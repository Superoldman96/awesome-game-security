Project Path: arc_gmh5225_tpm-mmio_xv7dfbux

Source Tree:

```txt
arc_gmh5225_tpm-mmio_xv7dfbux
├── LICENSE
├── README.md
├── tpm-mmio
│   ├── acpi.hpp
│   ├── crb.hpp
│   ├── defs.hpp
│   ├── main.cpp
│   ├── mmio.hpp
│   ├── ptp.hpp
│   ├── stdint.hpp
│   ├── tis.hpp
│   ├── tpm-mmio.vcxproj
│   ├── tpm-mmio.vcxproj.filters
│   ├── tpm-mmio.vcxproj.user
│   └── tpm.hpp
└── tpm-mmio.sln

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# WDK MMIO Implementation for TPM_ReadPublic

Many spoofing providers believe that hooking OS-provided resources like tbs.sys or tpm.sys is sufficient to hide the TPM's Endorsement Key (EK) and presence from anti-cheat systems. This proof of concept (POC) demonstrates how Memory-Mapped I/O (MMIO) can be used to directly query the TPM state and the EK from the chip itself, bypassing any OS hooks.

## Installation

- In CMD shell: ``shutdown /r /t 0 /o`` or Start button -> Power icon -> SHIFT key + Restart
- Navigate: Troubleshooting -> Advanced Settings -> Startup Settings -> Reboot 
- After reset choose F7 or 7 “Disable driver signature checks”
- Load driver using sc start/sc create.

## "Bypassing" or "Hooking" MMIO

Frankly, there is no way to "bypass" or "hook" MMIO. The only viable method to spoof a TPM's EK is through a hypervisor, which traps the guest TPM MMIO registers to redirect them to your own handler.

Creating a hypervisor today is very challenging, especially since anti-cheat systems are becoming increasingly sophisticated and have numerous tricks to fault your hypervisor and cause the guest PC to bugcheck.

## Detection Vectors of a Hypervisor

Even if you manage to create a fully undetected hypervisor and intercept/handle the MMIO TPM commands, you can still be detected.

The primary selling point of the TPM is its Remote Attestation capability, which can attest whether an EK is valid and whether the TPM device is genuine.

### How Remote Attestation Works:

1. Every TPM includes an Endorsement Key (EK) signed by a root EK, which belongs to the TPM vendor. It also includes an Attestation Key (AK). The client sends the TPM EK and AK to a server.
2. The server verifies the EK based on the TPM vendor's root CA certificate. The server generates a random secret and encrypts it, along with the AK, using the EK public key to create a challenge. The server then sends the challenge to the client.
3. The client decrypts the secret with the EK private key and checks the AK. The client then sends the secret back to the server.
4. The server confirms that the client has a genuine TPM.
   
[tpm-attestation](https://github.com/SyncUD/tpm-mmio/assets/109126667/36307325-f330-4e1a-bfe0-4d92acbad789) 
(Source: OpenPower TrustBoot).

## What Should You Do?

Wait for our spoofer (https://sync.top/) solution.

## Credits

Code restructured into WDK from EDK2 documentation and sourcecode: https://github.com/tianocore/edk2
Credits to the people @ e&f (mainly everdox & Zepta) for helping me out.


```

`tpm-mmio.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34723.18
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "tpm-mmio", "tpm-mmio\tpm-mmio.vcxproj", "{E0009D17-7436-43CE-BDE9-41CDFFB443DC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|ARM64.Build.0 = Debug|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|x64.ActiveCfg = Debug|x64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|x64.Build.0 = Debug|x64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Debug|x64.Deploy.0 = Debug|x64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|ARM64.ActiveCfg = Release|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|ARM64.Build.0 = Release|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|ARM64.Deploy.0 = Release|ARM64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|x64.ActiveCfg = Release|x64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|x64.Build.0 = Release|x64
		{E0009D17-7436-43CE-BDE9-41CDFFB443DC}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {16C5FBF9-744F-43F4-A6B1-358410F9EA3F}
	EndGlobalSection
EndGlobal

```

`tpm-mmio/acpi.hpp`:

```hpp
#pragma once

namespace acpi
{
	bool IsIntelCPU()
	{
		int cpuInfoRegisters[4];
		__cpuidex(cpuInfoRegisters, 0, 0);
		return cpuInfoRegisters[2] == 0x6c65746e;
	}

	bool GetTpm2PhysicalAddress(_Inout_ uintptr_t* tpmAddress)
	{		
		if (IsIntelCPU())
		{
			//
			// Hardcode TPM address for Intel CPU's
			//
			*tpmAddress = 0xfed40000;
			return true;
		}
		else
		{
			// AMD CPU's are left as an exercise for the reader.
			DbgError("AMD CPU's are not currently supported.\n");
			return false;
		}
	}
}
```

`tpm-mmio/crb.hpp`:

```hpp
#pragma once

class TpmCrb 
{
private:

    TpmPtp* ptpInterface = nullptr;

   //
   // Polls a 32-bit hardware register at the specified address, waiting for specified bits to be set and/or cleared within a timeout period.
   //
   // Parameters:
   // - registerAddress: Pointer to the hardware register to be polled.
   // - bitSet: Bitmask specifying the bits that must be set in the register.
   // - bitClear: Bitmask specifying the bits that must be clear in the register.
   // - timeOut: Maximum time in milliseconds to wait for the conditions to be met.
   //
   // Returns:
   // - STATUS_SUCCESS: The conditions were met within the timeout period.
   // - STATUS_TIMEOUT: The conditions were not met within the timeout period.
   //
   NTSTATUS CrbWaitRegisterBits(
        _In_ uint32_t* registerAddress,
        _In_ uint32_t  bitSet,
        _In_ uint32_t  bitClear,
        _In_ uint32_t  timeOut
    )
    {
        for (uint32_t waitTime = 0; waitTime < timeOut; waitTime += 30)
        {
            uint32_t registerRead = 0;
            if (mmio::Read((uintptr_t)registerAddress, sizeof(uint32_t), &registerRead))
            {
                if (((registerRead & bitSet) == bitSet) && ((registerRead & bitClear) == 0))
                {
                    return STATUS_SUCCESS;
                }
                KeStallExecutionProcessor(30);
            }
        }
        return STATUS_TIMEOUT;
    }

public:

    TpmCrb(TpmPtp* ptpInterface)
    {
        this->ptpInterface = ptpInterface;
    }

    //
    // Sends a command to the TPM CRB (Command Response Buffer) interface and retrieves the response.
    // This function is designed to interact with the TPM hardware via the CRB interface,
    // sending a command buffer and awaiting a response.
    //
    // Parameters:
    // - crbReg: Pointer to the CRB registers used to initiate commands and read responses.
    // - bufferIn: Pointer to the buffer containing the command data to be sent to the TPM.
    // - sizeIn: Size of the input buffer in bytes.
    // - bufferOut: Pointer to the buffer where the TPM's response will be stored.
    // - sizeOut: Pointer to a variable that on input specifies the maximum size of the output buffer,
    //            and on output reflects the actual size of the data written to the output buffer.
    //
    // Returns:
    // - STATUS_SUCCESS: The command was successfully sent and a response was received.
    // - STATUS_DEVICE_BUSY: The device is busy or in idle mode.
    // - STATUS_NOT_SUPPORTED: The command or TPM version aren't supported.
    // - STATUS_BUFFER_TOO_SMALL: The response is too small.
    //
    NTSTATUS CrbCommand(
        _In_ PTP_CRB_REGISTERS* crbReg,
        _In_reads_bytes_(sizeIn) const uint8_t* bufferIn,
        _In_ uint32_t sizeIn,
        _Inout_updates_bytes_(*sizeOut) uint8_t* bufferOut,
        _Inout_ uint32_t* sizeOut
    )
    {
        NTSTATUS status = STATUS_UNSUCCESSFUL;
        uint8_t retryCnt = 0;
        uint32_t bit = 0;

        while (true)
        {
            //
            // STEP 0:
            // if idleByPassState == 0, enforce Idle state before sending command
            //
            if (this->ptpInterface->idleByPassState == 0)
            {
                if (mmio::Read((uintptr_t)&crbReg->CrbControlStatus, sizeof(uint32_t), &bit))
                {
                    // Check if TPM is not idle
                    if ((bit & PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE) == 0)
                    {
                        status = this->CrbWaitRegisterBits(
                            &crbReg->CrbControlStatus,
                            PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE,
                            0,
                            PTP_TIMEOUT_C
                        );

                        if (NT_ERROR(status))
                        {
                            retryCnt++;
                            //
                            // Max retry count according to Spec TCG PC Client Device Driver Design Principles
                            //
                            if (retryCnt < RETRY_CNT_MAX)
                            {
                                bit = PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE;
                                (void)mmio::Write((uintptr_t)&crbReg->CrbControlRequest, sizeof(uint32_t), &bit);
                                continue;
                            }
                            else
                            {
                                //
                                // Try to goIdle to recover TPM
                                //
                                status = STATUS_DEVICE_BUSY;
                                goto GoIdle_Exit;
                            }
                        }
                    }
                }
            }

            //
            // STEP 1:
            // Ready is any time the TPM is ready to receive a command, following a write
            // of 1 by software to Request.cmdReady, as indicated by the Status field
            // being cleared to 0.
            //

            bit = PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY;
            (void)mmio::Write((uintptr_t)&crbReg->CrbControlRequest, sizeof(uint32_t), &bit);

            status = this->CrbWaitRegisterBits(
                &crbReg->CrbControlRequest,
                0,
                PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY,
                PTP_TIMEOUT_C
            );

            if (NT_ERROR(status))
            {
                retryCnt++;
                if (retryCnt < RETRY_CNT_MAX)
                {
                    bit = PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE;
                    (void)mmio::Write((uintptr_t)&crbReg->CrbControlRequest, sizeof(uint32_t), &bit);
                    continue;
                }
                else
                {
                    status = STATUS_DEVICE_BUSY;
                    goto GoIdle_Exit;
                }
            }

            status = this->CrbWaitRegisterBits(
                &crbReg->CrbControlStatus,
                0,
                PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE,
                PTP_TIMEOUT_C
            );

            if (NT_ERROR(status))
            {
                retryCnt++;
                if (retryCnt < RETRY_CNT_MAX)
                {
                    bit = PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE;
                    (void)mmio::Write((uintptr_t)&crbReg->CrbControlRequest, sizeof(uint32_t), &bit);
                    continue;
                }
                else
                {
                    status = STATUS_DEVICE_BUSY;
                    goto GoIdle_Exit;
                }
            }

            break;
        }

        //
        // STEP 2:
        // Command Reception occurs following a Ready state between the write of the
        // first byte of a command to the Command Buffer and the receipt of a write
        // of 1 to Start.
        //
        for (uint32_t i = 0; i < sizeIn; i++)
        {
            (void)mmio::Write((uintptr_t)&crbReg->CrbDataBuffer[i], sizeof(uint8_t), const_cast<uint8_t*>(&bufferIn[i]));
        }

        uint32_t highAddressPart = (uint32_t)((uintptr_t)crbReg->CrbDataBuffer >> 32);
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlCommandAddressHigh, sizeof(uint32_t), &highAddressPart);
        uint32_t crbDataBuffer = (uint32_t)(uintptr_t)crbReg->CrbDataBuffer;
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlCommandAddressLow, sizeof(uint32_t), &crbDataBuffer);
        uint32_t bufferSize = sizeof(crbReg->CrbDataBuffer);
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlCommandSize, sizeof(uint32_t), &bufferSize);

        (void)mmio::Write((uintptr_t)&crbReg->CrbControlResponseAddrss, sizeof(uint64_t), &crbDataBuffer);
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlResponseSize, sizeof(uint32_t), &bufferSize);

        //
        // STEP 3:
        // Command Execution occurs after receipt of a 1 to Start and the TPM
        // clearing Start to 0.
        //
        bit = PTP_CRB_CONTROL_START;
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlStart, sizeof(uint32_t), &bit);

        status = this->CrbWaitRegisterBits(
            &crbReg->CrbControlStart,
            0,
            PTP_CRB_CONTROL_START,
            PTP_TIMEOUT_MAX
        );

        if (NT_ERROR(status))
        {
            //
            // Command Completion check timeout. Cancel the currently executing command by writing TPM_CRB_CTRL_CANCEL,
            // Expect TPM_RC_CANCELLED or successfully completed response.
            //
            bit = PTP_CRB_CONTROL_CANCEL;
            (void)mmio::Write((uintptr_t)&crbReg->CrbControlCancel, sizeof(uint32_t), &bit);
            status = this->CrbWaitRegisterBits(
                &crbReg->CrbControlStart,
                0,
                PTP_CRB_CONTROL_START,
                PTP_TIMEOUT_B
            );

            bit = 0;
            (void)mmio::Write((uintptr_t)&crbReg->CrbControlCancel, sizeof(uint32_t), &bit);

            if (NT_ERROR(status))
            {
                //
                // Still in Command Execution state. Try to goIdle, the behavior is agnostic.
                //
                status = STATUS_DEVICE_BUSY;
                goto GoIdle_Exit;
            }
        }

        //
        // STEP 4:
        // Command Completion occurs after completion of a command (indicated by the
        // TPM clearing TPM_CRB_CTRL_Start_x to 0) and before a write of a 1 by the
        // software to Request.goIdle.
        //

        //
        // Get response data header
        //
        for (uint32_t i = 0; i < sizeof(TPM2_RESPONSE_HEADER); i++)
        {
            (void)mmio::Read((uintptr_t)&crbReg->CrbDataBuffer[i], sizeof(uint8_t), &bufferOut[i]);
        }

        //
        // Check the response data header (tag, parasize and returncode)
        //
        uint16_t data16 = 0;
        memcpy(&data16, bufferOut, sizeof(uint16_t));

        // TPM2 should not use this RSP_COMMAND
        if (_byteswap_ushort(data16) == TPM_ST_RSP_COMMAND)
        {
            DbgError("TPM_ST_RSP error: %x\n", TPM_ST_RSP_COMMAND);
            status = STATUS_NOT_SUPPORTED;
            goto GoIdle_Exit;
        }

        uint32_t data32 = 0;
        memcpy(&data32, (bufferOut + 2), sizeof(uint32_t));
        uint32_t tpmOutSize = _byteswap_ulong(data32);
        if (*sizeOut < tpmOutSize)
        {
            //
            // Command completed, but buffer is not enough
            //
            status = STATUS_BUFFER_TOO_SMALL;
            goto GoIdle_Exit;
        }

        *sizeOut = tpmOutSize;
        //
        // Continue reading the remaining data
        //
        for (uint32_t i = sizeof(TPM2_RESPONSE_HEADER); i < tpmOutSize; i++) {
            (void)mmio::Read((uintptr_t)&crbReg->CrbDataBuffer[i], sizeof(uint8_t), &bufferOut[i]);
        }


    GoIdle_Exit:

        //
        //  Return to Idle state by setting TPM_CRB_CTRL_STS_x.Status.goIdle to 1.
        //
        uint32_t bit32 = PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE;
        (void)mmio::Write((uintptr_t)&crbReg->CrbControlRequest, sizeof(uint32_t), &bit32);

        return status;
    }
};

```

`tpm-mmio/defs.hpp`:

```hpp

#pragma once

#define SYNC_EXTERN extern "C"

#define Dbg( X, ... ) DbgPrintEx(0, 0,"[sync] " X, __VA_ARGS__ )
#define DbgError( X, ... ) DbgPrintEx(0, 0, "ERROR: " X, __VA_ARGS__ )
#define KdBreak if (KD_DEBUGGER_ENABLED) __debugbreak();

#pragma pack(push, 1)


union PTP_CRB_INTERFACE_IDENTIFIER
{
	struct
	{
		uint32_t    InterfaceType : 4;
		uint32_t    InterfaceVersion : 4;
		uint32_t    CapLocality : 1;
		uint32_t    CapCRBIdleBypass : 1;
		uint32_t    Reserved1 : 1;
		uint32_t    CapDataXferSizeSupport : 2;
		uint32_t    CapFIFO : 1;
		uint32_t    CapCRB : 1;
		uint32_t    CapIFRes : 2;
		uint32_t    InterfaceSelector : 2;
		uint32_t    IntfSelLock : 1;
		uint32_t    Reserved2 : 4;
		uint32_t    Rid : 8;
	} Bits;
	uint32_t    Uint32;
};

union PTP_FIFO_INTERFACE_CAPABILITY
{
	struct
	{
		uint32_t    DataAvailIntSupport : 1;
		uint32_t    StsValidIntSupport : 1;
		uint32_t    LocalityChangeIntSupport : 1;
		uint32_t    InterruptLevelHigh : 1;
		uint32_t    InterruptLevelLow : 1;
		uint32_t    InterruptEdgeRising : 1;
		uint32_t    InterruptEdgeFalling : 1;
		uint32_t    CommandReadyIntSupport : 1;
		uint32_t    BurstCountStatic : 1;
		uint32_t    DataTransferSizeSupport : 2;
		uint32_t    Reserved : 17;
		uint32_t    InterfaceVersion : 3;
		uint32_t    Reserved2 : 1;
	} Bits;
	uint32_t    Uint32;
};

struct PTP_CRB_REGISTERS
{
	///
	/// Used to determine current state of Locality of the TPM.
	///
	uint32_t    LocalityState;                                     // 0
	uint8_t     Reserved1[4];                                      // 4
	///
	/// Used to gain control of the TPM by this Locality.
	///
	uint32_t    LocalityControl;                                   // 8
	///
	/// Used to determine whether Locality has been granted or Seized.
	///
	uint32_t    LocalityStatus;                                    // 0ch
	uint8_t     Reserved2[0x20];                                   // 10h
	///
	/// Used to identify the Interface types supported by the TPM.
	///
	uint32_t    interfaceId;                                       // 30h
	///
	/// Vendor ID
	///
	uint16_t    Vid;                                               // 34h
	///
	/// Device ID
	///
	uint16_t    Did;                                               // 36h
	///
	/// Optional Register used in low memory environments prior to CRB_DATA_BUFFER availability.
	///
	uint64_t    CrbControlExtension;                               // 38h
	///
	/// Register used to initiate transactions for the CRB interface.
	///
	uint32_t    CrbControlRequest;                                 // 40h
	///
	/// Register used by the TPM to provide status of the CRB interface.
	///
	uint32_t    CrbControlStatus;                                  // 44h
	///
	/// Register used by software to cancel command processing.
	///
	uint32_t    CrbControlCancel;                                  // 48h
	///
	/// Register used to indicate presence of command or response data in the CRB buffer.
	///
	uint32_t    CrbControlStart;                                   // 4Ch
	///
	/// Register used to configure and respond to interrupts.
	///
	uint32_t    CrbInterruptEnable;                                // 50h
	uint32_t    CrbInterruptStatus;                                // 54h
	///
	/// Size of the Command buffer.
	///
	uint32_t    CrbControlCommandSize;                             // 58h
	///
	/// Command buffer start address
	///
	uint32_t    CrbControlCommandAddressLow;                           // 5Ch
	uint32_t    CrbControlCommandAddressHigh;                          // 60h
	///
	/// Size of the Response buffer
	///
	uint32_t    CrbControlResponseSize;                            // 64h
	///
	/// Address of the start of the Response buffer
	///
	uint64_t    CrbControlResponseAddrss;                          // 68h
	uint8_t     Reserved4[0x10];                                   // 70h
	///
	/// Command/Response Data may be defined as large as 3968 (0xF80).
	///
	uint8_t     CrbDataBuffer[0xF80];                              // 80h
};

struct PTP_FIFO_REGISTERS
{
	///
	/// Used to gain ownership for this particular port.
	///
	uint8_t     Access;                                     // 0
	uint8_t     Reserved1[7];                               // 1
	///
	/// Controls interrupts.
	///
	uint32_t    IntEnable;                                  // 8
	///
	/// SIRQ vector to be used by the TPM.
	///
	uint8_t     IntVector;                                  // 0ch
	uint8_t     Reserved2[3];                               // 0dh
	///
	/// What caused interrupt.
	///
	uint32_t    IntSts;                                     // 10h
	///
	/// Shows which interrupts are supported by that particular TPM.
	///
	uint32_t    interfaceCapability;                        // 14h
	///
	/// Status Register. Provides status of the TPM.
	///
	uint8_t     Status;                                     // 18h
	///
	/// Number of consecutive writes that can be done to the TPM.
	///
	uint16_t    BurstCount;                                 // 19h
	///
	/// Additional Status Register.
	///
	uint8_t     StatusEx;                                   // 1Bh
	uint8_t     Reserved3[8];
	///
	/// Read or write FIFO, depending on transaction.
	///
	uint32_t    DataFifo;                                   // 24h
	uint8_t     Reserved4[8];                               // 28h
	///
	/// Used to identify the Interface types supported by the TPM.
	///
	uint32_t    interfaceId;                                // 30h
	uint8_t     Reserved5[0x4c];                            // 34h
	///
	/// Extended ReadFIFO or WriteFIFO, depending on the current bus cycle (read or write)
	///
	uint32_t    XDataFifo;                                  // 80h
	uint8_t     Reserved6[0xe7c];                           // 84h
	///
	/// Vendor ID
	///
	uint16_t    Vid;                                        // 0f00h
	///
	/// Device ID
	///
	uint16_t    Did;                                        // 0f02h
	///
	/// Revision ID
	///
	uint8_t     Rid;                                        // 0f04h
	uint8_t     Reserved[0xfb];                             // 0f05h
};

struct TIS_PC_REGISTERS
{
	///
	/// Used to gain ownership for this particular port.
	///
	uint8_t     Access;                                     // 0
	uint8_t     Reserved1[7];                               // 1
	///
	/// Controls interrupts.
	///
	uint32_t    IntEnable;                                  // 8
	///
	/// SIRQ vector to be used by the TPM.
	///
	uint8_t     IntVector;                                  // 0ch
	uint8_t     Reserved2[3];                               // 0dh
	///
	/// What caused interrupt.
	///
	uint32_t    IntSts;                                     // 10h
	///
	/// Shows which interrupts are supported by that particular TPM.
	///
	uint32_t    IntfCapability;                             // 14h
	///
	/// Status Register. Provides status of the TPM.
	///
	uint8_t     Status;                                     // 18h
	///
	/// Number of consecutive writes that can be done to the TPM.
	///
	uint16_t    BurstCount;                                 // 19h
	uint8_t     Reserved3[9];
	///
	/// Read or write FIFO, depending on transaction.
	///
	uint32_t    DataFifo;                                   // 24h
	uint8_t     Reserved4[0xed8];                           // 28h
	///
	/// Vendor ID
	///
	uint16_t    Vid;                                        // 0f00h
	///
	/// Device ID
	///
	uint16_t    Did;                                        // 0f02h
	///
	/// Revision ID
	///
	uint8_t     Rid;                                        // 0f04h
	uint8_t     Reserved[0x7b];                             // 0f05h
	///
	/// Alias to I/O legacy space.
	///
	uint32_t    LegacyAddress1;                             // 0f80h
	///
	/// Additional 8 bits for I/O legacy space extension.
	///
	uint32_t    LegacyAddress1Ex;                           // 0f84h
	///
	/// Alias to second I/O legacy space.
	///
	uint32_t    LegacyAddress2;                             // 0f88h
	///
	/// Additional 8 bits for second I/O legacy space extension.
	///
	uint32_t    LegacyAddress2Ex;                           // 0f8ch
	///
	/// Vendor-defined configuration registers.
	///
	uint8_t     VendorDefined[0x70];                        // 0f90h
};

enum PTP_INTERFACE_TYPE
{
	PtpInterfaceTis,
	PtpInterfaceFifo,
	PtpInterfaceCrb,
	PtpInterfaceNull,
};

#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_FIFO 0x0
#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_CRB 0x1
#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_TIS 0xF
#define PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_FIFO 0x0
#define PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_CRB 0x1
#define INTERFACE_CAPABILITY_INTERFACE_VERSION_PTP 0x3
#define PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE 0x00000002
#define PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE 0x00000002
#define PTP_TIMEOUT_C (200 * 1000) // 200ms
#define PTP_TIMEOUT_MAX (90000 * 1000) // 90s
#define RETRY_CNT_MAX 3
#define PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY 0x00000001
#define PTP_CRB_CONTROL_START 0x00000001
#define PTP_CRB_CONTROL_CANCEL 0x00000001
#define PTP_TIMEOUT_B (2000 * 1000) // 2s
#define TIS_PC_STS_READY 0x00000040
#define TIS_TIMEOUT_B (2000 * 1000) // 2s
#define TIS_TIMEOUT_D (750  * 1000) // 750ms
#define TIS_TIMEOUT_C (750  * 1000) // 750ms
#define TIS_PC_STS_EXPECT 0x00000008
#define TIS_PC_VALID 0x00000080
#define TIS_PC_STS_GO 0x00000020
#define TIS_TIMEOUT_MAX (90000 * 1000) // 90s
#define TIS_PC_STS_DATA 0x00000010
#define TIS_PC_STS_CANCEL 0x01000000

#define SHA1_DIGEST_SIZE  20
#define SHA1_BLOCK_SIZE   64

// Table 206 - Defines for SHA256 Hash Values
#define SHA256_DIGEST_SIZE  32
#define SHA256_BLOCK_SIZE   64

// Table 207 - Defines for SHA384 Hash Values
#define SHA384_DIGEST_SIZE  48
#define SHA384_BLOCK_SIZE   128

// Table 208 - Defines for SHA512 Hash Values
#define SHA512_DIGEST_SIZE  64
#define SHA512_BLOCK_SIZE   128

// Table 209 - Defines for SM3_256 Hash Values
#define SM3_256_DIGEST_SIZE  32
#define SM3_256_BLOCK_SIZE   64

// Table 210 - Defines for Architectural Limits Values
#define MAX_SESSION_NUMBER  3

// Annex B Implementation Definitions

// Table 211 - Defines for Logic Values
#define YES    1
#define NO     0
#define SET    1
#define CLEAR  0

// Table 215 - Defines for RSA Algorithm Constants
#define MAX_RSA_KEY_BITS   2048
#define MAX_RSA_KEY_BYTES  ((MAX_RSA_KEY_BITS + 7) / 8)

// Table 216 - Defines for ECC Algorithm Constants
#define MAX_ECC_KEY_BITS   256
#define MAX_ECC_KEY_BYTES  ((MAX_ECC_KEY_BITS + 7) / 8)

// Table 217 - Defines for AES Algorithm Constants
#define MAX_AES_KEY_BITS          128
#define MAX_AES_BLOCK_SIZE_BYTES  16
#define MAX_AES_KEY_BYTES         ((MAX_AES_KEY_BITS + 7) / 8)

// Table 218 - Defines for SM4 Algorithm Constants
#define MAX_SM4_KEY_BITS          128
#define MAX_SM4_BLOCK_SIZE_BYTES  16
#define MAX_SM4_KEY_BYTES         ((MAX_SM4_KEY_BITS + 7) / 8)

// Table 219 - Defines for Symmetric Algorithm Constants
#define MAX_SYM_KEY_BITS    MAX_AES_KEY_BITS
#define MAX_SYM_KEY_BYTES   MAX_AES_KEY_BYTES
#define MAX_SYM_BLOCK_SIZE  MAX_AES_BLOCK_SIZE_BYTES

// Table 220 - Defines for Implementation Values
typedef uint16_t BSIZE;
#define BUFFER_ALIGNMENT     4
#define IMPLEMENTATION_PCR   24
#define PLATFORM_PCR         24
#define DRTM_PCR             17
#define NUM_LOCALITIES       5
#define MAX_HANDLE_NUM       3
#define MAX_ACTIVE_SESSIONS  64
typedef uint16_t CONTEXT_SLOT;
typedef uint64_t CONTEXT_COUNTER;
#define MAX_LOADED_SESSIONS            3
#define MAX_SESSION_NUM                3
#define MAX_LOADED_OBJECTS             3
#define MIN_EVICT_OBJECTS              2
#define PCR_SELECT_MIN                 ((PLATFORM_PCR + 7) / 8)
#define PCR_SELECT_MAX                 ((IMPLEMENTATION_PCR + 7) / 8)
#define NUM_POLICY_PCR_GROUP           1
#define NUM_AUTHVALUE_PCR_GROUP        1
#define MAX_CONTEXT_SIZE               4000
#define MAX_DIGEST_BUFFER              1024
#define MAX_NV_INDEX_SIZE              1024
#define MAX_CAP_BUFFER                 1024
#define NV_MEMORY_SIZE                 16384
#define NUM_STATIC_PCR                 16
#define MAX_ALG_LIST_SIZE              64
#define TIMER_PRESCALE                 100000
#define PRIMARY_SEED_SIZE              32
#define CONTEXT_ENCRYPT_ALG            TPM_ALG_AES
#define CONTEXT_ENCRYPT_KEY_BITS       MAX_SYM_KEY_BITS
#define CONTEXT_ENCRYPT_KEY_BYTES      ((CONTEXT_ENCRYPT_KEY_BITS + 7) / 8)
#define CONTEXT_INTEGRITY_HASH_ALG     TPM_ALG_SHA256
#define CONTEXT_INTEGRITY_HASH_SIZE    SHA256_DIGEST_SIZE
#define PROOF_SIZE                     CONTEXT_INTEGRITY_HASH_SIZE
#define NV_CLOCK_UPDATE_INTERVAL       12
#define NUM_POLICY_PCR                 1
#define MAX_COMMAND_SIZE               4096
#define MAX_RESPONSE_SIZE              4096
#define ORDERLY_BITS                   8
#define MAX_ORDERLY_COUNT              ((1 << ORDERLY_BITS) - 1)
#define ALG_ID_FIRST                   TPM_ALG_FIRST
#define ALG_ID_LAST                    TPM_ALG_LAST
#define MAX_SYM_DATA                   128
#define MAX_RNG_ENTROPY_SIZE           64
#define RAM_INDEX_SPACE                512
#define RSA_DEFAULT_PUBLIC_EXPONENT    0x00010001
#define CRT_FORMAT_RSA                 YES
#define PRIVATE_VENDOR_SPECIFIC_BYTES  ((MAX_RSA_KEY_BYTES / 2) * ( 3 + CRT_FORMAT_RSA * 2))

// Capability related MAX_ value
#define MAX_CAP_DATA        (MAX_CAP_BUFFER - sizeof(TPM_CAP) - sizeof(uint32_t))
#define MAX_CAP_ALGS        (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY))
#define MAX_CAP_HANDLES     (MAX_CAP_DATA / sizeof(TPM_HANDLE))
#define MAX_CAP_CC          (MAX_CAP_DATA / sizeof(TPM_CC))
#define MAX_TPM_PROPERTIES  (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY))
#define MAX_PCR_PROPERTIES  (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT))
#define MAX_ECC_CURVES      (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE))

//
// Always set 5 here, because we want to support all hash algo in BIOS.
//
#define HASH_COUNT  5

// 5 Base Types

// Table 3 - Definition of Base Types
typedef uint8_t BYTE;

// Table 4 - Definition of Types for Documentation Clarity
//
// NOTE: Comment because it has same name as TPM1.2 (value is same, so not runtime issue)
//
// typedef uint32_t TPM_ALGORITHM_ID;
// typedef uint32_t TPM_MODIFIER_INDICATOR;
typedef uint32_t TPM_AUTHORIZATION_SIZE;
typedef uint32_t TPM_PARAMETER_SIZE;
typedef uint16_t TPM_KEY_SIZE;
typedef uint16_t TPM_KEY_BITS;
typedef uint32_t TPM_HANDLE;

// 6 Constants

// Table 6 - TPM_GENERATED Constants
typedef uint32_t TPM_GENERATED;
#define TPM_GENERATED_VALUE  (TPM_GENERATED)(0xff544347)

// Table 7 - TPM_ALG_ID Constants
typedef uint16_t TPM_ALG_ID;
//
// NOTE: Comment some algo which has same name as TPM1.2 (value is same, so not runtime issue)
//
#define TPM_ALG_ERROR  (TPM_ALG_ID)(0x0000)
#define TPM_ALG_FIRST  (TPM_ALG_ID)(0x0001)
#define TPM_ALG_RSA            (TPM_ALG_ID)(0x0001)
#define TPM_ALG_SHA            (TPM_ALG_ID)(0x0004)
#define TPM_ALG_SHA1  (TPM_ALG_ID)(0x0004)
#define TPM_ALG_HMAC           (TPM_ALG_ID)(0x0005)
#define TPM_ALG_AES  (TPM_ALG_ID)(0x0006)
#define TPM_ALG_MGF1           (TPM_ALG_ID)(0x0007)
#define TPM_ALG_KEYEDHASH  (TPM_ALG_ID)(0x0008)
#define TPM_ALG_XOR            (TPM_ALG_ID)(0x000A)
#define TPM_ALG_SHA256          (TPM_ALG_ID)(0x000B)
#define TPM_ALG_SHA384          (TPM_ALG_ID)(0x000C)
#define TPM_ALG_SHA512          (TPM_ALG_ID)(0x000D)
#define TPM_ALG_NULL            (TPM_ALG_ID)(0x0010)
#define TPM_ALG_SM3_256         (TPM_ALG_ID)(0x0012)
#define TPM_ALG_SM4             (TPM_ALG_ID)(0x0013)
#define TPM_ALG_RSASSA          (TPM_ALG_ID)(0x0014)
#define TPM_ALG_RSAES           (TPM_ALG_ID)(0x0015)
#define TPM_ALG_RSAPSS          (TPM_ALG_ID)(0x0016)
#define TPM_ALG_OAEP            (TPM_ALG_ID)(0x0017)
#define TPM_ALG_ECDSA           (TPM_ALG_ID)(0x0018)
#define TPM_ALG_ECDH            (TPM_ALG_ID)(0x0019)
#define TPM_ALG_ECDAA           (TPM_ALG_ID)(0x001A)
#define TPM_ALG_SM2             (TPM_ALG_ID)(0x001B)
#define TPM_ALG_ECSCHNORR       (TPM_ALG_ID)(0x001C)
#define TPM_ALG_ECMQV           (TPM_ALG_ID)(0x001D)
#define TPM_ALG_KDF1_SP800_56a  (TPM_ALG_ID)(0x0020)
#define TPM_ALG_KDF2            (TPM_ALG_ID)(0x0021)
#define TPM_ALG_KDF1_SP800_108  (TPM_ALG_ID)(0x0022)
#define TPM_ALG_ECC             (TPM_ALG_ID)(0x0023)
#define TPM_ALG_SYMCIPHER       (TPM_ALG_ID)(0x0025)
#define TPM_ALG_CTR             (TPM_ALG_ID)(0x0040)
#define TPM_ALG_OFB             (TPM_ALG_ID)(0x0041)
#define TPM_ALG_CBC             (TPM_ALG_ID)(0x0042)
#define TPM_ALG_CFB             (TPM_ALG_ID)(0x0043)
#define TPM_ALG_ECB             (TPM_ALG_ID)(0x0044)
#define TPM_ALG_LAST            (TPM_ALG_ID)(0x0044)

// Table 8 - TPM_ECC_CURVE Constants
typedef uint16_t TPM_ECC_CURVE;
#define TPM_ECC_NONE       (TPM_ECC_CURVE)(0x0000)
#define TPM_ECC_NIST_P192  (TPM_ECC_CURVE)(0x0001)
#define TPM_ECC_NIST_P224  (TPM_ECC_CURVE)(0x0002)
#define TPM_ECC_NIST_P256  (TPM_ECC_CURVE)(0x0003)
#define TPM_ECC_NIST_P384  (TPM_ECC_CURVE)(0x0004)
#define TPM_ECC_NIST_P521  (TPM_ECC_CURVE)(0x0005)
#define TPM_ECC_BN_P256    (TPM_ECC_CURVE)(0x0010)
#define TPM_ECC_BN_P638    (TPM_ECC_CURVE)(0x0011)
#define TPM_ECC_SM2_P256   (TPM_ECC_CURVE)(0x0020)

// Table 11 - TPM_CC Constants (Numeric Order)
typedef uint32_t TPM_CC;
#define TPM_CC_FIRST                       (TPM_CC)(0x0000011F)
#define TPM_CC_PP_FIRST                    (TPM_CC)(0x0000011F)
#define TPM_CC_NV_UndefineSpaceSpecial     (TPM_CC)(0x0000011F)
#define TPM_CC_EvictControl                (TPM_CC)(0x00000120)
#define TPM_CC_HierarchyControl            (TPM_CC)(0x00000121)
#define TPM_CC_NV_UndefineSpace            (TPM_CC)(0x00000122)
#define TPM_CC_ChangeEPS                   (TPM_CC)(0x00000124)
#define TPM_CC_ChangePPS                   (TPM_CC)(0x00000125)
#define TPM_CC_Clear                       (TPM_CC)(0x00000126)
#define TPM_CC_ClearControl                (TPM_CC)(0x00000127)
#define TPM_CC_ClockSet                    (TPM_CC)(0x00000128)
#define TPM_CC_HierarchyChangeAuth         (TPM_CC)(0x00000129)
#define TPM_CC_NV_DefineSpace              (TPM_CC)(0x0000012A)
#define TPM_CC_PCR_Allocate                (TPM_CC)(0x0000012B)
#define TPM_CC_PCR_SetAuthPolicy           (TPM_CC)(0x0000012C)
#define TPM_CC_PP_Commands                 (TPM_CC)(0x0000012D)
#define TPM_CC_SetPrimaryPolicy            (TPM_CC)(0x0000012E)
#define TPM_CC_FieldUpgradeStart           (TPM_CC)(0x0000012F)
#define TPM_CC_ClockRateAdjust             (TPM_CC)(0x00000130)
#define TPM_CC_CreatePrimary               (TPM_CC)(0x00000131)
#define TPM_CC_NV_GlobalWriteLock          (TPM_CC)(0x00000132)
#define TPM_CC_PP_LAST                     (TPM_CC)(0x00000132)
#define TPM_CC_GetCommandAuditDigest       (TPM_CC)(0x00000133)
#define TPM_CC_NV_Increment                (TPM_CC)(0x00000134)
#define TPM_CC_NV_SetBits                  (TPM_CC)(0x00000135)
#define TPM_CC_NV_Extend                   (TPM_CC)(0x00000136)
#define TPM_CC_NV_Write                    (TPM_CC)(0x00000137)
#define TPM_CC_NV_WriteLock                (TPM_CC)(0x00000138)
#define TPM_CC_DictionaryAttackLockReset   (TPM_CC)(0x00000139)
#define TPM_CC_DictionaryAttackParameters  (TPM_CC)(0x0000013A)
#define TPM_CC_NV_ChangeAuth               (TPM_CC)(0x0000013B)
#define TPM_CC_PCR_Event                   (TPM_CC)(0x0000013C)
#define TPM_CC_PCR_Reset                   (TPM_CC)(0x0000013D)
#define TPM_CC_SequenceComplete            (TPM_CC)(0x0000013E)
#define TPM_CC_SetAlgorithmSet             (TPM_CC)(0x0000013F)
#define TPM_CC_SetCommandCodeAuditStatus   (TPM_CC)(0x00000140)
#define TPM_CC_FieldUpgradeData            (TPM_CC)(0x00000141)
#define TPM_CC_IncrementalSelfTest         (TPM_CC)(0x00000142)
#define TPM_CC_SelfTest                    (TPM_CC)(0x00000143)
#define TPM_CC_Startup                     (TPM_CC)(0x00000144)
#define TPM_CC_Shutdown                    (TPM_CC)(0x00000145)
#define TPM_CC_StirRandom                  (TPM_CC)(0x00000146)
#define TPM_CC_ActivateCredential          (TPM_CC)(0x00000147)
#define TPM_CC_Certify                     (TPM_CC)(0x00000148)
#define TPM_CC_PolicyNV                    (TPM_CC)(0x00000149)
#define TPM_CC_CertifyCreation             (TPM_CC)(0x0000014A)
#define TPM_CC_Duplicate                   (TPM_CC)(0x0000014B)
#define TPM_CC_GetTime                     (TPM_CC)(0x0000014C)
#define TPM_CC_GetSessionAuditDigest       (TPM_CC)(0x0000014D)
#define TPM_CC_NV_Read                     (TPM_CC)(0x0000014E)
#define TPM_CC_NV_ReadLock                 (TPM_CC)(0x0000014F)
#define TPM_CC_ObjectChangeAuth            (TPM_CC)(0x00000150)
#define TPM_CC_PolicySecret                (TPM_CC)(0x00000151)
#define TPM_CC_Rewrap                      (TPM_CC)(0x00000152)
#define TPM_CC_Create                      (TPM_CC)(0x00000153)
#define TPM_CC_ECDH_ZGen                   (TPM_CC)(0x00000154)
#define TPM_CC_HMAC                        (TPM_CC)(0x00000155)
#define TPM_CC_Import                      (TPM_CC)(0x00000156)
#define TPM_CC_Load                        (TPM_CC)(0x00000157)
#define TPM_CC_Quote                       (TPM_CC)(0x00000158)
#define TPM_CC_RSA_Decrypt                 (TPM_CC)(0x00000159)
#define TPM_CC_HMAC_Start                  (TPM_CC)(0x0000015B)
#define TPM_CC_SequenceUpdate              (TPM_CC)(0x0000015C)
#define TPM_CC_Sign                        (TPM_CC)(0x0000015D)
#define TPM_CC_Unseal                      (TPM_CC)(0x0000015E)
#define TPM_CC_PolicySigned                (TPM_CC)(0x00000160)
#define TPM_CC_ContextLoad                 (TPM_CC)(0x00000161)
#define TPM_CC_ContextSave                 (TPM_CC)(0x00000162)
#define TPM_CC_ECDH_KeyGen                 (TPM_CC)(0x00000163)
#define TPM_CC_EncryptDecrypt              (TPM_CC)(0x00000164)
#define TPM_CC_FlushContext                (TPM_CC)(0x00000165)
#define TPM_CC_LoadExternal                (TPM_CC)(0x00000167)
#define TPM_CC_MakeCredential              (TPM_CC)(0x00000168)
#define TPM_CC_NV_ReadPublic               (TPM_CC)(0x00000169)
#define TPM_CC_PolicyAuthorize             (TPM_CC)(0x0000016A)
#define TPM_CC_PolicyAuthValue             (TPM_CC)(0x0000016B)
#define TPM_CC_PolicyCommandCode           (TPM_CC)(0x0000016C)
#define TPM_CC_PolicyCounterTimer          (TPM_CC)(0x0000016D)
#define TPM_CC_PolicyCpHash                (TPM_CC)(0x0000016E)
#define TPM_CC_PolicyLocality              (TPM_CC)(0x0000016F)
#define TPM_CC_PolicyNameHash              (TPM_CC)(0x00000170)
#define TPM_CC_PolicyOR                    (TPM_CC)(0x00000171)
#define TPM_CC_PolicyTicket                (TPM_CC)(0x00000172)
#define TPM_CC_ReadPublic                  (TPM_CC)(0x00000173)
#define TPM_CC_RSA_Encrypt                 (TPM_CC)(0x00000174)
#define TPM_CC_StartAuthSession            (TPM_CC)(0x00000176)
#define TPM_CC_VerifySignature             (TPM_CC)(0x00000177)
#define TPM_CC_ECC_Parameters              (TPM_CC)(0x00000178)
#define TPM_CC_FirmwareRead                (TPM_CC)(0x00000179)
#define TPM_CC_GetCapability               (TPM_CC)(0x0000017A)
#define TPM_CC_GetRandom                   (TPM_CC)(0x0000017B)
#define TPM_CC_GetTestResult               (TPM_CC)(0x0000017C)
#define TPM_CC_Hash                        (TPM_CC)(0x0000017D)
#define TPM_CC_PCR_Read                    (TPM_CC)(0x0000017E)
#define TPM_CC_PolicyPCR                   (TPM_CC)(0x0000017F)
#define TPM_CC_PolicyRestart               (TPM_CC)(0x00000180)
#define TPM_CC_ReadClock                   (TPM_CC)(0x00000181)
#define TPM_CC_PCR_Extend                  (TPM_CC)(0x00000182)
#define TPM_CC_PCR_SetAuthValue            (TPM_CC)(0x00000183)
#define TPM_CC_NV_Certify                  (TPM_CC)(0x00000184)
#define TPM_CC_EventSequenceComplete       (TPM_CC)(0x00000185)
#define TPM_CC_HashSequenceStart           (TPM_CC)(0x00000186)
#define TPM_CC_PolicyPhysicalPresence      (TPM_CC)(0x00000187)
#define TPM_CC_PolicyDuplicationSelect     (TPM_CC)(0x00000188)
#define TPM_CC_PolicyGetDigest             (TPM_CC)(0x00000189)
#define TPM_CC_TestParms                   (TPM_CC)(0x0000018A)
#define TPM_CC_Commit                      (TPM_CC)(0x0000018B)
#define TPM_CC_PolicyPassword              (TPM_CC)(0x0000018C)
#define TPM_CC_ZGen_2Phase                 (TPM_CC)(0x0000018D)
#define TPM_CC_EC_Ephemeral                (TPM_CC)(0x0000018E)
#define TPM_CC_LAST                        (TPM_CC)(0x0000018E)

// Table 15 - TPM_RC Constants (Actions)
typedef uint32_t TPM_RC;
#define TPM_RC_SUCCESS            (TPM_RC)(0x000)
#define TPM_RC_BAD_TAG            (TPM_RC)(0x030)
#define RC_VER1                   (TPM_RC)(0x100)
#define TPM_RC_INITIALIZE         (TPM_RC)(RC_VER1 + 0x000)
#define TPM_RC_FAILURE            (TPM_RC)(RC_VER1 + 0x001)
#define TPM_RC_SEQUENCE           (TPM_RC)(RC_VER1 + 0x003)
#define TPM_RC_PRIVATE            (TPM_RC)(RC_VER1 + 0x00B)
#define TPM_RC_HMAC               (TPM_RC)(RC_VER1 + 0x019)
#define TPM_RC_DISABLED           (TPM_RC)(RC_VER1 + 0x020)
#define TPM_RC_EXCLUSIVE          (TPM_RC)(RC_VER1 + 0x021)
#define TPM_RC_AUTH_TYPE          (TPM_RC)(RC_VER1 + 0x024)
#define TPM_RC_AUTH_MISSING       (TPM_RC)(RC_VER1 + 0x025)
#define TPM_RC_POLICY             (TPM_RC)(RC_VER1 + 0x026)
#define TPM_RC_PCR                (TPM_RC)(RC_VER1 + 0x027)
#define TPM_RC_PCR_CHANGED        (TPM_RC)(RC_VER1 + 0x028)
#define TPM_RC_UPGRADE            (TPM_RC)(RC_VER1 + 0x02D)
#define TPM_RC_TOO_MANY_CONTEXTS  (TPM_RC)(RC_VER1 + 0x02E)
#define TPM_RC_AUTH_UNAVAILABLE   (TPM_RC)(RC_VER1 + 0x02F)
#define TPM_RC_REBOOT             (TPM_RC)(RC_VER1 + 0x030)
#define TPM_RC_UNBALANCED         (TPM_RC)(RC_VER1 + 0x031)
#define TPM_RC_COMMAND_SIZE       (TPM_RC)(RC_VER1 + 0x042)
#define TPM_RC_COMMAND_CODE       (TPM_RC)(RC_VER1 + 0x043)
#define TPM_RC_AUTHSIZE           (TPM_RC)(RC_VER1 + 0x044)
#define TPM_RC_AUTH_CONTEXT       (TPM_RC)(RC_VER1 + 0x045)
#define TPM_RC_NV_RANGE           (TPM_RC)(RC_VER1 + 0x046)
#define TPM_RC_NV_SIZE            (TPM_RC)(RC_VER1 + 0x047)
#define TPM_RC_NV_LOCKED          (TPM_RC)(RC_VER1 + 0x048)
#define TPM_RC_NV_AUTHORIZATION   (TPM_RC)(RC_VER1 + 0x049)
#define TPM_RC_NV_UNINITIALIZED   (TPM_RC)(RC_VER1 + 0x04A)
#define TPM_RC_NV_SPACE           (TPM_RC)(RC_VER1 + 0x04B)
#define TPM_RC_NV_DEFINED         (TPM_RC)(RC_VER1 + 0x04C)
#define TPM_RC_BAD_CONTEXT        (TPM_RC)(RC_VER1 + 0x050)
#define TPM_RC_CPHASH             (TPM_RC)(RC_VER1 + 0x051)
#define TPM_RC_PARENT             (TPM_RC)(RC_VER1 + 0x052)
#define TPM_RC_NEEDS_TEST         (TPM_RC)(RC_VER1 + 0x053)
#define TPM_RC_NO_RESULT          (TPM_RC)(RC_VER1 + 0x054)
#define TPM_RC_SENSITIVE          (TPM_RC)(RC_VER1 + 0x055)
#define RC_MAX_FM0                (TPM_RC)(RC_VER1 + 0x07F)
#define RC_FMT1                   (TPM_RC)(0x080)
#define TPM_RC_ASYMMETRIC         (TPM_RC)(RC_FMT1 + 0x001)
#define TPM_RC_ATTRIBUTES         (TPM_RC)(RC_FMT1 + 0x002)
#define TPM_RC_HASH               (TPM_RC)(RC_FMT1 + 0x003)
#define TPM_RC_VALUE              (TPM_RC)(RC_FMT1 + 0x004)
#define TPM_RC_HIERARCHY          (TPM_RC)(RC_FMT1 + 0x005)
#define TPM_RC_KEY_SIZE           (TPM_RC)(RC_FMT1 + 0x007)
#define TPM_RC_MGF                (TPM_RC)(RC_FMT1 + 0x008)
#define TPM_RC_MODE               (TPM_RC)(RC_FMT1 + 0x009)
#define TPM_RC_TYPE               (TPM_RC)(RC_FMT1 + 0x00A)
#define TPM_RC_HANDLE             (TPM_RC)(RC_FMT1 + 0x00B)
#define TPM_RC_KDF                (TPM_RC)(RC_FMT1 + 0x00C)
#define TPM_RC_RANGE              (TPM_RC)(RC_FMT1 + 0x00D)
#define TPM_RC_AUTH_FAIL          (TPM_RC)(RC_FMT1 + 0x00E)
#define TPM_RC_NONCE              (TPM_RC)(RC_FMT1 + 0x00F)
#define TPM_RC_PP                 (TPM_RC)(RC_FMT1 + 0x010)
#define TPM_RC_SCHEME             (TPM_RC)(RC_FMT1 + 0x012)
#define TPM_RC_SIZE               (TPM_RC)(RC_FMT1 + 0x015)
#define TPM_RC_SYMMETRIC          (TPM_RC)(RC_FMT1 + 0x016)
#define TPM_RC_TAG                (TPM_RC)(RC_FMT1 + 0x017)
#define TPM_RC_SELECTOR           (TPM_RC)(RC_FMT1 + 0x018)
#define TPM_RC_INSUFFICIENT       (TPM_RC)(RC_FMT1 + 0x01A)
#define TPM_RC_SIGNATURE          (TPM_RC)(RC_FMT1 + 0x01B)
#define TPM_RC_KEY                (TPM_RC)(RC_FMT1 + 0x01C)
#define TPM_RC_POLICY_FAIL        (TPM_RC)(RC_FMT1 + 0x01D)
#define TPM_RC_INTEGRITY          (TPM_RC)(RC_FMT1 + 0x01F)
#define TPM_RC_TICKET             (TPM_RC)(RC_FMT1 + 0x020)
#define TPM_RC_RESERVED_BITS      (TPM_RC)(RC_FMT1 + 0x021)
#define TPM_RC_BAD_AUTH           (TPM_RC)(RC_FMT1 + 0x022)
#define TPM_RC_EXPIRED            (TPM_RC)(RC_FMT1 + 0x023)
#define TPM_RC_POLICY_CC          (TPM_RC)(RC_FMT1 + 0x024 )
#define TPM_RC_BINDING            (TPM_RC)(RC_FMT1 + 0x025)
#define TPM_RC_CURVE              (TPM_RC)(RC_FMT1 + 0x026)
#define TPM_RC_ECC_POINT          (TPM_RC)(RC_FMT1 + 0x027)
#define RC_WARN                   (TPM_RC)(0x900)
#define TPM_RC_CONTEXT_GAP        (TPM_RC)(RC_WARN + 0x001)
#define TPM_RC_OBJECT_MEMORY      (TPM_RC)(RC_WARN + 0x002)
#define TPM_RC_SESSION_MEMORY     (TPM_RC)(RC_WARN + 0x003)
#define TPM_RC_MEMORY             (TPM_RC)(RC_WARN + 0x004)
#define TPM_RC_SESSION_HANDLES    (TPM_RC)(RC_WARN + 0x005)
#define TPM_RC_OBJECT_HANDLES     (TPM_RC)(RC_WARN + 0x006)
#define TPM_RC_LOCALITY           (TPM_RC)(RC_WARN + 0x007)
#define TPM_RC_YIELDED            (TPM_RC)(RC_WARN + 0x008)
#define TPM_RC_CANCELED           (TPM_RC)(RC_WARN + 0x009)
#define TPM_RC_TESTING            (TPM_RC)(RC_WARN + 0x00A)
#define TPM_RC_REFERENCE_H0       (TPM_RC)(RC_WARN + 0x010)
#define TPM_RC_REFERENCE_H1       (TPM_RC)(RC_WARN + 0x011)
#define TPM_RC_REFERENCE_H2       (TPM_RC)(RC_WARN + 0x012)
#define TPM_RC_REFERENCE_H3       (TPM_RC)(RC_WARN + 0x013)
#define TPM_RC_REFERENCE_H4       (TPM_RC)(RC_WARN + 0x014)
#define TPM_RC_REFERENCE_H5       (TPM_RC)(RC_WARN + 0x015)
#define TPM_RC_REFERENCE_H6       (TPM_RC)(RC_WARN + 0x016)
#define TPM_RC_REFERENCE_S0       (TPM_RC)(RC_WARN + 0x018)
#define TPM_RC_REFERENCE_S1       (TPM_RC)(RC_WARN + 0x019)
#define TPM_RC_REFERENCE_S2       (TPM_RC)(RC_WARN + 0x01A)
#define TPM_RC_REFERENCE_S3       (TPM_RC)(RC_WARN + 0x01B)
#define TPM_RC_REFERENCE_S4       (TPM_RC)(RC_WARN + 0x01C)
#define TPM_RC_REFERENCE_S5       (TPM_RC)(RC_WARN + 0x01D)
#define TPM_RC_REFERENCE_S6       (TPM_RC)(RC_WARN + 0x01E)
#define TPM_RC_NV_RATE            (TPM_RC)(RC_WARN + 0x020)
#define TPM_RC_LOCKOUT            (TPM_RC)(RC_WARN + 0x021)
#define TPM_RC_RETRY              (TPM_RC)(RC_WARN + 0x022)
#define TPM_RC_NV_UNAVAILABLE     (TPM_RC)(RC_WARN + 0x023)
#define TPM_RC_NOT_USED           (TPM_RC)(RC_WARN + 0x7F)
#define TPM_RC_H                  (TPM_RC)(0x000)
#define TPM_RC_P                  (TPM_RC)(0x040)
#define TPM_RC_S                  (TPM_RC)(0x800)
#define TPM_RC_1                  (TPM_RC)(0x100)
#define TPM_RC_2                  (TPM_RC)(0x200)
#define TPM_RC_3                  (TPM_RC)(0x300)
#define TPM_RC_4                  (TPM_RC)(0x400)
#define TPM_RC_5                  (TPM_RC)(0x500)
#define TPM_RC_6                  (TPM_RC)(0x600)
#define TPM_RC_7                  (TPM_RC)(0x700)
#define TPM_RC_8                  (TPM_RC)(0x800)
#define TPM_RC_9                  (TPM_RC)(0x900)
#define TPM_RC_A                  (TPM_RC)(0xA00)
#define TPM_RC_B                  (TPM_RC)(0xB00)
#define TPM_RC_C                  (TPM_RC)(0xC00)
#define TPM_RC_D                  (TPM_RC)(0xD00)
#define TPM_RC_E                  (TPM_RC)(0xE00)
#define TPM_RC_F                  (TPM_RC)(0xF00)
#define TPM_RC_N_MASK             (TPM_RC)(0xF00)

// Table 16 - TPM_CLOCK_ADJUST Constants
typedef INT8 TPM_CLOCK_ADJUST;
#define TPM_CLOCK_COARSE_SLOWER  (TPM_CLOCK_ADJUST)(-3)
#define TPM_CLOCK_MEDIUM_SLOWER  (TPM_CLOCK_ADJUST)(-2)
#define TPM_CLOCK_FINE_SLOWER    (TPM_CLOCK_ADJUST)(-1)
#define TPM_CLOCK_NO_CHANGE      (TPM_CLOCK_ADJUST)(0)
#define TPM_CLOCK_FINE_FASTER    (TPM_CLOCK_ADJUST)(1)
#define TPM_CLOCK_MEDIUM_FASTER  (TPM_CLOCK_ADJUST)(2)
#define TPM_CLOCK_COARSE_FASTER  (TPM_CLOCK_ADJUST)(3)

// Table 17 - TPM_EO Constants
typedef uint16_t TPM_EO;
#define TPM_EO_EQ           (TPM_EO)(0x0000)
#define TPM_EO_NEQ          (TPM_EO)(0x0001)
#define TPM_EO_SIGNED_GT    (TPM_EO)(0x0002)
#define TPM_EO_UNSIGNED_GT  (TPM_EO)(0x0003)
#define TPM_EO_SIGNED_LT    (TPM_EO)(0x0004)
#define TPM_EO_UNSIGNED_LT  (TPM_EO)(0x0005)
#define TPM_EO_SIGNED_GE    (TPM_EO)(0x0006)
#define TPM_EO_UNSIGNED_GE  (TPM_EO)(0x0007)
#define TPM_EO_SIGNED_LE    (TPM_EO)(0x0008)
#define TPM_EO_UNSIGNED_LE  (TPM_EO)(0x0009)
#define TPM_EO_BITSET       (TPM_EO)(0x000A)
#define TPM_EO_BITCLEAR     (TPM_EO)(0x000B)

// Table 18 - TPM_ST Constants
typedef uint16_t TPM_ST;
#define TPM_ST_RSP_COMMAND           (TPM_ST)(0x00C4)
#define TPM_ST_NULL                  (TPM_ST)(0X8000)
#define TPM_ST_NO_SESSIONS           (TPM_ST)(0x8001)
#define TPM_ST_SESSIONS              (TPM_ST)(0x8002)
#define TPM_ST_ATTEST_NV             (TPM_ST)(0x8014)
#define TPM_ST_ATTEST_COMMAND_AUDIT  (TPM_ST)(0x8015)
#define TPM_ST_ATTEST_SESSION_AUDIT  (TPM_ST)(0x8016)
#define TPM_ST_ATTEST_CERTIFY        (TPM_ST)(0x8017)
#define TPM_ST_ATTEST_QUOTE          (TPM_ST)(0x8018)
#define TPM_ST_ATTEST_TIME           (TPM_ST)(0x8019)
#define TPM_ST_ATTEST_CREATION       (TPM_ST)(0x801A)
#define TPM_ST_CREATION              (TPM_ST)(0x8021)
#define TPM_ST_VERIFIED              (TPM_ST)(0x8022)
#define TPM_ST_AUTH_SECRET           (TPM_ST)(0x8023)
#define TPM_ST_HASHCHECK             (TPM_ST)(0x8024)
#define TPM_ST_AUTH_SIGNED           (TPM_ST)(0x8025)
#define TPM_ST_FU_MANIFEST           (TPM_ST)(0x8029)

// Table 19 - TPM_SU Constants
typedef uint16_t TPM_SU;
#define TPM_SU_CLEAR  (TPM_SU)(0x0000)
#define TPM_SU_STATE  (TPM_SU)(0x0001)

// Table 20 - TPM_SE Constants
typedef uint8_t TPM_SE;
#define TPM_SE_HMAC    (TPM_SE)(0x00)
#define TPM_SE_POLICY  (TPM_SE)(0x01)
#define TPM_SE_TRIAL   (TPM_SE)(0x03)

// Table 21 - TPM_CAP Constants
typedef uint32_t TPM_CAP;
#define TPM_CAP_FIRST            (TPM_CAP)(0x00000000)
#define TPM_CAP_ALGS             (TPM_CAP)(0x00000000)
#define TPM_CAP_HANDLES          (TPM_CAP)(0x00000001)
#define TPM_CAP_COMMANDS         (TPM_CAP)(0x00000002)
#define TPM_CAP_PP_COMMANDS      (TPM_CAP)(0x00000003)
#define TPM_CAP_AUDIT_COMMANDS   (TPM_CAP)(0x00000004)
#define TPM_CAP_PCRS             (TPM_CAP)(0x00000005)
#define TPM_CAP_TPM_PROPERTIES   (TPM_CAP)(0x00000006)
#define TPM_CAP_PCR_PROPERTIES   (TPM_CAP)(0x00000007)
#define TPM_CAP_ECC_CURVES       (TPM_CAP)(0x00000008)
#define TPM_CAP_LAST             (TPM_CAP)(0x00000008)
#define TPM_CAP_VENDOR_PROPERTY  (TPM_CAP)(0x00000100)

// Table 22 - TPM_PT Constants
typedef uint32_t TPM_PT;
#define TPM_PT_NONE                 (TPM_PT)(0x00000000)
#define PT_GROUP                    (TPM_PT)(0x00000100)
#define PT_FIXED                    (TPM_PT)(PT_GROUP * 1)
#define TPM_PT_FAMILY_INDICATOR     (TPM_PT)(PT_FIXED + 0)
#define TPM_PT_LEVEL                (TPM_PT)(PT_FIXED + 1)
#define TPM_PT_REVISION             (TPM_PT)(PT_FIXED + 2)
#define TPM_PT_DAY_OF_YEAR          (TPM_PT)(PT_FIXED + 3)
#define TPM_PT_YEAR                 (TPM_PT)(PT_FIXED + 4)
#define TPM_PT_MANUFACTURER         (TPM_PT)(PT_FIXED + 5)
#define TPM_PT_VENDOR_STRING_1      (TPM_PT)(PT_FIXED + 6)
#define TPM_PT_VENDOR_STRING_2      (TPM_PT)(PT_FIXED + 7)
#define TPM_PT_VENDOR_STRING_3      (TPM_PT)(PT_FIXED + 8)
#define TPM_PT_VENDOR_STRING_4      (TPM_PT)(PT_FIXED + 9)
#define TPM_PT_VENDOR_TPM_TYPE      (TPM_PT)(PT_FIXED + 10)
#define TPM_PT_FIRMWARE_VERSION_1   (TPM_PT)(PT_FIXED + 11)
#define TPM_PT_FIRMWARE_VERSION_2   (TPM_PT)(PT_FIXED + 12)
#define TPM_PT_INPUT_BUFFER         (TPM_PT)(PT_FIXED + 13)
#define TPM_PT_HR_TRANSIENT_MIN     (TPM_PT)(PT_FIXED + 14)
#define TPM_PT_HR_PERSISTENT_MIN    (TPM_PT)(PT_FIXED + 15)
#define TPM_PT_HR_LOADED_MIN        (TPM_PT)(PT_FIXED + 16)
#define TPM_PT_ACTIVE_SESSIONS_MAX  (TPM_PT)(PT_FIXED + 17)
#define TPM_PT_PCR_COUNT            (TPM_PT)(PT_FIXED + 18)
#define TPM_PT_PCR_SELECT_MIN       (TPM_PT)(PT_FIXED + 19)
#define TPM_PT_CONTEXT_GAP_MAX      (TPM_PT)(PT_FIXED + 20)
#define TPM_PT_NV_COUNTERS_MAX      (TPM_PT)(PT_FIXED + 22)
#define TPM_PT_NV_INDEX_MAX         (TPM_PT)(PT_FIXED + 23)
#define TPM_PT_MEMORY               (TPM_PT)(PT_FIXED + 24)
#define TPM_PT_CLOCK_UPDATE         (TPM_PT)(PT_FIXED + 25)
#define TPM_PT_CONTEXT_HASH         (TPM_PT)(PT_FIXED + 26)
#define TPM_PT_CONTEXT_SYM          (TPM_PT)(PT_FIXED + 27)
#define TPM_PT_CONTEXT_SYM_SIZE     (TPM_PT)(PT_FIXED + 28)
#define TPM_PT_ORDERLY_COUNT        (TPM_PT)(PT_FIXED + 29)
#define TPM_PT_MAX_COMMAND_SIZE     (TPM_PT)(PT_FIXED + 30)
#define TPM_PT_MAX_RESPONSE_SIZE    (TPM_PT)(PT_FIXED + 31)
#define TPM_PT_MAX_DIGEST           (TPM_PT)(PT_FIXED + 32)
#define TPM_PT_MAX_OBJECT_CONTEXT   (TPM_PT)(PT_FIXED + 33)
#define TPM_PT_MAX_SESSION_CONTEXT  (TPM_PT)(PT_FIXED + 34)
#define TPM_PT_PS_FAMILY_INDICATOR  (TPM_PT)(PT_FIXED + 35)
#define TPM_PT_PS_LEVEL             (TPM_PT)(PT_FIXED + 36)
#define TPM_PT_PS_REVISION          (TPM_PT)(PT_FIXED + 37)
#define TPM_PT_PS_DAY_OF_YEAR       (TPM_PT)(PT_FIXED + 38)
#define TPM_PT_PS_YEAR              (TPM_PT)(PT_FIXED + 39)
#define TPM_PT_SPLIT_MAX            (TPM_PT)(PT_FIXED + 40)
#define TPM_PT_TOTAL_COMMANDS       (TPM_PT)(PT_FIXED + 41)
#define TPM_PT_LIBRARY_COMMANDS     (TPM_PT)(PT_FIXED + 42)
#define TPM_PT_VENDOR_COMMANDS      (TPM_PT)(PT_FIXED + 43)
#define PT_VAR                      (TPM_PT)(PT_GROUP * 2)
#define TPM_PT_PERMANENT            (TPM_PT)(PT_VAR + 0)
#define TPM_PT_STARTUP_CLEAR        (TPM_PT)(PT_VAR + 1)
#define TPM_PT_HR_NV_INDEX          (TPM_PT)(PT_VAR + 2)
#define TPM_PT_HR_LOADED            (TPM_PT)(PT_VAR + 3)
#define TPM_PT_HR_LOADED_AVAIL      (TPM_PT)(PT_VAR + 4)
#define TPM_PT_HR_ACTIVE            (TPM_PT)(PT_VAR + 5)
#define TPM_PT_HR_ACTIVE_AVAIL      (TPM_PT)(PT_VAR + 6)
#define TPM_PT_HR_TRANSIENT_AVAIL   (TPM_PT)(PT_VAR + 7)
#define TPM_PT_HR_PERSISTENT        (TPM_PT)(PT_VAR + 8)
#define TPM_PT_HR_PERSISTENT_AVAIL  (TPM_PT)(PT_VAR + 9)
#define TPM_PT_NV_COUNTERS          (TPM_PT)(PT_VAR + 10)
#define TPM_PT_NV_COUNTERS_AVAIL    (TPM_PT)(PT_VAR + 11)
#define TPM_PT_ALGORITHM_SET        (TPM_PT)(PT_VAR + 12)
#define TPM_PT_LOADED_CURVES        (TPM_PT)(PT_VAR + 13)
#define TPM_PT_LOCKOUT_COUNTER      (TPM_PT)(PT_VAR + 14)
#define TPM_PT_MAX_AUTH_FAIL        (TPM_PT)(PT_VAR + 15)
#define TPM_PT_LOCKOUT_INTERVAL     (TPM_PT)(PT_VAR + 16)
#define TPM_PT_LOCKOUT_RECOVERY     (TPM_PT)(PT_VAR + 17)
#define TPM_PT_NV_WRITE_RECOVERY    (TPM_PT)(PT_VAR + 18)
#define TPM_PT_AUDIT_COUNTER_0      (TPM_PT)(PT_VAR + 19)
#define TPM_PT_AUDIT_COUNTER_1      (TPM_PT)(PT_VAR + 20)

// Table 23 - TPM_PT_PCR Constants
typedef uint32_t TPM_PT_PCR;
#define TPM_PT_PCR_FIRST         (TPM_PT_PCR)(0x00000000)
#define TPM_PT_PCR_SAVE          (TPM_PT_PCR)(0x00000000)
#define TPM_PT_PCR_EXTEND_L0     (TPM_PT_PCR)(0x00000001)
#define TPM_PT_PCR_RESET_L0      (TPM_PT_PCR)(0x00000002)
#define TPM_PT_PCR_EXTEND_L1     (TPM_PT_PCR)(0x00000003)
#define TPM_PT_PCR_RESET_L1      (TPM_PT_PCR)(0x00000004)
#define TPM_PT_PCR_EXTEND_L2     (TPM_PT_PCR)(0x00000005)
#define TPM_PT_PCR_RESET_L2      (TPM_PT_PCR)(0x00000006)
#define TPM_PT_PCR_EXTEND_L3     (TPM_PT_PCR)(0x00000007)
#define TPM_PT_PCR_RESET_L3      (TPM_PT_PCR)(0x00000008)
#define TPM_PT_PCR_EXTEND_L4     (TPM_PT_PCR)(0x00000009)
#define TPM_PT_PCR_RESET_L4      (TPM_PT_PCR)(0x0000000A)
#define TPM_PT_PCR_NO_INCREMENT  (TPM_PT_PCR)(0x00000011)
#define TPM_PT_PCR_DRTM_RESET    (TPM_PT_PCR)(0x00000012)
#define TPM_PT_PCR_POLICY        (TPM_PT_PCR)(0x00000013)
#define TPM_PT_PCR_AUTH          (TPM_PT_PCR)(0x00000014)
#define TPM_PT_PCR_LAST          (TPM_PT_PCR)(0x00000014)

// Table 24 - TPM_PS Constants
typedef uint32_t TPM_PS;
#define TPM_PS_MAIN            (TPM_PS)(0x00000000)
#define TPM_PS_PC              (TPM_PS)(0x00000001)
#define TPM_PS_PDA             (TPM_PS)(0x00000002)
#define TPM_PS_CELL_PHONE      (TPM_PS)(0x00000003)
#define TPM_PS_SERVER          (TPM_PS)(0x00000004)
#define TPM_PS_PERIPHERAL      (TPM_PS)(0x00000005)
#define TPM_PS_TSS             (TPM_PS)(0x00000006)
#define TPM_PS_STORAGE         (TPM_PS)(0x00000007)
#define TPM_PS_AUTHENTICATION  (TPM_PS)(0x00000008)
#define TPM_PS_EMBEDDED        (TPM_PS)(0x00000009)
#define TPM_PS_HARDCOPY        (TPM_PS)(0x0000000A)
#define TPM_PS_INFRASTRUCTURE  (TPM_PS)(0x0000000B)
#define TPM_PS_VIRTUALIZATION  (TPM_PS)(0x0000000C)
#define TPM_PS_TNC             (TPM_PS)(0x0000000D)
#define TPM_PS_MULTI_TENANT    (TPM_PS)(0x0000000E)
#define TPM_PS_TC              (TPM_PS)(0x0000000F)

// 7 Handles

// Table 25 - Handles Types
//
// NOTE: Comment because it has same name as TPM1.2 (value is same, so not runtime issue)
//
// typedef uint32_t    TPM_HANDLE;

// Table 26 - TPM_HT Constants
typedef uint8_t TPM_HT;
#define TPM_HT_PCR             (TPM_HT)(0x00)
#define TPM_HT_NV_INDEX        (TPM_HT)(0x01)
#define TPM_HT_HMAC_SESSION    (TPM_HT)(0x02)
#define TPM_HT_LOADED_SESSION  (TPM_HT)(0x02)
#define TPM_HT_POLICY_SESSION  (TPM_HT)(0x03)
#define TPM_HT_ACTIVE_SESSION  (TPM_HT)(0x03)
#define TPM_HT_PERMANENT       (TPM_HT)(0x40)
#define TPM_HT_TRANSIENT       (TPM_HT)(0x80)
#define TPM_HT_PERSISTENT      (TPM_HT)(0x81)

// Table 27 - TPM_RH Constants
typedef uint32_t TPM_RH;
#define TPM_RH_FIRST        (TPM_RH)(0x40000000)
#define TPM_RH_SRK          (TPM_RH)(0x40000000)
#define TPM_RH_OWNER        (TPM_RH)(0x40000001)
#define TPM_RH_REVOKE       (TPM_RH)(0x40000002)
#define TPM_RH_TRANSPORT    (TPM_RH)(0x40000003)
#define TPM_RH_OPERATOR     (TPM_RH)(0x40000004)
#define TPM_RH_ADMIN        (TPM_RH)(0x40000005)
#define TPM_RH_EK           (TPM_RH)(0x40000006)
#define TPM_RH_NULL         (TPM_RH)(0x40000007)
#define TPM_RH_UNASSIGNED   (TPM_RH)(0x40000008)
#define TPM_RS_PW           (TPM_RH)(0x40000009)
#define TPM_RH_LOCKOUT      (TPM_RH)(0x4000000A)
#define TPM_RH_ENDORSEMENT  (TPM_RH)(0x4000000B)
#define TPM_RH_PLATFORM     (TPM_RH)(0x4000000C)
#define TPM_RH_PLATFORM_NV  (TPM_RH)(0x4000000D)
#define TPM_RH_AUTH_00      (TPM_RH)(0x40000010)
#define TPM_RH_AUTH_FF      (TPM_RH)(0x4000010F)
#define TPM_RH_LAST         (TPM_RH)(0x4000010F)

// Table 28 - TPM_HC Constants
typedef TPM_HANDLE TPM_HC;
#define HR_HANDLE_MASK        (TPM_HC)(0x00FFFFFF)
#define HR_RANGE_MASK         (TPM_HC)(0xFF000000)
#define HR_SHIFT              (TPM_HC)(24)
#define HR_PCR                (TPM_HC)((TPM_HC)TPM_HT_PCR << HR_SHIFT)
#define HR_HMAC_SESSION       (TPM_HC)((TPM_HC)TPM_HT_HMAC_SESSION << HR_SHIFT)
#define HR_POLICY_SESSION     (TPM_HC)((TPM_HC)TPM_HT_POLICY_SESSION << HR_SHIFT)
#define HR_TRANSIENT          (TPM_HC)((TPM_HC)TPM_HT_TRANSIENT << HR_SHIFT)
#define HR_PERSISTENT         (TPM_HC)((TPM_HC)TPM_HT_PERSISTENT << HR_SHIFT)
#define HR_NV_INDEX           (TPM_HC)((TPM_HC)TPM_HT_NV_INDEX << HR_SHIFT)
#define HR_PERMANENT          (TPM_HC)((TPM_HC)TPM_HT_PERMANENT << HR_SHIFT)
#define PCR_FIRST             (TPM_HC)(HR_PCR + 0)
#define PCR_LAST              (TPM_HC)(PCR_FIRST + IMPLEMENTATION_PCR - 1)
#define HMAC_SESSION_FIRST    (TPM_HC)(HR_HMAC_SESSION + 0)
#define HMAC_SESSION_LAST     (TPM_HC)(HMAC_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1)
#define LOADED_SESSION_FIRST  (TPM_HC)(HMAC_SESSION_FIRST)
#define LOADED_SESSION_LAST   (TPM_HC)(HMAC_SESSION_LAST)
#define POLICY_SESSION_FIRST  (TPM_HC)(HR_POLICY_SESSION + 0)
#define POLICY_SESSION_LAST   (TPM_HC)(POLICY_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1)
#define TRANSIENT_FIRST       (TPM_HC)(HR_TRANSIENT + 0)
#define ACTIVE_SESSION_FIRST  (TPM_HC)(POLICY_SESSION_FIRST)
#define ACTIVE_SESSION_LAST   (TPM_HC)(POLICY_SESSION_LAST)
#define TRANSIENT_LAST        (TPM_HC)(TRANSIENT_FIRST+MAX_LOADED_OBJECTS - 1)
#define PERSISTENT_FIRST      (TPM_HC)(HR_PERSISTENT + 0)
#define PERSISTENT_LAST       (TPM_HC)(PERSISTENT_FIRST + 0x00FFFFFF)
#define PLATFORM_PERSISTENT   (TPM_HC)(PERSISTENT_FIRST + 0x00800000)
#define NV_INDEX_FIRST        (TPM_HC)(HR_NV_INDEX + 0)
#define NV_INDEX_LAST         (TPM_HC)(NV_INDEX_FIRST + 0x00FFFFFF)
#define PERMANENT_FIRST       (TPM_HC)(TPM_RH_FIRST)
#define PERMANENT_LAST        (TPM_HC)(TPM_RH_LAST)

// 8 Attribute Structures

// Table 29 - TPMA_ALGORITHM Bits
typedef struct {
	uint32_t    asymmetric : 1;
	uint32_t    symmetric : 1;
	uint32_t    hash : 1;
	uint32_t    object : 1;
	uint32_t    reserved4_7 : 4;
	uint32_t    signing : 1;
	uint32_t    encrypting : 1;
	uint32_t    method : 1;
	uint32_t    reserved11_31 : 21;
} TPMA_ALGORITHM;

// Table 30 - TPMA_OBJECT Bits
typedef struct {
	uint32_t    reserved1 : 1;
	uint32_t    fixedTPM : 1;
	uint32_t    stClear : 1;
	uint32_t    reserved4 : 1;
	uint32_t    fixedParent : 1;
	uint32_t    sensitiveDataOrigin : 1;
	uint32_t    userWithAuth : 1;
	uint32_t    adminWithPolicy : 1;
	uint32_t    reserved8_9 : 2;
	uint32_t    noDA : 1;
	uint32_t    encryptedDuplication : 1;
	uint32_t    reserved12_15 : 4;
	uint32_t    restricted : 1;
	uint32_t    decrypt : 1;
	uint32_t    sign : 1;
	uint32_t    reserved19_31 : 13;
} TPMA_OBJECT;

// Table 31 - TPMA_SESSION Bits
typedef struct {
	uint8_t    continueSession : 1;
	uint8_t    auditExclusive : 1;
	uint8_t    auditReset : 1;
	uint8_t    reserved3_4 : 2;
	uint8_t    decrypt : 1;
	uint8_t    encrypt : 1;
	uint8_t    audit : 1;
} TPMA_SESSION;

// Table 32 - TPMA_LOCALITY Bits
//
// NOTE: Use low case here to resolve conflict
//
typedef struct {
	uint8_t    locZero : 1;
	uint8_t    locOne : 1;
	uint8_t    locTwo : 1;
	uint8_t    locThree : 1;
	uint8_t    locFour : 1;
	uint8_t    Extended : 3;
} TPMA_LOCALITY;

// Table 33 - TPMA_PERMANENT Bits
typedef struct {
	uint32_t    ownerAuthSet : 1;
	uint32_t    endorsementAuthSet : 1;
	uint32_t    lockoutAuthSet : 1;
	uint32_t    reserved3_7 : 5;
	uint32_t    disableClear : 1;
	uint32_t    inLockout : 1;
	uint32_t    tpmGeneratedEPS : 1;
	uint32_t    reserved11_31 : 21;
} TPMA_PERMANENT;

// Table 34 - TPMA_STARTUP_CLEAR Bits
typedef struct {
	uint32_t    phEnable : 1;
	uint32_t    shEnable : 1;
	uint32_t    ehEnable : 1;
	uint32_t    reserved3_30 : 28;
	uint32_t    orderly : 1;
} TPMA_STARTUP_CLEAR;

// Table 35 - TPMA_MEMORY Bits
typedef struct {
	uint32_t    sharedRAM : 1;
	uint32_t    sharedNV : 1;
	uint32_t    objectCopiedToRam : 1;
	uint32_t    reserved3_31 : 29;
} TPMA_MEMORY;

// Table 36 - TPMA_CC Bits
typedef struct {
	uint32_t    commandIndex : 16;
	uint32_t    reserved16_21 : 6;
	uint32_t    nv : 1;
	uint32_t    extensive : 1;
	uint32_t    flushed : 1;
	uint32_t    cHandles : 3;
	uint32_t    rHandle : 1;
	uint32_t    V : 1;
	uint32_t    Res : 2;
} TPMA_CC;

// 9 Interface Types

// Table 37 - TPMI_YES_NO Type
typedef BYTE TPMI_YES_NO;

// Table 38 - TPMI_DH_OBJECT Type
typedef TPM_HANDLE TPMI_DH_OBJECT;

// Table 39 - TPMI_DH_PERSISTENT Type
typedef TPM_HANDLE TPMI_DH_PERSISTENT;

// Table 40 - TPMI_DH_ENTITY Type
typedef TPM_HANDLE TPMI_DH_ENTITY;

// Table 41 - TPMI_DH_PCR Type
typedef TPM_HANDLE TPMI_DH_PCR;

// Table 42 - TPMI_SH_AUTH_SESSION Type
typedef TPM_HANDLE TPMI_SH_AUTH_SESSION;

// Table 43 - TPMI_SH_HMAC Type
typedef TPM_HANDLE TPMI_SH_HMAC;

// Table 44 - TPMI_SH_POLICY Type
typedef TPM_HANDLE TPMI_SH_POLICY;

// Table 45 - TPMI_DH_CONTEXT Type
typedef TPM_HANDLE TPMI_DH_CONTEXT;

// Table 46 - TPMI_RH_HIERARCHY Type
typedef TPM_HANDLE TPMI_RH_HIERARCHY;

// Table 47 - TPMI_RH_HIERARCHY_AUTH Type
typedef TPM_HANDLE TPMI_RH_HIERARCHY_AUTH;

// Table 48 - TPMI_RH_PLATFORM Type
typedef TPM_HANDLE TPMI_RH_PLATFORM;

// Table 49 - TPMI_RH_OWNER Type
typedef TPM_HANDLE TPMI_RH_OWNER;

// Table 50 - TPMI_RH_ENDORSEMENT Type
typedef TPM_HANDLE TPMI_RH_ENDORSEMENT;

// Table 51 - TPMI_RH_PROVISION Type
typedef TPM_HANDLE TPMI_RH_PROVISION;

// Table 52 - TPMI_RH_CLEAR Type
typedef TPM_HANDLE TPMI_RH_CLEAR;

// Table 53 - TPMI_RH_NV_AUTH Type
typedef TPM_HANDLE TPMI_RH_NV_AUTH;

// Table 54 - TPMI_RH_LOCKOUT Type
typedef TPM_HANDLE TPMI_RH_LOCKOUT;

// Table 55 - TPMI_RH_NV_INDEX Type
typedef TPM_HANDLE TPMI_RH_NV_INDEX;

// Table 56 - TPMI_ALG_HASH Type
typedef TPM_ALG_ID TPMI_ALG_HASH;

// Table 57 - TPMI_ALG_ASYM Type
typedef TPM_ALG_ID TPMI_ALG_ASYM;

// Table 58 - TPMI_ALG_SYM Type
typedef TPM_ALG_ID TPMI_ALG_SYM;

// Table 59 - TPMI_ALG_SYM_OBJECT Type
typedef TPM_ALG_ID TPMI_ALG_SYM_OBJECT;

// Table 60 - TPMI_ALG_SYM_MODE Type
typedef TPM_ALG_ID TPMI_ALG_SYM_MODE;

// Table 61 - TPMI_ALG_KDF Type
typedef TPM_ALG_ID TPMI_ALG_KDF;

// Table 62 - TPMI_ALG_SIG_SCHEME Type
typedef TPM_ALG_ID TPMI_ALG_SIG_SCHEME;

// Table 63 - TPMI_ECC_KEY_EXCHANGE Type
typedef TPM_ALG_ID TPMI_ECC_KEY_EXCHANGE;

// Table 64 - TPMI_ST_COMMAND_TAG Type
typedef TPM_ST TPMI_ST_COMMAND_TAG;

// 10 Structure Definitions

// Table 65 - TPMS_ALGORITHM_DESCRIPTION Structure
typedef struct {
	TPM_ALG_ID        alg;
	TPMA_ALGORITHM    attributes;
} TPMS_ALGORITHM_DESCRIPTION;

// Table 66 - TPMU_HA Union
typedef union {
	BYTE    sha1[SHA1_DIGEST_SIZE];
	BYTE    sha256[SHA256_DIGEST_SIZE];
	BYTE    sm3_256[SM3_256_DIGEST_SIZE];
	BYTE    sha384[SHA384_DIGEST_SIZE];
	BYTE    sha512[SHA512_DIGEST_SIZE];
} TPMU_HA;

// Table 67 - TPMT_HA Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
	TPMU_HA          digest;
} TPMT_HA;

// Table 68 - TPM2B_DIGEST Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(TPMU_HA)];
} TPM2B_DIGEST;

// Table 69 - TPM2B_DATA Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(TPMT_HA)];
} TPM2B_DATA;

// Table 70 - TPM2B_NONCE Types
typedef TPM2B_DIGEST TPM2B_NONCE;

// Table 71 - TPM2B_AUTH Types
typedef TPM2B_DIGEST TPM2B_AUTH;

// Table 72 - TPM2B_OPERAND Types
typedef TPM2B_DIGEST TPM2B_OPERAND;

// Table 73 - TPM2B_EVENT Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[1024];
} TPM2B_EVENT;

// Table 74 - TPM2B_MAX_BUFFER Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_DIGEST_BUFFER];
} TPM2B_MAX_BUFFER;

// Table 75 - TPM2B_MAX_NV_BUFFER Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_NV_INDEX_SIZE];
} TPM2B_MAX_NV_BUFFER;

// Table 76 - TPM2B_TIMEOUT Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(uint64_t)];
} TPM2B_TIMEOUT;

// Table 77 -- TPM2B_IV Structure <I/O>
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_SYM_BLOCK_SIZE];
} TPM2B_IV;

// Table 78 - TPMU_NAME Union
typedef union {
	TPMT_HA       digest;
	TPM_HANDLE    handle;
} TPMU_NAME;

// Table 79 - TPM2B_NAME Structure
typedef struct {
	uint16_t    size;
	BYTE      name[sizeof(TPMU_NAME)];
} TPM2B_NAME;

// Table 80 - TPMS_PCR_SELECT Structure
typedef struct {
	uint8_t    sizeofSelect;
	BYTE     pcrSelect[PCR_SELECT_MAX];
} TPMS_PCR_SELECT;

// Table 81 - TPMS_PCR_SELECTION Structure
typedef struct {
	TPMI_ALG_HASH    hash;
	uint8_t            sizeofSelect;
	BYTE             pcrSelect[PCR_SELECT_MAX];
} TPMS_PCR_SELECTION;

// Table 84 - TPMT_TK_CREATION Structure
typedef struct {
	TPM_ST               tag;
	TPMI_RH_HIERARCHY    hierarchy;
	TPM2B_DIGEST         digest;
} TPMT_TK_CREATION;

// Table 85 - TPMT_TK_VERIFIED Structure
typedef struct {
	TPM_ST               tag;
	TPMI_RH_HIERARCHY    hierarchy;
	TPM2B_DIGEST         digest;
} TPMT_TK_VERIFIED;

// Table 86 - TPMT_TK_AUTH Structure
typedef struct {
	TPM_ST               tag;
	TPMI_RH_HIERARCHY    hierarchy;
	TPM2B_DIGEST         digest;
} TPMT_TK_AUTH;

// Table 87 - TPMT_TK_HASHCHECK Structure
typedef struct {
	TPM_ST               tag;
	TPMI_RH_HIERARCHY    hierarchy;
	TPM2B_DIGEST         digest;
} TPMT_TK_HASHCHECK;

// Table 88 - TPMS_ALG_PROPERTY Structure
typedef struct {
	TPM_ALG_ID        alg;
	TPMA_ALGORITHM    algProperties;
} TPMS_ALG_PROPERTY;

// Table 89 - TPMS_TAGGED_PROPERTY Structure
typedef struct {
	TPM_PT    property;
	uint32_t    value;
} TPMS_TAGGED_PROPERTY;

// Table 90 - TPMS_TAGGED_PCR_SELECT Structure
typedef struct {
	TPM_PT    tag;
	uint8_t     sizeofSelect;
	BYTE      pcrSelect[PCR_SELECT_MAX];
} TPMS_TAGGED_PCR_SELECT;

// Table 91 - TPML_CC Structure
typedef struct {
	uint32_t    count;
	TPM_CC    commandCodes[MAX_CAP_CC];
} TPML_CC;

// Table 92 - TPML_CCA Structure
typedef struct {
	uint32_t     count;
	TPMA_CC    commandAttributes[MAX_CAP_CC];
} TPML_CCA;

// Table 93 - TPML_ALG Structure
typedef struct {
	uint32_t        count;
	TPM_ALG_ID    algorithms[MAX_ALG_LIST_SIZE];
} TPML_ALG;

// Table 94 - TPML_HANDLE Structure
typedef struct {
	uint32_t        count;
	TPM_HANDLE    handle[MAX_CAP_HANDLES];
} TPML_HANDLE;

// Table 95 - TPML_DIGEST Structure
typedef struct {
	uint32_t          count;
	TPM2B_DIGEST    digests[8];
} TPML_DIGEST;

// Table 96 -- TPML_DIGEST_VALUES Structure <I/O>
typedef struct {
	uint32_t     count;
	TPMT_HA    digests[HASH_COUNT];
} TPML_DIGEST_VALUES;

// Table 97 - TPM2B_DIGEST_VALUES Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(TPML_DIGEST_VALUES)];
} TPM2B_DIGEST_VALUES;

// Table 98 - TPML_PCR_SELECTION Structure
typedef struct {
	uint32_t                count;
	TPMS_PCR_SELECTION    pcrSelections[HASH_COUNT];
} TPML_PCR_SELECTION;

// Table 99 - TPML_ALG_PROPERTY Structure
typedef struct {
	uint32_t               count;
	TPMS_ALG_PROPERTY    algProperties[MAX_CAP_ALGS];
} TPML_ALG_PROPERTY;

// Table 100 - TPML_TAGGED_TPM_PROPERTY Structure
typedef struct {
	uint32_t                  count;
	TPMS_TAGGED_PROPERTY    tpmProperty[MAX_TPM_PROPERTIES];
} TPML_TAGGED_TPM_PROPERTY;

// Table 101 - TPML_TAGGED_PCR_PROPERTY Structure
typedef struct {
	uint32_t                    count;
	TPMS_TAGGED_PCR_SELECT    pcrProperty[MAX_PCR_PROPERTIES];
} TPML_TAGGED_PCR_PROPERTY;

// Table 102 - TPML_ECC_CURVE Structure
typedef struct {
	uint32_t           count;
	TPM_ECC_CURVE    eccCurves[MAX_ECC_CURVES];
} TPML_ECC_CURVE;

// Table 103 - TPMU_CAPABILITIES Union
typedef union {
	TPML_ALG_PROPERTY           algorithms;
	TPML_HANDLE                 handles;
	TPML_CCA                    command;
	TPML_CC                     ppCommands;
	TPML_CC                     auditCommands;
	TPML_PCR_SELECTION          assignedPCR;
	TPML_TAGGED_TPM_PROPERTY    tpmProperties;
	TPML_TAGGED_PCR_PROPERTY    pcrProperties;
	TPML_ECC_CURVE              eccCurves;
} TPMU_CAPABILITIES;

// Table 104 - TPMS_CAPABILITY_DATA Structure
typedef struct {
	TPM_CAP              capability;
	TPMU_CAPABILITIES    data;
} TPMS_CAPABILITY_DATA;

// Table 105 - TPMS_CLOCK_INFO Structure
typedef struct {
	uint64_t         clock;
	uint32_t         resetCount;
	uint32_t         restartCount;
	TPMI_YES_NO    safe;
} TPMS_CLOCK_INFO;

// Table 106 - TPMS_TIME_INFO Structure
typedef struct {
	uint64_t             time;
	TPMS_CLOCK_INFO    clockInfo;
} TPMS_TIME_INFO;

// Table 107 - TPMS_TIME_ATTEST_INFO Structure
typedef struct {
	TPMS_TIME_INFO    time;
	uint64_t            firmwareVersion;
} TPMS_TIME_ATTEST_INFO;

// Table 108 - TPMS_CERTIFY_INFO Structure
typedef struct {
	TPM2B_NAME    name;
	TPM2B_NAME    qualifiedName;
} TPMS_CERTIFY_INFO;

// Table 109 - TPMS_QUOTE_INFO Structure
typedef struct {
	TPML_PCR_SELECTION    pcrSelect;
	TPM2B_DIGEST          pcrDigest;
} TPMS_QUOTE_INFO;

// Table 110 - TPMS_COMMAND_AUDIT_INFO Structure
typedef struct {
	uint64_t          auditCounter;
	TPM_ALG_ID      digestAlg;
	TPM2B_DIGEST    auditDigest;
	TPM2B_DIGEST    commandDigest;
} TPMS_COMMAND_AUDIT_INFO;

// Table 111 - TPMS_SESSION_AUDIT_INFO Structure
typedef struct {
	TPMI_YES_NO     exclusiveSession;
	TPM2B_DIGEST    sessionDigest;
} TPMS_SESSION_AUDIT_INFO;

// Table 112 - TPMS_CREATION_INFO Structure
typedef struct {
	TPM2B_NAME      objectName;
	TPM2B_DIGEST    creationHash;
} TPMS_CREATION_INFO;

// Table 113 - TPMS_NV_CERTIFY_INFO Structure
typedef struct {
	TPM2B_NAME             indexName;
	uint16_t                 offset;
	TPM2B_MAX_NV_BUFFER    nvContents;
} TPMS_NV_CERTIFY_INFO;

// Table 114 - TPMI_ST_ATTEST Type
typedef TPM_ST TPMI_ST_ATTEST;

// Table 115 - TPMU_ATTEST Union
typedef union {
	TPMS_CERTIFY_INFO          certify;
	TPMS_CREATION_INFO         creation;
	TPMS_QUOTE_INFO            quote;
	TPMS_COMMAND_AUDIT_INFO    commandAudit;
	TPMS_SESSION_AUDIT_INFO    sessionAudit;
	TPMS_TIME_ATTEST_INFO      time;
	TPMS_NV_CERTIFY_INFO       nv;
} TPMU_ATTEST;

// Table 116 - TPMS_ATTEST Structure
typedef struct {
	TPM_GENERATED      magic;
	TPMI_ST_ATTEST     type;
	TPM2B_NAME         qualifiedSigner;
	TPM2B_DATA         extraData;
	TPMS_CLOCK_INFO    clockInfo;
	uint64_t             firmwareVersion;
	TPMU_ATTEST        attested;
} TPMS_ATTEST;

// Table 117 - TPM2B_ATTEST Structure
typedef struct {
	uint16_t    size;
	BYTE      attestationData[sizeof(TPMS_ATTEST)];
} TPM2B_ATTEST;

// Table 118 - TPMS_AUTH_COMMAND Structure
typedef struct {
	TPMI_SH_AUTH_SESSION    sessionHandle;
	TPM2B_NONCE             nonce;
	TPMA_SESSION            sessionAttributes;
	TPM2B_AUTH              hmac;
} TPMS_AUTH_COMMAND;

// Table 119 - TPMS_AUTH_RESPONSE Structure
typedef struct {
	TPM2B_NONCE     nonce;
	TPMA_SESSION    sessionAttributes;
	TPM2B_AUTH      hmac;
} TPMS_AUTH_RESPONSE;

// 11 Algorithm Parameters and Structures

// Table 120 - TPMI_AES_KEY_BITS Type
typedef TPM_KEY_BITS TPMI_AES_KEY_BITS;

// Table 121 - TPMI_SM4_KEY_BITS Type
typedef TPM_KEY_BITS TPMI_SM4_KEY_BITS;

// Table 122 - TPMU_SYM_KEY_BITS Union
typedef union {
	TPMI_AES_KEY_BITS    aes;
	TPMI_SM4_KEY_BITS    SM4;
	TPM_KEY_BITS         sym;
	TPMI_ALG_HASH xor;
} TPMU_SYM_KEY_BITS;

// Table 123 - TPMU_SYM_MODE Union
typedef union {
	TPMI_ALG_SYM_MODE    aes;
	TPMI_ALG_SYM_MODE    SM4;
	TPMI_ALG_SYM_MODE    sym;
} TPMU_SYM_MODE;

// Table 125 - TPMT_SYM_DEF Structure
typedef struct {
	TPMI_ALG_SYM         algorithm;
	TPMU_SYM_KEY_BITS    keyBits;
	TPMU_SYM_MODE        mode;
} TPMT_SYM_DEF;

// Table 126 - TPMT_SYM_DEF_OBJECT Structure
typedef struct {
	TPMI_ALG_SYM_OBJECT    algorithm;
	TPMU_SYM_KEY_BITS      keyBits;
	TPMU_SYM_MODE          mode;
} TPMT_SYM_DEF_OBJECT;

// Table 127 - TPM2B_SYM_KEY Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_SYM_KEY_BYTES];
} TPM2B_SYM_KEY;

// Table 128 - TPMS_SYMCIPHER_PARMS Structure
typedef struct {
	TPMT_SYM_DEF_OBJECT    sym;
} TPMS_SYMCIPHER_PARMS;

// Table 129 - TPM2B_SENSITIVE_DATA Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_SYM_DATA];
} TPM2B_SENSITIVE_DATA;

// Table 130 - TPMS_SENSITIVE_CREATE Structure
typedef struct {
	TPM2B_AUTH              userAuth;
	TPM2B_SENSITIVE_DATA    data;
} TPMS_SENSITIVE_CREATE;

// Table 131 - TPM2B_SENSITIVE_CREATE Structure
typedef struct {
	uint16_t                   size;
	TPMS_SENSITIVE_CREATE    sensitive;
} TPM2B_SENSITIVE_CREATE;

// Table 132 - TPMS_SCHEME_SIGHASH Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_SIGHASH;

// Table 133 - TPMI_ALG_KEYEDHASH_SCHEME Type
typedef TPM_ALG_ID TPMI_ALG_KEYEDHASH_SCHEME;

// Table 134 - HMAC_SIG_SCHEME Types
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_HMAC;

// Table 135 - TPMS_SCHEME_XOR Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
	TPMI_ALG_KDF     kdf;
} TPMS_SCHEME_XOR;

// Table 136 - TPMU_SCHEME_KEYEDHASH Union
typedef union {
	TPMS_SCHEME_HMAC    hmac;
	TPMS_SCHEME_XOR xor;
} TPMU_SCHEME_KEYEDHASH;

// Table 137 - TPMT_KEYEDHASH_SCHEME Structure
typedef struct {
	TPMI_ALG_KEYEDHASH_SCHEME    scheme;
	TPMU_SCHEME_KEYEDHASH        details;
} TPMT_KEYEDHASH_SCHEME;

// Table 138 - RSA_SIG_SCHEMES Types
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSASSA;
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSAPSS;

// Table 139 - ECC_SIG_SCHEMES Types
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECDSA;
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_SM2;
typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECSCHNORR;

// Table 140 - TPMS_SCHEME_ECDAA Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
	uint16_t           count;
} TPMS_SCHEME_ECDAA;

// Table 141 - TPMU_SIG_SCHEME Union
typedef union {
	TPMS_SCHEME_RSASSA       rsassa;
	TPMS_SCHEME_RSAPSS       rsapss;
	TPMS_SCHEME_ECDSA        ecdsa;
	TPMS_SCHEME_ECDAA        ecdaa;
	TPMS_SCHEME_ECSCHNORR    ecSchnorr;
	TPMS_SCHEME_HMAC         hmac;
	TPMS_SCHEME_SIGHASH      any;
} TPMU_SIG_SCHEME;

// Table 142 - TPMT_SIG_SCHEME Structure
typedef struct {
	TPMI_ALG_SIG_SCHEME    scheme;
	TPMU_SIG_SCHEME        details;
} TPMT_SIG_SCHEME;

// Table 143 - TPMS_SCHEME_OAEP Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_OAEP;

// Table 144 - TPMS_SCHEME_ECDH Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_ECDH;

// Table 145 - TPMS_SCHEME_MGF1 Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_MGF1;

// Table 146 - TPMS_SCHEME_KDF1_SP800_56a Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_KDF1_SP800_56a;

// Table 147 - TPMS_SCHEME_KDF2 Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_KDF2;

// Table 148 - TPMS_SCHEME_KDF1_SP800_108 Structure
typedef struct {
	TPMI_ALG_HASH    hashAlg;
} TPMS_SCHEME_KDF1_SP800_108;

// Table 149 - TPMU_KDF_SCHEME Union
typedef union {
	TPMS_SCHEME_MGF1              mgf1;
	TPMS_SCHEME_KDF1_SP800_56a    kdf1_SP800_56a;
	TPMS_SCHEME_KDF2              kdf2;
	TPMS_SCHEME_KDF1_SP800_108    kdf1_sp800_108;
} TPMU_KDF_SCHEME;

// Table 150 - TPMT_KDF_SCHEME Structure
typedef struct {
	TPMI_ALG_KDF       scheme;
	TPMU_KDF_SCHEME    details;
} TPMT_KDF_SCHEME;

// Table 151 - TPMI_ALG_ASYM_SCHEME Type
typedef TPM_ALG_ID TPMI_ALG_ASYM_SCHEME;

// Table 152 - TPMU_ASYM_SCHEME Union
typedef union {
	TPMS_SCHEME_RSASSA       rsassa;
	TPMS_SCHEME_RSAPSS       rsapss;
	TPMS_SCHEME_OAEP         oaep;
	TPMS_SCHEME_ECDSA        ecdsa;
	TPMS_SCHEME_ECDAA        ecdaa;
	TPMS_SCHEME_ECSCHNORR    ecSchnorr;
	TPMS_SCHEME_SIGHASH      anySig;
} TPMU_ASYM_SCHEME;

// Table 153 - TPMT_ASYM_SCHEME Structure
typedef struct {
	TPMI_ALG_ASYM_SCHEME    scheme;
	TPMU_ASYM_SCHEME        details;
} TPMT_ASYM_SCHEME;

// Table 154 - TPMI_ALG_RSA_SCHEME Type
typedef TPM_ALG_ID TPMI_ALG_RSA_SCHEME;

// Table 155 - TPMT_RSA_SCHEME Structure
typedef struct {
	TPMI_ALG_RSA_SCHEME    scheme;
	TPMU_ASYM_SCHEME       details;
} TPMT_RSA_SCHEME;

// Table 156 - TPMI_ALG_RSA_DECRYPT Type
typedef TPM_ALG_ID TPMI_ALG_RSA_DECRYPT;

// Table 157 - TPMT_RSA_DECRYPT Structure
typedef struct {
	TPMI_ALG_RSA_DECRYPT    scheme;
	TPMU_ASYM_SCHEME        details;
} TPMT_RSA_DECRYPT;

// Table 158 - TPM2B_PUBLIC_KEY_RSA Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_RSA_KEY_BYTES];
} TPM2B_PUBLIC_KEY_RSA;

// Table 159 - TPMI_RSA_KEY_BITS Type
typedef TPM_KEY_BITS TPMI_RSA_KEY_BITS;

// Table 160 - TPM2B_PRIVATE_KEY_RSA Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_RSA_KEY_BYTES / 2];
} TPM2B_PRIVATE_KEY_RSA;

// Table 161 - TPM2B_ECC_PARAMETER Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_ECC_KEY_BYTES];
} TPM2B_ECC_PARAMETER;

// Table 162 - TPMS_ECC_POINT Structure
typedef struct {
	TPM2B_ECC_PARAMETER    x;
	TPM2B_ECC_PARAMETER    y;
} TPMS_ECC_POINT;

// Table 163 -- TPM2B_ECC_POINT Structure <I/O>
typedef struct {
	uint16_t            size;
	TPMS_ECC_POINT    point;
} TPM2B_ECC_POINT;

// Table 164 - TPMI_ALG_ECC_SCHEME Type
typedef TPM_ALG_ID TPMI_ALG_ECC_SCHEME;

// Table 165 - TPMI_ECC_CURVE Type
typedef TPM_ECC_CURVE TPMI_ECC_CURVE;

// Table 166 - TPMT_ECC_SCHEME Structure
typedef struct {
	TPMI_ALG_ECC_SCHEME    scheme;
	TPMU_SIG_SCHEME        details;
} TPMT_ECC_SCHEME;

// Table 167 - TPMS_ALGORITHM_DETAIL_ECC Structure
typedef struct {
	TPM_ECC_CURVE          curveID;
	uint16_t                 keySize;
	TPMT_KDF_SCHEME        kdf;
	TPMT_ECC_SCHEME        sign;
	TPM2B_ECC_PARAMETER    p;
	TPM2B_ECC_PARAMETER    a;
	TPM2B_ECC_PARAMETER    b;
	TPM2B_ECC_PARAMETER    gX;
	TPM2B_ECC_PARAMETER    gY;
	TPM2B_ECC_PARAMETER    n;
	TPM2B_ECC_PARAMETER    h;
} TPMS_ALGORITHM_DETAIL_ECC;

// Table 168 - TPMS_SIGNATURE_RSASSA Structure
typedef struct {
	TPMI_ALG_HASH           hash;
	TPM2B_PUBLIC_KEY_RSA    sig;
} TPMS_SIGNATURE_RSASSA;

// Table 169 - TPMS_SIGNATURE_RSAPSS Structure
typedef struct {
	TPMI_ALG_HASH           hash;
	TPM2B_PUBLIC_KEY_RSA    sig;
} TPMS_SIGNATURE_RSAPSS;

// Table 170 - TPMS_SIGNATURE_ECDSA Structure
typedef struct {
	TPMI_ALG_HASH          hash;
	TPM2B_ECC_PARAMETER    signatureR;
	TPM2B_ECC_PARAMETER    signatureS;
} TPMS_SIGNATURE_ECDSA;

// Table 171 - TPMU_SIGNATURE Union
typedef union {
	TPMS_SIGNATURE_RSASSA    rsassa;
	TPMS_SIGNATURE_RSAPSS    rsapss;
	TPMS_SIGNATURE_ECDSA     ecdsa;
	TPMS_SIGNATURE_ECDSA     sm2;
	TPMS_SIGNATURE_ECDSA     ecdaa;
	TPMS_SIGNATURE_ECDSA     ecschnorr;
	TPMT_HA                  hmac;
	TPMS_SCHEME_SIGHASH      any;
} TPMU_SIGNATURE;

// Table 172 - TPMT_SIGNATURE Structure
typedef struct {
	TPMI_ALG_SIG_SCHEME    sigAlg;
	TPMU_SIGNATURE         signature;
} TPMT_SIGNATURE;

// Table 173 - TPMU_ENCRYPTED_SECRET Union
typedef union {
	BYTE    ecc[sizeof(TPMS_ECC_POINT)];
	BYTE    rsa[MAX_RSA_KEY_BYTES];
	BYTE    symmetric[sizeof(TPM2B_DIGEST)];
	BYTE    keyedHash[sizeof(TPM2B_DIGEST)];
} TPMU_ENCRYPTED_SECRET;

// Table 174 - TPM2B_ENCRYPTED_SECRET Structure
typedef struct {
	uint16_t    size;
	BYTE      secret[sizeof(TPMU_ENCRYPTED_SECRET)];
} TPM2B_ENCRYPTED_SECRET;

// 12 Key/Object Complex

// Table 175 - TPMI_ALG_PUBLIC Type
typedef TPM_ALG_ID TPMI_ALG_PUBLIC;

// Table 176 - TPMU_PUBLIC_ID Union
typedef union {
	TPM2B_DIGEST            keyedHash;
	TPM2B_DIGEST            sym;
	TPM2B_PUBLIC_KEY_RSA    rsa;
	TPMS_ECC_POINT          ecc;
} TPMU_PUBLIC_ID;

// Table 177 - TPMS_KEYEDHASH_PARMS Structure
typedef struct {
	TPMT_KEYEDHASH_SCHEME    scheme;
} TPMS_KEYEDHASH_PARMS;

// Table 178 - TPMS_ASYM_PARMS Structure
typedef struct {
	TPMT_SYM_DEF_OBJECT    symmetric;
	TPMT_ASYM_SCHEME       scheme;
} TPMS_ASYM_PARMS;

// Table 179 - TPMS_RSA_PARMS Structure
typedef struct {
	TPMT_SYM_DEF_OBJECT    symmetric;
	TPMT_RSA_SCHEME        scheme;
	TPMI_RSA_KEY_BITS      keyBits;
	uint32_t                 exponent;
} TPMS_RSA_PARMS;

// Table 180 - TPMS_ECC_PARMS Structure
typedef struct {
	TPMT_SYM_DEF_OBJECT    symmetric;
	TPMT_ECC_SCHEME        scheme;
	TPMI_ECC_CURVE         curveID;
	TPMT_KDF_SCHEME        kdf;
} TPMS_ECC_PARMS;

// Table 181 - TPMU_PUBLIC_PARMS Union
typedef union {
	TPMS_KEYEDHASH_PARMS    keyedHashDetail;
	TPMT_SYM_DEF_OBJECT     symDetail;
	TPMS_RSA_PARMS          rsaDetail;
	TPMS_ECC_PARMS          eccDetail;
	TPMS_ASYM_PARMS         asymDetail;
} TPMU_PUBLIC_PARMS;

// Table 182 - TPMT_PUBLIC_PARMS Structure
typedef struct {
	TPMI_ALG_PUBLIC      type;
	TPMU_PUBLIC_PARMS    parameters;
} TPMT_PUBLIC_PARMS;

// Table 183 - TPMT_PUBLIC Structure
typedef struct {
	TPMI_ALG_PUBLIC      type;
	TPMI_ALG_HASH        nameAlg;
	TPMA_OBJECT          objectAttributes;
	TPM2B_DIGEST         authPolicy;
	TPMU_PUBLIC_PARMS    parameters;
	TPMU_PUBLIC_ID       unique;
} TPMT_PUBLIC;

// Table 184 - TPM2B_PUBLIC Structure
typedef struct {
	uint16_t         size;
	TPMT_PUBLIC    publicArea;
} TPM2B_PUBLIC;

// Table 185 - TPM2B_PRIVATE_VENDOR_SPECIFIC Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[PRIVATE_VENDOR_SPECIFIC_BYTES];
} TPM2B_PRIVATE_VENDOR_SPECIFIC;

// Table 186 - TPMU_SENSITIVE_COMPOSITE Union
typedef union {
	TPM2B_PRIVATE_KEY_RSA            rsa;
	TPM2B_ECC_PARAMETER              ecc;
	TPM2B_SENSITIVE_DATA             bits;
	TPM2B_SYM_KEY                    sym;
	TPM2B_PRIVATE_VENDOR_SPECIFIC    any;
} TPMU_SENSITIVE_COMPOSITE;

// Table 187 - TPMT_SENSITIVE Structure
typedef struct {
	TPMI_ALG_PUBLIC             sensitiveType;
	TPM2B_AUTH                  authValue;
	TPM2B_DIGEST                seedValue;
	TPMU_SENSITIVE_COMPOSITE    sensitive;
} TPMT_SENSITIVE;

// Table 188 - TPM2B_SENSITIVE Structure
typedef struct {
	uint16_t            size;
	TPMT_SENSITIVE    sensitiveArea;
} TPM2B_SENSITIVE;

// Table 189 - _PRIVATE Structure
typedef struct {
	TPM2B_DIGEST      integrityOuter;
	TPM2B_DIGEST      integrityInner;
	TPMT_SENSITIVE    sensitive;
} _PRIVATE;

// Table 190 - TPM2B_PRIVATE Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(_PRIVATE)];
} TPM2B_PRIVATE;

// Table 191 - _ID_OBJECT Structure
typedef struct {
	TPM2B_DIGEST    integrityHMAC;
	TPM2B_DIGEST    encIdentity;
} _ID_OBJECT;

// Table 192 - TPM2B_ID_OBJECT Structure
typedef struct {
	uint16_t    size;
	BYTE      credential[sizeof(_ID_OBJECT)];
} TPM2B_ID_OBJECT;

// 13 NV Storage Structures

// Table 193 - TPM_NV_INDEX Bits
//
// NOTE: Comment here to resolve conflict
//
// typedef struct {
//  uint32_t index : 22;
//  uint32_t space : 2;
//  uint32_t RH_NV : 8;
// } TPM_NV_INDEX;

// Table 195 - TPMA_NV Bits
typedef struct {
	uint32_t    TPMA_NV_PPWRITE : 1;
	uint32_t    TPMA_NV_OWNERWRITE : 1;
	uint32_t    TPMA_NV_AUTHWRITE : 1;
	uint32_t    TPMA_NV_POLICYWRITE : 1;
	uint32_t    TPMA_NV_COUNTER : 1;
	uint32_t    TPMA_NV_BITS : 1;
	uint32_t    TPMA_NV_EXTEND : 1;
	uint32_t    reserved7_9 : 3;
	uint32_t    TPMA_NV_POLICY_DELETE : 1;
	uint32_t    TPMA_NV_WRITELOCKED : 1;
	uint32_t    TPMA_NV_WRITEALL : 1;
	uint32_t    TPMA_NV_WRITEDEFINE : 1;
	uint32_t    TPMA_NV_WRITE_STCLEAR : 1;
	uint32_t    TPMA_NV_GLOBALLOCK : 1;
	uint32_t    TPMA_NV_PPREAD : 1;
	uint32_t    TPMA_NV_OWNERREAD : 1;
	uint32_t    TPMA_NV_AUTHREAD : 1;
	uint32_t    TPMA_NV_POLICYREAD : 1;
	uint32_t    reserved20_24 : 5;
	uint32_t    TPMA_NV_NO_DA : 1;
	uint32_t    TPMA_NV_ORDERLY : 1;
	uint32_t    TPMA_NV_CLEAR_STCLEAR : 1;
	uint32_t    TPMA_NV_READLOCKED : 1;
	uint32_t    TPMA_NV_WRITTEN : 1;
	uint32_t    TPMA_NV_PLATFORMCREATE : 1;
	uint32_t    TPMA_NV_READ_STCLEAR : 1;
} TPMA_NV;

// Table 196 - TPMS_NV_PUBLIC Structure
typedef struct {
	TPMI_RH_NV_INDEX    nvIndex;
	TPMI_ALG_HASH       nameAlg;
	TPMA_NV             attributes;
	TPM2B_DIGEST        authPolicy;
	uint16_t              dataSize;
} TPMS_NV_PUBLIC;

// Table 197 - TPM2B_NV_PUBLIC Structure
typedef struct {
	uint16_t            size;
	TPMS_NV_PUBLIC    nvPublic;
} TPM2B_NV_PUBLIC;

// 14 Context Data

// Table 198 - TPM2B_CONTEXT_SENSITIVE Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[MAX_CONTEXT_SIZE];
} TPM2B_CONTEXT_SENSITIVE;

// Table 199 - TPMS_CONTEXT_DATA Structure
typedef struct {
	TPM2B_DIGEST               integrity;
	TPM2B_CONTEXT_SENSITIVE    encrypted;
} TPMS_CONTEXT_DATA;

// Table 200 - TPM2B_CONTEXT_DATA Structure
typedef struct {
	uint16_t    size;
	BYTE      buffer[sizeof(TPMS_CONTEXT_DATA)];
} TPM2B_CONTEXT_DATA;

// Table 201 - TPMS_CONTEXT Structure
typedef struct {
	uint64_t                sequence;
	TPMI_DH_CONTEXT       savedHandle;
	TPMI_RH_HIERARCHY     hierarchy;
	TPM2B_CONTEXT_DATA    contextBlob;
} TPMS_CONTEXT;

// 15 Creation Data

// Table 203 - TPMS_CREATION_DATA Structure
typedef struct {
	TPML_PCR_SELECTION    pcrSelect;
	TPM2B_DIGEST          pcrDigest;
	TPMA_LOCALITY         locality;
	TPM_ALG_ID            parentNameAlg;
	TPM2B_NAME            parentName;
	TPM2B_NAME            parentQualifiedName;
	TPM2B_DATA            outsideInfo;
} TPMS_CREATION_DATA;

// Table 204 - TPM2B_CREATION_DATA Structure
typedef struct {
	uint16_t                size;
	TPMS_CREATION_DATA    creationData;
} TPM2B_CREATION_DATA;

//
// Command Header
//
typedef struct {
	TPM_ST    tag;
	uint32_t    paramSize;
	TPM_CC    commandCode;
} TPM2_COMMAND_HEADER;

typedef struct {
	TPM_ST    tag;
	uint32_t    paramSize;
	TPM_RC    responseCode;
} TPM2_RESPONSE_HEADER;

#define HASH_ALG_SHA1     0x00000001
#define HASH_ALG_SHA256   0x00000002
#define HASH_ALG_SHA384   0x00000004
#define HASH_ALG_SHA512   0x00000008
#define HASH_ALG_SM3_256  0x00000010

typedef struct {
	TPM2_COMMAND_HEADER    Header;
	TPMI_DH_OBJECT         ObjectHandle;
} TPM2_READ_PUBLIC_COMMAND;

typedef struct {
	TPM2_RESPONSE_HEADER    Header;
	TPM2B_PUBLIC            OutPublic;
	TPM2B_NAME              Name;
	TPM2B_NAME              QualifiedName;
} TPM2_READ_PUBLIC_RESPONSE;

typedef struct {
	uint32_t    Signature;
	uint32_t    Length;
	uint8_t     Revision;
	uint8_t     Checksum;
	uint8_t     OemId[6];
	uint64_t    OemTableId;
	uint32_t    OemRevision;
	uint32_t    CreatorId;
	uint32_t    CreatorRevision;
} ACPI_DESCRIPTION_HEADER;

typedef struct {
	ACPI_DESCRIPTION_HEADER          Header;
	uint32_t                         Flags;
	uint64_t                         AddressOfControlArea;
	uint32_t                         StartMethod;
} TPM2_ACPI_TABLE, * PTPM2_ACPI_TABLE;

#pragma pack(pop)

```

`tpm-mmio/main.cpp`:

```cpp

#include <ntddk.h>
#include <bcrypt.h>
#include <ntstrsafe.h>
#include <aux_klib.h>

#pragma warning(disable : 4996) // Disable "ExAllocatePool" is deprecated.

#include "stdint.hpp"
#include "defs.hpp"
#include "mmio.hpp"
#include "acpi.hpp"
#include "ptp.hpp"
#include "crb.hpp"
#include "tis.hpp"
#include "tpm.hpp"

void* operator new(size_t size) { return ExAllocatePool(NonPagedPool, size); }
void operator delete(void* p, size_t /*size*/) { if (p) ExFreePool(p); }

void DriverUnload(_In_ PDRIVER_OBJECT driverObject) 
{
	UNREFERENCED_PARAMETER(driverObject);
	Dbg("Unloading tpm-mmio.sys.\n"); 
}

void PrintBufferContents(const char* label, const uint8_t* buffer, uint16_t size) 
{
    char outputBuffer[1024];
    char tempBuffer[5];
    RtlZeroMemory(outputBuffer, sizeof(outputBuffer));
    RtlZeroMemory(tempBuffer, sizeof(tempBuffer));

    for (uint16_t i = 0; i < size; i++)
    {
        RtlStringCbPrintfA(tempBuffer, sizeof(tempBuffer), "%02x", buffer[i]);
        RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), tempBuffer);
    }
    Dbg("%s (size: %u): %s\n", label, size, outputBuffer);

    BCRYPT_ALG_HANDLE hAlgorithm;
    BCRYPT_HASH_HANDLE hHash;
    UCHAR hashBuffer[64];
    ULONG hashLength = 0;
    ULONG resultLength = 0;

    if (NT_SUCCESS(BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_MD5_ALGORITHM, NULL, 0)))
    {
        if (NT_SUCCESS(BCryptGetProperty(hAlgorithm, BCRYPT_HASH_LENGTH, (PUCHAR)&hashLength, sizeof(hashLength), &resultLength, 0)))
        {
            if (NT_SUCCESS(BCryptCreateHash(hAlgorithm, &hHash, NULL, 0, NULL, 0, 0)))
            {
                if (NT_SUCCESS(BCryptHashData(hHash, (PUCHAR)buffer, size, 0)))
                {
                    if (NT_SUCCESS(BCryptFinishHash(hHash, hashBuffer, hashLength, 0)))
                    {
                        RtlZeroMemory(outputBuffer, sizeof(outputBuffer));
                        RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), "\t[!] MD5: ");
                        for (ULONG i = 0; i < hashLength; i++)
                        {
                            RtlStringCbPrintfA(tempBuffer, sizeof(tempBuffer), "%02x", hashBuffer[i]);
                            RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), tempBuffer);
                        }
                        DbgPrintEx(0, 0, "%s\n", outputBuffer);
                    }
                }
                BCryptDestroyHash(hHash);
            }
        }
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
    }


    if (NT_SUCCESS(BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_SHA1_ALGORITHM, NULL, 0)))
    {
        if (NT_SUCCESS(BCryptGetProperty(hAlgorithm, BCRYPT_HASH_LENGTH, (PUCHAR)&hashLength, sizeof(hashLength), &resultLength, 0)))
        {
            if (NT_SUCCESS(BCryptCreateHash(hAlgorithm, &hHash, NULL, 0, NULL, 0, 0)))
            {
                if (NT_SUCCESS(BCryptHashData(hHash, (PUCHAR)buffer, size, 0)))
                {
                    if (NT_SUCCESS(BCryptFinishHash(hHash, hashBuffer, hashLength, 0)))
                    {
                        RtlZeroMemory(outputBuffer, sizeof(outputBuffer));
                        RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), "\t[!] SHA-1: ");
                        for (ULONG i = 0; i < hashLength; i++)
                        {
                            RtlStringCbPrintfA(tempBuffer, sizeof(tempBuffer), "%02x", hashBuffer[i]);
                            RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), tempBuffer);
                        }
                        DbgPrintEx(0, 0, "%s\n", outputBuffer);
                    }
                }
                BCryptDestroyHash(hHash);
            }
        }
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
    }

    if (NT_SUCCESS(BCryptOpenAlgorithmProvider(&hAlgorithm, BCRYPT_SHA256_ALGORITHM, NULL, 0)))
    {
        if (NT_SUCCESS(BCryptGetProperty(hAlgorithm, BCRYPT_HASH_LENGTH, (PUCHAR)&hashLength, sizeof(hashLength), &resultLength, 0)))
        {
            if (NT_SUCCESS(BCryptCreateHash(hAlgorithm, &hHash, NULL, 0, NULL, 0, 0)))
            {
                if (NT_SUCCESS(BCryptHashData(hHash, (PUCHAR)buffer, size, 0)))
                {
                    if (NT_SUCCESS(BCryptFinishHash(hHash, hashBuffer, hashLength, 0)))
                    {
                        RtlZeroMemory(outputBuffer, sizeof(outputBuffer));
                        RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), "\t[!] SHA-256: ");
                        for (ULONG i = 0; i < hashLength; i++)
                        {
                            RtlStringCbPrintfA(tempBuffer, sizeof(tempBuffer), "%02x", hashBuffer[i]);
                            RtlStringCbCatA(outputBuffer, sizeof(outputBuffer), tempBuffer);
                        }
                        DbgPrintEx(0, 0, "%s\n", outputBuffer);
                    }
                }
                BCryptDestroyHash(hHash);
            }
        }
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
    }
}

SYNC_EXTERN NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT driverObject, _In_ PUNICODE_STRING registryPath)
{
	UNREFERENCED_PARAMETER(registryPath);
	driverObject->DriverUnload = DriverUnload;

	Tpm* tpm = new Tpm();
	if (!tpm)
	{
		DbgError("Failed to instantiate Tpm class.\n");
		return STATUS_INSUFFICIENT_RESOURCES;
	}	
	else if (!tpm->Init())
	{
		DbgError("Failed to initialize Tpm class.\n");
		return STATUS_DEVICE_HARDWARE_ERROR;
	}

    //
    // EK reserved handle from TCG Provisioning Guidance PDF.
    //
	TPMI_DH_OBJECT objectHandle = 0x81010001;
	TPM2B_PUBLIC outPublic = { 0 };
	TPM2B_NAME name = { 0 };
	TPM2B_NAME qualifiedName = { 0 };

	NTSTATUS status = tpm->ReadPublic(objectHandle, &outPublic, &name, &qualifiedName);
	if (NT_SUCCESS(status))
	{
		Dbg("ReadEkPub succeeded.\n");
		PrintBufferContents("EK", outPublic.publicArea.unique.rsa.buffer, outPublic.publicArea.unique.rsa.size);
	}
	else
	{
		Dbg("ReadEkPub failed.\n");
	}	

	delete tpm;

    Dbg("Returning with status code: 0x%x.\n", status);

	return status;
}
```

`tpm-mmio/mmio.hpp`:

```hpp
#pragma once

namespace mmio
{
    //
    // Maps a given MMIO (Memory-Mapped I/O) physical address to a virtual address 
    // and writes the specified bytes to the mapped memory.
    //
    // Parameters:
    // - physicalAddress: The physical address in MMIO space that needs to be mapped 
    //                    and written to.
    // - len: The number of bytes to write to the mapped memory.
    // - pData: A pointer to the data to be written to the mapped memory.
    //
    // Returns:
    // - true: If the operation is successful.
    // - false: If the operation fails.
    //
    bool Write(
        _In_ uintptr_t physicalAddress,    
        _In_ uint32_t len,                 
        _In_reads_bytes_(len) PVOID pData  
    )
    {
        PHYSICAL_ADDRESS physAddress;
        RtlZeroMemory(&physAddress, sizeof(PHYSICAL_ADDRESS));        
        physAddress.QuadPart = (LONGLONG)physicalAddress;
        PVOID virtualAddress = MmMapIoSpace(physAddress, len, MmNonCached);
        if (virtualAddress)
        {
            switch (len)
            {
            case 1:
                WRITE_REGISTER_BUFFER_UCHAR((volatile UCHAR*)(virtualAddress), (PUCHAR)pData, 1);
                break;
            case 2:
                WRITE_REGISTER_BUFFER_USHORT((volatile USHORT*)(virtualAddress), (PUSHORT)pData, 1);
                break;
            case 4:
                WRITE_REGISTER_BUFFER_ULONG((volatile ULONG*)(virtualAddress), (PULONG)pData, 1);
                break;
            case 8:
                WRITE_REGISTER_BUFFER_ULONG((volatile ULONG*)(virtualAddress), (PULONG)pData, 2);
                break;
            }
            MmUnmapIoSpace(virtualAddress, len);
            return true;
        }
        DbgError("Failed to map physical address to virtual address. (%s)\n", __FUNCTION__);
        return false;
    }

    //
    // Maps a given MMIO (Memory-Mapped I/O) physical address to a virtual address
    // and reads the specified number of bytes from this mapped memory into the provided buffer.
    //
    // Parameters:
    // - physicalAddress (in): The physical address in MMIO space that needs to be mapped
    //                          and read from.
    // - len (in): The number of bytes to read from the mapped memory.
    // - pData (out): A pointer to the buffer where the read data will be stored.
    //
    // Returns:
    // - true: If the operation is successful.
    // - false: If the operation fails.
    //
    bool Read(
        _In_ uintptr_t physicalAddress,     
        _In_ uint32_t len,                  
        _Out_writes_bytes_(len) PVOID pData 
    )
    {
        PHYSICAL_ADDRESS physAddress;
        RtlZeroMemory(&physAddress, sizeof(PHYSICAL_ADDRESS));
        physAddress.QuadPart = (LONGLONG)physicalAddress;
        PVOID virtualAddress = MmMapIoSpace(physAddress, len, MmNonCached);
        if (virtualAddress)
        {
            switch (len)
            {
            case 1:
                READ_REGISTER_BUFFER_UCHAR((volatile UCHAR*)(virtualAddress), (PUCHAR)pData, 1);
                break;
            case 2:
                READ_REGISTER_BUFFER_USHORT((volatile USHORT*)(virtualAddress), (PUSHORT)pData, 1);
                break;
            case 4:
                READ_REGISTER_BUFFER_ULONG((volatile ULONG*)(virtualAddress), (PULONG)pData, 1);
                break;
            case 8:
                READ_REGISTER_BUFFER_ULONG((volatile ULONG*)(virtualAddress), (PULONG)pData, 2);
                break;
            }
            MmUnmapIoSpace(virtualAddress, len);
            return true;
        }
        DbgError("Failed to map physical address to virtual address. (%s)\n", __FUNCTION__);
        return false;
    }
};
```

`tpm-mmio/ptp.hpp`:

```hpp
#pragma once

class TpmPtp
{
private:

	//
	// TPM register base address.
	//
	uintptr_t tpmBaseAddress = 0;

	//
	// Check whether TPM PTP register exists.
	//
	// Returns:
	// - true: TPM PTP exists.
	// - false: TPM PTP is not found.
	//
	bool IsPtpAvailable()
	{
		uint8_t data = 0xFF;
		if (mmio::Read(this->tpmBaseAddress, sizeof(data), &data))
		{
			if (data != 0xFF)
			{
				return true;
			}
			//
			// No TPM chip
			//
		}
		return false;
	}

	//
	// Retrieves the TPM PTP (Platform TPM Profile) interface so we can communicate with chip correctly.
	// 
	// Returns:
	// - true: Retrieved interface successfully.
	// - false: Failed to retrieve interface. 
	//
	bool GetPtpInterface()
	{
		bool status = false;
		PTP_CRB_INTERFACE_IDENTIFIER interfaceId = { { 0 } };
		PTP_FIFO_INTERFACE_CAPABILITY interfaceCapability = { { 0 } };

		if (this->IsPtpAvailable())
		{
			if (mmio::Read((uintptr_t) & ((PTP_CRB_REGISTERS*)this->tpmBaseAddress)->interfaceId, sizeof(uint32_t), &interfaceId.Uint32))
			{
				if (mmio::Read((uintptr_t) & ((PTP_FIFO_REGISTERS*)this->tpmBaseAddress)->interfaceCapability, sizeof(uint32_t), &interfaceCapability.Uint32))
				{
					if ((interfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_CRB) &&
						(interfaceId.Bits.InterfaceVersion == PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_CRB) &&
						(interfaceId.Bits.CapCRB != 0))
					{
						this->cachedInterface = PTP_INTERFACE_TYPE::PtpInterfaceCrb;
						this->idleByPassState = (uint8_t)(interfaceId.Bits.CapCRBIdleBypass);
						// Status is true if idleByPassState is NOT 0xFF, false otherwise.
						status = (this->idleByPassState != 0xFF);
						if (!status)  
						{
							DbgError("Failed to get IdleByPass state, double check PTP awareness in BIOS.\n");
						}
					}

					if ((interfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_FIFO) &&
						(interfaceId.Bits.InterfaceVersion == PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_FIFO) &&
						(interfaceId.Bits.CapFIFO != 0) &&
						(interfaceCapability.Bits.InterfaceVersion == INTERFACE_CAPABILITY_INTERFACE_VERSION_PTP))
					{
						this->cachedInterface = PTP_INTERFACE_TYPE::PtpInterfaceFifo;
						status = true;
					}

					if (interfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_TIS) 
					{
						this->cachedInterface = PTP_INTERFACE_TYPE::PtpInterfaceTis;
						status = true;
					}
				}
			}
		}

		return status;
	}

public:

	//
	// Cached PTP interface & CRB IdleByPass state for later use in submit command.
	//
	PTP_INTERFACE_TYPE cachedInterface = PTP_INTERFACE_TYPE::PtpInterfaceNull;
	uint8_t idleByPassState = 0xFF;

	TpmPtp(uintptr_t tpmBaseAddress)
	{
		this->tpmBaseAddress = tpmBaseAddress;
	}

	bool Init()
	{
		if (!this->GetPtpInterface())
		{
			DbgError("Failed to get TPM PTP interface, double check you have TPM enabled in BIOS & PTP awareness is enabled.\n");
			return false;
		}
		Dbg("ptpInterface: 0x%x\n", this->cachedInterface);
		return true;
	}

};
```

`tpm-mmio/stdint.hpp`:

```hpp
#pragma once
#define _STDINT

#ifndef RC_INVOKED
typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

// These macros must exactly match those in the Windows SDK's intsafe.h.
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_MIN   INT8_MIN
#define INT_LEAST16_MIN  INT16_MIN
#define INT_LEAST32_MIN  INT32_MIN
#define INT_LEAST64_MIN  INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN    INT8_MIN
#define INT_FAST16_MIN   INT32_MIN
#define INT_FAST32_MIN   INT32_MIN
#define INT_FAST64_MIN   INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN   INT64_MIN
#define INTPTR_MAX   INT64_MAX
#define UINTPTR_MAX  UINT64_MAX
#else
#define INTPTR_MIN   INT32_MIN
#define INTPTR_MAX   INT32_MAX
#define UINTPTR_MAX  UINT32_MAX
#endif

#define INTMAX_MIN       INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_MIN      INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
#define SIZE_MAX     UINTPTR_MAX
#endif

#define SIG_ATOMIC_MIN   INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#define WCHAR_MIN        0x0000
#define WCHAR_MAX        0xffff

#define WINT_MIN         0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)

#endif // RC_INVOKED

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */
```

`tpm-mmio/tis.hpp`:

```hpp
#pragma once

class TpmTis
{
private:
	
    //
    // Polls an 8-bit hardware register at the specified address, waiting for specified bits to be set and/or cleared within a timeout period.
    //
    // Parameters:
    // - registerAddress: Pointer to the hardware register to be polled.
    // - bitSet: Bitmask specifying the bits that must be set in the register.
    // - bitClear: Bitmask specifying the bits that must be clear in the register.
    // - timeOut: Maximum time in milliseconds to wait for the conditions to be met.
    //
    // Returns:
    // - STATUS_SUCCESS: The conditions were met within the timeout period.
    // - STATUS_TIMEOUT: The conditions were not met within the timeout period.
    //
    NTSTATUS TisWaitRegisterBits(
        _In_ uint8_t* registerAddress,
        _In_ uint8_t  bitSet,
        _In_ uint8_t  bitClear,
        _In_ uint32_t  timeOut
    )
    {
        for (uint32_t waitTime = 0; waitTime < timeOut; waitTime += 30)
        {
            uint8_t registerRead = 0;
            if (mmio::Read((uintptr_t)registerAddress, sizeof(uint8_t), &registerRead))
            {
                if (((registerRead & bitSet) == bitSet) && ((registerRead & bitClear) == 0))
                {
                    return STATUS_SUCCESS;
                }
                KeStallExecutionProcessor(30);
            }
        }
        return STATUS_TIMEOUT;
    }

    //
    // Prepares the TPM Interface Specification (TIS) device for a command by setting the READY bit
    // in the TIS PC (Platform Control) registers and waits for the device to be ready.
    //
    // This function writes to the Status register of the TIS PC registers to indicate readiness,
    // and then polls the Status register until the READY bit is set, indicating that the device
    // is ready to accept a command or has completed the previous command.
    //
    // Parameters:
    // - tisReg: Pointer to the TIS PC registers structure. This structure contains all the
    //           necessary register mappings needed to interface with the TPM device.
    //
    // Returns:
    // - STATUS_INVALID_PARAMETER: The input pointer 'tisReg' is nullptr, indicating an invalid
    //   parameter was passed.
    // - STATUS_SUCCESS: The TPM device is successfully prepared and ready.
    // - STATUS_TIMEOUT: The conditions were not met within the timeout period.
    //
    NTSTATUS TisPrepareCommand(
        _In_ TIS_PC_REGISTERS* tisReg
    )
    {
        NTSTATUS status = STATUS_INVALID_PARAMETER;
        if (tisReg != nullptr)
        {
            uint8_t bit = TIS_PC_STS_READY;
            (void)mmio::Write((uintptr_t)&tisReg->Status, sizeof(uint8_t), &bit);
            status = this->TisWaitRegisterBits(
                &tisReg->Status,
                TIS_PC_STS_READY,
                0,
                TIS_TIMEOUT_B
            );
        }
        return status;
    }

    
    //
    // Reads the burst count from the TPM Interface Specification (TIS) device.
    //
    // The burst count indicates the number of bytes the TPM can transfer in one burst. 
    // Since the burst count register is not 2-byte aligned, it needs to be read in two separate 
    // 1-byte reads. This function will poll the burst count register until a non-zero value is read 
    // or a timeout occurs.
    //
    // Parameters:
    // - tisReg: Pointer to the TIS PC registers structure. This structure contains the register mappings 
    //           needed to interface with the TPM device.
    // - burstCount: Pointer to a variable that will receive the burst count value read from the TPM.
    //
    // Returns:
    // - STATUS_SUCCESS: A non-zero burst count is successfully read.
    // - STATUS_TIMEOUT: The burst count remains zero after the timeout period.
    // - STATUS_INVALID_PARAMETER: Either 'tisReg' or 'burstCount' is a nullptr.
    //
    NTSTATUS TisReadBurstCount(
        _In_ TIS_PC_REGISTERS* tisReg,
        _Out_ uint16_t* burstCount
    )
    {
        if (burstCount != nullptr && tisReg != nullptr)
        {
            uint32_t waitTime = 0;
            do
            {
                //
                // The burst count register is a 16-bit value, but it is not 2-byte aligned.
                // Therefore, it needs to be read in two separate 1-byte reads.
                //
                uint8_t dataByte0 = 0;
                (void)mmio::Read((uintptr_t)&tisReg->BurstCount, sizeof(uint8_t), &dataByte0);
                uint8_t dataByte1 = 0;
                (void)mmio::Read((uintptr_t)&tisReg->BurstCount + 1, sizeof(uint8_t), &dataByte1);

                *burstCount = (uint16_t)((dataByte1 << 8) + dataByte0);
                if (*burstCount != 0)
                {
                    return STATUS_SUCCESS;
                }

                KeStallExecutionProcessor(30);
                waitTime += 30;
            } while (waitTime < TIS_TIMEOUT_D);

            return STATUS_TIMEOUT;
        }
        return STATUS_INVALID_PARAMETER;
    }

public:

    //
    // Sends a command to the TPM using the TPM Interface Specification (TIS) device and retrieves the response.
    //
    // This function writes a command buffer to the TPM, issues the command, and then reads the response
    // from the TPM into the provided output buffer. The function ensures that the TPM is ready to receive
    // a command before writing, and waits for the TPM to become ready after the command has been issued.
    //
    // Parameters:
    // - tisReg: Pointer to the tisReg registers used to initiate commands and read responses.
    // - bufferIn: Pointer to the buffer containing the command data to be sent to the TPM.
    // - sizeIn: Size of the input buffer in bytes.
    // - bufferOut: Pointer to the buffer where the TPM's response will be stored.
    // - sizeOut: Pointer to a variable that on input specifies the maximum size of the output buffer,
    //            and on output reflects the actual size of the data written to the output buffer.
    //
    // Returns:
    // - STATUS_SUCCESS: The command was successfully sent and a response was received.
    // - STATUS_DEVICE_BUSY: The device is busy or in idle mode.
    // - STATUS_NOT_SUPPORTED: The command or TPM version aren't supported.
    // - STATUS_BUFFER_TOO_SMALL: The response is too small.
    //
    NTSTATUS TisCommand(
        _In_ TIS_PC_REGISTERS* tisReg,
        _In_reads_bytes_(sizeIn) const uint8_t* bufferIn,
        _In_ uint32_t sizeIn,
        _Inout_updates_bytes_(*sizeOut) uint8_t* bufferOut,
        _Inout_ uint32_t* sizeOut
    )
    {
        NTSTATUS status = this->TisPrepareCommand(tisReg);
        if (NT_ERROR(status))
        {
            DbgError("Tpm2 is not ready for a command.\n");
            return STATUS_DEVICE_BUSY;
        }

        //
        // Send the command data to Tpm
        //
        uint32_t i = 0;
        uint16_t burstCount = 0;
        while (i < sizeIn)
        {
            status = this->TisReadBurstCount(tisReg, &burstCount);
            if (NT_ERROR(status))
            {
                status = STATUS_DEVICE_BUSY;
                goto Exit;
            }

            for (; burstCount > 0 && i < sizeIn; burstCount--)
            {
                (void)mmio::Write((uintptr_t)&tisReg->DataFifo, sizeof(uint8_t), const_cast<uint8_t*>(bufferIn + i));
                i++;
            }
        }

        //
        // Check the Tpm status STS_EXPECT change from 1 to 0
        //
        status = this->TisWaitRegisterBits(
            &tisReg->Status,
            (uint8_t)TIS_PC_VALID,
            TIS_PC_STS_EXPECT,
            TIS_TIMEOUT_C
        );

        if (NT_ERROR(status))
        {
            DbgError("The send buffer is too small for a command.\n");
            status = STATUS_BUFFER_TOO_SMALL;
            goto Exit;
        }

        //
        // Executed the TPM command and waiting for the response data ready
        //
        uint8_t bit = TIS_PC_STS_GO;
        (void)mmio::Write((uintptr_t)&tisReg->Status, sizeof(uint8_t), &bit);

        //
        // NOTE: That may take many seconds to minutes for certain commands, such as key generation.
        //
        status = this->TisWaitRegisterBits(
            &tisReg->Status,
            (uint8_t)(TIS_PC_VALID | TIS_PC_STS_DATA),
            0,
            TIS_TIMEOUT_MAX
        );

        if (NT_ERROR(status))
        {
            //
            // dataAvail check timeout. Cancel the currently executing command by writing commandCancel,
            // Expect TPM_RC_CANCELLED or successfully completed response.
            //
            DbgError("Timed out while waiting for TPM. Trying to cancel the command.\n");

            uint32_t bit32 = TIS_PC_STS_CANCEL;
            (void)mmio::Write((uintptr_t)&tisReg->Status, sizeof(uint32_t), &bit32);
            status = this->TisWaitRegisterBits(
                &tisReg->Status,
                (uint8_t)(TIS_PC_VALID | TIS_PC_STS_DATA),
                0,
                TIS_TIMEOUT_B
            );
            //
            // Do not clear CANCEL bit here because Writes of 0 to this bit are ignored
            //
            if (NT_ERROR(status))
            {
                //
                // Cancel executing command fail to get any response
                // Try to abort the command with write of a 1 to commandReady in Command Execution state
                //
                status = STATUS_DEVICE_BUSY;
                goto Exit;
            }
        }

        //
        // Get response data header
        //
        i = 0;
        burstCount = 0;
        while (i < sizeof(TPM2_RESPONSE_HEADER))
        {
            status = this->TisReadBurstCount(tisReg, &burstCount);
            if (NT_ERROR(status)) {
                status = STATUS_DEVICE_BUSY;
                goto Exit;
            }

            for (; burstCount > 0; burstCount--)
            {
                (void)mmio::Read((uintptr_t)&tisReg->DataFifo, sizeof(uint8_t), (bufferOut + i));
                i++;
                if (i == sizeof(TPM2_RESPONSE_HEADER))
                {
                    break;
                }
            }
        }
    
        //
        // Check the response data header (tag,parasize and returncode )
        //
        uint16_t data16 = 0;
        memcpy(&data16, bufferOut, sizeof(uint16_t));
        // TPM2 should not use this RSP_COMMAND
        if (_byteswap_ushort(data16) == TPM_ST_RSP_COMMAND)
        {
            Dbg("TPM_ST_RSP error - %x.\n", TPM_ST_RSP_COMMAND);
            status = STATUS_NOT_SUPPORTED;
            goto Exit;
        }

        uint32_t data32 = 0;
        memcpy(&data32, (bufferOut + 2), sizeof(uint32_t));
        uint32_t tpmOutSize = _byteswap_ulong(data32);
        if (*sizeOut < tpmOutSize)
        {
            status = STATUS_BUFFER_TOO_SMALL;
            goto Exit;
        }

        *sizeOut = tpmOutSize;
        //
        // Continue reading the remaining data
        //
        while (i < tpmOutSize)
        {
            for (; burstCount > 0; burstCount--)
            {
                (void)mmio::Read((uintptr_t)&tisReg->DataFifo, sizeof(uint8_t), (bufferOut + i));
                i++;
                if (i == tpmOutSize)
                {
                    status = STATUS_SUCCESS;
                    goto Exit;
                }
            }

            status = this->TisReadBurstCount(tisReg, &burstCount);
            if (NT_ERROR(status))
            {
                status = STATUS_DEVICE_BUSY;
                goto Exit;
            }
        }

    Exit:

        bit = TIS_PC_STS_READY;
        (void)mmio::Write((uintptr_t)&tisReg->Status, sizeof(uint8_t), &bit);
        return status;
    }


};
```

`tpm-mmio/tpm-mmio.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E0009D17-7436-43CE-BDE9-41CDFFB443DC}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>tpm_mmio</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_Klib.lib;cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Aux_Klib.lib;cng.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="acpi.hpp" />
    <ClInclude Include="crb.hpp" />
    <ClInclude Include="defs.hpp" />
    <ClInclude Include="mmio.hpp" />
    <ClInclude Include="stdint.hpp" />
    <ClInclude Include="tis.hpp" />
    <ClInclude Include="tpm.hpp" />
    <ClInclude Include="ptp.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`tpm-mmio/tpm-mmio.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\tpm">
      <UniqueIdentifier>{a223b4ad-2c9c-4979-bf59-8520f2a02fdc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\memory">
      <UniqueIdentifier>{1ab0aff3-34a9-4235-95ca-942bd2269434}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\tpm\crb">
      <UniqueIdentifier>{e2d53bc2-ccd2-4523-9753-21ca492a5ac1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\tpm\fifo">
      <UniqueIdentifier>{8da0997e-ed31-4d98-938f-80e430550ff4}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdint.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="tpm.hpp">
      <Filter>Header Files\tpm</Filter>
    </ClInclude>
    <ClInclude Include="ptp.hpp">
      <Filter>Header Files\tpm</Filter>
    </ClInclude>
    <ClInclude Include="mmio.hpp">
      <Filter>Header Files\memory</Filter>
    </ClInclude>
    <ClInclude Include="crb.hpp">
      <Filter>Header Files\tpm\crb</Filter>
    </ClInclude>
    <ClInclude Include="tis.hpp">
      <Filter>Header Files\tpm\fifo</Filter>
    </ClInclude>
    <ClInclude Include="acpi.hpp">
      <Filter>Header Files\tpm</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`tpm-mmio/tpm-mmio.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TestCertificate>
    </TestCertificate>
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`tpm-mmio/tpm.hpp`:

```hpp
#pragma once

class Tpm
{
private:

	//
	// TPM register base address.
	//
	uintptr_t tpmBaseAddress = 0;

    //
    // Cached PTP pointer.
    //
	TpmPtp* ptpInterface = nullptr;

    //
    // Reads a value of type T from an unaligned memory address.
    // This function uses RtlCopyMemory to safely read the value without assuming alignment.
    //
    // Parameters:
    // - source: Pointer to the unaligned memory address from which the value is to be read.
    //
    // Returns:
    // - T: The value read from the unaligned memory address.
    //
    template<typename T>
    T ReadUnaligned(const void* source)
    {
        T value;
        RtlCopyMemory(&value, source, sizeof(T));
        return value;
    }

    //
    // Writes a value of type T to an unaligned memory address.
    // This function uses RtlCopyMemory to safely write the value without assuming alignment.
    //
    // Parameters:
    // - destination: Pointer to the unaligned memory address to which the value is to be written.
    // - value: The value to be written to the unaligned memory address.
    //
    template<typename T>
    void WriteUnaligned(void* destination, T value)
    {
        RtlCopyMemory(destination, &value, sizeof(T));
    }
    
    //
    // Submits a command to the TPM through the appropriate TPM interface based on the configured interface type.
    // This function routes the command to either a CRB or FIFO interface handling routine.
    //
    // Parameters:
    // - inputParameterBlockSize: Size of the input parameter block.
    // - inputParameterBlock: Pointer to the input parameters for the TPM command.
    // - outputParameterBlockSize: Pointer to the size of the output parameter block, which may be updated.
    // - outputParameterBlock: Pointer to the buffer that will receive the TPM command's output.
    //
    // Returns:
    // - STATUS_SUCCESS: Command successfully sent and response received.
    // - STATUS_UNSUCCESSFUL: PTP interface not initialized or other failure.
    // - STATUS_DEVICE_NOT_CONNECTED: No valid PTP interface is connected.
    // - STATUS_INVALID_PARAMETER: Unknown or unsupported PTP interface type.
    //
    NTSTATUS SubmitCommand(
        _In_ uint32_t inputParameterBlockSize,
        _In_reads_bytes_(inputParameterBlockSize) const uint8_t* inputParameterBlock,
        _Inout_ uint32_t* outputParameterBlockSize,
        _Out_writes_bytes_(*outputParameterBlockSize) uint8_t* outputParameterBlock
    )
    {
        PTP_INTERFACE_TYPE interfaceType = this->ptpInterface->cachedInterface;

        if (interfaceType == PTP_INTERFACE_TYPE::PtpInterfaceTis || interfaceType == PTP_INTERFACE_TYPE::PtpInterfaceFifo) 
        {
            TpmTis tisInterface;           
            return tisInterface.TisCommand(
                (TIS_PC_REGISTERS*)this->tpmBaseAddress,
                inputParameterBlock,
                inputParameterBlockSize,
                outputParameterBlock,
                outputParameterBlockSize
            );
        }
        else if (interfaceType == PTP_INTERFACE_TYPE::PtpInterfaceCrb) 
        {
            TpmCrb crbInterface(this->ptpInterface);
            return crbInterface.CrbCommand(
                (PTP_CRB_REGISTERS*)this->tpmBaseAddress,
                inputParameterBlock,
                inputParameterBlockSize,
                outputParameterBlock,
                outputParameterBlockSize
            );  
        }
        else if (interfaceType == PTP_INTERFACE_TYPE::PtpInterfaceNull) 
        {
            return STATUS_DEVICE_NOT_CONNECTED; 
        }
        else 
        {
            DbgError("Unknown PTP interface type.\n");
            return STATUS_INVALID_PARAMETER; 
        }
    }

public:

	~Tpm()
	{
		delete this->ptpInterface;
	}

    //
    // Instantiate and initialize TpmPtp class then cache pointer to access PTP interface.
    // 
    // Returns:
    // - true: Instantiated and initialized successfully.
    // - false: Failed to instantiate or initialize.
    //
    bool Init()
    {
        if (!acpi::GetTpm2PhysicalAddress(&this->tpmBaseAddress))
        {
            // Already prints detailed error inside function.
            return false;
        }
        this->ptpInterface = new TpmPtp(this->tpmBaseAddress);
        if (!this->ptpInterface)
        {
            DbgError("Failed to instantiate TpmPtp class.\n");
            return false;
        }
        if (!this->ptpInterface->Init())
        {
            DbgError("Failed to initialize TpmPtp class.\n");
            return false;
        }
        Dbg("Instantiated and initialized TpmPtp class.\n");
        return true;
    }
    
    //
    // Reads the public area of a TPM object.
    //
    // This function retrieves the public area of a TPM object specified by its handle.
    // It constructs the command to send to the TPM, sends the command, receives the response,
    // and extracts the public area, the name, and the qualified name of the object.
    //
    // Parameters:
    // - objectHandle: Handle to the TPM object whose public area is to be read.
    // - outPublic: Pointer to a TPM2B_PUBLIC structure that will receive the public area of the object.
    // - name: Pointer to a TPM2B_NAME structure that will receive the name of the object.
    // - qualifiedName: Pointer to a TPM2B_NAME structure that will receive the qualified name of the object.
    //
    // Returns:
    // - STATUS_SUCCESS: The public area was successfully read.
    // - STATUS_UNSUCCESSFUL: An error occurred while reading the public area.
    // - STATUS_BUFFER_TOO_SMALL: recvBuffer size was too small.
    // - STATUS_INVALID_PARAMETER: One or more of the parameters are invalid.
    // - STATUS_DEVICE_BUSY: TPM device exception.
    // - STATUS_NOT_SUPPORTED: Read operation not supported.
    //
    NTSTATUS ReadPublic(
        _In_ TPMI_DH_OBJECT objectHandle,
        _Out_ TPM2B_PUBLIC* outPublic,
        _Out_ TPM2B_NAME* name,
        _Out_ TPM2B_NAME* qualifiedName
    )
    {
        //
        // Construct command
        //
        TPM2_READ_PUBLIC_COMMAND sendBuffer = { { 0 } };

        sendBuffer.Header.tag = _byteswap_ushort(TPM_ST_NO_SESSIONS);
        sendBuffer.Header.commandCode = _byteswap_ulong(TPM_CC_ReadPublic);

        sendBuffer.ObjectHandle = _byteswap_ulong(objectHandle);

        uint32_t sendBufferSize = (uint32_t)sizeof(sendBuffer);
        sendBuffer.Header.paramSize = _byteswap_ulong(sendBufferSize);

        //
        // send Tpm command
        //
        TPM2_READ_PUBLIC_RESPONSE recvBuffer = { { 0 } };

        uint32_t recvBufferSize = sizeof(recvBuffer);
        NTSTATUS status = this->SubmitCommand(sendBufferSize, (uint8_t*)&sendBuffer, &recvBufferSize, (uint8_t*)&recvBuffer);
        if (NT_ERROR(status)) 
        {
            return status;
        }

        if (recvBufferSize < sizeof(TPM2_RESPONSE_HEADER)) 
        {
            DbgError("ReadPublic - recvBufferSize Error - %x.\n", recvBufferSize);
            return STATUS_BUFFER_TOO_SMALL;
        }

        TPM_RC responseCode = _byteswap_ulong(recvBuffer.Header.responseCode);
        if (responseCode != TPM_RC_SUCCESS) 
        {
            DbgError("ReadPublic - responseCode - 0x%08x.\n", _byteswap_ulong(recvBuffer.Header.responseCode));
        }

        switch (responseCode) {
        case TPM_RC_SUCCESS:
            // return data
            break;
        case TPM_RC_SEQUENCE:
            // objectHandle references a sequence object
            return STATUS_INVALID_PARAMETER;
        default:
            return STATUS_DEVICE_BUSY;
        }

        //
        // Basic check
        //
        uint16_t outPublicSize = _byteswap_ushort(recvBuffer.OutPublic.size);
        if (outPublicSize > sizeof(TPMT_PUBLIC)) 
        {
            DbgError("ReadPublic - outPublicSize error %x.\n", outPublicSize);
            return STATUS_DEVICE_BUSY;
        }

        uint16_t nameSize = _byteswap_ushort(
            this->ReadUnaligned<uint16_t>(
                (uint16_t*)((uint8_t*)&recvBuffer + sizeof(TPM2_RESPONSE_HEADER) +
                    sizeof(uint16_t) + outPublicSize)
            )
        );
        if (nameSize > sizeof(TPMU_NAME)) 
        {
            DbgError("ReadPublic - nameSize error %x.\n", nameSize);
            return STATUS_DEVICE_BUSY;
        }

        uint16_t qualifiedNameSize = _byteswap_ushort(
            this->ReadUnaligned<uint16_t>(
                (uint16_t*)((uint8_t*)&recvBuffer + sizeof(TPM2_RESPONSE_HEADER) +
                    sizeof(uint16_t) + outPublicSize +
                    sizeof(uint16_t) + nameSize)
            )
        );
        if (qualifiedNameSize > sizeof(TPMU_NAME)) 
        {
            DbgError("ReadPublic - qualifiedNameSize error %x.\n", qualifiedNameSize);
            return STATUS_DEVICE_BUSY;
        }

        if (recvBufferSize != sizeof(TPM2_RESPONSE_HEADER) + sizeof(uint16_t) + outPublicSize + sizeof(uint16_t) + nameSize + sizeof(uint16_t) + qualifiedNameSize) 
        {
            DbgError("ReadPublic - recvBufferSize %x Error - outPublicSize %x, nameSize %x, qualifiedNameSize %x.\n", recvBufferSize, outPublicSize, nameSize, qualifiedNameSize);
            return STATUS_DEVICE_BUSY;
        }

        //
        // Return the response
        //
        uint8_t* buffer = (uint8_t*)&recvBuffer.OutPublic;
        memcpy(outPublic, &recvBuffer.OutPublic, sizeof(uint16_t) + outPublicSize);
        outPublic->size = outPublicSize;
        outPublic->publicArea.type = _byteswap_ushort(outPublic->publicArea.type);
        outPublic->publicArea.nameAlg = _byteswap_ushort(outPublic->publicArea.nameAlg);

        this->WriteUnaligned<uint32_t>((uint32_t*)&outPublic->publicArea.objectAttributes, _byteswap_ulong(this->ReadUnaligned<uint32_t>((uint32_t*)&outPublic->publicArea.objectAttributes)));

        buffer = (uint8_t*)&recvBuffer.OutPublic.publicArea.authPolicy;
        outPublic->publicArea.authPolicy.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
        buffer += sizeof(uint16_t);

        if (outPublic->publicArea.authPolicy.size > sizeof(TPMU_HA)) 
        {
            DbgError("ReadPublic - authPolicy.size error %x.\n", outPublic->publicArea.authPolicy.size);
            return STATUS_DEVICE_BUSY;
        }

        memcpy(outPublic->publicArea.authPolicy.buffer, buffer, outPublic->publicArea.authPolicy.size);
        buffer += outPublic->publicArea.authPolicy.size;

        // TPMU_PUBLIC_PARMS
        switch (outPublic->publicArea.type) 
        {
        case TPM_ALG_KEYEDHASH:
            outPublic->publicArea.parameters.keyedHashDetail.scheme.scheme = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.keyedHashDetail.scheme.scheme) 
            {
            case TPM_ALG_HMAC:
                outPublic->publicArea.parameters.keyedHashDetail.scheme.details.hmac.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_XOR:
                outPublic->publicArea.parameters.keyedHashDetail.scheme.details. xor .hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.keyedHashDetail.scheme.details. xor .kdf = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

        case TPM_ALG_SYMCIPHER:
            outPublic->publicArea.parameters.symDetail.algorithm = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.symDetail.algorithm) 
            {
            case TPM_ALG_AES:
                outPublic->publicArea.parameters.symDetail.keyBits.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.symDetail.mode.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_SM4:
                outPublic->publicArea.parameters.symDetail.keyBits.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.symDetail.mode.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_XOR:
                outPublic->publicArea.parameters.symDetail.keyBits. xor = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            break;
        case TPM_ALG_RSA:
            outPublic->publicArea.parameters.rsaDetail.symmetric.algorithm = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.rsaDetail.symmetric.algorithm) 
            {
            case TPM_ALG_AES:
                outPublic->publicArea.parameters.rsaDetail.symmetric.keyBits.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.rsaDetail.symmetric.mode.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_SM4:
                outPublic->publicArea.parameters.rsaDetail.symmetric.keyBits.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.rsaDetail.symmetric.mode.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            outPublic->publicArea.parameters.rsaDetail.scheme.scheme = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.rsaDetail.scheme.scheme) 
            {
            case TPM_ALG_RSASSA:
                outPublic->publicArea.parameters.rsaDetail.scheme.details.rsassa.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_RSAPSS:
                outPublic->publicArea.parameters.rsaDetail.scheme.details.rsapss.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_RSAES:
                break;
            case TPM_ALG_OAEP:
                outPublic->publicArea.parameters.rsaDetail.scheme.details.oaep.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            outPublic->publicArea.parameters.rsaDetail.keyBits = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            outPublic->publicArea.parameters.rsaDetail.exponent = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint32_t);
            break;
        case TPM_ALG_ECC:
            outPublic->publicArea.parameters.eccDetail.symmetric.algorithm = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.eccDetail.symmetric.algorithm) 
            {
            case TPM_ALG_AES:
                outPublic->publicArea.parameters.eccDetail.symmetric.keyBits.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.eccDetail.symmetric.mode.aes = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_SM4:
                outPublic->publicArea.parameters.eccDetail.symmetric.keyBits.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                outPublic->publicArea.parameters.eccDetail.symmetric.mode.SM4 = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            outPublic->publicArea.parameters.eccDetail.scheme.scheme = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.eccDetail.scheme.scheme) 
            {
            case TPM_ALG_ECDSA:
                outPublic->publicArea.parameters.eccDetail.scheme.details.ecdsa.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_ECDAA:
                outPublic->publicArea.parameters.eccDetail.scheme.details.ecdaa.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_ECSCHNORR:
                outPublic->publicArea.parameters.eccDetail.scheme.details.ecSchnorr.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_ECDH:
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            outPublic->publicArea.parameters.eccDetail.curveID = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            outPublic->publicArea.parameters.eccDetail.kdf.scheme = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            switch (outPublic->publicArea.parameters.eccDetail.kdf.scheme) 
            {
            case TPM_ALG_MGF1:
                outPublic->publicArea.parameters.eccDetail.kdf.details.mgf1.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_KDF1_SP800_108:
                outPublic->publicArea.parameters.eccDetail.kdf.details.kdf1_sp800_108.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_KDF1_SP800_56a:
                outPublic->publicArea.parameters.eccDetail.kdf.details.kdf1_SP800_56a.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_KDF2:
                outPublic->publicArea.parameters.eccDetail.kdf.details.kdf2.hashAlg = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
                buffer += sizeof(uint16_t);
                break;
            case TPM_ALG_NULL:
                break;
            default:
                return STATUS_NOT_SUPPORTED;
            }

            break;
        default:
            return STATUS_NOT_SUPPORTED;
        }

        // TPMU_PUBLIC_ID
        switch (outPublic->publicArea.type) 
        {
        case TPM_ALG_KEYEDHASH:
            outPublic->publicArea.unique.keyedHash.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            if (outPublic->publicArea.unique.keyedHash.size > sizeof(TPMU_HA)) 
            {
                DbgError("ReadPublic - keyedHash.size error %x.\n", outPublic->publicArea.unique.keyedHash.size);
                return STATUS_DEVICE_BUSY;
            }

            memcpy(outPublic->publicArea.unique.keyedHash.buffer, buffer, outPublic->publicArea.unique.keyedHash.size);
            buffer += outPublic->publicArea.unique.keyedHash.size;
            break;
        case TPM_ALG_SYMCIPHER:
            outPublic->publicArea.unique.sym.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            if (outPublic->publicArea.unique.sym.size > sizeof(TPMU_HA)) 
            {
                DbgError("ReadPublic - sym.size error %x.\n", outPublic->publicArea.unique.sym.size);
                return STATUS_DEVICE_BUSY;
            }

            memcpy(outPublic->publicArea.unique.sym.buffer, buffer, outPublic->publicArea.unique.sym.size);
            buffer += outPublic->publicArea.unique.sym.size;
            break;
        case TPM_ALG_RSA:
            outPublic->publicArea.unique.rsa.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            if (outPublic->publicArea.unique.rsa.size > MAX_RSA_KEY_BYTES) 
            {
                DbgError("ReadPublic - rsa.size error %x.\n", outPublic->publicArea.unique.rsa.size);
                return STATUS_DEVICE_BUSY;
            }

            memcpy(outPublic->publicArea.unique.rsa.buffer, buffer, outPublic->publicArea.unique.rsa.size);
            buffer += outPublic->publicArea.unique.rsa.size;
            break;
        case TPM_ALG_ECC:
            outPublic->publicArea.unique.ecc.x.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            if (outPublic->publicArea.unique.ecc.x.size > MAX_ECC_KEY_BYTES) 
            {
                DbgError("ReadPublic - ecc.x.size error %x.\n", outPublic->publicArea.unique.ecc.x.size);
                return STATUS_DEVICE_BUSY;
            }

            memcpy(outPublic->publicArea.unique.ecc.x.buffer, buffer, outPublic->publicArea.unique.ecc.x.size);
            buffer += outPublic->publicArea.unique.ecc.x.size;
            outPublic->publicArea.unique.ecc.y.size = _byteswap_ushort(this->ReadUnaligned<uint16_t>((uint16_t*)buffer));
            buffer += sizeof(uint16_t);
            if (outPublic->publicArea.unique.ecc.y.size > MAX_ECC_KEY_BYTES) 
            {
                DbgError("ReadPublic - ecc.y.size error %x.\n", outPublic->publicArea.unique.ecc.y.size);
                return STATUS_DEVICE_BUSY;
            }

            memcpy(outPublic->publicArea.unique.ecc.y.buffer, buffer, outPublic->publicArea.unique.ecc.y.size);
            buffer += outPublic->publicArea.unique.ecc.y.size;
            break;
        default:
            return STATUS_NOT_SUPPORTED;
        }

        memcpy(name->name, (uint8_t*)&recvBuffer + sizeof(TPM2_RESPONSE_HEADER) + sizeof(uint16_t) + outPublicSize + sizeof(uint16_t), nameSize);
        name->size = nameSize;

        memcpy(qualifiedName->name, (uint8_t*)&recvBuffer + sizeof(TPM2_RESPONSE_HEADER) + sizeof(uint16_t) + outPublicSize + sizeof(uint16_t) + nameSize + sizeof(uint16_t), qualifiedNameSize);
        qualifiedName->size = qualifiedNameSize;

        return STATUS_SUCCESS;
    }

};


```