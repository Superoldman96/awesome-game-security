Project Path: arc_gmh5225_BE-Shellcode_wwvm0xwq

Source Tree:

```txt
arc_gmh5225_BE-Shellcode_wwvm0xwq
├── BEShellcode
│   ├── BEShellcode.vcxproj
│   ├── BEShellcode.vcxproj.filters
│   ├── BEShellcode.vcxproj.user
│   ├── beshellcode.cpp
│   ├── beshellcode.h
│   ├── main.cpp
│   ├── misc.cpp
│   ├── misc.h
│   ├── modules.cpp
│   ├── modules.h
│   ├── nt.cpp
│   ├── nt.h
│   ├── sigs.cpp
│   ├── sigs.h
│   ├── systhreadfinder.cpp
│   ├── systhreadfinder.h
│   ├── thread_scan.cpp
│   ├── thread_scan.h
│   ├── veh.cpp
│   └── veh.h
├── BEShellcode.sln
└── README.md

```

`BEShellcode.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BEShellcode", "BEShellcode\BEShellcode.vcxproj", "{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Debug|x64.ActiveCfg = Debug|x64
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Debug|x64.Build.0 = Debug|x64
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Debug|x86.ActiveCfg = Debug|Win32
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Debug|x86.Build.0 = Debug|Win32
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Release|x64.ActiveCfg = Release|x64
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Release|x64.Build.0 = Release|x64
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Release|x86.ActiveCfg = Release|Win32
		{8DA4F0E6-546F-4401-8077-7AE1FB486B5F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F8CC6656-7470-4BC2-985B-12537E1E56DA}
	EndGlobalSection
EndGlobal

```

`BEShellcode/BEShellcode.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{8da4f0e6-546f-4401-8077-7ae1fb486b5f}</ProjectGuid>
    <RootNamespace>BEShellcode</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="beshellcode.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="misc.cpp" />
    <ClCompile Include="modules.cpp" />
    <ClCompile Include="nt.cpp" />
    <ClCompile Include="sigs.cpp" />
    <ClCompile Include="systhreadfinder.cpp" />
    <ClCompile Include="thread_scan.cpp" />
    <ClCompile Include="veh.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="beshellcode.h" />
    <ClInclude Include="misc.h" />
    <ClInclude Include="modules.h" />
    <ClInclude Include="nt.h" />
    <ClInclude Include="sigs.h" />
    <ClInclude Include="systhreadfinder.h" />
    <ClInclude Include="thread_scan.h" />
    <ClInclude Include="veh.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`BEShellcode/BEShellcode.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Quelldateien">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Headerdateien">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Headerdateien\beshellcode">
      <UniqueIdentifier>{2d2bce5e-0664-4d0a-8243-be1bdecdc6f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\veh">
      <UniqueIdentifier>{0af2a934-9295-49f9-bcb1-a7f87289d8bc}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\nt">
      <UniqueIdentifier>{3d0acb10-7fe3-49a9-997a-6b6b07c6ee21}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\systhreadfinder">
      <UniqueIdentifier>{e3d4741f-b9e8-46ba-b538-1904d07aaebd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\misc">
      <UniqueIdentifier>{90a3a9b7-8101-45e7-b9c2-dfeb5d213a83}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\module_check">
      <UniqueIdentifier>{b6a0f196-a7fc-4c43-b08b-77c7bc950faa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\signatures">
      <UniqueIdentifier>{c85a09b5-1b0e-4607-a26a-dc99644f8a64}</UniqueIdentifier>
    </Filter>
    <Filter Include="Headerdateien\beshellcode\thread_scan">
      <UniqueIdentifier>{80951c72-b2ed-47d3-9df3-2f2b225cd32b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Quelldateien</Filter>
    </ClCompile>
    <ClCompile Include="beshellcode.cpp">
      <Filter>Headerdateien\beshellcode</Filter>
    </ClCompile>
    <ClCompile Include="veh.cpp">
      <Filter>Headerdateien\beshellcode\veh</Filter>
    </ClCompile>
    <ClCompile Include="nt.cpp">
      <Filter>Headerdateien\nt</Filter>
    </ClCompile>
    <ClCompile Include="systhreadfinder.cpp">
      <Filter>Headerdateien\beshellcode\systhreadfinder</Filter>
    </ClCompile>
    <ClCompile Include="misc.cpp">
      <Filter>Headerdateien\beshellcode\misc</Filter>
    </ClCompile>
    <ClCompile Include="modules.cpp">
      <Filter>Headerdateien\beshellcode\module_check</Filter>
    </ClCompile>
    <ClCompile Include="sigs.cpp">
      <Filter>Headerdateien\beshellcode\signatures</Filter>
    </ClCompile>
    <ClCompile Include="thread_scan.cpp">
      <Filter>Headerdateien\beshellcode\thread_scan</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="beshellcode.h">
      <Filter>Headerdateien\beshellcode</Filter>
    </ClInclude>
    <ClInclude Include="veh.h">
      <Filter>Headerdateien\beshellcode\veh</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Headerdateien\nt</Filter>
    </ClInclude>
    <ClInclude Include="systhreadfinder.h">
      <Filter>Headerdateien\beshellcode\systhreadfinder</Filter>
    </ClInclude>
    <ClInclude Include="misc.h">
      <Filter>Headerdateien\beshellcode\misc</Filter>
    </ClInclude>
    <ClInclude Include="modules.h">
      <Filter>Headerdateien\beshellcode\module_check</Filter>
    </ClInclude>
    <ClInclude Include="sigs.h">
      <Filter>Headerdateien\beshellcode\signatures</Filter>
    </ClInclude>
    <ClInclude Include="thread_scan.h">
      <Filter>Headerdateien\beshellcode\thread_scan</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`BEShellcode/BEShellcode.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`BEShellcode/beshellcode.cpp`:

```cpp
#include "beshellcode.h"
void beshellcode::report(report_ids report_id) {
	printf("Triggered report id: %x\n", report_id);
}

HANDLE beshellcode::add_exception_handler() {
	PVOID handler = AddVectoredExceptionHandler(1, veh::be_handler);
	if (handler != INVALID_HANDLE_VALUE) {
		HMODULE user32 = LoadLibraryA("USER32.dll");
		HMODULE kernel32 = LoadLibraryA("KERNEL32.dll");
		HMODULE win32u = LoadLibraryA("win32u.dll");
		HMODULE ntdll = LoadLibraryA("ntdll.dll");
		HMODULE ucrtbase = LoadLibraryA("ucrtbase.dll");
		
		veh::add_func((uintptr_t)GetProcAddress(user32, "GetAsyncKeyState"));	
		veh::add_func((uintptr_t)GetProcAddress(user32, "GetCursorPos"));
		veh::add_func((uintptr_t)GetProcAddress(kernel32, "IsBadReadPtr"));
		veh::add_func((uintptr_t)GetProcAddress(win32u, "NtUserGetAsyncKeyState"));
		veh::add_func((uintptr_t)GetProcAddress(user32, "GetForegroundWindow"));
		veh::add_func((uintptr_t)GetProcAddress(user32, "CallWindowProcW"));
		veh::add_func((uintptr_t)GetProcAddress(win32u, "NtUserPeekMessage"));
		veh::add_func((uintptr_t)GetProcAddress(ntdll, "NtSetEvent"));
		veh::add_func((uintptr_t)GetProcAddress(ucrtbase, "__stdio_common_vsprintf_s"));
		veh::add_func((uintptr_t)GetProcAddress(ucrtbase, "sqrtf"));
		
	
	}
	

	/*
	Some additional d3d11 + dxgi + game specific stuff
	*/
	return (HANDLE)handler;
}
void beshellcode::remove_exception_handler(HANDLE handle) {
	if(handle != INVALID_HANDLE_VALUE)
		RemoveVectoredExceptionHandler(handle);
}

void beshellcode::find_system_threads()
{
	if (systhreadfinder::found_sys_thread(10)) {
		report(report_ids::HiddenSystemThread);
	}
}

void beshellcode::check_KiUserExceptionDispatcher_hook() {
	misc::check_KiUserExceptionDispatcher_hook();
}
void beshellcode::check_modules() {
	module_check::check_modules();
}
void beshellcode::function_integrity() {
	misc::check_integrity();
}
void beshellcode::scan_sigs() {
	signatures::scan_sigs();
}
void beshellcode::scan_threads() {
	thread_scan::scan_threads();
}
```

`BEShellcode/beshellcode.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <tuple>
#include <vector>
#include "veh.h"
#include "systhreadfinder.h"
#include "misc.h"
#include "modules.h"
#include "sigs.h"
#include "thread_scan.h"
namespace beshellcode {
	enum class report_ids : uint8_t {
		IllegaleCaller, //BE -> 0x43
		HiddenSystemThread,
		KiUserExceptionDispatcherHook,
		BlacklistedDll,
		BlacklistedDriver,
		PatchedFunction,
		HitSignature,
		SuspendedThread,
		IllegalRip

	};
	void report(report_ids report_id);
	HANDLE add_exception_handler();
	void remove_exception_handler(HANDLE handle);
	void find_system_threads();
	void check_KiUserExceptionDispatcher_hook();
	void check_modules();
	void function_integrity();
	void scan_sigs();
	void scan_threads();
}
```

`BEShellcode/main.cpp`:

```cpp
#include "beshellcode.h"

int thread_main(HMODULE dll) {
    AllocConsole();
    FILE* f;
    freopen_s(&f, "CONOUT$", "w", stdout);
    printf("Detections:\n");
    beshellcode::find_system_threads();
    beshellcode::check_KiUserExceptionDispatcher_hook();
    beshellcode::check_modules();
    beshellcode::function_integrity();
    beshellcode::scan_threads();
    HANDLE handler = beshellcode::add_exception_handler(); //Shellcode is called multiple times. Hook will be restored after first call
    beshellcode::scan_sigs();
    system("pause");
    beshellcode::remove_exception_handler(handler);
    fclose(f);
    FreeConsole();
    FreeLibraryAndExitThread(dll, 0);
}

BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,  
    DWORD fdwReason,     
    LPVOID lpReserved) 
{

    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(0, 0, (LPTHREAD_START_ROUTINE)thread_main, hinstDLL, 0, 0);
        break;
    }
    return TRUE;

}

```

`BEShellcode/misc.cpp`:

```cpp
#include "misc.h"

void misc::check_KiUserExceptionDispatcher_hook() {
    DWORD* KiUserExceptionDispatcher = (DWORD*)GetProcAddress(GetModuleHandleA("ntdll.dll"), "KiUserExceptionDispatcher");
    if (*KiUserExceptionDispatcher == 0x58B48FC)// Make sure its not patched
    {
        uintptr_t PointedTo = *(uintptr_t*)((char*)KiUserExceptionDispatcher + KiUserExceptionDispatcher[1] + 8);
        if (PointedTo)
        {
            MEMORY_BASIC_INFORMATION mbi{ 0 };
            size_t returnsize;
            if ((NtQueryVirtualMemory(
                (HANDLE)-1i64,
                (PVOID)(PointedTo & 0xFFFFFFFFFFFFF000ui64),
                MemoryBasicInformation,
                &mbi,
                sizeof(mbi),
                &returnsize
            ) < 0) || mbi.State == MEM_COMMIT && (mbi.Protect & 4) != 0) {
                beshellcode::report(beshellcode::report_ids::KiUserExceptionDispatcherHook);
            }

        }
    }
    else
        beshellcode::report(beshellcode::report_ids::KiUserExceptionDispatcherHook);
}

void misc::check_integrity() {
    WORD* mem_cpy = (WORD*)GetProcAddress(GetModuleHandleA("vcruntime140.dll"), "memcpy");
    WORD* mem_cmp = (WORD*)GetProcAddress(GetModuleHandleA("vcruntime140.dll"), "memcmp");
    if ((mem_cpy && *mem_cpy == 0x25FF) || (mem_cmp && *mem_cmp == 0x25FF)) {
        beshellcode::report(beshellcode::report_ids::PatchedFunction);
    }
    WORD* curr_thread_id = (WORD*)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetCurrentThreadId");
    if (curr_thread_id && *curr_thread_id == 0x25FF) {
        beshellcode::report(beshellcode::report_ids::PatchedFunction);
    }
}

```

`BEShellcode/misc.h`:

```h
#pragma once
#include <Windows.h>
#include "nt.h"
#include "beshellcode.h"
namespace misc {
	void check_KiUserExceptionDispatcher_hook();
	void check_integrity();
}
```

`BEShellcode/modules.cpp`:

```cpp
#include "modules.h"
std::vector<std::string>black_list_dlls{
	"..\\..\\Plugins\\ZipUtility\\ThirdParty\\7zpp\\dll\\Win64\\7z.dll",
	"hal.dll",
	"nvToolsExt64_1.dll",
	"ws2detour_x96.dll",
	"networkdllx64.dll",
	"nxdetours_64.dll",
	"nvcompiler.dll",
	"wmp.dll",
	"Project1.dll",
	"RompseAssPussy.dll", //wtf
	"DxtoryMM_x64.dll",
	"mslib.dll",
	"C:\\Windows\\mscorlib.ni.dll",
	"frAQBc8W.dll",
	//some checks on OwClientdll
	"shimloader64.dll",
	"BE_DLL.dll"
};
std::vector<std::string>black_list_driver{
	"\\\\.\\Beep",
	"\\\\.\\Null"
};
void module_check::check_modules() {
	for(auto current_module: black_list_dlls){
		if (GetModuleHandleA(current_module.c_str())) {
			beshellcode::report(beshellcode::report_ids::BlacklistedDll);
		}
	}
	for (auto current_driver : black_list_driver) {
		if (CreateFileA(current_driver.c_str(), 0x80000000, 3, 0, 3, 0, 0) != INVALID_HANDLE_VALUE) {
			beshellcode::report(beshellcode::report_ids::BlacklistedDriver);
		}
	}
	uintptr_t gameoverlaybase = (uintptr_t)GetModuleHandleA("gameoverlayrenderer64.dll");
	if (gameoverlaybase) {
		PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(gameoverlaybase + ((PIMAGE_DOS_HEADER)gameoverlaybase)->e_lfanew);
		if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size > 0x2000) {
			beshellcode::report(beshellcode::report_ids::BlacklistedDll);
		}
	}

}
```

`BEShellcode/modules.h`:

```h
#pragma once
#include "beshellcode.h"

namespace module_check {
	void check_modules();
}
```

`BEShellcode/nt.cpp`:

```cpp
#include "nt.h"
int* nt::get_proc_list() {
	int* proc_list = NULL;
	ULONG proc_list_size = 0;
	NtQuerySystemInformation(SystemProcessInformation, proc_list, proc_list_size, &proc_list_size);
	int* buf = (int*)realloc(proc_list, proc_list_size);
	if (buf == NULL)
		return NULL;
	else
		proc_list = buf;
	NtQuerySystemInformation(SystemProcessInformation, proc_list, proc_list_size, &proc_list_size);
	return proc_list;
}
int* nt::get_driver_list() {
	int* driver_list = NULL;
	ULONG driver_list_size = 0;
	NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0xB, 0, driver_list_size, &driver_list_size);
	int* buf = (int*)realloc(driver_list, driver_list_size);
	if (buf == NULL)
		return NULL;
	else
		driver_list = buf;
	NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0xB, driver_list, driver_list_size, &driver_list_size);
	return driver_list;
}
std::vector<nt_modules>nt::get_module_list() {
	std::vector<nt_modules> modules_to_return;

	PPEB peb = (PPEB)__readgsqword(0x60);
	PPEB_LDR_DATA ldr = peb->Ldr;
	PLDR_DATA_TABLE_ENTRY current_module = NULL;
	PLIST_ENTRY list = ldr->InLoadOrderModuleList.Flink;
	while (list != NULL && list != &ldr->InLoadOrderModuleList) {
		current_module = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		nt_modules new_nt_module;
		new_nt_module.base = (uintptr_t)current_module->DllBase;
		new_nt_module.size = current_module->SizeOfImage;
		modules_to_return.push_back(new_nt_module);
		list = list->Flink;
	}
	return modules_to_return;
}
```

`BEShellcode/nt.h`:

```h
#pragma once
#include <Windows.h>
#include <SubAuth.h>
#include <vector>
#include <TlHelp32.h>


struct nt_modules {
	uintptr_t base;
	DWORD size;
};
namespace nt {
	int* get_proc_list();
	int* get_driver_list();
	std::vector<nt_modules>get_module_list();
	template <typename t>
	inline t scanpattern(BYTE* base, const ULONG size, char* pattern, BYTE rva) {
		const auto patternSize = strlen(pattern);

		for (DWORD i = {}; i < size - patternSize; i++)
		{
			for (DWORD j = {}; j < patternSize; j++)
			{
				if (*reinterpret_cast<BYTE*>(base + i + j) != static_cast<BYTE>(pattern[j]))
					break;

				if (j == patternSize - 1)
					return reinterpret_cast<t>(base) + i + rva;
			}
		}

		return 0;
	}
}

typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
} VM_COUNTERS;



typedef struct _CLIENT_ID
{
	PVOID UniqueProcess;
	PVOID UniqueThread;
} CLIENT_ID, * PCLIENT_ID;


typedef struct
{
	FILETIME ProcessorTime;
	FILETIME UserTime;
	FILETIME CreateTime;
	ULONG WaitTime;
#ifdef _WIN64
	ULONG pad1;
#endif
	PVOID StartAddress;
	CLIENT_ID Client_Id;
	LONG CurrentPriority;
	LONG BasePriority;
	ULONG ContextSwitchesPerSec;
	ULONG ThreadState;
	ULONG ThreadWaitReason;
	ULONG pad2;
} SYSTEM_THREAD_INFORMATION;

typedef struct
{
	ULONG NextOffset;
	ULONG ThreadCount;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	FILETIME CreateTime;
	FILETIME UserTime;
	FILETIME KernelTime;
	UNICODE_STRING ImageName;
	long BasePriority;
#ifdef _WIN64
	ULONG pad1;
#endif
	ULONG ProcessId;
#ifdef _WIN64
	ULONG pad2;
#endif
	ULONG InheritedFromProcessId;
#ifdef _WIN64
	ULONG pad3;
#endif
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	VM_COUNTERS VirtualMemoryCounters;
	ULONG_PTR PrivatePageCount;
	IO_COUNTERS IoCounters;
	SYSTEM_THREAD_INFORMATION ThreadInfos[1];
} SYSTEM_PROCESS_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemBasicInformation = 0,
	SystemPerformanceInformation = 2,
	SystemTimeOfDayInformation = 3,
	SystemProcessInformation = 5,
	SystemProcessorPerformanceInformation = 8,
	SystemInterruptInformation = 23,
	SystemExceptionInformation = 33,
	SystemRegistryQuotaInformation = 37,
	SystemLookasideInformation = 45,
	SystemCodeIntegrityInformation = 103,
	SystemPolicyInformation = 134,
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

extern "C" NTSTATUS NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
typedef enum _MEMORY_INFORMATION_CLASS {
	MemoryBasicInformation
} MEMORY_INFORMATION_CLASS;
extern "C" NTSYSCALLAPI NTSTATUS NtQueryVirtualMemory(
	HANDLE                   ProcessHandle,
	PVOID                    BaseAddress,
	MEMORY_INFORMATION_CLASS MemoryInformationClass,
	PVOID                    MemoryInformation,
	SIZE_T                   MemoryInformationLength,
	PSIZE_T                  ReturnLength
);
typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	PVOID RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;
typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID    Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;


typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	HANDLE SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
	BOOLEAN ShutdownInProgress;
	HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{

} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB
{
	BOOLEAN InheritedAddressSpace;
	BOOLEAN ReadImageFileExecOptions;
	BOOLEAN BeingDebugged;
	union
	{
		BOOLEAN BitField;
		struct
		{
			BOOLEAN ImageUsesLargePages : 1;
			BOOLEAN IsProtectedProcess : 1;
			BOOLEAN IsImageDynamicallyRelocated : 1;
			BOOLEAN SkipPatchingUser32Forwarders : 1;
			BOOLEAN IsPackagedProcess : 1;
			BOOLEAN IsAppContainer : 1;
			BOOLEAN IsProtectedProcessLight : 1;
			BOOLEAN IsLongPathAwareProcess : 1;
		} s1;
	} u1;

	HANDLE Mutant;

	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID SubSystemData;
	PVOID ProcessHeap;
	PRTL_CRITICAL_SECTION FastPebLock;
	PVOID AtlThunkSListPtr;
	PVOID IFEOKey;
	union
	{
		ULONG CrossProcessFlags;
		struct
		{
			ULONG ProcessInJob : 1;
			ULONG ProcessInitializing : 1;
			ULONG ProcessUsingVEH : 1;
			ULONG ProcessUsingVCH : 1;
			ULONG ProcessUsingFTH : 1;
			ULONG ProcessPreviouslyThrottled : 1;
			ULONG ProcessCurrentlyThrottled : 1;
			ULONG ReservedBits0 : 25;
		} s2;
	} u2;
	union
	{
		PVOID KernelCallbackTable;
		PVOID UserSharedInfoPtr;
	} u3;
	ULONG SystemReserved[1];
	ULONG AtlThunkSListPtr32;
	PVOID ApiSetMap;
	ULONG TlsExpansionCounter;
	PVOID TlsBitmap;
	ULONG TlsBitmapBits[2];

	PVOID ReadOnlySharedMemoryBase;
	PVOID SharedData; // HotpatchInformation
	PVOID* ReadOnlyStaticServerData;

	PVOID AnsiCodePageData; // PCPTABLEINFO
	PVOID OemCodePageData; // PCPTABLEINFO
	PVOID UnicodeCaseTableData; // PNLSTABLEINFO

	ULONG NumberOfProcessors;
	ULONG NtGlobalFlag;

	LARGE_INTEGER CriticalSectionTimeout;
	SIZE_T HeapSegmentReserve;
	SIZE_T HeapSegmentCommit;
	SIZE_T HeapDeCommitTotalFreeThreshold;
	SIZE_T HeapDeCommitFreeBlockThreshold;

	ULONG NumberOfHeaps;
	ULONG MaximumNumberOfHeaps;
	PVOID* ProcessHeaps; // PHEAP

	PVOID GdiSharedHandleTable;
	PVOID ProcessStarterHelper;
	ULONG GdiDCAttributeList;

	PRTL_CRITICAL_SECTION LoaderLock;

	ULONG OSMajorVersion;
	ULONG OSMinorVersion;
	USHORT OSBuildNumber;
	USHORT OSCSDVersion;
	ULONG OSPlatformId;
	ULONG ImageSubsystem;
	ULONG ImageSubsystemMajorVersion;
	ULONG ImageSubsystemMinorVersion;
	ULONG_PTR ActiveProcessAffinityMask;
} PEB, * PPEB;
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	union
	{
		LIST_ENTRY InInitializationOrderLinks;
		LIST_ENTRY InProgressLinks;
	};
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	union
	{
		UCHAR FlagGroup[4];
		ULONG Flags;
		struct
		{
			ULONG PackagedBinary : 1;
			ULONG MarkedForRemoval : 1;
			ULONG ImageDll : 1;
			ULONG LoadNotificationsSent : 1;
			ULONG TelemetryEntryProcessed : 1;
			ULONG ProcessStaticImport : 1;
			ULONG InLegacyLists : 1;
			ULONG InIndexes : 1;
			ULONG ShimDll : 1;
			ULONG InExceptionTable : 1;
			ULONG ReservedFlags1 : 2;
			ULONG LoadInProgress : 1;
			ULONG LoadConfigProcessed : 1;
			ULONG EntryProcessed : 1;
			ULONG ProtectDelayLoad : 1;
			ULONG ReservedFlags3 : 2;
			ULONG DontCallForThreads : 1;
			ULONG ProcessAttachCalled : 1;
			ULONG ProcessAttachFailed : 1;
			ULONG CorDeferredValidate : 1;
			ULONG CorImage : 1;
			ULONG DontRelocate : 1;
			ULONG CorILOnly : 1;
			ULONG ReservedFlags5 : 3;
			ULONG Redirected : 1;
			ULONG ReservedFlags6 : 2;
			ULONG CompatDatabaseProcessed : 1;
		} s;
	} u;
	USHORT ObsoleteLoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;
	PVOID Lock;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

extern "C" NTSTATUS NtOpenFile(
	PHANDLE            FileHandle,
	ACCESS_MASK        DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK   IoStatusBlock,
	ULONG              ShareAccess,
	ULONG              OpenOptions
);
extern "C" VOID
RtlInitUnicodeString(
	PUNICODE_STRING DestinationString,
	PCWSTR SourceString
);
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#endif

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036
```

`BEShellcode/sigs.cpp`:

```cpp
#include "sigs.h"

std::vector<std::string>string_signatures{
	"ojects\\PUBGChinese",
	"BattleGroundsPrivate_CheatESP",
	"Neck",
	"Chest",
	"Mouse 1",
	"PlayerESPColor",
	"HackMachine",
	"VisualHacks.net",
	".rdata$zzzdbg",
	"D3D11Present initialised",
	"[ %.0fM ]",
	"[hp:%d]%dm",
	"d$8",
	"POSITION",
	"%s",
	"%d",
	"POSITION",
	"COLOR",
	"\n<assembly xmlns='urn:schemas-mi"
};

bool hit_sig(uintptr_t base, DWORD size) {
	for (auto curr_sig : string_signatures) {
		if (nt::scanpattern<uintptr_t>((BYTE*)base, size, (char*)curr_sig.c_str(), 0)) {
			printf("HIT SIG: %s\n", curr_sig.c_str());
			return true;
		}
	}
	return false;
}

void signatures::scan_sigs() {
	uintptr_t limit = (uintptr_t)GetModuleHandleA(0);
	uintptr_t curr_page_addy = 0x0;
	do {
		MEMORY_BASIC_INFORMATION mbi{ 0 };
		size_t return_length{ 0 };
		if (NtQueryVirtualMemory((HANDLE)-1, (PVOID)curr_page_addy, MemoryBasicInformation, &mbi, sizeof(mbi), &return_length) == 0) {
			if (
				mbi.State == MEM_COMMIT &&
				((mbi.Protect == PAGE_EXECUTE) || (mbi.Protect == PAGE_EXECUTE_READ) || (mbi.Protect == PAGE_EXECUTE_READWRITE))
				// && membase < beshellcode || membase > beshellcode
				)
			{
				if (mbi.Type == MEM_MAPPED || mbi.Type == MEM_PRIVATE) {
					if (hit_sig(curr_page_addy, mbi.RegionSize)) {
						beshellcode::report(beshellcode::report_ids::HitSignature);
					}
				}

			}
		}
		curr_page_addy = (uintptr_t)mbi.BaseAddress + mbi.RegionSize;
	} while (curr_page_addy < 0x7FFFFFFF0000);
	
}
```

`BEShellcode/sigs.h`:

```h
#pragma once
#include "beshellcode.h"

namespace signatures {
	void scan_sigs();
}
```

`BEShellcode/systhreadfinder.cpp`:

```cpp
#include "systhreadfinder.h"

bool systhreadfinder::found_sys_thread(int depth) {
	int iteration;
	uintptr_t idletime1, kerneltime1, usertime1;
	uintptr_t idletime2, kerneltime2, usertime2;
	uintptr_t deltatime1, deltatime2, deltatime3;

	SYSTEM_PROCESS_INFORMATION* proc1;
	SYSTEM_PROCESS_INFORMATION* proc2;
	for (iteration = 0; iteration < depth; iteration++) {
		int* proc_list_start = nt::get_proc_list();
		GetSystemTimes((PFILETIME)&idletime1, (PFILETIME)&kerneltime1, (PFILETIME)&usertime1);
		Sleep(1000);
		int* proc_list_end = nt::get_proc_list();
		GetSystemTimes((PFILETIME)&idletime2, (PFILETIME)&kerneltime2, (PFILETIME)&usertime2);

		deltatime1 = 0;
		for (proc2 = (SYSTEM_PROCESS_INFORMATION*)proc_list_end;; proc2 = (SYSTEM_PROCESS_INFORMATION*)((char*)proc2 + proc2->NextOffset)) {
			for (proc1 = (SYSTEM_PROCESS_INFORMATION*)proc_list_start; proc2->ProcessId != proc1->ProcessId; proc1 = (SYSTEM_PROCESS_INFORMATION*)((char*)proc1 + proc1->NextOffset)) {
				if (!proc1->NextOffset) {
					deltatime1 += *(uintptr_t*)&proc2->KernelTime + *(uintptr_t*)&proc2->UserTime;
					goto END;
				}
			}
			deltatime2 = *(uintptr_t*)&proc2->KernelTime - *(uintptr_t*)&proc1->KernelTime + *(uintptr_t*)&proc2->UserTime - *(uintptr_t*)&proc1->UserTime;
			deltatime1 += deltatime2;
		END:
			if (!proc2->NextOffset)
				break;
		}
		deltatime3 = usertime2 - usertime1 + kerneltime2 - kerneltime1 - deltatime1;
		if (deltatime3 < 0x7270E0)
			break;
		free(proc_list_start);
		free(proc_list_end);
	}

	return iteration == depth;
}
```

`BEShellcode/systhreadfinder.h`:

```h
#pragma once
#include <Windows.h>
#include "nt.h"

namespace systhreadfinder {
	bool found_sys_thread(int depth);
}
```

`BEShellcode/thread_scan.cpp`:

```cpp
#include "thread_scan.h"

void thread_scan::scan_threads(){
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
	if (hSnap != INVALID_HANDLE_VALUE) {
		THREADENTRY32 lpe32;
		lpe32.dwSize = sizeof(THREADENTRY32);
		if (Thread32First(hSnap, &lpe32)) {
			do {
				if (lpe32.th32OwnerProcessID == GetCurrentProcessId()) {
					HANDLE thread_handle = OpenThread(0xA, 0, lpe32.th32ThreadID);
					if (thread_handle != INVALID_HANDLE_VALUE) {
						DWORD result = ResumeThread(thread_handle);
						if (result && result != -1) {
							SuspendThread(thread_handle);
							beshellcode::report(beshellcode::report_ids::SuspendedThread);
						}
						CONTEXT thread_context;
						thread_context.ContextFlags = CONTEXT_ALL;
						if (GetThreadContext(thread_handle, &thread_context)) {
							MEMORY_BASIC_INFORMATION mbi{ 0 };
							size_t return_length{ 0 };
							if (
								(NtQueryVirtualMemory((HANDLE)-1, (PVOID)thread_context.Rip, MemoryBasicInformation, &mbi, sizeof(mbi), &return_length) < 0) ||
								mbi.State != MEM_COMMIT ||
								mbi.Type != MEM_IMAGE && mbi.RegionSize > 0x2000) {
								beshellcode::report(beshellcode::report_ids::IllegalRip);
							}					
						}
						CloseHandle(thread_handle);

					}
				}
			} while (Thread32Next(hSnap, &lpe32));
		}
		CloseHandle(hSnap);
	}
}

```

`BEShellcode/thread_scan.h`:

```h
#pragma once
#include "beshellcode.h"
namespace thread_scan {
	void scan_threads();
}
```

`BEShellcode/veh.cpp`:

```cpp
#include "veh.h"
std::vector<std::tuple<uintptr_t, BYTE>>checks;
LONG WINAPI veh::be_handler(struct _EXCEPTION_POINTERS* ExceptionInfo) {
	
	if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT) {
		for (std::vector<std::tuple<uintptr_t, BYTE>>::iterator it = checks.begin(); it != checks.end(); ++it)
		{
			if (std::get<0>(*it) == (uintptr_t)ExceptionInfo->ExceptionRecord->ExceptionAddress) {
				DWORD old;
				VirtualProtect((LPVOID)ExceptionInfo->ContextRecord->Rip, 0x1, PAGE_EXECUTE_READWRITE, &old);
				*(BYTE*)ExceptionInfo->ContextRecord->Rip = 0xC3;
				VirtualProtect((LPVOID)ExceptionInfo->ContextRecord->Rip, 0x1, old, &old);

	

				uintptr_t return_address = *(uintptr_t*)ExceptionInfo->ContextRecord->Rsp;
				MEMORY_BASIC_INFORMATION mbi{ 0 };
				size_t return_length{ 0 };
				if (
					(NtQueryVirtualMemory((HANDLE)-1, (PVOID)return_address, MemoryBasicInformation, &mbi, sizeof(mbi), &return_length) < 0) ||
					mbi.State != MEM_COMMIT ||
					mbi.Type != MEM_IMAGE && mbi.RegionSize > 0x2000 ||
					*(WORD*)return_address == 0x23FF || //https://www.unknowncheats.me/forum/anti-cheat-bypass/268039-x64-return-address-spoofing-source-explanation.html
					*(WORD*)return_address == 0x26FF ||
					*(WORD*)return_address == 0x27FF ||
					*(WORD*)return_address == 0x65FF ||
					*(WORD*)return_address == 0xE3FF
					) {

					//reportbuffer
					beshellcode::report(beshellcode::report_ids::IllegaleCaller);
				}
			

			}
		}
	
		
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	else if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP) {
		if (ExceptionInfo->ContextRecord->Rip >= 0x8000000000000000) { //Perfect Injector
			beshellcode::report(beshellcode::report_ids::IllegaleCaller);
		}
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	return EXCEPTION_CONTINUE_SEARCH;
}

void veh::add_func(uintptr_t func) {
	if (!func)
	{
		return;
	}
	while (*(BYTE*)func != 0xC3)
		func += 1;

	std::tuple<uintptr_t, BYTE>newcheck{ func, *(BYTE*)func };
	checks.push_back(newcheck);
	DWORD old;
	VirtualProtect((LPVOID)func, 0x1, PAGE_EXECUTE_READWRITE, &old);
	*(BYTE*)func = 0xCC;
	VirtualProtect((LPVOID)func, 0x1, old, &old);
}

```

`BEShellcode/veh.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <intrin.h>
#include "nt.h"
#include "beshellcode.h"
namespace veh {
    LONG WINAPI be_handler(struct _EXCEPTION_POINTERS* ExceptionInfo);
    void add_func(uintptr_t func);

}
```

`README.md`:

```md
# BE-Shellcode
Code for Battleyes shellcode
- Exception handler that checks for return addresses that match report criteria
- find hidden system threads by checking kernel time delta
- detect hooks that want to catch exceptions (KiUserExceptionDispatcher)
- detect blacklisted dlls (+checks for import etc) + blacklisted drivers
- check integrity of important functions
- check all threads in local process and find RIPs that match report criteria
- find blacklisted signatures

```