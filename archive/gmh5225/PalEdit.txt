Project Path: arc_gmh5225_PalEdit_qst4tpyk

Source Tree:

```txt
arc_gmh5225_PalEdit_qst4tpyk
‚îú‚îÄ‚îÄ EmptyObjectHandler.py
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ PalEdit.py
‚îú‚îÄ‚îÄ PalInfo.py
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ SaveConverter.py
‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ archive.py
‚îÇ   ‚îú‚îÄ‚îÄ gvas.py
‚îÇ   ‚îú‚îÄ‚îÄ noindent.py
‚îÇ   ‚îú‚îÄ‚îÄ palsav.py
‚îÇ   ‚îú‚îÄ‚îÄ paltypes.py
‚îÇ   ‚îî‚îÄ‚îÄ rawdata.py
‚îú‚îÄ‚îÄ resources
‚îÇ   ‚îú‚îÄ‚îÄ #ERROR.png
‚îÇ   ‚îú‚îÄ‚îÄ Anubis.png
‚îÇ   ‚îú‚îÄ‚îÄ Arsox.png
‚îÇ   ‚îú‚îÄ‚îÄ Astegon.png
‚îÇ   ‚îú‚îÄ‚îÄ Axel & Orserk.png
‚îÇ   ‚îú‚îÄ‚îÄ Azurobe.png
‚îÇ   ‚îú‚îÄ‚îÄ Beakon.png
‚îÇ   ‚îú‚îÄ‚îÄ Beegarde.png
‚îÇ   ‚îú‚îÄ‚îÄ Black Marketeer.png
‚îÇ   ‚îú‚îÄ‚îÄ Blazamut.png
‚îÇ   ‚îú‚îÄ‚îÄ Blazehowl Noct.png
‚îÇ   ‚îú‚îÄ‚îÄ Blazehowl.png
‚îÇ   ‚îú‚îÄ‚îÄ Bristla.png
‚îÇ   ‚îú‚îÄ‚îÄ Broncherry Aqua.png
‚îÇ   ‚îú‚îÄ‚îÄ Broncherry.png
‚îÇ   ‚îú‚îÄ‚îÄ Brothers of the Eternal Pyre Martyr.png
‚îÇ   ‚îú‚îÄ‚îÄ Burly Merc.png
‚îÇ   ‚îú‚îÄ‚îÄ Bushi.png
‚îÇ   ‚îú‚îÄ‚îÄ Caprity.png
‚îÇ   ‚îú‚îÄ‚îÄ Cattiva.png
‚îÇ   ‚îú‚îÄ‚îÄ Cawgnito.png
‚îÇ   ‚îú‚îÄ‚îÄ Celaray.png
‚îÇ   ‚îú‚îÄ‚îÄ Chikipi.png
‚îÇ   ‚îú‚îÄ‚îÄ Chillet.png
‚îÇ   ‚îú‚îÄ‚îÄ Cinnamoth.png
‚îÇ   ‚îú‚îÄ‚îÄ Cremis.png
‚îÇ   ‚îú‚îÄ‚îÄ Cryolinx.png
‚îÇ   ‚îú‚îÄ‚îÄ Daedream.png
‚îÇ   ‚îú‚îÄ‚îÄ Dazzi.png
‚îÇ   ‚îú‚îÄ‚îÄ Depresso.png
‚îÇ   ‚îú‚îÄ‚îÄ Digtoise.png
‚îÇ   ‚îú‚îÄ‚îÄ Dinossom Lux.png
‚îÇ   ‚îú‚îÄ‚îÄ Dinossom.png
‚îÇ   ‚îú‚îÄ‚îÄ Direhowl.png
‚îÇ   ‚îú‚îÄ‚îÄ Dumud.png
‚îÇ   ‚îú‚îÄ‚îÄ Eikthyrdeer Terra.png
‚îÇ   ‚îú‚îÄ‚îÄ Eikthyrdeer.png
‚îÇ   ‚îú‚îÄ‚îÄ Elizabee.png
‚îÇ   ‚îú‚îÄ‚îÄ Elphidran Aqua.png
‚îÇ   ‚îú‚îÄ‚îÄ Elphidran.png
‚îÇ   ‚îú‚îÄ‚îÄ Expedition Survivor.png
‚îÇ   ‚îú‚îÄ‚îÄ Faleris.png
‚îÇ   ‚îú‚îÄ‚îÄ Felbat.png
‚îÇ   ‚îú‚îÄ‚îÄ Fenglope.png
‚îÇ   ‚îú‚îÄ‚îÄ Flambelle.png
‚îÇ   ‚îú‚îÄ‚îÄ Flopie.png
‚îÇ   ‚îú‚îÄ‚îÄ Foxcicle.png
‚îÇ   ‚îú‚îÄ‚îÄ Foxparks.png
‚îÇ   ‚îú‚îÄ‚îÄ Free Pal Alliance Devout.png
‚îÇ   ‚îú‚îÄ‚îÄ Frostallion Noct.png
‚îÇ   ‚îú‚îÄ‚îÄ Frostallion.png
‚îÇ   ‚îú‚îÄ‚îÄ Fuack.png
‚îÇ   ‚îú‚îÄ‚îÄ Fuddler.png
‚îÇ   ‚îú‚îÄ‚îÄ Galeclaw.png
‚îÇ   ‚îú‚îÄ‚îÄ Gobfin Ignis.png
‚îÇ   ‚îú‚îÄ‚îÄ Gobfin.png
‚îÇ   ‚îú‚îÄ‚îÄ Gorirat.png
‚îÇ   ‚îú‚îÄ‚îÄ Grintale.png
‚îÇ   ‚îú‚îÄ‚îÄ Grizzbolt.png
‚îÇ   ‚îú‚îÄ‚îÄ Gumoss (Special).png
‚îÇ   ‚îú‚îÄ‚îÄ Gumoss.png
‚îÇ   ‚îú‚îÄ‚îÄ Hangyu Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Hangyu.png
‚îÇ   ‚îú‚îÄ‚îÄ Helzephyr.png
‚îÇ   ‚îú‚îÄ‚îÄ Hoocrates.png
‚îÇ   ‚îú‚îÄ‚îÄ Ice Kingpaca.png
‚îÇ   ‚îú‚îÄ‚îÄ Incineram Noct.png
‚îÇ   ‚îú‚îÄ‚îÄ Incineram.png
‚îÇ   ‚îú‚îÄ‚îÄ Jetragon.png
‚îÇ   ‚îú‚îÄ‚îÄ Jolthog Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Jolthog.png
‚îÇ   ‚îú‚îÄ‚îÄ Jormuntide Ignis.png
‚îÇ   ‚îú‚îÄ‚îÄ Jormuntide.png
‚îÇ   ‚îú‚îÄ‚îÄ Katress.png
‚îÇ   ‚îú‚îÄ‚îÄ Kelpsea Ignis.png
‚îÇ   ‚îú‚îÄ‚îÄ Kelpsea.png
‚îÇ   ‚îú‚îÄ‚îÄ Killamari.png
‚îÇ   ‚îú‚îÄ‚îÄ Kingpaca.png
‚îÇ   ‚îú‚îÄ‚îÄ Kitsun.png
‚îÇ   ‚îú‚îÄ‚îÄ Lamball.png
‚îÇ   ‚îú‚îÄ‚îÄ Leezpunk Ignis.png
‚îÇ   ‚îú‚îÄ‚îÄ Leezpunk.png
‚îÇ   ‚îú‚îÄ‚îÄ Lifmunk.png
‚îÇ   ‚îú‚îÄ‚îÄ Lily & Lyleen.png
‚îÇ   ‚îú‚îÄ‚îÄ Loupmoon.png
‚îÇ   ‚îú‚îÄ‚îÄ Lovander.png
‚îÇ   ‚îú‚îÄ‚îÄ Lunaris.png
‚îÇ   ‚îú‚îÄ‚îÄ Lyleen Noct.png
‚îÇ   ‚îú‚îÄ‚îÄ Lyleen.png
‚îÇ   ‚îú‚îÄ‚îÄ Mammorest Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Mammorest.png
‚îÇ   ‚îú‚îÄ‚îÄ Maraith.png
‚îÇ   ‚îú‚îÄ‚îÄ Marus & Faleris.png
‚îÇ   ‚îú‚îÄ‚îÄ Mau Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Mau.png
‚îÇ   ‚îú‚îÄ‚îÄ Melpaca.png
‚îÇ   ‚îú‚îÄ‚îÄ Menasting.png
‚îÇ   ‚îú‚îÄ‚îÄ Mossanda Lux.png
‚îÇ   ‚îú‚îÄ‚îÄ Mossanda.png
‚îÇ   ‚îú‚îÄ‚îÄ MossandaIcon.ico
‚îÇ   ‚îú‚îÄ‚îÄ MossandaIcon.png
‚îÇ   ‚îú‚îÄ‚îÄ Mozzarina.png
‚îÇ   ‚îú‚îÄ‚îÄ Necromus.png
‚îÇ   ‚îú‚îÄ‚îÄ Nitewing.png
‚îÇ   ‚îú‚îÄ‚îÄ Nox.png
‚îÇ   ‚îú‚îÄ‚îÄ Orserk.png
‚îÇ   ‚îú‚îÄ‚îÄ PAL Genetic Research Unit Executioner.png
‚îÇ   ‚îú‚îÄ‚îÄ PIDF Guard.png
‚îÇ   ‚îú‚îÄ‚îÄ Pal Merchant.png
‚îÇ   ‚îú‚îÄ‚îÄ Paladius.png
‚îÇ   ‚îú‚îÄ‚îÄ Pengullet.png
‚îÇ   ‚îú‚îÄ‚îÄ Penking.png
‚îÇ   ‚îú‚îÄ‚îÄ Petallia.png
‚îÇ   ‚îú‚îÄ‚îÄ Pyrin Noct.png
‚îÇ   ‚îú‚îÄ‚îÄ Pyrin.png
‚îÇ   ‚îú‚îÄ‚îÄ Quivern.png
‚îÇ   ‚îú‚îÄ‚îÄ Ragnahawk.png
‚îÇ   ‚îú‚îÄ‚îÄ Rayhound.png
‚îÇ   ‚îú‚îÄ‚îÄ Reindrix.png
‚îÇ   ‚îú‚îÄ‚îÄ Relaxaurus Lux.png
‚îÇ   ‚îú‚îÄ‚îÄ Relaxaurus.png
‚îÇ   ‚îú‚îÄ‚îÄ Reptyro Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Reptyro.png
‚îÇ   ‚îú‚îÄ‚îÄ Ribbuny.png
‚îÇ   ‚îú‚îÄ‚îÄ Robinquill Terra.png
‚îÇ   ‚îú‚îÄ‚îÄ Robinquill.png
‚îÇ   ‚îú‚îÄ‚îÄ Rooby.png
‚îÇ   ‚îú‚îÄ‚îÄ Rushoar.png
‚îÇ   ‚îú‚îÄ‚îÄ Shadowbeak.png
‚îÇ   ‚îú‚îÄ‚îÄ Sibelyx.png
‚îÇ   ‚îú‚îÄ‚îÄ Sparkit.png
‚îÇ   ‚îú‚îÄ‚îÄ Surfent Terra.png
‚îÇ   ‚îú‚îÄ‚îÄ Surfent.png
‚îÇ   ‚îú‚îÄ‚îÄ Suzaku Aqua.png
‚îÇ   ‚îú‚îÄ‚îÄ Suzaku.png
‚îÇ   ‚îú‚îÄ‚îÄ Swee.png
‚îÇ   ‚îú‚îÄ‚îÄ Sweepa.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Cleaner.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Crusher.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Elite.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Grenadier.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Gunner.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Hunter.png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Thug (Bat).png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Thug (Handgun).png
‚îÇ   ‚îú‚îÄ‚îÄ Syndicate Thug.png
‚îÇ   ‚îú‚îÄ‚îÄ Tanzee.png
‚îÇ   ‚îú‚îÄ‚îÄ Teafant.png
‚îÇ   ‚îú‚îÄ‚îÄ Tocotoco.png
‚îÇ   ‚îú‚îÄ‚îÄ Tombat.png
‚îÇ   ‚îú‚îÄ‚îÄ Univolt.png
‚îÇ   ‚îú‚îÄ‚îÄ Vaelet.png
‚îÇ   ‚îú‚îÄ‚îÄ Vanwyrm Cryst.png
‚îÇ   ‚îú‚îÄ‚îÄ Vanwyrm.png
‚îÇ   ‚îú‚îÄ‚îÄ Verdash.png
‚îÇ   ‚îú‚îÄ‚îÄ Victor & Shadowbeak.png
‚îÇ   ‚îú‚îÄ‚îÄ Vixy.png
‚îÇ   ‚îú‚îÄ‚îÄ Wandering Merchant.png
‚îÇ   ‚îú‚îÄ‚îÄ Warsect.png
‚îÇ   ‚îú‚îÄ‚îÄ Wixen.png
‚îÇ   ‚îú‚îÄ‚îÄ Woolipop.png
‚îÇ   ‚îú‚îÄ‚îÄ Wumpo Botan.png
‚îÇ   ‚îú‚îÄ‚îÄ Wumpo.png
‚îÇ   ‚îî‚îÄ‚îÄ Zoe & Grizzbolt.png
‚îî‚îÄ‚îÄ run.bat

```

`EmptyObjectHandler.py`:

```py
EmptySkillObject = {
    "array_type": "NameProperty",
    "id": None,
    "value": {
        "values": []
    },
    "type": "ArrayProperty"
}

EmptyLevelObject = {
    "id": None,
    "value": 1,
    "type": "IntProperty"
}

EmptyRankObject = {
    "id": None,
    "value": 1,
    "type": "IntProperty"
}

EmptyMeleeObject = {
    "id": None,
    "value": 0,
    "type": "IntProperty"
}

EmptyShotObject = {
    "id": None,
    "value": 0,
    "type": "IntProperty"
}

EmptyDefenceObject = {
    "id": None,
    "value": 0,
    "type": "IntProperty"
}

EmptyExpObject = {
    "id": None,
    "value": 0,
    "type": "IntProperty"
}

EmptyRarePalObject = {
    "value": False,
    "id": None,
    "type": "BoolProperty"
}
    

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Jacob Lawrence

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PalEdit.py`:

```py
import os, webbrowser, json, time, uuid

import SaveConverter

from PalInfo import *

from tkinter import *
from tkinter import ttk
from tkinter.filedialog import askopenfilename, asksaveasfilename
from tkinter import messagebox
from PIL import ImageTk, Image

global palbox
palbox = {}
global players
players = {}


global unknown
unknown = []
global data
global debug
debug = "false"
global editindex
editindex = -1
global version
version = "0.4.8"

def toggleDebug():
    global debug
    if debug == "false":
        debug = "true"
        frameDebug.pack(fill=BOTH, expand=False)
    else:
        debug = "false"
        frameDebug.pack_forget()


def isPalSelected():
    global palbox
    if current.get() == "":
        return False
    if len(palbox[players[current.get()]]) == 0:
        return False
    if len(listdisplay.curselection()) == 0:
        return False
    return True

def getSelectedPalInfo():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]
    print(f"Get Info: {pal.GetNickname()}")     
    print(f"  - Level: {pal.GetLevel() if pal.GetLevel() > 0 else '?'}")    
    print(f"  - Rank: {pal.GetRank()}")    
    print(f"  - Skill 1:  {skills[0].get()}")
    print(f"  - Skill 2:  {skills[1].get()}")
    print(f"  - Skill 3:  {skills[2].get()}")
    print(f"  - Skill 4:  {skills[3].get()}")
    print(f"  - Melee IV:  {pal.GetAttackMelee()}")
    print(f"  - Range IV:  {pal.GetAttackRanged()}")

def getSelectedPalData():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]
    print(f"Get Data: {pal.GetNickname()}")    
    print(f"{pal._obj}")  

def setpreset(preset):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i] # seems global palbox is not necessary

    match preset:
        case "worker":
            skills[0].set("Artisan")
            skills[1].set("Serious")
            skills[2].set("Lucky")
            skills[3].set("Work Slave")
        case "runner":
            skills[0].set("Swift")
            skills[1].set("Legend")
            skills[2].set("Runner")
            skills[3].set("Nimble")
        case "dmg_max":
            skills[0].set("Musclehead")
            skills[1].set("Legend")
            skills[2].set("Ferocious")
            skills[3].set("Lucky")
        case "dmg_balanced":
            skills[0].set("Musclehead")
            skills[1].set("Legend")
            skills[2].set("Ferocious")
            skills[3].set("Burly Body")
        case "dmg_dragon":
            skills[0].set("Musclehead")
            skills[1].set("Legend")
            skills[2].set("Ferocious")
            skills[3].set("Divine Dragon")
        case "tank":
            skills[0].set("Burly Body")
            skills[1].set("Legend")
            skills[2].set("Masochist")
            skills[3].set("Hard Skin")
        case _:
            print(f"Preset {preset} not found - nothing changed")
            return

    # exp (if level selected)
    if checkboxLevelVar.get() == 1:
        pal.SetLevel(textboxLevelVar.get())
    # rank (if rank selected)
    if checkboxRankVar.get() == 1:
        changerank(optionMenuRankVar.get())
    # attributes (if attributes selected)
    # TODO: change attributes

    refresh(i)

def makeworker():
    setpreset("worker")
def makerunner():
    setpreset("runner")
def makedmgmax():
    setpreset("dmg_max")
def makedmgbalanced():
    setpreset("dmg_balanced")
def makedmgdragon():
    setpreset("dmg_dragon")
def maketank():
    setpreset("tank")

def changerank(configvalue):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]
    match configvalue:
        case 4:
            pal.SetRank(5)
        case 3:
            pal.SetRank(4)
        case 2:
            pal.SetRank(3)
        case 1:
            pal.SetRank(2)
        case _:
            pal.SetRank(1)
    refresh(i)

def changerankchoice(choice):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]
    changerank(ranksvar.get())

def changeskill(num):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    if not skills[num].get() in ["Unknown", "UNKNOWN"]:
        if skills[num].get() in ["None", "NONE"]:
            pal.RemoveSkill(num)
        else:
            pal.SetSkill(num, skills[num].get())

    refresh(i)

def onselect(evt):
    global palbox
    global editindex
    w = evt.widget
    if not isPalSelected():
        return

    if editindex > -1:
        updatestats(editindex)
        
    index = int(w.curselection()[0])
    editindex = index

    pal = palbox[players[current.get()]][index]
    #palname.config(text=pal.GetName())
    speciesvar.set(pal.GetName())

    g = pal.GetGender()
    palgender.config(text=g, fg=PalGender.MALE.value if g == "Male ‚ôÇ" else PalGender.FEMALE.value)

    title.config(text=f"{pal.GetNickname()}")
    level.config(text=f"Lv. {pal.GetLevel() if pal.GetLevel() > 0 else '?'}")
    portrait.config(image=pal.GetImage())

    ptype.config(text=pal.GetPrimary().GetName(), bg=pal.GetPrimary().GetColour())
    stype.config(text=pal.GetSecondary().GetName(), bg=pal.GetSecondary().GetColour())

    # ‚öîüèπ
    meleevar.set(pal.GetAttackMelee())
    shotvar.set(pal.GetAttackRanged())
    defvar.set(pal.GetDefence())
    wspvar.set(pal.GetWorkSpeed())

    luckyvar.set(pal.isLucky)
    alphavar.set(pal.isBoss)

    # rank
    match pal.GetRank():
        case 5:
            ranksvar.set(ranks[4])
        case 4:
            ranksvar.set(ranks[3])
        case 3:
            ranksvar.set(ranks[2])
        case 2:
            ranksvar.set(ranks[1])
        case _:
            ranksvar.set(ranks[0])

    s = pal.GetSkills()[:]
    while len(s) < 4:
        s.append("NONE")

    for i in range(0, 4):
        if not s[i] in [s.name for s in PalSkills]:
            skills[i].set("Unknown")
        else:
            skills[i].set(PalSkills[s[i]].value)
    

def changetext(num):
    if num == -1:
        skilllabel.config(text="Hover a skill to see it's description")
        return
    
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i] # seems global palbox is not necessary

    global unknown
    if type(num) == str:
        skilllabel.config(text=pal.GetOwner())
        return


    if skills[num].get() == "Unknown":
        skilllabel.config(text=f"{pal.GetSkills()[num]}{SkillDesc['Unknown']}")
        return
    skilllabel.config(text=SkillDesc[skills[num].get()])

    
def loadfile():
    skilllabel.config(text="Loading save, please be patient...")

    file = askopenfilename(filetype=[("All files", "*.sav *.sav.json *.pson"),("Palworld Saves", "*.sav *.sav.json"),("Palworld Box", "*.pson")])
    print(f"Opening file {file}")

    if not file.endswith(".pson") and not file.endswith("Level.sav.json"):
        if file.endswith("Level.sav"):
            answer = messagebox.askquestion("Incorrect file", "This save hasn't been decompiled. Would you like to decompile it now?")
            if answer == "yes":
                skilllabel.config(text="Decompiling save, please be patient...")
                doconvertjson(file)
        else:
            messagebox.showerror("Incorrect file", "This is not the right file. Please select the Level.sav file.")
        changetext(-1)
        return
    load(file)

def sortPals(e):
    return e.GetName()


def load(file):
    global data
    global palbox
    global players
    global current
    current.set("")
    palbox = {}
    players = {}

    f = open(file, "r", encoding="utf8")
    data = json.loads(f.read())
    f.close()

    if file.endswith(".pson"):
        paldata = data
    else:
        paldata = data['properties']['worldSaveData']['value']['CharacterSaveParameterMap']['value']

        f = open("current.pson", "w", encoding="utf8")
        json.dump(paldata, f, indent=4)
        f.close()


    for i in paldata:
        try:
            p = PalEntity(i)
            if not p.owner in palbox:
                palbox[p.owner] = []
            palbox[p.owner].append(p)

            n = p.GetFullName()

        except Exception as e:

            if str(e) == "This is a player character":
                print("Found Player Character")
                pl = i['value']['RawData']['value']['object']['SaveParameter']['value']['NickName']['value']
                plguid = i['key']['PlayerUId']['value']
                print(f"{pl} - {plguid}")
                players[pl] = plguid
            else:
                unknown.append(i)
                print(f"Error occured: {str(e)}")
            # print(f"Debug: Data {i}")

    current.set(next(iter(players)))
    print(f"Defaulted selection to {current.get()}")

    updateDisplay()

    print(f"Unknown list contains {len(unknown)} entries")
    #for i in unknown:
        #print (i)
    
    print(f"{len(players)} players found:")
    for i in players:
        print(f"{i} = {players[i]}")
    playerdrop['values'] = list(players.keys())
    playerdrop.current(0)
    

    refresh()

    changetext(-1)
    jump()
    messagebox.showinfo("Done", "Done loading!")

def jump():
    root.attributes('-topmost', 1)
    root.attributes('-topmost', 0)
    root.focus_force()
    root.bell()

def updateDisplay():
    listdisplay.delete(0,END)
    palbox[players[current.get()]].sort(key=sortPals)

    for p in palbox[players[current.get()]]:
        listdisplay.insert(END, p.GetFullName())

        if p.isBoss:
            listdisplay.itemconfig(END, {'fg': 'red'})
        elif p.isLucky:
            listdisplay.itemconfig(END, {'fg': 'blue'})
    

def savefile():
    global palbox
    global data
    skilllabel.config(text="Saving, please be patient... (it can take up to 5 minutes in large files)")

    if isPalSelected():
        i = int(listdisplay.curselection()[0])
        refresh(i)
    
    file = asksaveasfilename(filetype=[("All files", "*.sav.json *.pson"),("Palworld Saves", "*.sav.json"),("Palworld Box", "*.pson")])
    print(f"Opening file {file}")

    if not file.endswith(".pson") and not file.endswith("Level.sav.json"):
        messagebox.showerror("Incorrect file", "You can only save to an existing Level.sav.json or a new .pson file")

    if file.endswith(".pson"):
        savepson(file)
    else:
        savejson(file)

    changetext(-1)
    jump()
    messagebox.showinfo("Done", "Done saving!")

def savepson(filename):
    f = open(filename, "w", encoding="utf8")
    if 'properties' in data:
        json.dump(data['properties']['worldSaveData']['value']['CharacterSaveParameterMap']['value'], f, indent=4)
    else:
        json.dump(data, f, indent=4)
    f.close()

def savejson(filename):
    f = open(filename, "r", encoding="utf8")
    svdata = json.loads(f.read())
    f.close()

    if 'properties' in data:
        svdata['properties']['worldSaveData']['value']['CharacterSaveParameterMap']['value'] = data['properties']['worldSaveData']['value']['CharacterSaveParameterMap']['value']
    else:
        svdata['properties']['worldSaveData']['value']['CharacterSaveParameterMap']['value'] = data

    f = open(filename, "w", encoding="utf8")
    json.dump(svdata, f)
    f.close()

    changetext(-1)

def generateguid():
    print(uuid.uuid4())

def updatestats(e):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][e]

    pal.SetAttackMelee(meleevar.get())
    pal.SetAttackRanged(shotvar.get())
    pal.SetDefence(defvar.get())
    pal.SetWorkSpeed(wspvar.get())

def takelevel():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    if pal.GetLevel() == 1:
        return
    pal.SetLevel(pal.GetLevel()-1)
    refresh(i)

def givelevel():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    if pal.GetLevel() == 50:
        return
    pal.SetLevel(pal.GetLevel()+1)
    refresh(i)

def changespeciestype(evt):
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]
    
    pal.SetType(speciesvar.get())
    updateDisplay()
    refresh(palbox[players[current.get()]].index(pal))

def refresh(num=0):
    listdisplay.select_set(num)
    listdisplay.event_generate("<<ListboxSelect>>")

def converttojson():

    skilllabel.config(text="Converting... this may take a while.")
    
    file = askopenfilename(filetype=[("All files", "*.sav")])
    print(f"Opening file {file}")

    doconvertjson(file)

def doconvertjson(file, compress=False):
    SaveConverter.convert_sav_to_json(file, file.replace(".sav", ".sav.json"), compress)

    load(file.replace(".sav", ".sav.json"))

    changetext(-1)
    jump()
    messagebox.showinfo("Done", "Done decompiling!")

def converttosave():
    skilllabel.config(text="Converting... this may take a while.")
    
    file = askopenfilename(filetype=[("All files", "*.sav.json")])
    print(f"Opening file {file}")

    doconvertsave(file)


def doconvertsave(file):
    SaveConverter.convert_json_to_sav(file, file.replace(".sav.json", ".sav"))

    changetext(-1)
    jump()
    messagebox.showinfo("Done", "Done compiling!")

def swapgender():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    pal.SwapGender()
    refresh(i)

def replaceitem(i, pal):
    listdisplay.delete(i)
    listdisplay.insert(i, pal.GetFullName())

    if pal.isBoss:
        listdisplay.itemconfig(i, {'fg': 'red'})
    elif pal.isLucky:
        listdisplay.itemconfig(i, {'fg': 'blue'})

def togglelucky():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    if luckyvar.get() == 1 and alphavar.get() == 1:
        alphavar.set(0)

    pal.SetLucky(True if luckyvar.get() == 1 else False)
    replaceitem(i, pal)
    refresh(i)

def togglealpha():
    if not isPalSelected():
        return
    i = int(listdisplay.curselection()[0])
    pal = palbox[players[current.get()]][i]

    if luckyvar.get() == 1 and alphavar.get() == 1:
        luckyvar.set(0)

    pal.SetBoss(True if alphavar.get() == 1 else False)
    replaceitem(i, pal)
    refresh(i)

root = Tk()
purplepanda = ImageTk.PhotoImage(Image.open(f'resources/MossandaIcon.png').resize((240,240)))
root.iconphoto(True, purplepanda)
root.title(f"PalEdit v{version}")
root.geometry("") # auto window size
root.minsize("800", "500") # minwidth for better view
#root.resizable(width=False, height=False)

global current
current = StringVar()
current.set("")

tools = Menu(root)
root.config(menu=tools)

filemenu = Menu(tools, tearoff=0)
filemenu.add_command(label="Load Save", command=loadfile)
filemenu.add_command(label="Save Changes", command=savefile)

tools.add_cascade(label="File", menu=filemenu, underline=0)

toolmenu = Menu(tools, tearoff=0)
toolmenu.add_command(label="Generate GUID", command=generateguid)
toolmenu.add_command(label="Debug", command=toggleDebug)

tools.add_cascade(label="Tools", menu=toolmenu, underline=0)

convmenu = Menu(tools, tearoff=0)
convmenu.add_command(label="Convert Save to Json", command=converttojson)
convmenu.add_command(label="Convert Json to Save", command=converttosave)

tools.add_cascade(label="Converter", menu=convmenu, underline=0)

scrollview = Frame(root)
scrollview.pack(side=LEFT, fill=Y)

def changeplayer(evt):
    print(current.get())
    updateDisplay()

playerframe = Frame(scrollview)
playerframe.pack(fill=X)
playerlbl = Label(playerframe, text="Player:")
playerlbl.config(justify='center')
playerlbl.pack(side=LEFT, fill=X, expand=True)
playerdrop = ttk.Combobox(playerframe, textvariable=current)
playerdrop.pack(side=RIGHT, fill=X)
playerdrop.bind("<<ComboboxSelected>>", changeplayer)

scrollbar = Scrollbar(scrollview)
scrollbar.pack(side=LEFT, fill=Y)
listdisplay = Listbox(scrollview, width=30, yscrollcommand=scrollbar.set, exportselection=0)
listdisplay.pack(side=LEFT, fill=BOTH)
listdisplay.bind("<<ListboxSelect>>", onselect)
scrollbar.config(command=listdisplay.yview)

infoview = Frame(root, relief="groove", borderwidth=2, width=480, height=480)
infoview.pack(side=RIGHT, fill=BOTH, expand=True)

dataview = Frame(infoview)
dataview.pack(side=TOP, fill=BOTH)

resourceview = Frame(dataview)
resourceview.pack(side=LEFT, fill=BOTH, expand=True)

portrait = Label(resourceview, image=purplepanda, relief="sunken", borderwidth=2)
portrait.pack()

ftsize = 18

typeframe = Frame(resourceview)
typeframe.pack(expand=True, fill=X)
ptype = Label(typeframe, text="Electric", font=("Arial", ftsize), bg=Elements.ELECTRICITY.value.GetColour(), width=6)
ptype.pack(side=LEFT, expand=True, fill=X)
stype = Label(typeframe, text="Dark", font=("Arial", ftsize), bg=Elements.DARK.value.GetColour(), width=6)
stype.pack(side=RIGHT, expand=True, fill=X)

formframe = Frame(resourceview)
formframe.pack(expand=True, fill=X)
luckyvar = IntVar()
alphavar = IntVar()
luckybox = Checkbutton(formframe, text='Lucky', variable=luckyvar, onvalue='1', offvalue='0', command=togglelucky)
luckybox.pack(side=LEFT, expand=True)
alphabox = Checkbutton(formframe, text='Alpha', variable=alphavar, onvalue='1', offvalue='0', command=togglealpha)
alphabox.pack(side=RIGHT, expand=True)

deckview = Frame(dataview, width=320, relief="sunken", borderwidth=2, pady=0)
deckview.pack(side=RIGHT, fill=BOTH, expand=True)

title = Label(deckview, text=f"PalEdit", bg="darkgrey", font=("Arial", 24), width=17)
title.pack(expand=True, fill=BOTH)

headerframe = Frame(deckview, padx=0, pady=0, bg="darkgrey")
headerframe.pack(fill=X)
headerframe.grid_rowconfigure(0, weight=1)
headerframe.grid_columnconfigure((0,2), uniform="equal")
headerframe.grid_columnconfigure(1, weight=1)

level = Label(headerframe, text=f"v{version}", bg="darkgrey", font=("Arial", 24), width=17)
level.bind("<Enter>", lambda evt, num="owner": changetext(num))
level.bind("<Leave>", lambda evt, num=-1: changetext(num))
level.grid(row=0, column=1, sticky="nsew")

minlvlbtn = Button(headerframe, text="‚ûñ", borderwidth=1, font=("Arial", ftsize-2), command=takelevel, bg="darkgrey")
minlvlbtn.grid(row=0, column=0, sticky="nsew")

addlvlbtn = Button(headerframe, text="‚ûï", borderwidth=1, font=("Arial", ftsize-2), command=givelevel, bg="darkgrey")
addlvlbtn.grid(row=0, column=2, sticky="nsew")


labelview = Frame(deckview, bg="lightgrey", pady=0, padx=16)
labelview.pack(side=LEFT, expand=True, fill=BOTH)

name = Label(labelview, text="Species", font=("Arial", ftsize), bg="lightgrey")
name.pack(expand=True, fill=X)
gender = Label(labelview, text="Gender", font=("Arial", ftsize), bg="lightgrey", width=6)
gender.pack(expand=True, fill=X)
attack = Label(labelview, text="Attack", font=("Arial", ftsize), bg="lightgrey", width=6)
attack.pack(expand=True, fill=X)
defence = Label(labelview, text="Defence", font=("Arial", ftsize), bg="lightgrey", width=6)
defence.pack(expand=True, fill=X)
workspeed = Label(labelview, text="Workspeed", font=("Arial", ftsize), bg="lightgrey", width=10)
workspeed.pack(expand=True, fill=X)
rankspeed = Label(labelview, text="Rank", font=("Arial", ftsize), bg="lightgrey")
rankspeed.pack(expand=True, fill=X)

editview = Frame(deckview)
editview.pack(side=RIGHT, expand=True, fill=BOTH)

species = [e.value.GetName() for e in PalType]
species.sort()
speciesvar = StringVar()
speciesvar.set("PalEdit")
palname = OptionMenu(editview, speciesvar, *species, command=changespeciestype)
palname.config(font=("Arial", ftsize), padx=0, pady=0, borderwidth=1, width=5, direction='right')
palname.pack(expand=True, fill=X)

genderframe = Frame(editview, pady=0)
genderframe.pack()
palgender = Label(genderframe, text="Unknown", font=("Arial", ftsize), fg=PalGender.UNKNOWN.value, width=10)
palgender.pack(side=LEFT, expand=True, fill=X)
swapbtn = Button(genderframe, text="‚Ü∫", borderwidth=1, font=("Arial", ftsize-2), command=swapgender)
swapbtn.pack(side=RIGHT)

def clamp(var):
    try:
        int(var.get())
    except TclError as e:
        return

    if var.get() > 100:
        var.set(100)
        return

    if var.get() < 0:
        var.set(0)
        return

def ivvalidate(p):
    if len(p) > 3:
        return False
    
    if p.isdigit() or p == "":
        return True

    return False

def fillifempty(var):
    try:
        int(var.get())
    except TclError as e:
        var.set(0)

valreg = root.register(ivvalidate)

attackframe = Frame(editview, width=6)
attackframe.pack(fill=X)
meleevar = IntVar()
shotvar = IntVar()
meleevar.trace("w", lambda name, index, mode, sv=meleevar: clamp(sv))
shotvar.trace("w", lambda name, index, mode, sv=shotvar: clamp(sv))
meleevar.set(100)
shotvar.set(0)
meleeicon = Label(attackframe, text="‚öî", font=("Arial", ftsize))
meleeicon.pack(side=LEFT)
shoticon = Label(attackframe, text="üèπ", font=("Arial", ftsize))
shoticon.pack(side=RIGHT)
palmelee = Entry(attackframe, textvariable=meleevar, font=("Arial", ftsize), width=6)
palmelee.config(justify="center", validate="all", validatecommand=(valreg, '%P'))
palmelee.bind("<FocusOut>", lambda evt, sv=meleevar: fillifempty(sv))
palmelee.pack(side=LEFT)
palshot = Entry(attackframe, textvariable=shotvar, font=("Arial", ftsize), width=6)
palshot.config(justify="center", validate="all", validatecommand=(valreg, '%P'))
palshot.bind("<FocusOut>", lambda evt, sv=shotvar: fillifempty(sv))
palshot.pack(side=RIGHT)


defvar = IntVar()
defvar.trace("w", lambda name, index, mode, sv=defvar: clamp(sv))
defvar.set(100)
paldef = Entry(editview, textvariable=defvar, font=("Arial", ftsize), width=6)
paldef.config(justify="center", validate="all", validatecommand=(valreg, '%P'))
paldef.bind("<FocusOut>", lambda evt, sv=defvar: fillifempty(sv))
paldef.pack(expand=True, fill=X)


wspvar = IntVar()
wspvar.trace("w", lambda name, index, mode, sv=wspvar: clamp(sv))
wspvar.set(70)
palwsp = Entry(editview, textvariable=wspvar, font=("Arial", ftsize), width=6)
palwsp.config(justify="center", validate="all", validatecommand=(valreg, '%P'))
palwsp.bind("<FocusOut>", lambda evt, sv=wspvar: fillifempty(sv))
palwsp.pack(expand=True, fill=X)

ranks = ('0', '1', '2', '3', '4')
ranksvar = IntVar()
palrank = OptionMenu(editview, ranksvar, *ranks, command=changerankchoice)
palrank.config(font=("Arial", ftsize),  justify='center', padx=0, pady=0, borderwidth=1, width=5)
ranksvar.set(ranks[4])
palrank.pack(expand=True, fill=X)

# PASSIVE ABILITIES
skillview = Frame(infoview, relief="sunken", borderwidth=2)
skillview.pack(fill=BOTH, expand=True)

topview = Frame(skillview)
topview.pack(fill=BOTH, expand=True)
botview = Frame(skillview)
botview.pack(fill=BOTH, expand=True)

skills = [StringVar(), StringVar(), StringVar(), StringVar()]
for i in range(0, 4):
    skills[i].set("Unknown")
    skills[i].trace("w", lambda *args, num=i: changeskill(num))
skills[0].set("Legend")
skills[1].set("Workaholic")
skills[2].set("Ferocious")
skills[3].set("Lucky")

op = [e.value for e in PalSkills]
op.pop(0)
op.pop(0)
op.sort()
op.insert(0, "None")
skilldrops = [
    OptionMenu(topview, skills[0], *op),
    OptionMenu(topview, skills[1], *op),
    OptionMenu(botview, skills[2], *op),
    OptionMenu(botview, skills[3], *op)
    ]

skilldrops[0].pack(side=LEFT, expand=True, fill=BOTH)
skilldrops[0].config(font=("Arial", ftsize), width=6, direction="right")
skilldrops[1].pack(side=RIGHT, expand=True, fill=BOTH)
skilldrops[1].config(font=("Arial", ftsize), width=6, direction="right")
skilldrops[2].pack(side=LEFT, expand=True, fill=BOTH)
skilldrops[2].config(font=("Arial", ftsize), width=6, direction="right")
skilldrops[3].pack(side=RIGHT, expand=True, fill=BOTH)
skilldrops[3].config(font=("Arial", ftsize), width=6, direction="right")

skilldrops[0].bind("<Enter>", lambda evt, num=0: changetext(num))
skilldrops[1].bind("<Enter>", lambda evt, num=1: changetext(num))
skilldrops[2].bind("<Enter>", lambda evt, num=2: changetext(num))
skilldrops[3].bind("<Enter>", lambda evt, num=3: changetext(num))
skilldrops[0].bind("<Leave>", lambda evt, num=-1: changetext(num))
skilldrops[1].bind("<Leave>", lambda evt, num=-1: changetext(num))
skilldrops[2].bind("<Leave>", lambda evt, num=-1: changetext(num))
skilldrops[3].bind("<Leave>", lambda evt, num=-1: changetext(num))

# PRESETS
framePresets = Frame(infoview, relief="groove", borderwidth=0)
framePresets.pack(fill=BOTH, expand=True)

framePresetsTitle = Frame(framePresets)
framePresetsTitle.pack(fill=BOTH)
presetTitle = Label(framePresetsTitle, text='Presets:', anchor='w', bg="darkgrey", font=("Arial", ftsize), width=6, height=1).pack(fill=BOTH)

framePresetsButtons = Frame(framePresets, relief="groove", borderwidth=4)
framePresetsButtons.pack(fill=BOTH, expand=True)

framePresetsButtons1 = Frame(framePresetsButtons)
framePresetsButtons1.pack(fill=BOTH, expand=True)
makeworkerBtn = Button(framePresetsButtons1, text="Worker", command=makeworker)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)
makeworkerBtn = Button(framePresetsButtons1, text="Runner", command=makerunner)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)
makeworkerBtn = Button(framePresetsButtons1, text="Tank", command=maketank)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)

framePresetsButtons2 = Frame(framePresetsButtons)
framePresetsButtons2.pack(fill=BOTH, expand=True)
makeworkerBtn = Button(framePresetsButtons2, text="DMG: Max", command=makedmgmax)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)
makeworkerBtn = Button(framePresetsButtons2, text="DMG: Balanced", command=makedmgbalanced)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)
makeworkerBtn = Button(framePresetsButtons2, text="DMG: Dragon", command=makedmgdragon)
makeworkerBtn.config(font=("Arial", 12))
makeworkerBtn.pack(side=LEFT, expand=True, fill=BOTH)

# PRESETS OPTIONS
framePresetsExtras = Frame(framePresets, relief="groove", borderwidth=4)
framePresetsExtras.pack(fill=BOTH, expand=True)

framePresetsLevel = Frame(framePresetsExtras)
framePresetsLevel.pack(fill=BOTH, expand=True)
presetTitleLevel = Label(framePresetsLevel, text='Set Level:', anchor='center', bg="lightgrey", font=("Arial", 13), width=20, height=1).pack(side=LEFT, expand=False, fill=Y)
checkboxLevelVar = IntVar()
checkboxLevel = Checkbutton(framePresetsLevel, text='Preset changes level', variable=checkboxLevelVar, onvalue='1', offvalue='0').pack(side=LEFT,expand=False, fill=BOTH)
textboxLevelVar = IntVar(value=1)
textboxLevel = Entry(framePresetsLevel, textvariable=textboxLevelVar, justify='center', width=10)
textboxLevel.config(font=("Arial", 10), width=10)
textboxLevel.pack(side=LEFT,expand=True, fill=Y)

framePresetsRank = Frame(framePresetsExtras)
framePresetsRank.pack(fill=BOTH, expand=True)
presetTitleRank = Label(framePresetsRank, text='Set Rank:', anchor='center', bg="lightgrey", font=("Arial", 13), width=20, height=1).pack(side=LEFT, expand=False, fill=Y)
checkboxRankVar = IntVar()
checkboxRank = Checkbutton(framePresetsRank, text='Preset changes rank', variable=checkboxRankVar, onvalue='1', offvalue='0').pack(side=LEFT,expand=False, fill=BOTH)
optionMenuRankVar = IntVar(value=1)
ranks = ('0', '1', '2', '3', '4')
optionMenuRank = OptionMenu(framePresetsRank, optionMenuRankVar, *ranks)
optionMenuRankVar.set(ranks[0])
optionMenuRank.config(font=("Arial", 10), width=5, justify='center')
optionMenuRank.pack(side=LEFT, expand=True, fill=Y)

framePresetsAttributes = Frame(framePresetsExtras)
framePresetsAttributes.pack(fill=BOTH, expand=False)
presetTitleAttributes = Label(framePresetsAttributes, text='Set Attributes:', anchor='center', bg="lightgrey", font=("Arial", 13), width=20, height=1).pack(side=LEFT, expand=False, fill=Y)
checkboxAttributesVar = IntVar()
checkboxAttributes = Checkbutton(framePresetsAttributes, text='Preset changes attributes', variable=checkboxAttributesVar, onvalue='1', offvalue='0').pack(side=LEFT,expand=False, fill=BOTH)
presetTitleAttributesTodo = Label(framePresetsAttributes, text='Not Yet', font=("Arial", 10), width=10, justify='center').pack(side=LEFT, expand=True, fill=Y)

# DEBUG
frameDebug = Frame(infoview, relief="flat")
frameDebug.pack()
frameDebug.pack_forget()
presetTitle = Label(frameDebug, text='Debug:', anchor='w', bg="darkgrey", font=("Arial", ftsize), width=6, height=1).pack(fill=BOTH)
button = Button(frameDebug, text="Get Info", command=getSelectedPalInfo)
button.config(font=("Arial", 12))
button.pack(side=LEFT, expand=True, fill=BOTH)
button = Button(frameDebug, text="Get Data", command=getSelectedPalData)
button.config(font=("Arial", 12))
button.pack(side=LEFT, expand=True, fill=BOTH)

# FOOTER
frameFooter = Frame(infoview, relief="flat")
frameFooter.pack(fill=BOTH, expand=False)
skilllabel = Label(frameFooter, text="Hover a skill to see it's description")
skilllabel.pack()



root.mainloop()

```

`PalInfo.py`:

```py
import json

from enum import Enum
from PIL import ImageTk, Image
from EmptyObjectHandler import *

xpthresholds = [
    0,
    25,
    56,
    93,
    138,
    207,
    306,
    440,
    616,
    843,
    1131,
    1492,
    1941,
    2495,
    3175,
    4007,
    5021,
    6253,
    7747,
    9555,
    11740,
    14378,
    17559,
    21392,
    26007,
    31561,
    38241,
    46272,
    55925,
    67524,
    81458,
    98195,
    118294,
    142429,
    171406,
    206194,
    247955,
    298134,
    358305,
    430525,
    517205,
    621236,
    746089,
    895928,
    1075751,
    1291554,
    1550533,
    1861323,
    2234286,
    2681857
]
if len(xpthresholds) < 50:
    print("Something is wrong with the thresholds")


SkillDesc = {
        "Unknown": " does not exist or is not in our database yet",
        "None": "The pal has no skill in this slot",
        
        "Abnormal": "-10% damage received from Neutral attacks",
        "Cheery": "-10% damage received from Dark attacks",
        "Dragonkiller": "-10% damage received from Dragon attacks",
        "Heated Body": "-10% damage received from Ice attacks",
        "Suntan Lover": "-10% damage received from Fire attacks",
        "Botanical Barrier": "-10% damage received from Grass attacks",
        "Earthquake Resistant": "-10% damage received from Ground attacks",
        "Insulated Body": "-10% damage received from Electric attacks",
        "Waterproof": "-10% damage received from Water attacks",

        "Zen Mind": "+10% damage dealt with Neutral attacks",
        "Veil of Darkness": "+10% damage dealt with Dark attacks",
        "Blood of the Dragon": "+10% damage dealt with Dragon attacks",
        "Coldblooded": "+10% damage dealt with Ice attacks",
        "Pyromaniac": "+10% damage dealt with Fire attacks",
        "Fragrant Foliage": "+10% damage dealt with Grass attacks",
        "Power of Gaia": "+10% damage dealt with Ground attacks",
        "Capacitor": "+10% damage dealt with Electric attacks",
        "Hydromaniac": "+10% damage dealt with Water attacks",

        "Celestial Emperor": "+20% damage dealt with Neutral attacks; Paladius' signature ability",
        "Lord of the Underworld": "+20% damage dealt with Dark attacks; Necromus' signature ability",
        "Divine Dragon": "+20% damage dealt with Dragon attacks; Jetragon's signature ability",
        "Ice Emperor": "+20% damage dealt with Ice attacks; Frostallion's signature ability",
        "Flame Emperor": "+20% damage dealt with Fire attacks; Blazamut's signature ability",
        "Spirit Emperor": "+20% damage dealt with Grass attacks; Lyleen's signature ability",
        "Earth Emperor": "+20% damage dealt with Ground attacks; Anubis' signature ability",
        "Lord of Lightning": "+20% damage dealt with Electric attacks; Orserk's signature ability",
        "Lord of the Sea": "+20% damage dealt with Water attacks; Jormuntide's signature ability",

        "Brave": "+10% to Attack stat",
        "Ferocious": "+20% to Attack stat",
        "Coward": "-10% to Attack stat",
        "Pacifist": "-20% to Attack stat",
        
        "Hard Skin": "+10% to Defence stat",
        "Burly Body": "+20% to Defence stat",
        "Downtrodden": "-10% to Defence stat",
        "Brittle": "-20% to Defence stat",

        "Mine Foreman": "+25% to Player mining efficiency",
        "Logging Foreman": "+25% to Player logging efficiency",
        "Vanguard": "+10% to Player attack stat",
        "Motivational Leader": "+25% to Player move speed",
        "Stronghold Strategist": "+10% to Player defence stat",

        "Positive Thinker": "Sanity drops 10% slower",
        "Workaholic": "Sanity drops 15% slower",
        "Unstable": "Sanity drops 10% faster",
        "Destructive": "Sanity drops 15% faster",

        "Dainty Eater": "Hunger drops 10% slower",
        "Diet Lover": "Chance to lose hunger -15%",
        "Glutton": "Hunger drops 10% faster",
        "Bottomless Stomach": "Hunger drops 15% faster",

        "Serious": "+20% work speed",
        "Artisan": "+50% work speed",
        "Clumsy": "-10% work speed",
        "Slacker": "-30% work speed",

        "Nimble": "+10% movement speed",
        "Runner": "+20% movement speed",
        "Swift": "+30% movement speed",

        "Work Slave": "+30% work speed, -30% attack",

        "Hooligan": "+15% attack, -10% work speed",
        "Musclehead": "+30% attack, -50% work speed",

        "Aggressive": "+10% attack, -20% defence",

        "Conceited": "+10% work speed, -20% defence",

        "Masochist": "+15% defence, -15% attack",
        "Sadist": "+15% attack, +15% defence",

        "Lucky": "+15% attack, +15% work speed",
        "Legend": "+20% attack, +20% defence, +15% move speed",
        
        "":""
    }
    
class PalSkills(Enum):
    UNKNOWN = "Unknown"
    NONE = "None"
    
    ElementResist_Normal_1_PAL = "Abnormal"
    ElementResist_Dark_1_PAL = "Cheery"
    ElementResist_Dragon_1_PAL = "Dragonkiller"
    ElementResist_Ice_1_PAL = "Heated Body"
    ElementResist_Fire_1_PAL = "Suntan Lover"
    ElementResist_Leaf_1_PAL = "Botanical Barrier"
    ElementResist_Earth_1_PAL = "Earthquake Resistant"
    ElementResist_Thunder_1_PAL = "Insulated Body"
    ElementResist_Aqua_1_PAL = "Waterproof"

    ElementBoost_Normal_1_PAL = "Zen Mind"
    ElementBoost_Dark_1_PAL = "Veil of Darkness"
    ElementBoost_Dragon_1_PAL = "Blood of the Dragon"
    ElementBoost_Ice_1_PAL = "Coldblooded"
    ElementBoost_Fire_1_PAL = "Pyromaniac"
    ElementBoost_Leaf_1_PAL = "Fragrant Foliage"
    ElementBoost_Earth_1_PAL = "Power of Gaia"
    ElementBoost_Thunder_1_PAL = "Capacitor"
    ElementBoost_Aqua_1_PAL = "Hydromaniac"

    ElementBoost_Normal_2_PAL = "Celestial Emperor"
    ElementBoost_Dark_2_PAL = "Lord of the Underworld"
    ElementBoost_Dragon_2_PAL = "Divine Dragon"
    ElementBoost_Ice_2_PAL = "Ice Emperor"
    ElementBoost_Fire_2_PAL = "Flame Emperor"
    ElementBoost_Leaf_2_PAL = "Spirit Emperor"
    ElementBoost_Earth_2_PAL = "Earth Emperor"
    ElementBoost_Thunder_2_PAL = "Lord of Lightning"
    ElementBoost_Aqua_2_PAL = "Lord of the Sea"

    PAL_ALLAttack_up1 = "Brave"
    PAL_ALLAttack_up2 = "Ferocious"
    PAL_ALLAttack_down1 = "Coward"
    PAL_ALLAttack_down2 = "Pacifist"
    
    Deffence_up1 = "Hard Skin"
    Deffence_up2 = "Burly Body"
    Deffence_down1 = "Downtrodden"
    Deffence_down2 = "Brittle"

    TrainerMining_up1 = "Mine Foreman"
    TrainerLogging_up1 = "Logging Foreman"
    TrainerATK_UP_1 = "Vanguard"
    TrainerWorkSpeed_UP_1 = "Motivational Leader"
    TrainerDEF_UP_1 = "Stronghold Strategist"

    PAL_Sanity_Down_1 = "Positive Thinker"
    PAL_Sanity_Down_2 = "Workaholic"
    PAL_Sanity_Up_1 = "Unstable"
    PAL_Sanity_Up_2 = "Destructive"

    PAL_FullStomach_Down_1 = "Dainty Eater"
    PAL_FullStomach_Down_2 = "Diet Lover"
    PAL_FullStomach_Up_1 = "Glutton"
    PAL_FullStomach_Up_2 = "Bottomless Stomach"
    

    CraftSpeed_up1 = "Serious"
    CraftSpeed_up2 = "Artisan"
    CraftSpeed_down1 = "Clumsy"
    CraftSpeed_down2 = "Slacker"

    MoveSpeed_up_1 = "Nimble"
    MoveSpeed_up_2 = "Runner"
    MoveSpeed_up_3 = "Swift"

    PAL_CorporateSlave = "Work Slave"

    PAL_rude = "Hooligan"
    Noukin = "Musclehead"

    PAL_oraora = "Aggressive"

    PAL_conceited = "Conceited"

    PAL_masochist = "Masochist"
    PAL_sadist = "Sadist"
    
    Rare = "Lucky"
    Legend = "Legend"


class PalGender(Enum):
    MALE = "#02A3FE"
    FEMALE = "#EC49A6"
    UNKNOWN = "darkgrey"

class PalElement:
    def __init__(self, name, colour):
        self._name = name
        self._colour = colour

    def GetName(self):
        return self._name

    def GetColour(self):
        return self._colour
    
class Elements(Enum):
    NONE = PalElement("None", "lightgrey")
    NORMAL = PalElement("Neutral", "#D8A796")
    DARK = PalElement("Dark", "#AD0035")
    DRAGON = PalElement("Dragon", "#C22DF9")
    ICE = PalElement("Ice", "#00F2FF")
    FIRE = PalElement("Fire", "#FF4208")
    LEAF = PalElement("Grass", "#83F001")
    EARTH = PalElement("Ground", "#BA5608")
    ELECTRICITY = PalElement("Electric", "#FEED01")
    WATER = PalElement("Water", "#0074FF")

class PalObject:
    def __init__(self, name, primary, secondary=Elements.NONE, human=False, tower=False):
        self._name = name
        self._img = None
        self._primary = primary
        self._secondary = secondary
        self._human = human
        self._tower = tower

    def GetName(self):
        return self._name

    def IsTower(self):
        return self._tower

    def GetImage(self):
        if self._img == None:
            n = self.GetName() if not self._human else "#ERROR"
            self._img = ImageTk.PhotoImage(Image.open(f'resources/{n}.png').resize((240,240)))
        return self._img

    
    def GetPrimary(self):
        return self._primary

    def GetSecondary(self):
        return self._secondary

class PalType(Enum):
    # Thank you to @DMVoidKitten
    
    # Normal Pal List
    Alpaca = PalObject("Melpaca", Elements.NORMAL)#
    AmaterasuWolf = PalObject("Kitsun", Elements.FIRE)#
    Anubis = PalObject("Anubis", Elements.EARTH)#
    Baphomet = PalObject("Incineram", Elements.FIRE, Elements.DARK)#
    Baphomet_Dark = PalObject("Incineram Noct", Elements.DARK)#
    Bastet = PalObject("Mau", Elements.DARK)#
    Bastet_Ice = PalObject("Mau Cryst", Elements.ICE)#
    BerryGoat = PalObject("Caprity", Elements.LEAF)#
    BirdDragon = PalObject("Vanwyrm", Elements.FIRE, Elements.DARK)#
    BirdDragon_Ice = PalObject("Vanwyrm Cryst", Elements.ICE, Elements.DARK)#
    BlackCentaur = PalObject("Necromus", Elements.DARK)#
    BlackGriffon = PalObject("Shadowbeak", Elements.DARK)#
    BlackMetalDragon = PalObject("Astegon", Elements.DRAGON, Elements.DARK)#
    BlueDragon = PalObject("Azurobe", Elements.WATER, Elements.DRAGON)#
    BluePlatypus = PalObject("Fuack", Elements.WATER)#
    Boar = PalObject("Rushoar", Elements.EARTH)#
    CaptainPenguin = PalObject("Penking", Elements.WATER, Elements.ICE)#
    Carbunclo = PalObject("Lifmunk", Elements.LEAF)#
    CatBat = PalObject("Tombat", Elements.DARK)#
    CatMage = PalObject("Katress", Elements.DARK)#
    CatVampire = PalObject("Felbat", Elements.DARK)#
    ChickenPal = PalObject("Chikipi", Elements.NORMAL)#
    ColorfulBird = PalObject("Tocotoco", Elements.NORMAL)#
    CowPal = PalObject("Mozzarina", Elements.NORMAL)#
    CuteButterfly = PalObject("Cinnamoth", Elements.LEAF)#
    CuteFox = PalObject("Vixy", Elements.NORMAL)#
    CuteMole = PalObject("Fuddler", Elements.EARTH)#
    DarkCrow = PalObject("Cawgnito", Elements.DARK)#
    DarkScorpion = PalObject("Menasting", Elements.DARK, Elements.EARTH)#
    Deer = PalObject("Eikthyrdeer", Elements.NORMAL)#
    Deer_Ground = PalObject("Eikthyrdeer Terra", Elements.EARTH)#
    DreamDemon = PalObject("Daedream", Elements.DARK)#
    DrillGame = PalObject("Digtoise", Elements.EARTH)#
    Eagle = PalObject("Galeclaw", Elements.NORMAL)#
    ElecCat = PalObject("Sparkit", Elements.ELECTRICITY)#
    ElecPanda = PalObject("Grizzbolt", Elements.ELECTRICITY)#
    FairyDragon = PalObject("Elphidran", Elements.DRAGON)#
    FairyDragon_Water = PalObject("Elphidran Aqua", Elements.DRAGON, Elements.WATER)#
    FengyunDeeper = PalObject("Fenglope", Elements.NORMAL)#
    FireKirin = PalObject("Pyrin", Elements.FIRE)#
    FireKirin_Dark = PalObject("Pyrin Noct", Elements.FIRE, Elements.DARK)#
    FlameBambi = PalObject("Rooby", Elements.FIRE)#
    FlameBuffalo = PalObject("Arsox", Elements.FIRE)#
    FlowerDinosaur = PalObject("Dinossom", Elements.LEAF, Elements.DRAGON)#
    FlowerDinosaur_Electric = PalObject("Dinossom Lux", Elements.ELECTRICITY, Elements.DRAGON)#
    FlowerDoll = PalObject("Petallia", Elements.LEAF)#
    FlowerRabbit = PalObject("Flopie", Elements.LEAF)#
    FlyingManta = PalObject("Celaray", Elements.WATER)#
    FoxMage = PalObject("Wixen", Elements.FIRE)#
    Ganesha = PalObject("Teafant", Elements.WATER)#
    Garm = PalObject("Direhowl", Elements.NORMAL)#
    GhostBeast = PalObject("Maraith", Elements.DARK)#
    Gorilla = PalObject("Gorirat", Elements.NORMAL)#
    GrassMammoth = PalObject("Mammorest", Elements.LEAF)#
    GrassMammoth_Ice = PalObject("Mammorest Cryst", Elements.ICE)#
    GrassPanda = PalObject("Mossanda", Elements.LEAF)#
    GrassPanda_Electric = PalObject("Mossanda Lux", Elements.ELECTRICITY)#
    GrassRabbitMan = PalObject("Verdash", Elements.LEAF)#
    HadesBird = PalObject("Helzephyr", Elements.DARK)#
    HawkBird = PalObject("Nitewing", Elements.NORMAL)#
    Hedgehog = PalObject("Jolthog", Elements.ELECTRICITY)#
    Hedgehog_Ice = PalObject("Jolthog Cryst", Elements.ICE)#
    HerculesBeetle = PalObject("Warsect", Elements.EARTH, Elements.LEAF)#
    Horus = PalObject("Faleris", Elements.FIRE)#
    IceDeer = PalObject("Reindrix", Elements.ICE)#
    IceFox = PalObject("Foxcicle", Elements.ICE)#
    IceHorse = PalObject("Frostallion", Elements.ICE)#
    IceHorse_Dark = PalObject("Frostallion Noct", Elements.DARK)#
    JetDragon = PalObject("Jetragon", Elements.DRAGON)#
    Kelpie = PalObject("Kelpsea", Elements.WATER)#
    Kelpie_Fire = PalObject("Kelpsea Ignis", Elements.FIRE)#
    KingAlpaca = PalObject("Kingpaca", Elements.NORMAL)#
    KingAlpaca_Ice = PalObject("Ice Kingpaca", Elements.ICE)#
    KingBahamut = PalObject("Blazamut", Elements.FIRE)#
    Kirin = PalObject("Univolt", Elements.ELECTRICITY)#
    Kitsunebi = PalObject("Foxparks", Elements.FIRE)#
    LavaGirl = PalObject("Flambelle", Elements.FIRE)#
    LazyCatfish = PalObject("Dumud", Elements.EARTH)#
    LazyDragon = PalObject("Relaxaurus", Elements.DRAGON, Elements.WATER)#
    LazyDragon_Electric = PalObject("Relaxaurus Lux", Elements.DRAGON, Elements.ELECTRICITY)#
    LilyQueen = PalObject("Lyleen", Elements.LEAF)#
    LilyQueen_Dark = PalObject("Lyleen Noct", Elements.DARK)#
    LittleBriarRose = PalObject("Bristla", Elements.LEAF)#
    LizardMan = PalObject("Leezpunk", Elements.DARK)#
    LizardMan_Fire = PalObject("Leezpunk Ignis", Elements.FIRE)#
    Manticore = PalObject("Blazehowl", Elements.FIRE)#
    Manticore_Dark = PalObject("Blazehowl Noct", Elements.FIRE, Elements.DARK)#
    Monkey = PalObject("Tanzee", Elements.LEAF)#
    MopBaby = PalObject("Swee", Elements.ICE)#
    MopKing = PalObject("Sweepa", Elements.ICE)#
    Mutant = PalObject("Lunaris", Elements.NORMAL)#
    NaughtyCat = PalObject("Grintale", Elements.NORMAL)#
    NegativeKoala = PalObject("Depresso", Elements.DARK)#
    NegativeOctopus = PalObject("Killamari", Elements.DARK)#
    NightFox = PalObject("Nox", Elements.DARK)#
    Penguin = PalObject("Pengullet", Elements.WATER, Elements.ICE)#
    PinkCat = PalObject("Cattiva", Elements.NORMAL)#
    PinkLizard = PalObject("Lovander", Elements.NORMAL)#
    PinkRabbit = PalObject("Ribbuny", Elements.NORMAL)#
    PlantSlime = PalObject("Gumoss", Elements.LEAF, Elements.EARTH)#
    QueenBee = PalObject("Elizabee", Elements.LEAF)#
    RaijinDaughter = PalObject("Dazzi", Elements.ELECTRICITY)#
    RedArmorBird = PalObject("Ragnahawk", Elements.FIRE)#
    RobinHood = PalObject("Robinquill", Elements.LEAF)#
    RobinHood_Ground = PalObject("Robinquill Terra", Elements.LEAF, Elements.EARTH)#
    Ronin = PalObject("Bushi", Elements.FIRE)#
    SaintCentaur = PalObject("Paladius", Elements.NORMAL)#
    SakuraSaurus = PalObject("Broncherry", Elements.LEAF)#
    SakuraSaurus_Water = PalObject("Broncherry Aqua", Elements.LEAF, Elements.WATER)#
    Serpent = PalObject("Surfent", Elements.WATER)#
    Serpent_Ground = PalObject("Surfent Terra", Elements.EARTH)#
    SharkKid = PalObject("Gobfin", Elements.WATER)#
    SharkKid_Fire = PalObject("Gobfin Ignis", Elements.FIRE)#
    Sheepball = PalObject("Lamball", Elements.NORMAL)#
    SkyDragon = PalObject("Quivern", Elements.DRAGON)#
    SoldierBee = PalObject("Beegarde", Elements.LEAF)#
    Suzaku = PalObject("Suzaku", Elements.FIRE)#
    Suzaku_Water = PalObject("Suzaku Aqua", Elements.WATER)#
    SweetsSheep = PalObject("Woolipop", Elements.NORMAL)#
    ThunderBird = PalObject("Beakon", Elements.ELECTRICITY)#
    ThunderDog = PalObject("Rayhound", Elements.ELECTRICITY)#
    ThunderDragonMan = PalObject("Orserk", Elements.DRAGON, Elements.ELECTRICITY)#
    Umihebi = PalObject("Jormuntide", Elements.DRAGON, Elements.WATER)#
    Umihebi_Fire = PalObject("Jormuntide Ignis", Elements.DRAGON, Elements.FIRE)#
    VioletFairy = PalObject("Vaelet", Elements.LEAF)#
    VolcanicMonster = PalObject("Reptyro", Elements.FIRE, Elements.EARTH)#
    VolcanicMonster_Ice = PalObject("Reptyro Cryst", Elements.ICE, Elements.EARTH)#
    WeaselDragon = PalObject("Chillet", Elements.ICE, Elements.DRAGON)#
    Werewolf = PalObject("Loupmoon", Elements.DARK)#
    WhiteMoth = PalObject("Sibelyx", Elements.ICE)#
    WhiteTiger = PalObject("Cryolinx", Elements.ICE)#
    WindChimes = PalObject("Hangyu", Elements.EARTH)#
    WindChimes_Ice = PalObject("Hangyu Cryst", Elements.ICE)#
    WizardOwl = PalObject("Hoocrates", Elements.DARK)#
    WoolFox = PalObject("Cremis", Elements.NORMAL)#
    Yeti = PalObject("Wumpo", Elements.ICE)#
    Yeti_Grass = PalObject("Wumpo Botan", Elements.LEAF)#

    # Tower Bosses
    GYM_ThunderDragonMan = PalObject("Axel & Orserk", Elements.DRAGON, Elements.ELECTRICITY, tower=True)#
    GYM_LilyQueen = PalObject("Lily & Lyleen", Elements.LEAF, tower=True)#
    GYM_Horus = PalObject("Marus & Faleris", Elements.FIRE, tower=True)#
    GYM_BlackGriffon = PalObject("Victor & Shadowbeak", Elements.DARK, tower=True)#
    GYM_ElecPanda = PalObject("Zoe & Grizzbolt", Elements.ELECTRICITY, tower=True)#

    # Human Entities (Not yet finished)
    Male_DarkTrader01 = PalObject("Black Marketeer", Elements.NONE, human=True)#
    FireCult_FlameThrower = PalObject("Brothers of the Eternal Pyre Martyr", Elements.NONE, human=True)#
    Male_Soldier01 = PalObject("Burly Merc", Elements.NONE, human=True)#
    Female_Soldier01 = PalObject("Expedition Survivor", Elements.NONE, human=True)#
    Believer_CrossBow = PalObject("Free Pal Alliance Devout", Elements.NONE, human=True)#
    Male_Scientist01_LaserRifle = PalObject("PAL Genetic Research Unit Executioner", Elements.NONE, human=True)#
    PalDealer = PalObject("Pal Merchant", Elements.NONE, human=True)#
    Police_Handgun = PalObject("PIDF Guard", Elements.NONE, human=True)#
    Hunter_Bat = PalObject("Syndicate Thug (Bat)", Elements.NONE, human=True)#
    Hunter_FlameThrower = PalObject("Syndicate Cleaner", Elements.NONE, human=True)#
    Hunter_Fat_GatlingGun = PalObject("Syndicate Crusher", Elements.NONE, human=True)#
    Hunter_RocketLauncher = PalObject("Syndicate Elite", Elements.NONE, human=True)#
    Hunter_Grenade = PalObject("Syndicate Grenadier", Elements.NONE, human=True)#
    Hunter_Rifle = PalObject("Syndicate Gunner", Elements.NONE, human=True)#
    Hunter_Shotgun = PalObject("Syndicate Hunter", Elements.NONE, human=True)#
    Hunter_Handgun = PalObject("Syndicate Thug (Handgun)", Elements.NONE, human=True)#
    SalesPerson = PalObject("Wandering Merchant", Elements.NONE, human=True)#

    @classmethod
    def find(self, value):
        for i in PalType:
            if i.value.GetName() == value:
                return i

class PalEntity:

    def __init__(self, data):
        self._data = data
        self._obj = data['value']['RawData']['value']['object']['SaveParameter']['value']

        self.owner = ""
        if "OwnerPlayerUId" in self._obj:
            self.owner = self._obj["OwnerPlayerUId"]['value']

        if "IsPlayer" in self._obj:
            raise Exception("This is a player character")

        if not "IsRarePal" in self._obj:
            self._obj["IsRarePal"] = EmptyRarePalObject.copy()
        self.isLucky = self._obj["IsRarePal"]['value']

        
        typename = self._obj['CharacterID']['value']
        # print(f"Debug: typename1 - {typename}")

        self.isBoss = False
        if typename[:5].lower() == "boss_":
            typename = typename[5:] # if first 5 characters match boss_ then cut the first 5 characters off
            # typename = typename.replace("BOSS_", "") # this causes bugs
            self.isBoss = True if not self.isLucky else False
            if typename == "LazyCatFish": # BOSS_LazyCatFish and LazyCatfish
                typename = "LazyCatfish"

        # print(f"Debug: typename2 - '{typename}'")
        if typename.lower() == "sheepball":
            typename = "Sheepball"

            # Strangely, Boss and Lucky Lamballs have camelcasing
            # Regular ones... don't
        # print(f"Debug: typename3 - '{typename}'")
        
        self._type = PalType[typename]
        print(f"Created Entity of type {typename}: {self._type.value} - Lucky: {self.isLucky} Boss: {self.isBoss}")

        if "Gender" in self._obj:
            if self._obj['Gender']['value']['value'] == "EPalGenderType::Male":
                self._gender = "Male ‚ôÇ"
            else:
                self._gender = "Female ‚ôÄ"
        else:
            self._gender = "Unknown"

        self._workspeed = self._obj['CraftSpeed']['value']

        if not "Talent_Melee" in self._obj:
            self._obj['Talent_Melee'] = EmptyMeleeObject.copy()
        self._melee = self._obj['Talent_Melee']['value']

        if not "Talent_Shot" in self._obj:
            self._obj['Talent_Shot'] = EmptyShotObject.copy()
        self._ranged = self._obj['Talent_Shot']['value']

        if not "Talent_Defense" in self._obj:
            self._obj['Talent_Defense'] = EmptyDefenceObject.copy()
        self._defence = self._obj['Talent_Defense']['value']

        if not "Rank" in self._obj:
            self._obj['Rank'] = EmptyRankObject.copy()
        self._rank = self._obj['Rank']['value']

        # Fix broken ranks
        if self.GetRank() < 1 or self.GetRank() > 5:
            self.SetRank(1)

        if not "PassiveSkillList" in self._obj:
            self._obj['PassiveSkillList'] = EmptySkillObject.copy()
        self._skills = self._obj['PassiveSkillList']['value']['values']
        self.CleanseSkills()

        if not "Level" in self._obj:
            self._obj['Level'] = EmptyLevelObject.copy()
        self._level = self._obj['Level']['value']

        if not "Exp" in self._obj:
            self._obj['Exp'] = EmptyExpObject.copy()
        # We don't store Exp yet

        self._nickname = ""
        if "NickName" in self._obj:
            self._nickname = self._obj['NickName']['value']

        self.isTower = self._type.value.IsTower()

    def SwapGender(self):
        if self._obj['Gender']['value']['value'] == "EPalGenderType::Male":
            self._obj['Gender']['value']['value'] = "EPalGenderType::Female"
            self._gender = "Female ‚ôÄ"
        else:
            self._obj['Gender']['value']['value'] = "EPalGenderType::Male"
            self._gender = "Male ‚ôÇ"
               

    def CleanseSkills(self):
        i = 0
        while i < len(self._skills):
            if self._skills[i].lower() == "none":
                self._skills.pop(i)
            else:
                i+=1
        
    def GetType(self):
        return self._type

    def SetType(self, value):
        self._obj['CharacterID']['value'] = ("BOSS_" if (self.isBoss or self.isLucky) else "") + PalType.find(value).name
        self._type = PalType.find(value)

    def GetObject(self):
        return self._type.value

    def GetGender(self):
        return self._gender

    def GetWorkSpeed(self):
        return self._workspeed

    def SetWorkSpeed(self, value):
        self._obj['CraftSpeed']['value'] = self._workspeed = value

    def SetAttack(self, mval, rval):
        self._obj['Talent_Melee']['value'] = self._melee = mval
        self._obj['Talent_Shot']['value'] = self._ranged = rval

    def GetAttackMelee(self):
        return self._melee

    def SetAttackMelee(self, value):
        self._obj['Talent_Melee']['value'] = self._melee = value

    def GetAttackRanged(self):
        return self._ranged

    def SetAttackRanged(self, value):
        self._obj['Talent_Shot']['value'] = self._ranged = value

    def GetDefence(self):
        return self._defence

    def SetDefence(self, value):
        self._obj['Talent_Defense']['value'] = self._defence = value

    def GetName(self):
        return self.GetObject().GetName()

    def GetImage(self):
        return self.GetObject().GetImage()
    
    def GetPrimary(self):
        return self.GetObject().GetPrimary().value

    def GetSecondary(self):
        return self.GetObject().GetSecondary().value

    def GetSkills(self):
        self.CleanseSkills()
        return self._skills

    def SkillCount(self):
        return len(self._skills)

    def SetSkill(self, slot, skill):
        if slot > len(self._skills)-1:
            self._skills.append(PalSkills(skill).name)
        else:
            self._skills[slot] = PalSkills(skill).name

    def GetOwner(self):
        return self.owner

    def GetLevel(self):
        return self._level

    def SetLevel(self, value):
        # We need this check until we fix adding missing nodes
        if "Level" in self._obj and "Exp" in self._obj:
            self._obj['Level']['value'] = self._level = value
            self._obj['Exp']['value'] = xpthresholds[value-1]
        else:
            print(f"[ERROR:] Failed to update level for: '{self.GetName()}'")

    def GetRank(self):
        return self._rank

    def SetRank(self, value):
        if "Rank" in self._obj:
            self._obj['Rank']['value'] = self._rank = value # we dont +1 here, since we have methods to patch rank in PalEdit.py
        else:
            print(f"[ERROR:] Failed to update rank for: '{self.GetName()}'") # we probably could get rid of this line, since you add rank if missing - same with level

    def RemoveSkill(self, slot):
        if slot < len(self._skills):
            self._skills.pop(slot)

    def GetNickname(self):
        return self.GetName() if self._nickname == "" else self._nickname

    def GetFullName(self):
        return self.GetObject().GetName() + (" üíÄ" if self.isBoss else "") + (" ‚ôñ" if self.isTower else "" ) + (" ‚ú®" if self.isLucky else "") + (f" - '{self._nickname}'" if not self._nickname == "" else "")
    
    def SetLucky(self, v=True):
        self._obj["IsRarePal"]['value'] = self.isLucky = v
        self.SetType(self._type.value.GetName())
        if v:
            if self.isBoss:
                self.isBoss = False
                
    def SetBoss(self, v=True):
        self.isBoss = v
        self.SetType(self._type.value.GetName())
        if v:
            if self.isLucky:
                self.SetLucky(False)

        

if __name__ == "__main__":
    import os

    print(len(PalType))
    
    print(PalType.GrassPanda)
    print(PalType.GrassPanda.name)
    print(PalType.GrassPanda.value)

    for i in PalType:
        if not os.path.exists(f"resources/{i.value.GetName()}.png"):
            f = open(f"resources/{i.value.GetName()}.png", "w")
            f.write("0")
            f.close()

```

`README.md`:

```md
> Because apparently it needs to be stated here as well as in the NexusMods; the application is __unsigned__ and therefore can flag up a __False Positive__ with some anti-virus software. If you are really scared about it being a virus, download the application and compile it yourself. Look through the source code. [You can see a virus report here](https://www.virustotal.com/gui/file/d20dcab42b8ba55442c27c16235c27fb80d16f7494ee32a790767a2eb38ceefb)

<h1 align="center">PalEdit</h1>

<div align="center">

[![GitHub Pull Requests](https://img.shields.io/github/issues-pr/EternalWraith/PalEdit.svg)](https://github.com/EternalWraith/PalEdit/pulls)
[![GitHub Issues](https://img.shields.io/github/issues/EternalWraith/PalEdit.svg)](https://github.com/EternalWraith/PalEdit/issues)
![Python](https://img.shields.io/badge/python-FFD43B.svg?&logo=python&logoColor=ffde57&color=4584b6)
<br>
**A simple tool for editing and generating Pals within PalWorld saves.**

</div>

> ‚ö†Ô∏è **Before Opening a new Issue**: Please check the [**üöß Project roadmap**](#-project-roadmap) section to ensure that your concern or feature request hasn't already been addressed or is planned for a future release. Also check the [Open Issues](https://github.com/EternalWraith/PalEdit/issues).

## **üìö Table of Contents**

- [**üöÄ Installation**](#-installation)
- [**‚ö†Ô∏è A word of warning**](#Ô∏è-a-word-of-warning)
- [**üïπÔ∏è Usage**](#Ô∏è-usage)
- [**üíæ Saving Edited Pals**](#-saving-edited-pals)
- [**üì¶ Backing up your save**](#-backing-up-your-save)
- [**üöß Project roadmap**](#-project-roadmap)

## **üöÄ Installation**

Download the compiled executable from [Nexus Mods](https://www.nexusmods.com/palworld/mods/104) or over on the [Releases Page](https://github.com/EternalWraith/PalEdit/releases).

## **‚ö†Ô∏è A word of warning**

When in the app, simply load a _deserialized_ save file using the file menu. Wait **patiently** for it to load the `*.json` and gather the data.
You can then replace the traits of your Pals with ones that you want.

> [!CAUTION]
> It is advised that you backup ALL save files before using the tool; it will eventually do this on it's own but doesn't yet.
> For more information on how to do this, see the [**üì¶ Backing up your save**](#-backing-up-your-save) section.

It is recommended to save your edited pals as a `*.pson` file for easier access. You can choose to save as a `*.pson` file. When you want to inject the changes into your save, simply save over your `Level.sav.json` and the program will splice it in at the correct location. Then Serialize the save again using 'palworld-save-tools' and put the resulting `Level.sav` into your save folder where the original one was. Load up PalWorld and enjoy.

## **üïπÔ∏è Usage**

1. Convert your save to a `*.sav.json` using the Convert menu at the top.
2. Load the `*.sav.json` file using the File menu.
3. Edit your Pals as desired.
4. Save the changes to the same `*.sav.json` file.
5. Convert it back to a `*.sav` using the Convert menu again.

## **üíæ Saving Edited Pals**

1. Save your edited pals as a `*.pson` file for easier access.
2. Choose to save as a `*.pson` file.
3. To inject the changes into your save, save over your `Level.sav.json`.
4. The program will splice it in at the correct location.
5. Serialize the save again using the Convert menu.
6. Put the resulting `Level.sav` into your save folder where the original one was.
7. Load up PalWorld and enjoy.

## **üì¶ Backing up your save**

It is advised that you backup ALL save files before using the tool. Although the tool will eventually do this on its own, it doesn't yet.

On Windows, the saves can be found in the following locations:

- `%appdata%/Local/Pal/Save/Savegames`
- `C:\Users\<username>\AppData\Local\Pal\Saved\SaveGames`

Replace `<username>` with your Windows username.

If you‚Äôve installed Palworld via Steam, you can also access your save files by following these steps:

1. Open your Steam library.
2. Right-click on Palworld, then select Manage > Browse local files.
3. This will open the folder where Palworld‚Äôs installed files are stored, named Pal.
4. From here, go to Saved > SaveGames to access your save files for the game.

## **üöß Project roadmap**

- **Future Releases:**
  - [ ] Generating new Pals
  - [ ] Cloning Pals
  - [ ] Pal Deletion
  - [ ] Database system to make things easier to update
  - [ ] Localisation support for Chinese, Japanese, Spanish, French, German, and English (for starters)
  - [ ] Stat Editing (Hero Statue)
  - [ ] Move Editing
  - [ ] Menu displaying Pal moves/attacks
  - [ ] Pal Info Database Overhaul
  - [ ] Simplify Loading/Converting/Saving process
  - [ ] Edit Pals Nickname
  - [ ] Improve Pal ListBox UI to mimic ingame PalBox

- **v0.3 Release:**
  - [x] Integrate SaveTools into PalEdit natively.
  - [x] Nickname Compatibility
  - [x] Ability to Change Species

- **v0.4 Release:**
  - [x] Defence Editing
  - [x] Gender Swapping
  - [x] Sorted lists so that everything is alphabetical
  - [x] Rank editing (Pal Essence Condenser)
  - [x] Workspeed Editing
  - [x] Pal presets to speed up creation of workers, fighters and tanks
  - [x] Compatibility for Tower Boss and Human captures
  - [x] Overhauled Attack IV and Level Editing to make it easier
  - [x] Moved species editing to main app instead of tucked away in the Tools menu

- **v0.4.8 Release:**
  - [x] Converting Pal to Lucky
  - [x] Converting Pal to Alpha (Boss)
  - [x] Player Filtered Pals so you know who belongs to who

```

`SaveConverter.py`:

```py
#!/usr/bin/env python3

import argparse
import json
import os
from lib.gvas import GvasFile
from lib.noindent import CustomEncoder
from lib.palsav import compress_gvas_to_sav, decompress_sav_to_gvas
from lib.paltypes import PALWORLD_CUSTOM_PROPERTIES, PALWORLD_TYPE_HINTS

### Credit for this file and all those within "lib" belong to "cheahjs" on Github
### https://github.com/cheahjs/palworld-save-tools


def main():
    parser = argparse.ArgumentParser(
        prog="palworld-save-tools",
        description="Converts Palworld save files to and from JSON",
    )
    parser.add_argument("filename")
    parser.add_argument(
        "--to-json",
        action="store_true",
        help="Override heuristics and convert SAV file to JSON",
    )
    parser.add_argument(
        "--from-json",
        action="store_true",
        help="Override heuristics and convert JSON file to SAV",
    )
    parser.add_argument(
        "--output",
        "-o",
        help="Output file (default: <filename>.json or <filename>.sav)",
    )
    parser.add_argument("--minify-json", action="store_true", help="Minify JSON output")
    args = parser.parse_args()

    if args.to_json and args.from_json:
        print("Cannot specify both --to-json and --from-json")
        exit(1)

    if not os.path.exists(args.filename):
        print(f"{args.filename} does not exist")
        exit(1)
    if not os.path.isfile(args.filename):
        print(f"{args.filename} is not a file")
        exit(1)

    if args.to_json or args.filename.endswith(".sav"):
        if not args.output:
            output_path = args.filename + ".json"
        else:
            output_path = args.output
        convert_sav_to_json(args.filename, output_path, args.minify_json)

    if args.from_json or args.filename.endswith(".json"):
        if not args.output:
            output_path = args.filename.replace(".json", "")
        else:
            output_path = args.output
        if os.path.exists(output_path):
            print(f"{output_path} already exists, this will overwrite the file")
            if not confirm_prompt("Are you sure you want to continue?"):
                exit(1)
        convert_json_to_sav(args.filename, output_path)


def convert_sav_to_json(filename, output_path, minify):
    print(f"Converting {filename} to JSON, saving to {output_path}")
    if os.path.exists(output_path):
        print(f"{output_path} already exists, this will overwrite the file")
    print(f"Decompressing sav file")
    with open(filename, "rb") as f:
        data = f.read()
        raw_gvas, _ = decompress_sav_to_gvas(data)
    print(f"Loading GVAS file")
    gvas_file = GvasFile.read(raw_gvas, PALWORLD_TYPE_HINTS, PALWORLD_CUSTOM_PROPERTIES)
    print(f"Writing JSON to {output_path}")
    with open(output_path, "w", encoding="utf8") as f:
        indent = None if minify else "\t"
        json.dump(gvas_file.dump(), f, indent=indent, cls=CustomEncoder)


def convert_json_to_sav(filename, output_path):
    print(f"Converting {filename} to SAV, saving to {output_path}")
    if os.path.exists(output_path):
        print(f"{output_path} already exists, this will overwrite the file")
    print(f"Loading JSON from {filename}")
    with open(filename, "r", encoding="utf8") as f:
        data = json.load(f)
    gvas_file = GvasFile.load(data)
    print(f"Compressing SAV file")
    if (
        "Pal.PalWorldSaveGame" in gvas_file.header.save_game_class_name
        or "Pal.PalLocalWorldSaveGame" in gvas_file.header.save_game_class_name
    ):
        save_type = 0x32
    else:
        save_type = 0x31
    sav_file = compress_gvas_to_sav(
        gvas_file.write(PALWORLD_CUSTOM_PROPERTIES), save_type
    )
    print(f"Writing SAV file to {output_path}")
    with open(output_path, "wb") as f:
        f.write(sav_file)


def confirm_prompt(question: str) -> bool:
    reply = None
    while reply not in ("y", "n"):
        reply = input(f"{question} (y/n): ").casefold()
    return reply == "y"


if __name__ == "__main__":
    main()

```

`lib/archive.py`:

```py
import io
import os
import struct
from typing import Callable, Union
import uuid


def instance_id_reader(reader):
    return {
        "guid": reader.read_uuid(),
        "instance_id": reader.read_uuid(),
    }


def uuid_reader(reader):
    b = reader.read_bytes(16)
    return uuid.UUID(
        bytes=bytes(
            [
                b[0x3],
                b[0x2],
                b[0x1],
                b[0x0],
                b[0x7],
                b[0x6],
                b[0x5],
                b[0x4],
                b[0xB],
                b[0xA],
                b[0x9],
                b[0x8],
                b[0xF],
                b[0xE],
                b[0xD],
                b[0xC],
            ]
        )
    )


class FArchiveReader:
    data: io.BytesIO
    size: int
    type_hints: dict[str, str]
    custom_properties: dict[str, tuple[Callable, Callable]]

    def __init__(
        self,
        data,
        type_hints: dict[str, str] = {},
        custom_properties: dict[str, tuple[Callable, Callable]] = {},
    ):
        self.data = io.BytesIO(data)
        self.size = len(self.data.read())
        self.data.seek(0)
        self.type_hints = type_hints
        self.custom_properties = custom_properties

    def __enter__(self):
        self.size = len(self.data.read())
        self.data.seek(0)
        return self

    def __exit__(self, type, value, traceback):
        self.data.close()

    def get_type_or(self, path: str, default: str):
        if path in self.type_hints:
            return self.type_hints[path]
        else:
            print(f"Struct type for {path} not found, assuming {default}")
            return default

    def eof(self):
        return self.data.tell() >= self.size

    def read(self, size: int):
        return self.data.read(size)

    def read_to_end(self):
        return self.data.read(self.size - self.data.tell())

    def read_bool(self):
        return self.read_byte() > 0

    def read_fstring(self):
        size = self.read_int32()
        LoadUCS2Char: bool = size < 0

        if LoadUCS2Char:
            if size == -2147483648:
                raise Exception("Archive is corrupted.")

            size = -size

        if size == 0:
            return ""

        data: bytes
        encoding: str
        if LoadUCS2Char:
            data = self.read(size * 2)[:-2]
            encoding = "utf-16-le"
        else:
            data = self.read(size)[:-1]
            encoding = "ascii"
        try:
            return data.decode(encoding)
        except Exception as e:
            raise Exception(
                f"Error decoding {encoding} string of length {size}: {bytes(data)}"
            ) from e

    def read_int16(self):
        return struct.unpack("h", self.data.read(2))[0]

    def read_uint16(self):
        return struct.unpack("H", self.data.read(2))[0]

    def read_int32(self):
        return struct.unpack("i", self.data.read(4))[0]

    def read_uint32(self):
        return struct.unpack("I", self.data.read(4))[0]

    def read_int64(self):
        return struct.unpack("q", self.data.read(8))[0]

    def read_uint64(self):
        return struct.unpack("Q", self.data.read(8))[0]

    def read_float(self):
        return struct.unpack("f", self.data.read(4))[0]

    def read_double(self):
        return struct.unpack("d", self.data.read(8))[0]

    def read_byte(self):
        return struct.unpack("B", self.data.read(1))[0]

    def read_bytes(self, size: int):
        return struct.unpack(str(size) + "B", self.data.read(size))

    def skip(self, size: int):
        self.data.read(size)

    def read_uuid(self):
        return uuid_reader(self)

    def read_optional_uuid(self):
        return uuid_reader(self) if self.read_bool() else None

    def read_tarray(self, type_reader):
        count = self.read_uint32()
        array = []
        for _ in range(count):
            array.append(type_reader(self))
        return array

    def read_properties_until_end(self, path=""):
        properties = {}
        while True:
            name = self.read_fstring()
            if name == "None":
                break
            type_name = self.read_fstring()
            size = self.read_uint64()
            properties[name] = self.read_property(type_name, size, f"{path}.{name}")
        return properties

    def read_property(self, type_name, size, path, allow_custom=True):
        value = {}
        if allow_custom and path in self.custom_properties:
            value = self.custom_properties[path][0](self, type_name, size, path)
            value["custom_type"] = path
        elif type_name == "StructProperty":
            value = self.read_struct(path)
        elif type_name == "IntProperty":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_int32(),
            }
        elif type_name == "Int64Property":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_int64(),
            }
        elif type_name == "FixedPoint64Property":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_int32(),
            }
        elif type_name == "FloatProperty":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_float(),
            }
        elif type_name == "StrProperty":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_fstring(),
            }
        elif type_name == "NameProperty":
            value = {
                "id": self.read_optional_uuid(),
                "value": self.read_fstring(),
            }
        elif type_name == "EnumProperty":
            enum_type = self.read_fstring()
            _id = self.read_optional_uuid()
            enum_value = self.read_fstring()
            value = {
                "id": _id,
                "value": {
                    "type": enum_type,
                    "value": enum_value,
                },
            }
        elif type_name == "BoolProperty":
            value = {
                "value": self.read_bool(),
                "id": self.read_optional_uuid(),
            }
        elif type_name == "ArrayProperty":
            array_type = self.read_fstring()
            value = {
                "array_type": array_type,
                "id": self.read_optional_uuid(),
                "value": self.read_array_property(array_type, size - 4, path),
            }
        elif type_name == "MapProperty":
            key_type = self.read_fstring()
            value_type = self.read_fstring()
            _id = self.read_optional_uuid()
            self.read_uint32()
            count = self.read_uint32()
            values = {}
            key_path = path + ".Key"
            if key_type == "StructProperty":
                key_struct_type = self.get_type_or(key_path, "Guid")
            else:
                key_struct_type = None
            value_path = path + ".Value"
            if value_type == "StructProperty":
                value_struct_type = self.get_type_or(value_path, "StructProperty")
            else:
                value_struct_type = None
            values = []
            for _ in range(count):
                key = self.read_prop_value(key_type, key_struct_type, key_path)
                value = self.read_prop_value(value_type, value_struct_type, value_path)
                values.append(
                    {
                        "key": key,
                        "value": value,
                    }
                )
            value = {
                "key_type": key_type,
                "value_type": value_type,
                "key_struct_type": key_struct_type,
                "value_struct_type": value_struct_type,
                "id": _id,
                "value": values,
            }
        else:
            raise Exception(f"Unknown type: {type_name} ({path})")
        value["type"] = type_name
        return value

    def read_prop_value(self, type_name, struct_type_name, path):
        if type_name == "StructProperty":
            return self.read_struct_value(struct_type_name, path)
        elif type_name == "EnumProperty":
            return self.read_fstring()
        elif type_name == "NameProperty":
            return self.read_fstring()
        elif type_name == "IntProperty":
            return self.read_int32()
        elif type_name == "BoolProperty":
            return self.read_bool()
        else:
            raise Exception(f"Unknown property value type: {type_name} ({path})")

    def read_struct(self, path):
        struct_type = self.read_fstring()
        struct_id = self.read_uuid()
        _id = self.read_optional_uuid()
        value = self.read_struct_value(struct_type, path)
        return {
            "struct_type": struct_type,
            "struct_id": struct_id,
            "id": _id,
            "value": value,
        }

    def read_struct_value(self, struct_type, path=""):
        if struct_type == "Vector":
            return {
                "x": self.read_double(),
                "y": self.read_double(),
                "z": self.read_double(),
            }
        elif struct_type == "DateTime":
            return self.read_uint64()
        elif struct_type == "Guid":
            return self.read_uuid()
        elif struct_type == "Quat":
            return {
                "x": self.read_double(),
                "y": self.read_double(),
                "z": self.read_double(),
                "w": self.read_double(),
            }
        elif struct_type == "LinearColor":
            return {
                "r": self.read_float(),
                "g": self.read_float(),
                "b": self.read_float(),
                "a": self.read_float(),
            }
        else:
            if os.environ.get("DEBUG", "0") == "1":
                print(f"Assuming struct type: {struct_type} ({path})")
            return self.read_properties_until_end(path)

    def read_array_property(self, array_type, size, path):
        count = self.read_uint32()
        value = {}
        if array_type == "StructProperty":
            prop_name = self.read_fstring()
            prop_type = self.read_fstring()
            self.read_uint64()
            type_name = self.read_fstring()
            _id = self.read_uuid()
            self.skip(1)
            prop_values = []
            for _ in range(count):
                prop_values.append(
                    self.read_struct_value(type_name, f"{path}.{prop_name}")
                )
            value = {
                "prop_name": prop_name,
                "prop_type": prop_type,
                "values": prop_values,
                "type_name": type_name,
                "id": _id,
            }
        else:
            value = {
                "values": self.read_array_value(array_type, count, size, path),
            }
        return value

    def read_array_value(self, array_type, count, size, path):
        values = []
        for _ in range(count):
            if array_type == "EnumProperty":
                values.append(self.read_fstring())
            elif array_type == "NameProperty":
                values.append(self.read_fstring())
            elif array_type == "Guid":
                values.append(self.read_uuid())
            elif array_type == "ByteProperty":
                if size == count:
                    values.append(self.read_byte())
                else:
                    raise Exception("Labelled ByteProperty not implemented")
            else:
                raise Exception(f"Unknown array type: {array_type} ({path})")
        return values


def uuid_writer(writer, s: Union[str, uuid.UUID]):
    if isinstance(s, str):
        u = uuid.UUID(s)
        b = u.bytes
    else:
        b = s.bytes
    ub = bytes(
        [
            b[0x3],
            b[0x2],
            b[0x1],
            b[0x0],
            b[0x7],
            b[0x6],
            b[0x5],
            b[0x4],
            b[0xB],
            b[0xA],
            b[0x9],
            b[0x8],
            b[0xF],
            b[0xE],
            b[0xD],
            b[0xC],
        ]
    )
    writer.write(ub)


def instance_id_writer(writer, d):
    uuid_writer(writer, d["guid"])
    uuid_writer(writer, d["instance_id"])


class FArchiveWriter:
    data: io.BytesIO
    size: int
    custom_properties: dict[str, tuple[Callable, Callable]]

    def __init__(self, custom_properties: dict[str, tuple[Callable, Callable]] = {}):
        self.data = io.BytesIO()
        self.custom_properties = custom_properties

    def __enter__(self):
        self.data.seek(0)
        return self

    def __exit__(self, type, value, traceback):
        self.data.close()

    def create_nested(self) -> "FArchiveWriter":
        return FArchiveWriter(self.custom_properties)

    def bytes(self):
        pos = self.data.tell()
        self.data.seek(0)
        b = self.data.read()
        self.data.seek(pos)
        return b

    def write(self, data):
        self.data.write(data)

    def write_bool(self, bool):
        self.data.write(struct.pack("?", bool))

    def write_fstring(self, string) -> int:
        start = self.data.tell()
        if string == "":
            self.write_int32(0)
        elif string.isascii():
            str_bytes = string.encode("utf-8")
            self.write_int32(len(string) + 1)
            self.data.write(str_bytes)
            self.data.write(b"\x00")
        else:
            str_bytes = string.encode("utf-16-le")
            self.write_int32(-(len(string) + 1))
            self.data.write(str_bytes)
            self.data.write(b"\x00\x00")
        return self.data.tell() - start

    def write_int16(self, i):
        self.data.write(struct.pack("h", i))

    def write_uint16(self, i):
        self.data.write(struct.pack("H", i))

    def write_int32(self, i):
        self.data.write(struct.pack("i", i))

    def write_uint32(self, i):
        self.data.write(struct.pack("I", i))

    def write_int64(self, i):
        self.data.write(struct.pack("q", i))

    def write_uint64(self, i):
        self.data.write(struct.pack("Q", i))

    def write_float(self, i):
        self.data.write(struct.pack("f", i))

    def write_double(self, i):
        self.data.write(struct.pack("d", i))

    def write_byte(self, b):
        self.data.write(bytes([b]))

    def write_uint8(self, b):
        self.data.write(struct.pack("B", b))

    def write_bytes(self, b):
        self.data.write(b)

    def write_uuid(self, u):
        uuid_writer(self, u)

    def write_optional_uuid(self, u):
        if u is None:
            self.write_bool(False)
        else:
            self.write_bool(True)
            uuid_writer(self, u)

    def write_tarray(self, type_writer, array):
        self.write_uint32(len(array))
        for i in range(len(array)):
            type_writer(self, array[i])

    def write_properties(self, properties):
        for key in properties:
            self.write_fstring(key)
            self.write_property(properties[key])
        self.write_fstring("None")

    def write_property(self, property):
        # write type_name
        self.write_fstring(property["type"])
        nested_writer = self.create_nested()
        size: int
        property_type = property["type"]
        size = nested_writer.write_property_inner(property_type, property)
        buf = nested_writer.bytes()
        # write size
        self.write_uint64(size)
        self.write_bytes(buf)

    def write_property_inner(self, property_type, property) -> int:
        if "custom_type" in property:
            if property["custom_type"] in self.custom_properties:
                size = self.custom_properties[property["custom_type"]][1](
                    self, property_type, property
                )
            else:
                raise Exception(
                    f"Unknown custom property type: {property['custom_type']}"
                )
        elif property_type == "StructProperty":
            size = self.write_struct(property)
        elif property_type == "IntProperty":
            self.write_optional_uuid(property.get("id", None))
            self.write_int32(property["value"])
            size = 4
        elif property_type == "Int64Property":
            self.write_optional_uuid(property.get("id", None))
            self.write_int64(property["value"])
            size = 8
        elif property_type == "FixedPoint64Property":
            self.write_optional_uuid(property.get("id", None))
            self.write_int32(property["value"])
            size = 4
        elif property_type == "FloatProperty":
            self.write_optional_uuid(property.get("id", None))
            self.write_float(property["value"])
            size = 4
        elif property_type == "StrProperty":
            self.write_optional_uuid(property.get("id", None))
            size = self.write_fstring(property["value"])
        elif property_type == "NameProperty":
            self.write_optional_uuid(property.get("id", None))
            size = self.write_fstring(property["value"])
        elif property_type == "EnumProperty":
            self.write_fstring(property["value"]["type"])
            self.write_optional_uuid(property.get("id", None))
            size = self.write_fstring(property["value"]["value"])
        elif property_type == "BoolProperty":
            self.write_bool(property["value"])
            self.write_optional_uuid(property.get("id", None))
            size = 0
        elif property_type == "ArrayProperty":
            self.write_fstring(property["array_type"])
            self.write_optional_uuid(property.get("id", None))
            array_writer = self.create_nested()
            array_writer.write_array_property(property["array_type"], property["value"])
            array_buf = array_writer.bytes()
            size = len(array_buf)
            self.write_bytes(array_buf)
        elif property_type == "MapProperty":
            self.write_fstring(property["key_type"])
            self.write_fstring(property["value_type"])
            self.write_optional_uuid(property.get("id", None))
            map_writer = self.create_nested()
            map_writer.write_uint32(0)
            map_writer.write_uint32(len(property["value"]))
            for entry in property["value"]:
                map_writer.write_prop_value(
                    property["key_type"], property["key_struct_type"], entry["key"]
                )
                map_writer.write_prop_value(
                    property["value_type"],
                    property["value_struct_type"],
                    entry["value"],
                )
            map_buf = map_writer.bytes()
            size = len(map_buf)
            self.write_bytes(map_buf)
        else:
            raise Exception(f"Unknown property type: {property_type}")
        return size

    def write_struct(self, property) -> int:
        self.write_fstring(property["struct_type"])
        self.write_uuid(property["struct_id"])
        self.write_optional_uuid(property.get("id", None))
        start = self.data.tell()
        self.write_struct_value(property["struct_type"], property["value"])
        return self.data.tell() - start

    def write_struct_value(self, struct_type, value):
        if struct_type == "Vector":
            self.write_double(value["x"])
            self.write_double(value["y"])
            self.write_double(value["z"])
        elif struct_type == "DateTime":
            self.write_uint64(value)
        elif struct_type == "Guid":
            self.write_uuid(value)
        elif struct_type == "Quat":
            self.write_double(value["x"])
            self.write_double(value["y"])
            self.write_double(value["z"])
            self.write_double(value["w"])
        elif struct_type == "LinearColor":
            self.write_float(value["r"])
            self.write_float(value["g"])
            self.write_float(value["b"])
            self.write_float(value["a"])
        else:
            if os.environ.get("DEBUG", "0") == "1":
                print(f"Assuming struct type: {struct_type}")
            return self.write_properties(value)

    def write_prop_value(self, type_name, struct_type_name, value):
        if type_name == "StructProperty":
            self.write_struct_value(struct_type_name, value)
        elif type_name == "EnumProperty":
            self.write_fstring(value)
        elif type_name == "NameProperty":
            self.write_fstring(value)
        elif type_name == "IntProperty":
            self.write_int32(value)
        elif type_name == "BoolProperty":
            self.write_bool(value)
        else:
            raise Exception(f"Unknown property value type: {type_name}")

    def write_array_property(self, array_type, value):
        count = len(value["values"])
        self.write_uint32(count)
        if array_type == "StructProperty":
            self.write_fstring(value["prop_name"])
            self.write_fstring(value["prop_type"])
            nested_writer = self.create_nested()
            for i in range(count):
                nested_writer.write_struct_value(value["type_name"], value["values"][i])
            data_buf = nested_writer.bytes()
            self.write_uint64(len(data_buf))
            self.write_fstring(value["type_name"])
            self.write_uuid(value["id"])
            self.write_uint8(0)
            self.write_bytes(data_buf)
        else:
            self.write_array_value(array_type, count, value["values"])

    def write_array_value(self, array_type, count, values):
        for i in range(count):
            if array_type == "IntProperty":
                self.write_int32(values[i])
            elif array_type == "Int64Property":
                self.write_int64(values[i])
            elif array_type == "FloatProperty":
                self.write_float(values[i])
            elif array_type == "StrProperty":
                self.write_fstring(values[i])
            elif array_type == "NameProperty":
                self.write_fstring(values[i])
            elif array_type == "EnumProperty":
                self.write_fstring(values[i])
            elif array_type == "BoolProperty":
                self.write_bool(values[i])
            elif array_type == "ByteProperty":
                self.write_byte(values[i])
            else:
                raise Exception(f"Unknown array type: {array_type}")

```

`lib/gvas.py`:

```py
import base64
from lib.archive import FArchiveReader, FArchiveWriter
from typing import Any, Callable


def custom_version_reader(reader: FArchiveReader):
    return (reader.read_uuid(), reader.read_int32())


def custom_version_writer(writer: FArchiveWriter, value: tuple[str, int]):
    writer.write_uuid(value[0])
    writer.write_int32(value[1])


class GvasHeader:
    magic: int
    save_game_version: int
    package_file_version_ue4: int
    package_file_version_ue5: int
    engine_version_major: int
    engine_version_minor: int
    engine_version_patch: int
    engine_version_changelist: int
    engine_version_branch: str
    custom_version_format: int
    custom_versions: list[tuple[str, int]]
    save_game_class_name: str

    @staticmethod
    def read(reader: FArchiveReader) -> "GvasHeader":
        header = GvasHeader()
        # FileTypeTag
        header.magic = reader.read_int32()
        if header.magic != 0x53415647:
            raise Exception("invalid magic")
        # SaveGameFileVersion
        header.save_game_version = reader.read_int32()
        if header.save_game_version != 3:
            raise Exception(
                f"expected save game version 3, got {header.save_game_version}"
            )
        # PackageFileUEVersion
        header.package_file_version_ue4 = reader.read_int32()
        header.package_file_version_ue5 = reader.read_int32()
        # SavedEngineVersion
        header.engine_version_major = reader.read_uint16()
        header.engine_version_minor = reader.read_uint16()
        header.engine_version_patch = reader.read_uint16()
        header.engine_version_changelist = reader.read_uint32()
        header.engine_version_branch = reader.read_fstring()
        # CustomVersionFormat
        header.custom_version_format = reader.read_int32()
        if header.custom_version_format != 3:
            raise Exception(
                f"expected custom version format 3, got {header.custom_version_format}"
            )
        # CustomVersions
        header.custom_versions = reader.read_tarray(custom_version_reader)
        header.save_game_class_name = reader.read_fstring()
        return header

    @staticmethod
    def load(dict: dict[str, Any]) -> "GvasHeader":
        header = GvasHeader()
        header.magic = dict["magic"]
        header.save_game_version = dict["save_game_version"]
        header.package_file_version_ue4 = dict["package_file_version_ue4"]
        header.package_file_version_ue5 = dict["package_file_version_ue5"]
        header.engine_version_major = dict["engine_version_major"]
        header.engine_version_minor = dict["engine_version_minor"]
        header.engine_version_patch = dict["engine_version_patch"]
        header.engine_version_changelist = dict["engine_version_changelist"]
        header.engine_version_branch = dict["engine_version_branch"]
        header.custom_version_format = dict["custom_version_format"]
        header.custom_versions = dict["custom_versions"]
        header.save_game_class_name = dict["save_game_class_name"]
        return header

    def dump(self) -> dict[str, Any]:
        return {
            "magic": self.magic,
            "save_game_version": self.save_game_version,
            "package_file_version_ue4": self.package_file_version_ue4,
            "package_file_version_ue5": self.package_file_version_ue5,
            "engine_version_major": self.engine_version_major,
            "engine_version_minor": self.engine_version_minor,
            "engine_version_patch": self.engine_version_patch,
            "engine_version_changelist": self.engine_version_changelist,
            "engine_version_branch": self.engine_version_branch,
            "custom_version_format": self.custom_version_format,
            "custom_versions": self.custom_versions,
            "save_game_class_name": self.save_game_class_name,
        }

    def write(self, writer: FArchiveWriter):
        writer.write_int32(self.magic)
        writer.write_int32(self.save_game_version)
        writer.write_int32(self.package_file_version_ue4)
        writer.write_int32(self.package_file_version_ue5)
        writer.write_uint16(self.engine_version_major)
        writer.write_uint16(self.engine_version_minor)
        writer.write_uint16(self.engine_version_patch)
        writer.write_uint32(self.engine_version_changelist)
        writer.write_fstring(self.engine_version_branch)
        writer.write_int32(self.custom_version_format)
        writer.write_tarray(custom_version_writer, self.custom_versions)
        writer.write_fstring(self.save_game_class_name)


class GvasFile:
    header: GvasHeader
    properties: dict[str, Any]
    trailer: bytes

    @staticmethod
    def read(
        data: bytes,
        type_hints: dict[str, str] = {},
        custom_properties: dict[str, tuple[Callable, Callable]] = {},
    ) -> "GvasFile":
        gvas_file = GvasFile()
        reader = FArchiveReader(data, type_hints, custom_properties)
        gvas_file.header = GvasHeader.read(reader)
        gvas_file.properties = reader.read_properties_until_end()
        gvas_file.trailer = reader.read_to_end()
        if gvas_file.trailer != b"\x00\x00\x00\x00":
            print(
                f"{len(gvas_file.trailer)} bytes of trailer data, file may not have fully parsed"
            )
        return gvas_file

    @staticmethod
    def load(dict: dict[str, Any]) -> "GvasFile":
        gvas_file = GvasFile()
        gvas_file.header = GvasHeader.load(dict["header"])
        gvas_file.properties = dict["properties"]
        gvas_file.trailer = base64.b64decode(dict["trailer"])
        return gvas_file

    def dump(self) -> dict[str, Any]:
        return {
            "header": self.header.dump(),
            "properties": self.properties,
            "trailer": base64.b64encode(self.trailer).decode("utf-8"),
        }

    def write(
        self, custom_properties: dict[str, tuple[Callable, Callable]] = {}
    ) -> bytes:
        writer = FArchiveWriter(custom_properties)
        self.header.write(writer)
        writer.write_properties(self.properties)
        writer.write_bytes(self.trailer)
        return writer.bytes()

```

`lib/noindent.py`:

```py
import ctypes
import json
import re
import uuid


class NoIndent(object):
    """Value wrapper."""

    def __init__(self, value):
        if not isinstance(value, (list, tuple)):
            raise TypeError("Only lists and tuples can be wrapped")
        self.value = value


class CustomEncoder(json.JSONEncoder):
    FORMAT_SPEC = "@@{}@@"
    regex = re.compile(FORMAT_SPEC.format(r"(\d+)"))

    def __init__(self, **kwargs):
        # Keyword arguments to ignore when encoding NoIndent wrapped values.
        ignore = {"cls", "indent"}

        # Save copy of any keyword argument values needed for use here.
        self._kwargs = {k: v for k, v in kwargs.items() if k not in ignore}
        super(CustomEncoder, self).__init__(**kwargs)

    def default(self, obj):
        if isinstance(obj, NoIndent):
            return self.FORMAT_SPEC.format(id(obj))
        elif isinstance(obj, uuid.UUID):
            return str(obj)
        return super(CustomEncoder, self).default(obj)

    def iterencode(self, obj, **kwargs):
        format_spec = self.FORMAT_SPEC  # Local var to expedite access.

        # Replace any marked-up NoIndent wrapped values in the JSON repr
        # with the json.dumps() of the corresponding wrapped Python object.
        for encoded in super(CustomEncoder, self).iterencode(obj, **kwargs):
            match = self.regex.search(encoded)
            if match:
                id = int(match.group(1))
                no_indent = ctypes.cast(id, ctypes.py_object).value
                json_repr = json.dumps(no_indent.value, **self._kwargs)
                # Replace the matched id string with json formatted representation
                # of the corresponding Python object.
                encoded = encoded.replace(
                    '"{}"'.format(format_spec.format(id)), json_repr
                )

            yield encoded


class NoIndentByteDecoder(json.JSONDecoder):
    def __init__(self, *args, **kwargs):
        json.JSONDecoder.__init__(self, object_hook=self.object_hook, *args, **kwargs)

    def object_hook(self, dct):
        if "value" in dct:
            if "values" in dct["value"]:
                if isinstance(dct["value"]["values"], list):
                    if isinstance(dct["value"]["values"][0], int):
                        dct["value"]["values"] = NoIndent(dct["value"]["values"])
        return dct

```

`lib/palsav.py`:

```py
import zlib


def decompress_sav_to_gvas(data: bytes) -> tuple[bytes, int]:
    uncompressed_len = int.from_bytes(data[0:4], byteorder="little")
    compressed_len = int.from_bytes(data[4:8], byteorder="little")
    magic_bytes = data[8:11]
    save_type = data[11]
    # Check for magic bytes
    if magic_bytes != b"PlZ":
        raise Exception(
            f"not a compressed Palworld save, found {magic_bytes} instead of P1Z"
        )
    # Valid save types
    if save_type not in [0x30, 0x31, 0x32]:
        raise Exception(f"unknown save type: {save_type}")
    # We only have 0x31 (single zlib) and 0x32 (double zlib) saves
    if save_type not in [0x31, 0x32]:
        raise Exception(f"unhandled compression type: {save_type}")
    if save_type == 0x31:
        # Check if the compressed length is correct
        if compressed_len != len(data) - 12:
            raise Exception(f"incorrect compressed length: {compressed_len}")
    # Decompress file
    uncompressed_data = zlib.decompress(data[12:])
    if save_type == 0x32:
        # Check if the compressed length is correct
        if compressed_len != len(uncompressed_data):
            raise Exception(f"incorrect compressed length: {compressed_len}")
        # Decompress file
        uncompressed_data = zlib.decompress(uncompressed_data)
    # Check if the uncompressed length is correct
    if uncompressed_len != len(uncompressed_data):
        raise Exception(f"incorrect uncompressed length: {uncompressed_len}")

    return uncompressed_data, save_type


def compress_gvas_to_sav(data: bytes, save_type: int) -> bytes:
    uncompressed_len = len(data)
    compressed_data = zlib.compress(data)
    compressed_len = len(compressed_data)
    if save_type == 0x32:
        compressed_data = zlib.compress(compressed_data)

    # Create a byte array and append the necessary information
    result = bytearray()
    result.extend(uncompressed_len.to_bytes(4, byteorder="little"))
    result.extend(compressed_len.to_bytes(4, byteorder="little"))
    result.extend(b"PlZ")
    result.extend(bytes([save_type]))
    result.extend(compressed_data)

    return bytes(result)

```

`lib/paltypes.py`:

```py
from lib.rawdata import *

PALWORLD_TYPE_HINTS = {
    ".worldSaveData.CharacterContainerSaveData.Key": "StructProperty",
    ".worldSaveData.CharacterSaveParameterMap.Key": "StructProperty",
    ".worldSaveData.CharacterSaveParameterMap.Value": "StructProperty",
    ".worldSaveData.FoliageGridSaveDataMap.Key": "StructProperty",
    ".worldSaveData.FoliageGridSaveDataMap.Value.ModelMap.Value": "StructProperty",
    ".worldSaveData.FoliageGridSaveDataMap.Value.ModelMap.Value.InstanceDataMap.Key": "StructProperty",
    ".worldSaveData.FoliageGridSaveDataMap.Value.ModelMap.Value.InstanceDataMap.Value": "StructProperty",
    ".worldSaveData.FoliageGridSaveDataMap.Value": "StructProperty",
    ".worldSaveData.ItemContainerSaveData.Key": "StructProperty",
    ".worldSaveData.MapObjectSaveData.MapObjectSaveData.ConcreteModel.ModuleMap.Value": "StructProperty",
    ".worldSaveData.MapObjectSaveData.MapObjectSaveData.Model.EffectMap.Value": "StructProperty",
    ".worldSaveData.MapObjectSpawnerInStageSaveData.Key": "StructProperty",
    ".worldSaveData.MapObjectSpawnerInStageSaveData.Value": "StructProperty",
    ".worldSaveData.MapObjectSpawnerInStageSaveData.Value.SpawnerDataMapByLevelObjectInstanceId.Key": "Guid",
    ".worldSaveData.MapObjectSpawnerInStageSaveData.Value.SpawnerDataMapByLevelObjectInstanceId.Value": "StructProperty",
    ".worldSaveData.MapObjectSpawnerInStageSaveData.Value.SpawnerDataMapByLevelObjectInstanceId.Value.ItemMap.Value": "StructProperty",
    ".worldSaveData.WorkSaveData.WorkSaveData.WorkAssignMap.Value": "StructProperty",
    ".worldSaveData.BaseCampSaveData.Key": "Guid",
    ".worldSaveData.BaseCampSaveData.Value": "StructProperty",
    ".worldSaveData.BaseCampSaveData.Value.ModuleMap.Value": "StructProperty",
    ".worldSaveData.ItemContainerSaveData.Value": "StructProperty",
    ".worldSaveData.CharacterContainerSaveData.Value": "StructProperty",
    ".worldSaveData.GroupSaveDataMap.Key": "Guid",
    ".worldSaveData.GroupSaveDataMap.Value": "StructProperty",
    ".worldSaveData.EnemyCampSaveData.EnemyCampStatusMap.Value": "StructProperty",
    ".worldSaveData.DungeonSaveData.DungeonSaveData.MapObjectSaveData.MapObjectSaveData.Model.EffectMap.Value": "StructProperty",
    ".worldSaveData.DungeonSaveData.DungeonSaveData.MapObjectSaveData.MapObjectSaveData.ConcreteModel.ModuleMap.Value": "StructProperty",
}

PALWORLD_CUSTOM_PROPERTIES = {
    ".worldSaveData.GroupSaveDataMap": (decode_group_data, encode_group_data),
    ".worldSaveData.CharacterSaveParameterMap.Value.RawData": (
        decode_character_data,
        encode_character_data,
    ),
    # ".worldSaveData.MapObjectSaveData.MapObjectSaveData.Model.BuildProcess.RawData": (),
    # ".worldSaveData.MapObjectSaveData.MapObjectSaveData.Model.Connector.RawData": (),
    # ".worldSaveData.MapObjectSaveData.MapObjectSaveData.Model.RawData": (),
    # ".worldSaveData.MapObjectSaveData.MapObjectSaveData.ConcreteModel.ModuleMap.Value.RawData": (),
    # ".worldSaveData.MapObjectSaveData.MapObjectSaveData.ConcreteModel.RawData": (),
    # ".worldSaveData.FoliageGridSaveDataMap.Value.ModelMap.Value.InstanceDataMap.Value.RawData": (),
    # ".worldSaveData.FoliageGridSaveDataMap.Value.ModelMap.Value.RawData": (),
    # ".worldSaveData.CharacterContainerSaveData.Value.RawData": (),
    # ".worldSaveData.CharacterContainerSaveData.Value.Slots.Slots.RawData": (),
    # ".worldSaveData.DynamicItemSaveData.DynamicItemSaveData.RawData": (),
    # ".worldSaveData.ItemContainerSaveData.Value.RawData": (),
    # ".worldSaveData.ItemContainerSaveData.Value.Slots.Slots.RawData": (),
}

```

`lib/rawdata.py`:

```py
from typing import Any, Sequence
from lib.archive import *


def decode_group_data(
    reader: FArchiveReader, type_name: str, size: int, path: str
) -> dict[str, Any]:
    if type_name != "MapProperty":
        raise Exception(f"Expected MapProperty, got {type_name}")
    value = reader.read_property(type_name, size, path, allow_custom=False)
    # Decode the raw bytes and replace the raw data
    group_map = value["value"]
    for group in group_map:
        group_type = group["value"]["GroupType"]["value"]["value"]
        group_bytes = group["value"]["RawData"]["value"]["values"]
        group["value"]["RawData"]["value"] = decode_group_data_bytes(
            group_bytes, group_type
        )
    return value


def decode_group_data_bytes(
    group_bytes: Sequence[int], group_type: str
) -> dict[str, Any]:
    reader = FArchiveReader(bytes(group_bytes))
    group_data = {
        "group_type": group_type,
        "group_id": reader.read_uuid(),
        "group_name": reader.read_fstring(),
        "individual_character_handle_ids": reader.read_tarray(instance_id_reader),
    }
    if group_type in [
        "EPalGroupType::Guild",
        "EPalGroupType::IndependentGuild",
        "EPalGroupType::Organization",
    ]:
        org = {
            "org_type": reader.read_byte(),
            "base_ids": reader.read_tarray(uuid_reader),
        }
        group_data |= org
    if group_type in ["EPalGroupType::Guild", "EPalGroupType::IndependentGuild"]:
        guild = {
            "base_camp_level": reader.read_int32(),
            "map_object_instance_ids_base_camp_points": reader.read_tarray(uuid_reader),
            "guild_name": reader.read_fstring(),
        }
        group_data |= guild
    if group_type == "EPalGroupType::IndependentGuild":
        indie = {
            "player_uid": reader.read_uuid(),
            "guild_name_2": reader.read_fstring(),
            "player_info": {
                "last_online_real_time": reader.read_int64(),
                "player_name": reader.read_fstring(),
            },
        }
        group_data |= indie
    if group_type == "EPalGroupType::Guild":
        guild = {"admin_player_uid": reader.read_uuid(), "players": []}
        player_count = reader.read_int32()
        for _ in range(player_count):
            player = {
                "player_uid": reader.read_uuid(),
                "player_info": {
                    "last_online_real_time": reader.read_int64(),
                    "player_name": reader.read_fstring(),
                },
            }
            guild["players"].append(player)
        group_data |= guild
    if not reader.eof():
        raise Exception("Warning: EOF not reached")
    return group_data


def encode_group_data(
    writer: FArchiveWriter, property_type: str, properties: dict[str, Any]
) -> int:
    if property_type != "MapProperty":
        raise Exception(f"Expected MapProperty, got {property_type}")
    del properties["custom_type"]
    group_map = properties["value"]
    for group in group_map:
        if "values" in group["value"]["RawData"]["value"]:
            continue
        p = group["value"]["RawData"]["value"]
        encoded_bytes = encode_group_data_bytes(p)
        group["value"]["RawData"]["value"] = {"values": [b for b in encoded_bytes]}
    return writer.write_property_inner(property_type, properties)


def encode_group_data_bytes(p: dict[str, Any]) -> bytes:
    writer = FArchiveWriter()
    writer.write_uuid(p["group_id"])
    writer.write_fstring(p["group_name"])
    writer.write_tarray(instance_id_writer, p["individual_character_handle_ids"])
    if p["group_type"] in [
        "EPalGroupType::Guild",
        "EPalGroupType::IndependentGuild",
        "EPalGroupType::Organization",
    ]:
        writer.write_byte(p["org_type"])
        writer.write_tarray(uuid_writer, p["base_ids"])
    if p["group_type"] in ["EPalGroupType::Guild", "EPalGroupType::IndependentGuild"]:
        writer.write_int32(p["base_camp_level"])
        writer.write_tarray(uuid_writer, p["map_object_instance_ids_base_camp_points"])
        writer.write_fstring(p["guild_name"])
    if p["group_type"] == "EPalGroupType::IndependentGuild":
        writer.write_uuid(p["player_uid"])
        writer.write_fstring(p["guild_name_2"])
        writer.write_int64(p["player_info"]["last_online_real_time"])
        writer.write_fstring(p["player_info"]["player_name"])
    if p["group_type"] == "EPalGroupType::Guild":
        writer.write_uuid(p["admin_player_uid"])
        writer.write_int32(len(p["players"]))
        for i in range(len(p["players"])):
            writer.write_uuid(p["players"][i]["player_uid"])
            writer.write_int64(p["players"][i]["player_info"]["last_online_real_time"])
            writer.write_fstring(p["players"][i]["player_info"]["player_name"])
    encoded_bytes = writer.bytes()
    return encoded_bytes


def decode_character_data(
    reader: FArchiveReader, type_name: str, size: int, path: str
) -> dict[str, Any]:
    if type_name != "ArrayProperty":
        raise Exception(f"Expected ArrayProperty, got {type_name}")
    value = reader.read_property(type_name, size, path, allow_custom=False)
    char_bytes = value["value"]["values"]
    value["value"] = decode_character_data_bytes(char_bytes)
    return value


def decode_character_data_bytes(char_bytes: Sequence[int]) -> dict[str, Any]:
    reader = FArchiveReader(bytes(char_bytes))
    char_data = {}
    char_data["object"] = reader.read_properties_until_end()
    char_data["unknown_bytes"] = reader.read_bytes(4)
    char_data["group_id"] = reader.read_uuid()
    if not reader.eof():
        raise Exception("Warning: EOF not reached")
    return char_data


def encode_character_data(
    writer: FArchiveWriter, property_type: str, properties: dict[str, Any]
) -> int:
    if property_type != "ArrayProperty":
        raise Exception(f"Expected ArrayProperty, got {property_type}")
    del properties["custom_type"]
    encoded_bytes = encode_character_data_bytes(properties["value"])
    properties["value"] = {"values": [b for b in encoded_bytes]}
    return writer.write_property_inner(property_type, properties)


def encode_character_data_bytes(p: dict[str, Any]) -> bytes:
    writer = FArchiveWriter()
    writer.write_properties(p["object"])
    writer.write_bytes(bytes(p["unknown_bytes"]))
    writer.write_uuid(p["group_id"])
    encoded_bytes = writer.bytes()
    return encoded_bytes

```

`resources/Black Marketeer.png`:

```png
0
```

`resources/Brothers of the Eternal Pyre Martyr.png`:

```png
0
```

`resources/Burly Merc.png`:

```png
0
```

`resources/Expedition Survivor.png`:

```png
0
```

`resources/Free Pal Alliance Devout.png`:

```png
0
```

`resources/PAL Genetic Research Unit Executioner.png`:

```png
0
```

`resources/PIDF Guard.png`:

```png
0
```

`resources/Pal Merchant.png`:

```png
0
```

`resources/Syndicate Cleaner.png`:

```png
0
```

`resources/Syndicate Crusher.png`:

```png
0
```

`resources/Syndicate Elite.png`:

```png
0
```

`resources/Syndicate Grenadier.png`:

```png
0
```

`resources/Syndicate Gunner.png`:

```png
0
```

`resources/Syndicate Hunter.png`:

```png
0
```

`resources/Syndicate Thug (Bat).png`:

```png
0
```

`resources/Syndicate Thug (Handgun).png`:

```png
0
```

`resources/Syndicate Thug.png`:

```png
0
```

`resources/Wandering Merchant.png`:

```png
0
```

`run.bat`:

```bat
@ECHO OFF

@REM Check if python is installed, error if not
python --version 2>NUL
IF %ERRORLEVEL% NEQ 0 (
    python3 --version 2>NUL
    IF %ERRORLEVEL% NEQ 0 (
        py3 --version 2>NUL
        IF %ERRORLEVEL% NEQ 0 (
            ECHO Python is not installed. Please install python and try again.
            PAUSE
            EXIT /B 1
        ) ELSE (
            SET PYTHON_BIN=py3
        )
    ) ELSE (
        SET PYTHON_BIN=python3
    )
) ELSE (
    SET PYTHON_BIN=python
)

@REM Switch to script directory
cd /D "%~dp0"

ECHO "%~dp0"
%PYTHON_BIN% PalEdit.py
IF %ERRORLEVEL% NEQ 0 pause
```