Project Path: arc_gmh5225_QuickAsm_6vgsa2_s

Source Tree:

```txt
arc_gmh5225_QuickAsm_6vgsa2_s
├── HexView
│   ├── CHexView.h
│   ├── HexView.cpp
│   ├── HexView.h
│   ├── HexView.vcxproj
│   ├── HexView.vcxproj.filters
│   ├── HexViewBoomark.cpp
│   ├── HexViewClipboard.cpp
│   ├── HexViewDraw.cpp
│   ├── HexViewDrawNote.cpp
│   ├── HexViewFile.cpp
│   ├── HexViewFind.cpp
│   ├── HexViewHighlight.cpp
│   ├── HexViewInternal.h
│   ├── HexViewKeyboard.cpp
│   ├── HexViewMouse.cpp
│   ├── HexViewScroll.cpp
│   ├── IDataObject.cpp
│   ├── IDropSource.cpp
│   ├── IDropTarget.cpp
│   ├── IEnumFormat.cpp
│   ├── IStream.cpp
│   ├── LICENCE.TXT
│   ├── README.md
│   ├── seqbase.h
│   ├── seqbuf.cpp
│   ├── sequence.cpp
│   └── sequence.h
├── LICENSE.txt
├── QuickAsm
│   ├── App.cpp
│   ├── App.h
│   ├── AssemblerBase.cpp
│   ├── AssemblerBase.h
│   ├── AssemblyEditCtrl.cpp
│   ├── AssemblyEditCtrl.h
│   ├── CapstoneEngine.cpp
│   ├── CapstoneEngine.h
│   ├── Helpers.cpp
│   ├── Helpers.h
│   ├── HexViewPanel.cpp
│   ├── HexViewPanel.h
│   ├── Icons
│   │   ├── 16bit.ico
│   │   ├── 32bit.ico
│   │   ├── 64bit.ico
│   │   ├── 8.ico
│   │   ├── AsmStudio.ico
│   │   ├── Binary.ico
│   │   ├── Edit.ico
│   │   ├── Microprocessor.ico
│   │   ├── Paste.ico
│   │   ├── Redo.ico
│   │   ├── Restart.ico
│   │   ├── Save.ico
│   │   ├── SetNext.ico
│   │   ├── StepInto.ico
│   │   ├── StepOut.ico
│   │   ├── StepOver.ico
│   │   ├── Stop.ico
│   │   ├── Undo.ico
│   │   ├── asm.ico
│   │   ├── break.ico
│   │   ├── breakpoint.ico
│   │   ├── build.ico
│   │   ├── copy.ico
│   │   ├── cut.ico
│   │   ├── delete.ico
│   │   ├── file-new.ico
│   │   ├── memory.ico
│   │   ├── number-1.ico
│   │   ├── number-2.ico
│   │   ├── number-4.ico
│   │   ├── number-8.ico
│   │   ├── open.ico
│   │   ├── registers.ico
│   │   ├── run.ico
│   │   └── save_as.ico
│   ├── KeystoneAssembler.cpp
│   ├── KeystoneAssembler.h
│   ├── LocalArtProvider.cpp
│   ├── LocalArtProvider.h
│   ├── MainFrame.cpp
│   ├── MainFrame.h
│   ├── NasmAssembler.cpp
│   ├── NasmAssembler.h
│   ├── NewScrollingDialog.cpp
│   ├── NewScrollingDialog.h
│   ├── QuickAsm.cbp
│   ├── QuickAsm.layout
│   ├── QuickAsm.rc
│   ├── QuickAsm.vcxproj
│   ├── QuickAsm.vcxproj.filters
│   ├── RegisterInfo.cpp
│   ├── RegisterInfo.h
│   ├── Tag.h
│   ├── TagDialogGui.h
│   ├── UnicornEngine.cpp
│   ├── UnicornEngine.h
│   ├── pch.cpp
│   ├── pch.h
│   ├── resource.h
│   ├── targetver.h
│   ├── wxHexView.cpp
│   └── wxHexView.h
├── QuickAsm.sln
├── README.md
├── common
│   ├── Trace.c
│   └── Trace.h
└── x64Types
    ├── dllmain.cpp
    ├── pch.cpp
    ├── pch.h
    ├── x64Types.h
    ├── x64Types.vcxproj
    └── x64Types.vcxproj.filters

```

`HexView/CHexView.h`:

```h
//
//	WTL C++ interface to the HexView win32 control
//
//	www.catch22.net
//
//	Released under the MIT licence
//
#pragma once

#include "HexView.h"

template <class TBase>
class CHexViewCtrlT : public TBase
{
public:
	// Constructors
	CHexViewCtrlT(HWND hWnd = NULL) : TBase(hWnd)
	{ }

	CHexViewCtrlT< TBase >& operator =(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		pMsg;
		return FALSE;
	}

	static ATOM InitHexView()
	{
		return ::InitHexView();
	}

	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		InitHexView();
		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_HEXVIEW;
	}

  // uIndex - one of the HVC_* values
  UINT SetColor(UINT uIndex, COLORREF color)
  {
    return HexView_SetColor(m_hWnd, uIndex, color);
  }

  COLORREF GetColor(UINT uIndex)
  {
    return HexView_GetColor(m_hWnd, uIndex);
  }

  UINT SetFontSpacing(int xspace, int yspace)
  {
    return HexView_SetFontSpacing(m_hWnd, xspace, yspace);
  }

  VOID SetFont(HFONT hFont)
  {
    return HexView_SetFont(m_hWnd, hFont);
  }

  // uMask, uStyle - one or more of the HVS_* styles
	UINT SetStyle(UINT uMask, UINT uStyle)
	{
		return HexView_SetStyle(m_hWnd, uMask, uStyle);
	}

	UINT SetGrouping(UINT nBytes)
	{
		return HexView_SetGrouping(m_hWnd, nBytes);
	}

  BOOL SetPadding(int nPaddingLeft, int nPaddingRight)
  {
    return HexView_SetPadding(m_hWnd, nPaddingLeft, nPaddingRight);
  }

  VOID SetAddressOffset(size_w offset)
  {
    HexView_SetAddressOffset(m_hWnd, offset);
  }

	UINT GetStyle()
	{
		return HexView_GetStyle(m_hWnd);
	}

	UINT GetStyleMask(UINT uMask)
	{
		return HexView_GetStyleMask(m_hWnd, uMask);
	}

	UINT GetGrouping()
	{
		return HexView_GetGrouping(m_hWnd);
	}

	HBOOKMARK AddBookmark(PBOOKMARK param)
	{
		return HexView_AddBookmark(m_hWnd, param);
	}

	UINT DelBookmark(PBOOKMARK param)
	{
		return HexView_DelBookmark(m_hWnd, param);
	}

	UINT SetSearchPattern(PBYTE pData, ULONG nLength)
	{
		return HexView_SetSearchPattern(m_hWnd, pData, nLength);
	}

	size_w GetCurPos()
	{
		size_w pos = 0;
		HexView_GetCurPos(m_hWnd, &pos);
		return pos;
	}

	size_w GetSelStart()
	{
		size_w pos = 0;
		HexView_GetSelStart(m_hWnd, &pos);
		return pos;
	}

	size_w GetSelEnd()
	{
		size_w pos = 0;
		HexView_GetSelEnd(m_hWnd, &pos);
		return pos;
	}

	size_w GetSelSize()
	{
		size_w len = 0;
		HexView_GetSelSize(m_hWnd, &len)
		return len;
	}

	size_w GetFileSize()
	{
		size_w len = 0;
		HexView_GetFileSize(m_hWnd, &len);
		return len;
	}

	UINT GetDataCur(PBYTE pData, ULONG nLength)
	{
		return HexView_GetDataCur(m_hWnd, pData, nLength);
	}

	UINT GetDataAdv(PBYTE pData, ULONG nLength)
	{
		return HexView_GetDataAdv(m_hWnd, pData, nLength);
	}

	UINT SetDataCur(PBYTE pData, ULONG nLength)
	{
		return HexView_SetDataCur(m_hWnd, pData, nLength);
	}

	UINT SetDataAdv(PBYTE pData, ULONG nLength)
	{
		return HexView_SetDataAdv(m_hWnd, pData, nLength);
	}

	UINT Undo()
	{
		return HexView_Undo(m_hWnd);
	}

	UINT Redo()
	{
		return HexView_Redo(m_hWnd);
	}

	UINT Cut()
	{
		return HexView_Cut(m_hWnd);
	}

	UINT Copy()
	{
		return HexView_Copy(m_hWnd);
	}

	UINT Paste()
	{
		return HexView_Paste(m_hWnd);
	}

	UINT Delete()
	{
		return HexView_Delete(m_hWnd);
	}

	UINT SetEditMode(UINT nEditMode)
	{
		return HexView_SetEditMode(m_hWnd, nEditMode);
	}

	UINT GetEditMode()
	{
		return HexView_GetEditMode(m_hWnd);
	}

	UINT OpenFile(LPCTSTR szFileName, UINT uMethod)
	{
		return HexView_OpenFile(m_hWnd, szFileName, uMethod);
	}

	UINT SaveFile(LPCTSTR szFileName, UINT uMethod)
	{
		return HexView_SaveFile(m_hWnd, szFileName, uMethod);
	}

  UINT InitBuf(const BYTE *buf, size_w len)
  {
    return HexView_InitBuf(m_hWnd, buf, len);
  }

  UINT InitBufShared(const BYTE *buf, size_w len)
  {
    return HexView_InitBufShared(m_hWnd, buf, len);
  }

	BOOL CanUndo()
	{
		return HexView_CanUndo(m_hWnd);
	}

	BOOL CanRedo()
	{
		return HexView_CanRedo(m_hWnd);
	}

	HMENU SetContextMenu(HMENU hMenu)
	{
		return HexView_SetContextMenu(m_hWnd, hMenu);
	}

	BOOL Clear()
	{
		return HexView_Clear(m_hWnd);
	}

	BOOL ClearBookmarks()
	{
		return HexView_ClearBookmarks(m_hWnd);
	}

	BOOL GetBookmark(HBOOKMARK hBookmark, PBOOKMARK bookm)
	{
		return HexView_GetBookmark(m_hWnd, hBookmark, bookm);
	}

	HBOOKMARK EnumBookmark(HBOOKMARK hBookmark, PBOOKMARK bookm)
	{
		return HexView_EnumBook(m_hWnd, hBookmark, bookm)
	}

	BOOL SetBookmark(HBOOKMARK hBookmark, PBOOKMARK bookm)
	{
		return HexView_SetBookmark(m_hWnd, hBookmark, bookm);
	}

	UINT SetCurPos(size_w pos)
	{
		return HexView_SetCurPos(m_hWnd, pos);
	}

	UINT SetSelStart(size_w pos)
	{
		return HexView_SetSelStart(m_hWnd, pos);
	}

	UINT SetSelEnd(size_w pos)
	{
		return HexView_SetSelEnd(m_hWnd, pos);
	}

	UINT ScrollTo(size_w pos)
	{
		return HexView_ScrollTo(m_hWnd, pos);
	}

	UINT ScrollTop(size_w pos)
	{
		return HexView_ScrollTop(m_hWnd, pos);
	}

  int FormatData(HEXFMT_PARAMS *fmtparam)
	{
		return HexView_FormatData(m_hWnd, fmtparam);
	}

	UINT GetLineChars()
	{
		return HexView_GetLineChars(m_hWnd);
	}

  UINT GetLineLen()
	{
		return HexView_GetLineLen(m_hWnd);
	}

	UINT SetLineLen(UINT len)
	{
		return HexView_SetLineLen(m_hWnd, len);
	}

	BOOL IsDragLoop()
	{
		return HexView_IsDragLoop(m_hWnd);
	}

	UINT SelectAll()
	{
		return HexView_SelectAll(m_hWnd);
	}

	BOOL FindInit(PBYTE data, UINT len)
	{
		return HexView_FindInit(m_hWnd, data, len);
	}

	BOOL FindNext(size_w *pos, UINT options)
	{
		return HexView_FindNext(m_hWnd, pos, options);
	}

	BOOL FindPrev(size_w *pos, UINT options)
	{
		return HexView_FindPrev(m_hWnd, pos, options);
	}

	BOOL FindCancel()
	{
		return HexView_FindCancel(m_hWnd);
	}

	HANDLE GetFileHandle()
	{
		return HexView_GetFileHandle(m_hWnd);
	}

	UINT GetCurPane()
	{
		return HexView_GetCurPane(m_hWnd);
	}

	UINT SetCurPane(UINT pane)
	{
		return HexView_SetCurPane(m_hWnd, pane);
	}

	UINT GetFileName(LPTSTR szName, UINT len)
	{
		return HexView_GetFileName(hwnd, szName, len);
	}

	BOOL IsReadOnly()
	{
		return HexView_IsReadOnly(m_hWnd);
	}

	BOOL GetCurCoord(POINT *coord)
	{
		return HexView_GetCurCoord(m_hWnd, coord);
	}

	BOOL Revert()
	{
		return HexView_Revert(m_hWnd);
	}

	UINT ImportFile(LPCTSTR szFileName, UINT uMethod)
	{
		return HexView_ImportFile(m_hWnd, szFileName, uMethod);
	}

	ULONG SetCurSel(size_w selStart, size_w selEnd)
	{
		return HexView_SetCurSel(m_hWnd, selStart, selEnd);
	}

	ULONG SetData(size_w offset, BYTE *buf, ULONG len)
	{
		return HexView_SetData(m_hWnd, offset, buf, len);
	}

	ULONG GetData(size_w offset, BYTE *buf, ULONG len)
	{
		return HexView_GetData(m_hWnd, offset, buf, len);
	}

	ULONG FillData(BYTE *buf, ULONG buflen, size_w len)
	{
		return HexView_FillData(m_hWnd, buf, buflen, len);
	}

};

typedef CHexViewCtrlT<ATL::CWindow>   CHexViewCtrl;

```

`HexView/HexView.cpp`:

```cpp
//
//  HexView.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#define STRICT
#define _WIN32_WINNT 0x501
#include <windows.h>
#include <WindowsX.h>
#include <tchar.h>
#include <stdio.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

// delay-load the UXTHEME library
//#pragma comment(lib, "DelayImp.lib")

// set via property pages
//#pragma comment(linker, "/DELAYLOAD:uxtheme.dll")

static HexView* GetHexView(HWND hwndHexView) {
	return (HexView*)GetWindowLongPtr(hwndHexView, 0);
}

static HTHEME OpenThemeShim(HWND hwnd, LPCWSTR pszClassList) {
	__try {
		return OpenThemeData(hwnd, pszClassList);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		return NULL;
	}
}

size_w HexView::SelectionSize() {
	if (m_nSelectionStart < m_nSelectionEnd)
		return m_nSelectionEnd - m_nSelectionStart;
	else
		return m_nSelectionStart - m_nSelectionEnd;
}

size_w HexView::SelectionStart() {
	return min(m_nSelectionStart, m_nSelectionEnd);
}

size_w HexView::SelectionEnd() {
	return max(m_nSelectionStart, m_nSelectionEnd);
}


LRESULT HexView::NotifyParent(UINT nNotifyCode, NMHDR* optional /* = 0*/) {
	UINT  nCtrlId = GetWindowLong(m_hWnd, GWL_ID);
	NMHDR nmhdr = { m_hWnd, nCtrlId, nNotifyCode };
	NMHDR* nmptr = &nmhdr;

	if (optional) {
		nmptr = optional;
		*nmptr = nmhdr;
	}

	return SendMessage(GetParent(m_hWnd), WM_NOTIFY, (WPARAM)nCtrlId, (LPARAM)nmptr);
}

HexView::HexView(HWND hwnd) :
//, byte_seq *seq = //new byte_seq(0xffffffff)) :
				//new byte_seq(0x1000000)) :
				 //new byte_seq(0xffffffffffffffff)) :
				 //new byte_seq(0xff+2)) :
//				 new byte_seq(0x1000000000)) :
				//new byte_seq(0x12873)) :


	m_hWnd(hwnd),
	m_hwndEdit(0),
	m_pDataSeq(new sequence),
	m_hUserMenu(0),

	//m_nFileLength(seq->length()),//0x3000),

	// 
	m_nAddressDigits(8),
	m_nAddressWidth(8),
	m_nHexPaddingLeft(3),
	m_nHexPaddingRight(3),
	m_nBytesPerLine(16),
	m_nHexWidth(16 * 3 - 1),
	m_nTotalWidth(0),
	m_nWindowLines(0),
	m_nWindowColumns(0),

	m_nSearchLen(0),

	m_nBytesPerColumn(1),		//1/2/4/8

	//m_fMouseDown(FALSE),
	m_nSelectionMode(SEL_NONE),
	m_fResizeBar(false),
	m_fResizeAddr(false),
	m_nScrollCounter(0),
	m_nScrollTimer(0),
	m_nScrollMouseRemainder(0),
	m_fCursorAdjustment(FALSE),

	//m_fHighlighting(false),
	//m_HighlightFG(RGB(0,0,0)),
	//m_HighlightBG(RGB(255,255,0)),

	m_nHScrollPos(0),
	m_nVScrollPos(0),
	m_nHScrollMax(0),
	m_nVScrollMax(0),

	m_pLastDataObject(0),
	m_lRefCount(1),
	m_nWhichPane(0),
	m_nSelectionStart(0),
	m_nSelectionEnd(0),
	m_nCursorOffset(0),
	m_fStartDrag(false),
	m_fDigDragDrop(false),
	m_nSubItem(0),
	m_fRedrawChanges(true),

	//m_HighlightOrderList(0),
	//m_HighlightSortedList(0),

	m_HighlightCurrent(0),
	m_HighlightHot(0),
	m_HitTestCurrent(0),
	m_HitTestHot(0),
	m_nAddressOffset(0),
	m_nDataShift(0),
	m_nVScrollPinned(0),
	m_nLastEditOffset(0),
	m_fCursorMoved(true)


{
	m_nEditMode = HVMODE_OVERWRITE;
	m_nControlStyles = 0;	// styles cleared by default

	//
	//	Initialize the default colour scheme
	//
	m_ColourList[HVC_BACKGROUND] = COLOR_WINDOW | HEX_SYS_COLOR;
	m_ColourList[HVC_SELECTION] = COLOR_HIGHLIGHT | HEX_SYS_COLOR;
	m_ColourList[HVC_SELECTION2] = COLOR_HIGHLIGHT | HEX_SYS_COLOR;
	m_ColourList[HVC_ADDRESS] = COLOR_WINDOWTEXT | HEX_SYS_COLOR;
	m_ColourList[HVC_HEXODD] = RGB(0, 0, 196);
	m_ColourList[HVC_HEXEVEN] = RGB(0, 0, 128);
	m_ColourList[HVC_HEXODDSEL] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;//RGB(255, 255, 0);
	m_ColourList[HVC_HEXODDSEL2] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;//RGB(255, 255, 0);
	m_ColourList[HVC_HEXEVENSEL] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;//RGB(255, 255, 127);
	m_ColourList[HVC_HEXEVENSEL2] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;//RGB(255, 255, 127);
	m_ColourList[HVC_ASCII] = COLOR_WINDOWTEXT | HEX_SYS_COLOR;
	m_ColourList[HVC_ASCIISEL] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;
	m_ColourList[HVC_ASCIISEL2] = COLOR_HIGHLIGHTTEXT | HEX_SYS_COLOR;
	m_ColourList[HVC_MODIFY] = RGB(255, 0, 0);
	m_ColourList[HVC_MODIFYSEL] = RGB(200, 60, 60);//RGB(0, 255, 255);
	m_ColourList[HVC_MODIFYSEL2] = RGB(200, 50, 60);//RGB(0, 255, 255);
	m_ColourList[HVC_BOOKMARK_FG] = RGB(0, 0, 0);
	m_ColourList[HVC_BOOKMARK_BG] = GetSysColor(COLOR_GRADIENTACTIVECAPTION);//RGB(219,233,249);//RGB(255, 255, 127);
	m_ColourList[HVC_BOOKSEL] = RGB(255, 255, 127);
	m_ColourList[HVC_RESIZEBAR] = COLOR_3DFACE | HEX_SYS_COLOR;

	m_ColourList[HVC_MATCHED] = RGB(255, 200, 128);
	m_ColourList[HVC_MATCHEDSEL] = RGB(200, 100, 60);//0xDBE2D8;//RGB(200,128,100);
	m_ColourList[HVC_MATCHEDSEL2] = 0xDBE2D8;//RGB(255,200,128);

	m_ColourList[HVC_SELECTION3] = 0xdddddd;//COLOR_3DFACE | HEX_SYS_COLOR;
	m_ColourList[HVC_SELECTION4] = COLOR_WINDOWTEXT | HEX_SYS_COLOR;

	// uncomment for dual-colour selection
	/*m_ColourList[HVC_SELECTION2]  = COLOR_GRADIENTACTIVECAPTION | HEX_SYS_COLOR;
	m_ColourList[HVC_ASCIISEL2]   = COLOR_WINDOWTEXT| HEX_SYS_COLOR;
	m_ColourList[HVC_HEXODDSEL2]  = COLOR_WINDOWTEXT| HEX_SYS_COLOR;
	m_ColourList[HVC_HEXEVENSEL2] = COLOR_WINDOWTEXT| HEX_SYS_COLOR;*/

	m_hTheme = OpenThemeShim(m_hWnd, L"edit");

	OnSetFont((HFONT)GetStockObject(ANSI_FIXED_FONT));

	RecalcPositions();

	SetCaretPos((m_nAddressWidth + m_nHexPaddingLeft) * m_nFontHeight, 0);

	RegisterDropWindow();

	m_szFilePath[0] = '\0';

	ZeroMemory(&m_HighlightGhost, sizeof(m_HighlightGhost));

	m_BookHead = new BOOKNODE;
	m_BookTail = new BOOKNODE;
	m_BookHead->next = m_BookTail;
	m_BookTail->prev = m_BookHead;

}

HexView::~HexView() {
	CloseFile();

	UnregisterDropWindow();

	m_pDataSeq->release();

	ClearBookmarks();

	if (m_hTheme)
		CloseThemeData(m_hTheme);
}

HMENU HexView::SetContextMenu(HMENU hMenu) {
	HMENU hOld = m_hUserMenu;
	m_hUserMenu = hMenu;
	return hMenu;
}

LRESULT HexView::OnSetFocus() {
	//TRACEA("setfocus %d\n", GetTickCount());
	CreateCaret(m_hWnd, NULL, 2, m_nFontHeight);
	RepositionCaret();
	ShowCaret(m_hWnd);
	RefreshWindow();
	return 0;
}

LRESULT HexView::OnKillFocus() {
	//TRACEA("killfocus\n");
	OnLButtonUp(0, 0, 0);

	HideCaret(m_hWnd);
	DestroyCaret();
	RefreshWindow();
	return 0;
}


bool HexView::CheckStyle(UINT uStyleFlag) {
	return (m_nControlStyles & uStyleFlag) ? true : false;
}

int HexView::UnitWidth() {
	static const int unitlook[] = { 2, 3, 3, 8 };
	return unitlook[GetStyleMask(HVS_FORMAT_MASK)];
}

UINT HexView::SetStyle(UINT uMask, UINT uStyles) {
	UINT uOldStyle = m_nControlStyles;

	m_nControlStyles = (m_nControlStyles & ~uMask) | uStyles;

	SetGrouping(m_nBytesPerColumn);

	// some of the styles could have caused the address column to change
	// so recalc as if the file-length changed.
	RecalcPositions();
	UpdateMetrics();

	RefreshWindow();
	return uOldStyle;
}

BOOL HexView::SetPadding(int left, int right) {
	left = max(left, 0);
	right = max(right, 0);
	left = min(left, 20);
	right = min(right, 20);

	m_nHexPaddingLeft = left;
	m_nHexPaddingRight = right;

	return 0;
}

UINT HexView::GetStyle(UINT uMask) {
	return m_nControlStyles;
}

UINT HexView::GetGrouping() {
	return m_nBytesPerColumn;
}

UINT HexView::SetGrouping(UINT nBytes) {
	int numcols;
	int unitwidth = UnitWidth();

	if (nBytes < 1 || nBytes >= 32)
		return 0;

	m_nBytesPerColumn = nBytes;

	numcols = m_nBytesPerLine / m_nBytesPerColumn;

	if (!CheckStyle(HVS_HEX_INVISIBLE)) {
		m_nHexWidth = (unitwidth * m_nBytesPerColumn + 1) * numcols - 1;

		// take into account partial columns
		if (m_nBytesPerLine % m_nBytesPerColumn)
			m_nHexWidth += (m_nBytesPerLine % m_nBytesPerColumn) * unitwidth + 1;
	}
	else {
		m_nHexWidth = 0;
	}

	m_nTotalWidth = CalcTotalWidth();

	UpdateMetrics();
	RefreshWindow();

	return 0;
}

UINT HexView::GetLineLen() {
	return m_nBytesPerLine;
}

UINT HexView::SetLineLen(UINT nLineLen) {
	m_nBytesPerLine = nLineLen;
	RecalcPositions();
	FakeSize();
	return m_nBytesPerLine;
}

VOID HexView::UpdateResizeBarPos() {
	m_nResizeBarPos = (-m_nHScrollPos * m_nFontWidth + (m_nTotalWidth -
		m_nBytesPerLine - 1) * m_nFontWidth
		- ((m_nHexPaddingRight * m_nFontWidth) / 2));

	m_nResizeBarPos = -m_nHScrollPos;
	m_nResizeBarPos += CheckStyle(HVS_ADDR_INVISIBLE) ? 0 : m_nAddressWidth;
	m_nResizeBarPos += CheckStyle(HVS_HEX_INVISIBLE) ? 0 : m_nHexPaddingLeft;
	m_nResizeBarPos += CheckStyle(HVS_HEX_INVISIBLE) ? 0 : m_nHexWidth;

	if (CheckStyle(HVS_HEX_INVISIBLE) == true) {
		m_nResizeBarPos += m_nBytesPerLine;
		m_nResizeBarPos += m_nHexPaddingRight;
	}

	m_nResizeBarPos *= m_nFontWidth;
	m_nResizeBarPos += (m_nHexPaddingRight * m_nFontWidth) / 2;
}

VOID HexView::RecalcPositions() {
	RECT rect;
	GetClientRect(m_hWnd, &rect);

	OnLengthChange(m_pDataSeq->size());

	m_nDataShift %= m_nBytesPerLine;
	SetGrouping(m_nBytesPerColumn);

	m_nWindowColumns = min((rect.right - rect.left) / m_nFontWidth, m_nTotalWidth);

	UpdateResizeBarPos();

	if (m_nVScrollPos > 0)
		PinToOffset(m_nVScrollPinned);
}

UINT HexView::GetStyleMask(UINT uStyleFlag) {
	return m_nControlStyles & uStyleFlag;
}

VOID HexView::OnLengthChange(size_w nNewLength) {
	TCHAR buf[40];

	if (nNewLength % m_nBytesPerLine == 0 && nNewLength > 0)
		nNewLength--;

	if (CheckStyle(HVS_ADDR_DEC))
		m_nAddressDigits = max(10, _stprintf_s(buf, 40, _T(" %I64u"), (UINT64)nNewLength));
	else
		m_nAddressDigits = max(8, _stprintf_s(buf, 40, _T(" %I64X"), (UINT64)nNewLength));

	m_nAddressWidth = m_nAddressDigits;

	if (CheckStyle(HVS_ADDR_MIDCOLON) && !CheckStyle(HVS_ADDR_DEC))
		m_nAddressWidth++;

	if (CheckStyle(HVS_ADDR_ENDCOLON))
		m_nAddressWidth++;

	// leading space
	m_nAddressWidth++;
}

BOOL HexView::SetFontSpacing(int x, int y) {
	HDC hdc;
	TEXTMETRIC tm;
	HANDLE hOld;

	hdc = GetDC(m_hWnd);
	hOld = SelectObject(hdc, m_hFont);

	GetTextMetrics(hdc, &tm);

	//glyphset = (GLYPHSET*)malloc(GetFontUnicodeRanges(hdc, 0));
	//GetFontUnicodeRanges(hdc, glyphset);
	//free(glyphset)

	m_nFontHeight = tm.tmHeight + y;
	m_nFontWidth = tm.tmAveCharWidth + x;

	SelectObject(hdc, hOld);
	ReleaseDC(m_hWnd, hdc);

	return TRUE;
}

LRESULT HexView::OnSetFont(HFONT hFont) {
	m_hFont = hFont;
	SetFontSpacing(0, 0);
	return 0;
}

size_w HexView::NumFileLines(size_w length) {
	if (length == 0)
		return 0;

	size_w olen = length + m_nDataShift;

	length = olen / m_nBytesPerLine;

	if (olen % m_nBytesPerLine)
		length++;

	//if((olen + m_nDataShift )% m_nBytesPerLine < m_nDataShift)
		//length++;

	return length;
}

bool HexView::PinToBottomCorner() {
	bool repos = false;

	if (m_nHScrollPos + m_nWindowColumns > m_nTotalWidth && !CheckStyle(HVS_FITTOWINDOW)) {
		m_nHScrollPos = m_nTotalWidth - m_nWindowColumns;
		repos = true;
	}

	if (m_nVScrollPos + m_nWindowLines > NumFileLines(m_pDataSeq->size())) {
		m_nVScrollPos = NumFileLines(m_pDataSeq->size()) - m_nWindowLines;
		repos = true;
	}

	return repos;
}

// maintain the vertical scrollbar position, such that the 
// offset at the top-left is always 'locked' at the same value.
// this requires that we shift the starting position of the
// document so that the specified offset always locates at the
// top-left of the viewport
void HexView::PinToOffset(size_w offset) {
	// work out the datashift first of all
	m_nDataShift = m_nBytesPerLine - offset % m_nBytesPerLine;
	m_nDataShift %= m_nBytesPerLine;

	// now work out the corresponding scrollbar position 
	m_nVScrollPos = (offset + m_nDataShift) / m_nBytesPerLine;
}

LRESULT HexView::OnSize(UINT nFlags, int width, int height) {
	// fit to window!
	if (CheckStyle(HVS_FITTOWINDOW)) {
		int logwidth = width / m_nFontWidth;			//logical width, in chars
		int prevbpl = m_nBytesPerLine;

		// work out size of hex+ascii parts
		logwidth -= CheckStyle(HVS_ADDR_INVISIBLE) ? 0 : m_nAddressWidth;

		if (CheckStyle(HVS_HEX_INVISIBLE) == true) {
			// just ascii
			logwidth -= m_nHexPaddingRight + 1;

			m_nBytesPerLine = logwidth;
		}
		else {
			if (CheckStyle(HVS_ASCII_INVISIBLE) == true) {
				logwidth -= m_nHexPaddingLeft;

				// just hex
				m_nBytesPerLine = (logwidth * m_nBytesPerColumn) /
					(m_nBytesPerColumn * UnitWidth() + 1);
			}
			else {
				logwidth -= m_nHexPaddingLeft + m_nHexPaddingRight;

				// ascii + hex
				m_nBytesPerLine = (logwidth * m_nBytesPerColumn) /
					(m_nBytesPerColumn * UnitWidth() + m_nBytesPerColumn + 1);
			}
		}

		//
		int minunit = CheckStyle(HVS_FORCE_FIXEDCOLS) ? m_nBytesPerColumn : 1;
		m_nBytesPerLine -= m_nBytesPerLine % m_nBytesPerColumn;

		// keep within legal limits
		m_nBytesPerLine = max(m_nBytesPerLine, minunit);

		// update display if anything has changed
		if (m_nBytesPerLine != prevbpl) {
			if (m_nVScrollPos > 0)
				PinToOffset(m_nVScrollPinned);

			m_nHScrollPos = 0;
			RecalcPositions();
			RefreshWindow();
			RepositionCaret();
		}
	}

	m_nWindowLines = (int)min((unsigned)height / m_nFontHeight, NumFileLines(m_pDataSeq->size()));
	m_nWindowColumns = (int)min(width / m_nFontWidth, m_nTotalWidth);

	if (PinToBottomCorner()) {
		RefreshWindow();
		RepositionCaret();
	}

	SetupScrollbars();

	return 0;
}

size_w HexView::Size() {
	return m_pDataSeq->size();
}

VOID HexView::FakeSize() {
	RECT rect;
	GetClientRect(m_hWnd, &rect);

	OnSize(0, rect.right, rect.bottom);
}

VOID HexView::UpdateMetrics() {
	FakeSize();
	RefreshWindow();

	RepositionCaret();
}

bool HexView::AllowChange(size_w offset, size_w length, UINT method, BYTE* data /*=0*/, UINT mask /*=0*/) {
	NMHVCHANGED nmchanging = { { 0,0,0 }, method, mask, offset, length, data };

	UINT result = (UINT)NotifyParent(HVN_CHANGING, (NMHDR*)&nmchanging);

	return (result == -1) ? false : true;
}

void HexView::ContentChanged(size_w offset, size_w length, UINT method) {
	NMHVCHANGED nmchanged = { { 0,0,0 }, method, 0, offset, length, NULL };
	UpdateMetrics();
	ScrollToCaret();
	NotifyParent(HVN_CHANGED, (NMHDR*)&nmchanged);
}

BOOL HexView::SetCurSel(size_w selStart, size_w selEnd) {
	if (selStart > m_pDataSeq->size() || selEnd > m_pDataSeq->size())
		return FALSE;

	if (selStart == m_nSelectionStart && selEnd == m_nSelectionEnd)
		return FALSE;

	InvalidateRange(m_nSelectionStart, m_nSelectionEnd);

	m_nSelectionStart = selStart;
	m_nSelectionEnd = selEnd;

	if (m_nCursorOffset != m_nSelectionEnd) {
		m_nCursorOffset = selEnd;
		ScrollToCaret();

		InvalidateRange(selStart, selEnd);
	}

	return TRUE;
}

//
//
//
ULONG WINAPI HexView_SetData(HWND hwnd, size_w offset, BYTE* buf, ULONG len) {
	HexView* hvp;

	if ((hvp = GetHexView(hwnd)) == 0)
		return FALSE;

	return hvp->SetData(offset, buf, len);
}

ULONG WINAPI HexView_GetData(HWND hwnd, size_w offset, BYTE* buf, ULONG len) {
	HexView* hvp;

	if ((hvp = GetHexView(hwnd)) == 0)
		return FALSE;

	return hvp->GetData(offset, buf, len);

}

ULONG WINAPI HexView_SetCurSel(HWND hwnd, size_w selStart, size_w selEnd) {
	HexView* hvp;

	if ((hvp = GetHexView(hwnd)) == 0)
		return FALSE;

	return hvp->SetCurSel(selStart, selEnd);
}

BOOL HexView::SetRedraw(BOOL fRedraw) {
	bool oldredraw = m_fRedrawChanges;

	if (fRedraw) {
		m_fRedrawChanges = true;
		ContentChanged(0, 0, 0);
	}
	else {
		m_fRedrawChanges = false;
	}

	return oldredraw ? TRUE : FALSE;
}


ULONG WINAPI HexView_FillData(HWND hwnd, BYTE* buf, ULONG buflen, size_w len) {
	HexView* hvp;

	if ((hvp = GetHexView(hwnd)) == 0)
		return FALSE;

	return hvp->FillData(buf, buflen, len);
}

LRESULT HexView::OnSelectAll() {
	m_nSelectionStart = 0;
	m_nSelectionEnd = m_pDataSeq->size();
	m_nCursorOffset = m_nSelectionEnd;

	if (m_nCursorOffset % m_nBytesPerLine == 0)
		m_fCursorAdjustment = TRUE;

	size_w oldpos = m_nVScrollPos;
	ScrollToCaret();

	if (oldpos == m_nVScrollPos)
		RefreshWindow();
	return 0;
}

LRESULT HexView::OnSetCurPos(size_w pos) {
	if (pos > m_pDataSeq->size())
		return FALSE;

	if (m_nCursorOffset != pos) {
		m_nCursorOffset = pos;

		if (m_nSelectionEnd != m_nSelectionStart) {
			m_nSelectionEnd = m_nSelectionStart = pos;
			RefreshWindow();
		}

		ScrollToCaret();
	}

	return TRUE;
}

LRESULT HexView::OnSetSelStart(size_w pos) {
	if (pos > m_pDataSeq->size())
		return FALSE;

	m_nSelectionStart = pos;
	return TRUE;
}

LRESULT HexView::OnSetSelEnd(size_w pos) {
	if (pos > m_pDataSeq->size())
		return FALSE;

	m_nSelectionEnd = pos;

	if (m_nCursorOffset != pos) {
		m_nCursorOffset = pos;
		ScrollToCaret();
	}

	return TRUE;
}


LRESULT HexView::WndProc(UINT msg, WPARAM wParam, LPARAM lParam) {
	size_w xparam;

	switch (msg) {
		case WM_PAINT:
			return OnPaint();

		case WM_NCPAINT:
			return OnNcPaint((HRGN)wParam);

		case WM_ERASEBKGND:
			return 1;

		case WM_SETFOCUS:
			return OnSetFocus();

		case WM_KILLFOCUS:
			return OnKillFocus();

		case WM_TIMER:
			return OnTimer((UINT_PTR)wParam);

		case WM_MOUSEACTIVATE:
			return OnMouseActivate((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

		case WM_LBUTTONDOWN:
			return OnLButtonDown((UINT)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

		case WM_LBUTTONDBLCLK:
			return OnLButtonDblClick((UINT)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

		case WM_RBUTTONDOWN:
			OnRButtonDown((UINT)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			return DefWindowProc(m_hWnd, msg, wParam, lParam);

		case WM_LBUTTONUP:
			return OnLButtonUp((UINT)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

		case WM_MOUSEMOVE:
			return OnMouseMove((UINT)wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

		case WM_MOUSEWHEEL:
			return OnMouseWheel((short)HIWORD(wParam));

		case WM_SETCURSOR:
			return OnSetCursor((UINT)wParam, (UINT)lParam);

		case WM_VSCROLL:
			return OnVScroll(LOWORD(wParam), HIWORD(wParam));

		case WM_HSCROLL:
			return OnHScroll(LOWORD(wParam), HIWORD(wParam));

		case WM_KEYDOWN:
			return OnKeyDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));

		case WM_CHAR:
			return OnChar((UINT)wParam);

		case WM_INITMENUPOPUP:
			return SendMessage(GetParent(m_hWnd), msg, wParam, lParam);
			//return OnInitMenuPopup((HWND)wParam, (HMENU)wParam, LOWORD(lParam), HIWORD(lParam));;
		case WM_CONTEXTMENU:
			return SendMessage(GetParent(m_hWnd), msg, wParam, lParam);
			//return DefWindowProc(m_hWnd, msg, wParam, lParam);
			//return OnContextMenu((HWND)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));

		case WM_CTLCOLOREDIT:
			SetBkColor((HDC)wParam, RGB(245, 245, 245));
			return 0;

		case WM_COMMAND:
			if (HIWORD(wParam) == EN_KILLFOCUS) {
				DestroyWindow(m_hwndEdit);
				m_hwndEdit = 0;
			}
			return 0;

		case WM_COPY:
			return OnCopy();

		case WM_CUT:
			return OnCut();

		case WM_PASTE:
			return OnPaste();

		case WM_CLEAR:
			return OnClear();

		case WM_GETDLGCODE:
			// allow hexview to operate in a dialogbox
			return DLGC_WANTCHARS | DLGC_WANTARROWS;

		case WM_UNDO: case HVM_UNDO:
			return Undo();

		case HVM_CANUNDO:
			return CanUndo();

		case HVM_REDO:
			return Redo();

		case HVM_CANREDO:
			return CanRedo();

		case HVM_ISREADONLY:
			return m_pDataSeq->isreadonly();

		case WM_SIZE:
			return OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));

		case WM_SETFONT:
			return OnSetFont((HFONT)wParam);

		case WM_SETREDRAW:
			return SetRedraw((BOOL)wParam);

		case WM_THEMECHANGED:
			if (m_hTheme)
				CloseThemeData(m_hTheme);

			m_hTheme = OpenThemeShim(m_hWnd, L"Edit");
			return 0;

		case HVM_CLEAR:
			return ClearFile();

		case HVM_OPENFILE:
			return OpenFile((LPCTSTR)lParam, (UINT)wParam);

		case HVM_SAVEFILE:
			return SaveFile((LPCTSTR)lParam, (UINT)wParam);

		case HVM_INITBUF:
			return InitBuf((const BYTE*)wParam, (size_t)lParam, true, false);

		case HVM_INITBUF_SHARED:
			return InitBuf((const BYTE*)wParam, (size_t)lParam, false, false);

		case HVM_IMPORTFILE:
			return ImportFile((LPCTSTR)lParam, (UINT)wParam);

		case HVM_GETFILESIZE:
			xparam = m_pDataSeq->size();
			if (lParam) *(size_w*)lParam = xparam;
			return (LONG)xparam;

		// set data at current cursor position, don't update cursor
		case HVM_SETDATACUR:
			return (LONG)EnterData((BYTE*)wParam, lParam, true/*false*/, true, false);

		// set data at current cursor position and update cursor
		case HVM_SETDATAADV:
			return (LONG)EnterData((BYTE*)wParam, lParam, true, true, false);

		// get data at current cursor position 
		case HVM_GETDATACUR:
			return GetData(m_nCursorOffset, (BYTE*)wParam, (UINT)lParam);

		// get data at current cursor position and update cursor
		case HVM_GETDATAADV:
			size_t n;
			n = GetData(m_nCursorOffset, (BYTE*)wParam, (UINT)lParam);
			m_nCursorOffset += n;
			return n;

		case HVM_GETCURPOS:
			xparam = m_nCursorOffset;
			if (lParam) *(size_w*)lParam = xparam;
			return (LONG)xparam;

		case HVM_GETSELSTART:
			xparam = SelectionStart();
			if (lParam) *(size_w*)lParam = xparam;
			return (LONG)xparam;

		case HVM_GETSELEND:
			xparam = SelectionEnd();
			if (lParam) *(size_w*)lParam = xparam;
			return (LONG)xparam;

		case HVM_SCROLLTO:
			xparam = MAKE_SIZEW(wParam, lParam);

			if (xparam > m_pDataSeq->size())
				return FALSE;

			return ScrollTo(xparam);

		case HVM_SCROLLTOP:
			xparam = MAKE_SIZEW(wParam, lParam);

			if (xparam > m_pDataSeq->size())
				return FALSE;

			return ScrollTop(xparam);

		case HVM_SETCURPOS:
			return OnSetCurPos(MAKE_SIZEW(wParam, lParam));

		case HVM_SETSELSTART:
			return OnSetSelStart(MAKE_SIZEW(wParam, lParam));

		case HVM_SETSELEND:
			return OnSetSelEnd(MAKE_SIZEW(wParam, lParam));

		case HVM_SELECTALL:
			return OnSelectAll();

		case HVM_GETSELSIZE:
			xparam = SelectionSize();
			if (lParam) *(size_w*)lParam = xparam;
			return (LONG)xparam;

		case HVM_SETSTYLE:
			return SetStyle((UINT)wParam, (UINT)lParam);

		case HVM_GETSTYLE:
			return GetStyle((UINT)wParam);

		case HVM_GETEDITMODE:
			return m_nEditMode;

		case HVM_SETEDITMODE:
			if (m_pDataSeq->isreadonly())
				return -1;

			lParam = m_nEditMode;
			m_nEditMode = (UINT)wParam;
			return lParam;

		case HVM_SETSEARCHPAT:
			m_nSearchLen = min((UINT)wParam, sizeof(m_pSearchPat));
			memcpy(m_pSearchPat, (BYTE*)lParam, m_nSearchLen);
			return 1;

		case HVM_SETGROUPING:
			return SetGrouping((UINT)wParam);

		case HVM_GETGROUPING:
			return GetGrouping();

		case HVM_SETCOLOR:
			return SetHexColour((UINT)wParam, (COLORREF)lParam);

		case HVM_GETCOLOR:
			return GetHexColour((UINT)wParam);

		case HVM_SETPADDING:
			return SetPadding(LOWORD(lParam), HIWORD(lParam));

		//case HVM_HIGHLIGHT:
		//	return Highlight(wParam);

		case HVM_ADDBOOKMARK:
			return (LRESULT)AddBookmark((BOOKMARK*)lParam);

		case HVM_DELBOOKMARK:
			return DelBookmark((BOOKNODE*)wParam);

		case HVM_CLEARBOOKMARKS:
			return ClearBookmarks();

		case HVM_SETCONTEXTMENU:
			return (LRESULT)SetContextMenu((HMENU)wParam);

		case HVM_GETBOOKMARK:
			return (LRESULT)GetBookmark((BOOKNODE*)wParam, (BOOKMARK*)lParam);

		case HVM_ENUMBOOKMARK:
			return (LRESULT)EnumBookmark((BOOKNODE*)wParam, (BOOKMARK*)lParam);

		case HVM_SETBOOKMARK:
			return SetBookmark((BOOKNODE*)wParam, (BOOKMARK*)lParam);

		case HVM_FORMATDATA:
			return FormatData((HEXFMT_PARAMS*)lParam);

		case HVM_GETLINELEN:
			return GetLineLen();

		case HVM_GETLINECHARS:
			return m_nTotalWidth + 1;

		case HVM_SETLINELEN:
			return SetLineLen((UINT)wParam);

		case HVM_FINDINIT:
			return FindInit((BYTE*)lParam, wParam, FALSE, FALSE);

		case HVM_FINDNEXT:
			return FindNext((size_w*)lParam, (UINT)wParam);

		case HVM_FINDPREV:
			return FALSE;

		case HVM_FINDCANCEL:
			return FALSE;

		case HVM_GETFILEHANDLE:
			return (LRESULT)m_pDataSeq->_handle();

		case HVM_GETCURPANE:
			return m_nWhichPane;

		case HVM_SETCURPANE:
			m_nWhichPane = wParam == 0 ? 0 : 1;
			ScrollToCaret();
			return 0;

		case HVM_GETFILENAME:

			if (m_szFilePath && m_szFilePath[0]) {
				lstrcpyn((TCHAR*)lParam, m_szFilePath, (int)wParam);
				return TRUE;
			}
			else {
				if (lParam && wParam > 0)
					((TCHAR*)lParam)[0] = '\0';

				return FALSE;
			}

		case HVM_REVERT:
			return RevertFile();

		case HVM_ISDRAGLOOP:
			return m_nSelectionMode == SEL_DRAGDROP ? TRUE : FALSE;

		case HVM_GETCURCOORD:
		{
			int x, y;
			CaretPosFromOffset(m_nCursorOffset, &x, &y);
			//PositionCaret(x, y, m_nWhichPane);
			//, 
			((POINT*)lParam)->x = LogToPhyXCoord(x, m_nWhichPane);
			((POINT*)lParam)->y = y * m_nFontHeight;
		}
		return TRUE;

		case HVM_SETFONTSPACING:
			return SetFontSpacing((short)LOWORD(lParam), (short)HIWORD(lParam));

		case HVM_SETADDROFFSET:
			m_nAddressOffset = MAKE_SIZEW(wParam, lParam);
			return 0;

		case HVM_SETDATASHIFT:
			m_nDataShift = max(0, (int)wParam);//(int)MAKE_SIZEW(wParam, lParam);
			RepositionCaret();
			return 0;


		default:
			return DefWindowProc(m_hWnd, msg, wParam, lParam);
	}
}

LRESULT CALLBACK HexViewWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	HexView* hvp = GetHexView(hwnd);

	switch (msg) {
	// First message received by any window - make a new HexView object
	// and store pointer to it in our extra-window-bytes
		case WM_NCCREATE:

			if ((hvp = new HexView(hwnd)) == 0)
				return FALSE;

			SetWindowLongPtr(hwnd, 0, (LONG_PTR)hvp);
			return TRUE;

		// Last message received by any window - delete the HexView object
		case WM_NCDESTROY:
			delete hvp;
			SetWindowLongPtr(hwnd, 0, 0);
			return 0;

		// Pass everything to the HexView window procedure
		default:
			return hvp ? hvp->WndProc(msg, wParam, lParam) : 0;
	}
}

ATOM InitHexView() {
	WNDCLASSEX wc = { sizeof(wc) };

	wc.cbWndExtra = sizeof(wc);
	wc.style = CS_DBLCLKS;
	wc.hCursor = 0;//LoadCursor(NULL, IDC_IBEAM);
	wc.hInstance = GetModuleHandle(0);
	wc.lpfnWndProc = HexViewWndProc;
	wc.lpszClassName = WC_HEXVIEW;

	return RegisterClassEx(&wc);
}


HWND CreateHexView(HWND hwndParent) {
	InitHexView();

	return CreateWindowEx(WS_EX_CLIENTEDGE, WC_HEXVIEW, TEXT(""),
		WS_CHILD | WS_VSCROLL | WS_CLIPCHILDREN | WS_VISIBLE,
		0, 0, 0, 0, hwndParent, 0, GetModuleHandle(0), 0);
}

```

`HexView/HexView.h`:

```h
/**
 * @file
 * @author  James Brown
 * @version 1.0
 *
 * @section LICENSE
 *
 * Copyright (C) 2012 James Brown
 * Please refer to the file LICENCE.TXT for copying permission
 *
 * @section DESCRIPTION
 *
 * HexView win32 control
 * www.catch22.net
 *
 */
#ifndef HEXVIEW_INCLUDED
#define HEXVIEW_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Initialize the HexView control library
 *
 * This function registers the HexView window class - must be called 
 * prior to creating any HexView controls
 *
 */
ATOM InitHexView();
		
/**
 * Create a HexView control. Just a convenience function -
 * use CreateWindowEx specifying WC_HEXVIEW as an alternative
 */
HWND CreateHexView(HWND hwndParent);

// HexView window class name
#define WC_HEXVIEW _T("HexView32")

//
// Define SEQUENCE64 at the project-level in order to
// support 64bit filesizes (i.e. files over 4gb in size)
//
// Recommened for all projects - this method works in 
// both win32 and win64 projects
//
#ifdef SEQUENCE64
typedef unsigned __int64  size_w;
#else
typedef unsigned long	  size_w;
#endif


typedef struct
{
	COLORREF colFG;
	COLORREF colBG;

} HEXCOL, ATTR;

//
//	Input to HVM_FORMATDATA
//  Caller must allocate szText and attrList to the
//  size returned from HVM_GETLINECHARS
//
typedef struct _HEXFMT_PARAMS
{
	size_w	offset;
	size_t	length;

	size_t   bufferSize;
	TCHAR	*szText;
	ATTR	*attrList;

} HEXFMT_PARAMS, *PHEXFMT_PARAMS;

typedef struct _BOOKMARK
{
	DWORD		flags;

	size_w		offset;
	size_w		length;
	COLORREF	col;
	COLORREF	backcol;

	TCHAR    *	pszText;
	ULONG		nMaxText;
	TCHAR    *	pszTitle;
	ULONG		nMaxTitle;

} BOOKMARK, *PBOOKMARK;

typedef void * HBOOKMARK;

/**
 * HexView styles
 *
 * Set using the HexView_SetStyle message
 * 
 *	Be sure to update the HVS_xxx_MASK values if you change anything!!
 */
//! Hex column styles
#define HVS_FORMAT_HEX		0x0000		// hex format is the default
#define HVS_FORMAT_DEC		0x0001		// decimal formatting
#define HVS_FORMAT_OCT		0x0002		// octal formatting
#define HVS_FORMAT_BIN		0x0003		// binary formatting
#define HVS_FORMAT_MASK		0x0003

//! Address column styles
#define HVS_ADDR_HEX		0x0000		// hex address (default)
#define HVS_ADDR_VISIBLE	0x0000		// visible (default)
#define HVS_ADDR_DEC		0x0004		// decimal address 
#define HVS_ADDR_RESIZING	0x0008		// auto resize address
#define HVS_ADDR_ENDCOLON	0x0010		// place a colon : at the end of the address
#define HVS_ADDR_MIDCOLON	0x0020		// place a colon in middle (hex address only)
#define HVS_ADDR_INVISIBLE	0x0040		// hide the address
#define HVS_ADDR_MASK		0x007C

/* // grouping now specified via HVM_SETGROUPING message
#define HVS_WIDTH_BYTE		0x0000		// single-byte grouping is default
#define HVS_WIDTH_WORD		0x0100		// word (16bit) grouping of bytes
#define HVS_WIDTH_DWORD		0x0200		// dword (32bit) grouping
#define HVS_WIDTH_MASK		0x0300*/

// Endian display mode (for hex column, with grouping enabled)
#define HVS_ENDIAN_LITTLE	0x0000		// little endian is default
#define HVS_ENDIAN_BIG		0x0400		// big endian (only when WORD/DWORD grouping)
#define HVS_ENDIAN_MASK		0x0400

// Ascii column styles
#define HVS_ASCII_VISIBLE	0x0000		// visible (default)
#define HVS_ASCII_SHOWCTRLS	0x0800		// show control (0-31) chars
#define HVS_ASCII_SHOWEXTD	0x1000		// show extended chars (128-255)
#define HVS_ASCII_INVISIBLE 0x2000		// hide the ascii display
#define HVS_ASCII_MASK		0x3800

// Basic HexView control styles
#define HVS_FORCE_FIXEDCOLS 0x80		// force whole-sized hex columns
#define HVS_FIXED_EDITMODE  0x0100		// prevent user from using INSERT to change edit mode
#define HVS_DISABLE_UNDO	0x0200		// prevent undo/redo functionality
#define HVS_SUBPOSITIONING  0x0200      // use keyboard & mouse to allow inter-byte (bit/nibble) editing & positioning

#define HVS_ALWAYSDELETE	0x4000		// backspace/delete work even in OVR mode
#define HVS_HEX_INVISIBLE   0x8000		// hide the hex display
#define HVS_UPPERCASEHEX	0x000000	// hex characters (A-F) are upper-case (default)
#define HVS_LOWERCASEHEX	0x010000	// hex characters (A-F) are lower-case
#define HVS_FITTOWINDOW		0x020000	// adjust columns to fit in window		
#define HVS_SHOWMODS		0x040000	// show modifications to the file
#define HVS_REPLACESEL		0x080000	// typing replaces selection
#define HVS_ENABLEDRAGDROP	0x100000	// enable drag-and-drop
#define HVS_INSERTMODEDEF	0x200000	// insert mode is default (replace is usually)
#define HVS_LINKDROPFILES	0x400000	// link any files dropped from explorer (default)
#define HVS_BRINGTOTOP		0x800000	// bring window to foreground during drag+drop

// Editing styles
/*#define HVS_OVERSTRIKE		0x0000000	// overstrike (default)
#define HVS_INSERT			0x1000000	// insertion
#define HVS_READONLY		0x2000000	// readonly (no editing)
#define HVS_QUICKSAVE		0x4000000	// quicksave
*/

#define HVS_HEXPANE			0x0000000	// cursor in hex pane (default)
#define HVS_ASCPANE			0x8000000	// cursor in ascii pane

#define HVS_ALWAYSVSCROLL   0x10000000
#define HVS_ALWAYSHSCROLL   0x20000000
#define HVS_RESIZEBAR	    0x40000000
#define HVS_INVERTSELECTION 0x80000000

// Editing mode
#define HVMODE_READONLY			0			// readonly (no editing)
#define HVMODE_INSERT			1			// insertion
#define HVMODE_OVERWRITE		2			// overstrike (default)
#define HVMODE_QUICKSAVE		0x4000000	// quicksave

//
//	HexView_OpenFile flags
//
#define HVOF_DEFAULT			0
#define HVOF_READONLY			1			// open the file as read-only
#define HVOF_QUICKLOAD			2			// enable quickload - keep file on disk + use minimal memory
#define HVOF_QUICKSAVE			4			// enable quicksave - only writes modified portions of a file to disk
#define HVOF_AUTOQUICKLOAD		(8 | HVOF_QUICKLOAD) // always quickload for larger files

//
//	HexView_Bookmark flags
//
#define HVBF_DEFAULT			0
#define HVBF_NOPERSIST			1	// mark as non-persistant
#define HVBF_NOBOOKNOTE			2	// don't display the note-tab
#define HVBF_NOENUM				4	// don't return in bookmark enumerations

/*
 *	HexView_Find flags
 */
#define HVFF_SCOPE_ALL			0
#define HVFF_SCOPE_SELECTION	1
#define HVFF_CASE_INSENSITIVE	2

/*
 *	Colour support
 *  Modify the colour palete using the HexView_SetColor message
 */
#define HVC_BACKGROUND		0			///< normal background colour
#define HVC_SELECTION       1			///< selection background colour
#define HVC_SELECTION2      2			//! secondary selection background colour
#define HVC_ADDRESS			3			//! address text
#define HVC_HEXODD			4			//! odd column text
#define HVC_HEXODDSEL		5			//! odd selected text
#define HVC_HEXODDSEL2		6			//! odd selected text (secondary)
#define HVC_HEXEVEN			7			//! even column text
#define HVC_HEXEVENSEL		8			//! even selected text
#define HVC_HEXEVENSEL2		9			//! even selected text (secondary
#define HVC_ASCII			10			//! ascii text
#define HVC_ASCIISEL		11			//! ascii selection text
#define HVC_ASCIISEL2		12			//! ascii selection text
#define HVC_MODIFY			13			//! modified bytes colour
#define HVC_MODIFYSEL		14			//! modified bytes selected
#define HVC_MODIFYSEL2		15			//! modified bytes selected
#define HVC_BOOKMARK_FG		16			//! bookmarks
#define HVC_BOOKMARK_BG		17			//! bookmarks
#define HVC_BOOKSEL			18			//! selected bookmark
#define HVC_RESIZEBAR		19			//! resizing bar
#define HVC_SELECTION3      20			//! secondary selection background colour
#define HVC_SELECTION4		21
#define HVC_MATCHED			22			//! matched pattern background
#define HVC_MATCHEDSEL		23			//! selected pattern match			
#define HVC_MATCHEDSEL2		24			//! selected pattern match (secondary)
#define HVC_MAX_COLOURS		25

#define HEX_GET_COLOR		0x00ffffff	// mask to 
#define HEX_SYS_COLOR		0x80000000	// top bit in a COLORREF indicates that it is a COLOR_xx index 

// create a HexView color based on one of the GetSysColor COLOR_* system color codes
// the resulting
#define HEX_SYSCOLOR(code) (HEX_SYS_COLOR | (code))	

// Find (realise) the real colour
// an RGB value will not have the top byte set to anything,
// so we can tell if we have a specific colour or not.
// we can set the top byte to a meaningful value to indicate
// that we are using a system colour - just mask the low triple
// bytes to get the COLOR_* value
#define HexView_RealiseColour(cr) (((cr) & HEX_SYS_COLOR) ? GetSysColor((cr) & HEX_GET_COLOR) : (cr))


/*
 *	HexView-specific messages that can be sent to a HexView control
 *  using the SendMessage API
 *
 *  Refer to the corresponding HexView_xxx message macros at the bottom of
 *  this file for details about what parameters each message takes.
 *
 */
#define HVM_FIRST WM_USER

//#define HVM_HIGHLIGHT		(HVM_FIRST + 2)
#define HVM_GETCURPOS		(HVM_FIRST + 3)
#define HVM_GETSELSTART		(HVM_FIRST + 4)
#define HVM_GETSELEND		(HVM_FIRST + 5)
#define HVM_GETSELSIZE		(HVM_FIRST + 6)
#define HVM_SETSEARCHPAT	(HVM_FIRST + 7)
#define HVM_GETDATACUR		(HVM_FIRST + 8)
#define HVM_SETDATACUR		(HVM_FIRST + 9)
//#define HVM_INSERTDATA		(HVM_FIRST + 10)
//#define HVM_REPLACEDATA		(HVM_FIRST + 11)
#define HVM_ERASEDATA		(HVM_FIRST + 12)
#define HVM_UNDO			(HVM_FIRST + 13)
#define HVM_REDO			(HVM_FIRST + 14)

#define HVM_SETSTYLE		(HVM_FIRST + 0)
#define HVM_SETGROUPING		(HVM_FIRST + 1)

#define HVM_SETEDITMODE		(HVM_FIRST + 15)
#define HVM_GETEDITMODE		(HVM_FIRST + 16)
#define HVM_OPENFILE		(HVM_FIRST + 17)
#define HVM_SAVEFILE		(HVM_FIRST + 18)
#define HVM_SELECTALL		(HVM_FIRST + 19)
#define HVM_CANUNDO			(HVM_FIRST + 20)
#define HVM_CANREDO			(HVM_FIRST + 21)
#define HVM_SETCONTEXTMENU  (HVM_FIRST + 22)
#define HVM_CLEAR			(HVM_FIRST + 23)
#define HVM_ADDBOOKMARK		(HVM_FIRST + 24)
#define HVM_CLEARBOOKMARKS	(HVM_FIRST + 25)
#define HVM_GETBOOKMARK		(HVM_FIRST + 26)
#define HVM_SETBOOKMARK		(HVM_FIRST + 27)
#define HVM_SETCURPOS		(HVM_FIRST + 28)
#define HVM_SETSELSTART		(HVM_FIRST + 29)
#define HVM_SETSELEND		(HVM_FIRST + 30)
#define HVM_SCROLLTO		(HVM_FIRST + 31)
#define HVM_GETSTYLE		(HVM_FIRST + 32)
#define HVM_GETGROUPING		(HVM_FIRST + 33)
#define HVM_FORMATDATA		(HVM_FIRST + 34)
#define HVM_GETLINELEN		(HVM_FIRST + 35)
#define HVM_SETLINELEN		(HVM_FIRST + 36)
#define HVM_ISDRAGLOOP		(HVM_FIRST + 37)
#define HVM_GETDATAADV		(HVM_FIRST + 38)
#define HVM_SETDATAADV		(HVM_FIRST + 39)
#define HVM_GETFILESIZE		(HVM_FIRST + 40)
#define HVM_FINDINIT		(HVM_FIRST + 41)
#define HVM_FINDNEXT		(HVM_FIRST + 42)
#define HVM_FINDPREV		(HVM_FIRST + 43)
#define HVM_FINDCANCEL		(HVM_FIRST + 44)
#define	HVM_GETFILEHANDLE	(HVM_FIRST + 45)
#define HVM_GETCURPANE		(HVM_FIRST + 46)
#define HVM_SETCURPANE		(HVM_FIRST + 47)
#define HVM_GETFILENAME		(HVM_FIRST + 48)
#define HVM_ISREADONLY		(HVM_FIRST + 49)
#define HVM_GETCURCOORD		(HVM_FIRST + 50)
#define HVM_REVERT			(HVM_FIRST + 51)
#define HVM_FILLDATA		(HVM_FIRST + 52)
#define HVM_IMPORTFILE		(HVM_FIRST + 53)
#define HVM_DELBOOKMARK		(HVM_FIRST + 54)
#define HVM_ENUMBOOKMARK	(HVM_FIRST + 55)
#define HVM_INITBUF			(HVM_FIRST + 56)
#define HVM_INITBUF_SHARED  (HVM_FIRST + 57)
#define HVM_SETFONTSPACING  (HVM_FIRST + 58)
#define HVM_SETCOLOR		(HVM_FIRST + 59)
#define HVM_GETCOLOR		(HVM_FIRST + 60)
#define HVM_SETPADDING		(HVM_FIRST + 61)
//#define HVM_GETPADDING		(HVM_FIRST + 62)
#define HVM_SETADDROFFSET   (HVM_FIRST + 63)
#define HVM_SCROLLTOP       (HVM_FIRST + 64)
#define HVM_GETLINECHARS	(HVM_FIRST + 65)
#define HVM_SETDATASHIFT    (HVM_FIRST + 66)


//
//	HexView notifications
//	sent via the WM_NOTIFY message
//
#define HVN_BASE				(WM_USER)
#define HVN_CURSOR_CHANGE		(HVN_BASE + 0)  // the cursor has changed location
#define HVN_SELECTION_CHANGE	(HVN_BASE + 1)  // the selection has changed
#define HVN_EDITMODE_CHANGE		(HVN_BASE + 2)  // the edit mode (insert/delete/readonly) has changed
#define HVN_CHANGED				(HVN_BASE + 3)  // the file content has changed (see NMHVCHANGED structure)
#define HVN_ESCAPE				(HVN_BASE + 4)  // the escape key was pressed
#define HVN_PROGRESS			(HVN_BASE + 5)  // NMHVPROGRESS
#define HVN_BOOKCLOSE			(HVN_BASE + 6)  // a bookmark has been closed
#define HVN_CONTEXTMENU			(HVN_BASE + 7)  // the context menu is being displayed
#define HVN_CHANGING            (HVN_BASE + 8)  // the file content is about to change (return TRUE to prevent edits)

/**
 * NMHVCHANGED
 *
 * Sent via the WM_NOTIFY message (with HVN_CHANGE and HVN_CHANGING)
 * Indicates that a range of bytes has changed due to 
 * an action by the user
 *
 * HVN_CHANGING - return TRUE to prevent the edit from occurring
 * HVN_CHANGED  - sent AFTER the edit has occurred
*/
typedef struct _NMHVCHANGED
{
#define HVMETHOD_INSERT    1
#define HVMETHOD_OVERWRITE 2
#define HVMETHOD_DELETE    3

	NMHDR	hdr;
	UINT	method;		// how the data changed - one of the HVMETHOD_xxx values
	UINT    bitmask;    // bitmask that indicates which bit(s) have changed

	size_w  offset;     // starting offset of where data changed
	size_w  length;     // number of bytes that were affected
	BYTE *  data;		// optional pointer to data that is being inserted

} NMHVCHANGED;

/**
 * NMHVPROGRESS
 *
 * Sent via the WM_NOTIFY message (with HVN_PROGRESS).
 * Indicates the progress of the current operation (typically searching)
*/
typedef struct _NMHVPROGRESS
{
	NMHDR  hdr;
	size_w pos;  // current progress
	size_w len;  // when pos equals this value, the operation is complete
} NMHVPROGRESS;

typedef struct _NMHVBOOKMARK
{
	NMHDR		hdr;
	HBOOKMARK	hbm;

} NMHVBOOKMARK;

#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif

//
// macros to allow passing of 64bit values to the 32bit version of SendMessage
// this works by passing the low 32bits in WPARAM, and the top 32bits in LPARAM
//
#ifdef SEQUENCE64
#define MAKE_SIZEW(wParam, lParam) ((size_w)(wParam) | ((size_w)(lParam) << 32))
#define WPARAM_SIZEW(sw) ((WPARAM)((size_w)(sw) & 0xffffffff))
#define LPARAM_SIZEW(sw) ((LPARAM)((size_w)(sw) >> 32))
#else
#define MAKE_SIZEW(wParam, lParam) ((size_w)(wParam))
#define WPARAM_SIZEW(sw) ((WPARAM)((size_w)(sw) & 0xffffffff))
#define LPARAM_SIZEW(sw) ((LPARAM)0)
#endif

/**
 * Apply one or more of the HexView-specific HVS_xxx styles. 
 *
 * @param  UINT uMask  - bitmask to control which bits to modify
 * @param  UINT uStyle - one or more of the HVS_xxx style values
 *
 */
#define HexView_SetStyle(hwnd, uMask, uStyle) \
	(UINT)SNDMSG((hwnd), HVM_SETSTYLE, (WPARAM)(UINT_PTR)(uMask), (LPARAM)(UINT_PTR)(uStyle))

/**
 * Specify the byte-grouping arrangement in the hex-pane. This allows
 * the hexpane to group bytes into columns. Typical values are 1, 2, 4 and 8
 *
 * @param UINT nBytes - the number of bytes in each column grouping
 */
#define HexView_SetGrouping(hwnd, nBytes) \
	(UINT)SNDMSG((hwnd), HVM_SETGROUPING, (WPARAM)(UINT_PTR)(nBytes), 0)

/**
 * Return the current styles selected into the hexview control
 * The styles are returned as a single UINT value
 *
 * @param
 */
#define HexView_GetStyle(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETSTYLE, (WPARAM)(UINT_PTR)(-1), 0)

/**
 * Return the style value(s) specified by the mask. The uMask
 * parameter must be one of the HVS_xx style values
 *
 * @param UINT uMask - bitmask that specifies which style(s) to return
 */
#define HexView_GetStyleMask(hwnd, uMask) \
	(UINT)SNDMSG((hwnd), HVM_GETSTYLE, (WPARAM)(UINT)(uMask), 0)

/**
 * Return the current byte-grouping arrange in the hex pane
 *
 */
#define HexView_GetGrouping(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETGROUPING, 0, 0)

//#define HexView_Highlight(hwnd, fEnable) \
//	(UINT)SNDMSG((hwnd), HVM_HIGHLIGHT, (WPARAM)(BOOL)(fEnable), 0)

#define HexView_AddBookmark(hwnd, param) \
	(HBOOKMARK)SNDMSG((hwnd), HVM_ADDBOOKMARK, 0, (LPARAM)(PBOOKMARK)(param))

#define HexView_DelBookmark(hwnd, param) \
	(UINT)SNDMSG((hwnd), HVM_DELBOOKMARK, (WPARAM)(HBOOKMARK)(param), 0)

/**
 * Specify a sequence of bytes that will have its every occurrence
 * highlighted in the current file
 *
 * @param
 */
#define HexView_SetSearchPattern(hwnd, pData, nLength) \
	(UINT)SNDMSG((hwnd), HVM_SETSEARCHPAT, (WPARAM)(ULONG_PTR)(nLength), (LPARAM)(PBYTE)(pData))

/**
 * Return the current position of the cursor, as an offset
 * in bytes, relative to the start of the file
 *
 * @param size_w *pCurPos - address of variable that will receive the value
 */
#define HexView_GetCurPos(hwnd, pCurPos) \
	(UINT)SNDMSG((hwnd), HVM_GETCURPOS, 0, (LPARAM)(size_w *)(pCurPos))

/**
 * Return the starting position of the active selection
 *
 * @param size_w *pSelStart - address of variable that will receive the value
 */
#define HexView_GetSelStart(hwnd, pSelStart) \
	(UINT)SNDMSG((hwnd), HVM_GETSELSTART, 0, (LPARAM)(size_w *)(pSelStart))

/**
 * Return the ending position of the active selection
 *
 * @param size_w *pSelEnd  - address of variable that will receive the value
 */
#define HexView_GetSelEnd(hwnd, pSelEnd) \
	(UINT)SNDMSG((hwnd), HVM_GETSELEND, 0, (LPARAM)(size_w *)(pSelEnd))

/**
 * Return the size of the active selection, in bytes
 *
 * @param size_w *pSelSize - 
 */
#define HexView_GetSelSize(hwnd, pSelSize) \
	(UINT)SNDMSG((hwnd), HVM_GETSELSIZE, 0, (LPARAM)(size_w *)(pSelSize))

/**
 * Return the size of the current file, in bytes
 *
 * @param size_w *pFileSize - pointer to a size_w variable, into which the filesize is returned
 */
#define HexView_GetFileSize(hwnd, pFileSize) \
	(UINT)SNDMSG((hwnd), HVM_GETFILESIZE, 0, (LPARAM)(size_w *)(pFileSize))

/**
 * Retrieve data from the active cursor location
 *
 * @param  BYTE *pData   - buffer which will receive the data being read
 * @param  ULONG nLength - size of pData, in bytes
 */
#define HexView_GetDataCur(hwnd, pData, nLength) \
	(UINT)SNDMSG((hwnd), HVM_GETDATACUR, (WPARAM)(PBYTE)pData, (LPARAM)(ULONG)nLength)

/**
 * Retrieve data from the active cursor location, and 
 * advance the cursor offset to the last position read from the file
 *
 * @param BYTE *pData - buffer which will receive the data being read
 * @param ULONG nLength - sizeof of pData, in bytes
 */
#define HexView_GetDataAdv(hwnd, pData, nLength) \
	(UINT)SNDMSG((hwnd), HVM_GETDATAADV, (WPARAM)(PBYTE)pData, (LPARAM)(ULONG)nLength)

/**
 * Insert/Overwrite data into the current cursor location,
 * but do not adjust the cursor offset
 *
 * @param BYTE *pData - buffer containing the data to insert/overwrite
 * @param ULONG nLength - size of pData, in bytes
 */
#define HexView_SetDataCur(hwnd, pData, nLength) \
	(UINT)SNDMSG((hwnd), HVM_SETDATACUR, (WPARAM)(PBYTE)pData, (LPARAM)(ULONG)nLength)

/**
 * Insert/Overwrite data into the current cursor location,
 * and advance the cursor offset to the end of the newly inserted data
 *
 * @param BYTE *pData - buffer containing the data to insert/overwrite
 * @param ULONG nLength - size of pData, in bytes
 */
#define HexView_SetDataAdv(hwnd, pData, nLength) \
	(UINT)SNDMSG((hwnd), HVM_SETDATAADV, (WPARAM)(PBYTE)pData, (LPARAM)(ULONG)nLength)

/**
 * Undo the last edit operation
 *
 * @param
 */
#define HexView_Undo(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_UNDO, 0, 0)

/**
 * Repeat the last Undo operation
 *
 */
#define HexView_Redo(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_REDO, 0, 0)

/**
 * Remove data within the active selection, and copy it to the clipboard
 *
 * @param
 */
#define HexView_Cut(hwnd) \
	(UINT)SNDMSG((hwnd), WM_CUT, 0, 0)

/**
 * Copy the active selection to the clipboard as CF_TEXT
 *
 * @param
 */
#define HexView_Copy(hwnd) \
	(UINT)SNDMSG((hwnd), WM_COPY, 0, 0)

/**
 * Paste the current CF_TEXT clipboard contents into HexView
 *
 * @param
 */
#define HexView_Paste(hwnd) \
	(UINT)SNDMSG((hwnd), WM_PASTE, 0, 0)

/**
 * Delete the current file content, but do not
 * reset the active file - allowing this operation to be undone
 *
 */
#define HexView_Delete(hwnd) \
	(UINT)SNDMSG((hwnd), WM_CLEAR, 0, 0)

/**
 * Set the current edit mode (insert/overwrite/readonly)
 *
 * @param UINT nEditMode - one of the 
 */
#define HexView_SetEditMode(hwnd, nEditMode) \
	(UINT)SNDMSG((hwnd), HVM_SETEDITMODE, (WPARAM)(nEditMode), 0)

/**
 * Return the current edit mode (one of the HVS_ values)
 *
 * @param
 */
#define HexView_GetEditMode(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETEDITMODE, 0, 0)

//!
//!	HexView_OpenFile
//!
//!	@param szFileName - full or partial path to file
//!	@param uMethod    - specify one of more of the HVOF_xxx flags:
//!					HVOF_READONLY, HVOF_QUICKLOAD, HVOF_QUICKSAVE
//!
#define HexView_OpenFile(hwnd, szFileName, uMethod) \
	(UINT)SNDMSG((hwnd), HVM_OPENFILE, (WPARAM)(UINT_PTR)(uMethod), (LPARAM)(LPCTSTR)(szFileName))

//!
//!	HexView_SaveFile
//!
//!	szFileName - full or partial path to file
//!	uMethod    - specify one of more of the HVOF_xxx flags:
//!					HVOF_READONLY, HVOF_QUICKLOAD, HVOF_QUICKSAVE
//!
#define HexView_SaveFile(hwnd, szFileName, uMethod) \
	(UINT)SNDMSG((hwnd), HVM_SAVEFILE, (WPARAM)(UINT_PTR)(uMethod), (LPARAM)(LPCTSTR)(szFileName))

#define HexView_InitBuf(hwnd, pBuffer, nLength) \
	(UINT)SNDMSG((hwnd), HVM_INITBUF, (WPARAM)(const PBYTE)(pBuffer), (LPARAM)(UINT_PTR)(nLength))

#define HexView_InitBufShared(hwnd, pBuffer, nLength) \
	(UINT)SNDMSG((hwnd), HVM_INITBUF_SHARED, (WPARAM)(const PBYTE)(pBuffer), (LPARAM)(UINT_PTR)(nLength))

/**
 * Return a boolean value indicating whether there are
 * any undo operations available
 *
 */
#define HexView_CanUndo(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_CANUNDO, 0, 0)

/**
 * Return a boolean value indicating whether there are any 
 * redo operations available
 *
 */
#define HexView_CanRedo(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_CANREDO, 0, 0)

/**
 * Specify a new menu to be used for the context-menu
 *
 * @param HMENU hMenu - win32 handle to the menu resource
 */
#define HexView_SetContextMenu(hwnd, hMenu) \
	(HMENU)SNDMSG((hwnd), HVM_SETCONTEXTMENU, (WPARAM)(HMENU)(hMenu), 0)

/**
 * Clear (delete) the current file content
 *
 */
#define HexView_Clear(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_CLEAR, 0, 0)

#define HexView_ClearBookmarks(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_CLEARBOOKMARKS, 0, 0)

#define HexView_GetBookmark(hwnd, hBookmark, bookm) \
	(BOOL)SNDMSG((hwnd), HVM_GETBOOKMARK, (WPARAM)(HBOOKMARK)(hBookmark), (LPARAM)(PBOOKMARK)(bookm))

#define HexView_EnumBookmark(hwnd, hBookmark, bookm) \
	(HBOOKMARK)SNDMSG((hwnd), HVM_ENUMBOOKMARK, (WPARAM)(HBOOKMARK)(hBookmark), (LPARAM)(PBOOKMARK)(bookm))

#define HexView_SetBookmark(hwnd, hBookmark, bookm) \
	(BOOL)SNDMSG((hwnd), HVM_SETBOOKMARK, (WPARAM)(HBOOKMARK)(hBookmark), (LPARAM)(PBOOKMARK)(bookm))

/**
 * Set the active cursor location (in bytes, offset from the start of the file)
 *
 * @param size_w pos - new offset of the cursor 
 */
#define HexView_SetCurPos(hwnd, pos) \
	(UINT)SNDMSG((hwnd), HVM_SETCURPOS, WPARAM_SIZEW(pos), LPARAM_SIZEW(pos))

/**
 * Set the starting position of the current selection
 *
 * @param size_w pos - offset of the selection-start, in bytes
 */
#define HexView_SetSelStart(hwnd, pos) \
	(UINT)SNDMSG((hwnd), HVM_SETSELSTART, WPARAM_SIZEW(pos), LPARAM_SIZEW(pos))

/**
 * Set the ending position of the current selection
 *
 * @param  size_w pos - offset of selection-end, in bytes
 */
#define HexView_SetSelEnd(hwnd, pos) \
	(UINT)SNDMSG((hwnd), HVM_SETSELEND, WPARAM_SIZEW(pos), LPARAM_SIZEW(pos))

/**
 * Adjust the viewport so that the specified file-offset
 * is scrolled into view, if that offset is outside of the viewport
 *
 * @param  size_w pos  - offset within the file which will be scrolled into view
 */
#define HexView_ScrollTo(hwnd, pos) \
	(UINT)SNDMSG((hwnd), HVM_SCROLLTO, WPARAM_SIZEW(pos), LPARAM_SIZEW(pos))

/**
 * Adjust the viewport so that the specified file-offset
 * is scrolled to the top of the viewport
 *
 * @param  size_w pos  - offset within the file which will be scrolled into view
 */
#define HexView_ScrollTop(hwnd, pos) \
	(UINT)SNDMSG((hwnd), HVM_SCROLLTOP, WPARAM_SIZEW(pos), LPARAM_SIZEW(pos))

#define HexView_FormatData(hwnd, fmtparam) \
	(int)SNDMSG((hwnd), HVM_FORMATDATA, 0, (LPARAM)(HEXFMT_PARAMS *)(fmtparam))

/**
 * Return the current line-length, in bytes
 *
 */
#define HexView_GetLineLen(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETLINELEN, 0, 0)

/**
 * Set the current line-length, in bytes
 *
 * @param UINT len - length of line, in bytes
 */
#define HexView_SetLineLen(hwnd, len) \
	(UINT)SNDMSG((hwnd), HVM_SETLINELEN, (WPARAM)(UINT)(len), 0)

/**
 * Returns a boolean value indicating if the HexView is in a 
 * drag-and-drop operation
 *
 * @param
 */
#define HexView_IsDragLoop(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_ISDRAGLOOP, 0, 0)

/**
 * Select all data in the HexView control
 *
 */
#define HexView_SelectAll(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_SELECTALL, 0, 0)

/**
 * Initialize a search with a new search term
 *
 * @param  BYTE *data  - address of buffer containing the search term
 * @param  UINT  len   - lengh of [data], in bytes
 */
#define HexView_FindInit(hwnd, data, len) \
	(BOOL)SNDMSG((hwnd), HVM_FINDINIT, (WPARAM)(UINT)(len), (LPARAM)(PBYTE)(data))

/**
 * Find the next occurance of the current search term
 *
 * @param size_w *pdwResult  - address of variable to receive location of matched data
 * @param UINT    options    - one of the HVFF_xxx values
 */
#define HexView_FindNext(hwnd, pdwResult, options) \
	(BOOL)SNDMSG((hwnd), HVM_FINDNEXT, (WPARAM)(UINT)(options), (LPARAM)(size_w *)(pdwResult))

/**
 * Find the previous occurance of the current search term
 *
 * @param size_w *pdwResult  - address of size_w variable to receive location of matched data
 * @param UINT    options    - one of the HVFF_xxx values
 *
 * @returns BOOL - boolean value indicating success or failure
 */
#define HexView_FindPrev(hwnd, pdwResult, options) \
	(BOOL)SNDMSG((hwnd), HVM_FINDPREV, (WPARAM)(UINT)(options), (LPARAM)(size_w *)(pdwResult))

/**
 * Cancel the current Find operation, if one is active
 *
 */
#define HexView_FindCancel(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_FINDCANCEL, 0, 0)

/**
 * Return the Win32 File HANDLE of the current file being edited
 *
 */
#define HexView_GetFileHandle(hwnd) \
	(HANDLE)SNDMSG((hwnd), HVM_GETFILEHANDLE, 0, 0)

/**
 * Return the current editing pane - either HVS_HEXPANE or HCS_ASCPANE
 * 
 */
#define HexView_GetCurPane(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETCURPANE, 0, 0)

/**
 * Set the current editing pane - either Hex or Ascii
 *
 * @param UINT pane  - either HVS_HEXPANE or HVS_ASCPANE values
 */
#define HexView_SetCurPane(hwnd, pane) \
	(UINT)SNDMSG((hwnd), HVM_SETCURPANE, (WPARAM)(UINT)(pane), 0)

/**
 * Return the path to the current file being edited
 *
 * @param TCHAR *buf  - pointer to buffer that will receive the filename
 * @param UINT   len  - length of [buf], in TCHARs
 */
#define HexView_GetFileName(hwnd, buf, len) \
	(UINT)SNDMSG((hwnd), HVM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPCTSTR)(buf))

/**
 * Returns whether the current file is being edited as readonly
 *
 */
#define HexView_IsReadOnly(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_ISREADONLY, 0, 0)

/**
 * Return the logical cursor position within the current
 * viewport, as an x,y coordinate
 *
 * @param POINT *coord - address of a POINT structure that receives the cursor position
 */
#define HexView_GetCurCoord(hwnd, coord) \
	(BOOL)SNDMSG((hwnd), HVM_GETCURCOORD, 0, (LPARAM)(POINT *)(coord))

/**
 * Restore the current file in the hexview to it's original state
 *
 */
#define HexView_Revert(hwnd) \
	(BOOL)SNDMSG((hwnd), HVM_REVERT, 0, 0)

/**
 * Import the specified file at the current cursor location,
 * using the current editing mode (insert/overwrite)
 *
 * @param TCHAR *szFileName - Path to the file to import
 * @param UINT   uMethod    - One of the HVOF_xxx flags
 */
#define HexView_ImportFile(hwnd, szFileName, uMethod) \
	(UINT)SNDMSG((hwnd), HVM_IMPORTFILE, (WPARAM)(UINT)(uMethod), (LPARAM)(LPCTSTR)(szFileName))

/**
 * Adjust the horizontal and vertical spacing between characters in
 * the current font selected into the HexView. Send this message after 
 * setting the active font.
 *
 * @param SHORT xspace   - Horizontal spacing (in pixels)
 * @param SHORT yspace   - Vertical spacing (in pixels)
 */
#define HexView_SetFontSpacing(hwnd, xspace, yspace) \
	(UINT)SNDMSG((hwnd), HVM_SETFONTSPACING, 0, (LPARAM)MAKELONG((short)(xspace), (short)(yspace)))

/**
 * Set the font for the specified HexView control
 *
 * @param HFONT hFont - win32 font handle
 *
 */
#define HexView_SetFont(hwnd, hFont) \
	(VOID)SNDMSG((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hFont), 0)

/**
 * Set a new color for the specified HexView display element
 *
 * @param UINT index     - one of the HVC_* color indices
 * @param COLORREF color - a RGB value, or a HEX_SYSCOLOR value
 */
#define HexView_SetColor(hwnd, index, color) \
	(UINT)SNDMSG((hwnd), HVM_SETCOLOR, (WPARAM)(UINT_PTR)(index), (LPARAM)(COLORREF)(color))

/**
 * Get the color-value for the specified HexView display element
 *
 * @param UINT index     - one of the HVC_* color indices
 */
#define HexView_GetColor(hwnd, index) \
	(COLORREF)SNDMSG((hwnd), HVM_GETCOLOR, (WPARAM)(UINT)(index), 0)

/**
 * Specify the left & right padding (in character units) 
 * either side of the main hex display. i.e. in-between the address&hex display,
 * and the hex&ascii display, respectively
 *
 * @param int left - number of characters between the address column & hex display
 * @param int right - number of characters between the hex display & ascii display
 */
#define HexView_SetPadding(hwnd, left, right) \
	(VOID)SNDMSG((hwnd), HVM_SETPADDING, 0, (LPARAM)MAKEWPARAM((USHORT)(int)(left), (USHORT)(int)(right)))

/**
 * Specify offset that the address display begins at (default is 0)
 * This is purely a cosmetic change - actual offsets (such as cursor/selection)
 * within the hexview do not change
 *
 * @param size_w offset - value by which to offset the address column
 */
#define HexView_SetAddressOffset(hwnd, offset) \
	(VOID)SNDMSG((hwnd), HVM_SETADDROFFSET, WPARAM_SIZEW(offset), LPARAM_SIZEW(offset))

/**
 * Return the number of characters required to render a line in the hexview,
 * includes the space required for the null character
 */
#define HexView_GetLineChars(hwnd) \
	(UINT)SNDMSG((hwnd), HVM_GETLINECHARS, 0, 0)

/**
 * Offset the hex&ascii display by the given amount 
 *
 * @param size_w offset  - number of bytes to offset the display by
 */
#define HexView_SetDataShift(hwnd, offset) \
	(UINT)SNDMSG((hwnd), HVM_SETDATASHIFT, WPARAM_SIZEW(offset), LPARAM_SIZEW(offset))


//
//	Functions exported from HexLib (i.e not message macros)
//

/**
 * Set the starting and ending positions for the active selection
 *
 * @param size_w selStart - starting offset, in bytes
 * @param size_w selEnd   - ending offset, in bytes
 */
ULONG WINAPI HexView_SetCurSel(HWND hwnd, size_w selStart, size_w selEnd);

/**
 * Insert or Overwrite (depending on the current edit mode) the specified
 * buffer of data, into the specified offset within the file
 *
 * @param  size_w offset - position into which to insert/overwrite the data
 * @param  BYTE *buf     - buffer containing the data to insert
 * @param  ULONG len     - length of data to insert, in bytes
 */
ULONG WINAPI HexView_SetData(HWND hwnd, size_w offset, BYTE *buf, ULONG len);

/**
 * Retrieve data in the current file from the specified offset
 *
 * @param  size_w offset - position from which to retrieve the data
 * @param  BYTE *buf     - buffer that will receive the data
 * @param  ULONG len     - length of the [buf] buffer, in bytes
 */
ULONG WINAPI HexView_GetData(HWND hwnd, size_w offset, BYTE *buf, ULONG len);

/**
 * Fill using the specified buffer of data, at the current cursor offset, using the 
 * current edit mode (insert/overwrite). The data will be repeated to ensure the 
 * specified range of data is updated
 *
 * @param  BYTE *buf    - buffer containing the Fill data
 * @param  ULONG buflen - size of [buf], in bytes
 * @param  size_w len   - total length of data to insert/overwrite
 */
ULONG WINAPI HexView_FillData(HWND hwnd, BYTE *buf, ULONG buflen, size_w len);

#define HexView_SetRedraw(hwnd, fRedraw) \
	(UINT)SNDMSG((hwnd), WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0)

#ifdef __cplusplus
}
#endif

#endif

```

`HexView/HexView.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3FBA3178-4AE6-4103-9EB2-542901D978B7}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HexView</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v143</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(ProjectDir)$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(ProjectDir)$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IntDir>$(ProjectDir)$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IntDir>$(ProjectDir)$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(ProjectDir)$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(ProjectDir)$(Configuration)\</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IntDir>$(ProjectDir)$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IntDir>$(ProjectDir)$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);SEQUENCE64</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions);SEQUENCE64</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);SEQUENCE64</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions);SEQUENCE64</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>..\Common</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <LanguageStandard>stdcpp14</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HexView.cpp" />
    <ClCompile Include="HexViewBoomark.cpp" />
    <ClCompile Include="HexViewClipboard.cpp" />
    <ClCompile Include="HexViewDraw.cpp" />
    <ClCompile Include="HexViewDrawNote.cpp" />
    <ClCompile Include="HexViewFile.cpp" />
    <ClCompile Include="HexViewFind.cpp" />
    <ClCompile Include="HexViewHighlight.cpp" />
    <ClCompile Include="HexViewKeyboard.cpp" />
    <ClCompile Include="HexViewMouse.cpp" />
    <ClCompile Include="HexViewScroll.cpp" />
    <ClCompile Include="IDataObject.cpp" />
    <ClCompile Include="IDropSource.cpp" />
    <ClCompile Include="IDropTarget.cpp" />
    <ClCompile Include="IEnumFormat.cpp" />
    <ClCompile Include="IStream.cpp" />
    <ClCompile Include="seqbuf.cpp" />
    <ClCompile Include="sequence.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HexView.h" />
    <ClInclude Include="HexViewInternal.h" />
    <ClInclude Include="seqbase.h" />
    <ClInclude Include="sequence.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HexView/HexView.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HexView.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewBoomark.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewClipboard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewDraw.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewDrawNote.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewFile.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewFind.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewHighlight.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewKeyboard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewMouse.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewScroll.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IDataObject.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IDropSource.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IDropTarget.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IEnumFormat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IStream.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="seqbuf.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="sequence.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="HexView.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="HexViewInternal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="seqbase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sequence.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`HexView/HexViewBoomark.cpp`:

```cpp
//
//  HexViewBoomark.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include <tchar.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

bool __inline overlaps(size_w a1, size_w b1, size_w a2, size_w b2)
{
	return (a1 >= a2 && a1 < b2 || b1 >= a2 && b1 < b2 || a1 <= a2 && b1 > a2);
}

BOOKNODE * HexView::FindBookmark(size_w startoff, size_w endoff)
{
	BOOKNODE *bptr = 0;

	for(bptr = m_BookHead->next; bptr != m_BookTail; bptr = bptr->next)
	{
		if(overlaps(startoff, endoff, bptr->bookmark.offset, bptr->bookmark.offset + bptr->bookmark.length))
			break;
	}

	return bptr;
}

extern "C" COLORREF MixRgb(COLORREF col1, COLORREF col2);

BOOL HexView::GetHighlightCol(size_w offset, int pane, BOOKNODE *itemStart,  
							  HEXCOL *col1, HEXCOL *col2, 
							  bool fModified, bool fMatched, bool fIncSelection)
{
	//int idx = -1;
	//int m_nNumHighlights = m_Highlight->nNumItems;
	//HIGHLIGHT *Highlight = m_Highlight->Highlight;

	BOOKNODE *hi = itemStart;

	size_w selstart = min(m_nSelectionStart, m_nSelectionEnd);
	size_w selend   = max(m_nSelectionStart, m_nSelectionEnd);

	int nSchemeIdxFG;
	int nSchemeIdxBG;

	BOOL fGotFocus = GetFocus() == m_hWnd ? TRUE : FALSE;
//	fGotFocus = fGotFocus && GetAncestor(GetForegroundWindow(), GA_ROOTOWNER) == GetParent(m_hWnd);
	
	fGotFocus = fGotFocus && IsWindowEnabled(GetParent(m_hWnd));

	//TRACEA("FG = %x (me=%x)\n", GetForegroundWindow(), m_hWnd);

	if(pane == 0)
	{
		nSchemeIdxFG = (((offset + m_nDataShift)% m_nBytesPerLine) / m_nBytesPerColumn) & 1 ? HVC_HEXEVEN : HVC_HEXODD;
		nSchemeIdxBG = HVC_BACKGROUND;
	}
	else
	{
		nSchemeIdxFG = HVC_ASCII;
		nSchemeIdxBG = HVC_BACKGROUND;
	}

	// modified bytes override normal settings
	if(fModified && CheckStyle(HVS_SHOWMODS))
		nSchemeIdxFG = HVC_MODIFY;

	if(fMatched)
	{
		//nSchemeIdxFG = HVC_BACKGROUND;
		nSchemeIdxBG = HVC_MATCHED;
	}

	// search forward to find the highlight under specified offset
	for(hi = itemStart; hi; hi = hi->next)
	{
		if(offset >= hi->bookmark.offset && 
			offset < hi->bookmark.offset + hi->bookmark.length)
		{
			break;
		}
	}
/*

	// search forward to find the highlight under specified offset
	for(int i = highidx; i < m_nNumHighlights && i != -1; i++)
	{
		// find the nearest highlight 
		if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd)
		{
			idx = i;
			//break;
		}
	}*/

	// matched a highlight...check if its a stack of highlights
	if(hi)//idx != -1)
	{
		// if this is a stack of highlights, iterate down through the stack looking
		// for a highlight which overlaps
	/*	while(Highlight[idx].Stack != 0)
		{
			m_nNumHighlights = Highlight[idx].Stack->nNumItems;
			Highlight = Highlight[idx].Stack->Highlight;

			for(int i = m_nNumHighlights-1; i >= 0; i--)
			{
				if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd)
				{
					idx = i;
					break;
				}
			}
		}*/
	}

	// found a highlight? set the colour
	if(hi && 
		offset >= hi->bookmark.offset && 
		offset < hi->bookmark.offset + hi->bookmark.length)// >= 0)
	{
		//col1->colFG = Highlight[idx].colFG;
		//col1->colBG = Highlight[idx].colBG;


		col1->colFG = hi->bookmark.col;
		col1->colBG = hi->bookmark.backcol;

		//col1->colFG = RGB(255,255,255);
		//col1->colBG = RGB(128,128,128);

		*col2 = *col1;

		if(fModified)
		{
			col1->colFG = GetHexColour(HVC_MODIFY);
			col2->colFG = GetHexColour(HVC_MODIFY);
		}
	}
	// no highlight, use the default window scheme
	else
	{
		col1->colFG = GetHexColour(nSchemeIdxFG);
		col1->colBG = GetHexColour(nSchemeIdxBG);
		*col2 = *col1;
	}

	// if at the end of the highlight, need to paint in two colours
	//if(idx != -1 && offset == Highlight[idx].nRangeEnd - 1)
	if(hi && offset == hi->bookmark.offset + hi->bookmark.length - 1)
	{
		/*int idx2 = -1;

		// search backwards again
		for(int i = idx - 1; i >= 0; i--)
		{
			if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd - 1)
			{
				idx2 = i;
				break;
			}
		}

		if(idx2 != -1)
		{
			col2->colFG = Highlight[idx2].colFG;
			col2->colBG = Highlight[idx2].colBG;
		}
		else
		{
			col2->colBG = GetHexColour(nSchemeIdxBG);
		}*/
	}

	// selected data overrides everything else!
	if(fIncSelection && offset >= selstart && offset < selend)
	{
		// selected colour is next sequential index
		if(fGotFocus)
		nSchemeIdxFG++;

		//nSchemeIdxFG = nSchemeIdxBG;
		//nSchemeIdxBG++;
		//nSchemeIdxFG++;
		//nSchemeIdxBG++;


		if(nSchemeIdxBG == HVC_MATCHED)
			nSchemeIdxFG = HVC_MATCHEDSEL;

		//nSchemeIdxBG = HVC_SELECTION;

		if(pane != m_nWhichPane)
		{
			//if(nSchemeIdxBG == HVC_BACKGROUND)
				nSchemeIdxBG = HVC_SELECTION;
		//	nSchemeIdxFG++;
		//	nSchemeIdxBG++;
		}
		else
		{
			//if(nSchemeIdxBG == HVC_BACKGROUND)
				nSchemeIdxBG = HVC_SELECTION;

		}
		
		if(!fGotFocus)
		{
			nSchemeIdxBG = HVC_SELECTION3;
			//nSchemeIdxFG = HVC_SELECTION4;
		}


		if(CheckStyle(HVS_INVERTSELECTION))
		{
			col1->colBG = 0xffffff & ~col1->colBG;
			col1->colFG = 0xffffff & ~col1->colFG;
		}
		else
		{
			//col1->colFG = MixRgb(GetHexColour(HVC_SELECTION), GetHexColour(nSchemeIdxFG));
			//col1->colBG = MixRgb(GetHexColour(HVC_SELECTION), GetHexColour(nSchemeIdxBG));

			//if(!fModified)
			col1->colFG = !hi || fModified ? GetHexColour(nSchemeIdxFG) :col2->colBG;
			col1->colBG = GetHexColour(nSchemeIdxBG);
			
			
			//col1->colFG = GetHexColour((idx == -1) ? nSchemeIdxFG : HVC_BOOKSEL);
			//col1->colBG = idx == -1 ? col1->colBG : 0xffffff & ~col1->colFG;
		}


#ifdef SELECTION_USES_HIGHLIGHT
		if(m_fHighlighting)
		{
			col1->colFG = 0xffffff & ~GetHexColour(HVC_BOOKMARK_FG);
			col1->colBG = 0xffffff & ~GetHexColour(HVC_BOOKMARK_BG);
		}
#endif

		if(offset < selend - 1 && selend > 0)
			*col2 = *col1;
	} 

	// take into account any offset/shift in the datasource
	offset += m_nDataShift;//Start;
	if((offset + 1) % (m_nBytesPerLine) == 0 && offset != 0)
	{
		col2->colFG = col1->colFG;
		col2->colBG = GetHexColour(HVC_BACKGROUND);
	}

	return TRUE;
}

/*LONG HexView::Highlight(BOOL fEnable)
{
	m_fHighlighting = fEnable ? true : false;
	return 0;
}*/

BOOKNODE * HexView::AddBookmark(BOOKMARK * bookm)
{
	BOOKNODE * bnew = new BOOKNODE();//bookm);
	BOOKNODE * bptr;

	// find the best place to insert into
	for(bptr = m_BookHead->next; bptr != m_BookTail; bptr = bptr->next)
	{
		if(bookm->offset < bptr->bookmark.offset)
		{
			break;
		}
	}

	bnew->prev		 = bptr->prev;
	bnew->next		 = bptr;

	bptr->prev->next = bnew;
	bptr->prev		 = bnew;


	bnew->bookmark = *bookm;
	bnew->bookmark.pszText  = bookm->pszText ? _tcsdup(bookm->pszText) : 0;//TEXT("");
	bnew->bookmark.pszTitle = bookm->pszTitle ? _tcsdup(bookm->pszTitle) : 0;//TEXT("");
	

	RefreshWindow();


	return (BOOKNODE *)bnew;
}

BOOL HexView::DelBookmark(BOOKNODE * delthis)
{
	BOOKNODE * bptr;

	for(bptr = m_BookHead->next; bptr != m_BookTail; bptr = bptr->next)
	{
		if(bptr == delthis)
		{
			bptr->prev->next = bptr->next;
			bptr->next->prev = bptr->prev;

			delete delthis;
			RefreshWindow();

			return TRUE;
		}
	}

	return FALSE;
}

BOOL HexView::ClearBookmarks()
{
	BOOKNODE *bptr, *btmp;
	
	for(bptr = m_BookHead->next; bptr != m_BookTail; bptr = btmp)
	{
		btmp = bptr->next;
		delete bptr;
	}

	m_BookHead->next = m_BookTail;
	m_BookTail->prev = m_BookHead;

	RefreshWindow();
	return TRUE;
}

BOOL HexView::SetBookmark(BOOKNODE *bptr, BOOKMARK *param)
{
	// if the offset/length has changed??
	if(param->offset != bptr->bookmark.offset || 
	   param->length != bptr->bookmark.length)
	{
		//InvalidateRange(hip->hp.start, hip->hp.start + hip->hp.length);
		//InvalidateRange(param->start, param->start + param->length);
		RefreshWindow();
	}

	free(bptr->bookmark.pszText);
	free(bptr->bookmark.pszTitle);

	bptr->bookmark = *param;
	bptr->bookmark.pszText  = param->pszText ? _tcsdup(param->pszText) : 0;
	bptr->bookmark.pszTitle = param->pszTitle ? _tcsdup(param->pszTitle) : 0;

	RefreshWindow();

	return TRUE;
}
	
BOOKNODE * HexView::EnumBookmark(BOOKNODE * bptr, BOOKMARK * param)
{
	if(bptr == NULL)
		bptr = m_BookHead;

	while(bptr)
	{
		bptr = bptr->next;

		if(bptr == m_BookTail)
			return NULL;

		if((bptr->bookmark.flags & HVBF_NOENUM) == 0)
		{
			*param = bptr->bookmark;
			return bptr;
		}
	}

	return NULL;
}

BOOL HexView::GetBookmark(BOOKNODE * bptr, BOOKMARK * param)
{
	if(bptr == NULL || bptr == m_BookHead || bptr == m_BookTail)
		return FALSE;

	*param = bptr->bookmark;
	return TRUE;
}

BOOL HexView::BookmarkRect(BOOKMARK *bm, RECT *rect)
{
	size_w windowstart = m_nVScrollPos * m_nBytesPerLine;

	if(bm->offset >= windowstart && bm->offset + bm->length < windowstart + m_nWindowLines*m_nBytesPerLine)
	{
		rect->top	 = (LONG)(bm->offset / m_nBytesPerLine - m_nVScrollPos) * m_nFontHeight;
		rect->bottom = rect->top + 50;
		rect->left	 = m_nWindowColumns * m_nFontWidth + BOOKMARK_XOFFSET - m_nHScrollPos * m_nFontWidth;
		rect->right  = rect->left + 300;

		HDC hdc = GetDC(0);
				
		DrawText(hdc, bm->pszText, lstrlen(bm->pszText), rect, DT_EDITCONTROL|DT_CALCRECT);

		ReleaseDC(0, hdc);
		
		rect->right = rect->left + 300;
		rect->bottom += 20;

		return TRUE;
	}

	return FALSE;
}

```

`HexView/HexViewClipboard.cpp`:

```cpp
//
//  HexViewClipboard.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include <tchar.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"
#include <memory>
#include <string>

HRESULT GetDataObjBuf(IDataObject* pDataObject, LPCTSTR szFormat, PVOID pData, DWORD nLength);
HRESULT GetDataObjDword(IDataObject* pDataObject, LPCTSTR szFormat, DWORD_PTR* pdwValue);

/*DWORD GetClipboardDataPtr(TCHAR *szFormatName, PVOID pData, DWORD nLength)
{
	UINT	uFormat;
	HANDLE	hMem;
	PVOID	ptr;

	if((uFormat = RegisterClipboardFormat(szFormatName)) == 0)
		return FALSE;

	if((hMem = GetClipboardData(uFormat)) == 0)
		return FALSE;

	if((ptr = GlobalLock(hMem)) == 0)
		return FALSE;

	nLength = min(nLength, GlobalSize(hMem));

	memcpy(pData, ptr, nLength);

	GlobalUnlock(hMem);
	return nLength;
}

BOOL SetClipboardDataPtr(TCHAR *szFormatName, PVOID pData, ULONG nLength)
{
	UINT	uFormat;
	PVOID   ptr;

	if((uFormat = RegisterClipboardFormat(szFormatName)) == 0)
		return FALSE;

	if((ptr = GlobalAlloc(GPTR, nLength)) == 0)
		return FALSE;

	memcpy(ptr, pData, nLength);
	SetClipboardData(uFormat, ptr);
	return TRUE;
}*/

//
//	Paste any CF_TEXT/CF_UNICODE text from the clipboard
//
BOOL HexView::OnPaste() {
	BOOL success = FALSE;
	IDataObject* pDataObject;

	if (m_nEditMode == HVMODE_READONLY)
		return FALSE;

	// Retrieve IDataObject from the clipboard
	if (OleGetClipboard(&pDataObject) == S_OK) {
		// extract the data!
		DropData(pDataObject, true, false);
		pDataObject->Release();

		m_pDataSeq->breakopt();
		return TRUE;
	}

	return FALSE;

/*	if(OpenClipboard(m_hWnd))
	{
		DWORD  len;
		HANDLE hMem		= GetClipboardData(CF_TEXT);
		BYTE *pData		= (BYTE *)GlobalLock(hMem);

		if(pData)
		{
			if(GetClipboardDataPtr(CF_PRI_RLE32, &len, sizeof(DWORD)) == 0)
			{
				len = strlen((char *)pData);
			}

			EnterData(pData, len, false);

			m_pDataSeq->breakopt();

			//if(textlen > 1)
			//	m_pTextDoc->m_seq.breakopt();

			GlobalUnlock(hMem);
			success = TRUE;
		}

		CloseClipboard();
	}

	return success;*/
}

//
//	Retrieve the specified range of text and copy it to supplied buffer
//	szDest must be big enough to hold nLength characters
//	nLength includes the terminating NULL
//
ULONG HexView::GetData(size_w nStartOffset, BYTE* pBuf, ULONG nLength) {
	return (ULONG)m_pDataSeq->render(nStartOffset, pBuf, (ULONG)nLength);
}

//
//	Retrieve the specified range of text and copy it to supplied buffer
//	szDest must be big enough to hold nLength characters
//	nLength includes the terminating NULL
//
ULONG HexView::SetData(size_w nStartOffset, BYTE* pBuf, ULONG nLength) {
	InvalidateRange(nStartOffset, nStartOffset + nLength);
	return (ULONG)m_pDataSeq->replace(nStartOffset, pBuf, (ULONG)nLength);
	//return m_pDataSeq->render(nStartOffset, pDest, nLength);
}

ULONG HexView::FillData(BYTE* buf, ULONG buflen, size_w len) {
	m_pDataSeq->group();

	BOOL fRedraw = SetRedraw(FALSE);

	while (len > 0) {
		buflen = (ULONG)min(buflen, len);

		EnterData(buf, buflen, true, true, false, NULL);

		len -= buflen;
	}

	SetRedraw(fRedraw);

	size_w offset = min(SelectionStart(), m_nCursorOffset);
	ContentChanged(offset, len, HVMETHOD_OVERWRITE);

	m_pDataSeq->ungroup();
	return 0;
}



//
//	Enter a buffer of data into the HexView at the current
//  cursor position. Optional HexSnapShot can be used instead of buffer
//
size_w HexView::EnterData(BYTE* pSource, size_w nLength, bool fAdvanceCaret, bool fReplaceSelection, bool fSelectData, HexSnapShot* hss /*= 0*/) {
	size_w offset = m_nCursorOffset;
	bool fAllowChange = true;

	if (m_nEditMode == HVMODE_READONLY)
		return 0;

	if (pSource == NULL && hss == NULL)
		return 0;

	if (m_fRedrawChanges)
		fAllowChange = AllowChange(m_nCursorOffset, nLength, m_nEditMode == HVMODE_OVERWRITE ? HVMETHOD_OVERWRITE : HVMETHOD_INSERT, pSource);

	if (m_nEditMode != HVMODE_INSERT)
		fReplaceSelection = false;

	if (fReplaceSelection && SelectionSize() == 0)
		fReplaceSelection = false;

	if (fReplaceSelection && fAllowChange) {
		// group this erase with the insert/replace operation
		m_pDataSeq->group();
		m_pDataSeq->erase(SelectionStart(), SelectionSize());
	}

	if (SelectionSize() > 0 && (m_nCursorOffset == m_nSelectionStart || m_nCursorOffset == m_nSelectionEnd)) {
		m_nCursorOffset = SelectionStart();
	}

	// are we entering a snapshot?
	if (hss) {
		if (fAllowChange) {
			if (m_nEditMode == HVMODE_OVERWRITE)
				m_pDataSeq->replace_snapshot(m_nCursorOffset, hss->m_length, hss->m_desclist, hss->m_count);
			else
				m_pDataSeq->insert_snapshot(m_nCursorOffset, hss->m_length, hss->m_desclist, hss->m_count);
		}

		nLength = hss->m_length;
	}
	// regular data entry
	else {
		if (fAllowChange) {
			if (m_nEditMode == HVMODE_OVERWRITE)
				m_pDataSeq->replace(m_nCursorOffset, pSource, nLength);
			else
				m_pDataSeq->insert(m_nCursorOffset, pSource, nLength);
		}
	}

	if (fSelectData) {
		m_nSelectionStart = m_nCursorOffset;
		m_nCursorOffset += nLength;
		m_nSelectionEnd = m_nCursorOffset;
	}
	else if (fAllowChange) {
		if (fAdvanceCaret)
			m_nCursorOffset += nLength;

		m_nSelectionStart = m_nCursorOffset;
		m_nSelectionEnd = m_nCursorOffset;
	}

	if (fReplaceSelection && fAllowChange)
		m_pDataSeq->ungroup();

	if (m_fRedrawChanges)
		ContentChanged(offset, nLength, m_nEditMode == HVMODE_INSERT ? HVMETHOD_INSERT : HVMETHOD_OVERWRITE);

	return nLength;
}

//
//	Copy the currently selected text to the clipboard as CF_TEXT/CF_UNICODE
//
BOOL HexView::OnCopy() {
	//IDataObject *pDataObject;

	//if(SelectionSize() == 0)
	//	return FALSE;

	//// Create an IDataObject representing the range of selected data
	//if(!CreateDataObject(SelectionStart(), SelectionSize(), &pDataObject))
	//	return FALSE;

	//if(OleSetClipboard(pDataObject) == S_OK)
	//{
	//	m_pLastDataObject = pDataObject;
	//	//pDataObject->Release();
	//	return TRUE;
	//}
	//else
	//{
	//	pDataObject->Release();
	//	return FALSE;
	//}

	bool success = false;
	if (OpenClipboard(m_hWnd)) {
		HANDLE hMem;
		BYTE* ptr;

		auto sellen = SelectionSize();
		if (sellen == 0)
			return false;

		auto selstart = SelectionStart();
		auto data = std::make_unique<BYTE[]>(sellen);
		GetData(selstart, data.get(), sellen);

		if ((hMem = GlobalAlloc(GPTR, (sellen * 3) + 1)) != 0) {
			if ((ptr = (BYTE*)GlobalLock(hMem)) != 0) {
				EmptyClipboard();

				std::string sdata;
				char single[4];
				for (int i = 0; i < sellen; i++) {
					sprintf_s(single, "%02X ", data[i]);
					sdata += single;
				}
				memcpy(ptr, sdata.c_str(), sdata.length() + 1);
				SetClipboardData(CF_TEXT, hMem);
				success = TRUE;

				GlobalUnlock(hMem);

//				SetClipboardDataPtr(CF_PRI_RLE32, &sellen, sizeof(DWORD));
			}
		}

		CloseClipboard();
	}

	return success;
}

//
//	Remove current selection and copy to the clipboard
//
BOOL HexView::OnCut() {
	BOOL success = FALSE;

	// can only 'cut' when in Insert mode
	if (m_nEditMode != HVMODE_INSERT)
		return FALSE;

	if (SelectionSize() > 0) {
		// copy selected text to clipboard then erase current selection
		success = OnCopy() && OnClear();
	}

	return success;
}

//
//	Remove the current selection
//
BOOL HexView::OnClear() {
	BOOL success = FALSE;

	// can only 'delete' when in Insert mode
	switch (m_nEditMode) {
		case HVMODE_READONLY:
			break;

		case HVMODE_INSERT:

			if (SelectionSize() > 0) {
				ForwardDelete();
			}

			break;

		case HVMODE_OVERWRITE:

			if (SelectionSize() > 0) {
				BYTE b[] = { 0 };
				success = FillData(b, 1, SelectionSize());
				//ContentChanged(m_nCursorOffset, SelectionSize(), HVMETHOD_OVERWRITE);
			}

			break;
	}

	return success;
}

//
//
//
VOID HexView::ClipboardShutdown() {
	// is our dataobject still on the clipboard?
	if (S_OK == OleIsCurrentClipboard(m_pLastDataObject)) {
		DWORD_PTR len;

		// see how much data we put there
		if (GetDataObjDword(m_pLastDataObject, CFSTR_HEX_DATALEN, &len) == S_OK) {
			// ask the user to empty the clipboard if the data's quite large
			if (len > 1024) {
				UINT answer;
				TCHAR szMessage[200];

				wsprintf(szMessage, _T("There is currently %dkb of data on the Clipboard.\r\n")
					_T("Would you like to leave this data for other applications?"),
					len / 1024);

				answer = MessageBox(m_hWnd, szMessage, _T("HexEdit"), MB_YESNO | MB_ICONQUESTION);

				if (answer != IDYES)
					OleSetClipboard(NULL);
			}
		}

		// 'flush' our dataobject
		OleFlushClipboard();
	}
}
```

`HexView/HexViewDraw.cpp`:

```cpp
//
//  HexViewDraw.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#define _CRT_NON_CONFORMING_SWPRINTFS
#define _CRT_SECURE_NO_WARNINGS

#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <vsstyle.h>
//#include <tmschema.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include <trace.h>

//extern	HIGHLIGHT m_Highlight[];

//void DrawNoteStrip(HDC hdc, int x, int y, HIGHLIGHT_PARAM *hparam);

//extern UINT	 m_nNumHighlights;

//HIGHLIGHT_ITEM * FindHighlight(size_w startoff, size_w endoff, HIGHLIGHT_ITEM *HighlightList);
//int FindHighlight(size_w startoff, size_w endoff, HIGHLIGHT_LIST *HighlightList);

bool operator != (HEXCOL &c1, HEXCOL &c2)
{
	return memcmp(&c1, &c2, sizeof(HEXCOL)) != 0;
}

bool operator == (HEXCOL &c1, HEXCOL &c2)
{
	return memcmp(&c1, &c2, sizeof(HEXCOL)) == 0;
}

static size_t int_to_bin(TCHAR *buf, UINT width, UINT num)
{
	TCHAR *start = buf;
	size_t i;

	while(width > 0)
	{
		BYTE val = (num >> ((width * 8) - 8)) & 0x000000ff;

		for(i = 0; i < 8; i++)
		{
			*buf++ = (num & 0x80) ? '1' : '0';
			num <<= 1;
		}

		width--;
	}

	*buf = 0;

	return (buf-start);
}


//
//	Format an address into the specified buffer, using
//  current address-column settings
//
size_t HexView::FormatAddress(size_w addr, TCHAR *buf, size_t buflen)
{
	if(CheckStyle( HVS_ADDR_INVISIBLE ))
	{
		buf[0] = '\0';
		return 0;
	}

	addr += m_nAddressOffset;

	if(CheckStyle( HVS_ADDR_DEC ))
	{
		_stprintf_s(buf, buflen, _T(" %0.*I64u"), m_nAddressDigits, (UINT64)addr);
	}
	else
	{
		TCHAR *szHexFmt;

		if(CheckStyle( HVS_ADDR_MIDCOLON ))
		{
			/*if(m_nFileLength > 0xffffffff)
			{
				szHexFmt = CheckStyle( HVS_LOWERCASEHEX ) ? _T("%0.*I64x:%08x") : _T("%0.*I64X:%08X");
				_stprintf(buf, szHexFmt, m_nAddressDigits-8, (UINT64)addr >> 32L, addr & 0xFFFFFFFF);
			}
			else*/
			{
				szHexFmt = CheckStyle( HVS_LOWERCASEHEX ) ? _T(" %0.*I64x:%04x") : _T(" %0.*I64X:%04X");
				_stprintf_s(buf, buflen, szHexFmt, m_nAddressDigits-4, (UINT64)addr >> 16L, addr & 0xFFFF);
			}
		}
		else
		{
			szHexFmt = CheckStyle( HVS_LOWERCASEHEX ) ? _T(" %0.*I64x") : _T(" %0.*I64X");	//_T("%0.*I64x") : _T("%0.*I64X");
			//szHexFmt = CheckStyle( HVS_LOWERCASEHEX ) ? _T("%8x") : _T("%8x");	//_T("%0.*I64x") : _T("%0.*I64X");
			_stprintf_s(buf, buflen, szHexFmt, m_nAddressDigits, (UINT64)addr);
			//_stprintf(buf, szHexFmt, (UINT64)addr);
		}
	}

	if(CheckStyle( HVS_ADDR_ENDCOLON ))
		_tcscat(buf, _T(":"));

	size_t len = _tcslen(buf);

	if(len > m_nAddressWidth)
		wmemmove(buf+1, buf + (len - m_nAddressWidth) + 1, len-m_nAddressWidth+1);

	return _tcslen(buf);
}

void reverse(BYTE *buf, int len)
{
	for(int i = 0; i < len/2; i++)
	{
		BYTE tmp = buf[i];
		buf[i] = buf[len - i - 1];
		buf[len - i - 1] = tmp;
	}
}

BOOL HexView::SetHexColour(UINT uIndex, COLORREF col)
{
	if(uIndex >= HV_MAX_COLS) 
		return FALSE;

	m_ColourList[uIndex] = col;
	return TRUE;
}

COLORREF HexView::GetHexColour(UINT uIndex)
{
	if(uIndex >= HV_MAX_COLS) 
		return FALSE;

	return RealiseColour(m_ColourList[uIndex]);
}

COLORREF HexView::RealiseColour(COLORREF cr)
{
	return HexView_RealiseColour(cr);
}

size_t HexView::FormatHexUnit(BYTE *data, TCHAR *buf, size_t buflen)
{
	TCHAR *szFmt;

	switch(m_nControlStyles & HVS_FORMAT_MASK)
	{
	case HVS_FORMAT_HEX:
		switch (m_nBytesPerColumn) {
			case 1:	
				szFmt = CheckStyle(HVS_LOWERCASEHEX) ? _T("%02x") : _T("%02X");
				return _stprintf(buf, szFmt, data[0]);
			case 2:
				szFmt = CheckStyle(HVS_LOWERCASEHEX) ? _T("%04x") : _T("%04X");
				return _stprintf(buf, szFmt, *(unsigned short*)data);
			case 4:
				szFmt = CheckStyle(HVS_LOWERCASEHEX) ? _T("%08x") : _T("%08X");
				return _stprintf(buf, szFmt, *(unsigned*)data);
			case 8:
				szFmt = CheckStyle(HVS_LOWERCASEHEX) ? _T("%016x") : _T("%016X");
				return _stprintf(buf, szFmt, *(unsigned __int64*)data);

		}
		break;

	case HVS_FORMAT_DEC:
		return _stprintf(buf, _T("%03d"), data[0]);
	
	case HVS_FORMAT_OCT:
		return _stprintf(buf, _T("%03o"), data[0]);

	case HVS_FORMAT_BIN:
		return int_to_bin(buf, 1, data[0]);

	default:
		buf[0] = '\0';
		break;
	}

	return _tcslen(buf);
}

VOID HexView::InvalidateRange(size_w start, size_w finish)
{
	int m_nPageMaxLines = m_nWindowLines;

	size_w screenstartoffset = m_nVScrollPos * m_nBytesPerLine;
	size_w screenendoffset   = (m_nVScrollPos + m_nPageMaxLines + 1) * m_nBytesPerLine;

	// take into account any data shift
	start             += m_nDataShift;//Start;
	finish            += m_nDataShift;//Start;

	if(screenendoffset < screenstartoffset) 
		screenendoffset = -1;

	if(start > finish)
	{
		size_w t0 = start;
		start	  = finish;
		finish	  = t0;
	}

	//clip the offsets to within the visible view
	if(start  < screenstartoffset) 	start  = screenstartoffset;
	if(start  > screenendoffset)   	start  = screenendoffset;
	if(finish < screenstartoffset)	finish = screenstartoffset;
	if(finish > screenendoffset)  	finish = screenendoffset;

	size_w length = finish - start;
	int y = (int)(start / m_nBytesPerLine - m_nVScrollPos);

	//SendMessage(m_hWnd, WM_SETREDRAW, 0, 0);

	while(length != 0)
	{
		RECT   rect;
		int	x   = (int)(start % m_nBytesPerLine);
		int len = (int)min(m_nBytesPerLine - x, length);

		// hex column
		SetRect(&rect, LogToPhyXCoord(x, 0),
			           (y * m_nFontHeight),
					   LogToPhyXCoord(x+len, 0),
					   (y * m_nFontHeight + m_nFontHeight) );

		InvalidateRect(m_hWnd, &rect, FALSE);

		// ascii column
		SetRect(&rect, LogToPhyXCoord(x, 1),
					   (y * m_nFontHeight),
					   LogToPhyXCoord(x+len, 1),
					   (y * m_nFontHeight + m_nFontHeight) );
					   
		InvalidateRect(m_hWnd, &rect, FALSE);

		y++;
		start   = 0;
		length -= len;
	}

	//SendMessage(m_hWnd, WM_SETREDRAW, 1, 0);
}

void AddAttr(ATTR **attrListPtr, COLORREF fg, COLORREF bg, size_t count)
{
	ATTR *attrList = *attrListPtr;

	for(size_t i = 0; i < count; i++)
	{
		attrList[i].colFG = fg;
		attrList[i].colBG = bg;
	}

	(*attrListPtr) += count;
}
int fixthis = 0;
size_t HexView::FormatLine(
	BYTE *          data,		// the data to display
	size_t          length,		// length of data
	size_w          offset,		// address-offset (display only)
	TCHAR *         szBuf,		// text buffer to print into
	size_t          nBufLen,    // size of szBuf
	ATTR *          attrList,   // attribute-buffer (must be sizeof(szBuf))
	seqchar_info *  infobuf,    // seqchar info (must be sizeof(szBuf))
	bool            fIncSelection   // include the selection colors, if the data is selected
	)
{
	TCHAR *    ptr = szBuf;
	size_t     i;
	BOOKNODE * highlight;
	int        colidx = 0;
	ATTR     * attrPtr = attrList;


	//
	//	Format the offset as a hex/dec address
	//
	ptr += FormatAddress(offset, ptr, nBufLen);
	
	AddAttr(&attrPtr, GetHexColour(HVC_ADDRESS), GetHexColour(HVC_BACKGROUND), ptr - szBuf);

	highlight = FindBookmark(offset, offset+length);

	//
	//	Hex column
	//
	if(CheckStyle(HVS_HEX_INVISIBLE) == false)
	{
		// left padding
		for(i = 0; i < (size_t)m_nHexPaddingLeft; i++)
			*ptr++ = _T(' ');

		AddAttr(&attrPtr, GetHexColour(HVC_ADDRESS), GetHexColour(HVC_BACKGROUND), m_nHexPaddingLeft);

		for(i = 0; i < (int)length/* m_nBytesPerLine*/; i += m_nBytesPerColumn)
		{
			HEXCOL col1, col2;

			size_t len = FormatHexUnit(&data[i], ptr, 0);
			ptr += len;

			GetHighlightCol(offset+i, 0, highlight, &col1, &col2, 
				infobuf[i].buffer != 1 ? true : false,
				infobuf[i].userdata != 0 ? true : false,
				fIncSelection
				);

			if(i < fixthis)
			{
				col1.colBG = col2.colBG = GetHexColour(HVC_BACKGROUND);
				wmemset(ptr-len, ' ', len);
			}


			// add the colour information
			if(col1 != col2 || i == m_nBytesPerLine - 1 || (i+1) % (m_nBytesPerColumn) != 0)
			{
				AddAttr(&attrPtr, col1.colFG, col1.colBG, len);

				if(true || (i+1) % (m_nBytesPerColumn) == 0 && (i < length/*m_nBytesPerLine*/ - 1))
				{
					*ptr++ = ' ';
					AddAttr(&attrPtr, col2.colFG, col2.colBG, 1);
				}
			}
			else if(i < length - 1)
			{
				*ptr++ = ' ';
				AddAttr(&attrPtr, col1.colFG, col1.colBG, len+1);
			}
			else
			{
				AddAttr(&attrPtr, col1.colFG, col1.colBG, len);
			}
		}

		// dead space 
		if(i != m_nBytesPerLine)
		{
			size_t len = m_nHexWidth - (ptr - (szBuf+(m_nAddressWidth + m_nHexPaddingLeft)));
		
			for(i = 0; i < len; i++)
				*ptr++ = ' ';

			AddAttr(&attrPtr, GetHexColour(HVC_ASCII), GetHexColour(HVC_BACKGROUND), len);
		}
	}

	if(CheckStyle(HVS_ASCII_INVISIBLE) == false)
	{
		// right-side padding
		for(i = 0; i < (size_t)m_nHexPaddingRight; i++)
			*ptr++ = _T(' ');

		AddAttr(&attrPtr, GetHexColour(HVC_ASCII), GetHexColour(HVC_BACKGROUND), m_nHexPaddingRight);

		//
		//	Ascii column
		//
		for(i = 0; i < (int)length;/*m_nBytesPerLine*/ i++)
		{
			HEXCOL col1, col2;
			BYTE v = data[i];

			const int ctrlChar = '.';

			if(CheckStyle(HVS_ASCII_SHOWCTRLS) == 0 && (v < 32) )
			{
				*ptr++ = ctrlChar;
			}
			else if(CheckStyle(HVS_ASCII_SHOWEXTD) == 0 && (v >= 0x80 && v <= 0xa0) )
			{
				*ptr++ = ctrlChar;
			}
			else
			{
				*ptr++ = v;
			}

			//*ptr++ = (data[i] < 32) ? data[i] = '.' : (data[i] >;

			GetHighlightCol(offset+i, 1, highlight, &col1, &col2, 
				infobuf[i].buffer != 1 ? true : false,
				infobuf[i].userdata != 0 ? true : false,
				fIncSelection
				);

			if(i < fixthis)
			{
				col1.colBG = col2.colBG = GetHexColour(HVC_BACKGROUND);
				*(ptr-1) = ' ';
			}

			//if(col1.colBG == 0xffffff)
			//	col1.colBG = RGB(244,243,241);

			AddAttr(&attrPtr, col1.colFG, col1.colBG, 1);
		}

		if(i != m_nBytesPerLine)
		{
			size_t len = m_nBytesPerLine - i;

			for(i = 0; i < len; i++)
				*ptr++ = ' ';

			AddAttr(&attrPtr, GetHexColour(HVC_ASCII), GetHexColour(HVC_BACKGROUND), len);
		}


		*ptr = '\0';
	}

	return (ptr-szBuf);
}

size_t HexView::FormatData(HEXFMT_PARAMS *fmtParams)//size_w offset, int length, TCHAR *out, int outlen, ATTR *attrList)
{
	BYTE			*buf;
	seqchar_info	*infobuf;
	size_t			length = 0;

	if(fmtParams == 0 || fmtParams->length == 0)
		return 0;

	length  = fmtParams->length;
	buf		= new BYTE[length];
	infobuf = new seqchar_info[length];

	if(buf && infobuf)
	{
		//length = min(fmtParams->length, 100);
		length = m_pDataSeq->render(fmtParams->offset, buf, length, infobuf);
		length = FormatLine(buf, length, fmtParams->offset, fmtParams->szText, fmtParams->bufferSize, fmtParams->attrList, infobuf, false);
	}

	delete[] buf;
	delete[] infobuf;

	return length;
}

//
//	Draw the specified line of data
//
//	data - the data to render
//  datalen - expected to be no bigger than m_nBytesPerLine
//
int HexView::PaintLine(HDC hdc, size_w nLineNo, BYTE *data, size_t datalen, seqchar_info *infobuf)
{
	TCHAR	*buf;//[0x200];
	//BYTE	data[100];
	//seqchar_info infobuf[100];
	ATTR	*attrList;//[0x200];
	int		*advanceWidth;//[0x100];
	RECT	rect;
	RECT	clip;
	size_w	offset;
	size_t	i, len, lasti;	

	SelectObject(hdc, m_hFont);

	GetClientRect(m_hWnd, &rect);

	rect.left       = (long)(-m_nHScrollPos * m_nFontWidth);
	rect.top		= (long)((nLineNo - m_nVScrollPos) * m_nFontHeight);
	rect.right		= (long)(rect.right);
	rect.bottom		= (long)(rect.top + m_nFontHeight);

	CopyRect(&clip, &rect);

	// work out what data we want to draw
	// include the display-offset if we have shifted the
	// hex/ascii data by a certain amount
	offset	 = nLineNo * m_nBytesPerLine;// + m_nDataStart;

	// check we have data to draw on this line!
	if(offset - min(m_nDataShift, offset) >= m_pDataSeq->size())
	{
		SetTextColor(hdc, GetHexColour(HVC_BACKGROUND));
		SetBkColor(hdc,   GetHexColour(HVC_BACKGROUND));

		ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, 0, 0, 0);
		return 0;
	}

	SetTextAlign(hdc, TA_UPDATECP);
	MoveToEx(hdc, -(int)(m_nHScrollPos * m_nFontWidth), (int)(nLineNo - m_nVScrollPos) * m_nFontHeight, NULL);

	//
	//	Construct a text buffer and colour description buffer
	//
	buf				= new TCHAR[m_nTotalWidth+100];
	attrList		= new ATTR[m_nTotalWidth];
	advanceWidth	= new int[m_nTotalWidth];

	//
	offset -= m_nDataShift;
	len		 = FormatLine(data, datalen, offset, buf, m_nTotalWidth, attrList, infobuf, true);

	for(i = 0; i < len; i++)
		advanceWidth[i] = m_nFontWidth;

	// 
	//	Display the line of text, as a series of coloured spans of text 
	//
	for(i = 0, lasti = 0; i <= len; i++)
	{
		// detect changes in colour
		if( attrList[i].colFG != attrList[lasti].colFG  ||
			attrList[i].colBG != attrList[lasti].colBG ||
			i == len)
		{
			SetTextColor(hdc, attrList[lasti].colFG);
			SetBkColor(hdc,   attrList[lasti].colBG);

			// need clipping because of the ClearType 'bleed'
			clip.right = clip.left + (int)(i - lasti) * m_nFontWidth;

			// output an entire 'span' of text in a single colour
			ExtTextOut(hdc, 0, 0, ETO_OPAQUE|ETO_CLIPPED, &clip, buf + lasti, (UINT)(i - lasti), advanceWidth);
			clip.left = clip.right;

			lasti = i;
		}
	}

	//
	//	Dead space to right of ascii column
	//
	SetTextColor(hdc, GetHexColour(HVC_BACKGROUND));
	SetBkColor(hdc,   GetHexColour(HVC_BACKGROUND));

	POINT pt;

	MoveToEx(hdc, 0, 0, &pt);
//	SetRect(&rect, pt.x, pt.y, rect.right, pt.y + m_nFontHeight);
//	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, 0, 0, 0);

	delete[] buf;
	delete[] attrList;
	delete[] advanceWidth;

	return pt.x;
}

void DrawVLine(PPAINTSTRUCT pps, COLORREF col, int pos)
{
	RECT rc = pps->rcPaint;

	rc.left  = pos;
	rc.right = pos + 1;

	// paint a vertical line
	SetBkColor(pps->hdc, col);
	ExtTextOut(pps->hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

	// mask it so the regular painting logic doesn't overwrite it
	ExcludeClipRect(pps->hdc, rc.left, rc.top, rc.right, rc.bottom);
}

void HexView::IdentifySearchPatterns(BYTE *data, size_t len, seqchar_info *infobuf)
{
	size_t i;
	BYTE *ptr = data;

	if(m_nSearchLen == 0)
		return;

	while((ptr = (BYTE *)memchr(ptr, m_pSearchPat[0], len-(ptr-data))) != 0)
	{
		size_t slen = min(m_nSearchLen, len-(ptr-data));

		for(i = 1; i < slen; i++)
		{
			if(ptr[i] != m_pSearchPat[i])
				break;
		}

		if(i == m_nSearchLen)
		{
			for(i = 0; i < m_nSearchLen; i++)
				infobuf[i + (ptr - data)].userdata = 1;

			ptr += m_nSearchLen;
		}
		else
		{
			ptr += 1;
		}
	}
}

//
//	WM_PAINT message handler
//
LRESULT HexView::OnPaint()
{
	PAINTSTRUCT ps;

	size_w i, first, last;

	BeginPaint(m_hWnd, &ps);

	// figure out which lines to redraw
	first = m_nVScrollPos + ps.rcPaint.top / m_nFontHeight;
	last  = m_nVScrollPos + ps.rcPaint.bottom / m_nFontHeight;

	if(ps.rcPaint.bottom % m_nFontHeight)
		last++;

	if(last < first) last = -1;

	// paint the resize bar
	if(CheckStyle(HVS_RESIZEBAR))
	{
		int pos1 = (m_nAddressWidth - m_nHScrollPos) * m_nFontWidth + 
					(m_nHexPaddingLeft * m_nFontWidth) / 2;

		pos1 += m_nFontWidth/2;
		DrawVLine(&ps, GetHexColour(HVC_RESIZEBAR), pos1);
		DrawVLine(&ps, GetHexColour(HVC_RESIZEBAR), m_nResizeBarPos);
	}

	// work out what data we want to draw
	// include the display-offset if we have shifted the
	// hex/ascii data by a certain amount
	size_w offset = first * m_nBytesPerLine;// + m_nDataStart;
	size_t buflen = (size_t)(last - first + 1) * m_nBytesPerLine + m_nDataShift;

	BYTE *bigbuf;
	seqchar_info *bufinfo;

	if((bigbuf = new BYTE[buflen]) == 0)
		return 0;

	if((bufinfo = new seqchar_info[buflen]) == 0)
	{
		delete[] bigbuf;
		return 0;
	}
	
	int shift = 0;
	int shift2 = 0;
	if(m_nDataShift > offset)
	{
		shift = max(m_nDataShift, 0);//m_nDataStart % m_nBytesPerLine;
		memset(bigbuf, '?', shift);
	}
	else
	{
		shift2 = m_nDataShift;//abs(min(m_nDataShift, 0));
	}
	
	buflen = m_pDataSeq->render(offset - shift2, bigbuf + shift, buflen - shift, bufinfo + shift);
	buflen += shift;

	// identify any characters that match the current search-pattern
	IdentifySearchPatterns(bigbuf, buflen, bufinfo);

	RECT rect;
	GetClientRect(m_hWnd, &rect);
	rect.left = LogToPhyXCoord(m_nBytesPerLine, 1);

	//TRACEA("filling from %d\n", rect.left);

	// draw the display line-by-line
	for(i = first; i <= last; i++)
	{
		offset = (i - first) * m_nBytesPerLine;

		size_t len = (size_t)min(buflen - offset, m_nBytesPerLine);
		fixthis = (i == 0) ? m_nDataShift : 0;
		
		int width = PaintLine(ps.hdc, i, bigbuf + offset, len, bufinfo + offset);

		
		// draw the ghost item
		/*if(offset >= SelectionStart() && offset < SelectionStart() + m_nBytesPerLine && offset < SelectionEnd())
		{
			m_HighlightGhost.hp.start = SelectionStart();
			m_HighlightGhost.hp.length = SelectionSize();
			m_HighlightGhost.hp.colBG  = RGB(255,200,200);

			DrawNoteStrip(ps.hdc, width+BOOKMARK_XOFFSET, (i-m_nVScrollPos) * m_nFontHeight, 
				&m_HighlightGhost);
		}*/

		BOOKNODE * bnp;
		for(bnp = m_BookHead->next; bnp != m_BookTail; bnp = bnp->next)
		//for(j = 0; j < m_Highlight->nNumItems; j++)
		{
			BOOKMARK *bookmark = &bnp->bookmark;

			if(bookmark->pszText || bookmark->pszTitle)
			{
				if( bookmark->offset >= i*m_nBytesPerLine && 
					bookmark->offset < (i+1)*m_nBytesPerLine && 
					bookmark->offset < m_pDataSeq->size())
				{
					//ExcludeClipRect(ps.hdc, rect.left + 20,
					DrawNoteStrip(ps.hdc, width+BOOKMARK_XOFFSET, (int)(i-m_nVScrollPos) * m_nFontHeight, bnp);
				}
			}
		}
	}

	ExtTextOut(ps.hdc, 0, 0, ETO_OPAQUE, &rect, 0, 0, 0);

	EndPaint(m_hWnd, &ps);

	delete[] bigbuf;
	delete[] bufinfo;

	return 0;
}

HRGN ThemeEditBorder(HWND hwnd, HTHEME hTheme, HRGN hrgnUpdate)
{
	HDC hdc = GetWindowDC(hwnd);
	RECT rc;
	RECT rcWindow;
	DWORD state = ETS_NORMAL;
	HRGN hrgnClip;

	//TRACEA("ThemeEditBorder\n");
	
	if(!IsWindowEnabled(hwnd))
	{
		state = ETS_DISABLED;
	}
	else if(GetFocus() == hwnd)
	{
		state = ETS_NORMAL;//ETS_HOT;
	}
	else
	{
		state = ETS_NORMAL;
	}
	
	GetWindowRect(hwnd, &rcWindow);
	GetClientRect(hwnd, &rc);
	ClientToScreen(hwnd, (POINT *)&rc.left);
	ClientToScreen(hwnd, (POINT *)&rc.right);

	//TRACERECT(

	rc.right = rcWindow.right - (rc.left - rcWindow.left);
	rc.bottom = rcWindow.bottom - (rc.top - rcWindow.top);
	
	hrgnClip = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
	
	if(hrgnUpdate != (HRGN)1)
		CombineRgn(hrgnClip, hrgnClip, hrgnUpdate, RGN_AND);
	
	OffsetRect(&rc, -rcWindow.left, -rcWindow.top);
	
	ExcludeClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
	OffsetRect(&rcWindow, -rcWindow.left, -rcWindow.top);
	
	//if (IsThemeBackgroundPartiallyTransparent (hTheme, EP_EDITTEXT, state))
	//	DrawThemeParentBackground(m_hWnd, hdc, &rcWindow);
	
	DrawThemeBackground(hTheme, hdc, 
		6,//EP_EDITTEXT,//6,
		state,
		//EP_EDITTEXT, 
		//state, 
		//3,0,
		&rcWindow, NULL);
	
	ReleaseDC(hwnd, hdc);

	return hrgnClip;
}



LRESULT HexView::OnNcPaint(HRGN hrgnUpdate)
{
	HRGN	hrgnClip = hrgnUpdate;
	LRESULT res;

	if(m_hTheme != 0)
	{
		hrgnClip = ThemeEditBorder(m_hWnd, m_hTheme, hrgnUpdate);
	}

	res = DefWindowProc(m_hWnd, WM_NCPAINT, (WPARAM)hrgnClip, 0);	
	DeleteObject(hrgnClip);
	return res;
}


void HexView::RefreshWindow()
{
	InvalidateRect(m_hWnd, NULL, FALSE);
}
```

`HexView/HexViewDrawNote.cpp`:

```cpp
//
//  HexViewDrawNote.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include <trace.h>

#define SHADOW_DEPTH 2

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon2.ico */
BYTE HexData4[64] =
{
  0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 
  0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xfd, 0x00, 0x00, 
  0xff, 0xfb, 0x00, 0x00, 0xff, 0xf5, 0x00, 0x00, 0xff, 0xeb, 0x00, 0x00, 0xff, 0xd5, 0x00, 0x00, 
  0xff, 0xab, 0x00, 0x00, 0xff, 0x55, 0x00, 0x00, 0xfe, 0xab, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00
};

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon2.ico */
WORD HexData1[32] =
{
  0xffff,  0xffff, 0xffff, 0xffff, 
  0xffff,  0xffff, 0xffff, 0xfdff, 
  0xfbff,  0xf5ff, 0xebff, 0xd5ff, 
  0xabff,  0x55ff, 0xabfe, 0xffff, 
};

/* Generated by HexEdit */
/* C:\src\Hex\HexEdit\icon3.ico */
BYTE HexData2[] =
{
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff,  0xff, 0xff,  
  0xff, 0xff, 0xff, 0xff, 0xe7, 0x3f,  0xe2, 0x3f,  
  0xf0, 0x7f, 0xf8, 0xff, 0xf0, 0x7f,  0xe2, 0x3f,  
  0xe7, 0x3f, 0xff, 0xff, 0xff, 0xff,  0xff, 0xff
};

/* [x] close button with border */
WORD CloseButtonBitmapData[32] =
{
  0xffff, 0xffff, 0xffff, 0x0700,  
  0x0700, 0xe73f, 0x2727, 0x2722,  
  0x6730, 0xe738, 0x6730, 0x2722,  
  0x2727, 0xe73f, 0x0700, 0x0700
};


/* Generated by HexEdit */
/* C:\src\HexEdit2\HexEdit\ico00001.ico */
WORD CloseButtonDown[32] = 
{
  0xFFFF, 0xFFFF, 0xFFFF, 0x0700, 
  0x0700, 0x0700, 0xC718, 0xC71D, 
  0x870F, 0x0707, 0x870F, 0xC71D, 
  0xC718, 0x0700, 0x0700, 0x0700, 
};


/*
void RoundRect0(HDC hdc, int x1, int y1, int x2, int y2)
{
	MoveToEx(hdc, x1+1, y1, 0);
	LineTo(hdc, x2-1, y1);
	SetPixel(hdc, x1+1, y1+1, 0);

	MoveToEx(hdc, x2, y1+1, 0);
	LineTo(hdc, x2, y2-1);
	SetPixel(hdc, x2-1, y1+1, 0);

	MoveToEx(hdc, x2-1, y2, 0);
	LineTo(hdc, x1+1, y2);
	SetPixel(hdc, x2-1, y2-1, 0);

	MoveToEx(hdc, x1, y2-1, 0);
	LineTo(hdc, x1, y1+1);
	SetPixel(hdc, x1+1, y2-2, 0);
}
*/

void SizingGrip(HDC hdc, RECT *rect, HPEN hPen)
{
	const int grip_size = BOOKMARK_GRIPWIDTH;
	RECT r = { rect->right - 3 - grip_size, rect->bottom - 3 - grip_size, rect->right - 3, rect->bottom - 3 };
	//SetBkColor(hdc, 0);
	POINT pt1 = { rect->right - 4, rect->bottom - 3 };
	POINT pt2 = { rect->right - 3, rect->bottom - 4 };
	
	int x = rect->right - 3, y = rect->bottom - 3;
	//SelectObject(hdc, hPen);
	for(int i = 0; i < 4; i++)
	{
		MoveToEx(hdc, pt1.x, pt1.y, 0);
		LineTo(hdc, pt2.x+1, pt2.y-1 );

		pt1.x -= 2;
		pt2.y -= 2;
	}

}

void CloseButton(HDC hdc, RECT *rect, RECT *out, BOOL fHover)
{
	if(out)
	{
		out->left   = rect->right - 16;
		out->top    = rect->top + 4;
		out->right  = out->left + 13;
		out->bottom = out->top + 13;//16;
	}

	if(hdc)
	{
		BOOL fDown = fHover && (GetKeyState(VK_LBUTTON) & 0x80000000);

		HDC     hdcMem  = CreateCompatibleDC(hdc);
		HBITMAP hBmp = CreateBitmap(16, 16, 1, 1, fDown ? CloseButtonDown : CloseButtonBitmapData);
		HANDLE  hOld = SelectObject(hdcMem, hBmp);

		TRACEA("hot: %d\n", fHover);


		if(fDown)
		{
			SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
		}
		else if(fHover)
		{
			SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));
		}
		else
		{
			SetTextColor(hdc, GetSysColor(COLOR_3DSHADOW));
		}

		//SetBkColor(hdc, colBG);
		BitBlt(hdc, rect->right - 16, rect->top + 1, 13, 16, hdcMem, 0, 0, SRCCOPY);

		SelectObject(hdcMem, hOld);
		DeleteObject(hBmp);
		DeleteDC(hdcMem);
	}
}

void RoundRect(HDC hdc, RECT *rect, int cx, int cy, COLORREF fg, COLORREF bg)
{
	SetDCBrushColor(hdc, bg);
	SetDCPenColor(hdc, fg);
//	HBRUSH hBr = CreateSolidBrush(bg);
//	HPEN   hPn = CreatePen(0, PS_SOLID, fg);

//	HANDLE hOldBr  = SelectObject(hdc, hBr);
//	HANDLE hOldPen = SelectObject(hdc, hPn);

	RoundRect(hdc, rect->left, rect->top, rect->right, rect->bottom, cx, cy);

//	SelectObject(hdc, hOldBr);
//	SelectObject(hdc, hOldPen);
//	DeleteObject(hBr);
//	DeleteObject(hPn);
}

HRGN CreateRoundRectRgn(RECT *rect, int cx, int cy)
{
	return CreateRoundRectRgn(rect->left, rect->top, rect->right+1, rect->bottom+1, cx, cy);
}

	HFONT hFont1;
	HFONT hFont2;
	HFONT hFont3;

void Arse()
{
	hFont1 = CreateFont(-12,0,0,0,FW_BOLD,FALSE,0,0,0,0,0,0,0,_T("Tahoma"));
	hFont2 = CreateFont(-12,0,0,0,0,FALSE,0,0,0,0,0,0,0,_T("Tahoma"));
	hFont3 = CreateFont(-12,0,0,0,0,TRUE,0,0,0,0,0,0,0,_T("Tahoma"));

}

void HexView::DrawNoteStrip(HDC hdc, int nx, int ny, BOOKNODE *bnp)
{
	BOOKMARK *bookmark = &bnp->bookmark;

	RECT rect = { nx, ny, nx+300, ny+50 };
	RECT clip;
	const int colWidth = 18;

	HANDLE hOldBr  = SelectObject(hdc, GetStockObject(DC_BRUSH));
	HANDLE hOldPen = SelectObject(hdc, GetStockObject(DC_PEN));

	COLORREF colBG		= RGB(245,245,245);
	COLORREF colShadow	= RGB(220,220,220);//GetSysColor(COLOR_3DFACE);
	COLORREF colLine	= GetSysColor(COLOR_3DSHADOW);

	BookmarkRect(bookmark, &rect);

	//
	// [x] Close button 
	//
	//	Do this first so we can mask it out of the way; prevents flickering
	//
	CloseButton(hdc, &rect, &clip, m_HitTestHot == HVHT_BOOKCLOSE && m_HighlightHot == bnp);
	ExcludeClipRect(hdc, clip.left, clip.top, clip.right, clip.bottom);


	//
	// Main rectangle - dark border with light fill
	//
	RoundRect(hdc, &rect, 2, 2, colLine, colBG);

	// vertical separator line 
	MoveToEx(hdc, rect.left + colWidth, rect.top, 0);
	LineTo(hdc, rect.left + colWidth, rect.bottom);

	// color panel
	RECT colrc = { rect.left + 1, rect.top + 1, rect.left + colWidth, rect.bottom - 1 };
	SetBkColor(hdc, bookmark->backcol);
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &colrc, 0, 0, 0);

	RECT textrc = 
	{ 
		rect.left + colWidth + 8, rect.top + 4, rect.right - 4, rect.bottom - 4 
	};

	SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
	SetBkColor(hdc, colBG);
	SetTextAlign(hdc, TA_LEFT|TA_TOP);

	BOOL fItalic = FALSE;

	TCHAR *pszTitle = bookmark->pszTitle;
	TCHAR *pszText  = bookmark->pszText;

	if(pszTitle == 0 && pszText == 0)
	{
		fItalic	  = TRUE;
		pszTitle  = TEXT("Enter Bookmark");
		pszText   = TEXT("Descriptive text here");
	}
	
	HANDLE hOld;

	Arse();

	if(pszTitle)
	{
		// the text
		TCHAR text1[100];
		wsprintf(text1, _T("%08X - %d bytes"), bookmark->offset, bookmark->length);

		//hOld=SelectObject(hdc, hFont1);
		MoveToEx(hdc, textrc.left, textrc.top, 0);

		textrc.right -= 32;
		
		// draw the offset/length
		SetTextColor(hdc, GetSysColor(COLOR_3DDKSHADOW));
		hOld=SelectObject(hdc, hFont2);
		int height = DrawText(hdc, text1, lstrlen(text1), &textrc, DT_SINGLELINE|DT_RIGHT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);

		// draw the title, left-aligned
		SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
		hOld=SelectObject(hdc, fItalic?hFont3:hFont1);
		height = DrawText(hdc, pszTitle, lstrlen(pszTitle), &textrc, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);
		
		textrc.top += height;
	}

	if(pszText)
	{
		MoveToEx(hdc, textrc.left, textrc.top, 0);
		hOld = SelectObject(hdc, fItalic ? hFont3 : hFont2);
		DrawText(hdc, pszText, lstrlen(pszText), &textrc, DT_LEFT|DT_TOP|DT_NOPREFIX|DT_WORDBREAK|DT_MODIFYSTRING);//DT_NOCLIP|DT_LEFT|DT_WORDBREAK);
		SelectObject(hdc, hOld);
	}

	DeleteObject(hFont1);
	DeleteObject(hFont2);
	DeleteObject(hFont3);

	// sizing grip
	SizingGrip(hdc, &rect, 0);//, hPen);


	//
	//	Mask the rectangle
	//
/*	HRGN hClipRgn = CreateRoundRectRgn(&rect, 2, 2);
	ExtSelectClipRgn(hdc, hClipRgn, RGN_DIFF);

	//
	// Shadow goes underneath (offset by 2 pixels), so gets drawn first
	//
	OffsetRect(&rect, SHADOW_DEPTH, SHADOW_DEPTH);
	RoundRect(hdc, &rect, 2, 2, colShadow, colShadow);

	OffsetRgn(hClipRgn, SHADOW_DEPTH, SHADOW_DEPTH);
	ExtSelectClipRgn(hdc, hClipRgn, RGN_DIFF);
	DeleteObject(hClipRgn);*/

	//OffsetRect(&rect, -SHADOW_DEPTH, -SHADOW_DEPTH);


	// Include the shadow
	rect.right += SHADOW_DEPTH;
	rect.bottom += SHADOW_DEPTH;
	//RoundRect(hdc, smeg.left, smeg.top, smeg.right, smeg.bottom);
	ExcludeClipRect(hdc, rect.left, rect.top, rect.right, rect.bottom);

	SelectObject(hdc, hOldPen);
	SelectObject(hdc, hOldBr);

}


```

`HexView/HexViewFile.cpp`:

```cpp
//
//  HexViewFile.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#define STRICT
#define _WIN32_WINNT 0x501
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include "HexView.h"
#include "HexViewInternal.h"


BOOL HexView::OpenFile(LPCTSTR szFileName, UINT uOpenFlags)
{
	bool fReadonly  = (uOpenFlags & HVOF_READONLY) ? true : false;
	bool fQuickload = (uOpenFlags & HVOF_QUICKLOAD) ? true : false;
	bool fQuicksave = (uOpenFlags & HVOF_QUICKSAVE) ? true : false;

	// try to open as the caller requests us
	if(m_pDataSeq->open(szFileName, fReadonly, fQuickload))
	{
		TCHAR *fp;
		DWORD e = GetLastError();
		GetFullPathName(szFileName, MAX_PATH, m_szFilePath, &fp);

		RecalcPositions();

		SetCaretPos((m_nAddressWidth + m_nHexPaddingLeft) * m_nFontHeight, 0);

		UpdateMetrics();

		SetLastError(e);

		if(m_pDataSeq->isreadonly())
			m_nEditMode = HVMODE_READONLY;
		else
			m_nEditMode = HVMODE_OVERWRITE;

		m_nSearchLen = 0;
		return TRUE;
	}

	return FALSE;
}
BOOL HexView::InitBuf(const BYTE *buffer, size_t len, bool copybuf, bool readonly)
{
	if(m_pDataSeq->init(buffer, len, copybuf))
	{
		m_szFilePath[0] = '\0';
		
		m_nEditMode = readonly ? HVMODE_READONLY : HVMODE_OVERWRITE;

		RecalcPositions();
		SetCaretPos((m_nAddressWidth + m_nHexPaddingLeft) * m_nFontHeight, 0);
		UpdateMetrics();

		m_nSearchLen = 0;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL HexView::CloseFile()
{
	ClipboardShutdown();
	m_szFilePath[0]		= '\0';
	m_nSearchLen = 0;
	return TRUE;
}

BOOL HexView::SaveFile(LPCTSTR szFileName, UINT uMethod)
{
	// filename might be NULL, in which case we overwrite current file
	if(m_pDataSeq->save(szFileName))
	{
		if(szFileName)
		{
			TCHAR *fp;
			GetFullPathName(szFileName, MAX_PATH, m_szFilePath, &fp);
		}

		UpdateMetrics();
		m_nSearchLen = 0;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL HexView::ClearFile()
{
	if(m_pDataSeq)
	{
		m_pDataSeq->clear();
	}

	m_nVScrollPos		= 0;
	m_nHScrollPos		= 0;

	m_nSelectionStart	= 0;
	m_nSelectionEnd		= 0;
	m_nCursorOffset		= 0;
	m_nSearchLen		= 0;
	m_szFilePath[0]		= '\0';

	UpdateMetrics();

	return TRUE;
}

BOOL HexView::RevertFile()
{
	if(m_pDataSeq)
	{
		m_pDataSeq->clear();
	}

	m_nSearchLen = 0;

	if(m_szFilePath[0])
		return OpenFile(m_szFilePath, false);
	else
		return TRUE;
}

BOOL HexView::ImportFile(LPCTSTR szFileName, UINT uImportFlags)
{
	size_w len;

	bool fReadonly  = (uImportFlags & HVOF_READONLY) ? true : false;
	bool fQuickload = (uImportFlags & HVOF_QUICKLOAD) ? true : false;

	if(m_nEditMode == HVMODE_READONLY || m_pDataSeq == 0)
		return 0;

	m_nSelectionStart = m_nCursorOffset;

	if(m_nEditMode == HVMODE_OVERWRITE)
	{
		len = m_pDataSeq->replace_file(szFileName, m_nCursorOffset, fQuickload);
	}
	else if(m_nEditMode == HVMODE_INSERT)
	{
		len = m_pDataSeq->insert_file(szFileName, m_nCursorOffset, fQuickload);
	}

	m_nSelectionEnd = m_nCursorOffset + len;
	m_nCursorOffset = m_nCursorOffset + len;

	UpdateMetrics();
	ScrollToCaret();
	//SetCursor(

	return len ? TRUE : FALSE;
}

```

`HexView/HexViewFind.cpp`:

```cpp
//
//  HexViewFind.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

//
//	Borrowed from Michael Lecuyer's Java source 1998
//
//
#define _WIN32_WINNT 0x0500
#include <windows.h>
#include <tchar.h>
#include <trace.h>
#include "HexView.h"
#include "HexViewInternal.h"

#define MAX_PAT_LEN 256
#define MAX_CHAR	256

BYTE		pattern[MAX_PAT_LEN];
unsigned	skip[MAX_CHAR];
unsigned	d[MAX_CHAR];
unsigned	patpos;
unsigned	patlen;

BOOL HexView::FindInit(BYTE *pat, size_t length, BOOL searchback, BOOL matchcase)
{
	SearchCompile(pat, length);
	return TRUE;
}

bool HexView::SearchCompile(BYTE *pat, size_t length)
{
	unsigned j, k, t, t1, q, q1;
	unsigned f[MAX_PAT_LEN];
	
	patlen = (unsigned)length;
	
	if(patlen == 0 || patlen > MAX_PAT_LEN)
		return 0;
	
	memcpy(pattern, pat, patlen);
	
	for(k = 0; k < MAXCHAR; k++)
		skip[k] = patlen;
	
	for(k = 1; k <= patlen; k++)
	{
		d[k-1] = (patlen << 1) - k;
		skip[pattern[k-1]] = patlen - k;	
	}
	
	for(t = patlen + 1, j = patlen; j > 0; j--)
	{
		f[j-1] = t;
		
		while(t <= patlen && pattern[j-1] != pattern[t-1])
		{
			d[t-1] = min(d[t-1], patlen-j);
			t = f[t-1];
		}
		
		t--;
	}
	
	
	q = t;
	t = patlen + 1 - q;
	q1 = 1;
	t1 = 0;
	
	for(j = 1; j <= t; j++)
	{
		f[j-1] = t1;
		while (t1 >= 1 && pat[j-1] != pat[t1-1])
			t1 = f[t1-1];
		t1++;
	}
	
	while(q < patlen)
	{
		for(k = q1; k <= q; k++)
			d[k-1] = min(d[k-1], patlen + q - k);
		
		q1 = q + 1;
		q  = q + t - f[t-1];
		t  = f[t-1];
	}

	return TRUE;
}

int HexView::SearchBlock(BYTE *block, int start, int length, int *partial, bool matchcase /*=true*/)
{
	int		incr	 = 0;
	int		j		 = 0;
	int		blocklen = start + length;
	int		k;

	*partial = -1;

	for(k = start + patlen - 1; k < blocklen; )
	{
		if(matchcase)
		{
			// loop over pattern from right->left
			for(j = patlen - 1; j >= 0 && block[k] == pattern[j]; j--)
				k--;
		}
		else
		{
			// loop over pattern from right->left
			for(j = patlen - 1; j >= 0 && toupper(block[k]) == toupper(pattern[j]); j--)
				k--;
		}

		// found!
		if(j < 0)
		{
			//printf("found at %d\n", k+1);
			return k+1;
		}

		incr = max(skip[block[k]], d[j]);
		k += incr;
	}

	// if we're near end of buffer
	if(k >= blocklen && j > 0)
	{
		*partial = k - incr - 1;
		return -1;
	}
	
	return -1;
}

LRESULT HexView::QueryProgressNotify(UINT code, size_w pos, size_w len)
{
	NMHVPROGRESS nmhvp;

	nmhvp.hdr.code     = code;
	nmhvp.hdr.hwndFrom = m_hWnd;
	nmhvp.hdr.idFrom   = GetWindowLongPtr(m_hWnd, GWL_ID);
	
	nmhvp.len = len;
	nmhvp.pos = pos;

	return SendMessage(GetParent(m_hWnd), WM_NOTIFY, 0, (LPARAM)&nmhvp);
}

BOOL HexView::FindNext(size_w *result, UINT options)
{
	BYTE	block[1000];

	// are we searching just the selected area, or the entire file?
	bool	selScope  = (options & HVFF_SCOPE_SELECTION) ? true : false;
	size_w  searchidx = selScope ? SelectionStart() : m_nCursorOffset;
	size_w  searchlen = selScope ? SelectionSize() : m_pDataSeq->size();

	bool    matchCase = (options & HVFF_CASE_INSENSITIVE) ? false : true;

	int		len;
	int		querycount = 0;

	if(patlen == 0)
		return FALSE;

	// search the sequence a block at a time
	while((len = (int)m_pDataSeq->render(searchidx, block, 1000, 0)) > 0)
	{
		int pos = 0;
		int partial;

		if(selScope && (searchidx < SelectionStart() || searchidx >= SelectionEnd()))
		{
			break;
		}
		
		// Boyer-moore search each block
		while((pos = SearchBlock(block, pos, len - pos, &partial, matchCase)) >= 0)
		{
			if(pos >= 0)
			{
				// found a match!
				*result = searchidx + pos;
				return TRUE;
			}
		}

		// do we have a partial match?
		if(partial >= 0)
		{
			partial = -1;
		}

		// keep the user informed as to our progress, which gives
		// them the opportunity to cancel
		if(++querycount == 1024)// * 32)
		{
			if(QueryProgressNotify(HVN_PROGRESS, searchidx, searchlen))
			{
				//seterror(HVE_USER_ABORT);
				return FALSE;
			}

			querycount = 0;
		}

		searchidx += len;
	}

	return FALSE;
}

```

`HexView/HexViewHighlight.cpp`:

```cpp
//
//  HexViewHighlight.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

//
//
//
#include <windows.h>
#include <tchar.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

#if 0

int FindHighlight(size_w startoff, size_w endoff, HIGHLIGHT_LIST *m_Highlight);

bool __inline overlaps(size_w a1, size_w b1, size_w a2, size_w b2)
{
	return (a1 >= a2 && a1 < b2 || b1 >= a2 && b1 < b2 || a1 <= a2 && b1 > a2);
}

static int sortproc(const void *elem1, const void *elem2)
{
	HIGHLIGHT *r1 = (HIGHLIGHT *)elem1;
	HIGHLIGHT *r2 = (HIGHLIGHT *)elem2;

	if(r1->nRangeStart < r2->nRangeStart)
	{
		return -1;
	}
	else if(r1->nRangeStart > r2->nRangeStart)
	{
		return 1;
	}
	else
	{
		if(r1->nRangeEnd < r2->nRangeEnd)
			return -1;
		else if(r1->nRangeEnd > r2->nRangeEnd)
			return 1;
		else
			return 0;
	}
}

//
HIGHLIGHT * AddHighlightList(HIGHLIGHT_LIST *HighlightList, size_w startoff, size_w endoff, COLORREF foregnd, COLORREF backgnd)
{
	HIGHLIGHT *Highlight = &HighlightList->Highlight[HighlightList->nNumItems++];

	Highlight->nRangeStart		= min(startoff, endoff);
	Highlight->nRangeEnd		= max(startoff, endoff);
	Highlight->colFG			= foregnd;
	Highlight->colBG			= backgnd;
	Highlight->Stack			= 0;

	return Highlight;
}


HIGHLIGHT * HexView::AddHighlight2(HIGHLIGHT_PARAM *hp)//size_w nHighlightStart, size_w nHighlightEnd, COLORREF foregnd, COLORREF backgnd)
{
	size_w startoff = hp->start;//min(hp->start, nHighlightEnd);
	size_w endoff   = hp->length;//max(nHighlightStart, nHighlightEnd);
	
	int idx = FindHighlight(startoff, endoff, m_Highlight);

	HIGHLIGHT *Highlight = 0;

	if(idx < 0)
	{
		Highlight = AddHighlightList(m_Highlight, startoff, endoff, hp->colFG, hp->colBG);
		
		qsort(m_Highlight->Highlight, m_Highlight->nNumItems, sizeof(HIGHLIGHT), sortproc);
	}
	else
	{
		Highlight = &m_Highlight->Highlight[0];

		// loop over any highlight that the new one overlaps
		for(unsigned i = idx; i < m_Highlight->nNumItems && 
			overlaps(
				startoff, 
				endoff, 
				Highlight[i].nRangeStart, 
				Highlight[i].nRangeEnd
				)
			; i++)
		{
			startoff = min(startoff, Highlight[i].nRangeStart);
			endoff   = max(endoff,   Highlight[i].nRangeEnd);
		}

		// expand the "outer" highlight to encompass
		Highlight[idx].nRangeStart = startoff;
		Highlight[idx].nRangeEnd   = endoff;

		// remove any overlapped highlights
		memmove(Highlight+idx+1, Highlight+i, (m_Highlight->nNumItems - i) * sizeof(HIGHLIGHT));
		m_Highlight->nNumItems -= (i-idx-1);

		// update with new colour
		Highlight[idx].colFG = hp->colFG;
		Highlight[idx].colBG = hp->colBG;
	}

	return Highlight;
}
/*
int HexView::AddHighlight(size_w nHighlightStart, size_w nHighlightEnd, COLORREF foregnd, COLORREF backgnd)
{
	size_w startoff = min(nHighlightStart,nHighlightEnd);
	size_w endoff   = max(nHighlightStart,nHighlightEnd);
	
	int idx = FindHighlight(startoff, endoff, m_Highlight);

	if(idx < 0)
	{
		AddHighlightList(m_Highlight, startoff, endoff, foregnd, backgnd);
		
		qsort(m_Highlight->Highlight, m_Highlight->nNumItems, sizeof(HIGHLIGHT), sortproc);
	}
	else
	{
		HIGHLIGHT *Highlight=&m_Highlight->Highlight[0];

		// loop over any highlight that the new one overlaps
		for(unsigned i = idx; i < m_Highlight->nNumItems && 
			overlaps(
				startoff, 
				endoff, 
				Highlight[i].nRangeStart, 
				Highlight[i].nRangeEnd
				)
			; i++)
		{
			startoff = min(startoff, Highlight[i].nRangeStart);
			endoff   = max(endoff,   Highlight[i].nRangeEnd);
		}

		// expand the "outer" highlight to encompass
		Highlight[idx].nRangeStart = startoff;
		Highlight[idx].nRangeEnd   = endoff;

		// remove any overlapped highlights
		memmove(Highlight+idx+1, Highlight+i, (m_Highlight->nNumItems - i) * sizeof(HIGHLIGHT));
		m_Highlight->nNumItems -= (i-idx-1);

		// update with new colour
		Highlight[idx].TextCol.colFG = foregnd;
		Highlight[idx].TextCol.colBG = backgnd;
	}

	return 0;

}

*/

/*
int HexView::AddHighlight(size_w nHighlightStart, size_w nHighlightEnd, COLORREF foregnd, COLORREF backgnd)
{
	size_w startoff = min(nHighlightStart,nHighlightEnd);
	size_w endoff   = max(nHighlightStart,nHighlightEnd);
	
	int idx = FindHighlight(startoff, endoff, m_Highlight);

	// highlight doesn't intersect any others, so add it to main sorted list
	if(idx < 0)
	{
		AddHighlightList(m_Highlight, startoff, endoff, RGB(0,0,0), RGB(rand()%128+128,rand()%128+128,rand()%128+128));
		
		qsort(m_Highlight->Highlight, m_Highlight->nNumItems, sizeof(HIGHLIGHT), sortproc);
	}
	else if(idx >= 0)
	{
		// it does intersect!
		HIGHLIGHT *Highlight=&m_Highlight->Highlight[idx];
		
		size_w first = Highlight->nRangeStart;
		size_w last  = Highlight->nRangeEnd;
		
		if(Highlight->Stack == 0)
		{
			Highlight->Stack = (HIGHLIGHT_LIST*)malloc(0x1000);
			Highlight->Stack->nNumItems = 0;
			
			AddHighlightList(Highlight->Stack, Highlight->nRangeStart, Highlight->nRangeEnd, 
				Highlight->TextCol.colFG, Highlight->TextCol.colBG);
		} 
		
		// add the already existing highlights which intersect the new one
		for(unsigned i = 1; i+idx<m_Highlight->nNumItems && 
			overlaps(startoff, endoff, Highlight[i].nRangeStart, Highlight[i].nRangeEnd); 
			i++)
		{
			last = Highlight[i].nRangeEnd;
			
			if(Highlight[i].Stack)
			{
				for(unsigned j = 0; j < Highlight[i].Stack->nNumItems; j++)
				{
					AddHighlightList(Highlight->Stack, Highlight[i].Stack->Highlight[j].nRangeStart,
						Highlight[i].Stack->Highlight[j].nRangeEnd,
						Highlight[i].Stack->Highlight[j].TextCol.colFG,
						Highlight[i].Stack->Highlight[j].TextCol.colBG);
				}
				
				if(Highlight[i].Stack->nNumItems > 0)
				{
					free(Highlight[i].Stack);
					Highlight[i].Stack = 0;
				}
			}
			else
			{
				AddHighlightList(Highlight->Stack, Highlight[i].nRangeStart, 
					Highlight[i].nRangeEnd, Highlight[i].TextCol.colFG, Highlight[i].TextCol.colBG);
			}
			
		}
		
		// now remove them from the outer list
		memmove(Highlight+1, Highlight+i, (m_Highlight->nNumItems - (idx+i)) * sizeof(HIGHLIGHT));
		m_Highlight->nNumItems -= (i-idx-1);
		
		
		// expand the "outer" highlight to encompass
		Highlight->nRangeStart = min(first,  startoff);
		Highlight->nRangeEnd   = max(last,   endoff);
		
		// add the new highlight on top of all others
		AddHighlightList(Highlight->Stack, 
			startoff, endoff,
			RGB(0,0,0), RGB(rand()%128+128,rand()%128+128,rand()%128+128)
			);
	}

	return 0;
}*/

HIGHLIGHT_ITEM * FindHighlight(size_w startoff, size_w endoff, HIGHLIGHT_ITEM *HighlightList)
{
	HIGHLIGHT_ITEM *ptr = 0;

	for(ptr = HighlightList; ptr; ptr = ptr->sortedList)
	{
		//if(startoff >= ptr->hp.start && startoff < ptr->hp.start + ptr->hp.length)
		if(overlaps(startoff, endoff, ptr->hp.start, ptr->hp.start+ptr->hp.length))
		{
			return ptr;
		}
	}

	return ptr;
}

int FindHighlight(size_w startoff, size_w endoff, HIGHLIGHT_LIST *HighlightList)
{
	int m_nNumHighlights = HighlightList->nNumItems;
	HIGHLIGHT *Highlight = HighlightList->Highlight;

	int first = 0;
	int last  = m_nNumHighlights - 1;
	int i;

	// perform a "binary search" to find a highlight which intersects the
	// specified data range
	while(last >= first)
	{
		i = (last + first) / 2;

		if(overlaps(startoff, endoff, Highlight[i].nRangeStart, Highlight[i].nRangeEnd))
		{
			// found one...iterate backwards to make sure we have the first one
			while(i > 0 && overlaps(startoff, endoff, Highlight[i-1].nRangeStart, Highlight[i-1].nRangeEnd))
				i--;

			return i;
		}
		else if(startoff < Highlight[i].nRangeStart)
		{
			last = i-1;
		}
		else
		{
			first = i+1;	
		}
	}

	return -1;
}

extern "C" COLORREF MixRgb(COLORREF col1, COLORREF col2);

BOOL HexView::GetHighlightCol(size_w offset, int pane, HIGHLIGHT_ITEM *itemStart,  
							  HEXCOL *col1, HEXCOL *col2, 
							  bool fModified, bool fMatched, bool fIncSelection)
{
	//int idx = -1;
	//int m_nNumHighlights = m_Highlight->nNumItems;
	//HIGHLIGHT *Highlight = m_Highlight->Highlight;

	HIGHLIGHT_ITEM *hi = itemStart;

	size_w selstart = min(m_nSelectionStart, m_nSelectionEnd);
	size_w selend   = max(m_nSelectionStart, m_nSelectionEnd);

	int nSchemeIdxFG;
	int nSchemeIdxBG;

	BOOL fGotFocus = GetFocus() == m_hWnd ? TRUE : FALSE;
	fGotFocus = GetAncestor(GetForegroundWindow(), GA_ROOTOWNER) == GetParent(m_hWnd);
	
	fGotFocus = fGotFocus && IsWindowEnabled(GetParent(m_hWnd));

	//TRACEA("FG = %x (me=%x)\n", GetForegroundWindow(), m_hWnd);

	if(pane == 0)
	{
		nSchemeIdxFG = ((offset % m_nBytesPerLine) / m_nBytesPerColumn) & 1 ? HVC_HEXEVEN : HVC_HEXODD;
		nSchemeIdxBG = HVC_BACKGROUND;
	}
	else
	{
		nSchemeIdxFG = HVC_ASCII;
		nSchemeIdxBG = HVC_BACKGROUND;
	}

	// modified bytes override normal settings
	if(fModified)
		nSchemeIdxFG = HVC_MODIFY;

	if(fMatched)
	{
		//nSchemeIdxFG = HVC_BACKGROUND;
		nSchemeIdxBG = HVC_MATCHED;
	}

	// search forward to find the highlight under specified offset
	for(hi = itemStart; hi; hi = hi->sortedList)
	{
		if(offset >= hi->hp.start && 
			offset < hi->hp.start + hi->hp.length)
		{
			break;
		}
	}
/*

	// search forward to find the highlight under specified offset
	for(int i = highidx; i < m_nNumHighlights && i != -1; i++)
	{
		// find the nearest highlight 
		if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd)
		{
			idx = i;
			//break;
		}
	}*/

	// matched a highlight...check if its a stack of highlights
	if(hi)//idx != -1)
	{
		// if this is a stack of highlights, iterate down through the stack looking
		// for a highlight which overlaps
	/*	while(Highlight[idx].Stack != 0)
		{
			m_nNumHighlights = Highlight[idx].Stack->nNumItems;
			Highlight = Highlight[idx].Stack->Highlight;

			for(int i = m_nNumHighlights-1; i >= 0; i--)
			{
				if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd)
				{
					idx = i;
					break;
				}
			}
		}*/
	}

	// found a highlight? set the colour
	if(hi && 
		offset >= hi->hp.start && 
		offset < hi->hp.start + hi->hp.length)// >= 0)
	{
		//col1->colFG = Highlight[idx].colFG;
		//col1->colBG = Highlight[idx].colBG;


		col1->colFG = hi->hp.colFG;
		col1->colBG = hi->hp.colBG;

		//col1->colFG = RGB(255,255,255);
		//col1->colBG = RGB(128,128,128);

		*col2 = *col1;

		if(fModified)
		{
			col1->colFG = GetHexColour(HVC_MODIFY);
			col2->colFG = GetHexColour(HVC_MODIFY);
		}
	}
	// no highlight, use the default window scheme
	else
	{
		col1->colFG = GetHexColour(nSchemeIdxFG);
		col1->colBG = GetHexColour(nSchemeIdxBG);
		*col2 = *col1;
	}

	// if at the end of the highlight, need to paint in two colours
	//if(idx != -1 && offset == Highlight[idx].nRangeEnd - 1)
	if(hi && offset == hi->hp.start + hi->hp.length - 1)
	{
		/*int idx2 = -1;

		// search backwards again
		for(int i = idx - 1; i >= 0; i--)
		{
			if(offset >= Highlight[i].nRangeStart && offset < Highlight[i].nRangeEnd - 1)
			{
				idx2 = i;
				break;
			}
		}

		if(idx2 != -1)
		{
			col2->colFG = Highlight[idx2].colFG;
			col2->colBG = Highlight[idx2].colBG;
		}
		else
		{
			col2->colBG = GetHexColour(nSchemeIdxBG);
		}*/
	}

	// selected data overrides everything else!
	if(fIncSelection && offset >= selstart && offset < selend)
	{
		// selected colour is next sequential index
		if(fGotFocus)
		nSchemeIdxFG++;

		//nSchemeIdxFG = nSchemeIdxBG;
		//nSchemeIdxBG++;
		//nSchemeIdxFG++;
		//nSchemeIdxBG++;


		if(nSchemeIdxBG == HVC_MATCHED)
			nSchemeIdxFG = HVC_MATCHEDSEL;

		//nSchemeIdxBG = HVC_SELECTION;

		if(pane != m_nWhichPane)
		{
			//if(nSchemeIdxBG == HVC_BACKGROUND)
				nSchemeIdxBG = HVC_SELECTION;
		//	nSchemeIdxFG++;
		//	nSchemeIdxBG++;
		}
		else
		{
			//if(nSchemeIdxBG == HVC_BACKGROUND)
				nSchemeIdxBG = HVC_SELECTION;

		}
		
		if(!fGotFocus)
		{
			nSchemeIdxBG = HVC_SELECTION3;
			//nSchemeIdxFG = HVC_SELECTION4;
		}


		if(CheckStyle(HVS_INVERTSELECTION))
		{
			col1->colBG = 0xffffff & ~col1->colBG;
			col1->colFG = 0xffffff & ~col1->colFG;
		}
		else
		{
			//col1->colFG = MixRgb(GetHexColour(HVC_SELECTION), GetHexColour(nSchemeIdxFG));
			//col1->colBG = MixRgb(GetHexColour(HVC_SELECTION), GetHexColour(nSchemeIdxBG));

			//if(!fModified)
			col1->colFG = !hi || fModified ? GetHexColour(nSchemeIdxFG) :col2->colBG;
			col1->colBG = GetHexColour(nSchemeIdxBG);
			
			
			//col1->colFG = GetHexColour((idx == -1) ? nSchemeIdxFG : HVC_BOOKSEL);
			//col1->colBG = idx == -1 ? col1->colBG : 0xffffff & ~col1->colFG;
		}


#ifdef SELECTION_USES_HIGHLIGHT
		if(m_fHighlighting)
		{
			col1->colFG = 0xffffff & ~GetHexColour(HVC_BOOKMARK_FG);
			col1->colBG = 0xffffff & ~GetHexColour(HVC_BOOKMARK_BG);
		}
#endif

		if(offset < selend - 1 && selend > 0)
			*col2 = *col1;
	} 

	if((offset + 1) % (m_nBytesPerLine) == 0 && offset != 0)
	{
		col2->colFG = col1->colFG;
		col2->colBG = GetHexColour(HVC_BACKGROUND);
	}

	return TRUE;
}

/*LONG HexView::Highlight(BOOL fEnable)
{
	m_fHighlighting = fEnable ? true : false;
	return 0;
}*/

BOOL HexView::AddHighlight(HIGHLIGHT_PARAM *hp)
{
	HIGHLIGHT_ITEM *hi = new HIGHLIGHT_ITEM;
	HIGHLIGHT_ITEM *ptr, *next;

	if(m_HighlightOrderList == 0)
	{
		m_HighlightOrderList  = hi;
	}
	else
	{
		// add to end of list
		for(ptr = m_HighlightOrderList; ptr->orderList; ptr = ptr->orderList)
			;

		ptr->orderList = hi;
	}

	// add to the sorted list, so we can search for highlights
	// based on starting index
	for(ptr = m_HighlightSortedList; ptr; ptr = next)
	{
		next = ptr->sortedList;
		if(next == 0)
		{
			ptr->sortedList = hi;
		}
		else if(hp->start < next->hp.start)
		{
			hi->sortedList = next;
			ptr->sortedList = hi;
			//hi->sortedList = ptr;
			break;
		}
	}

	if(m_HighlightSortedList == 0)
		m_HighlightSortedList = hi;

	hi->hp			 = *hp;
	hi->hp.pszText  = _tcsdup(hp->pszText);
	hi->hp.pszTitle = _tcsdup(hp->pszTitle);

	//HIGHLIGHT *h = AddHighlight2(hp);//hp->start, hp->start+hp->length, hp->colFG, hp->colBG);

	return TRUE;
}

BOOL HexView::DelHighlight(int idx)
{
	HIGHLIGHT_ITEM *ptr, *prev = 0;
	HIGHLIGHT_ITEM *delthis = 0;
	int i = 0;

	for(ptr = m_HighlightOrderList; ptr; ptr = ptr->orderList)
	{
		if(i++ == idx)
		{
			if(prev == 0)
				m_HighlightOrderList = ptr->orderList;
			else
				prev->orderList = ptr->orderList;				

			delthis = ptr;

			break;
		}

		prev = ptr;
	}

	for(i = 0, prev = 0, ptr = m_HighlightSortedList; ptr; ptr = ptr->sortedList)
	{
		if(ptr == delthis)
		{
			if(prev == 0)
				m_HighlightSortedList = ptr->sortedList;
			else
				prev->sortedList = ptr->sortedList;				

			break;
		}

		prev = ptr;
	}

	delete delthis;

	return TRUE;
}

/*BOOL HexView::ClearHighlights()
{
	m_Highlight->nNumItems = 0;
	return TRUE;
}*/

BOOL HexView::SetHighlight(int idx, HIGHLIGHT_PARAM *param)
{
	HIGHLIGHT_ITEM *hip;
	int i = 0;
	
	for(hip = m_HighlightOrderList; hip; hip = hip->orderList)
	{
		if(i++ == idx)
		{
			if(param->start != hip->hp.start || param->length != hip->hp.length)
			{
				InvalidateRange(hip->hp.start, hip->hp.start + hip->hp.length);
				InvalidateRange(param->start, param->start + param->length);
			}

			hip->hp			 = *param;
			hip->hp.pszText  = _tcsdup(param->pszText);
			hip->hp.pszTitle = _tcsdup(param->pszTitle);
			return TRUE;
		}
	}

	return FALSE;
}
	
BOOL HexView::GetHighlight(int idx, HIGHLIGHT_PARAM *param)
{
	HIGHLIGHT_ITEM *hip;
	int i = 0;
	
	for(hip = m_HighlightOrderList; hip; hip = hip->orderList)
	{
		if(i++ == idx)
		{
			*param = hip->hp;
			return TRUE;
		}
	}

/*	for(int i = 0; i < m_Highlight->nNumItems; i++)
	{
		if(i == idx)
		{
			param->start	= m_Highlight->Highlight[i].nRangeStart;
			param->length	= m_Highlight->Highlight[i].nRangeEnd - param->start;
			param->colFG	= m_Highlight->Highlight[i].colFG;
			param->colBG	= m_Highlight->Highlight[i].colBG;

			return TRUE;
		}
	}*/

	return FALSE;
}

BOOL HexView::HighlightRect(HIGHLIGHT_PARAM *hp, RECT *rect)
{
	size_w windowstart = m_nVScrollPos * m_nBytesPerLine;

	if(hp->start >= windowstart && hp->start + hp->length < windowstart + m_nWindowLines*m_nBytesPerLine)
	{
		rect->top	 = (hp->start / m_nBytesPerLine - m_nVScrollPos) * m_nFontHeight;
		rect->bottom = rect->top + 50;
		rect->left	 = m_nWindowColumns * m_nFontWidth + BOOKMARK_XOFFSET - m_nHScrollPos * m_nFontWidth;
		rect->right  = rect->left + 300;

		HDC hdc = GetDC(0);
				
		DrawText(hdc, hp->pszText, lstrlen(hp->pszText), rect, DT_EDITCONTROL|DT_CALCRECT);

		ReleaseDC(0, hdc);
		
		rect->right = rect->left + 300;
		rect->bottom += 20;

		
		return TRUE;
	}

	return FALSE;
}

#endif

```

`HexView/HexViewInternal.h`:

```h
//
//  HexViewInternal.h
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#ifndef HEXVIEW_INTERNAL_INCLUDED
#define HEXVIEW_INTERNAL_INCLUDED
#include "sequence.h"
#undef HEXVIEW_64
//#define HEXVIEW_64

#ifdef HEXVIEW_64
//typedef UINT64 size_w;
//#define SIZEW_BITS 64
#pragma warning(disable : 4244)
#else
//typedef UINT32 size_w;
//#define SIZEW_BITS 32
#endif

#include <uxtheme.h>

#include "HexView.h"

#define HV_MAX_COLS 64

//typedef sequence<BYTE> byte_seq;

struct _HIGHLIGHT_LIST;

// hex-hittest regions
#define HVHT_NONE		0x00
#define HVHT_MAIN		0x01
//#define HVHT_ADDRESS	(HVHT_MAIN | 0x02)
//#define HVHT_HEXCOL		(HVHT_MAIN | 0x04)
//#define HVHT_ASCCOL		(HVHT_MAIN | 0x08)
#define HVHT_SELECTION	0x02
#define HVHT_RESIZE		0x10
#define HVHT_RESIZE0    (0x20 | HVHT_RESIZE)
#define HVHT_BOOKMARK	0x100
#define HVHT_BOOKCLOSE	(HVHT_BOOKMARK | 0x200)
#define HVHT_BOOKSIZE	(HVHT_BOOKMARK | 0x400)
#define HVHT_BOOKGRIP	(HVHT_BOOKMARK | 0x800)
#define HVHT_BOOKEDIT	(HVHT_BOOKMARK | 0x1000)
#define HVHT_BOOKEDIT1	(HVHT_BOOKEDIT | 0x2000)
#define HVHT_BOOKEDIT2	(HVHT_BOOKEDIT | 0x4000)
#define HVHT_BOOKEDIT3	(HVHT_BOOKEDIT | 0x8000)


#define BOOKMARK_XOFFSET 30
#define BOOKMARK_GRIPWIDTH 10

class HexView;
class HexSnapShot;

typedef struct _BOOKNODE
{
	_BOOKNODE() : prev(0), next(0)
	{
		memset(&bookmark, 0, sizeof(bookmark));
	}
	
	BOOKMARK bookmark;
	_BOOKNODE *prev;
	_BOOKNODE *next;

} BOOKNODE;


enum SELMODE { SEL_NONE, SEL_NORMAL, SEL_MARGIN, SEL_DRAGDROP };

// HexEdit private clipboard formats
#define CFSTR_HEX_DATALEN		_T("HexDataLength")
#define CFSTR_HEX_HWND			_T("HexHWND")
#define CFSTR_HEX_SNAPSHOTPTR	_T("HexSnapshotPtr")
//#define CF_PRI_RLE32 _T("RLE32HexBinary")

//
//	Define our custom HexView class. Inherit from the IDropTarget interface
//	to enable this window to become an OLE drop-target
//
class HexView : public IDropTarget
{
	friend class HexSnapShot;

public:
	HexView(HWND hwnd);//, byte_seq *seq);
	~HexView();

	LRESULT WndProc(UINT msg, WPARAM wParam, LPARAM lParam);



	//
	//	IDropTarget Interface
	//
	STDMETHODIMP QueryInterface (REFIID iid, void ** ppvObject);
    STDMETHODIMP_(ULONG) AddRef (void);
    STDMETHODIMP_(ULONG) Release (void);

    // IDropTarget implementation
    STDMETHODIMP DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);

	BOOL SetCurSel(size_w selStart, size_w selEnd);

	//
	//	
	//
	LRESULT OnPaint();
	LRESULT OnNcPaint(HRGN hrgnUpdate);
	LRESULT OnSetFont(HFONT hFont);
	UINT HitTest(int x, int y, RECT *phirc = 0, BOOKNODE **pbn = 0);
	LRESULT OnRButtonDown(UINT nFlags, int x, int y);
	LRESULT OnLButtonDown(UINT nFlags, int x, int y);
	LRESULT OnLButtonDblClick(UINT nFlags, int x, int y);
	LRESULT OnLButtonUp(UINT nFlags, int x, int y);
	LRESULT OnContextMenu(HWND hwndParam, int x, int y);
	LRESULT OnMouseMove(UINT nFlags, int x, int y);
	LRESULT OnMouseWheel(int nDelta);
	LRESULT OnMouseActivate(HWND hwndTop, UINT nHitTest, UINT nMessage);
	LRESULT OnTimer(UINT_PTR Id);
	LRESULT OnSetFocus();
	LRESULT OnKillFocus();
	LRESULT OnSetCursor(WPARAM wParam, LPARAM lParam);
	LRESULT OnSize(UINT nFlags, int width, int height);
	LRESULT OnKeyDown(UINT nVirtualKey, UINT nRepeatCount, UINT nFlags);
	LRESULT OnChar(UINT nChar);

	LRESULT OnSetCurPos(size_w pos);
	LRESULT OnSetSelStart(size_w pos);
	LRESULT OnSetSelEnd(size_w pos);
	LRESULT OnSelectAll();

	BOOL OnCopy();
	BOOL OnCut();
	BOOL OnPaste();
	BOOL OnClear();

	BOOL FindInit(BYTE *pattern, size_t length, BOOL searchback, BOOL matchcase);
	BOOL FindNext(size_w *result, UINT options);

	// internal
	int		SearchBlock(BYTE *block, int start, int length, int *partial, bool matchcase = true);
	bool	SearchCompile(BYTE *pat, size_t length);
	LRESULT QueryProgressNotify(UINT code, size_w pos, size_w len);



	LRESULT NotifyParent(UINT nNotifyCode, NMHDR *optional = 0);
	VOID FakeSize();

	LRESULT OnHScroll(UINT nSBCode, UINT nPos);
	LRESULT OnVScroll(UINT nSBCode, UINT nPos);

	VOID OnLengthChange(size_w nNewLength);

	HMENU SetContextMenu(HMENU hMenu);
	VOID Scroll(int dx, int dy);
	HRGN ScrollRgn(int dx, int dy, bool fReturnUpdateRgn);
	VOID SetupScrollbars();
	VOID RecalcPositions();
	VOID UpdateResizeBarPos();
	VOID UpdateMetrics();

	HMENU CreateContextMenu();

	int  GetLogicalX(int nScreenX, int *pane, int *subitem = 0);
	int  GetLogicalY(int nScreenY);
	void PositionCaret(int x, int y, int pane);
	int  LogToPhyXCoord(int x, int pane);
	void CaretPosFromOffset(size_w offset, int *x, int *y);

	size_w OffsetFromPhysCoord(int x, int y, int *pane = 0, int *lx = 0, int *ly = 0, int *subitem = 0);
	void   RepositionCaret();
	VOID   ScrollToCaret();
	BOOL   ScrollTo(size_w offset);
	BOOL   ScrollTop(size_w offset);
	bool   PinToBottomCorner();
	void   PinToOffset(size_w offset);
	void   UpdatePinnedOffset();

	bool   Undo();
	bool   Redo();
	bool   CanUndo();
	bool   CanRedo();
	//
	//
	//
	VOID	InvalidateRange(size_w start, size_w finish);
	void	RefreshWindow();
	int		PaintLine(HDC hdc, size_w nLineNo, BYTE *data, size_t datalen, seqchar_info *bufinfo);
	size_t	FormatAddress(size_w addr, TCHAR *buf, size_t buflen);
	size_t	FormatHexUnit(BYTE *data, TCHAR *buf, size_t buflen);
	size_t	FormatLine(BYTE *data, size_t length, size_w offset, TCHAR *buf, size_t buflen, ATTR *attrList, seqchar_info *infobuf, bool fIncSelection);

	size_t	FormatData(HEXFMT_PARAMS *fmtParams);


	VOID IdentifySearchPatterns(BYTE *data, size_t len, seqchar_info *infobuf);
	
	LONG Highlight(BOOL fEnable);

	BOOL GetHighlightCol(size_w offset, int pane, BOOKNODE * itemStart, HEXCOL *col1, HEXCOL *col2, bool fModified, bool fMatched, bool fIncSelection = true);

	BOOKNODE * AddBookmark(BOOKMARK * bookm);
	BOOL DelBookmark(BOOKNODE *);
	BOOL BookmarkRect(BOOKMARK *bm, RECT *rect);
	BOOL	   GetBookmark(BOOKNODE *, BOOKMARK *param);
	BOOKNODE * EnumBookmark(BOOKNODE *, BOOKMARK *param);
	BOOL SetBookmark(BOOKNODE *, BOOKMARK *param);
	BOOL ClearBookmarks();
	BOOKNODE * FindBookmark(size_w startoff, size_w endoff);
	void DrawNoteStrip(HDC hdc, int nx, int ny, BOOKNODE *pbn);

	static LRESULT CALLBACK EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
	WNDPROC m_oldEditProc;

	BOOL EditBookmark(BOOKNODE *pbn, RECT *rect, bool fTitle);
	BOOL ExitBookmark();

	BOOL	 SetHexColour(UINT uIndex, COLORREF col);
	COLORREF GetHexColour(UINT uIndex);
	COLORREF RealiseColour(COLORREF cr);

	bool	CheckStyle(UINT uStyleFlag);
	UINT	SetStyle(UINT uMask, UINT uStyles);
	UINT	GetStyle(UINT uMask);
	UINT	GetStyleMask(UINT uStyleFlag);
	UINT	SetGrouping(UINT nBytes);
	UINT	GetGrouping();
	UINT	GetLineLen();
	UINT	SetLineLen(UINT nLineLen);
	BOOL	SetPadding(int left, int right);

	size_w  NumFileLines(size_w length);
	bool	IsOverResizeBar(int x);
	int		UnitWidth();

	size_w  SelectionSize();
	size_w  SelectionStart();
	size_w  SelectionEnd();
	size_w	Size();

	size_w EnterData(BYTE *pDest, size_w nLength, bool fAdvanceCaret, bool fReplaceSelection, bool fSelectData, HexSnapShot *hss = 0);
	ULONG SetData(size_w offset, BYTE *buf, ULONG nLength);
	ULONG GetData(size_w offset, BYTE *pBuf, ULONG nLength);
	ULONG FillData(BYTE *buf, ULONG buflen, size_w len);

	bool ForwardDelete();
	bool BackDelete();

	bool AllowChange(size_w offset, size_w length, UINT method, BYTE *data = 0, UINT mask = 0);
	void ContentChanged(size_w offset, size_w length, UINT method);
	//size_w nStartOffset, size_w nLength

	BOOL OpenFile(LPCTSTR szFileName, UINT uMethod);
	BOOL SaveFile(LPCTSTR szFileName, UINT uMethod);
	BOOL ImportFile(LPCTSTR szFileName, UINT uMethod);
	BOOL InitBuf(const BYTE *pBuffer, size_t nLength, bool copybuf, bool readonly);
	BOOL CloseFile();
	BOOL ClearFile();
	BOOL RevertFile();

	BOOL SetRedraw(BOOL fRedraw);


private:

	//
	//	private helper functions
	//
	DWORD	DropEffect(DWORD grfKeyState, POINTL pt, DWORD dwAllowed);
	bool	QueryDataObject(IDataObject *pDataObject);
	void	RegisterDropWindow();
	void	UnregisterDropWindow();
	bool	DropData(IDataObject *pDataObject, bool fReplaceSelection, bool fSelectData);
	void	StartDrag();
	bool	CreateDataObject (size_w offset, size_w length, IDataObject **ppDataObject);
	HGLOBAL BuildHGlobal(size_w offset, size_w length);
	HexSnapShot *CreateSnapshot(size_w offset, size_w length);
	VOID	ClipboardShutdown();
	int		CalcTotalWidth();
	BOOL	SetFontSpacing(int x, int y);

	
	HWND		m_hWnd;
	HWND		m_hwndEdit;
	HTHEME		m_hTheme;


	TCHAR		m_szFilePath[MAX_PATH];

	//byte_seq *m_sequence;

	sequence	*m_pDataSeq;

	UINT	m_nControlStyles;

	// cursor
	size_w  m_nCursorOffset;
	int		m_nCaretX;
	int		m_nCaretY;
	int		m_nWhichPane;
	size_w  m_nAddressOffset;

	int     m_nDataShift;			// range from 0 to (m_nBytesPerLine-1)
	size_w  m_nLastEditOffset;
	bool	m_fCursorMoved;
	//bool	

	size_w  m_nSelectionStart;
	size_w  m_nSelectionEnd;


	// Font specific
	HFONT	m_hFont;
	int		m_nFontHeight;
	int		m_nFontWidth;


	// View dimensions
	int		m_nWindowLines;
	int		m_nWindowColumns;
	int		m_nBytesPerLine;
	int		m_nBytesPerColumn;

	// Scrollbar dimensions
	size_w	m_nVScrollPos;
	size_w  m_nVScrollMax;
	int		m_nHScrollPos;
	int		m_nHScrollMax;

	size_w  m_nVScrollPinned;

	// Drag+Drop support
	long   m_lRefCount;
    bool   m_fAllowDrop;
	bool   m_fStartDrag;
	bool   m_fDigDragDrop;


	// 
	int		m_nAddressWidth;
	int		m_nHexWidth;
	int		m_nAddressDigits;
	int		m_nHexPaddingLeft;
	int		m_nHexPaddingRight;
	int		m_nTotalWidth;
	int		m_nResizeBarPos;

	BOOKNODE * m_BookHead;
	BOOKNODE * m_BookTail;

	// hexview base colours
	COLORREF m_ColourList[HV_MAX_COLS];

	//
	// runtime flags
	//
	//BOOL	m_fMouseDown;
	bool		m_fRedrawChanges;
	SELMODE		m_nSelectionMode;
	UINT_PTR	m_nScrollTimer;
	LONG		m_nScrollCounter;
	LONG		m_nScrollMouseRemainder;
	BOOL		m_fCursorAdjustment;
	bool		m_fResizeBar;
	bool		m_fResizeAddr;
	UINT		m_nEditMode;
	int			m_nSubItem;
	HMENU		m_hUserMenu;
	
	BOOKNODE	*m_HighlightCurrent;
	UINT		m_HitTestCurrent;
	BOOKNODE	*m_HighlightHot;
	UINT		m_HitTestHot;
	BOOKNODE	m_HighlightGhost;

	IDataObject * m_pLastDataObject;

	BYTE	m_pSearchPat[64];
	ULONG	m_nSearchLen;

};	

class HexSnapShot : public IUnknown
{
	friend class HexView;

public:
	HexSnapShot(HexView *hvp)
	{
		m_lRefCount = 1;
		m_pHexView  = hvp;
	}

	~HexSnapShot()
	{
		delete[] m_desclist;
	}


    HRESULT __stdcall QueryInterface(REFIID iid, void ** ppvObject)
	{
		if(iid == IID_IUnknown)
		{
			AddRef();
			*ppvObject = this;
			return S_OK;
		}
		else
		{
			return E_NOINTERFACE;
		}
	}

    ULONG __stdcall AddRef(void)
	{
		return InterlockedIncrement(&m_lRefCount);
	}

    ULONG __stdcall Release(void)
	{
		LONG count = InterlockedDecrement(&m_lRefCount);
		
		if(count == 0)
			delete this;

		return count;
	}

	size_w Render(size_w offset, BYTE *buffer, size_w length)
	{
		return m_pHexView->m_pDataSeq->rendersnapshot(m_count, m_desclist, offset, buffer, (size_t)length);
	}

	HGLOBAL RenderAsHGlobal()
	{
		BYTE *bptr;
		
		// allocate space for the buffer, +1 for string-terminator
		if((bptr = (BYTE *)GlobalAlloc(GPTR, (DWORD)(m_length+1))) == 0)
			return 0;

		// render data and null-terminate
		Render(0, bptr, m_length);
		bptr[m_length] = 0;
		return bptr;
	}

private:

	LONG					m_lRefCount;

	HexView				*	m_pHexView;
	size_t					m_count;
	size_w					m_length;
	sequence::span_desc *	m_desclist;
};

#endif
```

`HexView/HexViewKeyboard.cpp`:

```cpp
//
//  HexViewKeyboard.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

bool IsKeyDown(UINT uVirtualKey)
{
	return (GetKeyState(uVirtualKey) & 0x80000000) ? true : false;
}

void HexView::ScrollToCaret()
{
	int x, y;
	int dx = 0, dy = 0;

	// first of all bring the view into view
	ScrollTo(m_nCursorOffset);

	if((m_nCursorOffset + m_nDataShift) % m_nBytesPerLine != 0)
	{
		m_fCursorAdjustment = FALSE;
	}

	// now find cursor position
	CaretPosFromOffset(m_nCursorOffset, &x, &y);

	if(y < 0)
		dy = y;
	else if(y > m_nWindowLines - 1)
		dy = y - m_nWindowLines + 1;

	if(x < 0)
		dx = x;
	
	Scroll(dx, dy);

	CaretPosFromOffset(m_nCursorOffset, &x, &y);
	PositionCaret(x, y, m_nWhichPane);
}


bool HexView::ForwardDelete()
{
	size_w length;
	bool success = false;

	if(!AllowChange(m_nCursorOffset, max(SelectionSize(), 1), HVMETHOD_DELETE))
		return false;

	if(SelectionSize() > 0)
	{
		length  = SelectionSize();
		success = m_pDataSeq->erase(SelectionStart(), length);

		m_nCursorOffset = SelectionStart();

		m_pDataSeq->breakopt();
	}
	else
	{
		length = 1;
		success = m_pDataSeq->erase(m_nCursorOffset, length);
	}

	m_nSelectionStart = m_nCursorOffset;
	m_nSelectionEnd   = m_nCursorOffset;

	if(success)
		ContentChanged(m_nCursorOffset, length, HVMETHOD_DELETE);

	return true;
}
	
bool HexView::BackDelete()
{
	size_w offset, length;
	bool success = false;

	if(SelectionSize())
	{
		offset = SelectionStart();
		length = SelectionSize();

		if(!AllowChange(offset, length, HVMETHOD_DELETE))
			return false;

		success = m_pDataSeq->erase(offset, length);
		m_nCursorOffset = offset;

		m_pDataSeq->breakopt();
	}
	else if(m_nCursorOffset > 0)
	{
		offset = --m_nCursorOffset;
		length = 1;

		if(!AllowChange(offset, length, HVMETHOD_DELETE))
			return false;

		success = m_pDataSeq->erase(offset, length);
	}

	m_nSelectionStart = m_nCursorOffset;
	m_nSelectionEnd   = m_nCursorOffset;

	if(success)
		ContentChanged(offset, length, HVMETHOD_DELETE);

	return true;
}


LRESULT HexView::OnKeyDown(UINT nVirtualKey, UINT nRepeatCount, UINT nFlags)
{
	BOOL	fForceUpdate = FALSE;
	bool	fCtrlDown	 = IsKeyDown(VK_CONTROL);
	bool	fShiftDown	 = IsKeyDown(VK_SHIFT);
	size_w  oldoffset    = m_nCursorOffset;

	fForceUpdate = !IsKeyDown(VK_SHIFT);

	if(nVirtualKey == VK_CONTROL || nVirtualKey == VK_SHIFT || nVirtualKey == VK_MENU)
		return 0;

	// take into account any offset/shift in the datasource
	// we'll restore it again after the cursor logic has taken place. this tricks
	// the switch-statement into thinking we are using a zero-based adddressing scheme,
	// which is important as the keyboard logic assumes this when keeping the cursor
	// within the bounds of the hex display
	//m_nCursorOffset += m_nDataShift;//+= min((size_w)-1 - m_nCursorOffset, m_nDataShift);

//	m_nCursorOffset += m_nDataShift;//+= min((size_w)-1 - m_nCursorOffset, m_nDataShift);

	switch(nVirtualKey)
	{
	case VK_ESCAPE:
		fForceUpdate = TRUE;
		break;

	case VK_INSERT:
		
		if(fCtrlDown)
		{
			OnCopy();
		}
		else if(fShiftDown)
		{
			OnPaste();
		}
		else if(CheckStyle(HVS_FIXED_EDITMODE) == 0)
		{
			if(m_nEditMode == HVMODE_INSERT)
				m_nEditMode = HVMODE_OVERWRITE;

			else if(m_nEditMode == HVMODE_OVERWRITE)
				m_nEditMode = HVMODE_INSERT;

			NotifyParent(HVN_EDITMODE_CHANGE);
		}

		return 0;

	case 'z': case 'Z':
		
		m_nSubItem = 0;

		if(fCtrlDown)
			Undo();

		return 0;

	// CTRL+Y redo
	case 'y': case 'Y':
		
		m_nSubItem = 0;

		if(fCtrlDown)
			Redo();

		return 0;

	case VK_DELETE:
		
		// cannot delete in readonly mode
		if(m_nEditMode == HVMODE_READONLY)
		{
			return 0;
		}
		// can only erase when in Insert mode
		else if(m_nEditMode == HVMODE_INSERT || 
			CheckStyle(HVS_ALWAYSDELETE) 
			)
		{
			ForwardDelete();
		}
		// overwrite mode - clear byte values
		else if(SelectionSize() > 0)
		{
			BYTE b[] = { 0 };
			FillData(b, 1, SelectionSize());
		}

		return 0;

	case VK_BACK:
		
		// cannot delete in readonly mode
		if(m_nEditMode == HVMODE_READONLY)
		{
			return 0;
		}
		// can only erase when in Insert mode
		else if(m_nEditMode == HVMODE_INSERT || 
			CheckStyle(HVS_ALWAYSDELETE)
			)
		{
			BackDelete();			
		}
		// overwrite mode - clear byte values
		else if(SelectionSize() > 0)
		{
			BYTE b[] = { 0 };
			FillData(b, 1, SelectionSize());
		}

		return 0;

	case VK_LEFT:

		//if ctrl held down, then scroll the viewport around!
		if(IsKeyDown(VK_CONTROL))
		{
			PostMessage(m_hWnd, WM_HSCROLL, SB_LINEUP, 0L);
			return 0;
		}

		if(m_nCursorOffset > 0) 
			m_nCursorOffset--;

		m_fCursorAdjustment = FALSE;
		break;

	case VK_RIGHT:

		//if ctrl held down, then scroll the viewport around!
		if(IsKeyDown(VK_CONTROL))
		{
			PostMessage(m_hWnd, WM_HSCROLL, SB_LINEDOWN, 0L);
			return 0;
		}
		
		if(m_nCursorOffset < m_pDataSeq->size()) 
		{
			m_nCursorOffset++;

			if(m_nCursorOffset == m_pDataSeq->size() &&  m_pDataSeq->size() % m_nBytesPerLine == 0)
				m_fCursorAdjustment = TRUE;
			else
				m_fCursorAdjustment = FALSE;
		}

		break;

	case VK_UP:

		//if ctrl held down, then scroll the viewport around!
		if(IsKeyDown(VK_CONTROL))
		{
			PostMessage(m_hWnd, WM_VSCROLL, SB_LINEUP, 0L);
			return 0;
		}

		if(m_nCursorOffset > (unsigned)m_nBytesPerLine)
			m_nCursorOffset -= m_nBytesPerLine;
		else if(m_nCursorOffset == m_nBytesPerLine && m_fCursorAdjustment == FALSE)
			m_nCursorOffset = 0;

		break;

	case VK_DOWN:

		//if ctrl held down, then scroll the viewport around!
		if(IsKeyDown(VK_CONTROL))
		{
			PostMessage(m_hWnd, WM_VSCROLL, SB_LINEDOWN, 0L);
			return 0;
		}
		
		m_nCursorOffset += min((size_w)m_nBytesPerLine, m_pDataSeq->size() - m_nCursorOffset);

		// if in the last partial line, don't go to end of file, rather
		// stay at "bottom" of file/window
		if(m_nCursorOffset >= m_pDataSeq->size() && !m_fCursorAdjustment)
		{		
			// test if in a partial line 
			if(	oldoffset % m_nBytesPerLine < m_pDataSeq->size() % m_nBytesPerLine  ||
				m_pDataSeq->size() % m_nBytesPerLine == 0)
			{
				m_nCursorOffset = oldoffset;
				fForceUpdate = TRUE;
			}
		}
	
		break;

	case VK_HOME:

		//if ctrl held down, then scroll the viewport around!
		if(fCtrlDown)
		{
			m_nCursorOffset = 0;
			PostMessage(m_hWnd, WM_VSCROLL, SB_TOP, 0L);
		}
		else
		{
			m_nCursorOffset += m_nDataShift;

			if(m_fCursorAdjustment && m_nCursorOffset > 0)
				m_nCursorOffset--;

			m_nCursorOffset -= m_nCursorOffset % m_nBytesPerLine;

			m_nCursorOffset -= min(m_nDataShift, m_nCursorOffset);
		}

		m_fCursorAdjustment = FALSE;
		break;

	case VK_END:
		
		if(IsKeyDown(VK_CONTROL))
		{
			m_nCursorOffset = m_pDataSeq->size();
		
			if(m_nCursorOffset % m_nBytesPerLine == 0)
				m_fCursorAdjustment = TRUE;

			PostMessage(m_hWnd, WM_VSCROLL, SB_BOTTOM, 0L);
		}
		else
		{
			// take into account the datashift
			// we need to 'shift' the end-of-file as well!
			m_nCursorOffset += m_nDataShift;
			size_w adjdocsize = m_pDataSeq->size() + m_nDataShift;

			// if not already at very end of line
			if(m_fCursorAdjustment == FALSE)
			{
				if(adjdocsize - m_nBytesPerLine >= m_nCursorOffset
					&& adjdocsize >= (size_t)m_nBytesPerLine)
				{
					m_nCursorOffset += m_nBytesPerLine - (m_nCursorOffset % m_nBytesPerLine);
					m_fCursorAdjustment = TRUE;
				}
				else
				{
					m_nCursorOffset += adjdocsize - m_nCursorOffset;
				}
			}

			if(m_nCursorOffset >= adjdocsize && adjdocsize % m_nBytesPerLine == 0)
				m_fCursorAdjustment = TRUE;

			m_nCursorOffset -= min(m_nDataShift, m_nCursorOffset);
		}

		break;

	case VK_PRIOR:		// pageup

		m_nCursorOffset -= min(m_nCursorOffset, (size_w)m_nBytesPerLine * m_nWindowLines);

		break;

	case VK_NEXT:		// pagedown

		m_nCursorOffset += min(m_pDataSeq->size() - m_nCursorOffset, (size_w)m_nBytesPerLine * m_nWindowLines);

		if(m_nCursorOffset >= m_pDataSeq->size() && m_pDataSeq->size() % m_nBytesPerLine == 0)
		{
			m_fCursorAdjustment = TRUE;
		}

		break;

	case VK_TAB:

		m_nWhichPane ^= 1;
		fForceUpdate = TRUE;
		
		if(m_ColourList[HVC_SELECTION] != m_ColourList[HVC_SELECTION2])
		{
			InvalidateRange(m_nSelectionStart, m_nSelectionEnd);
		}
		break;

	default:
		// don't know what this key is, so exit
		return 0;
	}

	m_nSubItem = 0;

	if(m_nCursorOffset != oldoffset || fForceUpdate)
	{
		// SHIFT key being held down?
		if(IsKeyDown(VK_SHIFT))
		{
			// extend the selection
			m_nSelectionEnd = m_nCursorOffset;
			InvalidateRange(oldoffset, m_nSelectionEnd);
		}
		else if(nVirtualKey != VK_TAB)
		{
			// clear any selection
			if(m_nSelectionEnd != m_nSelectionStart)
				InvalidateRange(m_nSelectionEnd, m_nSelectionStart);

			m_nSelectionEnd   = m_nCursorOffset;
			m_nSelectionStart = m_nCursorOffset;
		}

		ScrollToCaret();
		NotifyParent(HVN_CURSOR_CHANGE);

		if(nVirtualKey == VK_NEXT || nVirtualKey == VK_PRIOR)
		{
			RefreshWindow();
		}
	}

	return 0;
}

LRESULT HexView::OnChar(UINT nChar)
{
	if(nChar < 32)
		return 0;

	if(m_nEditMode == HVMODE_READONLY)
	{
		MessageBeep(MB_ICONASTERISK);
		return 0;
	}
		
	if(m_nWhichPane == 0)	// hex column
	{
		int  cl[4] = { 2, 3, 3, 8 };
		int  cb[4] = { 16, 10, 8, 2 };
		//int  cw[4] = { 2, 3, 3, 2 };
		int  cf = m_nControlStyles & HVS_FORMAT_MASK;
		int  val;
		BYTE b = 0;

		// get data under caret
		/*if(m_nSubItem > 0)
		{
			b = m_pDataSeq->getlastmodref();
		}
		else*/ if(m_nEditMode == HVMODE_INSERT)
		{
			b = 0;
		}
		else
		{
			GetData(m_nCursorOffset, &b, 1);
		}

		// check this is an allowed character
		if(cf == HVS_FORMAT_HEX && !isxdigit(nChar) ||
		   cf == HVS_FORMAT_DEC && !(nChar >= '0' && nChar <= '9')  ||
		   cf == HVS_FORMAT_OCT && !(nChar >= '0' && nChar <= '7')  ||
		   cf == HVS_FORMAT_BIN && !(nChar >= '0' && nChar <= '1')
		   )
		{
			MessageBeep(MB_ICONASTERISK);
			return 0;
		}

		int val2;
		if(nChar >= 'a')		val2 = nChar - 'a' + 0x0a;
		else if(nChar >= 'A')	val2 = nChar - 'A' + 0x0A;
		else					val2 = nChar - '0';

		int power = 1;
		int base  = cb[cf];
		for(int i = cl[cf] - 1; i > m_nSubItem; i--)
			power *= base;

		val = b;
		val = (val / power) % base;
		val *= power;
		val = b - val;
		val += val2 * power;

		// check that we won't overflow the underlying value
		if(val > 0xff)
		{
			//MessageBeep(MB_ICONASTERISK);
			//return 0;
			val -= b % power;
		}

		b = (BYTE)val;

		m_nSubItem++;

		if(m_fCursorMoved)
		{	
			// enter the data
			EnterData(&b, 1, m_nWhichPane == 0 ? false : true, true, false);
			
			m_nLastEditOffset = m_nCursorOffset;
			m_fCursorMoved	  = false;
		}
		else
		{
			// directly edit the byte in the sequence - this
			// prevents us from introducing any more spans than necessary
			// and keeps this as a single 'byte' edit
			m_pDataSeq->getlastmodref() = b;
			ContentChanged(m_nCursorOffset, 1, HVMETHOD_OVERWRITE);

			if(m_nSubItem == cl[cf])
			{
				m_nSubItem = 0;
				m_nCursorOffset++;
			}
			
			RepositionCaret();
		}


	}
	else
	{
		BYTE b = nChar;

		//if(!AllowChange(m_nCursorOffset, 1, HVMETHOD_OVERWRITE, &b))
			//return 0;

		// ascii column - enter the data as-is
		m_nSubItem = 0;
		EnterData(&b, 1, true, true, false);
	}

	return 0;
}

UINT method(size_w newlen, size_w oldlen)
{
	if(newlen == oldlen)
	{
		return HVMETHOD_OVERWRITE;
	}
	else if(newlen < oldlen)
	{
		return HVMETHOD_DELETE;
	}
	else if(newlen > oldlen)
	{
		return HVMETHOD_INSERT;
	}
	else
	{
		return 0;
	}
}

bool HexView::Undo()
{
	if(CheckStyle(HVS_DISABLE_UNDO))
		return false;
	
	size_w oldlen = m_pDataSeq->size();

	if(m_pDataSeq->undo())
	{
		m_nSelectionStart = m_pDataSeq->event_index();
		m_nSelectionEnd   = m_pDataSeq->event_length() + m_nSelectionStart;
		m_nCursorOffset   = m_nSelectionEnd;

		ContentChanged(m_pDataSeq->event_index(), m_pDataSeq->event_datalength(), method(m_pDataSeq->size(), oldlen));
		return true;
	}
	else
	{
		return false;
	}
}

bool HexView::Redo()
{
	if(CheckStyle(HVS_DISABLE_UNDO))
		return false;

	size_w oldlen = m_pDataSeq->size();

	if(m_pDataSeq->redo())
	{
		m_nSelectionStart = m_pDataSeq->event_index();
		m_nSelectionEnd   = m_pDataSeq->event_length() + m_nSelectionStart;
		m_nCursorOffset   = m_nSelectionEnd;

		ContentChanged(m_pDataSeq->event_index(), m_pDataSeq->event_datalength(), method(m_pDataSeq->size(), oldlen));
		return true;
	}
	else
	{
		return false;
	}
}


bool HexView::CanUndo()
{
	return m_pDataSeq->canundo();
}

bool HexView::CanRedo()
{
	return m_pDataSeq->canredo();
}

```

`HexView/HexViewMouse.cpp`:

```cpp
//
//  HexViewMouse.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#define STRICT
#define _WIN32_WINNT 0x500

#include <windows.h>
#include <tchar.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

HRESULT CreateDropSource(IDropSource **ppDropSource);
HRESULT CreateDataObject(int max, IDataObject **ppDataObject);

void CloseButton(HDC hdc, RECT *rect, RECT *out, BOOL fHover);

#define DRAGBORDER_SIZE 16

bool __inline inrange(size_w offset, size_w start, size_w finish)
{
	return offset >= start && offset < finish ||
		   offset >= finish && offset < start;
}

int HexView::GetLogicalX(int x, int *pane, int *subitem /*= 0*/)
{
	if(pane) *pane = CheckStyle(HVS_HEX_INVISIBLE) ? 1 : 0;
	if(subitem) *subitem = 0;

	// take into account the horizontal scroll position
	x += m_nHScrollPos * m_nFontWidth;

	// round down to mid-character position
	x = (x + (m_nFontWidth * 7) / 16) / m_nFontWidth;

	//TRACEA("xchar: %d: ", x);

	// clicked in address column?
	if(CheckStyle(HVS_ADDR_INVISIBLE) == false)
	{
		if(x < m_nAddressWidth + m_nHexPaddingLeft)
		{
			return 0;
		}
	
		x -= m_nAddressWidth;
	}

	if(CheckStyle(HVS_HEX_INVISIBLE) == false)
	{
		x -= m_nHexPaddingLeft;
	
		// clicked in hex column?
		if(x < m_nHexWidth)
		{
			int unitwidth = UnitWidth();

			int col    = x / (m_nBytesPerColumn * unitwidth + 1);
			int coloff = min(m_nBytesPerColumn-1,(x - col * (m_nBytesPerColumn * unitwidth + 1)) / unitwidth);

			col *= m_nBytesPerColumn;
			col += coloff;

			if(subitem)
				//*subitem = 0;
				*subitem = (x % (m_nBytesPerColumn * unitwidth + 1)) % unitwidth;

			return col;
		}

		x -= m_nHexWidth;// + 1;			// errrm
	
		// clicked in the 1st half of hex-padding-right?
		if(x < m_nHexPaddingRight / 2)
		{
			//TRACEA("%d %d\n", pane?*pane:-1, m_nBytesPerLine);
			return m_nBytesPerLine;
		}
	}
	
	if(CheckStyle(HVS_ASCII_INVISIBLE) == false)
	{
		x -= m_nHexPaddingRight;// - 1;  // errrm

		if(pane) *pane = 1;

		// clicked in ascii column?
		if(x > m_nBytesPerLine)// && !CheckStyle(HVS_ASCII_INVISIBLE))
			x = m_nBytesPerLine;
	}
	else
	{
		x = m_nBytesPerLine;
	}
	
	if(x < 0) 
		x = 0;

	//TRACEA("%d %d\n", pane ? *pane : -1, x);
	return x;
}

int HexView::GetLogicalY(int y)
{
	if(y < 0) y = 0;

	y = y / m_nFontHeight;

	return y;
}

void HexView::CaretPosFromOffset(size_w offset, int *x, int *y)
{
	// take into account any offset/shift in the datasource
	//offset -= m_nDataShift;
	offset += m_nDataShift;

	if(m_fCursorAdjustment && offset > 0)//>= m_nBytesPerLine)
	{
		*y = (int)(offset / m_nBytesPerLine - m_nVScrollPos - 1);
		*x = (int)(m_nBytesPerLine);

		if(*y < 0 && m_nVScrollPos == 0)
			*y = 0;
	}
	else
	{
		*y = (int)(offset / m_nBytesPerLine - m_nVScrollPos);
		*x = (int)(offset % m_nBytesPerLine);
	}

	// if the cursor is well outside the viewport, then hide it
	// because rounding errors could cause it to wrap around
	if(offset / m_nBytesPerLine < m_nVScrollPos)
	{
		*y = -1;
	}
	else if(offset / m_nBytesPerLine - m_nVScrollPos > (unsigned)m_nWindowLines+1)
	{
		*y = m_nWindowLines+1;
	}
}

int HexView::LogToPhyXCoord(int x, int pane)
{
	int offset	  = 0;
	int xpos	  = x;
	int unitwidth = UnitWidth();
	
	switch(pane)
	{
	case 0:		// hex
		
		// if at the end of line need to adjust
		// but only if we are also at end of a "block"
		if((x == m_nBytesPerLine) && (m_nBytesPerLine % m_nBytesPerColumn) == 0)
			offset = -1;

		x = (x * unitwidth) + (x / m_nBytesPerColumn);
		
		x -= m_nHScrollPos;
		x += CheckStyle(HVS_ADDR_INVISIBLE) ? 0 : m_nAddressWidth;
		x += m_nHexPaddingLeft;
		x += offset;
		
		if(m_nSelectionStart < m_nSelectionEnd && offset == 0 &&
			(xpos % m_nBytesPerColumn) == 0 && xpos > 0)
			x--;
		
		return x * m_nFontWidth;
		
	case 1:		// asc
		
		x -= m_nHScrollPos;
		x += CheckStyle(HVS_ADDR_INVISIBLE) ? 0 : m_nAddressWidth;
		x += CheckStyle(HVS_HEX_INVISIBLE) ? 0 : m_nHexPaddingLeft;
		x += CheckStyle(HVS_HEX_INVISIBLE) ? 0 : m_nHexWidth;
		
		x += CheckStyle(HVS_ASCII_INVISIBLE) ? 0 : m_nHexPaddingRight;

		x -= CheckStyle(HVS_ASCII_INVISIBLE) ? xpos : 0;
		
		return x * m_nFontWidth;
		
	default:
		return 0;
	}
}

size_w HexView::OffsetFromPhysCoord(int mx, int my, int *pane, int *lx, int *ly, int *subitem)
{
	size_w offset;

	int x = GetLogicalX(mx, pane, subitem);
	int y = GetLogicalY(my);

	if(y >= m_nWindowLines)   y = m_nWindowLines -1;
	if(x >= m_nWindowColumns) x = m_nWindowColumns -1;
	if(x < 0) x = 0;
	if(y < 0) y = 0;

	size_w adjdocsize = m_pDataSeq->size() + m_nDataShift;

	// need to do this in two stages to avoid overflow
	offset = /*x+*/(y + m_nVScrollPos) * m_nBytesPerLine;
	//offset -= m_nDataShift;
	offset += min((size_w)x, adjdocsize - offset);

	if(offset < m_nDataShift)
	{
		// did we click in the deadspace at start of the file?
		x = m_nDataShift;
	}

//	TRACEA("SMEG: %d\n", offset);

	if(lx) *lx = x;
	if(ly) *ly = y;
	
	// take into account any offset/shift in the datasource
	//int shft = min(m_nDataShift, offset);
	///offset -= min(m_nDataShift, offset);


//	offset -= min(m_nDataShift, offset);

	if(offset >= adjdocsize)
	{
		offset = adjdocsize;
		m_fCursorAdjustment = (offset % m_nBytesPerLine == 0);

		if(lx && ly)
		{
			if(offset == 0)
				*lx = *ly = 0;
			else
				CaretPosFromOffset(offset - m_nDataShift, lx, ly);
		}
	}
	else
	{
		//offset - min(m_nDataShift, offset);
	}

	offset -= min(m_nDataShift, offset);
	//return offset + m_nDataShift;
	return offset ;//- min(m_nDataShift, offset);
}

void HexView::PositionCaret(int x, int y, int pane)
{
	if(m_nLastEditOffset != m_nCursorOffset)
		m_fCursorMoved = true;

	m_fCursorAdjustment = (x == m_nBytesPerLine);

	int physx = LogToPhyXCoord(x, pane);
	int physy = y * m_nFontHeight;

	physx += m_nSubItem * m_nFontWidth;

	SetCaretPos(physx, physy);
	ShowCaret(m_hWnd);
}

void HexView::RepositionCaret()
{
	int x, y;

	CaretPosFromOffset(m_nCursorOffset, &x, &y);
	PositionCaret(x, y, m_nWhichPane);
}

bool HexView::IsOverResizeBar(int x)
{
	const int BARWIDTH = 8;
	return (x / BARWIDTH) == (m_nResizeBarPos / BARWIDTH);
}

UINT HexView::HitTest(int x, int y, RECT *phirc, BOOKNODE **pbnp)// = 0)
{
	const int BARWIDTH = 8;

	if(pbnp)
		*pbnp = 0;
		
	// mouse within the resize bar?
	if(!CheckStyle(HVS_FITTOWINDOW) && CheckStyle(HVS_RESIZEBAR))
	{
				int pos1 = (m_nAddressWidth - m_nHScrollPos) * m_nFontWidth + 
					(m_nHexPaddingLeft * m_nFontWidth) / 2;

		if((x / BARWIDTH) == (m_nResizeBarPos / BARWIDTH))
		{
			return HVHT_RESIZE;
		}
		else if((x / BARWIDTH) == (pos1/BARWIDTH))
		{
			return HVHT_RESIZE0;
		}
	}

	x -= m_nHScrollPos;

	// mouse within the main hex display?
	if(x < m_nWindowColumns * m_nFontWidth + BOOKMARK_XOFFSET - 3)
	{
		size_w curoff = OffsetFromPhysCoord(x, y);
		
		if(inrange(curoff, m_nSelectionStart, m_nSelectionEnd))
			return HVHT_SELECTION;
		else
			return HVHT_MAIN;
	}
	// otherwise it's in the bookmark column
	else
	{
		// ok we clicked to the right of the ascii column, where
		// the bookmarks sometimes live. Did we click on a bookmark,
		// or on deadspace?
		BOOKNODE *bptr;
	
		// what offset?
		size_w offset = (GetLogicalY(y) + m_nVScrollPos) * m_nBytesPerLine;
				
		// find a bookmark that we overlap
		for(bptr = m_BookHead->next; bptr != m_BookTail; bptr = bptr->next)
		{
			BOOKMARK *bookmark = &bptr->bookmark;

			RECT rect;

			// get the bounding rectangle of specified highlight
			if(BookmarkRect(bookmark, &rect))
			{
				POINT pt = { x, y };

				if(phirc)
					*phirc = rect;

				if(pbnp)
					*pbnp = bptr;
				
				if(PtInRect(&rect, pt))
				{
					//TRACEA("Wee %d,%d - %d,%d\n", rect.left,rect.top, rect.right,rect.bottom);

					if(pt.x < rect.left + BOOKMARK_GRIPWIDTH)
						return HVHT_BOOKGRIP;

					if(pt.x >= rect.right-16)
					{
						if(pt.y >= rect.bottom-16)
							return HVHT_BOOKSIZE;

						if(pt.x < rect.right - 3 &&
							pt.y >= rect.top + 4 && pt.y < rect.top + 16)
						{
							return HVHT_BOOKCLOSE;
						}
					}

					rect.left  += BOOKMARK_GRIPWIDTH;
					rect.right -= 16;
					InflateRect(&rect, -3, -3);

					if(PtInRect(&rect, pt))
					{
						if(pt.y < rect.top + 12)
						{
							if(pt.x > rect.right - 150)
								return HVHT_BOOKEDIT3;
							else
								return HVHT_BOOKEDIT1;
						}
						else
						{
							return HVHT_BOOKEDIT2;
						}
					}


					return HVHT_BOOKMARK;
				}
			}

			// does this highlight's starting offset intersect the line the mouse is over?
			if(bookmark->offset >= offset && bookmark->offset + bookmark->length < offset + m_nBytesPerLine*3)
			{
				int width  = 300;
				int height = 75;

				//HiglightRect(


				
			}
		}
	}

	return HVHT_NONE;
}

//
//	WM_MOUSEACTIVATE
//
//	Grab the keyboard input focus 
//	
LRESULT HexView::OnMouseActivate(HWND hwndTop, UINT nHitTest, UINT nMessage)
{
	//TRACEA("activate\n");
	POINT pt;
	GetCursorPos(&pt);
	ScreenToClient(m_hWnd, &pt);

	if(HitTest(pt.x, pt.y, 0, 0) & HVHT_BOOKMARK)
		return MA_ACTIVATE;

	//if(GetFocus() == m_hwndEdit)
		
	else if(GetFocus() != m_hWnd) 
		SetFocus(m_hWnd);
	
	return MA_ACTIVATE;

//	SetFocus(m_hWnd);
//	return MA_ACTIVATE;
}

LRESULT HexView::OnLButtonDblClick(UINT nFlags, int x, int y)
{
	size_t offset;
	size_w start;
	size_t len, i;

	BYTE buf[256];
	RECT hir;
	UINT ht = HitTest(x, y, &hir, &m_HighlightCurrent);
	m_HighlightHot = m_HighlightCurrent;
	m_HitTestHot   = ht;
	m_HitTestCurrent = ht;

	// if clicked on the resize bar
	if(ht & HVHT_BOOKMARK)//!CheckStyle(HVS_FITTOWINDOW) && CheckStyle(HVS_RESIZEBAR) && IsOverResizeBar(x))
	{
		InvalidateRect(m_hWnd, &hir, FALSE);
		UpdateWindow(m_hWnd);
		return 0;
	}

	if(m_hwndEdit)
		return 0;

	offset = (size_t)min(128, m_nCursorOffset);

	//start  = min(m_nCursorOffset, 128);

	start = 0;
	
	len = m_pDataSeq->render(m_nCursorOffset - offset, buf, 256);

	BYTE under = buf[offset];

	// search forwards through the buffer
	for(i = offset; i < len; i++)
	{
		if(!isalnum(buf[i]))
			break;
	}

	m_nSelectionEnd = m_nCursorOffset - offset + i;

	// search backwards
	for(i = 0; i < offset; i++)
	{
		if(!isalnum(buf[offset - i - 1]))
			break;
	}

	m_nSelectionStart = m_nCursorOffset - i;
	m_nCursorOffset   = m_nSelectionEnd;
	
	NotifyParent(HVN_SELECTION_CHANGE);
	NotifyParent(HVN_CURSOR_CHANGE);	

	RefreshWindow();
	ScrollToCaret();
	
	return 0;
}


static WNDPROC g_oldEditProc;

LRESULT HexView::EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LRESULT ret;
	BOOKNODE *bptr = (BOOKNODE *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch(msg)
	{
	case WM_MOUSEACTIVATE:
		if(GetFocus() != hwnd) 
			SetFocus(hwnd);
	
		return MA_ACTIVATE;

	case WM_SETTEXT:
	case WM_PASTE:
	case WM_KEYDOWN:
	case WM_CHAR:
		ret = CallWindowProc(g_oldEditProc, hwnd, msg, wParam, lParam);

		GetWindowText(hwnd, bptr->bookmark.pszText, 32);

		InvalidateRect(GetParent(hwnd),0,0);
		return ret;

	case WM_MOUSEWHEEL:
		return SendMessage(GetParent(hwnd), msg, wParam, lParam);
	}

	return CallWindowProc(g_oldEditProc, hwnd, msg, wParam, lParam);
}

BOOL HexView::EditBookmark(BOOKNODE *bptr, RECT *hir, bool fEditTitle)
{
	RECT rect = *hir;
	DWORD dwStyle;
	TCHAR *szText;

	HFONT hFont;

	if(fEditTitle)
	{
		dwStyle = WS_CHILD|ES_AUTOHSCROLL;
		szText  = bptr->bookmark.pszTitle;
		hFont   = CreateFont(-12, 0, 0, 0, FW_BOLD, 0, 0, 0, 0, 0, 0, 0, 0, TEXT("Tahoma"));
		rect.bottom = rect.top + 14;
	}
	else
	{
		dwStyle = WS_CHILD|ES_MULTILINE|ES_WANTRETURN|ES_AUTOVSCROLL;
		szText  = bptr->bookmark.pszText;
		hFont   = CreateFont(-12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, TEXT("Tahoma"));
	}

	//HighlightRect(hip->hp
	m_hwndEdit = CreateWindowEx(0, TEXT("EDIT"), 
		szText, dwStyle,
		rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
		m_hWnd, 0, 0, 0);

	SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM)hFont, 0);
	g_oldEditProc = (WNDPROC)GetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC);
	SetWindowLongPtr(m_hwndEdit, GWLP_USERDATA, (LONG_PTR)bptr);
	SetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditProc);
				
	//SendMessage(m_hwndEdit, EM_SETSEL, 0, -1);
	ShowWindow(m_hwndEdit, SW_SHOW);
	SetFocus(m_hwndEdit);
	POINT pt;
	GetCursorPos(&pt);
	
	//ScreenToClient(m_hwndEdit, &pt);
	//SendMessage(m_hwndEdit, WM_LBUTTONDOWN, nFlags, MAKELPARAM(pt.x,pt.y));
	INPUT inp = { INPUT_MOUSE, { pt.x, pt.y, 0, MOUSEEVENTF_ABSOLUTE|MOUSEEVENTF_LEFTDOWN }};
	SendInput(1, &inp, sizeof(inp));
	
	return 0;
}



LRESULT HexView::OnLButtonDown(UINT nFlags, int x, int y)
{
	::SetFocus(m_hWnd);
	RECT hir;

	UINT ht = HitTest(x, y, &hir, &m_HighlightCurrent);
	m_HighlightHot	 = m_HighlightCurrent;
	m_HitTestCurrent = ht;
	m_HitTestHot	 = ht;

	// if clicked on either resize bar
	if(ht & HVHT_RESIZE)//!CheckStyle(HVS_FITTOWINDOW) && CheckStyle(HVS_RESIZEBAR) && IsOverResizeBar(x))
	{
		if(ht == HVHT_RESIZE)
			m_fResizeBar = true;
		else if(ht == HVHT_RESIZE0)
			m_fResizeAddr = true;

		SetCapture(m_hWnd);
		return 0;
	}	
	// clicked on a bookmark?
	else if(ht & HVHT_BOOKMARK)
	{
		SetCapture(m_hWnd);

		if(ht == HVHT_BOOKCLOSE)
		{
			NMHVBOOKMARK nmbm;
			//nmbm.hp = 
			NotifyParent(HVN_BOOKCLOSE, (NMHDR *)&nmbm);

			RECT clip;
			CloseButton(NULL, &hir, &clip, 0);
			InvalidateRect(m_hWnd, &clip, 0);
			UpdateWindow(m_hWnd);
		}
		else if(ht == HVHT_BOOKEDIT1 || ht == HVHT_BOOKEDIT2)
		{
			hir.left += BOOKMARK_XOFFSET - 7;
			hir.right -= 16;

			if(ht == HVHT_BOOKEDIT2)
			{
				hir.top += 15;
			}
			else
			{
				hir.top += 1;
				hir.right -= 140;
			}

			InflateRect(&hir, -3, -3);

			//if(m_hwndEdit == 0)
			{
				DestroyWindow(m_hwndEdit);
				EditBookmark(m_HighlightCurrent, &hir, ht == HVHT_BOOKEDIT1 ? true : false);
			}
		}
	}
	else
	{
		// convert actual coords to font-based
		m_nSubItem = 0;
		m_nCursorOffset = OffsetFromPhysCoord(x, y, &m_nWhichPane, &x, &y, &m_nSubItem);
		
		// if the mouse is pressed when it is over a selection, 
		// then start a drag-drop as soon as the mouse moves
		if(inrange(m_nCursorOffset, m_nSelectionStart, m_nSelectionEnd))
		{
			m_fStartDrag = true;
			m_fDigDragDrop = false;
			
		}
		else
		{
			m_nSelectionMode = SEL_NORMAL;
			
			// if the shift key is pressed, extend the selection
			if(nFlags & MK_SHIFT)
			{
				InvalidateRange(m_nCursorOffset, m_nSelectionEnd);
				m_nSelectionEnd   = m_nCursorOffset;		
			}
			else
			{
				InvalidateRange(m_nSelectionStart, m_nSelectionEnd);
				m_nSelectionStart = m_nCursorOffset;
				m_nSelectionEnd   = m_nCursorOffset;
			}
		}
		
		PositionCaret(x, y, m_nWhichPane);
		
		NotifyParent(HVN_CURSOR_CHANGE);
		
		UpdateWindow(m_hWnd);
		
		SetCapture(m_hWnd);
	}

	return 0;
}

int ScrollDir(int counter, int distance)
{
	if(distance > 48)		return 5;
	if(distance > 16)		return 2;
	if(distance > 3)		return 1;
	if(distance > 0)		return counter % 5 == 0 ? 1 : 0;
	
	if(distance < -48)		return -5;
	if(distance < -16)		return -2;
	if(distance < -3)		return -1;
	if(distance < 0)		return counter % 5 == 0 ? -1 : 0;

	return 0;
}

LRESULT HexView::OnTimer(UINT_PTR Id)
{
	int dx = 0, dy = 0;

	RECT rect;
	POINT pt;
	
	// find client area, but make it an even no. of lines
	GetClientRect(m_hWnd, &rect);

	if(m_nSelectionMode == SEL_DRAGDROP)
	{
		InflateRect(&rect, -DRAGBORDER_SIZE, -DRAGBORDER_SIZE);
	}
	else
	{
		rect.bottom -= rect.bottom % m_nFontHeight;
		// rect.left += LeftMarginWidth();
	}

	// get the mouse's client-coordinates
	GetCursorPos(&pt);
	ScreenToClient(m_hWnd, &pt);

	// scrolling up / down??
	if(pt.y < rect.top)					
		dy = ScrollDir(m_nScrollCounter, pt.y - rect.top);

	else if(pt.y >= rect.bottom)	
		dy = ScrollDir(m_nScrollCounter, pt.y - rect.bottom);

	// scrolling left / right?
	if(pt.x < rect.left)					
		dx = ScrollDir(m_nScrollCounter, pt.x - rect.left);

	else if(pt.x > rect.right)		
		dx = ScrollDir(m_nScrollCounter, pt.x - rect.right);

	//
	// Scroll the window but don't update any invalid
	// areas - we will do this manually after we have 
	// repositioned the caret
	//
	HRGN hrgnUpdate = ScrollRgn(dx, dy, true);

	//
	// do the redraw now that the selection offsets are all 
	// pointing to the right places and the scroll positions are valid.
	//
	if(hrgnUpdate != NULL)
	{
		// We perform a "fake" WM_MOUSEMOVE for two reasons:
		//
		// 1. To get the cursor/caret/selection offsets set to the correct place
		//    *before* we redraw (so everything is synchronized correctly)
		//
		// 2. To invalidate any areas due to mouse-movement which won't
		//    get done until the next WM_MOUSEMOVE - and then it would
		//    be too late because we need to redraw *now*
		//
		OnMouseMove(0, pt.x, pt.y);

		// invalidate the area returned by ScrollRegion
		InvalidateRgn(m_hWnd, hrgnUpdate, FALSE);
		DeleteObject(hrgnUpdate);

		// the next time we process WM_PAINT everything 
		// should get drawn correctly!!
		UpdateWindow(m_hWnd);
	}

	/*int x = pt.x, y = pt.y;
	m_nSelectionEnd = OffsetFromPhysCoord(x, y, &pane, &x, &y);	

	if(pane != m_nWhichPane)
	{
		m_nWhichPane = pane;
		if(m_ColourList[HVC_SELECTION] != m_ColourList[HVC_SELECTION2])
			InvalidateRange(m_nSelectionStart, m_nSelectionEnd);
	}

	PositionCaret(x, y, m_nWhichPane);
	NotifyParent(HVN_CURSOR_CHANGE);*/

	// keep track of how many WM_TIMERs we process because
	// we might want to skip the next one
	InterlockedIncrement(&m_nScrollCounter);
	return 0;
}

void HexView::StartDrag()
{
	IDataObject *pDataObject;
	IDropSource *pDropSource;
	DWORD		 dwEffect;
	DWORD		 dwResult;
		
	// Create the IDropSource COM object
	CreateDropSource(&pDropSource);

	// Create an IDataObject that represents the specified range of data
	// in the current document
	CreateDataObject(SelectionStart(), SelectionSize(), &pDataObject);
	
	// Specify which drop-effects we allow based on the current edit mode
	dwEffect = DROPEFFECT_COPY;	

	if(m_nEditMode == HVMODE_INSERT)
		dwEffect |= DROPEFFECT_MOVE;

	//
	//	** ** ** The drag-drop operation starts here! ** ** **
	//
	size_w selstart = SelectionStart();
	size_w sellen   = SelectionSize();
	dwResult = DoDragDrop(pDataObject, pDropSource, dwEffect, &dwEffect);
	
	// success! check to see if we copied/moved data
	if(dwResult == DRAGDROP_S_DROP)
	{
		if(dwEffect & DROPEFFECT_MOVE)
		{
			// remove selection from edit control
			OnClear();
			//m_pDataSeq->erase(selstart, sellen);
			//m_pDataSeq->breakopt();
		}


	}
	// cancelled
	else if(dwResult == DRAGDROP_S_CANCEL)
	{
	}
	
	pDataObject->Release();
	pDropSource->Release();
	
	//ReleaseCapture();
}

TCHAR * CursorFromHittest(UINT ht)
{
	switch(ht)
	{
	case HVHT_NONE:		return IDC_ARROW;
	case HVHT_MAIN:		return IDC_IBEAM;
	case HVHT_SELECTION:return IDC_ARROW;
//	case HVHT_ADDRESS:	return IDC_IBEAM;
//	case HVHT_HEXCOL:	return IDC_IBEAM;
//	case HVHT_ASCCOL:	return IDC_IBEAM;
	case HVHT_RESIZE:	return IDC_SIZEWE;
	case HVHT_RESIZE0:	return IDC_SIZEWE;
	case HVHT_BOOKMARK:	return IDC_ARROW;
	case HVHT_BOOKCLOSE:return IDC_ARROW;
	case HVHT_BOOKSIZE:	return IDC_SIZENWSE;
	case HVHT_BOOKGRIP:	return IDC_SIZEALL;
	case HVHT_BOOKEDIT:	return IDC_IBEAM;
	case HVHT_BOOKEDIT1:return IDC_IBEAM;
	case HVHT_BOOKEDIT2:return IDC_IBEAM;
	case HVHT_BOOKEDIT3:return IDC_ARROW;
	default:			return IDC_ARROW;
	}
}

LRESULT HexView::OnMouseMove(UINT nFlags, int x, int y)
{
	int mx = x, my = y;
	const int SCROLLAMT = 1;
	size_w offset;
	RECT rect;
	RECT client;
	int pane;

	POINT	pt = { mx, my };

	GetClientRect(m_hWnd, &client);
	CopyRect(&rect, &client);
	rect.bottom -= rect.bottom % m_nFontHeight;

	offset = OffsetFromPhysCoord(mx, my, &pane, &x, &y);

	if(m_fStartDrag)
	{
		TRACEA("Starting Drag\n");
		m_fStartDrag = false;

		StartDrag();
		m_fDigDragDrop = true;
		return 0;
	}

	//
	// convert actual coords to font-based
	//
	if(m_nSelectionMode)// == SEL_NORMAL)
	{
		if(pane != m_nWhichPane)
		{
			m_nWhichPane = pane;
			
			if(m_ColourList[HVC_SELECTION] != m_ColourList[HVC_SELECTION2])
				InvalidateRange(m_nSelectionStart, m_nSelectionEnd);
		}

		if(m_nSelectionMode != SEL_DRAGDROP)
		{
			// update display if the cursor moved
			if(m_nCursorOffset != offset)
			{
				m_nCursorOffset = offset;
				m_nSubItem = 0;

				InvalidateRange(m_nCursorOffset, m_nSelectionEnd);
				m_nSelectionEnd = m_nCursorOffset;
				PositionCaret(x, y, m_nWhichPane);

				NotifyParent(HVN_SELECTION_CHANGE);
				NotifyParent(HVN_CURSOR_CHANGE);
			}

			//SetCursor(LoadCursor(NULL, IDC_IBEAM));
		}
		else
		{
			if(m_nCursorOffset != offset)
			{
				m_nCursorOffset = offset;
				m_nSubItem = 0;

				PositionCaret(x, y, m_nWhichPane);

				NotifyParent(HVN_SELECTION_CHANGE);
				NotifyParent(HVN_CURSOR_CHANGE);
			}

			InflateRect(&rect, -DRAGBORDER_SIZE, -DRAGBORDER_SIZE);
		}

		

		// If mouse is within this area, we don't need to scroll
		if(PtInRect(&rect, pt) || 
			m_nSelectionMode == SEL_DRAGDROP && !PtInRect(&client, pt))
		{
			if(m_nScrollTimer != 0)
			{
				KillTimer(m_hWnd, m_nScrollTimer);
				m_nScrollTimer = 0;
			}
		}
		// If mouse is outside window, start a timer in
		// order to generate regular scrolling intervals
		else
		{
			if(m_nScrollTimer == 0)
			{
				m_nScrollCounter = 0;
				m_nScrollTimer = SetTimer(m_hWnd, 1, 30, 0);
			}
		}			
	}
	// Otherwise is the user moving the mouse to resize the vertical pane splitters?
	else if(m_fResizeBar)
	{
		int width     = mx /= m_nFontWidth + m_nHScrollPos;
		int prevbpl	  = m_nBytesPerLine;
		int unitwidth = UnitWidth();

		if(CheckStyle(HVS_HEX_INVISIBLE) == false)
		{
			// work out the size of hex area
			width -= m_nAddressWidth + m_nHexPaddingLeft;
		
			// work out how many bytes-per-line will fit into specified width
			m_nBytesPerLine = (width * m_nBytesPerColumn) / 
						  (m_nBytesPerColumn * (unitwidth) + 1);
		}
		else
		{
			// ascii 
			width -= m_nAddressWidth + m_nHexPaddingRight;
			m_nBytesPerLine = width;
		}

		// force whole-sized columns if necessary
		int minunit = 1;//CheckStyle(HVS_FORCE_FIXEDCOLS) ? m_nBytesPerColumn : 1;

		m_nBytesPerLine -= m_nBytesPerLine % minunit;

		// make sure we stay within legal limits
		m_nBytesPerLine = max(m_nBytesPerLine, minunit);

		//m_nBytesPerLine = min(m_nBytesPerLine, HV_MAX_COLS);

		// update display if anything has changed
		if(prevbpl != m_nBytesPerLine)
		{
			m_fCursorAdjustment = FALSE;

			// maintain the vertical scrollbar position, such that the 
			// offset at the top-left is always 'locked' at the same value.
			// this requires that we 
			if(m_nVScrollPos > 0)
				PinToOffset(m_nVScrollPinned);

			TRACEA("VSP2: %I64x - %d    (%I64x)\n", m_nVScrollPinned, m_nDataShift, m_nVScrollPos * m_nBytesPerLine+ m_nDataShift);
			//SetupScrollbars();
			
			RecalcPositions();
			FakeSize();
			SetupScrollbars();

			if(m_nVScrollPos > m_nVScrollMax)
			{
				m_nVScrollPos = m_nVScrollMax;
				//SetupScrollbars();
				FakeSize();
			}

			RepositionCaret();
			RefreshWindow();
			TRACEA("VSP3: %I64x - %I64x\n", m_nVScrollPos, m_nVScrollPos * m_nBytesPerLine);
		}

		return 0;
	}
	else if(m_fResizeAddr)
	{
		// the resizebar next to the address column is used to
		// set the m_nDataShift value
		int pos1 = (m_nAddressWidth - m_nHScrollPos) * m_nFontWidth + 
					(m_nHexPaddingLeft * m_nFontWidth) / 2;

		int oldds = m_nDataShift;

		int pos = mx / m_nFontWidth + m_nHScrollPos;
		m_nDataShift = (pos - pos1 / m_nFontWidth) / 2;
		
		m_nDataShift = max(0, m_nDataShift);		// don't allow negative
		m_nDataShift = min(m_nDataShift, m_nBytesPerLine-1);

		if(m_nDataShift != oldds)
		{
			TRACEA("addr: %d\n", m_nDataShift);

			RecalcPositions();
			FakeSize();
			SetupScrollbars();
			RepositionCaret();
			RefreshWindow();
		}
		return 0;
	}
	//
	//	Mouse not being held down, just set the cursor
	//
	else 
	{
		UINT lastht = m_HitTestHot;
		BOOKNODE *lasthl = m_HighlightHot;

		RECT hitrc;
		
		m_HitTestHot = HitTest(mx, my, &hitrc, &m_HighlightHot);
		
		//size_w curoff = (y + m_nVScrollPos) * m_nBytesPerLine + x;
		//else if(inrange(curoff, m_nSelectionStart, m_nSelectionEnd))

		if(m_HighlightCurrent == 0)
		{
			SetCursor(LoadCursor(NULL, CursorFromHittest(m_HitTestHot)));
		}
		else
		{

		}

		

		//TRACEA("ht = %d, last=%d\n", ht, m_LastHitTest);

		// over a bookmark's close button?
		//if( (ht != m_LastHitTest && (ht == HVHT_BOOKCLOSE || m_LastHitTest == HVHT_BOOKCLOSE)) || 0
			//(ht != m_LastHitTest && (ht == HVHT_BOOKCLOSE || m_LastHitTest == HVHT_BOOKCLOSE)) ||
		//	)
		if(lasthl != m_HighlightHot || lastht != m_HitTestHot)
		{
			RECT clip;

			if(lasthl != m_HighlightHot && lasthl)
			{
				BookmarkRect(&lasthl->bookmark, &clip);
				InvalidateRect(m_hWnd, &clip, FALSE);
			}

			CloseButton(NULL, &hitrc, &clip, 0);

			//TRACEA("redraw %d,%d-%d,%d!!\n", clip.left,clip.top,clip.right,clip.bottom);
			//RefreshWindow();
			InvalidateRect(m_hWnd, &clip, 0);
			UpdateWindow(m_hWnd);
		}
		
	}

	//if(offset != m_nCursorOffset)
	//	NotifyParent(HVN_CURSOR_CHANGE);

//	UpdateWindow(m_hWnd);

	return 0;
}

LRESULT HexView::OnSetCursor(WPARAM wParam, LPARAM lParam)
{
	if(LOWORD(lParam) == HTCLIENT)
	{
		// don't set the cursor for the client area, 
		// we will do this during WM_MOUSEMOVE
		return TRUE;
	}
	else
	{
		// set the default cursor for any non-client areas
		return DefWindowProc(m_hWnd, WM_SETCURSOR, wParam, lParam);
	}
}

HMENU HexView::CreateContextMenu()
{
	HMENU hMenu = CreatePopupMenu();

	// do we have a selection?
	UINT fSelection = (m_nSelectionStart == m_nSelectionEnd) ?
		MF_DISABLED| MF_GRAYED : MF_ENABLED;

	// is there text on the clipboard?
	UINT fClipboard = IsClipboardFormatAvailable(CF_TEXT) ?
		MF_ENABLED : MF_GRAYED | MF_DISABLED;

	UINT fCanUndo = CanUndo() ? MF_ENABLED : MF_GRAYED | MF_DISABLED;
	UINT fCanRedo = CanRedo() ? MF_ENABLED : MF_GRAYED | MF_DISABLED;

	AppendMenu(hMenu, MF_STRING|fCanUndo,				WM_UNDO, _T("&Undo"));
	AppendMenu(hMenu, MF_STRING|fCanRedo,				HVM_REDO, _T("&Redo"));
	AppendMenu(hMenu, MF_SEPARATOR,						0, 0);
	AppendMenu(hMenu, MF_STRING|fSelection,				WM_CUT,    _T("Cu&t"));
	AppendMenu(hMenu, MF_STRING|fSelection,				WM_COPY,   _T("&Copy"));
	AppendMenu(hMenu, MF_STRING|fClipboard,				WM_PASTE,  _T("&Paste"));
	AppendMenu(hMenu, MF_STRING|fSelection,				WM_CLEAR,  _T("&Delete"));
	AppendMenu(hMenu, MF_SEPARATOR,						0, 0);
	AppendMenu(hMenu, MF_STRING|MF_ENABLED,				HVM_SELECTALL, _T("&Select All"));

	return hMenu;
}

LRESULT HexView::OnContextMenu(HWND hwndParam, int x, int y)
{
	if(m_hUserMenu)
	{
		// if there is a user-specified context-menu, use it
		UINT uCmd = TrackPopupMenu(m_hUserMenu, TPM_RETURNCMD, x, y, 0, m_hWnd, 0);

		if(uCmd != 0)
			PostMessage(GetParent(m_hWnd), WM_COMMAND, MAKEWPARAM(uCmd, 0), (LPARAM)GetParent(m_hWnd));
	}
	else
	{
		// otherwise use the default
		HMENU hMenu = CreateContextMenu();
		UINT  uCmd  = TrackPopupMenu(hMenu, TPM_RETURNCMD, x, y, 0, m_hWnd, 0);

		if(uCmd != 0)
			PostMessage(m_hWnd, uCmd, 0, 0);
	}
	
	return DefWindowProc(m_hWnd, WM_CONTEXTMENU, (WPARAM)hwndParam, MAKELONG(x,y));
}

LRESULT HexView::OnRButtonDown(UINT nFlags, int x, int y)
{
	return 0;

	//m_Highlight->nNumItems = 0;
	/*HIGHLIGHT_PARAM hp = 

	AddHighlight(m_nSelectionStart, m_nSelectionEnd, 
		0,
		GetSysColor(COLOR_HIGHLIGHT)
		//0xCBF2FA
		//RGB(rand(),rand(),rand()),
		//RGB(rand(),rand(),rand())
		);*/

	return 0;

	POINT pt = {x,y};
	//ClientToScreen(m_hWnd, &pt);

	CreateWindowEx(WS_EX_TOOLWINDOW,
		_T("EDIT"), _T("text here"), WS_VISIBLE|WS_CAPTION|WS_SYSMENU|WS_CHILD|ES_MULTILINE,
		pt.x, pt.y, 300,200,m_hWnd, 0, 0, 0);

	RefreshWindow();
	return 0;
}

static double HuetoRGB(double m1, double m2, double h )
{
	if( h < 0 ) h += 1.0;
	if( h > 1 ) h -= 1.0;

	if( 6.0*h < 1 )
		return (m1+(m2-m1)*h*6.0);
	
	if( 2.0*h < 1 )
		return m2;

	if( 3.0*h < 2.0 )
		return (m1+(m2-m1)*((2.0/3.0)-h)*6.0);

	return m1;
}

COLORREF HSLtoRGB( double H, double S, double L )
{
	double r,g,b;
	double m1, m2;
	
	if(S==0)
	{
		r=g=b=L;
	} 
	else
	{
		if(L <=0.5)
			m2 = L*(1.0+S);
		else
			m2 = L+S-L*S;
		m1 = 2.0*L-m2;

		r = HuetoRGB(m1,m2,H+1.0/3.0);
		g = HuetoRGB(m1,m2,H);
		b = HuetoRGB(m1,m2,H-1.0/3.0);
		
	} 
	
	return RGB((BYTE)(r*255),(BYTE)(g*255),(BYTE)(b*255));
}

LRESULT HexView::OnLButtonUp(UINT nFlags, int x, int y)
{	
	// if a drag-drop operation never got started (mouse didn't move)
	// then clear current selection
	if(m_fStartDrag)
	{
		m_nSelectionStart = m_nSelectionEnd;
		m_fStartDrag = false;
		RefreshWindow();
		OnMouseMove(0, x, y);
	}

	// resize bar?
	if(m_fResizeBar || m_fResizeAddr)
	{
		m_fResizeBar = false;
		m_fResizeAddr = false;
		ReleaseCapture();
	}
	// normal mouse selection
	else if(m_nSelectionMode)
	{
		/*if(m_fHighlighting && m_nSelectionStart != m_nSelectionEnd)
		{
			//static double d = 0;
			//AddHighlight(m_nSelectionStart, m_nSelectionEnd, RGB(0,0,0), HSLtoRGB(d, 0.5, 0.6));
			//d+=0.02; if(d > 1) d = 0;

			AddHighlight(m_nSelectionStart, m_nSelectionEnd, 
				GetHexColour(HVC_BOOKMARK_FG),
				GetHexColour(HVC_BOOKMARK_BG));
			
			m_nSelectionStart = m_nSelectionEnd;
		}*/

	

		// cancel the scroll-timer if it is still running
		if(m_nScrollTimer != 0)
		{
			KillTimer(m_hWnd, m_nScrollTimer);
			m_nScrollTimer = 0;
		}

		if(m_nSelectionMode == SEL_NORMAL)
		{
			ReleaseCapture();
			m_nSelectionMode = SEL_NONE;
		}

		/*if(m_fDigDragDrop == false)
		{
			m_nSelectionStart = m_nSelectionEnd = m_nCursorOffset;
			RefreshWindow();
			m_fDigDragDrop = false;
		}*/

		/*if(m_fHighlighting)
		{
			RefreshWindow();
			UpdateWindow(m_hWnd);
		}*/
	}
	else
	{
		if(m_HighlightCurrent)
		{
			if(m_HitTestHot == HVHT_BOOKCLOSE)
			{
				RECT hir, clip;

				ReleaseCapture();

				CloseButton(NULL, &hir, &clip, 0);
				InvalidateRect(m_hWnd, &clip, 0);
				UpdateWindow(m_hWnd);
			}
		}

		m_HighlightCurrent = 0;
	}

	if(GetCapture() == m_hWnd)
	{
		ReleaseCapture();
	}

	return 0;
}

LRESULT HexView::OnMouseWheel(int nDelta)
{
#ifndef	SPI_GETWHEELSCROLLLINES	
#define SPI_GETWHEELSCROLLLINES   104
#endif

	int nScrollLines;

	SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nScrollLines, 0);

	if(nScrollLines == -1 || nScrollLines <= 1)
		nScrollLines = 3;

	int nScrollAmount = nDelta + m_nScrollMouseRemainder;
	m_nScrollMouseRemainder = nScrollAmount % (120 / nScrollLines);
	Scroll(0, -nScrollAmount * nScrollLines / 120);
	RepositionCaret();
	
	return 0;
}


```

`HexView/HexViewScroll.cpp`:

```cpp
//
//  HexViewScroll.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"
#include <limits.h>
#include <float.h>

#define WIN32_SCROLLBAR_MAX 0x7fff

//
//	Return number of leading zero-bits in specified dword
//
static int numlz(size_w num) 
{
	size_w  mask  = ~((size_w)-1 >> 1);
	int		count = 0;

	while((num & mask) == 0)
	{
		count++;
		mask >>= 1;
	}

	return count; 
} 

//
//	Wrapper around SetScrollInfo, performs scaling to allow massive 64bit scroll ranges
//	
BOOL SetScrollInfo64(HWND hwnd, int nBar, int fMask, size_w nMax, size_w nPos, int nPage, BOOL fRedraw)
{
	SCROLLINFO si = { sizeof(si), (UINT)fMask };

	// normal scroll range requires no adjustment
	if(nMax <= WIN32_SCROLLBAR_MAX)
	{
		si.nMin  = (int)0;
		si.nMax  = (int)nMax;
		si.nPage = (int)nPage;
		si.nPos  = (int)nPos;
	}
	// scale the scrollrange down into allowed bounds
	else
	{
		int shift = numlz(nMax);

		si.nMin  = (int)0;
		si.nMax  = (int)WIN32_SCROLLBAR_MAX;
		si.nPage = (int)nPage;
		si.nPos  = (int)((nPos << shift) / ((nMax << shift) / WIN32_SCROLLBAR_MAX));
	}

	SetScrollInfo(hwnd, nBar, &si, fRedraw);
	return TRUE;
}

//
//	Wrapper around GetScrollInfo, returns scrollbar position
//
size_w GetScrollPos64(HWND hwnd, int nBar, int fMask, size_w nMax)
{
	SCROLLINFO si = { sizeof(si), (UINT)fMask | SIF_PAGE};
	size_w     nPos;

	if(!GetScrollInfo(hwnd, nBar, &si))
		return 0;

	nPos = (fMask & SIF_TRACKPOS) ? si.nTrackPos : si.nPos;

	// normal scroll range requires no adjustment
	if(nMax <= WIN32_SCROLLBAR_MAX)
	{
		return nPos;
	}
	// scroll position at the very end
	else if(nPos == WIN32_SCROLLBAR_MAX - si.nPage + 1)
	{
		return nMax - si.nPage + 1;
	}
	// adjust the scroll position to be relative to maximum value
	else
	{
		int shift = numlz(nMax);

		return (((nMax << shift) / WIN32_SCROLLBAR_MAX) * nPos) >> shift;
	}
}

int HexView::CalcTotalWidth()
{
	int width = 0;
	
	width += CheckStyle(HVS_ADDR_INVISIBLE)  ? 0 : m_nAddressWidth;
	width += CheckStyle(HVS_HEX_INVISIBLE)   ? 0 : m_nHexPaddingLeft;
	width += CheckStyle(HVS_HEX_INVISIBLE)   ? 0 : m_nHexWidth;
	width += CheckStyle(HVS_ASCII_INVISIBLE) ? 0 : m_nHexPaddingRight;
	width += CheckStyle(HVS_ASCII_INVISIBLE) ? 0 : m_nBytesPerLine;
	width += 1;

	return width;
}

//
//	Set scrollbar positions and range
//
VOID HexView::SetupScrollbars()
{
	UINT fMask;

	//
	//	Vertical scrollbar
	//
	fMask = CheckStyle(HVS_ALWAYSVSCROLL) ? SIF_DISABLENOSCROLL : 0;
	fMask |= SIF_PAGE | SIF_POS | SIF_RANGE; 

	size_w nMax = NumFileLines(m_pDataSeq->size());
	
	if(nMax > 0)
		nMax -= 1;
	
	SetScrollInfo64(m_hWnd, SB_VERT, fMask, nMax, m_nVScrollPos, m_nWindowLines, TRUE);
	m_nVScrollMax = NumFileLines(m_pDataSeq->size()) - m_nWindowLines;// + 1;

	//
	//	Horizontal scrollbar
	//
	m_nTotalWidth = CalcTotalWidth();

	fMask = CheckStyle(HVS_ALWAYSHSCROLL) ? SIF_DISABLENOSCROLL : 0;
	fMask |= SIF_PAGE | SIF_POS | SIF_RANGE;

	SetScrollInfo64(m_hWnd, SB_HORZ, fMask, m_nTotalWidth - 1, m_nHScrollPos, m_nWindowColumns, TRUE);
	m_nHScrollMax = m_nTotalWidth - m_nWindowColumns;

	UpdateResizeBarPos();
	UpdatePinnedOffset();
}

//
//	Reposition the viewport so the specified offset is at the top of the display
//
BOOL HexView::ScrollTop(size_w offset)
{
	if(offset > m_pDataSeq->size())
		return FALSE;

	PinToOffset(offset);
	m_nVScrollPinned = offset;

	//m_nVScrollPos = min(offset / m_nBytesPerLine, m_nVScrollMax);

	SetupScrollbars();
	RefreshWindow();

	return TRUE;
}

//
//	Scroll to the specified offset - but only if cursor is outside the viewport
//
BOOL HexView::ScrollTo(size_w offset)
{
	bool fRedraw = false;

	if(offset > m_pDataSeq->size())
		return FALSE;

	if(offset / m_nBytesPerLine < m_nVScrollPos)
	{
		m_nVScrollPos = offset / m_nBytesPerLine;
		fRedraw = true;
	}
	else if(offset / m_nBytesPerLine > m_nVScrollPos + m_nWindowLines)
	{
		m_nVScrollPos = offset / m_nBytesPerLine - m_nWindowLines;
		fRedraw = true;
	}

	if(fRedraw)
	{
		SetupScrollbars();
		RefreshWindow();
	}

	return TRUE;
}

//
//	ScrollRgn
//
//	Scrolls the viewport in specified direction. If fReturnUpdateRgn is true, 
//	then a HRGN is returned which holds the client-region that must be redrawn 
//	manually. This region must be deleted by the caller using DeleteObject.
//
//  Otherwise ScrollRgn returns NULL and updates the entire window 
//
HRGN HexView::ScrollRgn(int dx, int dy, bool fReturnUpdateRgn)
{
	RECT clip;

	GetClientRect(m_hWnd, &clip);

	// scroll up
	if(dy < 0)
	{
		dy = -(int)min((size_w)-dy, m_nVScrollPos);
		clip.top = -dy * m_nFontHeight;
	}
	// scroll down
	else if(dy > 0)
	{
		dy = (int)min((size_w)dy, m_nVScrollMax-m_nVScrollPos);
		clip.bottom = (m_nWindowLines - dy) * m_nFontHeight;
	}

	// scroll left
	if(dx < 0)
	{
		dx = -(int)min(-dx, m_nHScrollPos);
		clip.left = -dx * m_nFontWidth * 4;
	}
	// scroll right
	else if(dx > 0)
	{
		dx = (int)min((unsigned)dx, (unsigned)m_nHScrollMax-m_nHScrollPos);
		clip.right = (m_nWindowColumns - dx - 4) * m_nFontWidth;
	}

	// adjust the scroll thumb position
	m_nHScrollPos += dx;
	m_nVScrollPos += dy;

	// ignore clipping rectangle if its a whole-window scroll
	if(fReturnUpdateRgn == false)
		GetClientRect(m_hWnd, &clip);

	// take margin into account
	//clip.left += LeftMarginWidth();

	// extend selection whilst scrolling
	/*if(m_fMouseDown)
	{
		m_nSelectionEnd += dy * m_nBytesPerLine + dx;
		InvalidateRange(m_nCursorOffset, m_nSelectionEnd);
		m_nCursorOffset = m_nSelectionEnd;
	}*/

	// perform the scroll
	if(dx != 0 || dy != 0)
	{
		ScrollWindowEx(
			m_hWnd, 
			-dx * m_nFontWidth, 
			-dy * m_nFontHeight,
			NULL,
			&clip, 
			0, 
			0, 
			SW_INVALIDATE
			);

		SetupScrollbars();

		if(fReturnUpdateRgn)
		{
			RECT client;

			GetClientRect(m_hWnd, &client);

			HRGN hrgnClient  = CreateRectRgnIndirect(&client);
			HRGN hrgnUpdate  = CreateRectRgnIndirect(&clip);

			// create a region that represents the area outside the
			// clipping rectangle (i.e. the part that is never scrolled)
			CombineRgn(hrgnUpdate, hrgnClient, hrgnUpdate, RGN_XOR);

			DeleteObject(hrgnClient);
			return hrgnUpdate;
		}
	}

	/*
	// Update the margin to keep line numbers in sync
	if(dy != 0)
	{
		GetClientRect(m_hWnd, &clip);
		clip.right = LeftMarginWidth();
		InvalidateRect(m_hWnd, &clip, 0);
	}*/	

	return NULL;
}

//
//	Scroll viewport in specified direction
//
VOID HexView::Scroll(int dx, int dy)
{
	// do a "normal" scroll - don't worry about invalid regions,
	// just scroll the whole window 
	ScrollRgn(dx, dy, false);
}

void HexView::UpdatePinnedOffset()
{
	m_nVScrollPinned = m_nVScrollPos * m_nBytesPerLine;
	
	// take the datashift into account!
	m_nVScrollPinned -= m_nDataShift;

}

//
//	Vertical scrollbar support
//
LRESULT HexView::OnVScroll(UINT nSBCode, UINT nPos)
{
	size_w oldpos = m_nVScrollPos;

	switch(nSBCode)
	{
	case SB_TOP:
		m_nVScrollPos = 0;
		RefreshWindow();
		break;

	case SB_BOTTOM:
		m_nVScrollPos = m_nVScrollMax;
		RefreshWindow();
		break;

	case SB_LINEUP:
		Scroll(0, -1);
		break;

	case SB_LINEDOWN:
		Scroll(0, 1);
		break;

	case SB_PAGEDOWN:
		Scroll(0, m_nWindowLines);
		break;

	case SB_PAGEUP:
		Scroll(0, -m_nWindowLines);
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:

		m_nVScrollPos = GetScrollPos64(m_hWnd, SB_VERT, SIF_TRACKPOS, NumFileLines(m_pDataSeq->size())-1);
		RefreshWindow();

		break;
	}

	if(oldpos != m_nVScrollPos)
	{
		SetupScrollbars();
		RepositionCaret();
	}

	return 0;
}

//
//	Horizontal scrollbar support
//
LRESULT HexView::OnHScroll(UINT nSBCode, UINT nPos)
{
	int oldpos = m_nHScrollPos;

	switch(nSBCode)
	{
	case SB_LEFT:
		m_nHScrollPos = 0;
		RefreshWindow();
		break;

	case SB_RIGHT:
		m_nHScrollPos = m_nHScrollMax;
		RefreshWindow();
		break;

	case SB_LINELEFT:
		Scroll(-1, 0);
		break;

	case SB_LINERIGHT:
		Scroll(1, 0);
		break;

	case SB_PAGELEFT:
		Scroll(-m_nWindowColumns, 0);
		break;

	case SB_PAGERIGHT:
		Scroll(m_nWindowColumns, 0);
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:

		m_nHScrollPos = nPos;
		RefreshWindow();
		break;
	}

	if(oldpos != m_nHScrollPos)
	{
		SetupScrollbars();
		RepositionCaret();
	}

	return 0;
}



```

`HexView/IDataObject.cpp`:

```cpp
//
//  IDataObject.cpp
//	Implementation of the IDataObject COM interface
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//


#define STRICT

#include <windows.h>
#include <tchar.h>
#include "trace.h"
#include "HexViewInternal.h"

// defined in ienumformat.cpp
HRESULT CreateEnumFormatEtc(UINT nNumFormats, FORMATETC *pFormatEtc, IEnumFORMATETC **ppEnumFormatEtc);

// defined in istream.cpp
IStream *CreateStream(HexView * pHexView);


class CDataObject : public IDataObject
{
	struct DataItem
	{
		FORMATETC FormatEtc;
		STGMEDIUM StgMedium;
		BOOL	  fOwnMedium;
		BOOL	  fDelayRender;
	};

public:
	//
    // IUnknown members
	//
    HRESULT __stdcall QueryInterface (REFIID iid, void ** ppvObject);
    ULONG   __stdcall AddRef (void);
    ULONG   __stdcall Release (void);
		
    //
	// IDataObject members
	//
    HRESULT __stdcall GetData				(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium);
    HRESULT __stdcall GetDataHere			(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium);
    HRESULT __stdcall QueryGetData			(FORMATETC *pFormatEtc);
	HRESULT __stdcall GetCanonicalFormatEtc (FORMATETC *pFormatEct,  FORMATETC *pFormatEtcOut);
    HRESULT __stdcall SetData				(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium,  BOOL fRelease);
	HRESULT __stdcall EnumFormatEtc			(DWORD      dwDirection, IEnumFORMATETC **ppEnumFormatEtc);
	HRESULT __stdcall DAdvise				(FORMATETC *pFormatEtc,  DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT __stdcall DUnadvise				(DWORD      dwConnection);
	HRESULT __stdcall EnumDAdvise			(IEnumSTATDATA **ppEnumAdvise);
	
	//
    // Constructor / Destructor
	//
    CDataObject(int max);
    ~CDataObject();
	
	HRESULT SetData(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium,  BOOL fRelease, BOOL fDelayed);
	void SetSnapShot(HexSnapShot *hss);
	
private:

	int     LookupFormatEtc(FORMATETC *pFormatEtc);
	HRESULT DeepCopyStgMedium(FORMATETC *pFormatEtc, STGMEDIUM *pSrcMed, STGMEDIUM *pDestMed);

    //
	// any private members and functions
	//
    LONG			m_lRefCount;

	FORMATETC	  *	m_pFormatEtc;
	STGMEDIUM	  *	m_pStgMedium;
	BOOL		  *	m_pOwnMedium;
	BOOL		  *	m_pDelayed;
	LONG			m_nNumFormats;
	LONG			m_nMaxFormats;
	
	HexSnapShot   * m_pSnapShot;
};

//
//	Constructor
//
CDataObject::CDataObject(int max)
{
	m_lRefCount   = 1;
	m_nNumFormats = 0;
	m_nMaxFormats = max;
	m_pSnapShot   = 0;
	
	m_pFormatEtc  = new FORMATETC[m_nMaxFormats];
	m_pStgMedium  = new STGMEDIUM[m_nMaxFormats];
	m_pOwnMedium  = new BOOL[m_nMaxFormats];
	m_pDelayed    = new BOOL[m_nMaxFormats];
}

//
//	Destructor
//
CDataObject::~CDataObject()
{
	LONG i;

	// check our BOOL array to see which STGMEDIUMs need releasing
	for(i = 0; i < m_nNumFormats; i++)
	{
		if(m_pOwnMedium[i])
			ReleaseStgMedium(&m_pStgMedium[i]);
	}

	// cleanup
	if(m_pFormatEtc) delete[] m_pFormatEtc;
	if(m_pStgMedium) delete[] m_pStgMedium;
	if(m_pOwnMedium) delete[] m_pOwnMedium;
	if(m_pDelayed)   delete[] m_pDelayed;
}

void CDataObject::SetSnapShot(HexSnapShot *hss)
{
	m_pSnapShot = hss;
}

//
//	IUnknown::AddRef
//
ULONG __stdcall CDataObject::AddRef(void)
{
    // increment object reference count
    return InterlockedIncrement(&m_lRefCount);
}

//
//	IUnknown::Release
//
ULONG __stdcall CDataObject::Release(void)
{
    // decrement object reference count
	LONG count = InterlockedDecrement(&m_lRefCount);
		
	if(count == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return count;
	}
}

//
//	IUnknown::QueryInterface
//
HRESULT __stdcall CDataObject::QueryInterface(REFIID iid, void **ppvObject)
{
    // check to see what interface has been requested
    if(iid == IID_IDataObject || iid == IID_IUnknown)
    {
        AddRef();
        *ppvObject = this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

HGLOBAL DupMem(HGLOBAL hMem)
{
	// lock the source memory object
	size_t  len    = GlobalSize(hMem);
	PVOID	source = GlobalLock(hMem);
	
	// create a fixed "global" block - i.e. just
	// a regular lump of our process heap
	PVOID   dest   = GlobalAlloc(GMEM_FIXED, len);

	memcpy(dest, source, len);

	GlobalUnlock(hMem);

	return dest;
}

//
//	Duplicate specified buffer as a HGLOBAL
//
HANDLE CopyBuffer(PVOID pmem, ULONG plen)
{
    void  *ptr;
	
    // allocate and lock a global memory buffer. Make it fixed
    // data so we don't have to use GlobalLock
    ptr = (void *)GlobalAlloc(GMEM_FIXED, plen);
	
    // copy the string into the buffer
    memcpy(ptr, pmem, plen);
	
    return ptr;
}


//
//	'Deep-copy' the STGMEDIUM structure from source to destination, 
//  calling OleDuplicateData to copy the HGLOBAL/GDI contents
//
HRESULT CDataObject::DeepCopyStgMedium(FORMATETC *pFormatEtc, STGMEDIUM *pSrcMed, STGMEDIUM *pDestMed)
{
	// duplicate the contents of the storage-medium
	switch(pSrcMed->tymed)
	{
	case TYMED_ISTREAM:

		// Bump the reference-count and copy the pointer across
		pDestMed->pstm = pSrcMed->pstm;
		pDestMed->pstm->AddRef();
		break;

	case TYMED_ISTORAGE:

		// Bump the reference-count and copy the pointer across
		pDestMed->pstg = pSrcMed->pstg;
		pDestMed->pstg->AddRef();
		break;

	case TYMED_HGLOBAL: 
	case TYMED_GDI: 
	case TYMED_MFPICT: 
	case TYMED_ENHMF:
	case TYMED_FILE:

		// duplicate the HGLOBAL/HBITMAP/whatever
		pDestMed->hGlobal = OleDuplicateData(pSrcMed->hGlobal, pFormatEtc->cfFormat, 0);
		break;

	default:
		return DV_E_FORMATETC;
	}

	// copy the remaining structure-members across
	pDestMed->tymed			 = pSrcMed->tymed;
	pDestMed->pUnkForRelease = NULL;

	// copy the IUnknownForRelease if present
	if(pSrcMed->pUnkForRelease)
	{
		pDestMed->pUnkForRelease = pSrcMed->pUnkForRelease;
		pDestMed->pUnkForRelease->AddRef();
	}

	return S_OK;
}

//
// Private routine. See if we can match the requested FORMATETC
//
int CDataObject::LookupFormatEtc(FORMATETC *pFormatEtc)
{
	for(int i = 0; i < m_nNumFormats; i++)
	{
		bool fMatchedLindex = true;
		
		// if the 'lindex' is >= 0 then we need to check this matches also
		if(pFormatEtc->lindex != -1 && pFormatEtc->lindex != m_pFormatEtc[i].lindex)
			fMatchedLindex = false;

		if((pFormatEtc->tymed    &  m_pFormatEtc[i].tymed)   &&
			pFormatEtc->cfFormat == m_pFormatEtc[i].cfFormat && 
			pFormatEtc->dwAspect == m_pFormatEtc[i].dwAspect &&
			fMatchedLindex
			)
		{
			return i;
		}
	}

	return -1;
}

//
//	IDataObject::GetData
//
HRESULT __stdcall CDataObject::GetData (FORMATETC *pFormatEtc, STGMEDIUM *pMedium)
{
	int idx;

	//
	// try to match the requested FORMATETC with one of our supported formats
	//
	if((idx = LookupFormatEtc(pFormatEtc)) == -1)
	{
		return DV_E_FORMATETC;
	}

	// check if we can do a delay-render of CF_TEXT
	if(pFormatEtc->cfFormat == CF_TEXT && m_pSnapShot != 0)
	{
		if((pFormatEtc->tymed & TYMED_HGLOBAL) && m_pStgMedium[0].hGlobal == 0)
		{
			pMedium->tymed			= TYMED_HGLOBAL;
			pMedium->pUnkForRelease = 0;

			// render snapshot as a HGLOBAL
			if((pMedium->hGlobal = m_pSnapShot->RenderAsHGlobal()) == 0)
				return E_OUTOFMEMORY;

			TRACEA("Delay rendering HGLOBAL!\n");
			return S_OK;
		}
	}

	// found a match! transfer the data into the supplied storage-medium
	return DeepCopyStgMedium(&m_pFormatEtc[idx], &m_pStgMedium[idx], pMedium);
}

//
//	IDataObject::GetDataHere
//
HRESULT __stdcall CDataObject::GetDataHere (FORMATETC *pFormatEtc, STGMEDIUM *pMedium)
{
	// GetDataHere is only required for IStream and IStorage mediums
	// It is an error to call GetDataHere for things like HGLOBAL and other clipboard formats
	//
	//	OleFlushClipboard 
	//
	return DATA_E_FORMATETC;
}

//
//	IDataObject::QueryGetData
//
//	Called to see if the IDataObject supports the specified format of data
//
HRESULT __stdcall CDataObject::QueryGetData (FORMATETC *pFormatEtc)
{
	TRACEA("%d %d\n", LookupFormatEtc(pFormatEtc), pFormatEtc->cfFormat);

	return (LookupFormatEtc(pFormatEtc) == -1) ? DV_E_FORMATETC : S_OK;
}

//
//	IDataObject::GetCanonicalFormatEtc
//
HRESULT __stdcall CDataObject::GetCanonicalFormatEtc (FORMATETC *pFormatEct, FORMATETC *pFormatEtcOut)
{
	// Apparently we have to set this field to NULL even though we don't do anything else
	pFormatEtcOut->ptd = NULL;
	return E_NOTIMPL;
}

//
//	IDataObject::SetData
//
//	Private routine
//
HRESULT CDataObject::SetData(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium,  BOOL fRelease, BOOL fDelayed)
{
	int idx;
	
	if(pFormatEtc->tymed != pMedium->tymed)
		return DV_E_TYMED;

	// see if we already have this format
	if((idx = LookupFormatEtc(pFormatEtc)) != -1)
	{
		// make sure we have enough room
		if(m_nNumFormats == m_nMaxFormats)
			return E_FAIL;

		// free the existing data
		if(m_pOwnMedium[idx])
			ReleaseStgMedium(&m_pStgMedium[idx]);
	}
	else
	{
		// add to the end 
		idx = m_nNumFormats++;
	}

	// copy the format across, and remember who owns it
	m_pFormatEtc[idx] = *pFormatEtc;
	m_pStgMedium[idx] = *pMedium;
	m_pOwnMedium[idx] =  fRelease;		
	m_pDelayed[idx]   =  fDelayed;

	return S_OK;
}

//
//	IDataObject::SetData
//
HRESULT __stdcall CDataObject::SetData (FORMATETC *pFormatEtc, STGMEDIUM *pMedium,  BOOL fRelease)
{
	return SetData(pFormatEtc, pMedium, fRelease, FALSE);
}

//
//	IDataObject::EnumFormatEtc
//
HRESULT __stdcall CDataObject::EnumFormatEtc (DWORD dwDirection, IEnumFORMATETC **ppEnumFormatEtc)
{
	if(dwDirection == DATADIR_GET)
	{
		// for Win2k+ you can use the SHCreateStdEnumFmtEtc API call, however
		// to support all Windows platforms we need to implement IEnumFormatEtc ourselves.
		return CreateEnumFormatEtc(m_nNumFormats, m_pFormatEtc, ppEnumFormatEtc);
	}
	else
	{
		// the direction specified is not support for drag+drop
		return E_NOTIMPL;
	}
}

//
//	IDataObject::DAdvise
//
HRESULT __stdcall CDataObject::DAdvise (FORMATETC *pFormatEtc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
	return OLE_E_ADVISENOTSUPPORTED;
}

//
//	IDataObject::DUnadvise
//
HRESULT __stdcall CDataObject::DUnadvise (DWORD dwConnection)
{
	return OLE_E_ADVISENOTSUPPORTED;
}

//
//	IDataObject::EnumDAdvise
//
HRESULT __stdcall CDataObject::EnumDAdvise (IEnumSTATDATA **ppEnumAdvise)
{
	return OLE_E_ADVISENOTSUPPORTED;
}

//
//	Helper function to set the specified DWORD as a HGLOBAL
//
HRESULT SetDataObjBuf(IDataObject *pDataObject, LPCTSTR szFormat, PVOID pData, DWORD nLength)
{
	// register the specified clipboard-format
	CLIPFORMAT  cfFormat = RegisterClipboardFormat(szFormat);
	
	FORMATETC   fmtetc   = { cfFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM   stgmed   = { TYMED_HGLOBAL, NULL, NULL };
	
	// allocate a HGLOBAL to store the data
	if((stgmed.hGlobal = GlobalAlloc(GPTR, nLength)) == 0)
		return E_FAIL;

	// copy the data across
	memcpy(stgmed.hGlobal, pData, nLength);

	// pass the HGLOBAL to the data-object
	return pDataObject->SetData(&fmtetc, &stgmed, TRUE);
}

//
//	Helper function to retrieve the specified DWORD as a HGLOBAL
//
HRESULT GetDataObjBuf(IDataObject *pDataObject, LPCTSTR szFormat, PVOID pData, DWORD nLength)
{
	// register the specified clipboard-format
	CLIPFORMAT  cfFormat = RegisterClipboardFormat(szFormat);
	
	FORMATETC   fmtetc   = { cfFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM   stgmed   = { TYMED_HGLOBAL, NULL, NULL };

	PVOID   ptmp;
	HRESULT success;

	// ask for the specified format
	if((success = pDataObject->GetData(&fmtetc, &stgmed)) == S_OK)
	{
		success = E_FAIL;

		// extract the data stored inside the HGLOBAL
		if((ptmp = GlobalLock(stgmed.hGlobal)) != 0)
		{
			memcpy(pData, ptmp, min(nLength, GlobalSize(stgmed.hGlobal)));
			GlobalUnlock(stgmed.hGlobal);

			success = S_OK;
		}

		ReleaseStgMedium(&stgmed);
	}

	return success;
}

HRESULT SetDataObjDword(IDataObject *pDataObject, LPCTSTR szFormat, DWORD_PTR dwValue)
{
	return SetDataObjBuf(pDataObject, szFormat, &dwValue, sizeof(dwValue));
}

HRESULT GetDataObjDword(IDataObject *pDataObject, LPCTSTR szFormat, DWORD_PTR *pdwValue)
{	
	return GetDataObjBuf(pDataObject, szFormat, pdwValue, sizeof(*pdwValue));
}


HGLOBAL HexView::BuildHGlobal(size_w offset, size_w length)
{
	HGLOBAL hMem;
	PBYTE	ptr;

	if((hMem = GlobalAlloc(GPTR, (ULONG)(length + 1))) == 0)
		return 0;

	if((ptr = (BYTE *)GlobalLock(hMem)) != 0)
	{
		GetData(offset, ptr, (ULONG)length);
		ptr[length] = '\0';
	}

	GlobalUnlock(hMem);
	return hMem;
}

HexSnapShot * HexView::CreateSnapshot(size_w offset, size_w length)
{
	HexSnapShot *hss;
	size_t desclen = 0;

	// anything less than 64kb and we won't bother
	//if(length < 0x10000)
	//	return NULL;

	// calculate how many snapshot items there are
	m_pDataSeq->takesnapshot(offset, length, 0, &desclen);
	
	// allocate a new snapshot object
	hss = new HexSnapShot(this);
	hss->m_desclist = new sequence::span_desc[desclen+1];
	hss->m_count    = desclen;
	hss->m_length	= length;
	
	// take the snapshot again, this time fill in the data
	m_pDataSeq->takesnapshot(offset, length, hss->m_desclist, &desclen);

	return hss;
}

//
//	HexView helper function for creating DataObjects
//
bool HexView::CreateDataObject (size_w offset, size_w length, IDataObject **ppDataObject)
{
	if(ppDataObject == 0)
		return false;

	// create the data-object
	CDataObject *pDataObject = new CDataObject(10);

	// load it with data!
	FORMATETC fmtetc = { CF_TEXT, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM stgmed = { TYMED_HGLOBAL };

	// set the CF_TEXT content as a HGLOBAL
	// The handle will be NULL - we will delay-render it only when necessary
	stgmed.hGlobal = NULL;	//BuildHGlobal(offset, length);
	pDataObject->SetData(&fmtetc, &stgmed, TRUE);

	// set the CF_TEXT content as an IStream
	/*fmtetc.tymed = TYMED_ISTREAM;
	stgmed.tymed = TYMED_ISTREAM;
	stgmed.pstm  = CreateStream(this);
	pDataObject->SetData(&fmtetc, &stgmed, TRUE);*/

	// set the RLE32HexBinary
	SetDataObjDword(pDataObject, CFSTR_HEX_DATALEN, (DWORD_PTR)SelectionSize());

	// set the HexHWND
	SetDataObjDword(pDataObject, CFSTR_HEX_HWND, (DWORD_PTR)m_hWnd);

	// create a snapshot of the specified range of data, but
	// store the *address* of it on the clipboard. This is fine
	// because the data is only valid within the context of *this* process
	HexSnapShot *hss;
		
	if((hss = CreateSnapshot(offset, length)) != 0)
	{
		SetDataObjBuf(pDataObject, CFSTR_HEX_SNAPSHOTPTR, &hss, sizeof(HexSnapShot *));
		pDataObject->SetSnapShot(hss);
	}
	
	// return the data-object back to the caller as a pure IDataObject interface
	*ppDataObject = pDataObject;
	return pDataObject ? true : false;
}
```

`HexView/IDropSource.cpp`:

```cpp
//
//  IDropSource.cpp
//	Implementation of the IDropSource COM interface
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//


#define STRICT

#include <windows.h>

class CDropSource : public IDropSource
{
public:
	//
    // IUnknown members
	//
    HRESULT __stdcall QueryInterface	(REFIID iid, void ** ppvObject);
    ULONG   __stdcall AddRef			(void);
    ULONG   __stdcall Release			(void);
		
    //
	// IDropSource members
	//
    HRESULT __stdcall QueryContinueDrag	(BOOL fEscapePressed, DWORD grfKeyState);
	HRESULT __stdcall GiveFeedback		(DWORD dwEffect);
	
	//
    // Constructor / Destructor
	//
    CDropSource();
    ~CDropSource();
	
private:

    //
	// private members and functions
	//
    LONG	   m_lRefCount;
};

//
//	Constructor
//
CDropSource::CDropSource() 
{
	m_lRefCount = 1;
}

//
//	Destructor
//
CDropSource::~CDropSource()
{
}

//
//	IUnknown::AddRef
//
ULONG __stdcall CDropSource::AddRef(void)
{
    // increment object reference count
    return InterlockedIncrement(&m_lRefCount);
}

//
//	IUnknown::Release
//
ULONG __stdcall CDropSource::Release(void)
{
    // decrement object reference count
	LONG count = InterlockedDecrement(&m_lRefCount);
		
	if(count == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return count;
	}
}

//
//	IUnknown::QueryInterface
//
HRESULT __stdcall CDropSource::QueryInterface(REFIID iid, void **ppvObject)
{
    // check to see what interface has been requested
    if(iid == IID_IDropSource || iid == IID_IUnknown)
    {
        AddRef();
        *ppvObject = this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//
//	CDropSource::QueryContinueDrag
//
//	Called by OLE whenever Escape/Control/Shift/Mouse buttons have changed
//
HRESULT __stdcall CDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
	// if the <Escape> key has been pressed since the last call, cancel the drop
	if(fEscapePressed == TRUE)
		return DRAGDROP_S_CANCEL;	

	// if the <LeftMouse> button has been released, then do the drop!
	if((grfKeyState & MK_LBUTTON) == 0)
		return DRAGDROP_S_DROP;

	// continue with the drag-drop
	return S_OK;
}

//
//	CDropSource::GiveFeedback
//
//	Return either S_OK, or DRAGDROP_S_USEDEFAULTCURSORS to instruct OLE to use the
//  default mouse cursor images
//
HRESULT __stdcall CDropSource::GiveFeedback(DWORD dwEffect)
{
	return DRAGDROP_S_USEDEFAULTCURSORS;
}

//
//	Helper routine to create an IDropSource object
//	
HRESULT CreateDropSource(IDropSource **ppDropSource)
{
	if(ppDropSource == 0)
		return E_INVALIDARG;

	*ppDropSource = new CDropSource();

	return (*ppDropSource) ? S_OK : E_OUTOFMEMORY;

}
```

`HexView/IDropTarget.cpp`:

```cpp
//
//  IDropTarget.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//


#define STRICT

#include <windows.h>
#include <tchar.h>
#include <shlobj.h>
#include "HexView.h"
#include "HexViewInternal.h"
#include "trace.h"

HRESULT GetDataObjDword(IDataObject *pDataObject, LPCTSTR szFormat, DWORD_PTR *pdwValue);
HRESULT GetDataObjBuf(IDataObject *pDataObject, LPCTSTR szFormat, PVOID pData, DWORD nLength);

static WORD g_cfFileDesc = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);


//
//	IDropTarget Interface
//
HRESULT WINAPI HexView::QueryInterface (REFIID iid, void ** ppvObject)
{
    if(iid == IID_IDropTarget || iid == IID_IUnknown)
    {
        AddRef();
        *ppvObject = this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

ULONG WINAPI HexView::AddRef (void)
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG WINAPI HexView::Release (void)
{
	LONG count = InterlockedDecrement(&m_lRefCount);
		
	if(count == 0)
		delete this;

	return count;
}

HRESULT WINAPI HexView::DragEnter(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
	// does the dataobject contain data we want?
    m_fAllowDrop = QueryDataObject(pDataObject);

	//if(m_nEditMode == HVMODE_READONLY)
	//	m_fAllowDrop = false;
	
	if(m_fAllowDrop)
    {
        // get the dropeffect based on keyboard state
        *pdwEffect = DropEffect(grfKeyState, pt, *pdwEffect);

        SetFocus(m_hWnd);

		m_nSelectionMode = SEL_DRAGDROP;

		// use a fake WM_MOUSEMOVE in order to position the caret
		ScreenToClient(m_hWnd, (POINT *)&pt);
		OnMouseMove(0, pt.x, pt.y);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    return S_OK;

}

HRESULT WINAPI HexView::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
	if(m_fAllowDrop)
    {
        *pdwEffect = DropEffect(grfKeyState, pt, *pdwEffect);

		// Use a fake WM_MOUSEMOVE to position the caret
		ScreenToClient(m_hWnd, (POINT *)&pt);
		OnMouseMove(0, pt.x, pt.y);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

	return S_OK;
}

HRESULT WINAPI HexView::DragLeave(void)
{
	// restore selection/cursor state
	m_nCursorOffset  = m_nSelectionEnd;
	
	// fake a 
	OnLButtonUp(0, 0, 0);
	RepositionCaret();

	m_nSelectionMode = SEL_NONE;

	NotifyParent(HVN_SELECTION_CHANGE);
	NotifyParent(HVN_CURSOR_CHANGE);

	return S_OK;
}

HRESULT WINAPI HexView::Drop(IDataObject * pDataObject, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
	DWORD dwAllowed  = *pdwEffect;
	HRESULT hresult  = S_OK;

	size_w delstart = SelectionStart();
	size_w dellen   = SelectionSize();

	// prevent drop over existing selection
	if(m_nCursorOffset >= delstart && m_nCursorOffset < delstart+dellen)
	{
		m_fAllowDrop = FALSE;
		m_nSelectionStart = m_nSelectionEnd = m_nCursorOffset;
		RefreshWindow();
	}
	
	// if the data format is OK, and we're not over an existing selection
    if(m_fAllowDrop)
    {
		m_pDataSeq->group();

		// detect the source HWND of the drag-drop
		HWND hwndSource;
		GetDataObjDword(pDataObject, CFSTR_HEX_HWND, (DWORD_PTR *)&hwndSource);

		*pdwEffect = DropEffect(grfKeyState, pt, dwAllowed);

		// do an 'optimized' move if we are dragging+dropping within the same document
		if(*pdwEffect == DROPEFFECT_MOVE && hwndSource == m_hWnd)
		{
			*pdwEffect = DROPEFFECT_NONE;
			m_pDataSeq->erase(delstart, dellen);
		}

		// import the data
		if(!DropData(pDataObject, false, true))
		{
			*pdwEffect = DROPEFFECT_NONE;
			hresult = E_UNEXPECTED;
		}

		m_pDataSeq->ungroup();

    }


	OnLButtonUp(0, 0, 0);

//	*pdwEffect		 = DROPEFFECT_NONE;
	m_nSelectionMode = SEL_NONE;

	NotifyParent(HVN_SELECTION_CHANGE);
	NotifyParent(HVN_CURSOR_CHANGE);

    return hresult;	
}

//
//	
//
bool HexView::QueryDataObject(IDataObject *pDataObject)
{
    FORMATETC fmtetc[] = 
	{ 
		{	CF_TEXT,		0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
		{	CF_TEXT,		0, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
		{	CF_HDROP,		0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
		{	g_cfFileDesc,	0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
		{	0 }
	};

	int i;

	for(i = 0; fmtetc[i].cfFormat; i++)
	{
        // does the data object support CF_TEXT using a HGLOBAL?
	   if(pDataObject->QueryGetData(&fmtetc[i]) == S_OK)
		   return true;
	}

	return false;
}


DWORD HexView::DropEffect(DWORD grfKeyState, POINTL pt, DWORD dwAllowed)
{
	DWORD dwEffect = 0;

	// 1. check "pt" -> do we allow a drop at the specified coordinates?
	
	// 2. work out that the drop-effect should be based on grfKeyState
	if(grfKeyState & MK_CONTROL)
	{
		dwEffect = dwAllowed & DROPEFFECT_COPY;
	}
	else if(grfKeyState & MK_SHIFT)
	{
		dwEffect = dwAllowed & DROPEFFECT_MOVE;
	}
	
	// 3. no key-modifiers were specified (or drop effect not allowed), so
	//    base the effect on those allowed by the dropsource
	if(dwEffect == 0)
	{
		if(dwAllowed & DROPEFFECT_MOVE) dwEffect = DROPEFFECT_MOVE;
		if(dwAllowed & DROPEFFECT_COPY) dwEffect = DROPEFFECT_COPY;
		
	}
	
	return dwEffect;
}

bool GetStgMedium(IDataObject *pDataObject, UINT cfFormat, UINT tymed, STGMEDIUM *stgmed)
{
	FORMATETC fmtetc = { (CLIPFORMAT)cfFormat, 0, DVASPECT_CONTENT, -1, tymed };

	return pDataObject->GetData(&fmtetc, stgmed) == S_OK ? true : false;
}

//
//	Import the dataobject to the current cursor position
//
bool HexView::DropData(IDataObject *pDataObject, bool fReplaceSelection, bool fSelectData)
{
	// construct a FORMATETC object
	//FORMATETC fmtetc = { CF_TEXT, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM stgmed;
	HexSnapShot *hss;

	// Find the snapshot object
	if(S_OK == GetDataObjBuf(pDataObject, CFSTR_HEX_SNAPSHOTPTR, &hss, sizeof(HexSnapShot *)))
	{
		HWND hwndSource = 0;

		GetDataObjDword(pDataObject, CFSTR_HEX_HWND, (DWORD_PTR *)&hwndSource);

		// make sure that the source of the snapshot is *this* HexView!!!
		if(hwndSource == m_hWnd)
		{
			// only bother if it's a large amount of data
			if(hss->m_length >= 0x10000)
			{
				// enter a 'snapshot' rather than a databuffer -----v
				EnterData(NULL, 0, true, fReplaceSelection, fSelectData, hss);
				return true;
			}
		}
	}

	// Snapshot didn't work. See if the dataobject contains any TEXT stored as a HGLOBAL
	if(GetStgMedium(pDataObject, CF_TEXT, TYMED_HGLOBAL, &stgmed))
	{
		PVOID  data;
		DWORD_PTR  len;

		if((data = GlobalLock(stgmed.hGlobal)) != 0)
		{
			// see if there's a RLE object as well
			if(GetDataObjDword(pDataObject, CFSTR_HEX_DATALEN, &len) != S_OK)
			{
				// if not then manually calculate the length of data
				len = (DWORD)strlen((char *)data);
			}
			
			// input and select (highlight) the data-buffer
			EnterData((BYTE *)data, len, true, fReplaceSelection, fSelectData);
			
			GlobalUnlock(stgmed.hGlobal);
		}
		
		ReleaseStgMedium(&stgmed);
		return true;
	}
	
	
	if(GetStgMedium(pDataObject, CF_HDROP, TYMED_HGLOBAL, &stgmed))
	{
		//PVOID data;
		//DWORD len;

		TCHAR szFile[MAX_PATH];

		if(DragQueryFile((HDROP)stgmed.hGlobal, 0, szFile, MAX_PATH))
		{
			ImportFile(szFile, 0);
		}

		/*if((data = GlobalLock(stgmed.hGlobal)) != 0)
		{
	DROPFILES *df = (DROPFILES *)hDrop;
	
	
	{
		TCHAR tmp[MAX_PATH];
		
		if(ResolveShortcut(buf, tmp, MAX_PATH))
			lstrcpy(buf,tmp);

		HexeditOpenFile(hwnd, buf);
	}
	
	DragFinish(hDrop);*/
			
			
//			GlobalUnlock(stgmed.hGlobal);
//		}
		
		ReleaseStgMedium(&stgmed);
		return true;
	}

	return false;
}

void HexView::RegisterDropWindow()
{
	IDropTarget *pDropTarget = this;
	pDropTarget->AddRef();

	// acquire a strong lock
	CoLockObjectExternal(pDropTarget, TRUE, FALSE);

	// tell OLE that the window is a drop target
	RegisterDragDrop(m_hWnd, pDropTarget);
}

void HexView::UnregisterDropWindow()
{
	IDropTarget *pDropTarget = this;

	// remove drag+drop
	RevokeDragDrop(m_hWnd);

	// remove the strong lock
	CoLockObjectExternal(pDropTarget, FALSE, TRUE);

	// release our own reference
	pDropTarget->Release();
}

```

`HexView/IEnumFormat.cpp`:

```cpp
//
//  IEnumFormat.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//
//  -----
//	Implementation of the IEnumFORMATETC interface
//
//	For Win2K and above look at the SHCreateStdEnumFmtEtc API call!!
//
//	Apparently the order of formats in an IEnumFORMATETC object must be
//  the same as those that were stored in the clipboard
//

#define STRICT

#include <windows.h>

class CEnumFormatEtc : public IEnumFORMATETC
{
public:

	//
	// IUnknown members
	//
	HRESULT __stdcall  QueryInterface (REFIID iid, void ** ppvObject);
	ULONG	__stdcall  AddRef (void);
	ULONG	__stdcall  Release (void);

	//
	// IEnumFormatEtc members
	//
	HRESULT __stdcall  Next  (ULONG celt, FORMATETC * rgelt, ULONG * pceltFetched);
	HRESULT __stdcall  Skip  (ULONG celt); 
	HRESULT __stdcall  Reset (void);
	HRESULT __stdcall  Clone (IEnumFORMATETC ** ppEnumFormatEtc);

	//
	// Construction / Destruction
	//
	CEnumFormatEtc(FORMATETC *pFormatEtc, int nNumFormats);
	~CEnumFormatEtc();

private:

	LONG		m_lRefCount;		// Reference count for this COM interface
	ULONG		m_nIndex;			// current enumerator index
	ULONG		m_nNumFormats;		// number of FORMATETC members
	FORMATETC * m_pFormatEtc;		// array of FORMATETC objects
};

//
//	"Drop-in" replacement for SHCreateStdEnumFmtEtc. Called by CDataObject::EnumFormatEtc
//
HRESULT CreateEnumFormatEtc(UINT nNumFormats, FORMATETC *pFormatEtc, IEnumFORMATETC **ppEnumFormatEtc)
{
	if(nNumFormats == 0 || pFormatEtc == 0 || ppEnumFormatEtc == 0)
		return E_INVALIDARG;

	*ppEnumFormatEtc = new CEnumFormatEtc(pFormatEtc, nNumFormats);

	return (*ppEnumFormatEtc) ? S_OK : E_OUTOFMEMORY;
}

//
//	Helper function to perform a "deep" copy of a FORMATETC
//
static void DeepCopyFormatEtc(FORMATETC *dest, FORMATETC *source)
{
	// copy the source FORMATETC into dest
	*dest = *source;
	
	if(source->ptd)
	{
		// allocate memory for the DVTARGETDEVICE if necessary
		dest->ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));

		// copy the contents of the source DVTARGETDEVICE into dest->ptd
		*(dest->ptd) = *(source->ptd);
	}
}

//
//	Constructor 
//
CEnumFormatEtc::CEnumFormatEtc(FORMATETC *pFormatEtc, int nNumFormats)
{
	m_lRefCount   = 1;
	m_nIndex      = 0;
	m_nNumFormats = nNumFormats;
	m_pFormatEtc  = new FORMATETC[nNumFormats];
	
	// copy the FORMATETC structures
	for(int i = 0; i < nNumFormats; i++)
	{	
		DeepCopyFormatEtc(&m_pFormatEtc[i], &pFormatEtc[i]);
	}
}

//
//	Destructor
//
CEnumFormatEtc::~CEnumFormatEtc()
{
	if(m_pFormatEtc)
	{
		for(ULONG i = 0; i < m_nNumFormats; i++)
		{
			if(m_pFormatEtc[i].ptd)
				CoTaskMemFree(m_pFormatEtc[i].ptd);
		}

		delete[] m_pFormatEtc;
	}
}

//
//	IUnknown::AddRef
//
ULONG __stdcall CEnumFormatEtc::AddRef(void)
{
    // increment object reference count
    return InterlockedIncrement(&m_lRefCount);
}

//
//	IUnknown::Release
//
ULONG __stdcall CEnumFormatEtc::Release(void)
{
    // decrement object reference count
	LONG count = InterlockedDecrement(&m_lRefCount);
		
	if(count == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return count;
	}
}

//
//	IUnknown::QueryInterface
//
HRESULT __stdcall CEnumFormatEtc::QueryInterface(REFIID iid, void **ppvObject)
{
    // check to see what interface has been requested
    if(iid == IID_IEnumFORMATETC || iid == IID_IUnknown)
    {
        AddRef();
        *ppvObject = this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//
//	IEnumFORMATETC::Next
//
//	If the returned FORMATETC structure contains a non-null "ptd" member, then
//  the caller must free this using CoTaskMemFree (stated in the COM documentation)
//
HRESULT __stdcall CEnumFormatEtc::Next(ULONG celt, FORMATETC *pFormatEtc, ULONG * pceltFetched)
{
	ULONG copied  = 0;

	// validate arguments
	if(celt == 0 || pFormatEtc == 0)
		return E_INVALIDARG;

	// copy FORMATETC structures into caller's buffer
	while(m_nIndex < m_nNumFormats && copied < celt)
	{
		DeepCopyFormatEtc(&pFormatEtc[copied], &m_pFormatEtc[m_nIndex]);
		copied++;
		m_nIndex++;
	}

	// store result
	if(pceltFetched != 0) 
		*pceltFetched = copied;

	// did we copy all that was requested?
	return (copied == celt) ? S_OK : S_FALSE;
}

//
//	IEnumFORMATETC::Skip
//
HRESULT __stdcall CEnumFormatEtc::Skip(ULONG celt)
{
	m_nIndex += celt;
	return (m_nIndex <= m_nNumFormats) ? S_OK : S_FALSE;
}

//
//	IEnumFORMATETC::Reset
//
HRESULT __stdcall CEnumFormatEtc::Reset(void)
{
	m_nIndex = 0;
	return S_OK;
}

//
//	IEnumFORMATETC::Clone
//
HRESULT __stdcall CEnumFormatEtc::Clone(IEnumFORMATETC ** ppEnumFormatEtc)
{
	HRESULT hResult;

	// make a duplicate enumerator
	hResult = CreateEnumFormatEtc(m_nNumFormats, m_pFormatEtc, ppEnumFormatEtc);

	if(hResult == S_OK)
	{
		// manually set the index state
		((CEnumFormatEtc *) *ppEnumFormatEtc)->m_nIndex = m_nIndex;
	}

	return hResult;
}


```

`HexView/IStream.cpp`:

```cpp
//
//  IStream.cpp
//	Implementation of the IStream COM interface
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//
//
//	TODO: Implement IStream::Read
//

#define STRICT

#include <windows.h>
#include "HexViewInternal.h"

#define DEFNAME L"Catch22 IStream"

class CStream : public IStream
{
public:
	//
    // IUnknown members
	//
    HRESULT __stdcall QueryInterface	(REFIID iid, void ** ppvObject);
    ULONG   __stdcall AddRef			(void);
    ULONG   __stdcall Release			(void);
		
    //
	// ISequentialStream members
	//
	HRESULT __stdcall Read				(void *pv, ULONG cb, ULONG *pcbRead);
	HRESULT __stdcall Write				(const void *pv, ULONG cb, ULONG *pcbWritten);

    //
	// IStream members
	//
	HRESULT __stdcall Seek				(LARGE_INTEGER  dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
	HRESULT __stdcall SetSize			(ULARGE_INTEGER libNewSize);
	HRESULT __stdcall CopyTo			(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
	HRESULT __stdcall Commit			(DWORD grfCommitFlags);
	HRESULT __stdcall Revert			(void);
	HRESULT __stdcall LockRegion		(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall UnlockRegion		(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT __stdcall Stat				(STATSTG *pstatstg, DWORD grfStatFlag);
	HRESULT __stdcall Clone				(IStream **ppstm);

	//
    // Constructor / Destructor
	//
    CStream(HexView *pHexView, HexSnapShot *pSnapShot);
    ~CStream();
	
private:

    //
	// private members and functions
	//
    LONG			m_lRefCount;

	STATSTG			m_statstg;			// each IStream needs one of these
	ULARGE_INTEGER	m_nOffset;			// offset within the stream
	ULARGE_INTEGER	m_nLength;			// length of the stream
	
	HexView			* m_pHexView;		// HexView that we will stream data from
	HexSnapShot		* m_pSnapShot;		// the snapshot of data that we stream
};

//
//	Constructor
//
CStream::CStream(HexView *hvp, HexSnapShot *ss) 
{
	m_lRefCount					= 1;
	m_pHexView					= hvp;
	m_pSnapShot					= ss;
	
	// stream metrics
	m_nOffset.QuadPart			= 0;
	m_nLength.QuadPart			= 0;//len;

	// stream status
	m_statstg.type				= STGTY_STREAM;		// IStream object
	m_statstg.cbSize.QuadPart	= 0;//len;				// Set to the length of our stream object
	m_statstg.grfLocksSupported = 0;				// Region locking not supported
	m_statstg.grfMode			= 0;				// access mode
	m_statstg.clsid				= CLSID_NULL;		// not used for IStreams
	m_statstg.grfStateBits		= 0;				// not used for IStreams
	m_statstg.reserved			= 0;				// reserved for

	CoFileTimeNow(&m_statstg.ctime);				// creation time
	CoFileTimeNow(&m_statstg.atime);				// last access time
	CoFileTimeNow(&m_statstg.mtime);				// last modify time
}

//
//	Destructor
//
CStream::~CStream()
{
}

//
//	IUnknown::AddRef
//
ULONG __stdcall CStream::AddRef(void)
{
    // increment object reference count
    return InterlockedIncrement(&m_lRefCount);
}

//
//	IUnknown::Release
//
ULONG __stdcall CStream::Release(void)
{
    // decrement object reference count
	LONG count = InterlockedDecrement(&m_lRefCount);
		
	if(count == 0)
	{
		delete this;
		return 0;
	}
	else
	{
		return count;
	}
}

//
//	IUnknown::QueryInterface
//
HRESULT __stdcall CStream::QueryInterface(REFIID iid, void **ppvObject)
{
    // check to see what interface has been requested
    if(iid == IID_IStream || iid == IID_IUnknown || iid == IID_ISequentialStream)
    {
        AddRef();
        *ppvObject = this;
        return S_OK;
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }
}

//
//	ISequentialStream::Read
//
HRESULT __stdcall CStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	ULONG available;

	if(pv == 0)
		return STG_E_INVALIDPOINTER;

	available = min(cb, (ULONG)(m_nLength.QuadPart - m_nOffset.QuadPart));

	// extract the data from HexView
	m_pSnapShot->Render((size_w)m_nOffset.QuadPart, (BYTE *)pv, available);

	m_nOffset.QuadPart += available;

	//m_pHexView->m_pDataSeq->rendersnapshot(
	//*pcbRead = m_pHexView->GetData((BYTE *)pv, m_nOffset.QuadPart, available);
	
	return S_OK;
}

//
//	ISequentialStream::Write
//
HRESULT __stdcall CStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
	if(pv == 0)
		return STG_E_INVALIDPOINTER;

	return E_NOTIMPL;
}

//
//	IStream::Seek
//
HRESULT __stdcall CStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
	switch(dwOrigin)
	{
	case STREAM_SEEK_SET:	m_nOffset.QuadPart = dlibMove.QuadPart;						 break;
	case STREAM_SEEK_CUR:	m_nOffset.QuadPart = m_nOffset.QuadPart + dlibMove.QuadPart; break;
	case STREAM_SEEK_END:	m_nOffset.QuadPart = m_nLength.QuadPart - dlibMove.QuadPart; break;
	}
	
	if(plibNewPosition)
		*plibNewPosition = m_nOffset;

	return S_OK;
}

//
//	IStream::SetSize
//
HRESULT __stdcall CStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return S_OK;
}

//
//	IStream::CopyTo
//
HRESULT __stdcall CStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	BYTE  buf[512];
	DWORD len, written;

	if(pcbRead)
		pcbRead->QuadPart = 0;

	if(pcbWritten)
		pcbWritten->QuadPart = 0;

	while(cb.QuadPart)
	{
		len = (ULONG)min(cb.QuadPart, 512);
		
		if(m_pHexView->GetData((size_w)m_nOffset.QuadPart, buf, len))
		{
			pstm->Write(buf, len, &written);

			if(pcbRead)
				pcbRead->QuadPart += len;

			if(pcbWritten)
				pcbWritten->QuadPart += written;
		}

		cb.QuadPart -= len;	
	}

	return S_OK;
}

//
//	IStream::Commit
//
HRESULT __stdcall CStream::Commit(DWORD grfCommitFlags)
{
	// Transacted mode is not supported
	return S_OK;
}

//
//	IStream::Revert
//
HRESULT __stdcall CStream::Revert()
{
	// Transacted mode is not supported
	return S_OK;
}

//
//	IStream::LockRegion
//
HRESULT __stdcall CStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	// locking is not supported
	return STG_E_INVALIDFUNCTION;
}

//
//	IStream::UnlockRegion
//
HRESULT __stdcall CStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	// locking is not supported
	return STG_E_INVALIDFUNCTION;
}

//
//	IStream::Stat
//
HRESULT __stdcall CStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
	if(pstatstg == 0)
		return STG_E_INVALIDPOINTER;

	// return our STATSTG to the caller
	m_statstg.cbSize.QuadPart = m_pHexView->Size();
	*pstatstg = m_statstg;

	switch(grfStatFlag)
	{
	case STATFLAG_DEFAULT:

		// allocate a new buffer for the name
		if((pstatstg->pwcsName = (WCHAR *)CoTaskMemAlloc(sizeof(DEFNAME))) == 0)
			return STG_E_INSUFFICIENTMEMORY;

		lstrcpyW(pstatstg->pwcsName, DEFNAME);
		break;

	case STATFLAG_NONAME:
		pstatstg->pwcsName = 0;
		break;

	default:
		return STG_E_INVALIDFLAG;
	}

	return S_OK;
}

//
//	IStream::Clone
//
HRESULT __stdcall CStream::Clone(IStream **ppstm)
{
	if(ppstm == 0)
		return STG_E_INVALIDPOINTER;

	// duplicate this stream
	CStream *pStream	= new CStream(m_pHexView, m_pSnapShot);
	pStream->m_nOffset  = m_nOffset;

	*ppstm = pStream;

	return S_OK;
}

IStream *CreateStream(HexView * pHexView)
{
	return new CStream(pHexView, 0);
}

```

`HexView/LICENCE.TXT`:

```TXT
Copyright (C) 2012 James Brown

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`HexView/README.md`:

```md
Catch22 HexView
---------------

HexView is a component of the HexView project. It is a custom win32 control which allows the viewing and editing of large files or memory buffers

The HexEdit and HexView programs and sourcecode are released under the MIT open source licence.

Please refer to LICENCE.TXT for licencing terms and conditions.

Sourcecode is available on github:

  www.github.com/strobejb/HexEdit


Using HexView
-------------

HexView requires Visual C++ 2010 (or later). 

HexView.h   - Main header and documentation
CHexView.h  - WTL header and wrapper class for HexView (not required for strict win32 projects)

```

`HexView/seqbase.h`:

```h
//
//  seqbase.h
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#ifndef SEQBASE_INCLUDED
#define SEQBASE_INCLUDED

//
//	Define the underlying string/character type of the sequence.
//
//	'seqchar' can be redefined to BYTE, WCHAR, ULONG etc 
//	depending on what kind of string you want your sequence to hold
//
typedef unsigned char	  seqchar;

#ifdef SEQUENCE64
typedef unsigned __int64  size_w;
#else
typedef unsigned long	  size_w;
#endif

#endif

```

`HexView/seqbuf.cpp`:

```cpp
//
//  seqbuf.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <new>
#include "sequence.h"
#include "trace.h"


bool read_data(HANDLE hFile, seqchar *buffer, size_w offset, size_w length)
{
	LARGE_INTEGER li;
	DWORD numread;

	li.QuadPart = offset;

	SetFilePointerEx(hFile, li, 0, FILE_BEGIN);
	return ReadFile(hFile, buffer, (DWORD)length * sizeof(seqchar), &numread, 0) ? true : false;
}

bool write_data(HANDLE hFile, seqchar *buffer, size_w offset, size_w length)
{
	LARGE_INTEGER li;
	DWORD numwritten;

	li.QuadPart = offset;

	SetFilePointerEx(hFile, li, 0, FILE_BEGIN);
	return WriteFile(hFile, buffer, (DWORD)length * sizeof(seqchar), &numwritten, 0) ? true : false;
}

size_w inline calc_index_base(size_w index)
{
	if(index < MEM_BLOCK_SIZE / 2)
	{
		return 0;
	}
	else
	{
		return ((index + MEM_BLOCK_SIZE / 4) & (~(MEM_BLOCK_SIZE / 2 - 1))) - (MEM_BLOCK_SIZE / 2);
	}
}

seqchar	* sequence::getptr(span *sptr)
{
	return buffer_list[sptr->buffer]->getptr(sptr->offset, sptr->length);
}

seqchar * sequence::buffer_control::getptr(size_w off, size_w len)
{
	size_t i;

	//return viewlist[0].buffer + off;
	
	// search for a buffer that already contains the requested range of data
	for(i = 0; i < MAX_VIEWS; i++)	
	{
		buffer_view *bv = &viewlist[i];
	
		if(bv->initialized && off >= bv->offset && off+len <= bv->offset+bv->length)
		{
			return bv->buffer + (off - bv->offset);
		}
	}

	// didn't find one, so map in a new view
	if(hFile)
	{
		buffer_view *bv = &viewlist[0];

		// find one that isn't initialized yet
		for(i = 0; i < MAX_VIEWS; i++)
		{
			bv = &viewlist[i];

			if(bv->initialized == false)
			{
				bv->buffer		= new seqchar[MEM_BLOCK_SIZE];
				bv->offset		= calc_index_base(off);
				bv->length		= MEM_BLOCK_SIZE;
				bv->initialized = true;
				
				read_data(hFile, bv->buffer, bv->offset, bv->length);
				return bv->buffer + (off - bv->offset);
			}
		}

		bv->offset = calc_index_base(off);
		read_data(hFile, bv->buffer, bv->offset, bv->length);

		return bv->buffer + (off - bv->offset);
	}
	
	//return buffer + off;
	return 0;
}

//
//	Initialize with a fixed buffer
//
bool sequence::buffer_control::init(const seqchar * buf, size_w len, bool copybuf) 
{
	if(copybuf && buf == 0)
		return false;

	// make sure we don't try to alloc something too big for new[]
	if(len >= 0xffffffff)
		return false;

	length	= len;
	maxsize	= len;
	ownbuf	= copybuf;

	viewlist[0].buffer = (seqchar *)buf;
	viewlist[0].length = len;
	viewlist[0].offset = 0;
	
	try 
	{
		if(buf == false || copybuf)
		{
			if((viewlist[0].buffer = new seqchar[(size_t)len]) == 0)
				return false;
		}

		// duplicate the source buffer
		if(copybuf)
		{
			memcpy(viewlist[0].buffer, buf, (size_t)len * sizeof(seqchar));
		}
	}
	catch(std::bad_alloc & ba) 
	{
		UNREFERENCED_PARAMETER(ba);
		return false;
	}

	viewlist[0].initialized = true;
	return true;
}

//
// Initialize with a fixed (empty) buffer
//
bool sequence::buffer_control::init(size_t max)
{
	if((viewlist[0].buffer = new seqchar[max]) == 0)
		return false;

	viewlist[0].initialized = true;
	viewlist[0].offset = 0;
	viewlist[0].length = max;
	
	maxsize = max;
	length  = 0;
	ownbuf  = true;
	
	return true;
}

bool sequence::buffer_control::append(const seqchar * buf, size_t len)
{
	if(length + len < maxsize)
	{
		buffer_view *bv = &viewlist[0];
		memcpy(bv->buffer + length, buf, len * sizeof(seqchar));
		length += len;
		return true;
	}
	else
	{
		return false;
	}
}

/*

bool sequence::get_file_handle(const TCHAR * filename, bool & readonly, HANDLE & hFile, size_w & length, DWORD & dwError)
{
	DWORD  dwAccess = GENERIC_READ;

	// if the file is physically readonly, then we cannot open
	// it for writing even if we wanted to (we will get 'access denied')
	if(GetFileAttributes(filename) & FILE_ATTRIBUTE_READONLY)
		readonly = true;

	if(!readonly)
		dwAccess |= GENERIC_WRITE;

	// open the file
	hFile = CreateFile(filename, dwAccess, FILE_SHARE_READ, 
		0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		dwError = GetLastError();

		// try again with read-only access if the file is already open
		if(dwError == ERROR_SHARING_VIOLATION || dwError == ERROR_ACCESS_DENIED)
		{
			readonly = true;
			
			hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, 
				0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		}
	}

	if(hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD sizelow, sizehigh;
	sizelow = GetFileSize(hFile, &sizehigh);
	length  = (size_w)sizelow | ((size_w)sizehigh << 32);
	
	return true;
}
*/


// initialize with a file
bool sequence::buffer_control::load(const TCHAR * filename, bool reado, bool quickload)
{
	DWORD dwAccess = GENERIC_READ;
	DWORD dwError  = S_OK;
	bool  success  = false;

	readonly = reado;

	// if the file is physically readonly, then we cannot open
	// it for writing even if we wanted to (we will get 'access denied')
	if(GetFileAttributes(filename) & FILE_ATTRIBUTE_READONLY)
		readonly = true;

	if(!readonly)
		dwAccess |= GENERIC_WRITE;

	// open the file
	hFile = CreateFile(filename, dwAccess, FILE_SHARE_READ, 
		0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		dwError = GetLastError();

		// try again with read-only access if the file is already open
		if(dwError == ERROR_SHARING_VIOLATION || dwError == ERROR_ACCESS_DENIED)
		{
			readonly = true;
			
			hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, 
				0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		}
	}

	if(hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD sizelow, sizehigh;
	sizelow = GetFileSize(hFile, &sizehigh);
	length  = (size_w)sizelow;
#ifdef SEQUENCE64
	length |= ((size_w)sizehigh << 32);
#endif
	maxsize = length;
	ownbuf  = true;

	// only quickload if file is < 10Mb
	if(quickload == false && length < 1024*1024*10)
	{
		if(init(NULL, length, false))
		{
			if(read_data(hFile, viewlist[0].buffer, 0, length))
			{
				success = true;
			}
			else
			{
				dwError = GetLastError();
			}
		}
		else
		{
			dwError = ERROR_OUTOFMEMORY;
		}

		CloseHandle(hFile);
		hFile = 0;
	}
	else
	{
		success = true;
	}

	if(!success)
	{
		delete[] viewlist[0].buffer;
		CloseHandle(hFile);
	}

	SetLastError(dwError);
	return success;
}

HANDLE sequence::_handle()
{
	if(buffer_list.size() > 1)
	{
		for(size_t i = 0; i < buffer_list.size(); i++)
		{
			buffer_control *bc = buffer_list[i];
			HANDLE h = buffer_list[i]->hFile;
			h = h;
		}
		return buffer_list[1]->hFile;
	}

	return NULL;
}

void sequence::buffer_control::free()
{
	size_t i;

	if(hFile)
		CloseHandle(hFile);

	for(i = 0; ownbuf && i < MAX_VIEWS; i++)
	{
		if(viewlist[i].initialized)
		{
			delete[] viewlist[i].buffer;
		}
	}
}

bool allocfile(HANDLE hFile, size_w length)
{
	LARGE_INTEGER set;
	LARGE_INTEGER result;

	set.QuadPart = length;
	
	// allocate space for desired file size
	if(SetFilePointerEx(hFile, set, &result, FILE_BEGIN))
	{
		if(SetEndOfFile(hFile))
		{
			return true;
		}
	}

	return false;
}

HANDLE allocfile(const TCHAR *filename, size_w length)
{
	HANDLE hFile;

	hFile = CreateFile(filename, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, 0, 0);

	if(allocfile(hFile, length))
		return hFile;

	CloseHandle(hFile);
	return 0;
}

HANDLE alloctmpfile(TCHAR *tmpfilename, int namelen, size_w length)
{
	HANDLE hFile;

	if(namelen < MAX_PATH)
		return 0;

	if(GetTempPath(namelen, tmpfilename))
	{
		if(GetTempFileName(tmpfilename, TEXT("~HX"), 0, tmpfilename))
		{
			hFile = allocfile(tmpfilename, length);

			if(hFile != INVALID_HANDLE_VALUE)
			{
				return hFile;
			}

			DeleteFile(tmpfilename);
		}
	}

	return 0;
}

HANDLE createfile(const TCHAR *filename, size_w length)
{
	TCHAR tmpfile[MAX_PATH];
	const TCHAR *newname = filename;
	HANDLE hFile;

	if(filename == 0)
	{
		GetTempPath(MAX_PATH, tmpfile);
		GetTempFileName(tmpfile, TEXT("~HX"), 0, tmpfile);

		newname = tmpfile;
	}

	hFile = CreateFile(newname, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_ALWAYS, 0, 0);

	if(hFile != INVALID_HANDLE_VALUE)
	{
		LARGE_INTEGER set;
		LARGE_INTEGER result;

		set.QuadPart = length;
	
		// allocate space for desired file size
		if(SetFilePointerEx(hFile, set, &result, FILE_BEGIN))
		{
			if(SetEndOfFile(hFile))
			{
				return hFile;
			}
		}

		CloseHandle(hFile);
	}

	if(filename == 0)
		DeleteFile(tmpfile);

	return 0;
}
```

`HexView/sequence.cpp`:

```cpp
//
//  sequence.cpp
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <tchar.h>
#include "sequence.h"

bool   allocfile(HANDLE hFile, size_w length);
HANDLE allocfile(const TCHAR *filename, size_w length);
HANDLE alloctmpfile(TCHAR *tmpfilename, int namelen, size_w length);

bool write_data(HANDLE hFile, seqchar *buffer, size_w offset, size_w length);

#ifdef DEBUG_SEQUENCE

char debugfile[_MAX_PATH];
void odebug(const char *fmt, ...)
{
	va_list varg;
	va_start(varg, fmt);
	char buf[512];

	vsprintf(buf, fmt, varg);
	OutputDebugString(buf);

	va_end(varg);
}

void debug(const char *fmt, ...)
{
	FILE *fp;
	va_list varg;
	va_start(varg, fmt);

	if((fp = fopen(debugfile, "a")) != 0)
	{
		vfprintf(fp, fmt, varg);
		fclose(fp);
	}

	va_end(varg);
}

#else
#define debug
#define odebug
#endif


sequence::sequence ()
{
	record_action(action_invalid, 0);
	
	refCount		= 1;
	head = tail		= 0;
	sequence_length = 0;
	group_id		= 0;
	group_refcount	= 0;

	head			= new span(0, 0, 0);
	tail			= new span(0, 0, 0);
	head->next		= tail;
	tail->prev		= head;

#ifdef DEBUG_SEQUENCE
	SYSTEMTIME st;
	GetLocalTime(&st);
	sprintf(debugfile, "seqlog-%04d%02d%02d-%02d%02d%0d.txt", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
#endif

	init();
}

sequence::~sequence ()
{
	clear();

	delete head;
	delete tail;
}

bool sequence::isreadonly()
{
	if(origfile_id == -1)
		return false;

	buffer_control *bc = buffer_list[origfile_id];

	if(bc->readonly)
		return true;
	else
		return false;
}

bool sequence::init ()
{
	sequence_length  = 0;
	origfile_id		 = -1;
	origfile_name[0] = '\0';
	can_quicksave    = false;

	if(!alloc_modifybuffer(0x10000))
		return false;

	record_action(action_invalid, 0);
	group_id		= 0;
	group_refcount	= 0;
	undoredo_index	= 0;
	undoredo_length = 0;
	undoredo_datalength = 0;

	return true;
}

//
//	initialize with a buffer
//
bool sequence::init (const seqchar *buffer, size_t length, bool duplicate_buf /*=false*/)
{
	if(!clear())
		return false;

	buffer_control *bc = new buffer_control();
	bc->init(buffer, length, duplicate_buf);

	bc->id = (int)buffer_list.size();		// assign the id
	buffer_list.push_back(bc);

	/*buffer_control *bc = alloc_modifybuffer(length);
	memcpy(bc->buffer, buffer, length * sizeof(seqchar));
	bc->length = length;*/

	span *sptr = new span(0, length, bc->id, tail, head);
	head->next = sptr;
	tail->prev = sptr;

	sequence_length = length;
	return true;
}

sequence::span * sequence::loadspan(const TCHAR *filename, bool readonly, bool quickload)
{
	buffer_control *bc = new buffer_control();
	
	if(!bc->load(filename, readonly, quickload))
	{
		delete bc;
		return false;
	}

	bc->id = buffer_list.size();		// assign the id

	span *sptr = new span(0, bc->length, bc->id);

	if(sptr)
	{
		buffer_list.push_back(bc);
		return sptr;
	}
	else
	{
		delete bc;
		return false;
	}
}

//
//	Initialize from an on-disk file
//
bool sequence::open(const TCHAR *filename, bool readonly, bool quickload)
{
	if(!clear())
		return false;

	buffer_control *bc = new buffer_control();
	
	if(bc->load(filename, readonly, quickload))
	{
		bc->id = buffer_list.size();		// assign the id
		buffer_list.push_back(bc);

		span *sptr = new span(0, bc->length, bc->id, tail, head);
		head->next = sptr;
		tail->prev = sptr;

		sequence_length = bc->length;
		
		origfile_id = bc->id;
		_tcscpy_s(origfile_name, MAX_PATH, filename);

		can_quicksave    = true;

		return true;
	}
	else
	{
		return false;
	}
}

//bool sequence::link(const TCHAR *filename)
//{
	//return false;
//}

bool sequence::writespan(HANDLE hFile, size_w index, sequence::span *sptr)
{
	size_w copylen   = sptr->length;
	size_w srcoff	 = sptr->offset;

	buffer_control *bc = buffer_list[sptr->buffer];

	// copy the span data into supplied memory buffer
	while(copylen > 0)
	{
		seqchar *src;
		size_w len = min(copylen, 100);
			
		if((src = bc->getptr(srcoff, len)) == 0)
			return false;

		// write the data!!!
		if(write_data(hFile, src, index, len) == false)
		{
			return false;
		}

		index   += len;
		srcoff  += len;
		copylen -= len;
	}

	return true;
}

bool sequence::saveto(HANDLE hFile, bool quicksave)
{	
	span *sptr;
	size_w spanindex;

	// start at the start
	if((sptr = spanfromindex(0, &spanindex)) == 0)
		return false;

	// loop over every span
	for( ; sptr->next; sptr = sptr->next)
	{
		buffer_control *bc = buffer_list[sptr->buffer];

		if(quicksave == false || bc->id != origfile_id)
		{
			if(writespan(hFile, spanindex, sptr) == false)
			{
				return false;
			}
		}

		spanindex += sptr->length;
	}

	return true;
}

bool sequence::save(const TCHAR * filename /* = 0*/)
{
	HANDLE hFile = 0;
	bool quicksave = true;
	TCHAR newname[MAX_PATH] = { '\0' };

	// can't overwrite existing file if it doesn't exist
	if(origfile_id == -1 && filename == 0)
		return false;

	//
	//	We can only 'quicksave' if no inserts/deletes have
	//  occurred and we are saving back to the current file
	//
	if(can_quicksave && origfile_id == -1 && filename == 0)
	{
		// if we *can* quicksave, then write back to the
		// original file handle
		hFile = buffer_list[origfile_id]->hFile;

		// do we need more space??
		
		//
		quicksave = true;
	}
	else
	{
		// has a new filename been specified?
		if(filename)
		{
			// open the new file?
			hFile = allocfile(filename, sequence_length);
		}
		// overwriting current file?
		else
		{
			// create a temporary file and return the 'newname'
			hFile = alloctmpfile(newname, MAX_PATH, sequence_length);
		}

		quicksave = false;
	}

	if(hFile == 0)
		return false;

	// save the file to the specified HANDLE
	// if quicksave is 'true' then only those portions that
	// have changed will be written
	if(saveto(hFile, quicksave))
	{
		// reallocate the file??? truncate file if necessary
		allocfile(hFile, sequence_length);

		if(quicksave == false)
			CloseHandle(hFile);

		// remember the file we have open, because we need to re-open it
		TCHAR origfile[MAX_PATH];
		_tcscpy_s(origfile, MAX_PATH, origfile_name);

		// clear the sequence. This *should* free all buffers
		// and close all open file handles
		clear();

		// if we had to create a temporary, then move it back over the original
		if(newname[0])// == '\0')
			MoveFileEx(newname, origfile, MOVEFILE_REPLACE_EXISTING|MOVEFILE_COPY_ALLOWED);
			
		// reinitialize with the new file
		if(filename == 0)
		{
			_tcscpy_s(newname, MAX_PATH, origfile);
			filename = newname;
		}
			
		return open(filename, false);
	}

	return false;
}

//
//	Initialize from an on-disk file
//
//bool sequence::save(TCHAR *filename)
//{
//	return false;
//}

template <class type>
void sequence::clear_vector (type &vectorobject)
{
	for(size_t i = 0; i < vectorobject.size(); i++)
	{
		delete vectorobject[i];
	}
}

void sequence::clearstack (eventstack &dest)
{
	for(size_t i = 0; i < dest.size(); i++)
	{
		dest[i]->free();
		delete dest[i];
	}

	dest.clear();
}

void sequence::debug1 ()
{
	span *sptr;

	for(sptr = head; sptr; sptr = sptr->next)
	{
		//char *buffer = (char *)buffer_list[sptr->buffer]->viewlist[0].buffer;
		//printf("%.*s", sptr->length, buffer + sptr->offset);

		char *buffer = (char *)getptr(sptr);
		printf("%.*s", (int)sptr->length, buffer);
	}

	printf("\n");
}

void sequence::debug2 ()
{
	span *sptr;

	printf("**********************\n");
	for(sptr = head; sptr; sptr = sptr->next)
	{
		//char *buffer = (char *)buffer_list[sptr->buffer]->buffer;
		char *buffer = (char *)getptr(sptr);
		
		printf("[%d] [%4d %4d] %.*s\n", 
			(int)sptr->id,
			(int)sptr->offset, 
			(int)sptr->length,
			(int)sptr->length, buffer);
	}

	printf("-------------------------\n");

	for(sptr = tail; sptr; sptr = sptr->prev)
	{
		//char *buffer = (char *)buffer_list[sptr->buffer]->buffer;
		char *buffer = (char *)getptr(sptr);
		
		printf("[%d] [%4d %4d] %.*s\n", 
			(int)sptr->id,
			(int)sptr->offset, 
			(int)sptr->length,
			(int)sptr->length, 
			buffer + sptr->offset);
	}

	printf("**********************\n");

	for(sptr = head; sptr; sptr = sptr->next)
	{
		//char *buffer = (char *)buffer_list[sptr->buffer]->buffer;
		char *buffer = (char *)getptr(sptr);
		printf("%.*s", (int)sptr->length, buffer + sptr->offset);
	}

	printf("\nsequence length = %d chars\n", (int)sequence_length);
	printf("\n\n");
}
/*
//
//	Allocate a buffer and add it to our 'buffer control' list
//
sequence::buffer_control* sequence::alloc_buffer (size_t maxsize)
{
	buffer_control *bc;

	if((bc = new buffer_control) == 0)
		return 0;

	// allocate a new buffer of byte/wchar/long/whatever
	if((bc->buffer  = new seqchar[maxsize]) == 0)
	{
		delete bc;
		return 0;
	}

	bc->length  = 0;
	bc->maxsize = maxsize;
	bc->id		= buffer_list.size();		// assign the id

	buffer_list.push_back(bc);

	return bc;
}
*/
sequence::buffer_control* sequence::alloc_modifybuffer (size_t maxsize)
{
	buffer_control *bc = new buffer_control();
	
	if((bc->init(maxsize)) == 0)
		return 0;

	bc->id = buffer_list.size();		// assign the id
	buffer_list.push_back(bc);

	modifybuffer_id  = bc->id;
	modifybuffer_pos = 0;

	return bc;
}

//
//	Import the specified range of data into the sequence so we have our own private copy
//
bool sequence::import_buffer (const seqchar *buf, size_t len, size_w *buffer_offset)
{
	buffer_control *bc;
	
	// get the current modify-buffer
	bc = buffer_list[modifybuffer_id];

	*buffer_offset = bc->length;

	// if there isn't room then allocate a new modify-buffer
	if(!bc->append(buf, len))
	{
		if((bc = alloc_modifybuffer(len + 0x10000)) == 0)
			return false;
		
		*buffer_offset = bc->length;
		bc->append(buf, len);
		
		// make sure that no old spans use this buffer
		record_action(action_invalid, 0);
	}

	if(bc == 0)
		return false;

	// import the data
//	memcpy(bc->buffer + bc->length, buf, len * sizeof(seqchar));
	
	//bc->length += len;

	return true;
}


//
//	sequence::spanfromindex
//
//	search the spanlist for the span which encompasses the specified index position
//
//	index		- character-position index
//	*spanindex  - index of span within sequence
//
sequence::span* sequence::spanfromindex (size_w index, size_w *spanindex = 0) const
{
	span * sptr;
	size_w curidx = 0;
	
	// scan the list looking for the span which holds the specified index
	for(sptr = head->next; sptr->next; sptr = sptr->next)
	{
		if(index >= curidx && index < curidx + sptr->length)
		{
			if(spanindex) 
				*spanindex = curidx;

			return sptr;
		}

		curidx += sptr->length;
	}

	// insert at tail
	if(sptr && index == curidx)
	{
		*spanindex = curidx;
		return sptr;
	}

	return 0;
}

void sequence::swap_spanrange(span_range *src, span_range *dest)
{
	if(src->boundary)
	{
		if(!dest->boundary)
		{
			src->first->next = dest->first;
			src->last->prev  = dest->last;
			dest->first->prev = src->first;
			dest->last->next  = src->last;
		}
	}
	else
	{
		if(dest->boundary)
		{
			src->first->prev->next = src->last->next;
			src->last->next->prev  = src->first->prev;
		}
		else
		{
			src->first->prev->next = dest->first;
			src->last->next->prev  = dest->last;
			dest->first->prev = src->first->prev;
			dest->last->next = src->last->next;
		}	
	}
}

void sequence::restore_spanrange (span_range *range, bool undo_or_redo)
{
	if(range->boundary)
	{
		span *first = range->first->next;
		span *last  = range->last->prev;

		// unlink spans from main list
		range->first->next = range->last;
		range->last->prev  = range->first;

		// store the span range we just removed
		range->first = first;
		range->last  = last;
		range->boundary = false;
	}
	else
	{
		span *first = range->first->prev;
		span *last  = range->last->next;

		// are we moving spans into an "empty" region?
		// (i.e. inbetween two adjacent spans)
		if(first->next == last)
		{
			// move the old spans back into the empty region
			first->next = range->first;
			last->prev  = range->last;

			// store the span range we just removed
			range->first  = first;
			range->last   = last;
			range->boundary  = true;
		}
		// we are replacing a range of spans in the list,
		// so swap the spans in the list with the one's in our "undo" event
		else
		{
			// find the span range that is currently in the list
			first = first->next;
			last  = last->prev;

			// unlink the the spans from the main list
			first->prev->next = range->first;
			last->next->prev  = range->last;

			// store the span range we just removed
			range->first = first;
			range->last  = last;
			range->boundary = false;
		}
	}

	// update the 'sequence length' and 'quicksave' states
	std::swap(range->sequence_length,    sequence_length);
	std::swap(range->quicksave,			 can_quicksave);

	undoredo_index	= range->index;

	if(range->act == action_erase && undo_or_redo == true || 
		range->act != action_erase && undo_or_redo == false)
	{
		undoredo_length = range->length;
		undoredo_datalength = range->length;
	}
	else
	{
		undoredo_length = 0;
		undoredo_datalength = range->length;
	}
}

//
//	sequence::undoredo
//
//	private routine used to undo/redo spanrange events to/from 
//	the sequence - handles 'grouped' events
//
bool sequence::undoredo (eventstack &source, eventstack &dest)
{
	span_range *range = 0;
	size_t group_id;

	if(source.empty())
		return false;

	// make sure that no "optimized" actions can occur
	record_action(action_invalid, 0);

	group_id = source.back()->group_id;

	do
	{
		// remove the next event from the source stack
		range = source.back();
		source.pop_back();

		// add event onto the destination stack
		dest.push_back(range);

		// do the actual work
		restore_spanrange(range, source == undostack ? true : false);
	}
	while(!source.empty() && (source.back()->group_id == group_id && group_id != 0));

	return true;
}

void sequence::clear_undo()
{
	// very bad to do this!
	//clearstack(undostack);
	//clearstack(redostack);
}

// 
//	UNDO the last action
//
bool sequence::undo ()
{
	debug("Undo\n");
	return undoredo(undostack, redostack);
}

//
//	REDO the last UNDO
//
bool sequence::redo ()
{
	debug("Redo\n");
	return undoredo(redostack, undostack);
}

//
//	Will calling sequence::undo change the sequence?
//
bool sequence::canundo () const
{
	return undostack.size() != 0;
}

//
//	Will calling sequence::redo change the sequence?
//
bool sequence::canredo () const
{
	return redostack.size() != 0;
}

//
//	Group repeated actions on the sequence (insert/erase etc)
//	into a single 'undoable' action
//
void sequence::group()
{
	if(group_refcount == 0)
	{
		if(++group_id == 0)
			++group_id;

		group_refcount++;
	}
}

//
//	Close the grouping
//
void sequence::ungroup()
{
	if(group_refcount > 0)
		group_refcount--;
}

//
//	Return logical length of the sequence
//
size_w sequence::size () const
{
	return sequence_length;
}

//
//	sequence::initundo
//
//	create a new (empty) span range and save the current sequence state
//
sequence::span_range* sequence::initundo (size_w index, size_w length, action act)
{
	span_range *event = new span_range (
								sequence_length, 
								index,
								length,
								act,
								can_quicksave, 
								group_refcount ? group_id : 0
								);

	undostack.push_back(event);
	
	return event;
}

sequence::span_range* sequence::stackback(eventstack &source, size_t idx)
{
	size_t length = source.size();
	
	if(length > 0 && idx < length)
	{
		return source[length - idx - 1];
	}
	else
	{
		return 0;
	}
}

void sequence::record_action (action act, size_w index)
{
	lastaction_index = index;
	lastaction       = act;
}

bool sequence::can_optimize (action act, size_w index)
{
	return (lastaction == act && lastaction_index == index);
}

//
//	sequence::insert_worker
//
//	'buf' can be NULL - in which case only the spans in the piecetable are modified,
//						but no data is appended to the modify buffer. Used by
//						'snapshot' injection.
//	
bool sequence::insert_worker (size_w index, const seqchar *buf, size_w length, action act)
{
	span *		sptr;
	size_w		spanindex;
	size_w		modbuf_offset = 0;
	span_range	newspans;
	size_w		insoffset;

	if(index > sequence_length || length == 0)
		return false;

	// find the span that the insertion starts at
	if((sptr = spanfromindex(index, &spanindex)) == 0)
		return false;

	// ensure there is room in the modify buffer...
	// allocate a new buffer if necessary and then invalidate span cache
	// to prevent a span using two buffers of data
	if(buf && !import_buffer(buf, (size_t)length, &modbuf_offset))
		return false;

	debug("Inserting: idx=%d len=%d %.*s\n", index, length, length, buf);

	clearstack(redostack);
	insoffset = index - spanindex;

	// special-case #1: inserting at the end of a prior insertion, at a span-boundary
	if(insoffset == 0 && can_optimize(act, index))
	{
		// simply extend the last span's length
		span_range *event = undostack.back();
		sptr->prev->length	+= length;
		event->length		+= length;
	}
	// general-case #1: inserting at a span boundary?
	else if(insoffset == 0)
	{
		//
		// Create a new undo event; because we are inserting at a span
		// boundary there are no spans to replace, so use a "span boundary"
		//
		span_range *oldspans = initundo(index, length, act);
		oldspans->spanboundary(sptr->prev, sptr);
		
		// allocate new span in the modify buffer
		newspans.append(new span(
			modbuf_offset, 
			length, 
			modifybuffer_id)
			);
		
		// link the span into the sequence
		swap_spanrange(oldspans, &newspans);
	}
	// general-case #2: inserting in the middle of a span
	else
	{
		//
		//	Create a new undo event and add the span
		//  that we will be "splitting" in half
		//
		span_range *oldspans = initundo(index, length, act);
		oldspans->append(sptr);

		//	span for the existing data before the insertion
		newspans.append(new span(
							sptr->offset, 
							insoffset, 
							sptr->buffer)
						);

		// make a span for the inserted data
		newspans.append(new span(
							modbuf_offset, 
							length, 
							modifybuffer_id)
						);

		// span for the existing data after the insertion
		newspans.append(new span(
							sptr->offset + insoffset, 
							sptr->length - insoffset, 
							sptr->buffer)
						);

		swap_spanrange(oldspans, &newspans);
	}

	sequence_length += length;

	return true;
}

//
//	sequence::insert
//
//	Insert a buffer into the sequence at the specified position.
//	Consecutive insertions are optimized into a single event
//
bool sequence::insert (size_w index, const seqchar *buf, size_w length)
{
	bool append = index == sequence_length ? true : false;

	if(insert_worker(index, buf, length, action_insert))
	{
		if(can_quicksave && !append)
			can_quicksave = false;

		record_action(action_insert, index + length);
		return true;
	}
	else
	{
		return false;
	}
}

//
//	sequence::insert
//
//	Insert specified character-value into sequence
//
bool sequence::insert (size_w index, const seqchar val)
{
	return insert(index, &val, 1);
}

//
//	sequence::deletefromsequence
//
//	Remove + delete the specified *span* from the sequence
//
void sequence::deletefromsequence(span **psptr)
{
	span *sptr = *psptr;
	sptr->prev->next = sptr->next;
	sptr->next->prev = sptr->prev;

	memset(sptr, 0, sizeof(span));
	delete sptr;
	*psptr = 0;
}

//
//	sequence::erase_worker
//
bool sequence::erase_worker (size_w index, size_w length, action act)
{
	span		*sptr;
	span_range	 oldspans;
	span_range	 newspans;
	span_range	*event;
	size_w		 spanindex;
	size_w		 remoffset;
	size_w		 removelen;
	bool		 append_spanrange;	

	debug("Erasing: idx=%d len=%d\n", index, length);

	// make sure we stay within the range of the sequence
	if(length == 0 || length > sequence_length || index > sequence_length - length)
		return false;

	// find the span that the deletion starts at
	if((sptr = spanfromindex(index, &spanindex)) == 0)
		return false;

	// work out the offset relative to the start of the *span*
	remoffset = index - spanindex;
	removelen = length;

	//
	//	can we optimize?
	//
	//	special-case 1: 'forward-delete'
	//	erase+replace operations will pass through here
	//
	if(index == spanindex && can_optimize(act, index))
	{
		event = stackback(undostack, act == action_replace ? 1 : 0);
		event->length	+= length;
		append_spanrange = true;

		if(frag2 != 0)
		{
			if(length < frag2->length)
			{
				frag2->length	-= length;
				frag2->offset	+= length;
				sequence_length -= length;
				return true;
			}
			else
			{
				if(act == action_replace)
					stackback(undostack, 0)->last = frag2->next;

				removelen	-= sptr->length;
				sptr = sptr->next;
				deletefromsequence(&frag2);
			}
		}
	}
	//
	//	special-case 2: 'backward-delete'
	//	only erase operations can pass through here
	//
	else if(index + length == spanindex + sptr->length && can_optimize(action_erase, index+length))
	{
		event = undostack.back();
		event->length	+= length;
		event->index	-= length;
		append_spanrange = false;

		if(frag1 != 0)
		{
			if(length < frag1->length)
			{
				frag1->length	-= length;
				frag1->offset	+= 0;
				sequence_length -= length;
				return true;
			}
			else
			{
				removelen -= frag1->length;
				deletefromsequence(&frag1);
			}
		}
	}
	else
	{
		append_spanrange = true;
		frag1 = frag2 = 0;

		if((event = initundo(index, length, act)) == 0)
			return false;
	}

	//
	//	general-case 2+3
	//
	clearstack(redostack);

	// does the deletion *start* mid-way through a span?
	if(remoffset != 0)
	{
		// split the span - keep the first "half"
		newspans.append(new span(sptr->offset, remoffset, sptr->buffer));
		frag1 = newspans.first;
		
		// have we split a single span into two?
		// i.e. the deletion is completely within a single span
		if(remoffset + removelen < sptr->length)
		{
			// make a second span for the second half of the split
			newspans.append(new span(
							sptr->offset + remoffset + removelen, 
							sptr->length - remoffset - removelen, 
							sptr->buffer)
							);

			frag2 = newspans.last;
		}

		removelen -= min(removelen, (sptr->length - remoffset));

		// archive the span we are going to replace
		oldspans.append(sptr);
		sptr = sptr->next;	
	}

	// we are now on a proper span boundary, so remove
	// any further spans that the erase-range encompasses
	while(removelen > 0 && sptr != tail)
	{
		// will the entire span be removed?
		if(removelen < sptr->length)
		{
			// split the span, keeping the last "half"
			newspans.append(new span(
						sptr->offset + removelen, 
						sptr->length - removelen, 
						sptr->buffer)
						);

			frag2 = newspans.last;
		}

		removelen -= min(removelen, sptr->length);

		// archive the span we are replacing
		oldspans.append(sptr);
		sptr = sptr->next;
	}

	// for replace operations, update the undo-event for the
	// insertion so that it knows about the newly removed spans
	if(act == action_replace && !oldspans.boundary)
		stackback(undostack, 0)->last = oldspans.last->next;

	swap_spanrange(&oldspans, &newspans);
	sequence_length -= length;

	if(append_spanrange)
		event->append(&oldspans);
	else
		event->prepend(&oldspans);

	return true;
}

//
//	sequence::erase 
//
//  "removes" the specified range of data from the sequence. 
//
bool sequence::erase (size_w index, size_w len)
{
	if(erase_worker(index, len, action_erase))
	{
		can_quicksave = false;
		record_action(action_erase, index);
		return true;
	}
	else
	{
		return false;
	}
}

//
//	sequence::erase
//
//	remove single character from sequence
//
bool sequence::erase (size_w index)
{
	return erase(index, 1);
}

//
//	sequence::replace
//
//	A 'replace' (or 'overwrite') is a combination of erase+inserting
//  (first we erase a section of the sequence, then insert a new block
//  in it's place). 
//
//	Doing this as a distinct operation (erase+insert at the 
//  same time) is really complicated, so I just make use of the existing 
//  sequence::erase and sequence::insert and combine them into action. We
//	need to play with the undo stack to combine them in a 'true' sense.
//
bool sequence::replace(size_w index, const seqchar *buf, size_w length, size_w erase_length)
{
	size_w remlen = 0;

	debug("Replacing: idx=%d len=%d %.*s\n", index, length, length, buf);

	// make sure operation is within allowed range
	if(index > sequence_length || MAX_SEQUENCE_LENGTH - index < length)
		return false;

	// for a "replace" which will overrun the sequence, make sure we 
	// only delete up to the end of the sequence
	remlen = min(sequence_length - index, erase_length);

	// combine the erase+insert actions together
	group();

	// first of all remove the range
	if(remlen > 0 && index < sequence_length && !erase_worker(index, remlen, action_replace))
	{
		ungroup();
		return false;
	}
	
	// then insert the data
	if(insert_worker(index, buf, length, action_replace))
	{
		ungroup();
		record_action(action_replace, index + length);
		return true;
	}
	else
	{
		// failed...cleanup what we have done so far
		ungroup();
		record_action(action_invalid, 0);

		span_range *range = undostack.back();
		undostack.pop_back();
		restore_spanrange(range, true);
		delete range;

		return false;
	}
}

//
//	sequence::replace
//
//	overwrite with the specified buffer
//
bool sequence::replace (size_w index, const seqchar *buf, size_w length)
{
	return replace(index, buf, length, length);
}

//
//	sequence::replace
//
//	overwrite with a single character-value
//
bool sequence::replace (size_w index, const seqchar val)
{
	return replace(index, &val, 1);
}

//
//	sequence::append
//
//	very simple wrapper around sequence::insert, just inserts at
//  the end of the sequence
//
bool sequence::append (const seqchar *buf, size_w length)
{
	return insert(size(), buf, length);
}

//
//	sequence::append
//
//	append a single character to the sequence
//
bool sequence::append (const seqchar val)
{
	return append(&val, 1);
}

//
//	sequence::clear
//
//	empty the entire sequence, clear undo/redo history etc
//
bool sequence::clear ()
{
	span *sptr, *tmp;
	
	// delete all spans in the sequence
	for(sptr = head->next; sptr != tail; sptr = tmp)
	{
		tmp = sptr->next;
		delete sptr;
	}

	// re-link the head+tail
	head->next = tail;
	tail->prev = head;

	// delete everything in the undo/redo stacks
	clearstack(undostack);
	clearstack(redostack);

	// delete all memory-buffers
	for(size_t i = 0; i < buffer_list.size(); i++)
	{
		//delete[] buffer_list[i]->buffer;
		delete   buffer_list[i];
	}

	buffer_list.clear();
	sequence_length = 0;
	can_quicksave   = false;

	// make sure to setup all the filedescriptors again to 'empty'!
	init();
	return true;
}

//
//	sequence::render
//
//	render the specified range of data (index, len) and store in 'dest'
//
//	Returns number of chars copied into destination
//
size_t sequence::render(size_w index, seqchar *dest, size_t length, seqchar_info *infobuf /*= 0*/) const
{
	size_w spanindex = 0;
	size_t total = 0;
	span  *sptr;

	// find span to start rendering at
	if((sptr = spanfromindex(index, &spanindex)) == 0)
		return false;

	// might need to start mid-way through the first span
	spanindex = index - spanindex;

	// copy each span's referenced data in succession
	while(length && sptr != tail)
	{
		size_w copylen   = min(sptr->length - spanindex, length);
	//	seqchar *source  = buffer_list[sptr->buffer]->buffer;

		buffer_control *bc = buffer_list[sptr->buffer];
		size_w srcoff = sptr->offset + spanindex;

		// copy the span data into supplied memory buffer
		while(copylen > 0)
		{
			seqchar *src;
			size_t len = (size_t)min(copylen, 100);
			
			if((src = bc->getptr(srcoff, len)) == 0)
				return 0;

			// copy the memory
			memcpy(dest, src, len * sizeof(seqchar));

			// return buffer metadata
			if(infobuf)
			{
				for(size_t i = 0; i < len; i++)
				{
					infobuf[i].buffer	= sptr->buffer;
					infobuf[i].userdata = 0;
				}

				infobuf += len;
			}

			dest    += len;
			srcoff  += len;
			copylen -= len;
			length	-= len;
			total	+= len;
		}

		//spanindex = 0;

		/*
		// copy memory
		memcpy(dest, source + sptr->offset + spanindex, copylen * sizeof(seqchar));

		if(infobuf)
		{
			for(size_t i = 0; i < copylen; i++)
			{
				infobuf[i].buffer	= sptr->buffer;
				infobuf[i].userdata = 0;
			}

			infobuf += copylen;
		}
		dest	+= copylen;
		length	-= copylen;
		total	+= copylen;
		*/

		// next span!
		sptr = sptr->next;
		spanindex = 0;
	}

	return total;
}

//
//	sequence::peek
//
//	return single element at specified position in the sequence
//
seqchar sequence::peek(size_w index) const
{
	seqchar   value;
	return render(index, &value, 1) ? value : 0;
}

//
//	sequence::poke
//
//	modify single element at specified position in the sequence
//
bool sequence::poke(size_w index, seqchar value) 
{
	return replace(index, &value, 1);
}

//
//	sequence::operator[] const
//
//	readonly array access
//
seqchar sequence::operator[] (size_w index) const
{
	return peek(index);
}

//
//	sequence::operator[] 
//
//	read/write array access
//
sequence::ref sequence::operator[] (size_w index)
{
	return ref(this, index);
}

//
//	sequence::breakopt
//
//	Prevent subsequent operations from being optimized (coalesced) 
//  with the last.
//
void sequence::breakopt()
{
	lastaction = action_invalid;
}

seqchar&  sequence::getlastmodref(size_w *offset /*=0*/)
{
	static seqchar tmp = 0;
	buffer_control *bc;

	if(offset) *offset = 0;
	
	if(modifybuffer_id < buffer_list.size())
	{
		bc = buffer_list[modifybuffer_id];

		if(bc && bc->length > 0)
		{
			if(offset)
				*offset = lastaction_index;

			return bc->viewlist[0].buffer[bc->length - 1];
		}
	}

	return tmp;
}

//
//
//
bool sequence::takesnapshot(size_w index, size_w length, span_desc *desclist, size_t *desclen)
{
	span *sptr;
	size_w spanindex;
	size_t i = 0;

	if(desclen == 0)
		return false;

	// find span to start rendering at
	if((sptr = spanfromindex(index, &spanindex)) == 0)
		return false;

	while(length > 0 && sptr)
	{
		size_w tmplen = sptr->length - (index - spanindex);
		tmplen = min(tmplen, length);

		if(i < *desclen && desclist)
		{
			desclist[i].offset = sptr->offset + (index - spanindex);
			desclist[i].length = tmplen;
			desclist[i].buffer = sptr->buffer;
		}

		spanindex += sptr->length;
		index = spanindex;
		length -= tmplen;

		sptr = sptr->next;
		i++;
	}

	*desclen = i;
	return true;
}

bool sequence::rendersnapshot(size_t count, span_desc *desclist, size_w offset, seqchar *buf, size_t length)
{
	size_t i   = 0; 
	size_w ioff = 0;
	size_w offadjust = 0;

	// convert linear offset to a span-relative offset
	for(ioff = 0; ioff < offset; )
	{
		offadjust = offset - ioff;

		if(offadjust < desclist[i].length)
		{
			ioff += offadjust;
		}
		else
		{
			ioff += desclist[i].length;
			i++;
		}
	}

	// now render each span into the buffer
	for( ; i < count; i++)
	{
		size_w off = desclist[i].offset + offadjust;
		size_w len = desclist[i].length - offadjust;
		buffer_control *bc = buffer_list[desclist[i].buffer];

		while(len > 0)
		{
			size_t tlen = (size_t)min(len, 100);
			seqchar * src = bc->getptr(off, tlen);
			
			memcpy(buf, src, tlen * sizeof(seqchar));
			
			buf += tlen;
			len -= tlen;
			off += tlen;
		}

		offadjust = 0;
	}

	return true;
}

bool sequence::injectsnapshot(size_w index, span_desc *desclist, size_t desclen)
{
	span_range oldspan;
	span_range newspans;

	span *empty;
	
	if((empty = spanfromindex(index, 0)) == 0)
		return false;

	// 
	oldspan.append(empty);

	// build a spanrange to insert
	for(size_t i = 0; i < desclen; i++)
	{
		span *sptr;
		
		if((sptr = new span(desclist[i].offset, desclist[i].length, desclist[i].buffer)) == 0)
			return false;

		newspans.append(sptr);
	}

	swap_spanrange(&oldspan, &newspans);

	return true;
}

bool sequence::insert_snapshot(size_w index, size_w length, span_desc *desclist, size_t desclen)
{
	breakopt();

	if(insert(index, (seqchar *)NULL, length))
	{
		can_quicksave = false;

		injectsnapshot(index, desclist, desclen);
		breakopt();
		return true;
	}
	else
	{
		return false;
	}
}

bool sequence::replace_snapshot(size_w index, size_w length, span_desc *desclist, size_t desclen)
{
	breakopt();

	if(replace(index, (seqchar *)NULL, length))
	{
		injectsnapshot(index, desclist, desclen);
		breakopt();
		return true;
	}
	else
	{
		return false;
	}
}


size_w sequence::replace_file(const TCHAR *filename, size_w index, bool linkto)
{
	breakopt();

	span *sptr = loadspan(filename, true);

	if(replace(index, (seqchar *)NULL, sptr->length))
	{
		span *empty;
	
		span_range oldspan;
		span_range newspans;

		if((empty = spanfromindex(index, 0)) == 0)
			return false;

		oldspan.append(empty);

		empty->buffer = sptr->buffer;

		newspans.append(sptr);

		swap_spanrange(&oldspan, &newspans);
		
		return sptr->length;
	}

	return 0;
}

size_w sequence::insert_file(const TCHAR *filename, size_w index, bool linkto)
{
	breakopt();

	span *sptr = loadspan(filename, true);

	if(insert(index, (seqchar *)NULL, sptr->length))
	{
		span *empty;
	
		span_range oldspan;
		span_range newspans;

		if((empty = spanfromindex(index, 0)) == 0)
			return false;

		oldspan.append(empty);

		empty->buffer = sptr->buffer;

		newspans.append(sptr);

		swap_spanrange(&oldspan, &newspans);
		return sptr->length;
	}

	return 0;
}
```

`HexView/sequence.h`:

```h
//
//  sequence.h
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

#ifndef SEQUENCE_INCLUDED
#define SEQUENCE_INCLUDED

#include <vector>

#include "seqbase.h"

const size_w MAX_SEQUENCE_LENGTH = ((size_w)(-1) / sizeof(seqchar));

const size_w MEM_BLOCK_SIZE = 0x40000;	// 256kb view size

struct seqchar_info
{
	size_t	buffer;
	size_t	userdata;
};
/*
class seqfile
{
	seqfile();
	virtual ~seqfile();

	virtual open(LPCTSTR szFileName) = 0;
	virtual save() = 0;
	virtual read(size_w ) = 0;
};*/

//
//	sequence class!
//
class sequence
{
public:
	// forward declare the nested helper-classes
	class			span;
	class			span_range;
	class			buffer_control;
	class			iterator;
	class			ref;
	struct			span_desc;
	struct			span_desc_list;
	enum			action;

public:

	// sequence construction
	sequence();
	~sequence();

	long addref()
	{
		return InterlockedIncrement(&refCount);
	}

	long release()
	{
		long count = InterlockedDecrement(&refCount);
		
		if(count == 0)
			delete this;

		return count;
	}

	//
	// initialize with a file
	//
	bool		init();
	bool		open(const TCHAR *filename, bool readonly = false, bool quickload = false);
	////bool		link(const TCHAR *filename);
	size_w		replace_file(const TCHAR *filename, size_w index, bool linkto);
	size_w		insert_file(const TCHAR *filename, size_w index, bool linkto);

	//bool		link(const TCHAR *filename);
	bool		save(const TCHAR * filename = 0);
	bool		clear();
	bool		isreadonly();

	//
	// initialize from an in-memory buffer
	//
	bool		init(const seqchar *buffer, size_t length, bool duplicate_buf = false);

	//
	//	sequence statistics
	//
	size_w		size() const;
	
	//
	// sequence manipulation 
	//
	bool		insert (size_w index, const seqchar *buf, size_w length);
	bool		insert (size_w index, const seqchar  val, size_w count);
	bool		insert (size_w index, const seqchar  val);
	bool		replace(size_w index, const seqchar *buf, size_w length, size_w erase_length);
	bool		replace(size_w index, const seqchar *buf, size_w length);
	bool		replace(size_w index, const seqchar  val, size_w count);
	bool		replace(size_w index, const seqchar  val);
	bool		erase  (size_w index, size_w len);
	bool		erase  (size_w index);
	bool		append (const seqchar *buf, size_w len);
	bool		append (const seqchar val);
	void		breakopt();

	//
	// snapshot
	//
	bool		takesnapshot(size_w index, size_w length, span_desc *desclist, size_t *desclen);
	bool		injectsnapshot(size_w index, span_desc *desclist, size_t desclen);
	bool		rendersnapshot(size_t count, span_desc *desclist, size_w offset, seqchar *buffer, size_t length);
	bool		insert_snapshot(size_w index, size_w length, span_desc *desclist, size_t desclen);
	bool		replace_snapshot(size_w index, size_w length, span_desc *desclist, size_t desclen);


	//
	// undo/redo support
	//
	bool		undo();
	bool		redo();
	bool		canundo() const;
	bool		canredo() const;
	void		group();
	void		ungroup();
	void		clear_undo();
	size_w		event_index() const  { return undoredo_index; }
	size_w		event_length() const { return undoredo_length; }
	size_w		event_datalength() const { return undoredo_datalength; }

	// print out the sequence
	void		debug1();
	void		debug2();

	//
	// access and iteration
	//
	size_t		render(size_w index, seqchar *buf, size_t len, seqchar_info *infobuf = 0) const;
	seqchar		peek(size_w index) const;
	bool		poke(size_w index, seqchar val);
	seqchar&    getlastmodref(size_w *offset = 0);

	seqchar		operator[] (size_w index) const;
	ref			operator[] (size_w index);

	HANDLE		_handle();
	size_t		origfileid() { return origfile_id; }

private:

	long			refCount;

	typedef			std::vector<span_range*>	  eventstack;
	typedef			std::vector<buffer_control*>  bufferlist;
	template <class type> void clear_vector(type &source);

	//
	//	Span-table management
	//
	void			deletefromsequence(span **sptr);
	span		*	spanfromindex(size_w index, size_w *spanindex) const;
	void			scan(span *sptr);
	seqchar		*	getptr(span *sptr);


	size_w			sequence_length;
	span		*	head;
	span		*	tail;	
	span		*	frag1;
	span		*	frag2;

	
	//
	//	Undo and redo stacks
	//
	span_range *	initundo(size_w index, size_w length, action act);
	void			restore_spanrange(span_range *range, bool undo_or_redo);
	void			swap_spanrange(span_range *src, span_range *dest);
	bool			undoredo(eventstack &source, eventstack &dest);
	void			clearstack(eventstack &source);
	span_range *	stackback(eventstack &source, size_t idx);

	eventstack		undostack;
	eventstack		redostack;
	size_t			group_id;
	size_t			group_refcount;
	size_w			undoredo_index;
	size_w			undoredo_length;
	size_w			undoredo_datalength;

	//
	//	File and memory buffer management
	//
	span *			loadspan(const TCHAR *filename, bool readonly = false, bool keepondisk = false);
	//span *			linkspan(const TCHAR *filename, bool readonly);

	buffer_control *alloc_buffer(size_t size);
	buffer_control *alloc_modifybuffer(size_t size);
	bool			import_buffer(const seqchar *buf, size_t len, size_w *buffer_offset);
	bool			saveto(HANDLE hFile, bool quicksave);
	bool			writespan(HANDLE hFile, size_w index, span *sptr);


	bufferlist		buffer_list;
	size_t			modifybuffer_id;
	size_t			modifybuffer_pos;
	size_t			origfile_id;
	TCHAR			origfile_name[MAX_PATH];

	//
	//	Sequence manipulation
	//
	bool			insert_worker (size_w index, const seqchar *buf, size_w len, action act);
	bool			erase_worker  (size_w index, size_w len, action act);
	bool			can_optimize  (action act, size_w index);
	void			record_action (action act, size_w index);

	size_w			lastaction_index;
	action			lastaction;
	bool			can_quicksave;
	
	void			LOCK();
	void			UNLOCK();


};


//
//	sequence::action
//
//	enumeration of the type of 'edit actions' our sequence supports.
//	only important when we try to 'optimize' repeated operations on the
//	sequence by coallescing them into a single span.
//
enum sequence::action
{ 
	action_invalid, 
	action_insert, 
	action_erase, 
	action_replace 
};

//
//	sequence::span
//
//	private class to the sequence
//
class sequence::span
{
	friend class sequence;
	friend class span_range;
	
public:
	// constructor
	span(size_w off, size_w len, size_t buf, span *nx = 0, span *pr = 0) 
			:
			offset(off), 
			length(len), 
			buffer(buf),
			next(nx), 
			prev(pr)
	  {
		  static int count=-2;
		  id = count++;
	  }

	  
private:

	span   *next;
	span   *prev;	// double-link-list 
	
	size_w  offset;
	size_w  length;
	size_t  buffer;

	size_t	id;
};	
	


//
//	sequence::span_range
//
//	private class to the sequence. Used to represent a contiguous range of spans.
//	used by the undo/redo stacks to store state. A span-range effectively represents
//	the range of spans affected by an event (operation) on the sequence
//  
//
class sequence::span_range
{
	friend class sequence;

public:

	// constructor
	span_range(	size_w	seqlen = 0, 
				size_w	idx    = 0, 
				size_w	len    = 0, 
				action	a      = action_invalid,
				bool	qs     = false, 
				size_t	id     = 0
			) 
		: 
		first(0), 
		last(0), 
		boundary(true), 
		sequence_length(seqlen), 	
		index(idx),
		length(len),
		act(a),
		quicksave(qs),
		group_id(id)
	{
	}
		
	// destructor does nothing - because sometimes we don't want
	// to free the contents when the span_range is deleted. e.g. when
	// the span_range is just a temporary helper object. The contents
	// must be deleted manually with span_range::free
	~span_range()
	{
	}

	// separate 'destruction' used when appropriate
	void free()
	{
		span *sptr, *next, *term;
		
		if(boundary == false)
		{
			// delete the range of spans
			for(sptr = first, term = last->next; sptr && sptr != term; sptr = next)
			{
				next = sptr->next;
				delete sptr;
			}
		}
	}

	// add a span into the range
	void append(span *sptr)
	{
		if(sptr != 0)
		{
			// first time a span has been added?
			if(first == 0)
			{
				first = sptr;
			}
			// otherwise chain the spans together.
			else
			{
				last->next = sptr;
				sptr->prev = last;
			}
			
			last     = sptr;
			boundary = false;
		}
	}

	// join two span-ranges together
	void append(span_range *range)
	{
		if(range->boundary == false)
		{	
			if(boundary)
			{
				first       = range->first;
				last        = range->last;
				boundary    = false;
			}
			else
			{
				range->first->prev = last;
				last->next  = range->first;
				last		= range->last;
			}
		}
	}

	// join two span-ranges together. used only for 'back-delete'
	void prepend(span_range *range)
	{
		if(range->boundary == false)
		{
			if(boundary)
			{
				first       = range->first;
				last        = range->last;
				boundary    = false;
			}
			else
			{
				range->last->next = first;
				first->prev	= range->last;
				first		= range->first;
			}
		}
	}
	
	// An 'empty' range is represented by storing pointers to the
	// spans ***either side*** of the span-boundary position. Input is
	// always the span following the boundary.
	void spanboundary(span *before, span *after)
	{
		first    = before;
		last     = after;
		boundary = true;
	}

	
private:
	
	// the span range
	span	*first;
	span	*last;
	bool	 boundary;

	// sequence state
	size_w	 sequence_length;
	size_w	 index;
	size_w	 length;
	action	 act;
	bool	 quicksave;
	size_t	 group_id;
};

//
//	sequence::ref
//
//	temporary 'reference' to the sequence, used for
//  non-const array access with sequence::operator[]
//
class sequence::ref
{
public:
	ref(sequence *s, size_w i) 
		:  
		seq(s),  
		index(i) 
	{
	}

	operator seqchar() const		
	{ 
		return seq->peek(index);	          
	}
	
	ref & operator= (seqchar rhs)	
	{ 
		seq->poke(index, rhs); 
		return *this;	
	}

private:
	size_w		index;
	sequence *	seq;
};

//
//	buffer_control
//
class sequence::buffer_control
{
	friend class sequence;
#define MAX_VIEWS 4
	
	class buffer_view
	{
		friend class buffer_control;
		friend class sequence;
	public:

		buffer_view() : initialized(false), buffer(0)
		{
		};

	private:
		seqchar	   *buffer;
		size_w		offset;
		size_w		length;
		bool		initialized;
	};

public:
	buffer_control() : hFile(0), readonly(false)
	{
	}

	~buffer_control() 
	{ 
		free(); 
	}

	bool		init(const seqchar * buf, size_w len, bool copybuf);
	bool		init(size_t max);
	bool		append(const seqchar * buf, size_t len);
	bool		load(const TCHAR * filename, bool reado, bool quickload);
	void		free();

	seqchar *	getptr(size_w off, size_w len);

private:
	buffer_view		viewlist[MAX_VIEWS];
	//seqchar		*	buffer;
	size_w		length;
	size_w		maxsize;
	HANDLE		hFile;
	size_t		id;
	bool		ownbuf;
	bool		readonly;
};

class sequence::iterator
{
public:

};


struct sequence::span_desc
{
	size_w  offset;
	size_w  length;
	size_t	buffer;
};


#endif
```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`QuickAsm.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34310.174
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "QuickAsm", "QuickAsm\QuickAsm.vcxproj", "{08556E30-A5CA-4F40-BB93-D902D373C5F4}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HexView", "HexView\HexView.vcxproj", "{3FBA3178-4AE6-4103-9EB2-542901D978B7}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "x64Types", "x64Types\x64Types.vcxproj", "{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Debug|x64.ActiveCfg = Debug|x64
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Debug|x64.Build.0 = Debug|x64
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Debug|x86.ActiveCfg = Debug|Win32
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Debug|x86.Build.0 = Debug|Win32
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Release|x64.ActiveCfg = Release|x64
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Release|x64.Build.0 = Release|x64
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Release|x86.ActiveCfg = Release|Win32
		{08556E30-A5CA-4F40-BB93-D902D373C5F4}.Release|x86.Build.0 = Release|Win32
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Debug|x64.ActiveCfg = Debug|x64
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Debug|x64.Build.0 = Debug|x64
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Debug|x86.ActiveCfg = Debug|Win32
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Debug|x86.Build.0 = Debug|Win32
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Release|x64.ActiveCfg = Release|x64
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Release|x64.Build.0 = Release|x64
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Release|x86.ActiveCfg = Release|Win32
		{3FBA3178-4AE6-4103-9EB2-542901D978B7}.Release|x86.Build.0 = Release|Win32
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Debug|x64.ActiveCfg = Debug|x64
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Debug|x64.Build.0 = Debug|x64
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Debug|x86.ActiveCfg = Debug|Win32
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Debug|x86.Build.0 = Debug|Win32
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Release|x64.ActiveCfg = Release|x64
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Release|x64.Build.0 = Release|x64
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Release|x86.ActiveCfg = Release|Win32
		{88D28E0C-DE0F-462E-8E6F-78A81FF461F3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {17B5E576-8B0C-4D42-A071-3E423463F929}
	EndGlobalSection
EndGlobal

```

`QuickAsm/App.cpp`:

```cpp
#include "pch.h"
#include "App.h"
#include "MainFrame.h"
#include <wx/utils.h>
#include "LocalArtProvider.h"

wxIMPLEMENT_APP(App);

bool App::OnInit() {
	::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
	wxArtProvider::Push(new LocalArtProvider);
	wxSystemOptions::SetOption("msw.remap", 0);
	auto config = wxConfig::Get();
	int mode = config->ReadLong(L"DarkMode", 2);
	switch (mode) {
		case 0: MSWEnableDarkMode(DarkMode_Always); break;
		case 2: MSWEnableDarkMode(DarkMode_Auto); break;
	}

	auto frame = new MainFrame;
	frame->Create(nullptr, wxID_ANY, L"Quick Assembler");
	frame->SetSize(1300, 900);
	frame->Show(true);

	return true;
}

int App::OnExit() {
	if (Restart) {
		WCHAR path[MAX_PATH];
		::GetModuleFileName(nullptr, path, _countof(path));
		wxExecute(path);
	}
	return 0;
}

```

`QuickAsm/App.h`:

```h
#pragma once


class App : public wxApp {
public:
	bool OnInit() override;
	int OnExit() override;

	bool Restart{ false };
private:
};

wxDECLARE_APP(App);

```

`QuickAsm/AssemblerBase.cpp`:

```cpp
#include "pch.h"
#include "AssemblerBase.h"
#include <fstream>
#include "Helpers.h"

void AssemblerBase::SetName(PCWSTR name) {
    m_Name = name;
}

PCWSTR AssemblerBase::GetName() const {
    return m_Name.c_str();
}

AssemblerResults AssemblerBase::Assemble(std::string const& source) {
    AssemblerResults results{};
    results.Error = true;
    if (source.empty()) {
        results.Output = "Error: no source";
        return results;
    }

    auto path = Helpers::GetTempFilePath(L"asm");
    std::ofstream stm(path);

    if (stm.good()) {
        stm.write(source.c_str(), source.length());
        stm.close();
        return AssembleFile(path);
    }
    return results;
}

void AssemblerBase::SetValue(std::string name, OptionValue value) {
    m_Options[name] = std::move(value);
}

OptionValue const* AssemblerBase::GetValue(std::string_view name) const {
    if (auto it = m_Options.find(name.data()); it != m_Options.end())
        return &it->second;
    return nullptr;
}

int64_t const* AssemblerBase::GetIntValue(std::string_view name) const {
    auto value = GetValue(name);
    return value ? &std::get<0>(*value) : nullptr;
}

std::string const* AssemblerBase::GetStringValue(std::string_view name) const {
    auto value = GetValue(name);
    return value ? &std::get<1>(*value) : nullptr;
}


```

`QuickAsm/AssemblerBase.h`:

```h
#pragma once

#include <variant>

struct AssemblerResults {
	std::vector<uint8_t> Bytes;
	std::wstring OutputFile;
	std::string Output;
	size_t Instructions;
	int Error{ 0 };
};

using OptionValue = std::variant<int64_t, std::string>;

class AssemblerBase abstract {
public:
	virtual ~AssemblerBase() = default;
	void SetName(PCWSTR name);
	PCWSTR GetName() const;
	virtual AssemblerResults Assemble(std::string const& source);
	virtual AssemblerResults AssembleFile(std::wstring const& file) = 0;
	void SetValue(std::string name, OptionValue value);
	OptionValue const* GetValue(std::string_view name) const;
	int64_t const* GetIntValue(std::string_view name) const;
	std::string const* GetStringValue(std::string_view name) const;

private:
	std::unordered_map<std::string, OptionValue> m_Options;
	std::wstring m_Name;
};


```

`QuickAsm/AssemblyEditCtrl.cpp`:

```cpp
#include "pch.h"
#include "AssemblyEditCtrl.h"
#include <wx/fdrepdlg.h>

wxIMPLEMENT_DYNAMIC_CLASS(AssemblyEditCtrl, wxStyledTextCtrl);

static const char* KeyWords_ASM[] = {
	"aaa aad aam aas adc add and arpl blsr bnd bndcl bndcn bndcu bndmov bndstx bound bsf bsr bswap bt btc btr bts call cbw cdq cflush clc cld cli clts "
	"cmc cmova cmovae cmovb cmovbe cmovc cmove cmovg cmovge cmovl cmovle cmovna cmovnae cmovnb cmovnbe cmovnc "
	"cmovne cmovng cmovnge cmovnl cmovnle cmovno cmovnp cmovns cmovnz cmovo cmovp cmovpe cmovpo cmovs cmovz "
	"cmp cmps cmpsb cmpsd cmpsq cmpsw cmpxchg cmpxchg486 cmpxchg8b cpuid cwd cwde daa das dec div emms enter "
	"esc femms hlt ibts icebp idiv imul in inc ins insb insd insw int int01 int03 int1 int3 into invd invlpg "
	"iret iretd iretdf iretf iretw ja jae jb jbe jc jcxz je jecxz jg jge jl jle jmp jna jnae jnb jnbe jnc jne "
	"jng jnge jnl jnle jno jnp jns jnz jo jp jpe jpo js jz lahf lar lds lea leave les lfs lgdt lgs lidt lldt "
	"lmsw loadall loadall286 lock lods lodsb lodsd lodsq lodsw loop loopd loope looped loopew loopne loopned "
	"loopnew loopnz loopnzd loopnzw loopw loopz loopzd loopzw lsl lss ltr mov movs movsb movsd movsq movsw "
	"movsx movsxd movzx mul neg nop not or out outs outsb outsd outsw pop popa popad popaw popf popfd popfw "
	"push pusha pushad pushaw pushd pushf pushfd pushfw pushw rcl rcr rdmsr rdpmc rdshr rdtsc rep repe repne "
	"repnz repz ret retf retn rol ror rsdc rsldt rsm rsts sahf sal salc sar sbb scas scasb scasd scasq scasw "
	"seta setae setb setbe setc sete setg setge setl setle setna setnae setnb setnbe setnc setne setng setnge "
	"setnl setnle setno setnp setns setnz seto setp setpe setpo sets setz sgdt shl shld shr shrd sidt sldt smi "
	"smint smintold smsw stc std sti stos stosb stosd stosq stosw str sub svdc svldt svts syscall sysenter "
	"sysexit sysret test ud0 ud1 ud2 umov verr verw wait wbinvd wrmsr wrshr xadd xbts xchg xlat xlatb xor",
	"f2xm1 fabs fadd faddp fbld fbstp fchs fclex fcmovb fcmovbe fcmove fcmovnb fcmovnbe fcmovne fcmovnu fcmovu "
	"fcom fcomi fcomip fcomp fcompp fcos fdecstp fdisi fdiv fdivp fdivr fdivrp feni ffree ffreep fiadd ficom "
	"ficomp fidiv fidivr fild fimul fincstp finit fist fistp fisub fisubr fld fld1 fldcw fldenv fldenvd "
	"fldenvw fldl2e fldl2t fldlg2 fldln2 fldpi fldz fmul fmulp fnclex fndisi fneni fninit fnop fnsave fnsaved "
	"fnsavew fnstcw fnstenv fnstenvd fnstenvw fnstsw fpatan fprem fprem1 fptan frndint frstor frstord frstorw "
	"fsave fsaved fsavew fscale fsetpm fsin fsincos fsqrt fst fstcw fstenv fstenvd fstenvw fstp fstsw fsub "
	"fsubp fsubr fsubrp ftst fucom fucomp fucompp fwait fxam fxch fxtract fyl2x fyl2xp1",
	"ah al ax bh bl bp bx ch cl cr0 cr2 cr3 cr4 cs cx dh di dl dr0 dr1 dr2 dr3 dr6 dr7 ds dx eax ebp ebx ecx edi "
	"edx eip es esi esp fs gs mm0 mm1 mm2 mm3 mm4 mm5 mm6 mm7 r10 r10b r10d r10w r11 r11b r11d r11w r12 r12b "
	"r12d r12w r13 r13b r13d r13w r14 r14b r14d r14w r15 r15b r15d r15w r8 r8b r8d r8w r9 r9b r9d r9w rax rbp "
	"rbx rcx rdi rdx rip rsi rsp si sp ss st st0 st1 st2 st3 st4 st5 st6 st7 tr3 tr4 tr5 tr6 tr7 xmm0 xmm1 "
	"xmm10 xmm11 xmm12 xmm13 xmm14 xmm15 xmm2 xmm3 xmm4 xmm5 xmm6 xmm7 xmm8 xmm9 ymm0 ymm1 ymm10 ymm11 ymm12 "
	"ymm13 ymm14 ymm15 ymm2 ymm3 ymm4 ymm5 ymm6 ymm7 ymm8 ymm9",
	"%arg %assign %define %elif %elifctk %elifdef %elifid %elifidn %elifidni %elifmacro %elifnctk %elifndef "
	"%elifnid %elifnidn %elifnidni %elifnmacro %elifnnum %elifnstr %elifnum %elifstr %else %endif %endmacro "
	"%endrep %error %exitrep %iassign %idefine %if %ifctk %ifdef %ifid %ifidn %ifidni %ifmacro %ifnctk %ifndef "
	"%ifnid %ifnidn %ifnidni %ifnmacro %ifnnum %ifnstr %ifnum %ifstr %imacro %include %line %local %macro %out "
	"%pop %push %rep %repl %rotate %stacksize %strlen %substr %undef %xdefine %xidefine .186 .286 .286c .286p "
	".287 .386 .386c .386p .387 .486 .486p .8086 .8087 .alpha .break .code .const .continue .cref .data .data? "
	".dosseg .else .elseif .endif .endw .err .err1 .err2 .errb .errdef .errdif .errdifi .erre .erridn .erridni "
	".errnb .errndef .errnz .exit .fardata .fardata? .if .lall .lfcond .list .listall .listif .listmacro "
	".listmacroall .model .msfloat .no87 .nocref .nolist .nolistif .nolistmacro .radix .repeat .sall .seq "
	".sfcond .stack .startup .tfcond .type .until .untilcxz .while .xall .xcref .xlist absolute alias align "
	"alignb assume at bits catstr comm comment common cpu db dd df dosseg dq dt dup dw echo else elseif "
	"elseif1 elseif2 elseifb elseifdef elseifdif elseifdifi elseife elseifidn elseifidni elseifnb elseifndef "
	"end endif endm endp ends endstruc eq equ default even exitm export extern externdef extrn for forc ge global goto "
	"group gt high highword iend if if1 if2 ifb ifdef ifdif ifdifi ife ifidn ifidni ifnb ifndef import incbin "
	"include includelib instr invoke irp irpc istruc label le length lengthof local low lowword lroffset lt "
	"macro mask mod name ne offset opattr option org page popcontext proc proto ptr public purge pushcontext "
	"record repeat rept resb resd resq rest resw section seg segment short size sizeof sizestr struc struct "
	"substr subtitle subttl textequ this times title type typedef union use16 use32 while width",
	"$ $$ %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 .bss .data .text ? @b @f a16 a32 abs addr all assumes at basic byte c "
	"carry? casemap common compact cpu dotname dword emulator epilogue error export expr16 expr32 far far16 "
	"far32 farstack flat forceframe fortran fword huge language large listing ljmp loadds m510 medium memory "
	"near near16 near32 nearstack nodotname noemulator nokeyword noljmp nom510 none nonunique nooldmacros "
	"nooldstructs noreadonly noscoped nosignextend nosplit nothing notpublic o16 o32 oldmacros oldstructs "
	"os_dos overflow? para parity? pascal private prologue qword radix readonly real10 real4 real8 req sbyte "
	"scoped sdword seq setif2 sign? small smallstack stdcall sword syscall tbyte tiny use16 use32 uses vararg "
	"word wrt zero?",
	"addpd addps addsd addss andnpd andnps andpd andps blendpd blendps blendvpd blendvps cmpeqpd cmpeqps cmpeqsd "
	"cmpeqss cmplepd cmpleps cmplesd cmpless cmpltpd cmpltps cmpltsd cmpltss cmpnepd cmpneps cmpnesd cmpness "
	"cmpnlepd cmpnleps cmpnlesd cmpnless cmpnltpd cmpnltps cmpnltsd cmpnltss cmpordpd cmpordps cmpordsd "
	"cmpordss cmpunordpd cmpunordps cmpunordsd cmpunordss comisd comiss crc32 cvtdq2pd cvtdq2ps cvtpd2dq "
	"cvtpd2pi cvtpd2ps cvtpi2pd cvtpi2ps cvtps2dq cvtps2pd cvtps2pi cvtsd2si cvtsd2ss cvtsi2sd cvtsi2ss "
	"cvtss2sd cvtss2si cvttpd2dq cvttpd2pi cvttps2dq cvttps2pi cvttsd2si cvttss2si divpd divps divsd divss "
	"dppd dpps extractps fxrstor fxsave insertps ldmxscr lfence maskmovdq maskmovdqu maxpd maxps maxss mfence "
	"minpd minps minsd minss movapd movaps movd movdq2q movdqa movdqu movhlps movhpd movhps movlhps movlpd "
	"movlps movmskpd movmskps movntdq movntdqa movnti movntpd movntps movntq movq movq2dq movsd movss movupd "
	"movups mpsadbw mulpd mulps mulsd mulss orpd orps packssdw packsswb packusdw packuswb paddb paddd paddq "
	"paddsb paddsiw paddsw paddusb paddusw paddw pand pandn pause paveb pavgb pavgusb pavgw paxsd pblendvb "
	"pblendw pcmpeqb pcmpeqd pcmpeqq pcmpeqw pcmpestri pcmpestrm pcmpgtb pcmpgtd pcmpgtq pcmpgtw pcmpistri "
	"pcmpistrm pdistib pextrb pextrd pextrq pextrw pf2id pf2iw pfacc pfadd pfcmpeq pfcmpge pfcmpgt pfmax pfmin "
	"pfmul pfnacc pfpnacc pfrcp pfrcpit1 pfrcpit2 pfrsqit1 pfrsqrt pfsub pfsubr phminposuw pi2fd pinsrb pinsrd "
	"pinsrq pinsrw pmachriw pmaddwd pmagw pmaxsb pmaxsd pmaxsw pmaxub pmaxud pmaxuw pminsb pminsd pminsw "
	"pminub pminud pminuw pmovmskb pmovsxbd pmovsxbq pmovsxbw pmovsxdq pmovsxwd pmovsxwq pmovzxbd pmovzxbq "
	"pmovzxbw pmovzxdq pmovzxwd pmovzxwq pmuldq pmulhriw pmulhrwa pmulhrwc pmulhuw pmulhw pmulld pmullw "
	"pmuludq pmvgezb pmvlzb pmvnzb pmvzb popcnt por prefetch prefetchnta prefetcht0 prefetcht1 prefetcht2 "
	"prefetchw psadbw pshufd pshufhw pshuflw pshufw pslld pslldq psllq psllw psrad psraw psrld psrldq psrlq "
	"psrlw psubb psubd psubq psubsb psubsiw psubsw psubusb psubusw psubw pswapd ptest punpckhbw punpckhdq "
	"punpckhqdq punpckhwd punpcklbw punpckldq punpcklqdq punpcklwd pxor rcpps rcpss roundpd roundps roundsd "
	"roundss rsqrtps rsqrtss sfence shufpd shufps sqrtpd sqrtps sqrtsd sqrtss stmxcsr subpd subps subsd subss "
	"ucomisd ucomiss unpckhpd unpckhps unpcklpd unpcklps xorpd xorps",
};

AssemblyEditCtrl::AssemblyEditCtrl() {
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditCopy, this, wxID_COPY);
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditPaste, this, wxID_PASTE);
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditCut, this, wxID_CUT);
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditClear, this, wxID_CLEAR);
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditUndo, this, wxID_UNDO);
	Bind(wxEVT_MENU, &AssemblyEditCtrl::OnEditRedo, this, wxID_REDO);
}

void AssemblyEditCtrl::Init() {
	SetMarginSensitive(1, true);

	//IndicatorSetStyle(2, wxSTC_INDIC_FULLBOX);
	SetTabWidth(4);
	SetMarginType(0, wxSTC_MARGIN_NUMBER);
	SetMarginType(1, wxSTC_MARGIN_SYMBOL);
	MarkerDefine(1, wxSTC_MARK_CIRCLE);
	MarkerSetBackground(1, RGB(128, 0, 0));
	//MarkerSetForeground(1, RGB(0, 0, 0));
	SetMarginBackground(1, RGB(128, 128, 128));

	SetMarginWidth(0, 30);
	SetMarginWidth(1, 26);
	SetLexer(wxSTC_LEX_ASM);
	wxFont font(wxFontInfo(12).FaceName("Consolas"));
	StyleSetFont(wxSTC_STYLE_DEFAULT, font);

	StyleClearAll();
	auto dark = wxSystemSettingsNative::GetAppearance().IsDark();

	StyleSetForeground(wxSTC_ASM_DEFAULT, dark ? "WHITE" : "BLACK");
	StyleSetForeground(wxSTC_ASM_DIRECTIVE, dark ? "ORANGE" : "BROWN");
	StyleSetForeground(wxSTC_ASM_NUMBER, dark ? "CYAN" : "PURPLE");
	StyleSetForeground(wxSTC_ASM_REGISTER, dark ? "WHITE" : "BLACK");
	StyleSetBold(wxSTC_ASM_REGISTER, true);
	StyleSetForeground(wxSTC_ASM_STRING, dark ? "#C08000" : "#800000");
	StyleSetForeground(wxSTC_ASM_COMMENT, dark ? "GREEN" : "#008000");
	StyleSetForeground(wxSTC_ASM_CPUINSTRUCTION, dark ? "YELLOW" : "BLUE");
	StyleSetBold(wxSTC_ASM_CPUINSTRUCTION, true);
	StyleSetForeground(wxSTC_ASM_MATHINSTRUCTION, dark ? "YELLOW" : "BLUE");

	for (int i = 0; i < _countof(KeyWords_ASM); i++)
		SetKeyWords(i, KeyWords_ASM[i]);
}

bool AssemblyEditCtrl::ToggleBreakpoint(int line) {
	if (MarkerGet(line) & BreakpointMarker) {
		MarkerDelete(line, 1);
		return false;
	}
	MarkerAdd(line, 1);
	return true;
}


// edit event handlers
void AssemblyEditCtrl::OnEditRedo(wxCommandEvent& WXUNUSED(event)) {
	if (CanRedo())
		Redo();
}

void AssemblyEditCtrl::OnEditUndo(wxCommandEvent& WXUNUSED(event)) {
	if (CanUndo())
		Undo();
}

void AssemblyEditCtrl::OnEditClear(wxCommandEvent& WXUNUSED(event)) {
	if (!GetReadOnly())
		Clear();
}

void AssemblyEditCtrl::OnEditCut(wxCommandEvent& WXUNUSED(event)) {
	if (CanCut())
		Cut();
}

void AssemblyEditCtrl::OnEditCopy(wxCommandEvent& WXUNUSED(event)) {
	if (CanCopy())
		Copy();
}

void AssemblyEditCtrl::OnEditPaste(wxCommandEvent& WXUNUSED(event)) {
	if (CanPaste())
		Paste();
}

void AssemblyEditCtrl::OnFind(wxCommandEvent& event) {

}

```

`QuickAsm/AssemblyEditCtrl.h`:

```h
#pragma once

class AssemblyEditCtrl : public wxStyledTextCtrl {
    wxDECLARE_DYNAMIC_CLASS(AssemblyEditCtrl);

public:
    AssemblyEditCtrl();
    void Init();

    enum {
        BreakpointMarker = 2,
    };

    bool ToggleBreakpoint(int line);

    // common
    void OnCreate(wxWindowCreateEvent& event);
    void OnSize(wxSizeEvent& event);
    // edit
    void OnEditRedo(wxCommandEvent& event);
    void OnEditUndo(wxCommandEvent& event);
    void OnEditClear(wxCommandEvent& event);
    void OnEditCut(wxCommandEvent& event);
    void OnEditCopy(wxCommandEvent& event);
    void OnEditPaste(wxCommandEvent& event);
    // find
    void OnFind(wxCommandEvent& event);
    void OnFindNext(wxCommandEvent& event);
    void OnReplace(wxCommandEvent& event);
    void OnReplaceNext(wxCommandEvent& event);
    void OnBraceMatch(wxCommandEvent& event);
    void OnGoto(wxCommandEvent& event);
    void OnEditIndentInc(wxCommandEvent& event);
    void OnEditIndentRed(wxCommandEvent& event);
    void OnEditSelectAll(wxCommandEvent& event);
    void OnEditSelectLine(wxCommandEvent& event);
    //! view
    void OnHighlightLang(wxCommandEvent& event);
    void OnDisplayEOL(wxCommandEvent& event);
    void OnIndentGuide(wxCommandEvent& event);
    void OnLineNumber(wxCommandEvent& event);
    void OnLongLineOn(wxCommandEvent& event);
    void OnWhiteSpace(wxCommandEvent& event);
    void OnFoldToggle(wxCommandEvent& event);
    void OnSetOverType(wxCommandEvent& event);
    void OnSetReadOnly(wxCommandEvent& event);
    void OnWrapmodeOn(wxCommandEvent& event);
    void OnUseCharset(wxCommandEvent& event);
    // annotations
    void OnAnnotationAdd(wxCommandEvent& event);
    void OnAnnotationRemove(wxCommandEvent& event);
    void OnAnnotationClear(wxCommandEvent& event);
    void OnAnnotationStyle(wxCommandEvent& event);
    // indicators
    void OnIndicatorFill(wxCommandEvent& event);
    void OnIndicatorClear(wxCommandEvent& event);
    void OnIndicatorStyle(wxCommandEvent& event);
    // stc
    void OnMarginClick(wxStyledTextEvent& event);
    void OnCharAdded(wxStyledTextEvent& event);
    void OnCallTipClick(wxStyledTextEvent& event);

private:
};


```

`QuickAsm/CapstoneEngine.cpp`:

```cpp
#include "pch.h"
#include "CapstoneEngine.h"

CapstoneEngine::~CapstoneEngine() {
	if (m_CS)
		cs_close(&m_CS);
}

bool CapstoneEngine::Open(cs_mode mode) {
	csh h;
	m_Error = cs_open(CS_ARCH_X86, mode, &h);
	if (m_Error != CS_ERR_OK)
		return false;

	if (m_CS)
		cs_close(&m_CS);
	m_CS = h;
	return true;
}

std::vector<Instruction> CapstoneEngine::Disassemble(uint8_t const* code, size_t size, uint64_t address) {
	if (m_CS == 0)
		return {};

	cs_insn* insn;
	auto count = cs_disasm(m_CS, code, size, address, 0, &insn);
	if (count == 0) {
		m_Error = cs_errno(m_CS);
		return {};
	}

	std::vector<Instruction> inst;
	inst.reserve(count);
	for (size_t i = 0; i < count; i++) {
		auto& insni = insn[i];
		Instruction ins;
		ins.Id = insni.id;
		ins.Address = insni.address;
		ins.Bytes.resize(insni.size);
		memcpy(ins.Bytes.data(), insni.bytes, ins.Bytes.size());
		ins.Mnemonic = insni.mnemonic;
		ins.Operands = insni.op_str;
		if (insni.detail)
			ins.Details.reset(new cs_detail(*insni.detail));
		inst.push_back(std::move(ins));
	}
	cs_free(insn, count);

	return inst;
}

cs_err CapstoneEngine::GetLastError() const {
	return m_Error;
}

const char* CapstoneEngine::GetError(cs_err error) {
	return cs_strerror(error);
}

```

`QuickAsm/CapstoneEngine.h`:

```h
#pragma once

struct Instruction {
	uint64_t Address;
	std::vector<uint8_t> Bytes;
	std::string Mnemonic;
	std::string Operands;
	unsigned Id;
	std::unique_ptr<cs_detail> Details;
};

class CapstoneEngine final {
public:
	~CapstoneEngine();
	bool Open(cs_mode mode);
	std::vector<Instruction> Disassemble(uint8_t const* code, size_t size, uint64_t address);
	cs_err GetLastError() const;
	static const char* GetError(cs_err error);

private:
	csh m_CS{ 0 };
	cs_err m_Error;
};



```

`QuickAsm/Helpers.cpp`:

```cpp
#include "pch.h"
#include "Helpers.h"
#include "..\x64Types\x64Types.h"

std::wstring Helpers::GetTempFilePath(PCWSTR name) {
    WCHAR path[MAX_PATH]{};
    ::GetTempPath(_countof(path), path);
    ::GetTempFileName(path, name, 0, path);
    return path;
}

std::vector<BYTE> Helpers::ReadFileContents(PCWSTR path) {
    auto hFile = ::CreateFile(path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);
	if (hFile == INVALID_HANDLE_VALUE)
		return {};
	
    std::vector<BYTE> buffer(::GetFileSize(hFile, nullptr));
	DWORD read;
	::ReadFile(hFile, buffer.data(), (DWORD)buffer.size(), &read, nullptr);
	::CloseHandle(hFile);
	return buffer;
}

PCWSTR Helpers::RegisterTypeToString(RegisterType type) {
    static const struct {
        RegisterType value;
        PCWSTR text;
    } types[] = {
        { RegisterType::General, L"General" },
        { RegisterType::Segment, L"Segment" },
        { RegisterType::Special, L"Special" },
        { RegisterType::FloatingPoint, L"Float" },
        { RegisterType::SSE, L"SSE" },
        { RegisterType::Control, L"Control" },
        { RegisterType::Descriptor, L"Descriptor" },
    };

    for (auto& t : types)
        if ((t.value & type) == t.value)
            return t.text;

    return L"";
}

wxString Helpers::CPUFlagsToString(uint32_t value) {
    static const struct {
        int bit;
        PCWSTR text;
    } flags[] = {
        { 0, L"C" },
        { 2, L"P" },
        { 4, L"A" },
        { 6, L"Z" },
        { 7, L"S" },
        { 10, L"D" },
        { 11, L"O" },
        { 14, L"NT" },
        { 16, L"RF" },
        { 17, L"VM" },
        { 18, L"AC" },
        { 19, L"VIF" },
        { 20, L"VIP" },
        { 21, L"ID" },
    };
    wxString text;
    for (auto& f : flags)
        if (value & (1 << f.bit))
            text += wxString(f.text) + L"=1 ";

    text += wxString(L"IOPL=") + std::to_wstring((value & (1 << 12) || (1 << 13)) >> 12).c_str();
    return text;
}

wxString Helpers::CR0ToString(uint64_t value) {
    static const struct {
        int bit;
        PCWSTR text;
    } bits[] = {
        { 0, L"PE" },
        { 1, L"MP" },
        { 2, L"EM" },
        { 3, L"TS" },
        { 4, L"ET" },
        { 5, L"NE" },
        { 16, L"WP" },
        { 18, L"AM" },
        { 29, L"NW" },
        { 30, L"CD" },
        { 31, L"PG" },
    };

    wxString text;
    for (auto& b : bits)
        if (value & (1LL << b.bit))
            text += wxString(b.text) + L"=1 ";
    return text;
}

```

`QuickAsm/Helpers.h`:

```h
#pragma once

#include "RegisterInfo.h"

struct Helpers abstract final {
	static std::wstring GetTempFilePath(PCWSTR name);
	static std::vector<BYTE> ReadFileContents(PCWSTR path);
	static PCWSTR RegisterTypeToString(RegisterType type);
	static wxString CPUFlagsToString(uint32_t value);
	static wxString CR0ToString(uint64_t value);
};


```

`QuickAsm/HexViewPanel.cpp`:

```cpp
#include "pch.h"
#include "HexViewPanel.h"
#include "wxHexView.h"
#include "..\HexView\HexView.h"

wxIMPLEMENT_DYNAMIC_CLASS(HexViewPanel, wxPanel);

HexViewPanel::HexViewPanel(wxWindow* parent, IHexViewNotify* pNotify) : wxPanel(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize,
	wxTAB_TRAVERSAL | wxNO_BORDER | wxCLIP_CHILDREN | wxWANTS_CHARS), m_pNotify(pNotify) {
}

bool HexViewPanel::MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM* result) {
	auto hdr = (LPNMHDR)lParam;
	if (hdr->hwndFrom == m_pHexView->GetHWND() && m_pNotify) {
		return m_pNotify->OnHexViewNotify(m_pHexView, idCtrl, hdr, result);
	}
	return wxPanel::MSWOnNotify(idCtrl, lParam, result);
}

LRESULT HexViewPanel::MSWWindowProc(WXUINT msg, WXWPARAM wParam, WXLPARAM lParam) {
	switch (msg) {
		case WM_SETFOCUS:
			if (m_pHexView) {
				m_pHexView->SetFocus();
				return 0;
			}

		case WM_CONTEXTMENU:
			wxMenu menu;
			menu.Append(wxID_COPY)->SetBitmap(wxArtProvider::GetIcon(wxART_COPY, wxART_MENU));
			menu.Append(wxID_PASTE);
			PopupMenu(&menu);
			return 0;
	}
	return wxPanel::MSWWindowProc(msg, wParam, lParam);
}

void HexViewPanel::SetHexView(wxHexView* pHexView) {
	m_pHexView = pHexView;
}

```

`QuickAsm/HexViewPanel.h`:

```h
#pragma once

class wxHexView;

struct IHexViewNotify abstract {
	virtual bool OnHexViewNotify(wxHexView* pHexView, int idCtrl, LPNMHDR, WXLPARAM* result) = 0;
};

class HexViewPanel : public wxPanel {
	wxDECLARE_DYNAMIC_CLASS(HexViewPanel);
public:
	HexViewPanel() = default;
	HexViewPanel(wxWindow* parent, IHexViewNotify* pNotify = nullptr);
	bool MSWOnNotify(int idCtrl, WXLPARAM lParam, WXLPARAM* result) override;
	LRESULT MSWWindowProc(WXUINT msg, WXWPARAM wParam, WXLPARAM lParam) override;

	void SetHexView(wxHexView* pHexView);

private:
	wxHexView* m_pHexView{ nullptr };
	IHexViewNotify* m_pNotify{ nullptr };
};

```

`QuickAsm/KeystoneAssembler.cpp`:

```cpp
#include "pch.h"
#include "KeystoneAssembler.h"
#include <wil\resource.h>

KeystoneAssembler::KeystoneAssembler() {
    SetName(L"Keystone");
}

AssemblerResults KeystoneAssembler::AssembleFile(std::wstring const& file) {
    AssemblerResults results{};
    wil::unique_hfile hFile(::CreateFile(file.c_str(), GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr));
    if (!hFile) {
        results.Error = ::GetLastError();
        return results;
    }

    std::string text;
    text.resize(::GetFileSize(hFile.get(), nullptr));
    if (DWORD read; !::ReadFile(hFile.get(), text.data(), (DWORD)text.length(), &read, nullptr)) {
        results.Error = ::GetLastError();
        return results;
    }
    hFile.reset();

    results = Assemble(text);
    if (results.Bytes.empty())
        return results;

    std::wstring path(file.data());
    auto index = path.rfind(L'.');
    assert(index != std::string::npos);
    path = path.substr(0, index) + L".bin";
    hFile.reset(::CreateFile(path.c_str(), GENERIC_WRITE, 0, nullptr, OPEN_ALWAYS, 0, nullptr));
    if (!hFile) {
        results.Error = ::GetLastError();
        return results;
    }
    if (DWORD written; !::WriteFile(hFile.get(), results.Bytes.data(), (DWORD)results.Bytes.size(), &written, nullptr)) {
        results.Error = ::GetLastError();
        return results;
    }
    ::SetEndOfFile(hFile.get());
    results.OutputFile = path;
    return results;
}

AssemblerResults KeystoneAssembler::Assemble(std::string const& source) {
    AssemblerResults results{};
    if (source.empty()) {
        results.Error = 1;
        results.Output = "No source code";
        return results;
    }

    auto mode = GetIntValue("mode");
    if (mode) {
        switch (*mode) {
            case 16: m_Mode = KS_MODE_16; break;
            case 32: m_Mode = KS_MODE_32; break;
            case 64: m_Mode = KS_MODE_64; break;
        }
    }
    auto address = GetIntValue("address");
    if (address)
        m_Address = *address;

    ks_engine* ks;
    results.Error = ks_open(KS_ARCH_X86, m_Mode, &ks);
    if (results.Error != KS_ERR_OK)
        return results;

    uint8_t* encoding;
    size_t size;
    if (ks_asm(ks, source.c_str(), m_Address, &encoding, &size, &results.Instructions)) {
        results.Error = ks_errno(ks);
        results.Output = ks_strerror(ks_errno(ks));
    }
    else {
        results.Bytes.resize(size);
        memcpy(results.Bytes.data(), encoding, size);
        ks_free(encoding);
    }
    ks_close(ks);

    return results;
}

void KeystoneAssembler::SetMode(ks_mode mode) {
    m_Mode = mode;
}

ks_mode KeystoneAssembler::GetMode() const {
    return m_Mode;
}

void KeystoneAssembler::SetAddress(uint64_t address) {
    m_Address = address;
}

uint64_t KeystoneAssembler::GetAddress() const {
    return m_Address;
}

```

`QuickAsm/KeystoneAssembler.h`:

```h
#pragma once

#include "AssemblerBase.h"

class KeystoneAssembler : public AssemblerBase {
public:
	KeystoneAssembler();
	AssemblerResults AssembleFile(std::wstring const& file) override;
	AssemblerResults Assemble(std::string const& source) override;

	void SetMode(ks_mode mode);
	ks_mode GetMode() const;
	void SetAddress(uint64_t address);
	uint64_t GetAddress() const;

private:
	ks_mode m_Mode{ KS_MODE_32 };
	uint64_t m_Address{ 0 };
};


```

`QuickAsm/LocalArtProvider.cpp`:

```cpp
#include "pch.h"
#include "LocalArtProvider.h"
#include "resource.h"

wxBitmapBundle LocalArtProvider::CreateBitmapBundle(const wxArtID& id, const wxArtClient& client, const wxSize& size) {
    static const struct {
        wxArtID id;
        wxString icon;
    } iconsMap[] = {
        { wxART_FILE_OPEN, L"OPEN" },
        { wxART_UNDO, L"UNDO" },
        { wxART_REDO, L"REDO" },
        { wxART_COPY, L"COPY" },
        { wxART_CUT, L"CUT" },
        { wxART_FILE_SAVE, L"SAVE" },
        { wxART_FILE_SAVE_AS, L"SAVEAS" },
        { wxART_PASTE, L"PASTE" },
        { wxART_EDIT, L"EDIT" },
        { "RESTART", wxString::Format("#%d", IDI_RESTART) },
    };

    for (auto& icon : iconsMap) {
        if (id == icon.id) {
            wxIconBundle icons(icon.icon, nullptr);
            return wxBitmapBundle::FromIconBundle(icons);
        }
    }

    return wxBitmapBundle::FromIconBundle(wxIconBundle(id, nullptr));
}


```

`QuickAsm/LocalArtProvider.h`:

```h
#pragma once

class LocalArtProvider : public wxArtProvider {
public:
	wxBitmapBundle CreateBitmapBundle(const wxArtID& id, const wxArtClient& client,	const wxSize& size) override;
};


```

`QuickAsm/MainFrame.cpp`:

```cpp
#include "pch.h"
#include "MainFrame.h"
#include "LocalArtProvider.h"
#include "KeystoneAssembler.h"
#include "NasmAssembler.h"
#include "Helpers.h"
#include "RegisterInfo.h"
#include "wxHexView.h"
#include "HexViewPanel.h"
#include <wx/config.h>
#include "App.h"

wxIMPLEMENT_DYNAMIC_CLASS(MainFrame, wxFrame);

enum {
	wxID_ASSEMBLE = wxID_HIGHEST + 1,
	wxID_16BIT,
	wxID_32BIT,
	wxID_64BIT,
	wxID_8BITREG,
	wxID_16BITREG,
	wxID_32BITREG,
	wxID_64BITREG,
	wxID_FLOAT,
	wxID_RUN,
	wxID_RESTART,
	wxID_STEPOVER,
	wxID_STEPINTO,
	wxID_DARKTHEME,
	wxID_TOGGLEBP = wxID_DARKTHEME + 3,
	wxID_DELETEALL_BP,
	wxID_1BYTE,
};

MainFrame::MainFrame() {
	m_Memory.resize(1 << 16);
	Bind(wxEVT_CREATE, &MainFrame::OnCreate, this);
	Bind(wxEVT_MENU, &MainFrame::OnExit, this, wxID_EXIT);

	auto handler = [this](auto& e) {
		auto focus = FindFocus();
		if (focus == m_AsmSource || focus == m_DisamSource) {
			focus->GetEventHandler()->ProcessEventLocally(e);
		}
		else if (m_HexViewActive) {
			m_MemoryView->ProcessCommand(e);
		}
		};

	Bind(wxEVT_MENU, handler, wxID_EDIT, wxID_EDIT + 10);
	Bind(wxEVT_MENU, handler, wxID_UNDO, wxID_REDO);
	Bind(wxEVT_MENU, [this](auto& e) {
		wxFileDialog dlg(this, L"Open Assembly/Binary file", wxEmptyString, wxEmptyString,
		L"Assembly files (*.asm)|*.asm|Binary Files (*.bin)|*.bin|All files (*.*)|*.*", wxFD_OPEN | wxFD_FILE_MUST_EXIST);
	if (dlg.ShowModal() == wxID_OK) {
		m_FileName = dlg.GetPath();
		if (m_FileName.Right(4).CmpNoCase(L".asm") != 0) {
			m_AsmBytes = Helpers::ReadFileContents(m_FileName);
			Disassemble(m_AsmBytes);
		}
		else {
			m_AsmSource->LoadFile(m_FileName);
			m_AsmSource->SetModified(false);
		}
		SetTitle(wxString::Format(L"QuickAsm - %s", m_FileName));
	}
		}, wxID_OPEN);

	Bind(wxEVT_MENU, [this](auto& e) { DoSaveAs(e); }, wxID_SAVEAS);

	Bind(wxEVT_MENU, [this](auto& e) {
		if (m_FileName.IsEmpty())
			DoSaveAs(e);
		else {
			m_AsmSource->SaveFile(m_FileName);
			m_AsmSource->SetModified(false);
		}
		}, wxID_SAVE);

	Bind(wxEVT_MENU, [this](auto& e) {
		auto text = m_AsmSource->GetText();
		Assemble(text);
		}, wxID_ASSEMBLE);
	Bind(wxEVT_MENU, [this](auto& e) {
		m_AsmModeIndex = e.GetId() - wxID_16BIT;
		if (!m_AsmBytes.empty())
			Disassemble(m_AsmBytes);
		}, wxID_16BIT, wxID_64BIT);

	Bind(wxEVT_MENU, [this](auto& e) {
		auto selected = e.IsChecked();
		if (selected) {
			auto config = wxConfig::Get();
			config->Write(L"DarkMode", e.GetId() - wxID_DARKTHEME);
			if (wxYES == wxMessageBox(L"Restart QuickAsm for the change to take effect?", L"Quick Asm",
				wxYES | wxNO | wxICON_QUESTION)) {
				wxGetApp().Restart = true;
				Close();
			}
		}
		}, wxID_DARKTHEME, wxID_DARKTHEME + 2);

	m_Assemblers.push_back(std::make_unique<KeystoneAssembler>());
	m_Assemblers.push_back(std::make_unique<NasmAssembler>());

	m_hContinueEvent.reset(::CreateEvent(nullptr, FALSE, FALSE, nullptr));
	m_hStopEvent.reset(::CreateEvent(nullptr, FALSE, FALSE, nullptr));
}

LRESULT MainFrame::MSWWindowProc(WXUINT msg, WXWPARAM wParam, WXLPARAM lParam) {
	bool error = false;
	switch (static_cast<EmulatorMessage>(msg)) {
		case EmulatorMessage::RunError:
			error = true;
			[[fallthrough]];
		case EmulatorMessage::RunComplete:
			m_Emulator.Stop();
			m_Breakpoints.erase(m_Instructions[0].Address + m_AsmBytes.size());
			Enable(wxID_RUN, true);
			Enable(wxID_STOP, false);
			Enable(wxID_ASSEMBLE, true);
			UpdateEmulatorState();
			SetStatusText(L"Idle", 1);
			m_MemoryView->Refresh();
			m_EmulatorState = EmulatorState::Idle;
			m_CurrentLine = 0;
			if (error) {
				wxMessageBox(wxString::Format(L"Execution error at 0x%p: %s", m_CurrentAddress, m_Emulator.GetErrorText((uc_err)wParam)),
					L"Quick ASM", wxICON_ERROR);
			}
			break;

		case EmulatorMessage::BreakpointHit:
			m_EmulatorState = EmulatorState::Breakpoint;
			auto& bp = m_Breakpoints[lParam];
			m_DisamSource->SetIndicatorCurrent(2);
			m_DisamSource->IndicatorFillRange(m_DisamSource->PositionFromLine(bp.Line), m_DisamSource->LineLength(bp.Line));
			UpdateEmulatorState();
			Enable(wxID_RUN, true);
			m_CurrentLine = bp.Line;
			SetStatusText(wxString::Format(L"Breakpoint Line %d (0x%llX)", bp.Line, bp.Address), 1);
			break;
	}
	return wxFrame::MSWWindowProc(msg, wParam, lParam);
}

void MainFrame::OnCreate(wxWindowCreateEvent& event) {
	Unbind(wxEVT_CREATE, &MainFrame::OnCreate, this);

	SetIcon(wxICON(0APP));

	CreateMenu();
	CreateStatusBar(3);

	int widths[] = { 200, 300, -1 };
	SetStatusWidths(3, widths);
	SetStatusText(L"Idle", 1);

	auto tb = CreateToolBar(wxTB_HORZ_LAYOUT | wxTB_HORIZONTAL | wxTB_TEXT);
	wxSize size(24, 24);
	tb->AddTool(wxID_OPEN, L"Open", wxArtProvider::GetIcon(wxART_FILE_OPEN, wxART_TOOLBAR, size));
	tb->AddTool(wxID_SAVE, wxEmptyString, wxArtProvider::GetIcon(wxART_FILE_SAVE, wxART_TOOLBAR, size));
	tb->AddSeparator();
	wxArrayString assemblers;
	assemblers.Add(L"Keystone");
	assemblers.Add(L"NASM");
	auto cbAsm = new wxComboBox(tb, wxID_ANY, wxEmptyString, wxDefaultPosition,
		wxSize(80, -1), assemblers, wxCB_READONLY);
	cbAsm->SetSelection(1);
	cbAsm->Bind(wxEVT_COMBOBOX, [this](auto& e) {
		m_AssemblerIndex = e.GetSelection();
		});
	tb->AddSeparator();
	auto asmIcon = new wxStaticBitmap(tb, wxID_ANY, wxArtProvider::GetIcon(L"BINARY", wxART_TOOLBAR));
	tb->AddControl(asmIcon);
	tb->AddControl(cbAsm);
	tb->AddSeparator();
	tb->AddRadioTool(wxID_16BIT, wxEmptyString, wxArtProvider::GetIcon(L"16BIT", wxART_TOOLBAR, size));
	auto tool = tb->AddRadioTool(wxID_32BIT, wxEmptyString, wxArtProvider::GetIcon(L"32BIT", wxART_TOOLBAR, size));
	tb->AddRadioTool(wxID_64BIT, wxEmptyString, wxArtProvider::GetIcon(L"64BIT", wxART_TOOLBAR, size));
	tool->Toggle(true);
	tb->AddSeparator();
	tb->AddControl(new wxStaticText(tb, wxID_ANY, L"Address:"));
	tb->AddControl(m_AddressText = new wxTextCtrl(tb, wxID_ANY, "0x1000", wxDefaultPosition, wxSize(100, -1), wxTE_RIGHT));
	tb->AddSeparator();
	tb->AddTool(wxID_ASSEMBLE, L"Assemble", wxArtProvider::GetIcon(L"BUILD", wxART_TOOLBAR, size))->Enable(false);
	tb->AddSeparator();
	tb->AddTool(wxID_RUN, L"Run", wxArtProvider::GetIcon(L"RUN", wxART_TOOLBAR, size))->Enable(false);
	tb->AddTool(wxID_STOP, L"", wxArtProvider::GetIcon("STOP", wxART_TOOLBAR, size))->Enable(false);
	tb->AddTool(wxID_RESTART, L"", wxArtProvider::GetIcon("RESTART", wxART_TOOLBAR, size))->Enable(false);
	tb->AddSeparator();
	tb->AddTool(wxID_STEPOVER, L"", wxArtProvider::GetIcon("STEPOVER", wxART_TOOLBAR, size))->Enable(false);
	tb->AddTool(wxID_STEPINTO, L"", wxArtProvider::GetIcon("STEPINTO", wxART_TOOLBAR, size))->Enable(false);
	tb->AddSeparator();
	tb->AddTool(wxID_TOGGLEBP, L"", wxArtProvider::GetIcon("BREAKPOINT", wxART_TOOLBAR, size))->Enable(false);
	tb->Realize();

	m_Splitter = new wxSplitterWindow(this, wxID_ANY);
	m_Splitter->SetMinimumPaneSize(150);
	m_Splitter->SetWindowStyleFlag(wxSP_LIVE_UPDATE | wxSP_BORDER);

	m_HSplitter = new wxSplitterWindow(m_Splitter, wxID_ANY);
	m_HSplitter->SetMinimumPaneSize(150);
	m_HSplitter->SetWindowStyleFlag(wxSP_LIVE_UPDATE | wxSP_BORDER);

	m_AsmSource = new AssemblyEditCtrl;
	m_AsmSource->Create(m_Splitter, wxID_ANY);
	m_AsmSource->Init();
	m_AsmSource->Bind(wxEVT_STC_UPDATEUI, [this](auto& e) {
		m_HexViewActive = false;
		auto anyText = m_AsmSource->GetTextLength() > 0;
		Enable(wxID_SAVEAS, anyText);
		Enable(wxID_ASSEMBLE, anyText);
		auto modified = m_AsmSource->IsModified();
		Enable(wxID_SAVE, modified);
		if (modified != m_Modified) {
			m_Modified = modified;
			if (!m_FileName.IsEmpty())
				SetTitle(wxString::Format(L"QuickAsm - %s%s", m_FileName, modified ? L"*" : L""));
		}
		Enable(wxID_UNDO, m_AsmSource->CanUndo());
		Enable(wxID_REDO, m_AsmSource->CanRedo());
		Enable(wxID_COPY, m_AsmSource->CanCopy());
		Enable(wxID_PASTE, m_AsmSource->CanPaste());
		Enable(wxID_CLEAR, !m_AsmSource->GetReadOnly());
		Enable(wxID_CUT, m_AsmSource->CanCut());
		});

	m_DisamSource = new AssemblyEditCtrl;
	m_DisamSource->Bind(wxEVT_STC_UPDATEUI, [this](auto& e) {
		m_HexViewActive = false;
		Enable(wxID_COPY, m_DisamSource->CanCopy());
		Enable(wxID_UNDO, false);
		Enable(wxID_REDO, false);
		Enable(wxID_CUT, false);
		Enable(wxID_PASTE, false);
		Enable(wxID_CLEAR, false);
		});

	m_DisamSource->Bind(wxEVT_STC_MARGINCLICK, [this](auto& e) {
		if (e.GetMargin() == 1) {
			ToggleBreakpoint(m_DisamSource->LineFromPosition(e.GetPosition()));
		}
		});

	Bind(wxEVT_MENU, [this](auto& e) { Run(e); }, wxID_RUN);
	Bind(wxEVT_MENU, [this](auto& e) { Stop(e); }, wxID_STOP);
	Bind(wxEVT_MENU, [this](auto& e) { ToggleBreakpoint(e); }, wxID_TOGGLEBP);
	Bind(wxEVT_MENU, [this](auto& e) {
		BreakpointInfo bp;
		bp.Address = m_Instructions[m_CurrentLine].Address + m_Instructions[m_CurrentLine].Bytes.size();
		bp.Line = m_CurrentLine + 1;
		bp.OneShot = true;
		m_Breakpoints.insert({ bp.Address, bp });
		Run(e);
		}, wxID_STEPOVER);

	//
	// build right pane
	//
	m_DisamSource->Create(m_HSplitter, wxID_ANY);
	m_DisamSource->Init();
	m_DisamSource->SetReadOnly(true);

	m_Splitter->SplitVertically(m_AsmSource, m_HSplitter, 500);

	m_Notebook = new wxNotebook(m_HSplitter, wxID_ANY);
	m_HSplitter->SplitHorizontally(m_DisamSource, m_Notebook, 400);
	m_AsmSource->SetFocus();

	// create tabs
	m_ImageList.Create(16, 16);
	PCWSTR names[] = { L"REGISTERS", L"MEMORY", L"BREAKPOINT" };
	for (auto name : names)
		m_ImageList.Add(wxIcon(name, wxBITMAP_TYPE_ICO_RESOURCE, 16, 16));
	m_Notebook->SetImageList(&m_ImageList);

	//
	// create registers tab
	//
	auto frame = new wxPanel(m_Notebook);
	size = wxSize(16, 16);
	tb = new wxToolBar(frame, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTB_HORZ_LAYOUT | wxTB_HORIZONTAL | wxTB_NODIVIDER);
	tb->AddCheckTool(wxID_8BITREG, wxEmptyString, wxArtProvider::GetIcon(L"8BIT", wxART_TOOLBAR, size));
	tb->AddCheckTool(wxID_16BITREG, wxEmptyString, wxArtProvider::GetIcon(L"16BIT", wxART_TOOLBAR, size));
	tb->AddCheckTool(wxID_32BITREG, wxEmptyString, wxArtProvider::GetIcon(L"32BIT", wxART_TOOLBAR, size))->Toggle(true);
	tb->AddCheckTool(wxID_64BITREG, wxEmptyString, wxArtProvider::GetIcon(L"64BIT", wxART_TOOLBAR, size));
	tb->AddSeparator();
	tb->AddTool(wxID_EDIT, wxEmptyString, wxArtProvider::GetIcon(wxART_EDIT, wxART_TOOLBAR, size));
	tb->Realize();

	Bind(wxEVT_MENU, [this](auto& e) {
		if(m_RegistersList.GetFirstSelected() >= 0) 
			EditRegisterValue(m_RegistersList.GetFirstSelected());
		}, wxID_EDIT);

	m_RegistersList.Create(frame, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLC_REPORT | wxLC_SINGLE_SEL);
	auto sizer = new wxBoxSizer(wxVERTICAL);
	sizer->Add(tb, 0, wxALIGN_TOP | wxEXPAND);
	sizer->Add(&m_RegistersList, 1, wxEXPAND);
	frame->SetSizer(sizer);

	m_RegistersList.InsertColumn(0, L"Name", wxLIST_FORMAT_LEFT, 60);
	m_RegistersList.InsertColumn(1, L"Size", wxLIST_FORMAT_RIGHT, 55);
	m_RegistersList.InsertColumn(2, L"Value", wxLIST_FORMAT_RIGHT, 150);
	m_RegistersList.InsertColumn(3, L"Type", wxLIST_FORMAT_LEFT);
	m_RegistersList.InsertColumn(4, L"Details", wxLIST_FORMAT_LEFT, 200);

	m_RegistersList.Bind(wxEVT_LIST_ITEM_ACTIVATED, [this](auto& e) {
		auto index = e.GetIndex();
		if (index < 0)
			return;
		EditRegisterValue(index);
		});

	m_RegistersList.Bind(wxEVT_LIST_COL_CLICK, [this](auto& e) {
		auto col = e.GetColumn();
		auto asc = m_RegistersList.GetUpdatedAscendingSortIndicator(col);
		DoSortRegisters(col, asc);
		});

	Bind(wxEVT_MENU, [this](auto& e) {
		if (e.IsChecked())
			m_RegViewFilter |= 1 << (e.GetId() - wxID_8BITREG);
		else
			m_RegViewFilter &= ~(1 << (e.GetId() - wxID_8BITREG));
		ShowRegisters();
		}, wxID_8BITREG, wxID_FLOAT);

	m_Notebook->AddPage(frame, L"Registers", true, 0);

	auto panel = new HexViewPanel(m_Notebook, this);

	m_MemoryView = new wxHexView(panel);
	auto dark = wxSystemSettings::GetAppearance().IsDark();
	if (dark) {
		m_MemoryView->SetColor(ColorType::Background, 0x0E0E0E);
		m_MemoryView->SetColor(ColorType::Hexodd, 0xF0F0F0);
		m_MemoryView->SetColor(ColorType::Hexeven, 0xF0F0F0);
		m_MemoryView->SetColor(ColorType::Address, 0x00F0F0);
		m_MemoryView->SetColor(ColorType::Ascii, 0xF0F000);
	}
	panel->SetHexView(m_MemoryView);

	auto font = new wxFont(12, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false, L"Consolas");
	m_MemoryView->SetFont(*font);
	m_MemoryView->InitSharedBuffer(m_Memory.data(), (ULONG)m_Memory.size());

	tb = new wxToolBar(panel, wxID_ANY);
	tb->AddRadioTool(wxID_1BYTE, wxEmptyString, wxArtProvider::GetIcon(L"1BYTE", wxART_TOOLBAR))->Toggle(true);
	tb->AddRadioTool(wxID_1BYTE + 1, wxEmptyString, wxArtProvider::GetIcon(L"2BYTES", wxART_TOOLBAR));
	tb->AddRadioTool(wxID_1BYTE + 2, wxEmptyString, wxArtProvider::GetIcon(L"4BYTES", wxART_TOOLBAR));
	tb->AddRadioTool(wxID_1BYTE + 3, wxEmptyString, wxArtProvider::GetIcon(L"8BYTES", wxART_TOOLBAR));
	tb->Realize();
	Bind(wxEVT_MENU, [this](auto& e) {
		auto id = e.GetId() - wxID_1BYTE;
		m_MemoryView->SetGrouping(1 << id);
		}, wxID_1BYTE, wxID_1BYTE + 3);


	sizer = new wxBoxSizer(wxVERTICAL);
	sizer->Add(tb, 0, wxTOP);
	sizer->Add(m_MemoryView, 1, wxEXPAND);
	panel->SetSizer(sizer);
	m_Notebook->AddPage(panel, L"Memory", false, 1);

	m_Notebook->AddPage(new wxPanel(m_Notebook), L"Breakpoints", false, 2);
}

void MainFrame::Enable(int id, bool enable) {
	GetMenuBar()->Enable(id, enable);
	GetToolBar()->EnableTool(id, enable);
}

void MainFrame::ShowRegisters() {
	m_RegistersList.DeleteAllItems();
	if (!m_Emulator.IsOpen())
		return;

	auto mode = m_Emulator.GetMode();
	int i = 0;
	for (auto& ri : AllRegisters) {
		//auto floatRegs = (ri.Category & RegisterType::FloatingPoint) == RegisterType::FloatingPoint;
		if (((DWORD)ri.Category & (DWORD)mode) && (m_RegViewFilter & (ri.Size >> 3))) {
			auto index = m_RegistersList.InsertItem(m_RegistersList.GetItemCount(), ri.Name);
			m_RegistersList.SetItemData(index, i);
			m_RegistersList.SetItem(index, 1, wxString::Format(L"%d bit", ri.Size));
			SetRegisterValue(index, ri);
			m_RegistersList.SetItem(index, 3, Helpers::RegisterTypeToString(ri.Category));
		}
		i++;
	}
	DoSortRegisters(m_RegistersList.GetSortIndicator(), m_RegistersList.IsAscendingSortIndicator());
}

void MainFrame::RunOnThreadPool() {
	m_Emulator.HookCode(HookType::CODE, [&](auto address, auto) {
		m_CurrentAddress = address;
		if (auto it = m_Breakpoints.find(address); it != m_Breakpoints.end()) {
			auto& bp = it->second;
			::PostMessage(GetHandle(), UINT(EmulatorMessage::BreakpointHit), 0, address);
			m_BreakpointAddress = address;
			HANDLE hEvents[] = { m_hContinueEvent.get(), m_hStopEvent.get() };
			auto rc = ::WaitForMultipleObjects(_countof(hEvents), hEvents, FALSE, INFINITE);
			if (rc == WAIT_OBJECT_0)
				return;

			m_Emulator.Stop();
			::PostMessage(this->GetHandle(), UINT(EmulatorMessage::RunComplete), 0, 0);
			m_CurrentLine = bp.Line;
		}
		else {
			m_CurrentLine++;
		}
		}, m_Instructions[0].Address, m_Instructions[0].Address + m_AsmBytes.size());
	auto ok = m_Emulator.Start(m_Instructions[0].Address, m_Instructions[0].Address + m_AsmBytes.size());
	::PostMessage(this->GetHandle(), UINT(ok ? EmulatorMessage::RunComplete : EmulatorMessage::RunError), m_Emulator.LastError(), 0);
}

bool MainFrame::EditRegisterValue(int index) {
	auto id = m_RegistersList.GetItemData(index);
	auto& ri = AllRegisters[id];
	if ((ri.Category & (RegisterType::General | RegisterType::Segment)) == RegisterType::None) {
		wxASSERT(false);
		return false;
	}

	auto text = wxGetTextFromUser(L"New value:", L"Value for register " + ri.Name, m_RegistersList.GetItemText(index, 2), this);
	if (text.IsEmpty())
		return false;

	auto value = wcstoull(text.ToStdWstring().c_str(), nullptr, 0);
	m_Emulator.WriteReg(ri.Id, value);
	UpdateEmulatorState();
	return true;
}

wxString MainFrame::GetRegisterValueDetails(const void* pValue, RegisterInfo const& ri) const {
	switch (ri.Id) {
		case x86Register::CR0: return Helpers::CR0ToString(*(uint64_t*)pValue);
	}
	return wxString();
}

void MainFrame::Run(wxCommandEvent& e) {
	if (!m_Emulator.IsOpen())
		Assemble(m_AsmSource->GetText());
	if (m_Instructions.empty())
		return;

	switch (m_EmulatorState) {
		case EmulatorState::Idle:
			m_BreakpointAddress = m_CurrentAddress = 0;
			m_CurrentLine = 0;
			Enable(wxID_STOP, true);
			Enable(wxID_RUN, false);
			Enable(wxID_ASSEMBLE, false);
			m_EmulatorState = EmulatorState::Running;
			::TrySubmitThreadpoolCallback([](auto, auto p) {
				((MainFrame*)p)->RunOnThreadPool();
				}, this, nullptr);
			break;

		case EmulatorState::Breakpoint:
		{
			auto& bp = m_Breakpoints[m_BreakpointAddress];
			m_DisamSource->IndicatorClearRange(m_DisamSource->PositionFromLine(bp.Line), m_DisamSource->LineLength(bp.Line));
			if (bp.OneShot)
				m_Breakpoints.erase(bp.Address);
			::SetEvent(m_hContinueEvent.get());
		}
		break;
	}
	SetStatusText(L"Running", 1);
}

void MainFrame::Stop(wxCommandEvent& e) {
	if (m_BreakpointAddress) {
		auto& bp = m_Breakpoints[m_BreakpointAddress];
		m_DisamSource->IndicatorClearRange(m_DisamSource->PositionFromLine(bp.Line), m_DisamSource->LineLength(bp.Line));
	}
	switch (m_EmulatorState) {
		case EmulatorState::Running:
			m_Emulator.Stop();
			m_EmulatorState = EmulatorState::Idle;
			UpdateEmulatorState();
			Enable(wxID_RUN, true);
			Enable(wxID_STOP, false);
			Enable(wxID_ASSEMBLE, true);
			break;

		case EmulatorState::Breakpoint:
			::SetEvent(m_hStopEvent.get());
			break;
	}
	SetStatusText(L"Idle", 1);
}

void MainFrame::ToggleBreakpoint(wxCommandEvent& e) {
	auto line = m_DisamSource->GetCurrentLine();
	ToggleBreakpoint(line);
}

void MainFrame::ToggleBreakpoint(int line) {
	if (line >= m_Instructions.size()) {
		::MessageBeep(-1);
		return;
	}

	if (m_DisamSource->ToggleBreakpoint(line)) {
		BreakpointInfo bp;
		bp.Address = m_Instructions[line].Address;
		bp.Line = line;
		m_Breakpoints.insert({ bp.Address, bp });
	}
	else
		m_Breakpoints.erase(m_Instructions[line].Address);
}

void MainFrame::UpdateEmulatorState() {
	for (int i = 0; i < m_RegistersList.GetItemCount(); i++) {
		auto index = m_RegistersList.GetItemData(i);
		auto& ri = AllRegisters[index];
		//auto oldValue = wcstoull(m_RegistersList.GetItemText(i, 2).ToStdWstring().c_str(), nullptr, 0);
		SetRegisterValue(i, ri);
	}
}

void MainFrame::SetRegisterValue(int i, RegisterInfo const& ri) {
	if ((ri.Category & RegisterType::Descriptor) == RegisterType::None) {
		auto value = m_Emulator.ReadReg<size_t>(ri.Id);
		m_RegistersList.SetItem(i, 2, wxString::Format(L"0x%llX", value));
		if (ri.Id == x86Register::EFLAGS)
			m_RegistersList.SetItem(i, 4, Helpers::CPUFlagsToString((uint32_t)value));
		else {
			wxString text;
			switch (ri.Size) {
				case 8: text = wxString::Format(L"%u (%d)", (uint8_t)value, (int8_t)value); break;
				case 16: text = wxString::Format(L"%u (%d)", (uint16_t)value, (int16_t)value); break;
				case 32: text = wxString::Format(L"%u (%d)", (uint32_t)value, (int32_t)value); break;
				case 64: text = wxString::Format(L"%llu (%lld)", value, (int64_t)value); break;
			}
			text += L" " + GetRegisterValueDetails(&value, ri);
			m_RegistersList.SetItem(i, 4, text);
		}
	}
	else {
		auto value = m_Emulator.ReadReg<uc_x86_mmr>(ri.Id);
		m_RegistersList.SetItem(i, 2, wxString::Format(L"0x%X:%llX", value.limit, value.base));
	}
	m_RegistersList.RefreshItems(0, 10);
}

void MainFrame::DoSortRegisters(int col, bool asc) {
	if (col < 0)
		return;

	struct Data {
		int Col;
		bool Asc;
		bool Sorted{ true };
	} args{ col, asc };
	m_RegistersList.SortItems([](auto i1, auto i2, auto p) {
		auto args = (Data*)p;
		auto& r1 = AllRegisters[i1];
		auto& r2 = AllRegisters[i2];
		int r = 0;
		switch (args->Col) {
			case 0: r = strcmp(r1.Name.c_str(), r2.Name.c_str()); break;
			case 1: r = r1.Size - r2.Size; break;
			case 3: r = _wcsicmp(Helpers::RegisterTypeToString(r1.Category), Helpers::RegisterTypeToString(r2.Category)); break;
			default: args->Sorted = false; break;
		}
		if (!args->Asc)
			r = -r;
		return r;
		}, (wxIntPtr)&args);
	if (args.Sorted)
		m_RegistersList.ShowSortIndicator(col, asc);

}

void MainFrame::Disassemble(std::vector<uint8_t> const& bytes) {
	Disassemble(bytes.data(), bytes.size());
}

void MainFrame::DoSaveAs(wxCommandEvent&) {
	wxFileDialog dlg(this, L"Save Assembly file", wxEmptyString, wxEmptyString,
		L"Assembly files (*.asm)|*.asm|All files (*.*)|*.*", wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
	if (dlg.ShowModal() == wxID_OK) {
		m_AsmSource->SaveFile(dlg.GetPath());
		m_FileName = dlg.GetPath();
		m_AsmSource->SetModified(false);
	}
}

void MainFrame::CreateMenu() {
	// File menu
	wxSize size(16, 16);

	auto menuFile = new wxMenu;
	menuFile->Append(wxID_OPEN)->SetBitmap(wxArtProvider::GetIcon(wxART_FILE_OPEN, wxART_MENU, size));
	auto item = menuFile->Append(wxID_SAVE);
	item->Enable(false);
	item->SetBitmap(wxArtProvider::GetIcon(wxART_FILE_SAVE, wxART_MENU, size));
	item = menuFile->Append(wxID_SAVEAS);
	item->Enable(false);
	item->SetBitmap(wxArtProvider::GetIcon(wxART_FILE_SAVE_AS, wxART_MENU, size));
	menuFile->Append(wxID_CLOSE)->Enable(false);
	menuFile->AppendSeparator();
	item = menuFile->Append(wxID_EXIT);

	// Edit menu
	auto menuEdit = new wxMenu;
	menuEdit->Append(wxID_UNDO)->SetBitmap(wxArtProvider::GetIcon(wxART_UNDO, wxART_MENU, size));
	menuEdit->Append(wxID_REDO)->SetBitmap(wxArtProvider::GetIcon(wxART_REDO, wxART_MENU, size));
	menuEdit->AppendSeparator();
	menuEdit->Append(wxID_CUT)->SetBitmap(wxArtProvider::GetIcon(wxART_CUT, wxART_MENU, size));
	menuEdit->Append(wxID_COPY)->SetBitmap(wxArtProvider::GetIcon(wxART_COPY, wxART_MENU, size));
	menuEdit->Append(wxID_PASTE)->SetBitmap(wxArtProvider::GetIcon(wxART_PASTE, wxART_MENU, size));
	menuEdit->Append(wxID_CLEAR);
	menuEdit->AppendSeparator();
	menuEdit->Append(wxID_FIND);

	auto asmMenu = new wxMenu;
	item = asmMenu->Append(wxID_ASSEMBLE, _("&Assemble\tF7"));
	item->Enable(false);
	item->SetBitmap(wxArtProvider::GetIcon(L"BUILD", wxART_MENU, size));
	asmMenu->AppendSeparator();
	item = asmMenu->Append(wxID_RUN, _("&Run\tF5"));
	item->SetBitmap(wxArtProvider::GetIcon(L"RUN", wxART_MENU, size));
	item = asmMenu->Append(wxID_STOP, _("&Stop\tShift+F5"));
	item->SetBitmap(wxArtProvider::GetIcon(L"STOP", wxART_MENU, size));
	asmMenu->AppendSeparator();
	asmMenu->Append(wxID_STEPOVER, L"Step Over\tF10")->SetBitmap(wxArtProvider::GetIcon(L"STEPOVER", wxART_MENU, size));
	asmMenu->Append(wxID_STEPINTO, L"Step Into\tF11")->SetBitmap(wxArtProvider::GetIcon(L"STEPINTO", wxART_MENU, size));;
	asmMenu->AppendSeparator();
	item = asmMenu->Append(wxID_TOGGLEBP, L"Toggle Breakpoint\tF9");
	item->SetBitmap(wxArtProvider::GetIcon(L"BREAKPOINT", wxART_MENU, size));

	auto options = new wxMenu;
	auto dark = wxSystemSettings::GetAppearance().IsDark();
	auto darkMenu = new wxMenu;
	darkMenu->Append(wxID_DARKTHEME, L"Dark Theme", wxEmptyString, wxITEM_RADIO);
	darkMenu->Append(wxID_DARKTHEME + 1, L"Light Theme", wxEmptyString, wxITEM_RADIO);
	darkMenu->Append(wxID_DARKTHEME + 2, L"Same as System", wxEmptyString, wxITEM_RADIO);
	auto value = wxConfig::Get()->ReadLong(L"DarkMode", 1);
	darkMenu->Check(wxID_DARKTHEME + value, true);
	options->AppendSubMenu(darkMenu, L"Theme");

	m_MenuBar = new wxMenuBar;
	m_MenuBar->Append(menuFile, L"&File");
	m_MenuBar->Append(menuEdit, L"&Edit");
	m_MenuBar->Append(asmMenu, L"&Assembly");
	m_MenuBar->Append(options, L"&Options");

	SetMenuBar(m_MenuBar);
}

void MainFrame::OnExit(wxCommandEvent& event) {
	Close();
}

void MainFrame::Assemble(const wxString& text) {
	auto assembler = m_Assemblers[m_AssemblerIndex].get();
	assembler->SetValue("mode", 1 << (4 + m_AsmModeIndex));
	assembler->SetValue("address", std::wcstoll(m_AddressText->GetValue().ToStdWstring().c_str(), nullptr, 0));

	AssemblerResults results;
	results = assembler->Assemble(m_AsmSource->GetText().utf8_string());

	if (results.Error) {
		m_DisamSource->SetReadOnly(false);
		m_DisamSource->SetText(results.Output);
		m_DisamSource->SetReadOnly(true);
		m_AsmBytes.clear();
		m_Instructions.clear();
		Enable(wxID_RUN, false);
		Enable(wxID_STEPOVER, false);
		Enable(wxID_STEPINTO, false);
	}
	else {
		if (results.Bytes.empty())
			m_AsmBytes = Helpers::ReadFileContents(results.OutputFile.c_str());
		else
			m_AsmBytes = std::move(results.Bytes);
		Disassemble(m_AsmBytes);
	}
}

void MainFrame::Disassemble(uint8_t const* data, size_t size) {
	auto mode = 1 << (1 + m_AsmModeIndex);
	CapstoneEngine cs;
	if (cs.Open((cs_mode)mode)) {
		m_Instructions = cs.Disassemble(data, size, std::wcstoll(m_AddressText->GetValue().ToStdWstring().c_str(), nullptr, 0));
		m_DisamSource->SetReadOnly(false);
		m_DisamSource->ClearAll();
		for (auto& insn : m_Instructions) {
			m_DisamSource->AppendText(wxString::Format("0x%08X %-8s %-24s ;",
				(DWORD)insn.Address, insn.Mnemonic, insn.Operands));
			for (auto b : insn.Bytes) {
				m_DisamSource->AppendText(wxString::Format(L" %02X", b));
			}
			m_DisamSource->AppendText(L"\n");
		}
		m_DisamSource->SetReadOnly(true);
		if (!m_Instructions.empty()) {
			m_Emulator.Open(CpuArch::x86, (CpuMode)mode);
			m_Emulator.MapHostMemory(0, m_Memory.size(), MemProtection::All, m_Memory.data());
			m_Emulator.WriteMemory(m_Instructions[0].Address, data, size);
			m_MemoryView->Refresh();
			m_MemoryView->ScrollTop(m_Instructions[0].Address);

			ShowRegisters();
			Enable(wxID_TOGGLEBP, true);
			Enable(wxID_RUN, true);
			Enable(wxID_STEPOVER, true);
			Enable(wxID_STEPINTO, true);
			m_Breakpoints.clear();
		}
	}
}

bool MainFrame::OnHexViewNotify(wxHexView* pHexView, int idCtrl, LPNMHDR hdr, WXLPARAM* result) {
	switch (hdr->code) {
		case HVN_CHANGED:
		case HVN_SELECTION_CHANGE:
			Enable(wxID_COPY, pHexView->CanCopy());
			Enable(wxID_UNDO, pHexView->CanUndo());
			Enable(wxID_REDO, pHexView->CanRedo());
			Enable(wxID_CUT, pHexView->CanDelete());
			Enable(wxID_CLEAR, pHexView->CanDelete());
			Enable(wxID_PASTE, pHexView->CanPaste());
			m_HexViewActive = true;
			return true;
	}
	return false;
}

```

`QuickAsm/MainFrame.h`:

```h
#pragma once

#include "AssemblyEditCtrl.h"
#include "CapstoneEngine.h"
#include "UnicornEngine.h"
#include "HexViewPanel.h"

class AssemblerBase;
struct RegisterInfo;
class wxHexView;

class MainFrame : public wxFrame, public IHexViewNotify {
	wxDECLARE_DYNAMIC_CLASS(MainFrame);
public:
	MainFrame();

	LRESULT MSWWindowProc(WXUINT msg, WXWPARAM wParam, WXLPARAM lParam) override;

private:
	void OnCreate(wxWindowCreateEvent& event);
	void CreateMenu();
	void OnExit(wxCommandEvent& event);
	void Assemble(const wxString& text);
	void Disassemble(uint8_t const* data, size_t size);
	void Disassemble(std::vector<uint8_t> const& bytes);
	void DoSaveAs(wxCommandEvent& event);
	void Enable(int id, bool enable);
	void ShowRegisters();
	void Run(wxCommandEvent& e);
	void Stop(wxCommandEvent& e);
	void ToggleBreakpoint(wxCommandEvent& e);
	void ToggleBreakpoint(int line);

	void UpdateEmulatorState();
	void SetRegisterValue(int row, RegisterInfo const& reg);
	void DoSortRegisters(int col, bool asc);
	void RunOnThreadPool();
	bool OnHexViewNotify(wxHexView* pHexView, int idCtrl, LPNMHDR hdr, WXLPARAM* result) override;
	bool EditRegisterValue(int row);
	wxString GetRegisterValueDetails(const void* pValue, RegisterInfo const& ri) const;

	enum class EmulatorState {
		Idle,
		Running,
		Breakpoint,
	};

	enum class EmulatorMessage {
		RunComplete = WM_USER + 100,
		BreakpointHit,
		RunError,
	};

	struct BreakpointInfo {
		size_t Address;
		int Line;
		bool IsEnabled : 1{ true };
		bool OneShot : 1{ false };
	};

	wxSplitterWindow* m_Splitter;
	wxSplitterWindow* m_HSplitter;
	wxNotebook* m_Notebook;
	wxListView m_RegistersList;
	AssemblyEditCtrl* m_AsmSource;
	AssemblyEditCtrl* m_DisamSource;
	wxTextCtrl* m_AddressText;
	wxMenuBar* m_MenuBar;
	wxHexView* m_MemoryView;
	int m_AsmModeIndex{ 1 };
	wxString m_FileName;
	int m_AssemblerIndex{ 1 };
	std::vector<std::unique_ptr<AssemblerBase>> m_Assemblers;
	std::unordered_map<size_t, BreakpointInfo> m_Breakpoints;
	std::vector<uint8_t> m_AsmBytes;
	wxImageList m_ImageList;
	std::vector<Instruction> m_Instructions;
	UnicornEngine m_Emulator;
	EmulatorState m_EmulatorState;
	DWORD m_RegViewFilter{ 1 << 2 };
	void* m_EmulatorContext{ nullptr };
	std::vector<uint8_t> m_Memory;
	wil::unique_handle m_hContinueEvent, m_hStopEvent;
	std::atomic<uint64_t> m_BreakpointAddress{ 0 };
	std::atomic<int> m_CurrentLine{ 0 };
	uint64_t m_CurrentAddress;
	bool m_Modified{ false };
	bool m_HexViewActive{ false };
};


```

`QuickAsm/NasmAssembler.cpp`:

```cpp
#include "pch.h"
#include "NasmAssembler.h"
#include "Helpers.h"
#include <fstream>

NasmAssembler::NasmAssembler() {
	SetName(L"NASM");
	//
	// try the exe directory
	//
	WCHAR path[MAX_PATH];
	::GetModuleFileName(nullptr, path, _countof(path));
	*wcsrchr(path, L'\\') = 0;
	m_NasmDir = path;
	wcscat_s(path, L"\\nasm.exe");
	if (::GetFileAttributes(path) != INVALID_FILE_ATTRIBUTES)
		m_NasmPath = path;
}

AssemblerResults NasmAssembler::AssembleFile(std::wstring const& file) {
	AssemblerResults results{};
	if (m_NasmPath.empty()) {
		results.Error = ERROR_FILE_NOT_FOUND;
		return results;
	}

	auto modeValue = GetIntValue("mode");
	std::string prefix;
	int extraLines = 0;
	if (modeValue) {
		prefix = "bits " + std::to_string(*modeValue) + "\n";
		extraLines++;
	}

	auto address = GetIntValue("address");
	if (address) {
		prefix += "org " + std::to_string(*address) + "\n";
		extraLines++;
	}

	auto srcFile = file;
	if (!prefix.empty()) {
		auto hFile = ::CreateFile(file.c_str(), GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);
		if (hFile != INVALID_HANDLE_VALUE) {
			auto size = ::GetFileSize(hFile, nullptr);
			std::vector<BYTE> buffer(size);
			DWORD read;
			::ReadFile(hFile, buffer.data(), (DWORD)buffer.size(), &read, nullptr);
			auto tempSrc = Helpers::GetTempFilePath(L"src");
			auto hSrc = ::CreateFile(tempSrc.c_str(), GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 0, nullptr);
			if (hSrc != INVALID_HANDLE_VALUE) {
				::WriteFile(hSrc, prefix.data(), (DWORD)prefix.length(), &read, nullptr);
				::WriteFile(hSrc, buffer.data(), (DWORD)buffer.size(), &read, nullptr);
				::CloseHandle(hSrc);
				srcFile = tempSrc;
			}
			::CloseHandle(hFile);
		}
	}

	PROCESS_INFORMATION pi;
	STARTUPINFO si{ sizeof(si) };
	auto tempOutput = Helpers::GetTempFilePath(L"log");
	std::wstring objOutput = file.data();
	objOutput = objOutput.substr(0, file.rfind(L'.')) + L".bin";

	auto fullcmdline = m_NasmPath + L" -Z" + tempOutput + L" -o " + objOutput + L" " + srcFile;
	if (::CreateProcess(nullptr, fullcmdline.data(), nullptr, nullptr, FALSE,
		CREATE_NO_WINDOW, nullptr, m_NasmDir.c_str(), &si, &pi)) {
		::WaitForSingleObject(pi.hProcess, INFINITE);
		std::ifstream stm(tempOutput);
		if (stm.good()) {
			char line[1024];
			while(!stm.eof()) {
				stm.getline(line, sizeof(line));
				auto colon = strchr(line + 2, ':');
				if (colon == nullptr)
					break;
				if (extraLines) {
					//
					// subtract line number to align with actual assembly text
					//
					auto colon2 = strchr(colon + 1, ':');
					auto lineNum = atoi(colon + 1);
					lineNum -= extraLines;
					results.Output += std::to_string(lineNum) + ":" + (colon2 + 1);
				}
				else {
					results.Output += colon + 1;
				}
				results.Output += '\n';
			}
		}
	}
	if (results.Output.empty())
		results.OutputFile = objOutput;
	else
		results.Error = 1;

	::CloseHandle(pi.hProcess);
	::CloseHandle(pi.hThread);
	return results;
}

```

`QuickAsm/NasmAssembler.h`:

```h
#pragma once

#include "AssemblerBase.h"

class NasmAssembler : public AssemblerBase {
public:
	NasmAssembler();
	AssemblerResults AssembleFile(std::wstring const& file) override;

	void SetNasmPath(std::wstring path);
	std::wstring const& GetNasmPath() const;

private:
	std::wstring m_NasmPath;
	std::wstring m_NasmDir;
};


```

`QuickAsm/NewScrollingDialog.cpp`:

```cpp
#include "NewScrollingDialog.h"

//(*InternalHeaders(NewScrollingDialog)
#include <wx/intl.h>
#include <wx/string.h>
//*)

//(*IdInit(NewScrollingDialog)
//*)

BEGIN_EVENT_TABLE(NewScrollingDialog,wxScrollingDialog)
	//(*EventTable(NewScrollingDialog)
	//*)
END_EVENT_TABLE()

NewScrollingDialog::NewScrollingDialog(wxWindow* parent,wxWindowID id)
{
	//(*Initialize(NewScrollingDialog)
	Create(parent, id, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE, _T("id"));
	//*)
}

NewScrollingDialog::~NewScrollingDialog()
{
	//(*Destroy(NewScrollingDialog)
	//*)
}


```

`QuickAsm/NewScrollingDialog.h`:

```h
#ifndef NEWSCROLLINGDIALOG_H
#define NEWSCROLLINGDIALOG_H

//(*Headers(NewScrollingDialog)
#include "scrollingdialog.h"
//*)

class NewScrollingDialog: public wxScrollingDialog
{
	public:

		NewScrollingDialog(wxWindow* parent,wxWindowID id=wxID_ANY);
		virtual ~NewScrollingDialog();

		//(*Declarations(NewScrollingDialog)
		//*)

	protected:

		//(*Identifiers(NewScrollingDialog)
		//*)

	private:

		//(*Handlers(NewScrollingDialog)
		//*)

		DECLARE_EVENT_TABLE()
};

#endif

```

`QuickAsm/QuickAsm.cbp`:

```cbp
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="QuickAsm" />
		<Option pch_mode="2" />
		<Option compiler="clang" />
		<Build>
			<Target title="Debug Win32">
				<Option output="../Debug/QuickAsm" prefix_auto="1" extension_auto="1" />
				<Option object_output="Debug/" />
				<Option deps_output="../Debug/" />
				<Option type="0" />
				<Option compiler="clang" />
				<Compiler>
					<Add option="/D_UNICODE /DUNICODE" />
					<Add option="/Zi" />
					<Add option="/DWIN32" />
					<Add option="/D_DEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/W3" />
				</Compiler>
				<Linker>
					<Add option="/debug" />
					<Add library="winmm.lib" />
					<Add library="comctl32.lib" />
					<Add library="kernel32.lib" />
					<Add library="user32.lib" />
					<Add library="gdi32.lib" />
					<Add library="winspool.lib" />
					<Add library="comdlg32.lib" />
					<Add library="advapi32.lib" />
					<Add library="shell32.lib" />
					<Add library="ole32.lib" />
					<Add library="oleaut32.lib" />
					<Add library="uuid.lib" />
					<Add library="odbc32.lib" />
					<Add library="odbccp32.lib" />
				</Linker>
			</Target>
			<Target title="Debug x64">
				<Option output="../Debug/QuickAsm" prefix_auto="1" extension_auto="1" />
				<Option object_output="Debug/" />
				<Option deps_output="../Debug/" />
				<Option type="0" />
				<Option compiler="clang" />
				<Compiler>
					<Add option="/D_UNICODE /DUNICODE" />
					<Add option="/Zi" />
					<Add option="/D__WXDEBUG__" />
					<Add option="/D__WXMSW__" />
					<Add option="/D_DEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/MDd" />
					<Add option="/W3" />
					<Add directory="$(WXWIN)/include/msvc/" />
					<Add directory="$(WXWIN)/include/" />
				</Compiler>
				<ResourceCompiler>
					<Add directory="$(WXWIN)/include/" />
				</ResourceCompiler>
				<Linker>
					<Add option="/debug" />
					<Add library="winmm.lib" />
					<Add library="comctl32.lib" />
					<Add library="kernel32.lib" />
					<Add library="user32.lib" />
					<Add library="gdi32.lib" />
					<Add library="winspool.lib" />
					<Add library="comdlg32.lib" />
					<Add library="advapi32.lib" />
					<Add library="shell32.lib" />
					<Add library="ole32.lib" />
					<Add library="oleaut32.lib" />
					<Add library="uuid.lib" />
					<Add library="odbc32.lib" />
					<Add library="odbccp32.lib" />
					<Add directory="$(WXWIN)/lib/vc_x64_lib/" />
				</Linker>
			</Target>
			<Target title="Release x64">
				<Option output="../Release/QuickAsm" prefix_auto="1" extension_auto="1" />
				<Option object_output="Release/" />
				<Option deps_output="../Release/" />
				<Option type="0" />
				<Option compiler="clang" />
				<Compiler>
					<Add option="/D_UNICODE /DUNICODE" />
					<Add option="/D__WXMSW__" />
					<Add option="/DNDEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/MT" />
					<Add option="/W3" />
					<Add directory="$(WXWIN)/include/msvc/" />
					<Add directory="$(WXWIN)/include/" />
				</Compiler>
				<ResourceCompiler>
					<Add directory="$(WXWIN)/include/" />
				</ResourceCompiler>
				<Linker>
					<Add option="/debug" />
					<Add library="winmm.lib" />
					<Add library="comctl32.lib" />
					<Add library="kernel32.lib" />
					<Add library="user32.lib" />
					<Add library="gdi32.lib" />
					<Add library="winspool.lib" />
					<Add library="comdlg32.lib" />
					<Add library="advapi32.lib" />
					<Add library="shell32.lib" />
					<Add library="ole32.lib" />
					<Add library="oleaut32.lib" />
					<Add library="uuid.lib" />
					<Add library="odbc32.lib" />
					<Add library="odbccp32.lib" />
					<Add directory="$(WXWIN)/lib/vc_x64_lib/" />
				</Linker>
			</Target>
			<Target title="Release Win32">
				<Option output="../Release/QuickAsm" prefix_auto="1" extension_auto="1" />
				<Option object_output="Release/" />
				<Option deps_output="../Release/" />
				<Option type="0" />
				<Option compiler="clang" />
				<Compiler>
					<Add option="/D_UNICODE /DUNICODE" />
					<Add option="/DWIN32" />
					<Add option="/DNDEBUG" />
					<Add option="/D_WINDOWS" />
					<Add option="/W3" />
				</Compiler>
				<Linker>
					<Add option="/debug" />
					<Add library="winmm.lib" />
					<Add library="comctl32.lib" />
					<Add library="kernel32.lib" />
					<Add library="user32.lib" />
					<Add library="gdi32.lib" />
					<Add library="winspool.lib" />
					<Add library="comdlg32.lib" />
					<Add library="advapi32.lib" />
					<Add library="shell32.lib" />
					<Add library="ole32.lib" />
					<Add library="oleaut32.lib" />
					<Add library="uuid.lib" />
					<Add library="odbc32.lib" />
					<Add library="odbccp32.lib" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add directory="." />
		</Compiler>
		<ResourceCompiler>
			<Add directory="." />
		</ResourceCompiler>
		<Linker>
			<Add option="/pdb:$(TARGET_OUTPUT_DIR)$(TARGET_OUTPUT_BASENAME).pdb" />
		</Linker>
		<Unit filename="App.cpp" />
		<Unit filename="App.h" />
		<Unit filename="AssemblerBase.cpp" />
		<Unit filename="AssemblerBase.h" />
		<Unit filename="AssemblyEditCtrl.cpp" />
		<Unit filename="AssemblyEditCtrl.h" />
		<Unit filename="Helpers.cpp" />
		<Unit filename="Helpers.h" />
		<Unit filename="KeystoneAssembler.cpp" />
		<Unit filename="KeystoneAssembler.h" />
		<Unit filename="LocalArtProvider.cpp" />
		<Unit filename="LocalArtProvider.h" />
		<Unit filename="MainFrame.cpp" />
		<Unit filename="MainFrame.h" />
		<Unit filename="NasmAssembler.cpp" />
		<Unit filename="NasmAssembler.h" />
		<Unit filename="pch.cpp" />
		<Unit filename="pch.h" />
		<Unit filename="resource.h" />
		<Unit filename="targetver.h" />
		<Unit filename="wxWidgetsApp.rc">
			<Option compilerVar="WINDRES" />
		</Unit>
		<Extensions>
			<lib_finder disable_auto="1" />
		</Extensions>
	</Project>
</CodeBlocks_project_file>

```

`QuickAsm/QuickAsm.layout`:

```layout
<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_layout_file>
	<FileVersion major="1" minor="0" />
	<ActiveTarget name="Debug x64" />
	<File name="LocalArtProvider.cpp" open="1" top="0" tabpos="2" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
		<Cursor>
			<Cursor1 position="0" topLine="0" />
		</Cursor>
	</File>
	<File name="Helpers.h" open="1" top="0" tabpos="4" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
		<Cursor>
			<Cursor1 position="178" topLine="0" />
		</Cursor>
	</File>
	<File name="AssemblerBase.cpp" open="1" top="0" tabpos="1" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
		<Cursor>
			<Cursor1 position="0" topLine="0" />
		</Cursor>
	</File>
	<File name="KeystoneAssembler.cpp" open="1" top="1" tabpos="5" split="0" active="1" splitpos="0" zoom_1="0" zoom_2="0">
		<Cursor>
			<Cursor1 position="2803" topLine="53" />
		</Cursor>
	</File>
</CodeBlocks_layout_file>

```

`QuickAsm/QuickAsm.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "Resource.h"


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_RESTART             ICON                    "Icons\\Restart.ico"

0APP                    ICON                    "Icons\\AsmStudio.ico"

8BIT                    ICON                    "Icons\\8.ico"

16BIT                   ICON                    "Icons\\16bit.ico"

32BIT                   ICON                    "Icons\\32bit.ico"

64BIT                   ICON                    "Icons\\64bit.ico"

ASMFILE                 ICON                    "Icons\\asm.ico"

ASMSTUDIO               ICON                    "Icons\\AsmStudio.ico"

BUILD                   ICON                    "Icons\\build.ico"

OPEN                    ICON                    "Icons\\open.ico"

SAVE                    ICON                    "Icons\\save.ico"

SAVEAS                  ICON                    "Icons\\save_as.ico"

COPY                    ICON                    "Icons\\copy.ico"

CUT                     ICON                    "Icons\\cut.ico"

PASTE                   ICON                    "Icons\\paste.ico"

UNDO                    ICON                    "Icons\\undo.ico"

REDO                    ICON                    "Icons\\redo.ico"

BINARY                  ICON                    "Icons\\binary.ico"

RUN                     ICON                    "Icons\\run.ico"

STOP                    ICON                    "Icons\\stop.ico"

REGISTERS               ICON                    "Icons\\registers.ico"

BREAKPOINT              ICON                    "Icons\\breakpoint.ico"

MEMORY                  ICON                    "Icons\\Memory.ico"

EDIT                    ICON                    "Icons\\edit.ico"

1BYTE                   ICON                    "Icons\\number-1.ico"

2BYTES                  ICON                    "Icons\\number-2.ico"

4BYTES                  ICON                    "Icons\\number-4.ico"

8BYTES                  ICON                    "Icons\\number-8.ico"

STEPOVER                ICON                    "Icons\\stepover.ico"

STEPINTO                ICON                    "Icons\\stepinto.ico"

STEPOUT                 ICON                    "Icons\\stepout.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//


VS_VERSION_INFO VERSIONINFO
FILEVERSION 0,1,0,0
PRODUCTVERSION 0,1,0,0
FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Scorpio Software"
            VALUE "FileDescription", "QuickAsm"
            VALUE "FileVersion", "0.1.0.0"
            VALUE "InternalName", "QuickAsm.exe"
            VALUE "LegalCopyright", "© 2023-2024 Pavel Yosifovich"
            VALUE "OriginalFilename", "QuickAsm.exe"
            VALUE "ProductName", "QuickAsm"
            VALUE "ProductVersion", "0.1.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


```

`QuickAsm/QuickAsm.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{08556e30-a5ca-4f40-bb93-d902d373c5f4}</ProjectGuid>
    <RootNamespace>QuickAsm</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>__WXDEBUG__;__WXMSW__;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(WXWIN)\include\msvc;$(WXWIN)\include</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(WXWIN)\lib\vc_x64_lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$(WXWIN)\include</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>__WXMSW__;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(WXWIN)\include\msvc;$(WXWIN)\include</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(WXWIN)\lib\vc_x64_lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <ResourceCompile>
      <AdditionalIncludeDirectories>$(WXWIN)\include</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="AssemblerBase.h" />
    <ClInclude Include="AssemblyEditCtrl.h" />
    <ClInclude Include="CapstoneEngine.h" />
    <ClInclude Include="Helpers.h" />
    <ClInclude Include="HexViewPanel.h" />
    <ClInclude Include="KeystoneAssembler.h" />
    <ClInclude Include="LocalArtProvider.h" />
    <ClInclude Include="MainFrame.h" />
    <ClInclude Include="NasmAssembler.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="RegisterInfo.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="App.h" />
    <ClInclude Include="UnicornEngine.h" />
    <ClInclude Include="wxHexView.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\common\Trace.c">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="AssemblerBase.cpp" />
    <ClCompile Include="AssemblyEditCtrl.cpp" />
    <ClCompile Include="CapstoneEngine.cpp" />
    <ClCompile Include="Helpers.cpp" />
    <ClCompile Include="HexViewPanel.cpp" />
    <ClCompile Include="KeystoneAssembler.cpp" />
    <ClCompile Include="LocalArtProvider.cpp" />
    <ClCompile Include="MainFrame.cpp" />
    <ClCompile Include="NasmAssembler.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="App.cpp" />
    <ClCompile Include="RegisterInfo.cpp" />
    <ClCompile Include="UnicornEngine.cpp" />
    <ClCompile Include="wxHexView.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="QuickAsm.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="App.ico" />
    <Image Include="Icons\16bit.ico" />
    <Image Include="Icons\32bit.ico" />
    <Image Include="Icons\64bit.ico" />
    <Image Include="Icons\8.ico" />
    <Image Include="Icons\asm.ico" />
    <Image Include="Icons\AsmStudio.ico" />
    <Image Include="Icons\binary.ico" />
    <Image Include="Icons\breakpoint.ico" />
    <Image Include="Icons\build.ico" />
    <Image Include="Icons\copy.ico" />
    <Image Include="Icons\cut.ico" />
    <Image Include="Icons\edit.ico" />
    <Image Include="Icons\Memory.ico" />
    <Image Include="Icons\number-1.ico" />
    <Image Include="Icons\number-2.ico" />
    <Image Include="Icons\number-4.ico" />
    <Image Include="Icons\number-8.ico" />
    <Image Include="Icons\open.ico" />
    <Image Include="Icons\paste.ico" />
    <Image Include="Icons\redo.ico" />
    <Image Include="Icons\registers.ico" />
    <Image Include="Icons\Restart.ico" />
    <Image Include="Icons\run.ico" />
    <Image Include="Icons\save.ico" />
    <Image Include="Icons\save_as.ico" />
    <Image Include="Icons\stepinto.ico" />
    <Image Include="Icons\stepout.ico" />
    <Image Include="Icons\stepover.ico" />
    <Image Include="Icons\stop.ico" />
    <Image Include="Icons\undo.ico" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\HexView\HexView.vcxproj">
      <Project>{3fba3178-4ae6-4103-9eb2-542901d978b7}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`QuickAsm/QuickAsm.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Resource Files\Icons">
      <UniqueIdentifier>{aee5f18e-3153-49e8-800c-f5ee99b2b65d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Assemblers">
      <UniqueIdentifier>{2b061afc-b160-4f5d-81c3-17f437bdc458}</UniqueIdentifier>
    </Filter>
    <Filter Include="Helpers">
      <UniqueIdentifier>{fc3ea39a-7767-4f76-9944-26f6cb5b1965}</UniqueIdentifier>
    </Filter>
    <Filter Include="Disassemblers">
      <UniqueIdentifier>{d0e62e76-1419-4712-ae1a-3061b788c939}</UniqueIdentifier>
    </Filter>
    <Filter Include="Emulators">
      <UniqueIdentifier>{e9420882-a4ba-4048-bafc-a769087f99f0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Controls">
      <UniqueIdentifier>{3acd8b09-19b6-440b-8a17-cedda80cf210}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="App.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MainFrame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AssemblyEditCtrl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AssemblerBase.h">
      <Filter>Assemblers</Filter>
    </ClInclude>
    <ClInclude Include="KeystoneAssembler.h">
      <Filter>Assemblers</Filter>
    </ClInclude>
    <ClInclude Include="NasmAssembler.h">
      <Filter>Assemblers</Filter>
    </ClInclude>
    <ClInclude Include="Helpers.h">
      <Filter>Helpers</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resource Files</Filter>
    </ClInclude>
    <ClInclude Include="CapstoneEngine.h">
      <Filter>Disassemblers</Filter>
    </ClInclude>
    <ClInclude Include="HexViewPanel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="RegisterInfo.h">
      <Filter>Helpers</Filter>
    </ClInclude>
    <ClInclude Include="UnicornEngine.h">
      <Filter>Emulators</Filter>
    </ClInclude>
    <ClInclude Include="wxHexView.h">
      <Filter>Controls</Filter>
    </ClInclude>
    <ClInclude Include="LocalArtProvider.h">
      <Filter>Helpers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="App.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MainFrame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AssemblyEditCtrl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AssemblerBase.cpp">
      <Filter>Assemblers</Filter>
    </ClCompile>
    <ClCompile Include="KeystoneAssembler.cpp">
      <Filter>Assemblers</Filter>
    </ClCompile>
    <ClCompile Include="NasmAssembler.cpp">
      <Filter>Assemblers</Filter>
    </ClCompile>
    <ClCompile Include="Helpers.cpp">
      <Filter>Helpers</Filter>
    </ClCompile>
    <ClCompile Include="CapstoneEngine.cpp">
      <Filter>Disassemblers</Filter>
    </ClCompile>
    <ClCompile Include="..\common\Trace.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HexViewPanel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegisterInfo.cpp">
      <Filter>Helpers</Filter>
    </ClCompile>
    <ClCompile Include="UnicornEngine.cpp">
      <Filter>Emulators</Filter>
    </ClCompile>
    <ClCompile Include="wxHexView.cpp">
      <Filter>Controls</Filter>
    </ClCompile>
    <ClCompile Include="LocalArtProvider.cpp">
      <Filter>Helpers</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="QuickAsm.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="App.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\8.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\16bit.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\32bit.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\64bit.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\asm.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\AsmStudio.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\build.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\binary.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\copy.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\cut.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\open.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\paste.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\redo.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\save.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\save_as.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\undo.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\Restart.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\breakpoint.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\edit.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\Memory.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\number-1.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\number-2.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\number-4.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\number-8.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\registers.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\run.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\stepinto.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\stepout.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\stepover.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
    <Image Include="Icons\stop.ico">
      <Filter>Resource Files\Icons</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`QuickAsm/RegisterInfo.cpp`:

```cpp
#include "pch.h"
#include "RegisterInfo.h"

const std::vector<RegisterInfo> AllRegisters {
	{ "IP", 16, x86Register::IP, RegisterType::Special | RegisterType::Bits16 },
	{ "EIP", 32, x86Register::EIP, RegisterType::Special | RegisterType::Bits32 },
	{ "RIP", 64, x86Register::RIP, RegisterType::Special | RegisterType::Bits64 },

	{ "AX", 16, x86Register::AX, RegisterType::General | RegisterType::AllBits , x86Register::EAX, 0 },
	{ "AL", 8,  x86Register::AL, RegisterType::General | RegisterType::AllBits , x86Register::AX, 0 },
	{ "AH", 8,  x86Register::AH, RegisterType::General | RegisterType::AllBits , x86Register::AX, 8 },

	{ "BX", 16, x86Register::BX, RegisterType::General | RegisterType::AllBits, x86Register::EBX, 0 },
	{ "BL", 8,  x86Register::BL, RegisterType::General | RegisterType::AllBits, x86Register::BX, 0 },
	{ "BH", 8,  x86Register::BH, RegisterType::General | RegisterType::AllBits, x86Register::BX, 8 },

	{ "CX", 16, x86Register::CX, RegisterType::General | RegisterType::AllBits, x86Register::ECX, 0 },
	{ "CL", 8,  x86Register::CL, RegisterType::General | RegisterType::AllBits, x86Register::CX, 0 },
	{ "CH", 8,  x86Register::CH, RegisterType::General | RegisterType::AllBits, x86Register::CX, 8 },

	{ "DX", 16, x86Register::DX, RegisterType::General | RegisterType::AllBits, x86Register::EDX, 0 },
	{ "DL", 8,  x86Register::DL, RegisterType::General | RegisterType::AllBits, x86Register::DX, 0 },
	{ "DH", 8,  x86Register::DH, RegisterType::General | RegisterType::AllBits, x86Register::DX, 8 },

	{ "EAX", 32, x86Register::EAX, RegisterType::General | RegisterType::Bits32 | RegisterType::Bits64, x86Register::RAX },
	{ "EBX", 32, x86Register::EBX, RegisterType::General | RegisterType::Bits32 | RegisterType::Bits64, x86Register::RBX },
	{ "ECX", 32, x86Register::ECX, RegisterType::General | RegisterType::Bits32 | RegisterType::Bits64, x86Register::RCX },
	{ "EDX", 32, x86Register::EDX, RegisterType::General | RegisterType::Bits32 | RegisterType::Bits64, x86Register::RDX },

	{ "RAX", 64, x86Register::RAX, RegisterType::General | RegisterType::Bits64 },
	{ "RBX", 64, x86Register::RBX, RegisterType::General | RegisterType::Bits64 },
	{ "RCX", 64, x86Register::RCX, RegisterType::General | RegisterType::Bits64 },
	{ "RDX", 64, x86Register::RDX, RegisterType::General | RegisterType::Bits64 },

	{ "SP", 16, x86Register::SP, RegisterType::General | RegisterType::Bits16 },
	{ "ESP", 32, x86Register::ESP, RegisterType::General | RegisterType::Bits32 },
	{ "RSP", 64, x86Register::RSP, RegisterType::General | RegisterType::Bits64 },

	{ "BP", 16, x86Register::BP, RegisterType::General | RegisterType::Bits16 },
	{ "EBP", 32, x86Register::EBP, RegisterType::General | RegisterType::Bits32 },
	{ "RBP", 64, x86Register::RBP, RegisterType::General | RegisterType::Bits64 },

	{ "EFLAGS", 32, x86Register::EFLAGS, RegisterType::Special | RegisterType::Bits32 },
	{ "FLAGS", 16, x86Register::EFLAGS, RegisterType::Special | RegisterType::Bits16 },
	{ "RFLAGS", 64, x86Register::EFLAGS, RegisterType::Special | RegisterType::Bits64 },

	{ "CS", 16, x86Register::CS, RegisterType::Segment | RegisterType::AllBits },
	{ "DS", 16, x86Register::DS, RegisterType::Segment | RegisterType::AllBits },
	{ "ES", 16, x86Register::ES, RegisterType::Segment | RegisterType::AllBits },
	{ "SS", 16, x86Register::SS, RegisterType::Segment | RegisterType::AllBits },
	{ "FS", 16, x86Register::FS, RegisterType::Segment | RegisterType::Bits32 | RegisterType::Bits64 },
	{ "GS", 16, x86Register::GS, RegisterType::Segment | RegisterType::Bits32 | RegisterType::Bits64 },

	{ "SI", 16,   x86Register::SI, RegisterType::General | RegisterType::AllBits, x86Register::ESI, 0 },
	{ "ESI", 32,  x86Register::ESI, RegisterType::General | RegisterType::Bits64 | RegisterType::Bits32, x86Register::RSI, 0 },
	{ "RSI", 64,  x86Register::RSI, RegisterType::General | RegisterType::Bits64 },

	{ "DI", 16,   x86Register::DI, RegisterType::General | RegisterType::AllBits, x86Register::ESI, 0 },
	{ "EDI", 32,  x86Register::EDI, RegisterType::General | RegisterType::Bits64 | RegisterType::Bits32, x86Register::RDI, 0 },
	{ "RDI", 64,  x86Register::RDI, RegisterType::General | RegisterType::Bits64 },

	{ "R8", 64,  x86Register::R8, RegisterType::General | RegisterType::Bits64 },
	{ "R9", 64,  x86Register::R9, RegisterType::General | RegisterType::Bits64 },
	{ "R10", 64,  x86Register::R10, RegisterType::General | RegisterType::Bits64 },
	{ "R11", 64,  x86Register::R11, RegisterType::General | RegisterType::Bits64 },
	{ "R12", 64,  x86Register::R12, RegisterType::General | RegisterType::Bits64 },
	{ "R13", 64,  x86Register::R13, RegisterType::General | RegisterType::Bits64 },
	{ "R14", 64,  x86Register::R14, RegisterType::General | RegisterType::Bits64 },
	{ "R15", 64,  x86Register::R15, RegisterType::General | RegisterType::Bits64 },

	{ "R8D", 32,  x86Register::R8D, RegisterType::General | RegisterType::Bits64, x86Register::R8 },
	{ "R9D", 32,  x86Register::R9D, RegisterType::General | RegisterType::Bits64, x86Register::R9 },
	{ "R10D", 32,  x86Register::R10D, RegisterType::General | RegisterType::Bits64, x86Register::R10 },
	{ "R11D", 32,  x86Register::R11D, RegisterType::General | RegisterType::Bits64, x86Register::R11 },
	{ "R12D", 32,  x86Register::R12D, RegisterType::General | RegisterType::Bits64, x86Register::R12 },
	{ "R13D", 32,  x86Register::R13D, RegisterType::General | RegisterType::Bits64, x86Register::R13 },
	{ "R14D", 32,  x86Register::R14D, RegisterType::General | RegisterType::Bits64, x86Register::R14 },
	{ "R15D", 32,  x86Register::R15D, RegisterType::General | RegisterType::Bits64, x86Register::R15 },

	{ "R8W", 16,  x86Register::R8W, RegisterType::General | RegisterType::Bits64, x86Register::R8 },
	{ "R9W", 16,  x86Register::R9W, RegisterType::General | RegisterType::Bits64, x86Register::R9 },
	{ "R10W", 16,  x86Register::R10W, RegisterType::General | RegisterType::Bits64, x86Register::R10 },
	{ "R11W", 16,  x86Register::R11W, RegisterType::General | RegisterType::Bits64, x86Register::R11 },
	{ "R12W", 16,  x86Register::R12W, RegisterType::General | RegisterType::Bits64, x86Register::R12 },
	{ "R13W", 16,  x86Register::R13W, RegisterType::General | RegisterType::Bits64, x86Register::R13 },
	{ "R14W", 16,  x86Register::R14W, RegisterType::General | RegisterType::Bits64, x86Register::R14 },
	{ "R15W", 16,  x86Register::R15W, RegisterType::General | RegisterType::Bits64, x86Register::R15 },

	{ "R8B", 8,  x86Register::R8B, RegisterType::General | RegisterType::Bits64, x86Register::R8 },
	{ "R9B", 8,  x86Register::R9B, RegisterType::General | RegisterType::Bits64, x86Register::R9 },
	{ "R10B", 8,  x86Register::R10B, RegisterType::General | RegisterType::Bits64, x86Register::R10 },
	{ "R11B", 8,  x86Register::R11B, RegisterType::General | RegisterType::Bits64, x86Register::R11 },
	{ "R12B", 8,  x86Register::R12B, RegisterType::General | RegisterType::Bits64, x86Register::R12 },
	{ "R13B", 8,  x86Register::R13B, RegisterType::General | RegisterType::Bits64, x86Register::R13 },
	{ "R14B", 8,  x86Register::R14B, RegisterType::General | RegisterType::Bits64, x86Register::R14 },
	{ "R15B", 8,  x86Register::R15B, RegisterType::General | RegisterType::Bits64, x86Register::R15 },

	{ "CR0", 64,  x86Register::CR0, RegisterType::Control | RegisterType::Bits64 },
	{ "CR2", 64,  x86Register::CR2, RegisterType::Control | RegisterType::Bits64 },
	{ "CR3", 64,  x86Register::CR3, RegisterType::Control | RegisterType::Bits64 },
	{ "CR4", 64,  x86Register::CR4, RegisterType::Control | RegisterType::Bits64 },
	{ "CR0", 32,  x86Register::CR0, RegisterType::Control | RegisterType::Bits32 },
	{ "CR2", 32,  x86Register::CR2, RegisterType::Control | RegisterType::Bits32 },
	{ "CR3", 32,  x86Register::CR3, RegisterType::Control | RegisterType::Bits32 },
	{ "CR4", 32,  x86Register::CR4, RegisterType::Control | RegisterType::Bits32 },
	{ "CR8", 64,  x86Register::CR8, RegisterType::Control | RegisterType::Bits64 },

	{ "GDTR", 48,  x86Register::GDTR, RegisterType::Descriptor | RegisterType::Bits32 },
	{ "GDTR", 80,  x86Register::GDTR, RegisterType::Descriptor | RegisterType::Bits64 },
	{ "LDTR", 16,  x86Register::LDTR, RegisterType::Descriptor | RegisterType::Bits32 | RegisterType::Bits64 },
	{ "IDTR", 48,  x86Register::IDTR, RegisterType::Descriptor | RegisterType::Bits32 },
	{ "IDTR", 80,  x86Register::IDTR, RegisterType::Descriptor | RegisterType::Bits64 },
	{ "TR", 48,  x86Register::TR, RegisterType::Descriptor | RegisterType::Bits32 },
	{ "TR", 80,  x86Register::TR, RegisterType::Descriptor | RegisterType::Bits64 },
	{ "FS Base", 32,  x86Register::FS_BASE, RegisterType::Special | RegisterType::Bits32 },
	{ "FS Base", 64,  x86Register::FS_BASE, RegisterType::Special | RegisterType::Bits64 },
	{ "GS Base", 32,  x86Register::GS_BASE, RegisterType::Special | RegisterType::Bits32 },
	{ "GS Base", 64,  x86Register::GS_BASE, RegisterType::Special | RegisterType::Bits64 },

	//{ "ST0", 80,  x86Register::ST0, RegisterType::FloatingPoint },
	//{ "ST1", 80,  x86Register::ST1, RegisterType::FloatingPoint },
	//{ "ST2", 80,  x86Register::ST2, RegisterType::FloatingPoint },
	//{ "ST3", 80,  x86Register::ST3, RegisterType::FloatingPoint },
	//{ "ST4", 80,  x86Register::ST4, RegisterType::FloatingPoint },
	//{ "ST5", 80,  x86Register::ST5, RegisterType::FloatingPoint },
	//{ "ST6", 80,  x86Register::ST6, RegisterType::FloatingPoint },
	//{ "ST7", 80,  x86Register::ST7, RegisterType::FloatingPoint },

	//{ "MM0", 64,  x86Register::MM0, RegisterType::SSE },
	//{ "MM1", 64,  x86Register::MM1, RegisterType::SSE },
	//{ "MM2", 64,  x86Register::MM2, RegisterType::SSE },
	//{ "MM3", 64,  x86Register::MM3, RegisterType::SSE },
	//{ "MM4", 64,  x86Register::MM4, RegisterType::SSE },
	//{ "MM5", 64,  x86Register::MM5, RegisterType::SSE },
	//{ "MM6", 64,  x86Register::MM6, RegisterType::SSE },
	//{ "MM7", 64,  x86Register::MM7, RegisterType::SSE },

	{ "XMM0", 128,  x86Register::XMM0, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM1", 128,  x86Register::XMM1, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM2", 128,  x86Register::XMM2, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM3", 128,  x86Register::XMM3, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM4", 128,  x86Register::XMM4, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM5", 128,  x86Register::XMM5, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM6", 128,  x86Register::XMM6, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM7", 128,  x86Register::XMM7, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM8", 128,  x86Register::XMM8, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM9", 128,  x86Register::XMM9, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM10", 128,  x86Register::XMM10, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM11", 128,  x86Register::XMM11, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM12", 128,  x86Register::XMM12, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM13", 128,  x86Register::XMM13, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM14", 128,  x86Register::XMM14, RegisterType::SSE | RegisterType::FloatingPoint },
	{ "XMM15", 128,  x86Register::XMM15, RegisterType::SSE | RegisterType::FloatingPoint },
};


```

`QuickAsm/RegisterInfo.h`:

```h
#pragma once

#include "UnicornEngine.h"


enum class RegisterType {
	None = 0,
	General =		0x00001000,
	Segment =		0x00002000,
	FloatingPoint = 0x00004000,
	SSE =			0x00008000,
	Special =		0x00010000,
	Control =		0x00020000,
	Descriptor =	0x00040000,

	Bits16 = CS_MODE_16,
	Bits32 = CS_MODE_32,
	Bits64 = CS_MODE_64,

	AllBits = Bits16 | Bits32 | Bits64,
};
DEFINE_ENUM_FLAG_OPERATORS(RegisterType);

struct RegisterInfo {
	std::string Name;
	int Size;	// bits
	x86Register Id;
	RegisterType Category;
	x86Register SubReg;
	int StartBit;
};

extern const std::vector<RegisterInfo> AllRegisters;

```

`QuickAsm/Tag.h`:

```h
/***********************************(GPL)********************************
*   wxHexEditor is a hex edit tool for editing massive files in Linux   *
*   Copyright (C) 2010  Erdem U. Altinyurt                              *
*                                                                       *
*   This program is free software; you can redistribute it and/or       *
*   modify it under the terms of the GNU General Public License         *
*   as published by the Free Software Foundation; either version 2      *
*   of the License.                                                     *
*                                                                       *
*   This program is distributed in the hope that it will be useful,     *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of      *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *
*   GNU General Public License for more details.                        *
*                                                                       *
*   You should have received a copy of the GNU General Public License   *
*   along with this program;                                            *
*   if not, write to the Free Software Foundation, Inc.,                *
*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA        *
*                                                                       *
*               home  : www.wxhexeditor.org                             *
*               email : spamjunkeater@gmail.com                         *
*************************************************************************/


#ifndef __Tag_h__
#define __Tag_h__
#include <iostream>
#include <stdint.h>
#include <wx/clrpicker.h>
#if wxCHECK_VERSION(2, 9, 0)
	#include <wx/cmndata.h>
#endif
#if wxCHECK_VERSION(2, 9, 1)
	#include <wx/colourdata.h>
#endif
#include <wx/popupwin.h>
#include <wx/dcmemory.h>
#include "TagDialogGui.h"

class TagElementData{
	public:
	uint64_t start;
	uint64_t end;
	wxString tag;
	wxColourData FontClrData;
	wxColourData NoteClrData;
	bool visible;
	};

//class TagElement:public wxPopupWindow{
//class TagElement:public TagElementData{

class TagElement{
	public:
		TagElement();
		~TagElement();
		TagElement( TagElementData data );
		TagElement( uint64_t _start, uint64_t _end, wxString _tag, wxColourData fntclr, wxColourData noteclr);
		TagElement( uint64_t _start, uint64_t _end, wxString _tag, wxColour fntclr, wxColour noteclr);

		uint64_t start;
		uint64_t end;
		wxString tag;
		wxColourData FontClrData;
		wxColourData NoteClrData;
		bool visible;

		void Show( const wxPoint& pos, wxWindow *parent );
		void Hide( void );
		bool isCover( uint64_t );
		void print(void);
		wxColour SoftColour(wxColour);
		static int TagCompare(TagElement **first, TagElement **second);
//		bool operator<( TagElement a ){ return start < a.start; }
//		bool operator>( TagElement a ){ return start > a.start; }

//		void OnKillFocus( wxFocusEvent& event );
#ifndef __WXMAC__
		wxPopupWindow *wxP;
#endif	//wxPopupWindows is not yet implemented in MacOSX
	};

int TagElementSort( TagElement **a, TagElement **b );

class TagDialog : public TagDialogGui{
	public:
		TagDialog( TagElement& TE, wxWindow* parent );
		void OnSave( wxCommandEvent& event );
		void OnDelete( wxCommandEvent& event );
		void OnColorChange( wxCommandEvent& event );
		TagElement& Tag;
		TagElement TmpTag;
	};


#endif // __Tag_h__

```

`QuickAsm/TagDialogGui.h`:

```h
///////////////////////////////////////////////////////////////////////////
// C++ code generated with wxFormBuilder (version Apr 17 2008)
// http://www.wxformbuilder.org/
//
// PLEASE DO "NOT" EDIT THIS FILE!
///////////////////////////////////////////////////////////////////////////

#ifndef __TagDialogGui__
#define __TagDialogGui__

#include <wx/intl.h>

#include <wx/string.h>
#include <wx/textctrl.h>
#include <wx/gdicmn.h>
#include <wx/font.h>
#include <wx/colour.h>
#include <wx/settings.h>
#include <wx/stattext.h>
#include <wx/clrpicker.h>
#include <wx/sizer.h>
#include <wx/button.h>
#include <wx/dialog.h>

///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
/// Class TagDialogGui
///////////////////////////////////////////////////////////////////////////////
class TagDialogGui : public wxDialog 
{
	private:
	
	protected:
		wxTextCtrl* TagTextCtrl;
		wxStaticText* m_staticText1;
		wxColourPickerCtrl* m_FontColourPicker;
		wxStaticText* m_staticText2;
		wxColourPickerCtrl* m_NoteColourPicker;
		wxButton* m_SaveButton;
		wxButton* m_RemoveButton;
		
		// Virtual event handlers, overide them in your derived class
		virtual void OnSave( wxCommandEvent& event ){ event.Skip(); }
		virtual void OnDelete( wxCommandEvent& event ){ event.Skip(); }
		
	
	public:
		TagDialogGui( wxWindow* parent, wxWindowID id = wxID_ANY, const wxString& title = _("Tag Dialog"), const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxSize( -1,-1 ), long style = wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER );
		~TagDialogGui();
	
};

#endif //__TagDialogGui__

```

`QuickAsm/UnicornEngine.cpp`:

```cpp
#include "pch.h"
#include "UnicornEngine.h"

UnicornEngine::~UnicornEngine() {
    Close();
}

bool UnicornEngine::Open(CpuArch arch, CpuMode mode) {
    Close();

    m_LastError = uc_open((uc_arch)arch, (uc_mode)mode, &m_UC);
    m_Mode = mode;
    return m_LastError == UC_ERR_OK;
}

void UnicornEngine::Close() {
    if (m_UC) {
        uc_close(m_UC);
        m_UC = nullptr;
    }
}

bool UnicornEngine::IsOpen() const {
    return m_UC != nullptr;
}

uc_err UnicornEngine::LastError() const {
    return m_LastError;
}

CpuMode UnicornEngine::GetMode() const {
    return m_Mode;
}

bool UnicornEngine::WriteReg(x86Register reg, void* value) {
    m_LastError = uc_reg_write(m_UC, (int)reg, value);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::ReadReg(x86Register reg, void* value) const {
    m_LastError = uc_reg_read(m_UC, (int)reg, value);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::MapMemory(uint64_t address, uint64_t size, MemProtection protect) {
    m_LastError = uc_mem_map(m_UC, address, size, (uint32_t)protect);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::MapHostMemory(uint64_t address, uint64_t size, MemProtection protect, void* mem) {
    m_LastError = uc_mem_map_ptr(m_UC, address, size, (uint32_t)protect, mem);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::UnmapMemory(uint64_t address, uint64_t size) {
    m_LastError = uc_mem_unmap(m_UC, address, size);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::ProtectMemory(uint64_t address, uint64_t size, MemProtection protect) {
    m_LastError = uc_mem_protect(m_UC, address, size, (uint32_t)protect);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::WriteMemory(uint64_t address, const void* data, uint64_t size) {
    m_LastError = uc_mem_write(m_UC, address, data, size);
    assert(m_LastError == UC_ERR_OK);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::ReadMemory(uint64_t address, void* data, uint64_t size) {
    m_LastError = uc_mem_read(m_UC, address, data, size);
    return m_LastError == UC_ERR_OK;
}

void UnicornEngine::UnmapAllMemory() {
    uc_mem_region* regions;
    uint32_t count = 0;
    uc_mem_regions(m_UC, &regions, &count);
    for (uint32_t i = 0; i < count; i++)
        uc_mem_unmap(m_UC, regions[i].begin, regions[i].end - regions[i].begin);
    uc_free(regions);
}

bool UnicornEngine::Start(uint64_t address, uint64_t until, uint64_t timeout, size_t count) {
    m_LastError = uc_emu_start(m_UC, address, until, timeout, count);
    return m_LastError == UC_ERR_OK;
}

bool UnicornEngine::Stop() {
    m_LastError = uc_emu_stop(m_UC);
    return m_LastError == UC_ERR_OK;
}

UnicornEngine::CpuContext UnicornEngine::AllocContext() {
    return CpuContext(m_UC);
}

void UnicornEngine::EnableHooks(bool enable) {
    m_HooksEnabled = enable;
}

void* UnicornEngine::SaveContext(void* ctx) {
    if (ctx == nullptr)
        m_LastError = uc_context_alloc(m_UC, (uc_context**)&ctx);
    if (ctx == nullptr)
        return nullptr;

    m_LastError = uc_context_save(m_UC, (uc_context*)ctx);
    return ctx;
}

bool UnicornEngine::RestoreContext(void* ctx) {
    return uc_context_restore(m_UC, (uc_context*)ctx) == UC_ERR_OK;
}

const char* UnicornEngine::GetErrorText(uc_err error) const {
    return uc_strerror(error);
}

UnicornEngine::CpuContext::~CpuContext() {
    uc_context_free(m_ctx);
}

bool UnicornEngine::CpuContext::Save() {
    return uc_context_save(m_uc, m_ctx) == UC_ERR_OK;
}

bool UnicornEngine::CpuContext::Restore() {
    return uc_context_restore(m_uc, m_ctx) == UC_ERR_OK;
}

UnicornEngine::CpuContext::CpuContext(uc_engine* uc) : m_uc(uc) {
    uc_context_alloc(uc, &m_ctx);
}

void UnicornEngine::_CallbackHookCode(uc_engine* uc, uint64_t address, uint32_t size, void* ud) {
    auto hh = (HookHandle*)ud;
    (hh->m_CB)(address, size);
}

void* UnicornEngine::HookCode(HookType type, std::function<void(uint64_t, uint32_t)> cb, uint64_t begin, uint64_t end) {
    auto hh = new HookHandle;
    hh->m_CB = cb;
    m_LastError = uc_hook_add(m_UC, &hh->m_Hook, (int)type, &_CallbackHookCode, hh, begin, end);
    if (m_LastError == UC_ERR_OK)
        return hh;
    delete hh;
    return nullptr;
}

void UnicornEngine::Unhook(void* hook) {
    auto hh = (HookHandle*)hook;
    uc_hook_del(m_UC, hh->m_Hook);
    delete hh;
}


```

`QuickAsm/UnicornEngine.h`:

```h
#pragma once

enum class CpuArch {
	Arm = UC_ARCH_ARM,   // ARM architecture (including Thumb, Thumb-2)
	Arm64 = UC_ARCH_ARM64,      // ARM-64, also called AArch64
	x86 = UC_ARCH_X86,        // X86 architecture (including x86 & x86-64)
};

enum class CpuMode {
	LittleEndian = UC_MODE_LITTLE_ENDIAN,    // little-endian mode (default mode)
	BigEngian = UC_MODE_BIG_ENDIAN, // big-endian mode

	// arm / arm64
	Arm = UC_MODE_ARM,              // ARM mode
	Thumb = UC_MODE_THUMB,       // THUMB mode (including Thumb-2)
	MClass = UC_MODE_MCLASS,      // ARM's Cortex-M series (currently unsupported)
	V8 = UC_MODE_V8,          // ARMv8 A32 encodings for ARM (currently unsupported)

	// arm (32bit) cpu types
	Arm926 = UC_MODE_ARM926,	  // ARM926 CPU type
	Arm946 = UC_MODE_ARM946,	  // ARM946 CPU type
	Arm1176 = UC_MODE_ARM1176,	  // ARM1176 CPU type

	// ARM BE8
	ArmBe8 = UC_MODE_ARMBE8,     // Big-endian data and Little-endian code

	// x86 / x64
	x86_16 = UC_MODE_16,          // 16-bit mode
	x86_32 = UC_MODE_32,          // 32-bit mode
	x86_64 = UC_MODE_64,          // 64-bit mode
};

enum class x86Register {
	_INVALID = 0,
	AH, AL, AX, BH, BL,
	BP, BPL, BX, CH, CL,
	CS, CX, DH, DI, DIL,
	DL, DS, DX, EAX, EBP,
	EBX, ECX, EDI, EDX, EFLAGS,
	EIP, EIZ, ES, ESI, ESP,
	FPSW, FS, GS, IP, RAX,
	RBP, RBX, RCX, RDI, RDX,
	RIP, RIZ, RSI, RSP, SI,
	SIL, SP, SPL, SS, CR0,
	CR1, CR2, CR3, CR4, CR5,
	CR6, CR7, CR8, CR9, CR10,
	CR11, CR12, CR13, CR14, CR15,
	DR0, DR1, DR2, DR3, DR4,
	DR5, DR6, DR7, DR8, DR9,
	DR10, DR11, DR12, DR13, DR14,
	DR15, FP0, FP1, FP2, FP3,
	FP4, FP5, FP6, FP7,
	K0, K1, K2, K3, K4,
	K5, K6, K7, MM0, MM1,
	MM2, MM3, MM4, MM5, MM6,
	MM7, R8, R9, R10, R11,
	R12, R13, R14, R15,
	ST0, ST1, ST2, ST3,
	ST4, ST5, ST6, ST7,
	XMM0, XMM1, XMM2, XMM3, XMM4,
	XMM5, XMM6, XMM7, XMM8, XMM9,
	XMM10, XMM11, XMM12, XMM13, XMM14,
	XMM15, XMM16, XMM17, XMM18, XMM19,
	XMM20, XMM21, XMM22, XMM23, XMM24,
	XMM25, XMM26, XMM27, XMM28, XMM29,
	XMM30, XMM31, YMM0, YMM1, YMM2,
	YMM3, YMM4, YMM5, YMM6, YMM7,
	YMM8, YMM9, YMM10, YMM11, YMM12,
	YMM13, YMM14, YMM15, YMM16, YMM17,
	YMM18, YMM19, YMM20, YMM21, YMM22,
	YMM23, YMM24, YMM25, YMM26, YMM27,
	YMM28, YMM29, YMM30, YMM31, ZMM0,
	ZMM1, ZMM2, ZMM3, ZMM4, ZMM5,
	ZMM6, ZMM7, ZMM8, ZMM9, ZMM10,
	ZMM11, ZMM12, ZMM13, ZMM14, ZMM15,
	ZMM16, ZMM17, ZMM18, ZMM19, ZMM20,
	ZMM21, ZMM22, ZMM23, ZMM24, ZMM25,
	ZMM26, ZMM27, ZMM28, ZMM29, ZMM30,
	ZMM31, R8B, R9B, R10B, R11B,
	R12B, R13B, R14B, R15B, R8D,
	R9D, R10D, R11D, R12D, R13D,
	R14D, R15D, R8W, R9W, R10W,
	R11W, R12W, R13W, R14W, R15W,
	IDTR, GDTR, LDTR, TR, FPCW,
	FPTAG,
	MSR, // Model-Specific Register
	MXCSR,
	FS_BASE, // Base regs for x86_64
	GS_BASE,
	_Count
};

enum class MemoryType {
	READ = 16,   // Memory is read from
	WRITE,       // Memory is written to
	FETCH,       // Memory is fetched
	READ_UNMAPPED,    // Unmapped memory is read from
	WRITE_UNMAPPED,   // Unmapped memory is written to
	FETCH_UNMAPPED,   // Unmapped memory is fetched
	WRITE_PROT,  // Write to write protected, but mapped, memory
	READ_PROT,   // Read from read protected, but mapped, memory
	FETCH_PROT,  // Fetch from non-executable, but mapped, memory
	READ_AFTER,   // Memory is read from (successful access)
};

// All type of hooks for uc_hook_add() API.
enum class HookType {
	// Hook all interrupt/syscall events
	INTR = 1 << 0,
	// Hook a particular instruction - only a very small subset of instructions supported here
	INSN = 1 << 1,
	// Hook a range of code
	CODE = 1 << 2,
	// Hook basic blocks
	BLOCK = 1 << 3,
	// Hook for memory read on unmapped memory
	MEM_READ_UNMAPPED = 1 << 4,
	// Hook for invalid memory write events
	MEM_WRITE_UNMAPPED = 1 << 5,
	// Hook for invalid memory fetch for execution events
	MEM_FETCH_UNMAPPED = 1 << 6,
	// Hook for memory read on read-protected memory
	MEM_READ_PROT = 1 << 7,
	// Hook for memory write on write-protected memory
	MEM_WRITE_PROT = 1 << 8,
	// Hook for memory fetch on non-executable memory
	MEM_FETCH_PROT = 1 << 9,
	// Hook memory read events.
	MEM_READ = 1 << 10,
	// Hook memory write events.
	MEM_WRITE = 1 << 11,
	// Hook memory fetch for execution events
	MEM_FETCH = 1 << 12,
	// Hook memory read events, but only successful access.
	// The callback will be triggered after successful read.
	MEM_READ_AFTER = 1 << 13,
	// Hook invalid instructions exceptions.
	INSN_INVALID = 1 << 14,
};

enum class MemProtection {
	None = UC_PROT_NONE,
	Read = UC_PROT_READ,
	Write = UC_PROT_WRITE,
	Execute = UC_PROT_EXEC,
	All = UC_PROT_ALL,
};
DEFINE_ENUM_FLAG_OPERATORS(MemProtection);

class UnicornEngine {
public:
	UnicornEngine() = default;
	~UnicornEngine();
	UnicornEngine(UnicornEngine const&) = delete;
	UnicornEngine& operator=(UnicornEngine const&) = delete;

	bool Open(CpuArch arch, CpuMode mode);
	void Close();
	bool IsOpen() const;

	uc_err LastError() const;

	CpuMode GetMode() const;

	template<typename T> requires std::is_trivially_copyable_v<T>
	bool WriteReg(x86Register reg, T value) {
		m_LastError = uc_reg_write(m_UC, (int)reg, &value);
		return m_LastError == UC_ERR_OK;
	}

	bool WriteReg(x86Register reg, void* value);
	bool ReadReg(x86Register reg, void* value) const;

	template<typename T> requires std::is_trivially_copyable_v<T>
	T ReadReg(x86Register reg) const {
		T value{};
		m_LastError = uc_reg_read(m_UC, (int)reg, &value);
		return m_LastError == UC_ERR_OK ? value : T{};
	}

	bool MapMemory(uint64_t address, uint64_t size, MemProtection protect);
	bool MapHostMemory(uint64_t address, uint64_t size, MemProtection protect, void* mem);
	bool UnmapMemory(uint64_t address, uint64_t size);
	bool ProtectMemory(uint64_t address, uint64_t size, MemProtection protect);
	bool WriteMemory(uint64_t address, const void* data, uint64_t size);
	bool ReadMemory(uint64_t address, void* data, uint64_t size);
	void UnmapAllMemory();

	bool Start(uint64_t address, uint64_t until, uint64_t timeout = 0, size_t count = 0);
	bool Stop();

	void* HookCode(HookType type, std::function<void(uint64_t, uint32_t)> cb, uint64_t begin, uint64_t end);
	void Unhook(void* hook);

	struct CpuContext {
		friend class UnicornEngine;
		~CpuContext();
		bool Save();
		bool Restore();

	private:
		CpuContext(uc_engine* uc);

	private:
		uc_context* m_ctx;
		uc_engine* m_uc;
	};

	CpuContext AllocContext();
	void EnableHooks(bool enable);

	void* SaveContext(void* ctx = nullptr);
	bool RestoreContext(void* ctx);
	const char* GetErrorText(uc_err error) const;

private:
	static void _CallbackHookCode(uc_engine* uc, uint64_t address, uint32_t size, void* ud);

	struct HookHandle {
		uc_hook m_Hook{ 0 };
		UnicornEngine* m_Engine;
		std::function<void(uint64_t, uint32_t)> m_CB;
	};
	uc_engine* m_UC{ nullptr };
	mutable uc_err m_LastError{ UC_ERR_OK };
	CpuMode m_Mode;
	bool m_HooksEnabled{ true };
};


```

`QuickAsm/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`QuickAsm/pch.h`:

```h
#pragma once

#include <wx/setup.h>
#include <wx/wx.h>
#include <wx/splitter.h>
#include <wx/stc/stc.h>
#include <wx/artprov.h>
#include <wx/sysopt.h>
#include <wx/notebook.h>
#include <wx/listctrl.h>
#include <wx/msgdlg.h> 
#include <wx/config.h> 

#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>
#include <cassert>
#include <memory>
#include <map>

#include <keystone/keystone.h>
#include <capstone/capstone.h>
#include <unicorn/unicorn.h>
#include <wil/resource.h>

```

`QuickAsm/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by wxWidgetsApp.rc
//
#define IDI_RESTART                     200

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`QuickAsm/targetver.h`:

```h
#pragma once

// // Including SDKDDKVer.h defines the highest available Windows platform.
// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
#include <SDKDDKVer.h>

```

`QuickAsm/wxHexView.cpp`:

```cpp
#include "pch.h"
#include "wxHexView.h"

wxIMPLEMENT_DYNAMIC_CLASS(wxHexView, wxControl);

wxHexView::wxHexView(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style, const wxValidator& validator, const wxString& name) {
    Create(parent, id, pos, size, style, validator, name);
}

bool wxHexView::Create(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style, const wxValidator& validator, const wxString& name) {
    if (!CreateControl(parent, id, pos, size, style, validator, name))
        return false;

    m_hWnd = CreateHexView(parent->GetHWND());
    if(!m_hWnd)
		return false;
    
    return true;
}

void wxHexView::SetCurrentPos(uint64_t position) {
    HexView_SetCurPos(m_hWnd, position);
}

size_t wxHexView::GetCurrentPos() const {
    size_t pos = 0;
    HexView_GetCurPos(m_hWnd, &pos);
    return pos;
}

bool wxHexView::InitSharedBuffer(uint8_t* p, size_t size) {
    return HexView_InitBufShared(m_hWnd, p, size);
}

bool wxHexView::SetFont(wxFont const& font) {
    auto hFont = font.GetHFONT();
    if (hFont) {
        HexView_SetFont(m_hWnd, hFont);
        return true;
    }
    return false;
}

bool wxHexView::ScrollTop(size_t pos) {
    return HexView_ScrollTop(m_hWnd, pos);
}

int wxHexView::GetLineLength() const {
    return HexView_GetLineLen(m_hWnd);
}

bool wxHexView::SetLineLength(int length) {
    return HexView_SetLineLen(m_hWnd, length);
}

bool wxHexView::SelectAll() {
    return HexView_SelectAll(m_hWnd);
}

bool wxHexView::SetStyle(HexViewStyles mask, HexViewStyles style) {
    return HexView_SetStyle(m_hWnd, static_cast<DWORD>(mask), static_cast<DWORD>(style));
}

bool wxHexView::SetGrouping(int bytes) {
    return HexView_SetGrouping(m_hWnd, bytes);
}

int wxHexView::GetGrouping() const {
    return HexView_GetGrouping(m_hWnd);
}

bool wxHexView::SetEditMode(EditMode mode) {
    return HexView_SetEditMode(m_hWnd, mode);
}

EditMode wxHexView::GetEditMode() const {
    return (EditMode)HexView_GetEditMode(m_hWnd);
}

bool wxHexView::IsReadOnly() const {
    return HexView_IsReadOnly(m_hWnd);
}

size_t wxHexView::GetSelStart() const {
    size_t start = -1;
    HexView_GetSelStart(m_hWnd, &start);
    return start;
}

size_t wxHexView::GetSelEnd() const {
    size_t end = -1;
    HexView_GetSelEnd(m_hWnd, &end);
    return end;
}

bool wxHexView::SetSel(size_t start, size_t end) {
    return SetSelStart(start) && SetSelEnd(end);
}

bool wxHexView::SetSelStart(size_t start) {
    return HexView_SetSelStart(m_hWnd, start);
}

bool wxHexView::SetSelEnd(size_t end) {
    return HexView_SetSelEnd(m_hWnd, end);
}

std::pair<size_t, size_t> wxHexView::GetSelection() const {
    return std::make_pair(GetSelStart(), GetSelEnd());
}

size_t wxHexView::GetSelSize() const {
    size_t size = 0;
    HexView_GetSelSize(m_hWnd, &size);
    return size;
}

bool wxHexView::SetAddressOffset(size_t offset) {
    HexView_SetAddressOffset(m_hWnd, offset);
    return true;
}

bool wxHexView::SetColor(ColorType type, wxColour const& color) {
    return HexView_SetColor(m_hWnd, type, RGB(color.Red(), color.Green(), color.Blue()));
}

wxColor wxHexView::GetColor(ColorType type) const {
    auto color = HexView_GetColor(m_hWnd, type);
    return wxColor(GetRValue(color), GetGValue(color), GetBValue(color));
}

bool wxHexView::SetPadding(int left, int right) {
    HexView_SetPadding(m_hWnd, left, right);
    return true;
}

void wxHexView::SetContextMenu(wxMenu* menu) {
    HexView_SetContextMenu(m_hWnd, menu->GetHMenu());
}

void wxHexView::SetFocus() {
    ::SetFocus(m_hWnd);
}

bool wxHexView::ProcessCommand(wxCommandEvent& evt) {
    switch (evt.GetId()) {
        case wxID_UNDO: return Undo();
        case wxID_REDO: return Redo();
        case wxID_COPY: return Copy();
        case wxID_CUT: return Cut();
        case wxID_PASTE: return Paste();
        case wxID_DELETE: return Delete();
    }
    return false;
}

bool wxHexView::Copy() const {
    return HexView_Copy(m_hWnd);
}

bool wxHexView::CanCopy() const {
    return GetSelSize() > 0;
}

bool wxHexView::Cut() {
    return HexView_Cut(m_hWnd);
}

bool wxHexView::Paste() {
    return HexView_Paste(m_hWnd);
}

bool wxHexView::CanPaste() const {
    return ::IsClipboardFormatAvailable(CF_TEXT);
}

bool wxHexView::Delete() {
    return HexView_Delete(m_hWnd);
}

bool wxHexView::CanDelete() const {
    return GetEditMode() != EditMode::ReadOnly && GetSelSize() > 0;
}

bool wxHexView::Undo() {
    return HexView_Undo(m_hWnd);
}

bool wxHexView::Redo() {
    return HexView_Redo(m_hWnd);
}

bool wxHexView::CanUndo() const {
    return HexView_CanUndo(m_hWnd);
}

bool wxHexView::CanRedo() const {
    return HexView_CanRedo(m_hWnd);
}

bool wxHexView::OpenFile(PCWSTR path, OpenFileMode mode) {
    return HexView_OpenFile(m_hWnd, path, mode);
}




```

`QuickAsm/wxHexView.h`:

```h
#pragma once

#include "..\HexView\HexView.h"

enum class HexViewStyles {
	FormatHex = HVS_FORMAT_HEX,
	FormatDec = HVS_FORMAT_DEC,
	FormatOct = HVS_FORMAT_OCT,
	FormatBin = HVS_FORMAT_BIN,

	AddressHex = HVS_ADDR_HEX,
	AddressDec = HVS_ADDR_DEC,
	AddressVisible = HVS_ADDR_VISIBLE,
	AddressResizing = HVS_ADDR_RESIZING,
	AddressEndColon = HVS_ADDR_ENDCOLON,
	AddressMidColon = HVS_ADDR_MIDCOLON,
	AddressInvisible = HVS_ADDR_INVISIBLE,

	EndianLittle = HVS_ENDIAN_LITTLE,
	EndianBig = HVS_ENDIAN_BIG,

	AsciiVisible = HVS_ASCII_VISIBLE,
	AsciiShowCtrls = HVS_ASCII_SHOWCTRLS,
	AsciiShowExtended = HVS_ASCII_SHOWEXTD,
	AsciiInvisible = HVS_ASCII_INVISIBLE,
};
DEFINE_ENUM_FLAG_OPERATORS(HexViewStyles);

enum class EditMode {
	ReadOnly = HVMODE_READONLY,
	Insert = HVMODE_INSERT,
	Overwrite = HVMODE_OVERWRITE,
	QuickSave = HVMODE_QUICKSAVE,
};

enum class OpenFileMode {
	Default = HVOF_DEFAULT,
	ReadOnly = HVOF_READONLY,
	QuickLoad = HVOF_QUICKLOAD,
	QuickSave = HVOF_QUICKSAVE,
	AutoQuickLoad = HVOF_AUTOQUICKLOAD,
};

enum class ColorType {
	Background =	HVC_BACKGROUND,
	Selection =		HVC_SELECTION,
	Selection2 =	HVC_SELECTION2,
	Address =		HVC_ADDRESS,
	Hexodd =		HVC_HEXODD,
	Hexoddsel =		HVC_HEXODDSEL,
	Hexoddsel2 =	HVC_HEXODDSEL2,
	Hexeven =		HVC_HEXEVEN,
	Hexevensel =	HVC_HEXEVENSEL,
	Hexevensel2 =	HVC_HEXEVENSEL2,
	Ascii =			HVC_ASCII,
	Asciisel =		HVC_ASCIISEL,
	Asciisel2 =		HVC_ASCIISEL2,
	Modify =		HVC_MODIFY,
	Modifysel =		HVC_MODIFYSEL,
	Modifysel2 =	HVC_MODIFYSEL2,
	Bookmark_fg	=	HVC_BOOKMARK_FG,
	Bookmark_bg	=	HVC_BOOKMARK_BG,
	Booksel =		HVC_BOOKSEL,
	Resizebar =		HVC_RESIZEBAR,
	Selection3 =	HVC_SELECTION3,
	Selection4 =	HVC_SELECTION4,
	Matched =		HVC_MATCHED,
	Matchedsel =	HVC_MATCHEDSEL,
	Matchedsel2	=	HVC_MATCHEDSEL2,
};

class wxHexView : public wxControl {
	wxDECLARE_DYNAMIC_CLASS(wxHexView);
public:
	wxHexView() = default;
	wxHexView(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition,
		const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = L"wxHexView");
	bool Create(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition,
		const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = L"wxHexView");

	void SetCurrentPos(uint64_t position);
	size_t GetCurrentPos() const;
	bool InitSharedBuffer(uint8_t* p, size_t size);
	bool SetFont(wxFont const& font) override;
	bool ScrollTop(size_t pos);
	int GetLineLength() const;
	bool SetLineLength(int length);
	bool SelectAll();
	bool SetStyle(HexViewStyles mask, HexViewStyles style);
	bool SetGrouping(int bytes);
	int GetGrouping() const;
	bool SetEditMode(EditMode mode);
	EditMode GetEditMode() const;
	bool IsReadOnly() const;
	size_t GetSelStart() const;
	size_t GetSelEnd() const;
	bool SetSel(size_t start, size_t end);
	bool SetSelStart(size_t start);
	bool SetSelEnd(size_t end);
	std::pair<size_t, size_t> GetSelection() const;
	size_t GetSelSize() const;
	bool SetAddressOffset(size_t offset);
	bool SetColor(ColorType type, wxColour const& color);
	wxColor GetColor(ColorType type) const;
	bool SetPadding(int left, int right);
	void SetContextMenu(wxMenu* menu);
	void SetFocus();
	bool ProcessCommand(wxCommandEvent& evt);
	void UpdateUI();

	bool Copy() const;
	bool CanCopy() const;
	bool Cut();
	bool Paste();
	bool CanPaste() const;
	bool Delete();
	bool CanDelete() const;
	bool Undo();
	bool Redo();
	bool CanUndo() const;
	bool CanRedo() const;

	bool OpenFile(PCWSTR path, OpenFileMode mode = OpenFileMode::Default);

private:
};


```

`README.md`:

```md
# Quick Assembler

## Simple (experimental) x86/x86 assembler and emulator.

Quick Assembler is built with [wxWidgets](https://www.wxwidgets.org/downloads/). This is my first attempt at using wxWidgets for something real. I have created a private build of wxWidgets that supports static linking of wxWidgets with CRT static linking. If you build it, you may need to change project properties to use dynamic linking with the CRT, as I have not published my tweaks of wxWidgets build.

Here is a list of currently supported features:

* Editing, opening, and saving ASM files, including undo/redo.
* Assemble files with NASM or Keystone engine. For NASM, place `nasm.exe` in the output directory. NASM can be downloaded from its [official site](https://nasm.us/).
* Execute the assembled code (uses [Unicorn Engine](https://www.unicorn-engine.org/) emulator).
* Set breakpoints in the disassembled code.
* Change register values and memory.
* View registers and memory.

## Building

My build setup uses [Vcpkg](https://vcpkg.io/en/) where possible. [Capstone Engine](https://www.capstone-engine.org/), Keystone, and Uniocrn Engine are included using Vcpkg:

```cmd
vcpkg install unicorn:x64-windows
vcpkg install unicorn:x64-windows-static
vcpkg install capstone[x86]-windows
vcpkg install capstone[x86]-windows-static
vcpjg install keystone:x64-windows
vcpjg install keystone:x64-windows-static
```

The wxWidgets installation folder must be set with an environment variable named `WXWIN`. You can get the files by cloning the [wxWidgets repo](https://github.com/wxWidgets/wxWidgets).

## Screenshots

![image](https://github.com/zodiacon/QuickAsm/assets/4227784/b417f6fa-24cd-42ff-8f10-3469c71a4b09)


```

`common/Trace.c`:

```c
//
//  Trace.c
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

//
//	MODULE:		Trace.c
//
//	PURPOSE:	Provides TRACE macros (ala MFC) which wrap the 
//				OutputDebugString API call - removing these
//				calls in release build.
//
//	USAGE:		TRACE(...)  for TCHAR-strings
//				TRACEA(...) for char-strings
//				TRACEW(...) for WCHAR-strings
//
//	HISTORY:	v1.0 16/04/2002 J Brown		- Initial version
//

#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include "Trace.h"

#ifdef _DEBUG

#ifdef _CONSOLE
#define OUTPUTA(s) printf("%s", s)
#define OUTPUTW(s) wprintf(L"%s", s)
#else
#define OUTPUTA(s) OutputDebugStringA(s)
#define OUTPUTW(s) OutputDebugStringW(s)
#endif

//
//	Wide-character (UNICODE) version
//
void TraceW(LPCWSTR szFmt, ...)
{
	wchar_t szBuf[0x400];

	va_list arg;

	if(szFmt == 0) return;

	va_start(arg, szFmt);

	_vsnwprintf(szBuf, 0x400, szFmt, arg);
	OUTPUTW(szBuf);
	
	va_end(arg);
}

//
//	Single-character (ANSI) version
//
void TraceA(LPCSTR szFmt, ...)
{
	char szBuf[0x400];

	va_list arg;

	if(szFmt == 0) return;

	va_start(arg, szFmt);

	_vsnprintf(szBuf, 0x400, szFmt, arg);
	OUTPUTA(szBuf);
	
	va_end(arg);
}

void TraceErr(DWORD err)
{
	LPVOID lpMsgBuf;
	FormatMessageA( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		err,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPSTR) &lpMsgBuf,
		0,
		NULL 
		);

	TraceA( "[%x] %s\n", err, (lpMsgBuf ? lpMsgBuf : "unknown"));
	LocalFree( lpMsgBuf );	
}

#endif
```

`common/Trace.h`:

```h
//
//  Trace.h
//
//  www.catch22.net
//
//  Copyright (C) 2012 James Brown
//  Please refer to the file LICENCE.TXT for copying permission
//

//
//	Use: TRACE  for TCHAR-strings
//		 TRACEA for char-strings
//		 TRACEW for WCHAR-strings
//

#ifndef TRACE_INCLUDED
#define TRACE_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

void TraceA(LPCSTR szFmt, ...);
void TraceW(LPCWSTR szFmt, ...);
void TraceErr(DWORD err);

#ifdef _DEBUG

#define TRACEERR(err) TraceErr(err)

#ifdef UNICODE
#define TRACE	TraceW
#else
#define TRACE	TraceA
#endif

#define TRACEA	TraceA
#define TRACEW	TraceW

#else	//ifndef DEBUG

#define TRACEERR(err) 

#ifdef UNICODE
#define TRACE	//1 ? ((void)0) : TraceW
#else
#define TRACE	//1 ? ((void)0) : TraceA
#endif

#define TRACEA	//1 ? ((void)0) : TraceA
#define TRACEW	//1 ? ((void)0) : TraceW

#endif	//DEBUG

#ifdef UNICODE
#define ODB	TraceW
#else
#define ODB	TraceA
#endif

#define ODBW	TraceW
#define ODBA	TraceA

#ifdef __cplusplus
}
#endif

#endif
```

`x64Types/dllmain.cpp`:

```cpp
#include "pch.h"
#include "x64Types.h"

```

`x64Types/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`x64Types/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H


#endif //PCH_H

```

`x64Types/x64Types.h`:

```h
#pragma once

union CR0 {
    size_t All;
    struct {
        unsigned PE : 1;          //!< [0] Protected Mode Enabled
        unsigned MP : 1;          //!< [1] Monitor Coprocessor FLAG
        unsigned EM : 1;          //!< [2] Emulate FLAG
        unsigned TS : 1;          //!< [3] Task Switched FLAG
        unsigned ET : 1;          //!< [4] Extension Type FLAG
        unsigned NE : 1;          //!< [5] Numeric Error
        unsigned reserved1 : 10;  //!< [6:15]
        unsigned WP : 1;          //!< [16] Write Protect
        unsigned reserved2 : 1;   //!< [17]
        unsigned AM : 1;          //!< [18] Alignment Mask
        unsigned reserved3 : 10;  //!< [19:28]
        unsigned NW : 1;          //!< [29] Not Write-Through
        unsigned CD : 1;          //!< [30] Cache Disable
        unsigned PG : 1;          //!< [31] Paging Enabled
    };
};
static_assert(sizeof(CR0) == sizeof(void*), "Size check");

union CR4 {
    size_t All;
    struct {
        unsigned VME : 1;        //!< [0] Virtual Mode Extensions
        unsigned PVI : 1;        //!< [1] Protected-Mode Virtual Interrupts
        unsigned TSD : 1;        //!< [2] Time Stamp Disable
        unsigned DE : 1;         //!< [3] Debugging Extensions
        unsigned PSE : 1;        //!< [4] Page Size Extensions
        unsigned PAE : 1;        //!< [5] Physical Address Extension
        unsigned MCE : 1;        //!< [6] Machine-Check Enable
        unsigned PGE : 1;        //!< [7] Page Global Enable
        unsigned PCE : 1;        //!< [8] Performance-Monitoring Counter Enable
        unsigned OSFXSR : 1;     //!< [9] OS Support for FXSAVE/FXRSTOR
        unsigned OSXMMEXCPT : 1; //!< [10] OS Support for Unmasked SIMD Exceptions
        unsigned reserved1 : 2;  //!< [11:12]
        unsigned VMXE : 1;       //!< [13] Virtual Machine Extensions Enabled
        unsigned SMXE : 1;       //!< [14] SMX-Enable Bit
        unsigned reserved2 : 2;  //!< [15:16]
        unsigned PCIDE : 1;      //!< [17] PCID Enable
        unsigned OSXSAVE : 1;    //!< [18] XSAVE and Processor Extended States-Enable
        unsigned reserved3 : 1;  //!< [19]
        unsigned SMEP : 1;       //!< [20] Supervisor Mode Execution Protection Enable
        unsigned SMAP : 1;       //!< [21] Supervisor Mode Access Protection Enable
    };
};
static_assert(sizeof(CR4) == sizeof(void*), "Size check");

union DR6 {
    size_t All;
    struct {
        unsigned B0 : 1;          //!< [0] Breakpoint Condition Detected 0
        unsigned B1 : 1;          //!< [1] Breakpoint Condition Detected 1
        unsigned B2 : 1;          //!< [2] Breakpoint Condition Detected 2
        unsigned B3 : 1;          //!< [3] Breakpoint Condition Detected 3
        unsigned reserved1 : 8;   //!< [4:11] Always 1
        unsigned reserved2 : 1;   //!< [12] Always 0
        unsigned BD : 1;          //!< [13] Debug Register Access Detected
        unsigned BS : 1;          //!< [14] Single Step
        unsigned BT : 1;          //!< [15] Task Switch
        unsigned RTM : 1;         //!< [16] Restricted Transactional Memory
        unsigned reserved3 : 15;  //!< [17:31] Always 1
    };
};
static_assert(sizeof(DR6) == sizeof(void*), "Size check");

/// See: Debug Control Register (DR7)
union DR7 {
    size_t All;
    struct {
        unsigned L0 : 1;         //!< [0] Local Breakpoint Enable 0
        unsigned G0 : 1;         //!< [1] Global Breakpoint Enable 0
        unsigned L1 : 1;         //!< [2] Local Breakpoint Enable 1
        unsigned G1 : 1;         //!< [3] Global Breakpoint Enable 1
        unsigned L2 : 1;         //!< [4] Local Breakpoint Enable 2
        unsigned G2 : 1;         //!< [5] Global Breakpoint Enable 2
        unsigned L3 : 1;         //!< [6] Local Breakpoint Enable 3
        unsigned G3 : 1;         //!< [7] Global Breakpoint Enable 3
        unsigned LE : 1;         //!< [8] Local Exact Breakpoint Enable
        unsigned GE : 1;         //!< [9] Global Exact Breakpoint Enable
        unsigned reserved1 : 1;  //!< [10] Always 1
        unsigned RTM : 1;        //!< [11] Restricted Transactional Memory
        unsigned reserved2 : 1;  //!< [12] Always 0
        unsigned GD : 1;         //!< [13] General Detect Enable
        unsigned reserved3 : 2;  //!< [14:15] Always 0
        unsigned RW0 : 2;        //!< [16:17] Read / Write 0
        unsigned LEN0 : 2;       //!< [18:19] Length 0
        unsigned RW1 : 2;        //!< [20:21] Read / Write 1
        unsigned LEN1 : 2;       //!< [22:23] Length 1
        unsigned RW2 : 2;        //!< [24:25] Read / Write 2
        unsigned LEN2 : 2;       //!< [26:27] Length 2
        unsigned RW3 : 2;        //!< [28:29] Read / Write 3
        unsigned LEN3 : 2;       //!< [30:31] Length 3
    };
};
static_assert(sizeof(DR7) == sizeof(void*), "Size check");

#include <pshpack1.h>
struct IDTR {
    unsigned short Limit;
    size_t Base;
};

struct IDTR32 {
    unsigned short Limit;
    unsigned Base;
};
static_assert(sizeof(IDTR32) == 6, "Size check");

union SegmentSelector {
    unsigned short All;
    struct {
        unsigned short RPL : 2;  //!< Requested Privilege Level
        unsigned short TI : 1;   //!< Table Indicator
        unsigned short Index : 13;
    };
};
static_assert(sizeof(SegmentSelector) == 2, "Size check");

union SegmentDescriptor {
    unsigned long long All;
    struct {
        unsigned long long LimitLow : 16;
        unsigned long long BaseLow : 16;
        unsigned long long BaseMid : 8;
        unsigned long long Type : 4;
        unsigned long long System : 1;
        unsigned long long DPL : 2;
        unsigned long long Present : 1;
        unsigned long long LimitHigh : 4;
        unsigned long long AVL : 1;
        unsigned long long L : 1;  //!< 64-bit code segment (IA-32e mode only)
        unsigned long long DB : 1;
        unsigned long long Gran : 1;
        unsigned long long BaseHigh : 8;
    };
};
static_assert(sizeof(SegmentDescriptor) == 8, "Size check");

union CpuFeaturesEcx {
    unsigned All;
    struct {
        unsigned SSE3 : 1;       //!< [0] Streaming SIMD Extensions 3 (SSE3)
        unsigned PCLMULQDQ : 1;  //!< [1] PCLMULQDQ
        unsigned DTES64 : 1;     //!< [2] 64-bit DS Area
        unsigned MONITOR : 1;    //!< [3] MONITOR/WAIT
        unsigned DS_CPL : 1;     //!< [4] CPL qualified Debug Store
        unsigned VMX : 1;        //!< [5] Virtual Machine Technology
        unsigned SMX : 1;        //!< [6] Safer Mode Extensions
        unsigned EST : 1;        //!< [7] Enhanced Intel Speedstep Technology
        unsigned TM2 : 1;        //!< [8] Thermal monitor 2
        unsigned SSSE3 : 1;      //!< [9] Supplemental Streaming SIMD Extensions 3
        unsigned CID : 1;        //!< [10] L1 context ID
        unsigned SDBG : 1;       //!< [11] IA32_DEBUG_INTERFACE MSR
        unsigned FMA : 1;        //!< [12] FMA extensions using YMM state
        unsigned CX16 : 1;       //!< [13] CMPXCHG16B
        unsigned XTPR : 1;       //!< [14] xTPR Update Control
        unsigned PDCM : 1;       //!< [15] Performance/Debug capability MSR
        unsigned reserved : 1;   //!< [16] Reserved
        unsigned PCID : 1;       //!< [17] Process-context identifiers
        unsigned DCA : 1;        //!< [18] prefetch from a memory mapped device
        unsigned SSE4_1 : 1;     //!< [19] SSE4.1
        unsigned SSE4_2 : 1;     //!< [20] SSE4.2
        unsigned X2_APIC : 1;    //!< [21] x2APIC feature
        unsigned MOVBE : 1;      //!< [22] MOVBE instruction
        unsigned POPCNT : 1;     //!< [23] POPCNT instruction
        unsigned reserved2 : 1;  //!< [24] one-shot operation using a TSC deadline
        unsigned AES : 1;        //!< [25] AESNI instruction
        unsigned XSAVE : 1;      //!< [26] XSAVE/XRSTOR feature
        unsigned OSXSAVE : 1;    //!< [27] enable XSETBV/XGETBV instructions
        unsigned AVX : 1;        //!< [28] AVX instruction extensions
        unsigned F16C : 1;       //!< [29] 16-bit floating-point conversion
        unsigned RDRAND : 1;     //!< [30] RDRAND instruction
        unsigned unused : 1;   //!< [31] Always 0 (a.k.a. HypervisorPresent)
    };
};
static_assert(sizeof(CpuFeaturesEcx) == 4, "Size check");

union CpuFeaturesEdx {
    unsigned All;
    struct {
        unsigned FPU : 1;        //!< [0] Floating Point Unit On-Chip
        unsigned VME : 1;        //!< [1] Virtual 8086 Mode Enhancements
        unsigned DE : 1;         //!< [2] Debugging Extensions
        unsigned PSE : 1;        //!< [3] Page Size Extension
        unsigned TSC : 1;        //!< [4] Time Stamp Counter
        unsigned MSR : 1;        //!< [5] RDMSR and WRMSR Instructions
        unsigned MCE : 1;        //!< [7] Machine Check Exception
        unsigned CX8 : 1;        //!< [8] Thermal monitor 2
        unsigned APIC : 1;       //!< [9] APIC On-Chip
        unsigned reserved1 : 1;  //!< [10] Reserved
        unsigned SEP : 1;        //!< [11] SYSENTER and SYSEXIT Instructions
        unsigned MTRR : 1;       //!< [12] Memory Type Range Registers
        unsigned PGE : 1;        //!< [13] Page Global Bit
        unsigned MCA : 1;        //!< [14] Machine Check Architecture
        unsigned CMOV : 1;       //!< [15] Conditional Move Instructions
        unsigned PAT : 1;        //!< [16] Page Attribute Table
        unsigned PSE36 : 1;      //!< [17] 36-Bit Page Size Extension
        unsigned PSN : 1;        //!< [18] Processor Serial Number
        unsigned CLFSH : 1;      //!< [19] CLFLUSH Instruction
        unsigned reserved2 : 1;  //!< [20] Reserved
        unsigned DS : 1;         //!< [21] Debug Store
        unsigned ACPI : 1;       //!< [22] TM and Software Controlled Clock
        unsigned MMX : 1;        //!< [23] Intel MMX Technology
        unsigned FXSR : 1;       //!< [24] FXSAVE and FXRSTOR Instructions
        unsigned SSE : 1;        //!< [25] SSE
        unsigned SSE2 : 1;       //!< [26] SSE2
        unsigned SS : 1;         //!< [27] Self Snoop
        unsigned HTT : 1;        //!< [28] Max APIC IDs reserved field is Valid
        unsigned TM : 1;         //!< [29] Thermal Monitor
        unsigned reserved3 : 1;  //!< [30] Reserved
        unsigned PBE : 1;        //!< [31] Pending Break Enable
    };
};
static_assert(sizeof(CpuFeaturesEdx) == 4, "Size check");

struct HardwarePteX86 {
    unsigned Valid : 1;               //!< [0]
    unsigned Write : 1;               //!< [1]
    unsigned Owner : 1;               //!< [2]
    unsigned WriteThrough : 1;       //!< [3]
    unsigned CacheDisable : 1;       //!< [4]
    unsigned Accessed : 1;            //!< [5]
    unsigned Dirty : 1;               //!< [6]
    unsigned LargePage : 1;          //!< [7]
    unsigned Global : 1;              //!< [8]
    unsigned CopyOnWrite : 1;       //!< [9]
    unsigned Prototype : 1;           //!< [10]
    unsigned reserved : 1;           //!< [11]
    unsigned PageFrameNumber : 20;  //!< [12:31]
};
static_assert(sizeof(HardwarePteX86) == 4, "Size check");

/// nt!_HARDWARE_PTE on x86 PAE-enabled Windows
struct HardwarePteX86PAE {
    unsigned long long Valid : 1;               //!< [0]
    unsigned long long Write : 1;               //!< [1]
    unsigned long long Owner : 1;               //!< [2]
    unsigned long long WriteThrough : 1;       //!< [3]     PWT
    unsigned long long CacheDisable : 1;       //!< [4]     PCD
    unsigned long long Accessed : 1;            //!< [5]
    unsigned long long Dirty : 1;               //!< [6]
    unsigned long long LargePage : 1;          //!< [7]     PAT
    unsigned long long Global : 1;              //!< [8]
    unsigned long long CopyOnWrite : 1;       //!< [9]
    unsigned long long Prototype : 1;           //!< [10]
    unsigned long long reserved1 : 1;           //!< [11]
    unsigned long long PageFrameNumber : 26;  //!< [12:37]
    unsigned long long Reserved2 : 25;          //!< [38:62]
    unsigned long long NoExecute : 1;          //!< [63]
};
static_assert(sizeof(HardwarePteX86PAE) == 8, "Size check");

/// nt!_HARDWARE_PTE on x64 Windows
struct HardwarePteX64 {
    unsigned long long Valid : 1;               //!< [0]
    unsigned long long Write : 1;               //!< [1]
    unsigned long long Owner : 1;               //!< [2]
    unsigned long long WriteThrough : 1;       //!< [3]     PWT
    unsigned long long CacheDisable : 1;       //!< [4]     PCD
    unsigned long long Accessed : 1;            //!< [5]
    unsigned long long Dirty : 1;               //!< [6]
    unsigned long long LargePage : 1;          //!< [7]     PAT
    unsigned long long Global : 1;              //!< [8]
    unsigned long long CopyOnWrite : 1;       //!< [9]
    unsigned long long Prototype : 1;           //!< [10]
    unsigned long long reserved1 : 1;           //!< [11]
    unsigned long long PageFrameNumber : 36;  //!< [12:47]
    unsigned long long reserved2 : 4;           //!< [48:51]
    unsigned long long SoftwareWsIndex : 11;  //!< [52:62]
    unsigned long long NoExecute : 1;          //!< [63]
};
static_assert(sizeof(HardwarePteX64) == 8, "Size check");

enum class MSR : unsigned int {
    ApicBase = 0x01B,

    FeatureControl = 0x03A,

    SysenterCs = 0x174,
    SysenterEsp = 0x175,
    SysenterEip = 0x176,

    Debugctl = 0x1D9,

    MtrrCap = 0xFE,
    MtrrDefType = 0x2FF,
    MtrrPhysBaseN = 0x200,
    MtrrPhysMaskN = 0x201,
    MtrrFix64k00000 = 0x250,
    MtrrFix16k80000 = 0x258,
    MtrrFix16kA0000 = 0x259,
    MtrrFix4kC0000 = 0x268,
    MtrrFix4kC8000 = 0x269,
    MtrrFix4kD0000 = 0x26A,
    MtrrFix4kD8000 = 0x26B,
    MtrrFix4kE0000 = 0x26C,
    MtrrFix4kE8000 = 0x26D,
    MtrrFix4kF0000 = 0x26E,
    MtrrFix4kF8000 = 0x26F,

    VmxBasic = 0x480,
    VmxPinbasedCtls = 0x481,
    VmxProcBasedCtls = 0x482,
    VmxExitCtls = 0x483,
    VmxEntryCtls = 0x484,
    VmxMisc = 0x485,
    VmxCr0Fixed0 = 0x486,
    VmxCr0Fixed1 = 0x487,
    VmxCr4Fixed0 = 0x488,
    VmxCr4Fixed1 = 0x489,
    VmxVmcsEnum = 0x48A,
    VmxProcBasedCtls2 = 0x48B,
    VmxEptVpidCap = 0x48C,
    VmxTruePinbasedCtls = 0x48D,
    VmxTrueProcBasedCtls = 0x48E,
    VmxTrueExitCtls = 0x48F,
    VmxTrueEntryCtls = 0x490,
    VmxVmfunc = 0x491,

    Efer = 0xC0000080,
    Star = 0xC0000081,
    Lstar = 0xC0000082,

    Fmask = 0xC0000084,

    FsBase = 0xC0000100,
    GsBase = 0xC0000101,
    KernelGsBase = 0xC0000102,
    TscAux = 0xC0000103,
};

```

`x64Types/x64Types.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{88d28e0c-de0f-462e-8e6f-78a81ff461f3}</ProjectGuid>
    <RootNamespace>x64Types</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;X64TYPES_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;X64TYPES_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <NoEntryPoint>true</NoEntryPoint>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;X64TYPES_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <NoEntryPoint>true</NoEntryPoint>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;X64TYPES_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <NoEntryPoint>true</NoEntryPoint>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
    <ClInclude Include="x64Types.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`x64Types/x64Types.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="x64Types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```