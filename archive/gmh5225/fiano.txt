Project Path: arc_gmh5225_fiano_vv0td1jh

Source Tree:

```txt
arc_gmh5225_fiano_vv0td1jh
├── CONTRIBUTING.md
├── LICENSE
├── README.md
├── RELEASES.md
├── cmds
│   ├── .gitignore
│   ├── cbfs
│   │   ├── cbfs.go
│   │   ├── cbfs_test.go
│   │   └── testdata
│   │       └── coreboot.rom
│   ├── create-ffs
│   │   ├── create-ffs.go
│   │   └── create-ffs_test.go
│   ├── fittool
│   │   ├── commands
│   │   │   ├── addrawheaders
│   │   │   │   └── command.go
│   │   │   ├── command.go
│   │   │   ├── errors.go
│   │   │   ├── init
│   │   │   │   └── command.go
│   │   │   ├── removeheaders
│   │   │   │   └── command.go
│   │   │   ├── setrawheaders
│   │   │   │   └── command.go
│   │   │   └── show
│   │   │       └── command.go
│   │   └── main.go
│   ├── fmap
│   │   ├── fmap.go
│   │   ├── fmap_test.go
│   │   └── testdata
│   │       └── fake_test.flash
│   ├── fspinfo
│   │   ├── README.md
│   │   ├── main.go
│   │   ├── main_test.go
│   │   └── test_blobs
│   │       ├── ApolloLakeFspBinPkg
│   │       │   └── Fsp.fd
│   │       ├── FSP_License.pdf
│   │       └── README.md
│   ├── glzma
│   │   └── glzma.go
│   ├── guid2english
│   │   └── main.go
│   ├── microcode
│   │   └── microcode.go
│   └── utk
│       └── utk.go
├── data
│   └── PurleySiliconBinPkg
│       └── MeFirmware
│           ├── IgnitionFirmware
│           │   ├── License.txt
│           │   ├── MeRegion.bin
│           │   ├── Other_Licenses
│           │   │   └── libgcc_License.txt
│           │   └── README.md
│           └── README.md
├── fiano-logo.svg
├── go.mod
├── go.sum
├── integration
│   ├── files.go
│   ├── roms
│   │   ├── OVMF.json
│   │   ├── OVMF.md
│   │   ├── OVMF.rom
│   │   ├── OVMF_target.txt
│   │   ├── nvartest
│   │   │   ├── fvh.bin
│   │   │   ├── old0
│   │   │   ├── summary.json
│   │   │   └── test
│   │   ├── ovmfSECFV.fv
│   │   └── testfile.ffs
│   └── utk_test.go
├── pkg
│   ├── amd
│   │   ├── apcb
│   │   │   ├── apcb.go
│   │   │   ├── apcb_test.go
│   │   │   ├── internal.go
│   │   │   └── testdata
│   │   │       └── apcb_binary.xz
│   │   ├── manifest
│   │   │   ├── bios_directory_table.go
│   │   │   ├── bios_directory_table_test.go
│   │   │   ├── checksum.go
│   │   │   ├── checksum_test.go
│   │   │   ├── embedded_firmware_structure.go
│   │   │   ├── embedded_firmware_structure_test.go
│   │   │   ├── firmware.go
│   │   │   ├── internal.go
│   │   │   ├── psp_directory_table.go
│   │   │   ├── psp_directory_table_test.go
│   │   │   ├── psp_header.go
│   │   │   └── psp_header_test.go
│   │   └── psb
│   │       ├── biosentries.go
│   │       ├── common.go
│   │       ├── entries.go
│   │       ├── entries_test.go
│   │       ├── errors.go
│   │       ├── keys.go
│   │       ├── keys_artifacts_test.go
│   │       ├── keys_test.go
│   │       ├── keyset.go
│   │       ├── psbbinary.go
│   │       ├── psbbinary_test.go
│   │       ├── pspbinary_artifacts_test.go
│   │       ├── pspentries.go
│   │       ├── signature.go
│   │       ├── types.go
│   │       └── util.go
│   ├── bytes
│   │   ├── README.md
│   │   ├── is_zero_filled.go
│   │   ├── is_zero_filled_amd64.go
│   │   ├── is_zero_filled_other.go
│   │   ├── is_zero_filled_test.go
│   │   ├── range.go
│   │   └── range_test.go
│   ├── cbfs
│   │   ├── bootblock.go
│   │   ├── bootsplash.go
│   │   ├── cbfs.go
│   │   ├── cmos.go
│   │   ├── cmoslayout.go
│   │   ├── data.go
│   │   ├── empty.go
│   │   ├── file.go
│   │   ├── fns.go
│   │   ├── fsp.go
│   │   ├── image.go
│   │   ├── image_test.go
│   │   ├── master.go
│   │   ├── microcode.go
│   │   ├── optionrom.go
│   │   ├── payload.go
│   │   ├── raw.go
│   │   ├── spd.go
│   │   ├── stage.go
│   │   ├── testdata
│   │   │   └── coreboot.rom
│   │   ├── types.go
│   │   └── unknown.go
│   ├── compression
│   │   ├── compression.go
│   │   ├── compression_test.go
│   │   ├── lz4.go
│   │   ├── lzma.go
│   │   ├── systembrotli.go
│   │   ├── systemlzma.go
│   │   ├── testdata
│   │   │   ├── random.bin
│   │   │   ├── random.bin.lz4
│   │   │   ├── random.bin.lzma
│   │   │   ├── random.bin.lzma86
│   │   │   └── random.bin.zlib
│   │   ├── x86.go
│   │   └── zlib.go
│   ├── fmap
│   │   ├── fmap.go
│   │   └── fmap_test.go
│   ├── fsp
│   │   ├── header.go
│   │   └── header_test.go
│   ├── guid
│   │   ├── guid.go
│   │   └── guid_test.go
│   ├── guid2english
│   │   ├── transformer.go
│   │   └── transformer_test.go
│   ├── intel
│   │   ├── me
│   │   │   ├── me.go
│   │   │   ├── me_test.go
│   │   │   └── structures.go
│   │   ├── metadata
│   │   │   ├── README.md
│   │   │   ├── bg
│   │   │   │   ├── bgbootpolicy
│   │   │   │   │   ├── bpmh.go
│   │   │   │   │   ├── bpmh_manifestcodegen.go
│   │   │   │   │   ├── manifest.go
│   │   │   │   │   ├── manifest_manifestcodegen.go
│   │   │   │   │   ├── manifest_nocodegen.go
│   │   │   │   │   ├── manifest_test.go
│   │   │   │   │   ├── pm.go
│   │   │   │   │   ├── pm_manifestcodegen.go
│   │   │   │   │   ├── se.go
│   │   │   │   │   ├── se_manifestcodegen.go
│   │   │   │   │   ├── signature.go
│   │   │   │   │   ├── signature_manifestcodegen.go
│   │   │   │   │   └── testdata
│   │   │   │   │       ├── bpm.bin
│   │   │   │   │       ├── bpm2.bin
│   │   │   │   │       └── bpm3.bin
│   │   │   │   ├── bgkey
│   │   │   │   │   ├── manifest.go
│   │   │   │   │   ├── manifest_manifestcodegen.go
│   │   │   │   │   ├── manifest_nocodegen.go
│   │   │   │   │   ├── manifest_test.go
│   │   │   │   │   └── testdata
│   │   │   │   │       └── km.bin
│   │   │   │   ├── config.go
│   │   │   │   ├── crypto_routines.go
│   │   │   │   ├── crypto_routines_manifestcodegen.go
│   │   │   │   ├── hash.go
│   │   │   │   ├── hash_manifestcodegen.go
│   │   │   │   ├── key.go
│   │   │   │   ├── key_manifestcodegen.go
│   │   │   │   ├── key_signature.go
│   │   │   │   ├── key_signature_manifestcodegen.go
│   │   │   │   ├── signature.go
│   │   │   │   ├── signature_manifestcodegen.go
│   │   │   │   ├── signature_types.go
│   │   │   │   ├── structure.go
│   │   │   │   ├── structure_manifestcodegen.go
│   │   │   │   ├── svn.go
│   │   │   │   └── svn_manifestcodegen.go
│   │   │   ├── cbnt
│   │   │   │   ├── cbntbootpolicy
│   │   │   │   │   ├── Reserved.go
│   │   │   │   │   ├── Reserved_manifestcodegen.go
│   │   │   │   │   ├── bpmh.go
│   │   │   │   │   ├── bpmh_manifestcodegen.go
│   │   │   │   │   ├── manifest.go
│   │   │   │   │   ├── manifest_manifestcodegen.go
│   │   │   │   │   ├── manifest_nocodegen.go
│   │   │   │   │   ├── manifest_test.go
│   │   │   │   │   ├── pcd.go
│   │   │   │   │   ├── pcd_manifestcodegen.go
│   │   │   │   │   ├── pm.go
│   │   │   │   │   ├── pm_manifestcodegen.go
│   │   │   │   │   ├── se.go
│   │   │   │   │   ├── se_manifestcodegen.go
│   │   │   │   │   ├── signature.go
│   │   │   │   │   ├── signature_manifestcodegen.go
│   │   │   │   │   ├── testdata
│   │   │   │   │   │   └── bpm.bin
│   │   │   │   │   ├── txt.go
│   │   │   │   │   ├── txt_control_flags.go
│   │   │   │   │   ├── txt_control_flags_manifestcodegen.go
│   │   │   │   │   └── txt_manifestcodegen.go
│   │   │   │   ├── cbntkey
│   │   │   │   │   ├── hash.go
│   │   │   │   │   ├── hash_manifestcodegen.go
│   │   │   │   │   ├── manifest.go
│   │   │   │   │   ├── manifest_manifestcodegen.go
│   │   │   │   │   ├── manifest_nocodegen.go
│   │   │   │   │   ├── manifest_test.go
│   │   │   │   │   └── testdata
│   │   │   │   │       └── km.bin
│   │   │   │   ├── chipset_ac_module_information.go
│   │   │   │   ├── chipset_ac_module_information_manifestcodegen.go
│   │   │   │   ├── chipset_ac_module_information_nocodegen.go
│   │   │   │   ├── config.go
│   │   │   │   ├── crypto_routines.go
│   │   │   │   ├── crypto_routines_manifestcodegen.go
│   │   │   │   ├── hash.go
│   │   │   │   ├── hash_manifestcodegen.go
│   │   │   │   ├── key.go
│   │   │   │   ├── key_manifestcodegen.go
│   │   │   │   ├── key_signature.go
│   │   │   │   ├── key_signature_manifestcodegen.go
│   │   │   │   ├── signature.go
│   │   │   │   ├── signature_manifestcodegen.go
│   │   │   │   ├── signature_types.go
│   │   │   │   ├── structure.go
│   │   │   │   ├── structure_manifestcodegen.go
│   │   │   │   ├── svn.go
│   │   │   │   ├── tpm_info_list.go
│   │   │   │   └── tpm_info_list_manifestcodegen.go
│   │   │   ├── common
│   │   │   │   ├── bgheader
│   │   │   │   │   └── bgheader.go
│   │   │   │   ├── examples
│   │   │   │   │   └── cmd
│   │   │   │   │       └── bpmdump
│   │   │   │   │           └── main.go
│   │   │   │   ├── manifestcodegen
│   │   │   │   │   ├── cmd
│   │   │   │   │   │   └── manifestcodegen
│   │   │   │   │   │       ├── main.go
│   │   │   │   │   │       ├── template_methods.go
│   │   │   │   │   │       └── template_methods.tpl.go
│   │   │   │   │   └── pkg
│   │   │   │   │       └── analyze
│   │   │   │   │           ├── basic_named_type.go
│   │   │   │   │           ├── field.go
│   │   │   │   │           ├── func.go
│   │   │   │   │           ├── manifest_field_type.go
│   │   │   │   │           ├── package.go
│   │   │   │   │           ├── pretty_string.go
│   │   │   │   │           ├── scan.go
│   │   │   │   │           └── struct.go
│   │   │   │   ├── pretty
│   │   │   │   │   ├── options.go
│   │   │   │   │   └── pretty.go
│   │   │   │   ├── tracedbinary
│   │   │   │   │   └── binary.go
│   │   │   │   └── unittest
│   │   │   │       └── read_write.go
│   │   │   └── fit
│   │   │       ├── calc_offset.go
│   │   │       ├── check
│   │   │       │   ├── bounds.go
│   │   │       │   └── errors.go
│   │   │       ├── consts
│   │   │       │   ├── consts.go
│   │   │       │   └── fit.go
│   │   │       ├── ent_bios_policy_record.go
│   │   │       ├── ent_bios_startup_module_entry.go
│   │   │       ├── ent_boot_policy_manifest.go
│   │   │       ├── ent_cse_secure_boot.go
│   │   │       ├── ent_diagnostic_acm.go
│   │   │       ├── ent_feature_policy_delivery_record.go
│   │   │       ├── ent_fit_header_entry.go
│   │   │       ├── ent_jmp_debug_policy.go
│   │   │       ├── ent_key_manifest_record.go
│   │   │       ├── ent_microcode_update_entry.go
│   │   │       ├── ent_skip.go
│   │   │       ├── ent_startup_ac_module_entry.go
│   │   │       ├── ent_startup_ac_module_entry_test.go
│   │   │       ├── ent_tpm_policy_record.go
│   │   │       ├── ent_txt_policy_record.go
│   │   │       ├── ent_unknown.go
│   │   │       ├── entry.go
│   │   │       ├── entry_base.go
│   │   │       ├── entry_headers.go
│   │   │       ├── entry_test.go
│   │   │       ├── entry_type.go
│   │   │       ├── errors.go
│   │   │       ├── firmware.go
│   │   │       ├── get_entries.go
│   │   │       ├── get_entries_test.go
│   │   │       └── table.go
│   │   └── microcode
│   │       ├── microcode.go
│   │       └── microcode_test.go
│   ├── knownguids
│   │   └── guids.go
│   ├── log
│   │   └── logger.go
│   ├── uefi
│   │   ├── biosregion.go
│   │   ├── file.go
│   │   ├── file_test.go
│   │   ├── firmwarevolume.go
│   │   ├── firmwarevolume_test.go
│   │   ├── flash.go
│   │   ├── flash_test.go
│   │   ├── flashdescriptormap.go
│   │   ├── flashmastersection.go
│   │   ├── flashparams.go
│   │   ├── flashregionsection.go
│   │   ├── fuzz.go
│   │   ├── fuzz_test.go
│   │   ├── meregion.go
│   │   ├── meregion_test.go
│   │   ├── nvram.go
│   │   ├── nvram_test.go
│   │   ├── rawregion.go
│   │   ├── region.go
│   │   ├── region_test.go
│   │   ├── section.go
│   │   ├── section_test.go
│   │   ├── testdata
│   │   │   └── fuzz_in.txz
│   │   ├── uefi.go
│   │   ├── uefi_test.go
│   │   └── visitor.go
│   ├── unicode
│   │   └── ucs2.go
│   ├── utk
│   │   └── utk.go
│   └── visitors
│       ├── assemble.go
│       ├── assemble_test.go
│       ├── cat.go
│       ├── cat_test.go
│       ├── cli.go
│       ├── comment.go
│       ├── comment_test.go
│       ├── count.go
│       ├── count_test.go
│       ├── createfv.go
│       ├── createfv_test.go
│       ├── dump.go
│       ├── dump_test.go
│       ├── dxecleaner.go
│       ├── dxecleaner_test.go
│       ├── extract.go
│       ├── extract_test.go
│       ├── find.go
│       ├── find_test.go
│       ├── flatten.go
│       ├── helpers_test.go
│       ├── insert.go
│       ├── insert_test.go
│       ├── json.go
│       ├── json_test.go
│       ├── nvarinvalidate.go
│       ├── nvarinvalidate_test.go
│       ├── nvramcompact.go
│       ├── nvramcompact_test.go
│       ├── parsedir.go
│       ├── remove.go
│       ├── remove_test.go
│       ├── repack.go
│       ├── repack_test.go
│       ├── replacepe32.go
│       ├── replacepe32_test.go
│       ├── save.go
│       ├── table.go
│       ├── tightenme.go
│       ├── validate.go
│       └── validate_test.go
└── scripts
    ├── checklicenses
    │   └── checklicenses.go
    ├── namecollect
    │   └── namecollect.go
    └── pre-commit

```

`CONTRIBUTING.md`:

```md
# Contributing to fiano

Contributions are very welcome. See [issues](https://github.com/linuxboot/fiano/issues), and join us in [Slack](CONTRIBUTING.md#communication) to talk about your cool ideas for the project.

## Developer Sign-Off

For purposes of tracking code-origination, we follow a simple sign-off
process.  If you can attest to the [Developer Certificate of
Origin](https://developercertificate.org/) then you append in each git
commit text a line such as:
```
Signed-off-by: Your Name <username@youremail.com>
```
## Code of Conduct

Conduct your collaboration around the u-root [Code of
Conduct](https://github.com/u-root/u-root/wiki/Code-of-Conduct).

## Communication

- [Slack](https://u-root.slack.com), sign up
[here](http://slack.u-root.com/)
- [Join the mailing list](https://groups.google.com/forum/#!forum/u-root)

## Bugs

- Please submit issues to https://github.com/linuxboot/fiano/issues

## Coding Style

This project aims to follow the standard formatting recommendations
and language idioms set out in the [Effective Go](https://golang.org/doc/effective_go.html)
guide, for example [formatting](https://golang.org/doc/effective_go.html#formatting)
and [names](https://golang.org/doc/effective_go.html#names).

We have a few rules not covered by these tools:

- Standard imports are separated from other imports. Example:
    ```
    import (
      "regexp"
      "time"

      dhcp "github.com/krolaw/dhcp4"
    )
    ```

## Patch Format

Well formatted patches aid code review pre-merge and code archaeology in
the future.  The abstract form should be:
```
<component>: Change summary

More detailed explanation of your changes: Why and how.
Wrap it to 72 characters.
See [here] (http://chris.beams.io/posts/git-commit/)
for some more good advices.

Signed-off-by: <contributor@foo.com>
```

An example from this repo:
```
tcz: quiet it down

It had a spurious print that was both annoying and making
boot just a tad slower.

Signed-off-by: Ronald G. Minnich <rminnich@gmail.com>
```

## General Guidelines

## Pull Requests

We accept GitHub pull requests.

Fork the project on GitHub, work in your fork and in branches, push
these to your GitHub fork, and when ready, do a GitHub pull requests
against https://github.com/linuxboot/fiano.

`fiano` uses [dep](https://github.com/golang/dep)
for its dependency management. Please run `dep ensure`, `dep prune`, and commit Gopkg.toml, Gopkg.lock and vendor/ changes before opening a pull request.

Every commit in your pull request needs to be able to build and pass the CI tests.

If the pull request closes an issue please note it as: `"Fixes #NNN"`.

## Code Reviews

Look at the area of code you're modifying, its history, and consider
tagging some of the [maintainers](https://u-root.tk/#contributors) when doing a
pull request in order to instigate some code review.

## Quality Controls

[CircleCI](https://circleci.com/gh/linuxboot/fiano) is used to test and build commits in a pull request.

See [.circleci/config.yml](.circleci/config.yml) for the CI commands run. [test.sh](test.sh) is maintained as an easy way to run the commands locally. Additionally you can use [CircleCI's CLI tool](https://circleci.com/docs/2.0/local-jobs/) to run individual jobs from `.circlecl/config.yml` via Docker, eg. `circleci build --jobs dep`.

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2018-2019 LinuxBoot
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# fiano

Go-based tools for modifying UEFI firmware.

[![CircleCI](https://circleci.com/gh/linuxboot/fiano.svg?style=shield)](https://circleci.com/gh/linuxboot/fiano)
[![Go Report
Card](https://goreportcard.com/badge/github.com/linuxboot/fiano)](https://goreportcard.com/report/github.com/linuxboot/fiano)
[![GoDoc](https://godoc.org/github.com/linuxboot/fiano?status.svg)](https://godoc.org/github.com/linuxboot/fiano)
[![CodeCov](https://codecov.io/gh/linuxboot/fiano/branch/master/graph/badge.svg)](https://codecov.io/gh/linuxboot/fiano/)
[![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://github.com/linuxboot/fiano/blob/master/LICENSE)

![Fiano](./fiano-logo.svg)

# Contributing

For information about contributing, including how we sign off commits, please see
CONTRIBUTING.md

## UTK: Generic UEFI tool kit meant to handle rom images

Example usage:

```
# For a comprehensive list of commands
utk -h

# Display the image in a compact table form:
utk winterfell.rom table

# Summarize everything in JSON:
utk winterfell.rom json

# List information about a single file in JSON (using regex):
utk winterfell.rom find Shell

# Dump an EFI file to an ffs
utk winterfell.rom dump DxeCore dxecore.ffs

# Insert an EFI file into an FV near another Dxe
utk winterfell.rom insert_before Shell dxecore.ffs save inserted.rom
utk winterfell.rom insert_after Shell dxecore.ffs save inserted.rom

# Insert an EFI file into an FV at the front or the end
# "Shell" is just a means of specifying the FV that contains Shell
utk winterfell.rom insert_front Shell dxecore.ffs save inserted.rom
utk winterfell.rom insert_end Shell dxecore.ffs save inserted.rom

# Remove a file and pad the firmware volume to maintain offsets for the following files
utk winterfell.rom remove_pad Shell save removed.rom

# Remove two files by their GUID without padding and replace shell with Linux:
utk winterfell.rom \
  remove 12345678-9abc-def0-1234-567890abcdef \
  remove 23830293-3029-3823-0922-328328330939 \
  replace_pe32 Shell linux.efi \
  save winterfell2.rom

# Extract everything into a directory:
utk winterfell.rom extract winterfell/

# Re-assemble the directory into an image:
utk winterfell/ save winterfell2.rom
```

### DXE Cleaner

Delete unnecessary DXEs from your firmware. Free up space, speed up boot times
and decrease the attack surface area! See the demo:

[![asciicast](https://asciinema.org/a/233950.svg)](https://asciinema.org/a/233950)

## FMAP: Parses flash maps.

Example usage:

  + `fmap checksum [md5|sha1|sha256] FILE`
  + `fmap extract i FILE`
  + `fmap jget JSONFILE FILE`
  + `fmap jput JSONFILE FILE`
  + `fmap summary FILE`
  + `fmap usage FILE`
  + `fmap verify FILE`

## Installation

    # Golang version 1.13 is required:
    go version

    # For UTK:
    go install github.com/linuxboot/fiano/cmds/utk@latest

    # For fmap:
    go install github.com/linuxboot/fiano/cmds/fmap@latest

The executables are installed in `$HOME/go/bin`.

## Updating Dependencies

    # Fiano utilizes Go modules.
    Use the following to download the dependencies:
    ```
    go mod download
    go mod verify
    ```

    If you desire to update a existing dependency to a newer version:
    ```
    go get path/to/dependency/module@tag
    ```
    Execute this in any directory of fiano repository

```

`RELEASES.md`:

```md
# Releases

A new release happens every 6 weeks:

- 1st day on the first month of each quarter
- 15th day of the second month of each quarter


## v5.0.0 (2019-02-12)

- New Fiano logo
- Forth UTK
- Support for depex and version sections
- New visitors
  - insert, dxecleaner, repack, comment
- Option to use system's xz command
- Fixed region parsing for older IFDs
- Tested with:
  - Golang 1.11
  - u-root v3.0.0


## v2.0.0 (2018-10-01)

- utk2 has been merged into utk and the visitor pattern is here to stay.
- New major features:
  - Support for assembling compressed subsections
  - Improved test coverage
  - Support for CircleCI
  - Support for dependency expression parsing
- New visitors:
  - assemble, cat, count, dump, extract, find, insert, remove, table, verify
- Major bug fixes:
  - Fixed losing padding data between firmware volumes.
  - Fixed growing a compressed firmware volume to the excess of 16MiB.
  - Pads files are now created appropriately and without conflicting GUIDs.
- Tested with:
  - Golang 1.11
  - u-root v2.0.0


## v1.0.0 (2018-08-15)

- Initial release
- Tested with:
  - Golang 1.10.3
  - u-root v1.0.0
- Known bugs:
  - [#67](https://github.com/linuxboot/fiano/issues): UTK incorrectly loses pad
  files when multiple pad files contain the same GUID. It is common for BIOSes
  to set the GUID of all pad files to FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF.

```

`cmds/.gitignore`:

```
# Ignore binaries (files without extensions)
*
!*.*
!*/

```

`cmds/cbfs/cbfs.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/linuxboot/fiano/pkg/cbfs"
	flag "github.com/spf13/pflag"
)

var debug = flag.BoolP("debug", "d", false, "enable debug prints")

var errUsage = errors.New("usage: cbfs <firmware-file> <json,list,extract <directory-name>>")
var errMissingDirectory = errors.New("provide a directory name")

func run(stdout io.Writer, debug bool, args []string) error {
	if debug {
		cbfs.Debug = log.Printf
	}

	if len(args) < 2 {
		return errUsage
	}

	i, err := cbfs.Open(args[0])
	if err != nil {
		return err
	}

	switch args[1] {
	case "list":
		fmt.Fprintf(stdout, "%s", i.String())
	case "json":
		j, err := json.MarshalIndent(i, "  ", "  ")
		if err != nil {
			return err
		}
		fmt.Fprintf(stdout, "%s", string(j))
	case "extract":
		if len(args) != 3 {
			return errMissingDirectory
		}
		dir := filepath.Join(".", args[2])
		err := os.MkdirAll(dir, os.ModePerm)
		if err != nil {
			return err
		}

		base := i.Area.Offset
		log.Printf("FMAP base at %x", base)
		for s := range i.Segs {
			f := i.Segs[s].GetFile()
			n := f.Name
			c := f.Compression()
			o := f.RecordStart
			if f.Type.String() == cbfs.TypeDeleted.String() || f.Type.String() == cbfs.TypeDeleted2.String() {
				log.Printf("Skipping empty/deleted file at 0x%x", o)
			} else {
				log.Printf("Extracting %v from 0x%x, compression: %v", n, o, c)
				fpath := filepath.Join(dir, strings.ReplaceAll(n, "/", "_"))
				d, err := f.Decompress()
				if err != nil {
					return err
				}
				err = os.WriteFile(fpath, d, 0644)
				if err != nil {
					return err
				}
			}
		}
	default:
		return errUsage
	}

	return nil
}

func main() {
	flag.Parse()
	if err := run(os.Stdout, *debug, flag.Args()); err != nil {
		log.Fatal(err)
	}
}

```

`cmds/cbfs/cbfs_test.go`:

```go
// Copyright 2024 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestCBFS(t *testing.T) {
	t.Run("usage error", func(t *testing.T) {
		err := run(io.Discard, false, []string{"list"})
		if !errors.Is(err, errUsage) {
			t.Errorf("expected %v, got nil", errUsage)
		}
	})

	t.Run("unknown command", func(t *testing.T) {
		err := run(io.Discard, false, []string{"testdata/coreboot.rom", "unknown"})
		if !errors.Is(err, errUsage) {
			t.Errorf("expected %v, got nil", errUsage)
		}
	})

	t.Run("list command", func(t *testing.T) {
		stdout := &bytes.Buffer{}
		err := run(stdout, false, []string{"testdata/coreboot.rom", "list"})
		if err != nil {
			t.Fatalf("expected nil got %v", err)
		}

		if !strings.Contains(stdout.String(), "fallback/ramstage") {
			t.Errorf("output doesn't contain `fallback/ramstage`, %s", stdout.String())
		}
	})

	t.Run("list json", func(t *testing.T) {
		stdout := &bytes.Buffer{}
		err := run(stdout, false, []string{"testdata/coreboot.rom", "json"})
		if err != nil {
			t.Fatalf("expected nil got %v", err)
		}

		if !strings.Contains(stdout.String(), "fallback/ramstage") {
			t.Errorf("output doesn't contain `fallback/ramstage`, %s", stdout.String())
		}

		j := make(map[string]any)
		err = json.Unmarshal(stdout.Bytes(), &j)
		if err != nil {
			t.Errorf("expected json output, got unmarshal error: %v", err)
		}
	})

	t.Run("extract missing dir", func(t *testing.T) {
		err := run(io.Discard, false, []string{"testdata/coreboot.rom", "extract"})
		if !errors.Is(err, errMissingDirectory) {
			t.Errorf("expected %v, got nil", errMissingDirectory)
		}
	})

	t.Run("extract", func(t *testing.T) {
		dir := t.TempDir()
		// save local path
		romPath, err := filepath.Abs("testdata/coreboot.rom")
		if err != nil {
			t.Fatal(err)
		}

		err = os.Chdir(dir)
		if err != nil {
			t.Fatal(err)
		}

		err = run(io.Discard, false, []string{romPath, "extract", "firmware"})
		if err != nil {
			t.Fatalf("expected nil, got %v", err)
		}
	})
}

```

`cmds/create-ffs/create-ffs.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"crypto/sha1"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
	"github.com/linuxboot/fiano/pkg/visitors"
)

var (
	debug      = flag.Bool("d", false, "Enable debug prints")
	outfile    = flag.String("o", "", "output file, default is stdout")
	name       = flag.String("name", "", "Name to include in UI section")
	filetype   = flag.String("type", "DRIVER", "UEFI filetype")
	version    = flag.String("version", "1.0", "File version")
	guidString = flag.String("guid", "", "File GUID")
	depex      = flag.String("depex", "", "Space or comma separated protocol guid dependencies or TRUE")

	printf = func(string, ...interface{}) {}
)

const (
	usageString = "Usage: create-ffs [flags] file.efi"
)

func createDepExes(deps string) ([]uefi.DepExOp, error) {
	var err error
	ops := []uefi.DepExOp{}

	if strings.ToUpper(deps) == "TRUE" {
		// Create just "TRUE" and "END" for now, but this feels unnecessary to me.
		ops = append(ops, uefi.DepExOp{OpCode: "TRUE"})
		ops = append(ops, uefi.DepExOp{OpCode: "END"})
		return ops, nil
	}

	// we expect a space or comma separated list of GUIDs, split by both.
	guidSpace := strings.Split(deps, " ")
	guids := []string{}
	for _, g := range guidSpace {
		guids = append(guids, strings.Split(g, ",")...)
	}

	for _, guidStr := range guids {
		var g *guid.GUID

		if g, err = guid.Parse(guidStr); err != nil {
			return nil, err
		}
		printf("depex guid requested: %v", *g)
		ops = append(ops, uefi.DepExOp{OpCode: "PUSH", GUID: g})
	}

	// Append an "AND" for n-1 pushes.
	for i := 1; i < len(guids); i++ {
		ops = append(ops, uefi.DepExOp{OpCode: "AND"})
	}

	ops = append(ops, uefi.DepExOp{OpCode: "END"})
	return ops, nil
}

func parseFlags() (fType uefi.FVFileType, fGUID *guid.GUID, depOps []uefi.DepExOp, err error) {
	var ok bool

	if *debug {
		printf = log.Printf
	}

	// Check filetypes
	fType, ok = uefi.NamesToFileType[*filetype]
	if !ok {
		validTypes := []string{}
		for k := range uefi.NamesToFileType {
			validTypes = append(validTypes, k)
		}
		err = fmt.Errorf("unable to get EFI File type, got %v, expected values in\n{%v}",
			*filetype, strings.Join(validTypes, ", "))
		return
	}

	if *guidString != "" {
		fGUID, err = guid.Parse(*guidString)
		if err != nil {
			return
		}
	} else if *name != "" {
		// We sha1 the name to get a reproducible GUID.
		fGUID = &guid.GUID{}
		sum := sha1.Sum([]byte(*name))
		copy(fGUID[:], sum[:guid.Size])
	} else {
		err = errors.New("no GUID or name provided, please provide at least one")
		return
	}

	if *outfile == "" {
		err = errors.New("we don't currently support dumping to stdout, please specify an output file")
		return
	}

	if *depex != "" {
		depOps, err = createDepExes(*depex)
		if err != nil {
			err = fmt.Errorf("can't parse depex guids, got %v", err)
		}
	}

	return
}

func usage() {
	log.Print(usageString)
	flag.PrintDefaults()
	os.Exit(1)
}

func main() {
	var fType uefi.FVFileType
	var fGUID *guid.GUID
	var depOps []uefi.DepExOp
	var err error

	flag.Parse()
	if fType, fGUID, depOps, err = parseFlags(); err != nil {
		log.Fatal(err)
	}

	if flag.NArg() != 1 {
		usage()
	}

	secData, err := os.ReadFile(flag.Arg(0))
	if err != nil {
		log.Fatal(err)
	}

	printf("type requested: %v", fType)
	printf("name requested: %v", *name)
	printf("version requested: %v", *version)
	printf("guid: %v", fGUID)

	secType := uefi.SectionTypeRaw
	switch fType {
	case uefi.FVFileTypeApplication, uefi.FVFileTypeCombinedSMMDXE,
		uefi.FVFileTypeCombinedPEIMDriver, uefi.FVFileTypeDriver:
		secType = uefi.SectionTypePE32
	}

	file := &uefi.File{}
	file.Header.Type = fType
	file.Header.GUID = *fGUID
	file.Header.State = 0xF8
	file.Header.Attributes = 0x40

	mainSection := &uefi.Section{}
	mainSection.SetType(secType)
	mainSection.SetBuf(secData)
	// It is not clear why the author felt it was OK to ignore
	// the error.
	_ = mainSection.GenSecHeader()
	file.Sections = append(file.Sections, mainSection)
	printf("selected section type: %v", mainSection.Header.Type)

	if *name != "" {
		s := &uefi.Section{}
		s.SetType(uefi.SectionTypeUserInterface)
		s.Name = *name
		file.Sections = append(file.Sections, s)
	}

	if *version != "" {
		s := &uefi.Section{}
		s.SetType(uefi.SectionTypeVersion)
		s.Version = *version
		file.Sections = append(file.Sections, s)
	}

	if *depex != "" {
		s := &uefi.Section{}
		s.SetType(uefi.SectionTypeDXEDepEx)
		s.DepEx = depOps
		file.Sections = append(file.Sections, s)
	}

	save := &visitors.Save{DirPath: *outfile}

	err = file.Apply(save)
	if err != nil {
		log.Fatal(err)
	}

	if *debug {
		// Dump file json for checking
		jsonv := &visitors.JSON{W: os.Stdout}
		if err = file.Apply(jsonv); err != nil {
			log.Fatal(err)
		}
	}
}

```

`cmds/create-ffs/create-ffs_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

func compareErrors(expected string, err error) error {
	if expected != "" {
		if err == nil {
			return fmt.Errorf("error was not returned, expected %v", expected)
		}
		if expected != err.Error() {
			return fmt.Errorf("mismatched error returned, expected \n%v\n got \n%v",
				expected, err.Error())
		}
	} else if err != nil {
		return fmt.Errorf("error was not expected, got %v", err)
	}
	return nil
}

func compareOps(expectedOps []uefi.DepExOp, ops []uefi.DepExOp) error {
	if expectedOps != nil {
		if ops == nil {
			return fmt.Errorf("expected ops: %v, got nil", expectedOps)
		}
		if elen, olen := len(expectedOps), len(ops); elen != olen {
			return fmt.Errorf("different lenghts of depexes expected \n%v\n got \n%v",
				elen, olen)
		}
		for i := range expectedOps {
			if expectedOps[i].OpCode != ops[i].OpCode {
				return fmt.Errorf("different opcodes! expected %v, got %v",
					expectedOps[i].OpCode, ops[i].OpCode)
			}
			if expectedOps[i].GUID != nil {
				if ops[i].GUID == nil {
					return fmt.Errorf("expected GUID %v, got nil",
						*expectedOps[i].GUID)
				}
				if *expectedOps[i].GUID != *ops[i].GUID {
					return fmt.Errorf("mismatched GUID, expected %v, got %v",
						*expectedOps[i].GUID, *ops[i].GUID)
				}
			} else if ops[i].GUID != nil {
				return fmt.Errorf("expected no GUIDs, got %v", *ops[i].GUID)
			}
		}
	} else if ops != nil {
		return fmt.Errorf("expected no ops, got %v", ops)
	}
	return nil
}

func TestCreateDepExes(t *testing.T) {
	var tests = []struct {
		name  string
		input string
		ops   []uefi.DepExOp
		msg   string
	}{
		{"trueDepEx", "TRUE", []uefi.DepExOp{{OpCode: "TRUE"}, {OpCode: "END"}}, ""},
		{"pushone", "01234567-89AB-CDEF-0123-456789ABCDEF",
			[]uefi.DepExOp{
				{OpCode: "PUSH", GUID: guid.MustParse("01234567-89AB-CDEF-0123-456789ABCDEF")},
				{OpCode: "END"}}, ""},
		{"pushtwo", "01234567-89AB-CDEF-0123-456789ABCDEF 01234567-89AB-CDEF-0123-456789ABCDEF",
			[]uefi.DepExOp{
				{OpCode: "PUSH", GUID: guid.MustParse("01234567-89AB-CDEF-0123-456789ABCDEF")},
				{OpCode: "PUSH", GUID: guid.MustParse("01234567-89AB-CDEF-0123-456789ABCDEF")},
				{OpCode: "AND"},
				{OpCode: "END"}}, ""},
		{"badGUID", "ABC", nil, "guid string not correct, need string of the format \n01234567-89AB-CDEF-0123-456789ABCDEF" +
			"\n, got \nABC"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			outputs, err := createDepExes(test.input)
			if err = compareErrors(test.msg, err); err != nil {
				t.Fatal(err)
			}
			if err = compareOps(test.ops, outputs); err != nil {
				t.Fatal(err)
			}
		})
	}
}

```

`cmds/fittool/commands/addrawheaders/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package addrawheaders

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit"
)

var _ commands.Command = (*Command)(nil)

type Command struct {
	UEFIPath        string  `description:"path to UEFI image" required:"true" short:"f" long:"uefi"`
	AddressPointer  *uint64 `description:"the value for field 'ADDRESS'" long:"address-pointer"`
	AddressOffset   *uint64 `description:"the offset value to calculate the value for field 'ADDRESS'" long:"address-offset"`
	Size            *uint32 `description:"the value for field 'SIZE'" long:"size"`
	Version         *uint16 `description:"the value for field 'VERSION'" long:"version"`
	Type            *uint8  `description:"the value for field 'TYPE'" long:"type"`
	IsChecksumValid *bool   `description:"the value for field 'C_V'" long:"is-checksum-valid"`
	Checksum        *uint8  `description:"the value for field 'CHECKSUM'" long:"checksum"`
}

// ShortDescription explains what this command does in one line
func (cmd *Command) ShortDescription() string {
	return "insert an additional FIT entry headers to the UEFI image"
}

// LongDescription explains what this verb does (without limitation in amount of lines)
func (cmd *Command) LongDescription() string {
	return ""
}

// Execute is the main function here. It is responsible to
// start the execution of the command.
//
// `args` are the arguments left unused by verb itself and options.
func (cmd *Command) Execute(args []string) error {
	if len(args) != 0 {
		return commands.ErrArgs{Err: fmt.Errorf("there are extra arguments")}
	}

	if cmd.AddressOffset != nil && cmd.AddressPointer != nil {
		return commands.ErrArgs{Err: fmt.Errorf("it does not make sense to use '--address-pointer' and '--address-offset' together")}
	}

	if cmd.Type != nil && *cmd.Type >= 0x80 {
		return commands.ErrArgs{Err: fmt.Errorf("invalid value of 'type', it should be less than 0x80")}
	}

	file, err := os.OpenFile(cmd.UEFIPath, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("unable to open the firmware image file '%s': %w", cmd.UEFIPath, err)
	}

	table, err := fit.GetTableFrom(file)
	if err != nil {
		return fmt.Errorf("unable to get FIT from the firmware image: %w", err)
	}

	if len(table) == 0 {
		return fmt.Errorf("FIT is not initialized in the image")
	}

	entryHeaders := &fit.EntryHeaders{
		Version: fit.EntryVersion(0x1000),
	}
	entryHeaders.TypeAndIsChecksumValid.SetType(fit.EntryTypeSkip)

	if cmd.AddressPointer != nil {
		entryHeaders.Address = fit.Address64(*cmd.AddressPointer)
	}
	if cmd.AddressOffset != nil {
		fileSize, err := file.Seek(0, io.SeekEnd)
		if err != nil {
			return fmt.Errorf("unable to determine the file size: %w", err)
		}
		entryHeaders.Address.SetOffset(*cmd.AddressOffset, uint64(fileSize))
	}
	if cmd.Size != nil {
		entryHeaders.Size.SetUint32(*cmd.Size)
	}
	if cmd.IsChecksumValid != nil {
		entryHeaders.TypeAndIsChecksumValid.SetIsChecksumValid(*cmd.IsChecksumValid)
	}
	if cmd.Type != nil {
		entryHeaders.TypeAndIsChecksumValid.SetType(fit.EntryType(*cmd.Type))
	}
	if entryHeaders.TypeAndIsChecksumValid.IsChecksumValid() {
		entryHeaders.Checksum = entryHeaders.CalculateChecksum()
	}

	if cmd.Checksum != nil {
		entryHeaders.Checksum = *cmd.Checksum
	}

	if table[0].Type() != fit.EntryTypeFITHeaderEntry {
		return fmt.Errorf("the first entry should be of type 0x00")
	}
	table = append(table, *entryHeaders)
	table[0].Size.SetUint32(uint32(len(table)))
	if _, err := table.WriteToFirmwareImage(file); err != nil {
		return fmt.Errorf("unable to write FIT into a firmware: %w", err)
	}
	return nil
}

```

`cmds/fittool/commands/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package commands

import (
	"github.com/jessevdk/go-flags"
)

// Command is an interface of implementations of verbs
// (like "add", "remove" etc of "fittool add"/"fittool remove")
type Command interface {
	flags.Commander

	// ShortDescription explains what this command does in one line
	ShortDescription() string

	// LongDescription explains what this verb does (without limitation in amount of lines)
	LongDescription() string
}

```

`cmds/fittool/commands/errors.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package commands

import (
	"fmt"
)

// ErrArgs means arguments are invalid
type ErrArgs struct {
	Err error
}

func (err ErrArgs) Error() string {
	return fmt.Sprintf("invalid arguments: %v", err.Err)
}

func (err ErrArgs) Unwrap() error {
	return err.Err
}

```

`cmds/fittool/commands/init/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package init

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit"
)

var _ commands.Command = (*Command)(nil)

type Command struct {
	UEFIPath          string  `short:"f" long:"uefi" description:"path to UEFI image" required:"true"`
	Pointer           *uint64 `short:"p" long:"pointer" description:"the FIT pointer value"`
	PointerFromOffset *uint64 `long:"pointer-from-offset" description:"the FIT pointer value defined by an offset from the beginning of the image"`
}

// ShortDescription explains what this command does in one line
func (cmd *Command) ShortDescription() string {
	return "initializes FIT: insert a FIT pointer and the FIT entry of type 0x00"
}

// LongDescription explains what this verb does (without limitation in amount of lines)
func (cmd *Command) LongDescription() string {
	return ""
}

// Execute is the main function here. It is responsible to
// start the execution of the command.
//
// `args` are the arguments left unused by verb itself and options.
func (cmd *Command) Execute(args []string) error {
	if len(args) != 0 {
		return commands.ErrArgs{Err: fmt.Errorf("there are extra arguments")}
	}

	if cmd.PointerFromOffset == nil && cmd.Pointer == nil {
		return commands.ErrArgs{Err: fmt.Errorf("either '--pointer' or '--pointer-from-offset' is required")}
	}
	if cmd.PointerFromOffset != nil && cmd.Pointer != nil {
		return commands.ErrArgs{Err: fmt.Errorf("it does not make sense to use '--pointer' and '--pointer-from-offset' together")}
	}

	file, err := os.OpenFile(cmd.UEFIPath, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("unable to open the firmware image file '%s': %w", cmd.UEFIPath, err)
	}

	fileSize, err := file.Seek(0, io.SeekEnd)
	if err != nil {
		return fmt.Errorf("unable to detect file size (through seek): %w", err)
	}

	var fitOffset uint64
	if cmd.Pointer != nil {
		fitOffset = fit.Address64(*cmd.Pointer).Offset(uint64(fileSize))
	}
	if cmd.PointerFromOffset != nil {
		fitOffset = *cmd.PointerFromOffset
	}

	entries := fit.Entries{
		&fit.EntryFITHeaderEntry{},
	}
	if err := entries.RecalculateHeaders(); err != nil {
		return fmt.Errorf("unable to recalculate headers: %w", err)
	}

	if err := entries.InjectTo(file, fitOffset); err != nil {
		return fmt.Errorf("unable to inject entries to the firmware: %w", err)
	}

	return nil
}

```

`cmds/fittool/commands/removeheaders/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package removeheaders

import (
	"fmt"
	"os"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit"
)

var _ commands.Command = (*Command)(nil)

type Command struct {
	UEFIPath    string `description:"path to UEFI image" required:"true" short:"f" long:"uefi"`
	EntryNumber uint   `description:"FIT entry number" required:"true" short:"n" long:"entry-number"`
}

// ShortDescription explains what this command does in one line
func (cmd *Command) ShortDescription() string {
	return "remove a headers entry from FIT (but does not remove referenced data)"
}

// LongDescription explains what this verb does (without limitation in amount of lines)
func (cmd *Command) LongDescription() string {
	return ""
}

// Execute is the main function here. It is responsible to
// start the execution of the command.
//
// `args` are the arguments left unused by verb itself and options.
func (cmd *Command) Execute(args []string) error {
	if len(args) != 0 {
		return commands.ErrArgs{Err: fmt.Errorf("there are extra arguments")}
	}

	file, err := os.OpenFile(cmd.UEFIPath, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("unable to open the firmware image file '%s': %w", cmd.UEFIPath, err)
	}

	table, err := fit.GetTableFrom(file)
	if err != nil {
		return fmt.Errorf("unable to get FIT from the firmware image: %w", err)
	}

	if len(table) == 0 {
		return fmt.Errorf("FIT is not initialized in the image")
	}

	if len(table) <= int(cmd.EntryNumber) {
		return fmt.Errorf("there are only %d entries in the FIT (no entry # %d)", len(table), cmd.EntryNumber)
	}

	for idx := int(cmd.EntryNumber); idx < len(table)-1; idx++ {
		table[idx] = table[idx+1]
	}
	lastEntry := &table[len(table)-1]
	*lastEntry = fit.EntryHeaders{} // fill with zeros

	table[0].Size.SetUint32(uint32(len(table)) - 1)
	if _, err := table.WriteToFirmwareImage(file); err != nil {
		return fmt.Errorf("unable to write FIT into a firmware: %w", err)
	}
	return nil
}

```

`cmds/fittool/commands/setrawheaders/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package setrawheaders

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit"
)

var _ commands.Command = (*Command)(nil)

type Command struct {
	UEFIPath        string  `description:"path to UEFI image" required:"true" short:"f" long:"uefi"`
	EntryNumber     uint    `description:"FIT entry number" required:"true" short:"n" long:"entry-number"`
	AddressPointer  *uint64 `description:"the value for field 'ADDRESS'" long:"address-pointer"`
	AddressOffset   *uint64 `description:"the offset value to calculate the value for field 'ADDRESS'" long:"address-offset"`
	Size            *uint32 `description:"the value for field 'SIZE'" long:"size"`
	Version         *uint16 `description:"the value for field 'VERSION'" long:"version"`
	Type            *uint8  `description:"the value for field 'TYPE'" long:"type"`
	IsChecksumValid *bool   `description:"the value for field 'C_V'" long:"is-checksum-valid"`
	Checksum        *uint8  `description:"the value for field 'CHECKSUM'" long:"checksum"`
}

// ShortDescription explains what this command does in one line
func (cmd *Command) ShortDescription() string {
	return "overwrites FIT entry headers in the UEFI image"
}

// LongDescription explains what this verb does (without limitation in amount of lines)
func (cmd *Command) LongDescription() string {
	return ""
}

// Execute is the main function here. It is responsible to
// start the execution of the command.
//
// `args` are the arguments left unused by verb itself and options.
func (cmd *Command) Execute(args []string) error {
	if len(args) != 0 {
		return commands.ErrArgs{Err: fmt.Errorf("there are extra arguments")}
	}

	if cmd.AddressOffset != nil && cmd.AddressPointer != nil {
		return commands.ErrArgs{Err: fmt.Errorf("it does not make sense to use '--address-pointer' and '--address-offset' together")}
	}

	if cmd.Type != nil && *cmd.Type >= 0x80 {
		return commands.ErrArgs{Err: fmt.Errorf("invalid value of 'type', it should be less than 0x80")}
	}

	file, err := os.OpenFile(cmd.UEFIPath, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("unable to open the firmware image file '%s': %w", cmd.UEFIPath, err)
	}

	table, err := fit.GetTableFrom(file)
	if err != nil {
		return fmt.Errorf("unable to get FIT from the firmware image: %w", err)
	}

	if len(table) == 0 {
		return fmt.Errorf("FIT is not initialized in the image")
	}

	for len(table) <= int(cmd.EntryNumber) {
		hdr := fit.EntryHeaders{}
		hdr.TypeAndIsChecksumValid.SetType(fit.EntryTypeSkip)
		table = append(table, hdr)
	}

	entryHeaders := &table[cmd.EntryNumber]

	if cmd.AddressPointer != nil {
		entryHeaders.Address = fit.Address64(*cmd.AddressPointer)
	}
	if cmd.AddressOffset != nil {
		fileSize, err := file.Seek(0, io.SeekEnd)
		if err != nil {
			return fmt.Errorf("unable to determine the file size: %w", err)
		}
		entryHeaders.Address.SetOffset(*cmd.AddressOffset, uint64(fileSize))
	}
	if cmd.Size != nil {
		entryHeaders.Size.SetUint32(*cmd.Size)
	}
	if cmd.IsChecksumValid != nil {
		entryHeaders.TypeAndIsChecksumValid.SetIsChecksumValid(*cmd.IsChecksumValid)
	}
	if cmd.Type != nil {
		entryHeaders.TypeAndIsChecksumValid.SetType(fit.EntryType(*cmd.Type))
	}
	if entryHeaders.TypeAndIsChecksumValid.IsChecksumValid() {
		entryHeaders.Checksum = entryHeaders.CalculateChecksum()
	}
	if cmd.Checksum != nil {
		entryHeaders.Checksum = *cmd.Checksum
	}

	if table[0].Type() != fit.EntryTypeFITHeaderEntry {
		return fmt.Errorf("the first entry should be of type 0x00")
	}
	table[0].Size.SetUint32(uint32(len(table)))
	if _, err := table.WriteToFirmwareImage(file); err != nil {
		return fmt.Errorf("unable to write FIT into a firmware: %w", err)
	}
	return nil
}

```

`cmds/fittool/commands/show/command.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package show

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit"
)

var _ commands.Command = (*Command)(nil)

type Command struct {
	UEFIPath    string  `short:"f" long:"uefi" description:"path to UEFI image" required:"true"`
	Format      *string `long:"format" description:"output format [text, json]"`
	IncludeData *bool   `long:"include-data" description:"print also data section referenced by the FIT headers"`
}

type Format int

const (
	FormatUndefined = Format(iota)
	FormatText
	FormatJSON
)

func ParseFormat(s string) Format {
	switch strings.Trim(strings.ToLower(s), " ") {
	case "text":
		return FormatText
	case "json":
		return FormatJSON
	}
	return FormatUndefined
}

// ShortDescription explains what this command does in one line
func (cmd *Command) ShortDescription() string {
	return "prints FIT"
}

// LongDescription explains what this verb does (without limitation in amount of lines)
func (cmd *Command) LongDescription() string {
	return ""
}

// Execute is the main function here. It is responsible to
// start the execution of the command.
//
// `args` are the arguments left unused by verb itself and options.
func (cmd *Command) Execute(args []string) error {
	if len(args) != 0 {
		return commands.ErrArgs{Err: fmt.Errorf("there are extra arguments")}
	}

	includeData := false
	if cmd.IncludeData != nil {
		includeData = *cmd.IncludeData
	}

	format := FormatText
	if cmd.Format != nil {
		format = ParseFormat(*cmd.Format)
		if format == FormatUndefined {
			return commands.ErrArgs{Err: fmt.Errorf("unknown format '%s'", *cmd.Format)}
		}
	}

	file, err := os.OpenFile(cmd.UEFIPath, os.O_RDWR, 0)
	if err != nil {
		return fmt.Errorf("unable to open the firmware image file '%s': %w", cmd.UEFIPath, err)
	}

	entries, err := fit.GetEntriesFrom(file)
	if err != nil {
		return fmt.Errorf("unable to get FIT entries: %w", err)
	}

	switch format {
	case FormatText:
		if includeData {
			fmt.Printf("%s", entries.String())
		} else {
			fmt.Printf("%s", entries.Table().String())
		}
	case FormatJSON:
		var b []byte
		var err error
		if includeData {
			b, err = json.Marshal(entries)
		} else {
			b, err = json.Marshal(entries.Table())
		}
		if err != nil {
			panic(err)
		}
		fmt.Printf("%s\n", b)
	}

	return nil
}

```

`cmds/fittool/main.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// fittool manipulates Intel Firmware Interface Table (FIT) in an UEFI image.
//
//
// See "Firmware Interface Table BIOS Specification":
// * https://www.intel.com/content/dam/develop/external/us/en/documents/firmware-interface-table-bios-specification-r1p2p1.pdf
//
// Synopsis:
//     fittool init -f UEFI_FILE
//     fittool add_raw_headers -f UEFI_FILE [options]
//     fittool set_raw_headers -f UEFI_FILE -n ENTRY_ID [options]
//     fittool remove_headers -f UEFI_FILE -n ENTRY_ID [options]
//     fittool show -f UEFI_FILE [options]
//
// An example:
//     fittool init -f firmware.fd
//     fittool add_raw_headers -f firmware.fd --type 2 --address $((16#100000)) --size $((16#20000))
//     fittool set_raw_headers -f firmware.fd -n 1 --type $((16#7F))
//     fittool remove_headers -f firmware.fd -n 1
//     fittool show -f firmware.fd --format=json --include-data | jq -r '.[] | select(.Headers.Type == 2) | .DataParsed.EntrySACMDataInterface.TXTSVN'
//
// Description:
//     init:            Creates a FIT
//     add_raw_headers: Add raw headers to FIT
//     set_raw_headers: Overwrite the row # ENTRY_ID with specified RAW headers
//     remove_headers:  Remove headers from row entry # ENTRY_ID
//     show:            Print FIT
//
// For more advanced key manifest and boot policy manifest management see also Converged Security Suite:
// * https://github.com/9elements/converged-security-suite
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 */
package main

import (
	"log"

	"github.com/jessevdk/go-flags"

	"github.com/linuxboot/fiano/cmds/fittool/commands"
	"github.com/linuxboot/fiano/cmds/fittool/commands/addrawheaders"
	_init "github.com/linuxboot/fiano/cmds/fittool/commands/init"
	"github.com/linuxboot/fiano/cmds/fittool/commands/removeheaders"
	"github.com/linuxboot/fiano/cmds/fittool/commands/setrawheaders"
	"github.com/linuxboot/fiano/cmds/fittool/commands/show"
)

var (
	knownCommands = map[string]commands.Command{
		"init":            &_init.Command{},
		"show":            &show.Command{},
		"add_raw_headers": &addrawheaders.Command{},
		"set_raw_headers": &setrawheaders.Command{},
		"remove_headers":  &removeheaders.Command{},
	}
)

func main() {
	flagsParser := flags.NewParser(nil, flags.Default)
	for commandName, command := range knownCommands {
		_, err := flagsParser.AddCommand(commandName, command.ShortDescription(), command.LongDescription(), command)
		if err != nil {
			panic(err)
		}
	}

	// parse arguments and execute the appropriate command
	if _, err := flagsParser.Parse(); err != nil {
		log.Fatal(err)
	}
}

```

`cmds/fmap/fmap.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Fmap parses flash maps.
//
// Synopsis:
//
//	fmap checksum [md5|sha1|sha256] FILE
//	fmap extract [index|name] FILE
//	fmap jget JSONFILE FILE
//	fmap jput JSONFILE FILE
//	fmap summary FILE
//	fmap usage FILE
//	fmap verify FILE
//
// Description:
//
//	checksum: Print a checksum using the given hash function.
//	extract:  Print the i-th area or area name from the flash.
//	jget:     Write json representation of the fmap to JSONFILE.
//	jput:     Replace current fmap with json representation in JSONFILE.
//	summary:  Print a human readable summary.
//	usage:    Print human readable usage stats.
//	verify:   Return 1 if the flash map is invalid.
//
//	This implementation is based off of https://github.com/dhendrix/flashmap.
package main

import (
	"bytes"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/json"
	"errors"
	"fmt"
	"hash"
	"io"
	"os"
	"strconv"
	"text/template"

	"github.com/linuxboot/fiano/pkg/fmap"
	"github.com/linuxboot/fiano/pkg/log"
)

var cmds = map[string]struct {
	nArgs               int
	openFile, parseFMap bool
	f                   func(a cmdArgs) error
}{
	"checksum": {1, true, true, checksum},
	"extract":  {1, true, true, extract},
	"jget":     {1, true, true, jsonGet},
	"jput":     {1, false, false, jsonPut},
	"summary":  {0, true, true, summary},
	"usage":    {0, true, false, usage},
	"jusage":   {0, true, false, jusage},
	"verify":   {0, true, true, verify},
}

type cmdArgs struct {
	args []string
	f    *fmap.FMap     // optional
	m    *fmap.Metadata // optional
	r    *os.File
}

var hashFuncs = map[string](func() hash.Hash){
	"md5":    md5.New,
	"sha1":   sha1.New,
	"sha256": sha256.New,
}

type jsonSchema struct {
	FMap     *fmap.FMap
	Metadata *fmap.Metadata
}

// Print a checksum using the given hash function.
func checksum(a cmdArgs) error {
	if _, ok := hashFuncs[a.args[0]]; !ok {
		msg := "Not a valid hash function. Must be one of:"
		for k := range hashFuncs {
			msg += " " + k
		}
		return errors.New(msg)
	}

	checksum, err := a.f.Checksum(a.r, hashFuncs[a.args[0]]())
	if err != nil {
		return err
	}
	fmt.Printf("%x\n", checksum)
	return nil
}

// Print the i-th area of the flash.
func extract(a cmdArgs) error {
	i, err := strconv.Atoi(a.args[0])
	if err != nil {
		i = a.f.IndexOfArea(a.args[0])
		if i == -1 {
			return fmt.Errorf("area %q not found", a.args[0])
		}
	}
	area, err := a.f.ReadArea(a.r, i)
	if err != nil {
		return err
	}
	_, err = os.Stdout.Write(area)
	return err
}

// Write json representation of the fmap to JSONFILE.
func jsonGet(a cmdArgs) error {
	data, err := json.MarshalIndent(jsonSchema{a.f, a.m}, "", "\t")
	if err != nil {
		return err
	}
	data = append(data, byte('\n'))
	return os.WriteFile(a.args[0], data, 0666)
}

// Replace current fmap with json representation in JSONFILE.
func jsonPut(a cmdArgs) error {
	r, err := os.OpenFile(os.Args[len(os.Args)-1], os.O_WRONLY, 0666)
	if err != nil {
		return err
	}
	defer r.Close()

	data, err := os.ReadFile(a.args[0])
	if err != nil {
		return err
	}
	j := jsonSchema{}
	if err := json.Unmarshal(data, &j); err != nil {
		return err
	}
	return fmap.Write(r, j.FMap, j.Metadata)
}

// Print a human readable summary.
func summary(a cmdArgs) error {
	const desc = `Fmap found at {{printf "%#x" .Metadata.Start}}:
	Signature:  {{printf "%s" .Signature}}
	VerMajor:   {{.VerMajor}}
	VerMinor:   {{.VerMinor}}
	Base:       {{printf "%#x" .Base}}
	Size:       {{printf "%#x" .Size}}
	Name:       {{.Name}}
	NAreas:     {{.NAreas}}
{{- range $i, $v := .Areas}}
	Areas[{{$i}}]:
		Offset:  {{printf "%#x" $v.Offset}}
		Size:    {{printf "%#x" $v.Size}}
		Name:    {{$v.Name}}
		Flags:   {{printf "%#x" $v.Flags}} ({{FlagNames $v.Flags}})
{{- end}}
`
	t := template.Must(template.New("desc").
		Funcs(template.FuncMap{"FlagNames": fmap.FlagNames}).
		Parse(desc))
	// Combine the two structs to pass into template.
	combined := struct {
		*fmap.FMap
		Metadata *fmap.Metadata
	}{a.f, a.m}
	return t.Execute(os.Stdout, combined)
}

// Print human readable usage stats.
func usage(a cmdArgs) error {
	blockSize := 4 * 1024
	rowLength := 32

	buffer := make([]byte, blockSize)
	fullBlock := bytes.Repeat([]byte{0xff}, blockSize)
	zeroBlock := bytes.Repeat([]byte{0x00}, blockSize)

	fmt.Println("Legend: '.' - full (0xff), '0' - zero (0x00), '#' - mixed")

	if _, err := a.r.Seek(0, io.SeekStart); err != nil {
		return err
	}

	var numBlocks, numFull, numZero int
loop:
	for {
		fmt.Printf("%#08x: ", numBlocks*blockSize)
		for col := 0; col < rowLength; col++ {
			// Read next block.
			_, err := io.ReadFull(a.r, buffer)
			if err == io.EOF {
				fmt.Print("\n")
				break loop
			} else if err == io.ErrUnexpectedEOF {
				fmt.Printf("\nWarning: flash is not a multiple of %d", len(buffer))
				break loop
			} else if err != nil {
				return err
			}
			numBlocks++

			// Analyze block.
			if bytes.Equal(buffer, fullBlock) {
				numFull++
				fmt.Print(".")
			} else if bytes.Equal(buffer, zeroBlock) {
				numZero++
				fmt.Print("0")
			} else {
				fmt.Print("#")
			}
		}
		fmt.Print("\n")
	}

	// Print usage statistics.
	print := func(name string, n int) {
		fmt.Printf("%s %d (%.1f%%)\n", name, n,
			float32(n)/float32(numBlocks)*100)
	}
	print("Blocks:      ", numBlocks)
	print("Full (0xff): ", numFull)
	print("Empty (0x00):", numZero)
	print("Mixed:       ", numBlocks-numFull-numZero)
	return nil
}

type rowEntry struct {
	Entries []string `json:"entries"`
	Address string   `json:"address"`
}
type flashLaout struct {
	Data   []rowEntry `json:"layout"`
	Blocks int        `json:"blocks"`
	Full   int        `json:"full"`
	Zero   int        `json:"zero"`
	Used   int        `json:"used"`
}

// Print machine readable usage stats.
func jusage(a cmdArgs) error {
	blockSize := 4 * 1024
	rowLength := 32

	buffer := make([]byte, blockSize)
	fullBlock := bytes.Repeat([]byte{0xff}, blockSize)
	zeroBlock := bytes.Repeat([]byte{0x00}, blockSize)

	if _, err := a.r.Seek(0, io.SeekStart); err != nil {
		return err
	}

	var numBlocks, numFull, numZero int

	var layout flashLaout

loop:
	for {
		var row rowEntry
		row.Address = fmt.Sprintf("%#08x", numBlocks*blockSize)
		for col := 0; col < rowLength; col++ {
			// Read next block.
			_, err := io.ReadFull(a.r, buffer)
			if err == io.EOF {
				break loop
			} else if err == io.ErrUnexpectedEOF {
				fmt.Printf("\nWarning: flash is not a multiple of %d", len(buffer))
				break loop
			} else if err != nil {
				return err
			}
			numBlocks++

			// Analyze block.
			if bytes.Equal(buffer, fullBlock) {
				numFull++
				row.Entries = append(row.Entries, "full")
			} else if bytes.Equal(buffer, zeroBlock) {
				numZero++
				row.Entries = append(row.Entries, "zero")
			} else {
				row.Entries = append(row.Entries, "used")
			}
		}
		layout.Data = append(layout.Data, row)
	}
	layout.Blocks = numBlocks
	layout.Full = numFull
	layout.Zero = numZero
	layout.Used = numBlocks - numFull - numZero

	// fmt.Printf("%s\n%s\n", layout.data[0].address, layout.data[0].entries[0])
	data, err := json.MarshalIndent(layout, "", "  ")
	if err != nil {
		return err
	}
	fmt.Println(string(data))
	return nil
}

// Return 1 if the flash map is invalid.
func verify(a cmdArgs) error {
	var err error
	for i, area := range a.f.Areas {
		if area.Offset+area.Size > a.f.Size {
			err = errors.New("invalid flash map")
			log.Errorf("Area %d is out of range", i)
		}
	}
	return err
}

func printUsage() {
	fmt.Printf("Usage: %s CMD [ARGS...] FILE\n", os.Args[0])
	fmt.Printf("CMD can be one of:\n")
	for k := range cmds {
		fmt.Printf("\t%s\n", k)
	}
	os.Exit(2)
}

func main() {
	// Validate args.
	if len(os.Args) <= 2 {
		printUsage()
	}
	cmd, ok := cmds[os.Args[1]]
	if !ok {
		log.Errorf("Invalid command %#v\n", os.Args[1])
		printUsage()
	}
	if len(os.Args) != cmd.nArgs+3 {
		log.Errorf("Expected %d arguments, got %d\n", cmd.nArgs+3, len(os.Args))
		printUsage()
	}

	// Args passed to the command.
	a := cmdArgs{
		args: os.Args[2 : len(os.Args)-1],
	}

	// Open file, but only for specific commands.
	if cmd.openFile {
		// Open file.
		r, err := os.Open(os.Args[len(os.Args)-1])
		if err != nil {
			log.Fatalf("%v", err)
		}
		a.r = r
		defer r.Close()
	}

	// Parse fmap, but only for specific commands.
	if cmd.parseFMap {
		// Parse fmap.
		f, m, err := fmap.Read(a.r)
		if err != nil {
			log.Fatalf("%v", err)
		}
		a.f, a.m = f, m
	}

	// Execute command.
	if err := cmd.f(a); err != nil {
		log.Fatalf("%v", err)
	}
}

```

`cmds/fmap/fmap_test.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"os"
	"path/filepath"
	"testing"

	"github.com/u-root/u-root/pkg/testutil"
)

const testFlash = "testdata/fake_test.flash"

var tests = []struct {
	cmd string
	out string
}{
	// Test summary
	{
		cmd: "summary",
		out: `Fmap found at 0x5f74:
	Signature:  __FMAP__
	VerMajor:   1
	VerMinor:   0
	Base:       0xcafebabedeadbeef
	Size:       0x44332211
	Name:       Fake flash
	NAreas:     2
	Areas[0]:
		Offset:  0xdeadbeef
		Size:    0x11111111
		Name:    Area Number 1Hello
		Flags:   0x1013 (STATIC|COMPRESSED|0x1010)
	Areas[1]:
		Offset:  0xcafebabe
		Size:    0x22222222
		Name:    Area Number 2xxxxxxxxxxxxxxxxxxx
		Flags:   0x0 (0x0)
`,
	},
	// Test usage
	{
		cmd: "usage",
		out: `Legend: '.' - full (0xff), '0' - zero (0x00), '#' - mixed
0x00000000: 0..###
Blocks:       6 (100.0%)
Full (0xff):  2 (33.3%)
Empty (0x00): 1 (16.7%)
Mixed:        3 (50.0%)
`,
	},
}

// Table driven testing
func TestFmap(t *testing.T) {
	for _, tt := range tests {
		out, err := testutil.Command(t, tt.cmd, testFlash).CombinedOutput()
		if err != nil {
			t.Error(err)
		}

		// Filter out null characters which may be present in fmap strings.
		out = bytes.ReplaceAll(out, []byte{0}, []byte{})
		if string(out) != tt.out {
			t.Errorf("expected:\n%s\ngot:\n%s", tt.out, string(out))
		}
	}
}

func TestJson(t *testing.T) {
	tmpDir := t.TempDir()

	jsonFile := filepath.Join(tmpDir, "tmp.json")
	if err := testutil.Command(t, "jget", jsonFile, testFlash).Run(); err != nil {
		t.Fatal(err)
	}
	got, err := os.ReadFile(jsonFile)
	if err != nil {
		t.Fatal(err)
	}
	want := `{
	"FMap": {
		"Signature": [
			95,
			95,
			70,
			77,
			65,
			80,
			95,
			95
		],
		"VerMajor": 1,
		"VerMinor": 0,
		"Base": 14627333968688430831,
		"Size": 1144201745,
		"Name": "Fake flash",
		"NAreas": 2,
		"Areas": [
			{
				"Offset": 3735928559,
				"Size": 286331153,
				"Name": "Area Number 1\u0000\u0000\u0000Hello",
				"Flags": 4115
			},
			{
				"Offset": 3405691582,
				"Size": 572662306,
				"Name": "Area Number 2xxxxxxxxxxxxxxxxxxx",
				"Flags": 0
			}
		]
	},
	"Metadata": {
		"Start": 24436
	}
}
`
	if string(got) != want {
		t.Errorf("want:%s; got:%s", string(want), got)
	}
}

func TestMain(m *testing.M) {
	testutil.Run(m, main)
}

```

`cmds/fspinfo/README.md`:

```md
## fspinfo

`fspinfo` is a library and command line to parse and present [FSP](https://github.com/IntelFsp/FSP/blob/master/FSP_License.pdf)
information.

Intel FSP specification 2.0 can be found at
https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec-v2.pdf
.

## Example

Grab an FSP file at https://github.com/IntelFsp/FSP if you don't have one already.

NOTE: currently only the FSP 2.0 specification is supported, make sure to use
the right file (e.g. the ApolloLake one).

```
$ go run github.com/linuxboot/fiano/cmds/fspinfo/ FSP/ApolloLakeFspBinPkg/FspBin/Fsp.fd
Signature                   : FSPH
Header Length               : 72
Reserved1                   : 0x0000
Spec Version                : 2.0
Header Revision             : 3
Image Revision              : 1.4.3.1
Image ID                    : $APLFSP$
Image Size                  : 0x0002a000 172032
Image Base                  : 0x00200000 2097152
Image Attribute             : 0x01 GraphicsDisplaySupported
Component Attribute         : 0x3003 ReleaseBuild|TestRelease|TypeFSP-S (reserved bits are not zeroed)
Cfg Region Offset           : 0x00000124 292
Cfg Region Size             : 0x000003b0 944
Reserved2                   : 0x00000000
TempRAMInit Entry Offset    : 0x00000000 0
Reserved3                   : 0x00000000
NotifyPhase Entry Offset    : 0x00000580 1408
FSPMemoryInit Entry Offset  : 0x00000000 0
TempRAMExit Entry Offset    : 0x00000000 0
FSPSiliconInit Entry Offset : 0x0000058a 1418
```

You can also specify `-j` to obtain JSON output instead.

## Limitations

* Only the FSP 2.0 specification is currently implemented. Previous versions are
  not supported yet.
* The `FSP_INFO_EXTENDED_HEADER` is not implemented yet.

```

`cmds/fspinfo/main.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// fspinfo prints FSP header information.

package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"os"

	"github.com/linuxboot/fiano/pkg/fsp"
	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	flagJSON = flag.Bool("j", false, "Output as JSON")
)

// extractFSPHeader decapsulates an FSP header as described by the FSP specification.
// The FSP files from intel contain various components (e.g. FSP-M, FSP-T, FSP-S),
// each contained in a firmware volume.
// Each FSP component has an FSP_INFO_HEADER in the first FFS file in the first firmware
// volume.
// See https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec-v2.pdf chapter 4.

// TODO extract the remaining firmware volumes too
func extractFirstFSPHeader(b []byte) (*fsp.CommonInfoHeader, error) {
	fv, err := uefi.NewFirmwareVolume(b, 0, false)
	if err != nil {
		return nil, fmt.Errorf("cannot parse Firmware Volume: %v", err)
	}
	if len(fv.Files) < 1 {
		return nil, errors.New("firmware Volume has no files")
	}
	file := fv.Files[0]
	sec, err := uefi.NewSection(file.Buf()[file.DataOffset:], 0)
	if err != nil {
		return nil, fmt.Errorf("cannot parse section: %v", err)
	}
	// the section header size is 4, so skip it to get the data
	hdr, err := fsp.NewInfoHeader(sec.Buf()[4:])
	if err != nil {
		return nil, fmt.Errorf("cannot parse FSP Info Header: %v", err)
	}
	return hdr, nil
}

func main() {
	flag.Parse()
	if flag.Arg(0) == "" {
		log.Fatalf("missing file name")
	}
	data, err := os.ReadFile(flag.Arg(0))
	if err != nil {
		log.Fatalf("cannot read input file: %v", err)
	}
	hdr, err := extractFirstFSPHeader(data)
	if err != nil {
		log.Fatalf("%v", err)
	}

	j, err := json.MarshalIndent(hdr, "", "    ")
	if err != nil {
		log.Fatalf("cannot marshal JSON: %v", err)
	}
	if *flagJSON {
		fmt.Println(string(j))
	} else {
		fmt.Print(hdr.Summary())
	}
}

```

`cmds/fspinfo/main_test.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/fsp"
)

const (
	// From https://github.com/IntelFsp/FSP/blob/master/ApolloLakeFspBinPkg/FspBin/Fsp.fd
	// under the FSP license. See README.md under `test_blobs`.
	FSPTestFile = "test_blobs/ApolloLakeFspBinPkg/Fsp.fd"
)

func TestNewInfoHeaderRealFile(t *testing.T) {
	buf, err := os.ReadFile(FSPTestFile)
	if err != nil {
		t.Errorf("Error opening test file %s: %v", FSPTestFile, err)
	}
	// in the ApolloLake FSP, the FSP header starts at byte 148. This can be
	// extracted by parsing it as uefi.FirmwareVolume, but it's not relevant for
	// this test, so let's go with raw offsets.
	hdr, err := fsp.NewInfoHeader(buf[148 : 148+fsp.HeaderV3Length])
	if err != nil {
		t.Errorf("NewInfoHeader failed to parse FSP file %s: %v", FSPTestFile, err)
	}
	if hdr.Signature != fsp.Signature {
		t.Errorf("Invalid signature %v; want %v", hdr.Signature, fsp.Signature)
	}
	if hdr.HeaderLength != fsp.HeaderV3Length {
		t.Errorf("Invalid header length %d; want %d", hdr.HeaderLength, fsp.HeaderV3Length)
	}
	if hdr.SpecVersion != fsp.SpecVersion(0x20) {
		t.Errorf("Invalid spec version %s; want %s", hdr.SpecVersion, fsp.SpecVersion(0x20))
	}
	if hdr.HeaderRevision != 3 {
		t.Errorf("Invalid header revision %d; want %d", hdr.HeaderRevision, 3)
	}
	if hdr.ImageRevision != fsp.ImageRevision(0x0001000400030001) {
		t.Errorf("Invalid image revision %s; want %s", hdr.ImageRevision, fsp.ImageRevision(0x0001000400030001))
	}
	if !bytes.Equal(hdr.ImageID[:], []byte("$APLFSP$")) {
		t.Errorf("Invalid image ID %s; want %s", hdr.ImageID, "$APLFSP$")
	}
	if hdr.ImageSize != 0x2a000 {
		t.Errorf("Invalid image size %#x; want %#x", hdr.ImageSize, 0x2a000)
	}
	if hdr.ImageBase != 0x200000 {
		t.Errorf("Invalid image base %#x; want %#x", hdr.ImageSize, 0x200000)
	}
	if hdr.ImageAttribute != 0x1 {
		t.Errorf("Invalid image attribute %#x; want %#x", hdr.ImageAttribute, 0x1)
	}
	if hdr.ComponentAttribute != 0x3003 {
		t.Errorf("Invalid component attribute %#x; want %#x", hdr.ComponentAttribute, 0x3003)
	}
	if hdr.CfgRegionOffset != 0x124 {
		t.Errorf("Invalid cfg region offset %#x; want %#x", hdr.CfgRegionOffset, 0x124)
	}
	if hdr.CfgRegionSize != 0x3b0 {
		t.Errorf("Invalid cfg region size %#x; want %#x", hdr.CfgRegionSize, 0x3b0)
	}
	if hdr.TempRAMInitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0x0)
	}
	if hdr.NotifyPhaseEntryOffset != 0x580 {
		t.Errorf("Invalid notify phase entry offset %#x; want %#x", hdr.NotifyPhaseEntryOffset, 0x580)
	}
	if hdr.FSPMemoryInitEntryOffset != 0x0 {
		t.Errorf("Invalid FSP memory init entry offset %#x; want %#x", hdr.FSPMemoryInitEntryOffset, 0x0)
	}
	if hdr.TempRAMInitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0x0)
	}
	if hdr.FSPSiliconInitEntryOffset != 0x58a {
		t.Errorf("Invalid FSP silicon init entry offset %#x; want %#x", hdr.FSPSiliconInitEntryOffset, 0x58a)
	}
}

```

`cmds/fspinfo/test_blobs/README.md`:

```md
## test blobs

This directory contains binary FSP blobs used for testing. They are part of the
[Intel FSP](https://github.com/IntelFsp/FSP) repo, and are licensed under the
[FSP License](https://github.com/IntelFsp/FSP/blob/master/FSP_License.pdf).

A copy of the FSP license is included in this repository, and applies to all the
FSP binaries contained under this directory.

```

`cmds/glzma/glzma.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// glzma compresses and decompresses in the same manner as EDK2's LzmaCompress.
//
// Synopsis:
//
//	glzma -o OUTPUT_FILE (-d|-e) [-f86] INPUT_FILE
//
// Options:
//
//	-d: decode
//	-e: encode
//	-f86: Use the x86 branch/call/jump filter. See `man xz` for more information.
//	-o OUTPUT_FILE: output file
package main

import (
	"flag"
	"os"

	"github.com/linuxboot/fiano/pkg/compression"
	"github.com/linuxboot/fiano/pkg/log"
)

var (
	d   = flag.Bool("d", false, "decode")
	e   = flag.Bool("e", false, "encode")
	f86 = flag.Bool("f86", false, "use x86 extension")
	o   = flag.String("o", "", "output file")
)

func main() {
	flag.Parse()

	if *d == *e {
		log.Fatalf("either decode (-d) or encode (-e) must be set")
	}
	if *o == "" {
		log.Fatalf("output file must be set")
	}
	if flag.NArg() != 1 {
		log.Fatalf("expected one input file")
	}

	var compressor compression.Compressor
	if *f86 {
		compressor = compression.CompressorFromGUID(&compression.LZMAX86GUID)
	} else {
		compressor = compression.CompressorFromGUID(&compression.LZMAGUID)
	}

	var op func([]byte) ([]byte, error)
	if *d {
		op = compressor.Decode
	} else {
		op = compressor.Encode
	}

	in, err := os.ReadFile(flag.Args()[0])
	if err != nil {
		log.Fatalf("%v", err)
	}
	out, err := op(in)
	if err != nil {
		log.Fatalf("%v", err)
	}
	if err := os.WriteFile(*o, out, 0666); err != nil {
		log.Fatalf("%v", err)
	}
}

```

`cmds/guid2english/main.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// guid2english replace GUIDs with their English representation.
//
// Synopsis:
//
//	guid2english [-t TEMPLATE] [FILE]
//
// Options:
//
//	-t TEMPLATE:
//	    A template used to replace GUIDS. The template can refer to the
//	    following variables:
//	        * {{.Guid}}: The GUID being mapped
//	        * {{.Name}}: The English name of the GUID or "UNKNOWN"
//	        * {{.IsKnown}}: Set to true when the English name is not known
//	    The default template is "{{.GUID}} ({{.Name}})".
//
// Description:
//
//	If FILE is not specified, stdin is used.
package main

import (
	"flag"
	"io"
	"os"
	"text/template"

	"github.com/linuxboot/fiano/pkg/guid2english"
	"github.com/linuxboot/fiano/pkg/log"
	"golang.org/x/text/transform"
)

var (
	tmpl = flag.String("t", "{{.GUID}} ({{.Name}})", "template string")
)

func main() {
	flag.Parse()
	r := os.Stdin
	switch flag.NArg() {
	case 0:
	case 1:
		var err error
		r, err = os.Open(flag.Arg(0))
		if err != nil {
			log.Fatalf("Error opening file: %v", err)
		}
		defer r.Close()
	default:
		log.Fatalf("At most 1 positional arguments expected")
	}

	t, err := template.New("guid2english").Parse(*tmpl)
	if err != nil {
		log.Fatalf("Template not valid: %v", err)
	}

	trans := guid2english.New(guid2english.NewTemplateMapper(t))

	_, err = io.Copy(os.Stdout, transform.NewReader(r, trans))
	if err != nil {
		log.Fatalf("Error copying buffer: %v", err)
	}
}

```

`cmds/microcode/microcode.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"

	"github.com/linuxboot/fiano/pkg/intel/microcode"
	flag "github.com/spf13/pflag"
)

func main() {
	flag.Parse()

	a := flag.Args()
	if len(a) != 1 {
		log.Fatal("Usage: microcode <microcode-file>")
	}

	f, err := os.Open(a[0])
	if err != nil {
		log.Fatal(err)
	}
	b := bufio.NewReader(f)

	for {
		_, err = b.Peek(microcode.DefaultTotalSize)
		if err != nil {
			break
		}
		m, err := microcode.ParseIntelMicrocode(b)
		if err != nil {
			log.Fatal(err)
		}
		fmt.Println(m)
	}
}

```

`cmds/utk/utk.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The utk command performs operations on a UEFI firmware image.
//
// Synopsis:
//
//	utk BIOS OPERATIONS...
//
// Examples:
//
//	# Dump everything to JSON:
//	utk winterfell.rom json
//
//	# Dump a single file to JSON (using regex):
//	utk winterfell.rom find Shell
//
//	# Dump GUIDs and sizes to a compact table:
//	utk winterfell.rom table
//
//	# Extract everything into a directory:
//	utk winterfell.rom extract winterfell/
//
//	# Re-assemble the directory into an image:
//	utk winterfell/ save winterfell2.rom
//
//	# Remove two files by their GUID and replace shell with Linux:
//	utk winterfell.rom \
//	  remove 12345678-9abc-def0-1234-567890abcdef \
//	  remove 23830293-3029-3823-0922-328328330939 \
//	  replace_pe32 Shell linux.efi \
//	  save winterfell2.rom
//
// Operations:
//
//	`json`: Dump the entire parsed image (excluding binary data) as JSON to
//	        stdout.
//	`table`: Dump GUIDs and sizes to a compact table. This is only for human
//	         consumption and the format may change without notice.
//	`find (GUID|NAME)`: Dump the JSON of one or more files. The file is
//	                    found by a regex match to its GUID or name in the UI
//	                    section.
//	`remove (GUID|NAME)`: Remove the first file which matches the given GUID
//	                      or NAME. The same matching rules and exit status
//	                      are used as `find`.
//	`replace (GUID|NAME) FILE`: Replace the first file which matches the
//	                            given GUID or NAME with the contents of
//	                            FILE. The same matching rules and exit
//	                            status are used as `find`.
//	`save FILE`: Save the current state of the image to the give file.
//	             Remember that operations are applied left-to-right, so only
//	             the operations to the left are included in the new image.
//	`extract DIR`: Extract the BIOS to the given directory. Remember that
//	               operations are applied left-to-right, so only the
//	               operations to the left are included in the new image.
package main

import (
	"flag"
	"fmt"
	"strconv"

	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
	"github.com/linuxboot/fiano/pkg/utk"
	"github.com/linuxboot/fiano/pkg/visitors"
)

type config struct {
	ErasePolarity *byte
}

func parseArguments() (config, []string, error) {
	flag.Usage = func() {
		fmt.Fprintf(flag.CommandLine.Output(), "Usage: utk [flags] <file name> [0 or more operations]\n")
		flag.PrintDefaults()
		fmt.Fprintf(flag.CommandLine.Output(), "\nOperations:\n%s", visitors.ListCLI())
	}
	erasePolarityFlag := flag.String("erase-polarity", "", "set erase polarity; possible values: '', '0x00', '0xFF'")
	flag.Parse()
	if len(flag.Args()) == 0 || flag.Args()[0] == "help" {
		flag.Usage()
	}

	var cfg config

	if *erasePolarityFlag != "" {
		erasePolarity, err := strconv.ParseUint(*erasePolarityFlag, 0, 8)
		if err != nil {
			return config{}, nil, fmt.Errorf("unable to parse erase polarity '%s': %w", *erasePolarityFlag, err)
		}
		cfg.ErasePolarity = &[]uint8{uint8(erasePolarity)}[0]
	}

	return cfg, flag.Args(), nil
}

func main() {
	cfg, args, err := parseArguments()
	if err != nil {
		panic(err)
	}

	if cfg.ErasePolarity != nil {
		if err := uefi.SetErasePolarity(*cfg.ErasePolarity); err != nil {
			panic(fmt.Errorf("unable to set erase polarity 0x%X: %w", *cfg.ErasePolarity, err))
		}
	}

	if err := utk.Run(args...); err != nil {
		log.Fatalf("%v", err)
	}
}

```

`data/PurleySiliconBinPkg/MeFirmware/IgnitionFirmware/License.txt`:

```txt
Copyright (c) 2019 Intel Corporation.
All rights reserved.

Redistribution.

Redistribution and use in binary form, without modification, are permitted,
provided that the following conditions are met:

1.  Redistributions must reproduce the above copyright notice and the
    following disclaimer in the documentation and/or other materials provided
    with the distribution.

2.  Neither the name of Intel Corporation nor the names of its suppliers may
    be used to endorse or promote products derived from this software without
    specific prior written permission.

3.  No reverse engineering, decompilation, or disassembly of this software
    is permitted.


"Binary form" includes any format that is commonly used for electronic
conveyance that is a reversible, bit-exact translation of binary
representation to ASCII or ISO text, for example "uuencode".

DISCLAIMER.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

```

`data/PurleySiliconBinPkg/MeFirmware/IgnitionFirmware/Other_Licenses/libgcc_License.txt`:

```txt
GCC RUNTIME LIBRARY EXCEPTION

Version 3.1, 31 March 2009

Copyright (C) 2009 Free Software Foundation, Inc. <http://fsf.org/>

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

This GCC Runtime Library Exception ("Exception") is an additional
permission under section 7 of the GNU General Public License, version
3 ("GPLv3"). It applies to a given file (the "Runtime Library") that
bears a notice placed by the copyright holder of the file stating that
the file is governed by GPLv3 along with this Exception.

When you use GCC to compile a program, GCC may combine portions of
certain GCC header files and runtime libraries with the compiled
program. The purpose of this Exception is to allow compilation of
non-GPL (including proprietary) programs to use, in this way, the
header files and runtime libraries covered by this Exception.

0. Definitions.

A file is an "Independent Module" if it either requires the Runtime
Library for execution after a Compilation Process, or makes use of an
interface provided by the Runtime Library, but is not otherwise based
on the Runtime Library.

"GCC" means a version of the GNU Compiler Collection, with or without
modifications, governed by version 3 (or a specified later version) of
the GNU General Public License (GPL) with the option of using any
subsequent versions published by the FSF.

"GPL-compatible Software" is software whose conditions of propagation,
modification and use would permit combination with GCC in accord with
the license of GCC.

"Target Code" refers to output from any compiler for a real or virtual
target processor architecture, in executable form or suitable for
input to an assembler, loader, linker and/or execution
phase. Notwithstanding that, Target Code does not include data in any
format that is used as a compiler intermediate representation, or used
for producing a compiler intermediate representation.

The "Compilation Process" transforms code entirely represented in
non-intermediate languages designed for human-written code, and/or in
Java Virtual Machine byte code, into Target Code. Thus, for example,
use of source code generators and preprocessors need not be considered
part of the Compilation Process, since the Compilation Process can be
understood as starting with the output of the generators or
preprocessors.

A Compilation Process is "Eligible" if it is done using GCC, alone or
with other GPL-compatible software, or if it is done without using any
work based on GCC. For example, using non-GPL-compatible Software to
optimize any GCC intermediate representations would not qualify as an
Eligible Compilation Process.

1. Grant of Additional Permission.

You have permission to propagate a work of Target Code formed by
combining the Runtime Library with Independent Modules, even if such
propagation would otherwise violate the terms of GPLv3, provided that
all Target Code was generated by Eligible Compilation Processes. You
may then convey such a combination under terms of your choice,
consistent with the licensing of the Independent Modules.

2. No Weakening of GCC Copyleft.

The availability of this Exception does not imply any general
presumption that third-party software is unaffected by the copyleft
requirements of the license of GCC.


```

`data/PurleySiliconBinPkg/MeFirmware/IgnitionFirmware/README.md`:

```md
# Ignition ME firmware
Copyright &copy; 2019, Intel Corporation. All rights reserved.

## Overview
Ignition Firmware is a variant of ME firmware that is intended to provide lightweight chipset initialization. It does not contain all the features of the Intel&reg; Server Platform Services (SPS) ME firmware. Ignition Firmware is consequently much smaller than Intel&reg; SPS Firmware (~0.5 MB vs. ~3 MB). Both Intel&reg; SPS Firmware and Ignition Firmware are specifically designed for server platforms with Intel&reg; Xeon&reg; Processors and are different than the ME firmware found on client platforms. These binaries cannot be used on 1 socket High End Desktop (HEDT) platforms like Glacier Falls or Basin Falls. Glacier Falls and Basin Falls platforms use client ME firmware images.

## Package Contents

Ignition ME firmware is provided in the file:
 - MeRegion.bin - ME Firmware Image

## License Information
This release package contains the following license files:
 - License.txt - The primary license is provided in the main directory.
 - Other_Licenses - Third-party licenses are provided in the Other_Licenses directory.

```

`data/PurleySiliconBinPkg/MeFirmware/README.md`:

```md
# Cascade Lake Management Engine Firmware
These ME binaries are intended to be used with 2nd Generation Intel&reg; Xeon&reg; Scalable Processors and chipsets formerly known as Cascade Lake.

## Ignition Firmware Overview
Ignition Firmware is a variant of ME firmware that is intended to provide lightweight chipset initialization. It does not contain all the features of the Intel&reg; Server Platform Services (SPS) ME firmware. Ignition Firmware is consequently much smaller than Intel&reg; SPS Firmware (~0.5 MB vs. ~3 MB). Both Intel&reg; SPS Firmware and Ignition Firmware are specifically designed for server platforms with Intel&reg; Xeon&reg; Processors and are different than the ME firmware found on client platforms. These binaries cannot be used on 1 socket High End Desktop (HEDT) platforms like Glacier Falls or Basin Falls. Glacier Falls and Basin Falls platforms use client ME firmware images.

```

`fiano-logo.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   id="svg2"
   height="199.0722"
   width="203.4866"
   viewBox="-4.431797 -1 212.90924 204.96413"
   preserveAspectRatio="xMidYMid meet"
   version="1.1">
  <metadata
     id="metadata172">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <defs
     id="defs4">
    <path
       id="a2oeromWb3"
       d="m 190.92,97.84 c 8.48,0 12.72,3.8 12.72,11.39 0,0 0,0 0,0 0,7.59 -4.24,11.39 -12.72,11.39 -5.69,0 -8.85,0 -9.49,0 -8.47,0 -12.71,-3.8 -12.71,-11.39 0,0 0,0 0,0 0,-7.59 4.24,-11.39 12.71,-11.39 5.7,0 8.86,0 9.49,0 z" />
    <path
       id="i2TwJxvjU5"
       d="m 91.9,28.04 c 0,0 0.49,14.1 1.95,17.97 1.47,3.88 7.81,3.05 5.86,5.81 -1.95,2.77 -10.74,7.74 -17.58,10.23 -6.84,2.49 -5.93,5.89 -4.96,9.49 0.98,3.59 11.04,7.34 17.39,9 6.35,1.65 18.21,3.61 18.21,3.61 0,0 1.56,2.19 -4.52,2.79 -17.04,1.66 -28.37,8.29 -31,11.33 -3.2,3.7 -1.02,7.35 0.97,9.96 2.62,3.42 27.05,10.22 31.32,10.76 3.39,0.42 -0.17,2.84 -8.96,5.05 -8.79,2.21 -25.77,7.42 -26.26,11.84 -0.49,4.42 8.8,9.34 14.16,10.78 20.61,5.55 23.68,6.34 19.4,9.4 -3.9,2.79 -9.52,5.7 -16.03,7.9 -5.17,1.75 -14.4,6.85 -16,9.62 -0.63,1.09 -0.06,1.82 2.43,1.82 9.37,0.02 38.94,-9.32 45.8,-12.58 3.61,-1.72 8.43,-5.6 8.67,-10.3 0.23,-4.7 -9.43,-9.45 -20.82,-12.7 -10.42,-2.97 -21.48,-1.51 -4.71,-4.44 15.02,-2.63 23.46,-9.37 25.7,-14.16 1.09,-2.33 -1.7,-8.57 -17.58,-12.72 -15.67,-4.09 -24.55,-6.51 -16.12,-6.35 8.92,0.16 26.33,-6.07 29.79,-10.24 3.12,-3.76 4.07,-7.21 0.98,-11.89 -2.01,-3.04 -24.78,-9.32 -27.63,-9.32 -2.12,0.15 -12.94,-1.49 1.75,-4.5 12.66,-2.59 14.65,-12.72 14.65,-14.93 -1.68,-3.94 -3.97,-3.45 -7.82,-10.51 -0.01,-0.9 -0.07,-5.4 -0.17,-13.51 -10.07,0.42 -16.36,0.69 -18.87,0.79 z" />
    <path
       id="j76Hq98yQ"
       d="m 80.41,6 40.75,0 c 0,15.41 0,23.97 0,25.68 -13.31,4.59 -25.8,7.87 -40.75,0 0,-3.43 0,-11.99 0,-25.68 z" />
    <path
       id="bHcpXnpeU"
       d="m 99.98,0 c 20.94,-0.06 38,3.24 54.91,3.24 16.91,0 26.59,-3.52 37.86,-2.53 9.6,0.83 9.85,3.88 10,6.94 0.15,3 0,7.93 -0.8,10.17 -0.81,2.23 -3.02,4.24 -11.34,4.61 -8.32,0.38 -24.51,-1.98 -35.56,-1.89 -11.41,0.09 -44.9,2.23 -54.56,2.23 -9.66,0 -42.94,-2.5 -54.75,-2.5 -11.81,0 -25.5,2.13 -32.21,2.13 C 6.82,22.4 0.38,20.08 0.38,17.35 0.38,14.62 -0.56,6.22 0.51,4.74 1.59,3.25 3.29,0.53 11.05,0.34 17.22,0.18 29.23,2.53 45.88,2.57 69.8,2.63 78.91,0.06 99.98,0 Z" />
    <path
       id="d1CcgyhiWZ"
       d="m 158.47,47.11 c 14.17,0 21.25,7.08 21.25,21.25 0,67.87 0,105.57 0,113.11 0,14.17 -7.08,21.26 -21.25,21.26 -67.87,0 -105.57,0 -113.11,0 -14.17,0 -21.26,-7.09 -21.26,-21.26 0,-67.86 0,-105.57 0,-113.11 0,-14.17 7.09,-21.25 21.26,-21.25 67.86,0 105.57,0 113.11,0 z" />
    <path
       id="c1tOB3iImB"
       d="m 99.31,49.61 c -1.13,2.14 -4.16,5.37 -8.14,7.29 -3.97,1.92 -4.21,3.35 -3.64,6.13 0.57,2.78 7.67,5.77 11.36,7.05 3.69,1.29 9.66,4.06 9.66,4.06 0,0 3.97,1.07 0.57,2.36 -3.41,1.28 -18.18,6.41 -20.45,8.76 -2.27,2.35 -1.14,6.42 0.57,7.7 1.7,1.28 18.46,6.84 20.16,8.12 1.7,1.29 -0.57,2.78 -5.68,4.49 -5.11,1.71 -16.47,5.35 -16.76,8.77 -0.28,3.42 5.12,7.22 8.24,8.34 11.99,4.29 14.87,4.9 12.38,7.26 -2.27,2.16 -6.63,4.41 -10.42,6.12 -3,1.35 -8.38,5.29 -9.3,7.43 -0.37,0.85 -0.04,1.41 1.41,1.41 5.45,0.02 22.65,-7.21 26.63,-9.73 2.1,-1.32 4.91,-4.33 5.05,-7.96 0.13,-3.63 -6.31,-6.88 -12.97,-9.23 -5.21,-1.84 -11.43,-2.12 -2.27,-4.71 8.67,-2.44 14.03,-6.56 15.33,-10.26 0.64,-1.81 -0.99,-6.63 -10.22,-9.84 -9.11,-3.16 -14.2,-3.84 -9.37,-4.91 4.83,-1.07 15.05,-5.56 17.32,-7.91 2.27,-2.36 3.41,-6.85 0.57,-9.2 -2.84,-2.35 -15.05,-7.7 -15.05,-7.7 0.03,-0.03 -5.07,-0.57 0,-2.99 6.18,-2.95 11.23,-9.07 11.29,-10.76 -3.25,-0.02 -13.01,-0.07 -16.27,-0.09 z" />
    <path
       id="cN0GG3LLw"
       d="m 46.59,162.31 15.31,0 0,2.76 -10.8,0 0,3.86 9.32,0 0,2.76 -9.32,0 0,6.93 -4.51,0 0,-16.31 z" />
    <path
       id="c15gwn3kAE"
       d="m 70.85,162.31 4.5,0 0,16.31 -4.5,0 0,-16.31 z" />
    <path
       id="jfNNU3PpZ"
       d="m 100.22,178.62 -1.95,-3.7 -8.92,0 -1.85,3.7 -4.78,0 8.7,-16.31 4.77,0 8.94,16.31 -4.91,0 z m -3.39,-6.45 -3.08,-6.05 -3.02,6.05 6.1,0 z" />
    <path
       id="b1NSyYRt2j"
       d="m 112.93,162.31 4.39,0 9.14,10.89 0,-10.89 4.19,0 0,16.31 -4.53,0 -9,-10.63 0,10.63 -4.19,0 0,-16.31 z" />
  </defs>
  <g
     transform="translate(156.02753,-2.1332886)"
     id="g4351-8">
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-0"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="67.378471"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8-5"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="99.632629"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8-4-6"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="131.88678"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8-0-6"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="164.14095"
       rx="10"
       ry="10" />
  </g>
  <g
     transform="translate(-0.31777287,-2.1332886)"
     id="g4351">
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="67.378471"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="99.632629"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8-4"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="131.88678"
       rx="10"
       ry="10" />
    <rect
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate"
       id="rect4313-8-0"
       width="56.563953"
       height="18.113173"
       x="-4.1140242"
       y="164.14095"
       rx="10"
       ry="10" />
  </g>
  <g
     transform="translate(-0.31777287,-2.1332886)"
     id="g24">
    <g
       id="g34">
      <g
         id="g38">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:10;stroke-opacity:0"
           id="use40"
           xlink:href="#a2oeromWb3" />
      </g>
    </g>
    <g
       id="g90">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#000000;fill-opacity:1"
         id="use92"
         xlink:href="#i2TwJxvjU5" />
      <g
         id="g94">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use96"
           xlink:href="#i2TwJxvjU5" />
      </g>
    </g>
    <g
       transform="translate(1.125,0)"
       id="g98">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#000000;fill-opacity:1"
         id="use100"
         xlink:href="#j76Hq98yQ" />
      <g
         id="g102">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:10;stroke-opacity:0"
           id="use104"
           xlink:href="#j76Hq98yQ" />
      </g>
    </g>
    <g
       transform="matrix(0.78118746,0,0,1.0050154,22.695662,-0.05709854)"
       id="g106">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#000000;fill-opacity:1"
         id="use108"
         xlink:href="#bHcpXnpeU" />
      <g
         id="g110">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use112"
           xlink:href="#bHcpXnpeU" />
      </g>
    </g>
    <g
       id="g114">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#000000;fill-opacity:1"
         id="use116"
         xlink:href="#d1CcgyhiWZ" />
      <g
         id="g118">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:10;stroke-opacity:0"
           id="use120"
           xlink:href="#d1CcgyhiWZ" />
      </g>
    </g>
    <g
       transform="translate(-0.73985005,0.46240625)"
       id="g122">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#ffffff;fill-opacity:1"
         id="use124"
         xlink:href="#c1tOB3iImB" />
      <g
         id="g126">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use128"
           xlink:href="#c1tOB3iImB" />
      </g>
    </g>
    <g
       id="g130">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#ffffff;fill-opacity:1"
         id="use132"
         xlink:href="#cN0GG3LLw" />
      <g
         id="g134">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use136"
           xlink:href="#cN0GG3LLw" />
      </g>
    </g>
    <g
       id="g138">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#ffffff;fill-opacity:1"
         id="use140"
         xlink:href="#c15gwn3kAE" />
      <g
         id="g142">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use144"
           xlink:href="#c15gwn3kAE" />
      </g>
    </g>
    <g
       id="g146">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#ffffff;fill-opacity:1"
         id="use148"
         xlink:href="#jfNNU3PpZ" />
      <g
         id="g150">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use152"
           xlink:href="#jfNNU3PpZ" />
      </g>
    </g>
    <g
       id="g154">
      <use
         height="100%"
         width="100%"
         y="0"
         x="0"
         style="opacity:1;fill:#ffffff;fill-opacity:1"
         id="use156"
         xlink:href="#b1NSyYRt2j" />
      <g
         id="g158">
        <use
           height="100%"
           width="100%"
           y="0"
           x="0"
           style="opacity:1;fill-opacity:0;stroke:#000000;stroke-width:1;stroke-opacity:0"
           id="use160"
           xlink:href="#b1NSyYRt2j" />
      </g>
    </g>
    <ellipse
       ry="8.4848871"
       rx="11.01891"
       cy="170.49803"
       cx="150.68306"
       id="path4418"
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />
    <ellipse
       ry="5.6729398"
       rx="6.2778354"
       cy="170.49803"
       cx="150.68306"
       id="path4420"
       style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:10;stroke-linecap:square;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" />
  </g>
</svg>

```

`go.mod`:

```mod
module github.com/linuxboot/fiano

go 1.21

require (
	github.com/dustin/go-humanize v1.0.0
	github.com/fatih/camelcase v1.0.0
	github.com/hashicorp/go-multierror v1.1.1
	github.com/jedib0t/go-pretty/v6 v6.4.6
	github.com/jessevdk/go-flags v1.5.0
	github.com/klauspost/compress v1.13.6
	github.com/pierrec/lz4 v2.6.1+incompatible
	github.com/spf13/pflag v1.0.5
	github.com/stretchr/testify v1.8.1
	github.com/tjfoc/gmsm v1.4.1
	github.com/u-root/u-root v0.9.0
	github.com/ulikunitz/xz v0.5.11
	github.com/xaionaro-go/bytesextra v0.0.0-20220103144954-846e454ddea9
	github.com/xaionaro-go/gosrc v0.0.0-20201124181305-3fdf8476a735
	golang.org/x/text v0.6.0
)

require (
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/fatih/structtag v1.2.0 // indirect
	github.com/frankban/quicktest v1.14.5 // indirect
	github.com/hashicorp/errwrap v1.0.0 // indirect
	github.com/mattn/go-runewidth v0.0.13 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	github.com/xaionaro-go/unsafetools v0.0.0-20210722164218-75ba48cf7b3c // indirect
	golang.org/x/sys v0.4.0 // indirect
	gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

```

`go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=
github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/fatih/camelcase v1.0.0 h1:hxNvNX/xYBp0ovncs8WyWZrOrpBNub/JfaMvbURyft8=
github.com/fatih/camelcase v1.0.0/go.mod h1:yN2Sb0lFhZJUdVvtELVWefmrXpuZESvPmqwoZc+/fpc=
github.com/fatih/structtag v1.2.0 h1:/OdNE99OxoI/PqaW/SuSK9uxxT3f/tcSZgon/ssNSx4=
github.com/fatih/structtag v1.2.0/go.mod h1:mBJUNpUnHmRKrKlQQlmCrh5PuhftFbNv8Ys4/aAZl94=
github.com/frankban/quicktest v1.14.5 h1:dfYrrRyLtiqT9GyKXgdh+k4inNeTvmGbuSgZ3lx3GhA=
github.com/frankban/quicktest v1.14.5/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/hashicorp/errwrap v1.0.0 h1:hLrqtEDnRye3+sgx6z4qVLNuviH3MR5aQ0ykNJa/UYA=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=
github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=
github.com/jedib0t/go-pretty/v6 v6.4.6 h1:v6aG9h6Uby3IusSSEjHaZNXpHFhzqMmjXcPq1Rjl9Jw=
github.com/jedib0t/go-pretty/v6 v6.4.6/go.mod h1:Ndk3ase2CkQbXLLNf5QDHoYb6J9WtVfmHZu9n8rk2xs=
github.com/jessevdk/go-flags v1.5.0 h1:1jKYvbxEjfUl0fmqTCOfonvskHHXMjBySTLW4y9LFvc=
github.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=
github.com/klauspost/compress v1.13.6 h1:P76CopJELS0TiO2mebmnzgWaajssP/EszplttgQxcgc=
github.com/klauspost/compress v1.13.6/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=
github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/mattn/go-runewidth v0.0.13 h1:lTGmDsbAYt5DmK6OnoV7EuIF1wEIFAcxld6ypU4OSgU=
github.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/pierrec/lz4 v2.6.1+incompatible h1:9UY3+iC23yxF0UfGaYrGplQ+79Rg+h/q9FV9ix19jjM=
github.com/pierrec/lz4 v2.6.1+incompatible/go.mod h1:pdkljMzZIN41W+lC3N2tnIh5sFi+IEE17M5jbnwPHcY=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pkg/profile v1.6.0/go.mod h1:qBsxPvzyUincmltOk6iyRVxHYg4adc0OFOv72ZdLa18=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.4/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/tjfoc/gmsm v1.4.1 h1:aMe1GlZb+0bLjn+cKTPEvvn9oUEBlJitaZiiBwsbgho=
github.com/tjfoc/gmsm v1.4.1/go.mod h1:j4INPkHWMrhJb38G+J6W4Tw0AbuN8Thu3PbdVYhVcTE=
github.com/u-root/u-root v0.9.0 h1:1dpUzrE0FyKrNEjxpKFOkyveuV1f3T0Ko5CQg4gTkCg=
github.com/u-root/u-root v0.9.0/go.mod h1:ewc9w6JF1ayZCVC9Y5wsrUiCBw3nMmPC3QItvrEwmew=
github.com/ulikunitz/xz v0.5.11 h1:kpFauv27b6ynzBNT/Xy+1k+fK4WswhN/6PN5WhFAGw8=
github.com/ulikunitz/xz v0.5.11/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=
github.com/xaionaro-go/bytesextra v0.0.0-20220103144954-846e454ddea9 h1:LZsotURuIwV1yjhoaTpbdZHf0/7QtWtvXH8VZ4zs/ug=
github.com/xaionaro-go/bytesextra v0.0.0-20220103144954-846e454ddea9/go.mod h1:op5hoGu7YbHB+PlxrR0jAhl5OaCpYCEqtdCfusfZCYk=
github.com/xaionaro-go/gosrc v0.0.0-20201124181305-3fdf8476a735 h1:I5vlWq623SQl/E48ulUZP2YN+vlLMhzyETuOuTNtZhI=
github.com/xaionaro-go/gosrc v0.0.0-20201124181305-3fdf8476a735/go.mod h1:KWPOUqeg7VZ8gE4MQJJmG+YgmNf2yAkBiDI++R48tFg=
github.com/xaionaro-go/unsafetools v0.0.0-20210722164218-75ba48cf7b3c h1:WeiZrQbFImtlpYCHdxWpjm033Zm0n1ihx3bD/9b6rYI=
github.com/xaionaro-go/unsafetools v0.0.0-20210722164218-75ba48cf7b3c/go.mod h1:fnHPnf0CsRZNVxlSs0ZdUiYW49mLF5QFycfmoT+LuO4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20201012173705-84dcc777aaee/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20201010224723-4f7140c49acb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.4.0 h1:Zr2JFtRQNX3BCZ8YtxRE9hNJYC8J6I1MVbMg6owUp18=
golang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.6.0 h1:3XmdazWV+ubf7QgHSTWeykHOci5oeekaGJBLkrkaw4k=
golang.org/x/text v0.6.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=

```

`integration/files.go`:

```go
// Copyright 2024 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utk_test

import _ "embed"

//go:embed roms/ovmfSECFV.fv
var OVMFSecFV []byte

```

`integration/roms/OVMF.json`:

```json
{
	"Elements": [
		{
			"Type": "*uefi.FirmwareVolume",
			"Value": {
				"FileSystemGUID": {
					"GUID": "FFF12B8D-7696-4C8B-A985-2747075B4F50"
				},
				"Length": 540672,
				"Signature": 1213613663,
				"Attributes": 327423,
				"HeaderLen": 72,
				"Checksum": 47279,
				"ExtHeaderOffset": 0,
				"Revision": 2,
				"Blocks": [
					{
						"Count": 132,
						"Size": 4096
					}
				],
				"FVName": {
					"GUID": "00000000-0000-0000-0000-000000000000"
				},
				"ExtHeaderSize": 0,
				"DataOffset": 72,
				"FVOffset": 0,
				"ExtractPath": "",
				"Resizable": false
			}
		},
		{
			"Type": "*uefi.FirmwareVolume",
			"Value": {
				"FileSystemGUID": {
					"GUID": "8C8CE578-8A3D-4F1C-9935-896185C32DD3"
				},
				"Length": 3440640,
				"Signature": 1213613663,
				"Attributes": 327423,
				"HeaderLen": 72,
				"Checksum": 25331,
				"ExtHeaderOffset": 96,
				"Revision": 2,
				"Blocks": [
					{
						"Count": 840,
						"Size": 4096
					}
				],
				"FVName": {
					"GUID": "48DB5E17-707C-472D-91CD-1613E7EF51B0"
				},
				"ExtHeaderSize": 20,
				"Files": [
					{
						"Header": {
							"GUID": {
								"GUID": "9E21FD93-9C72-4C15-8C4B-E77F1DB2D792"
							},
							"Type": 11,
							"Attributes": 0,
							"Size": 1201831,
							"State": 248
						},
						"Type": "EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE",
						"Sections": [
							{
								"Header": {
									"Type": 2
								},
								"Type": "EFI_SECTION_GUID_DEFINED",
								"ExtractPath": "",
								"TypeSpecific": {
									"Type": 2,
									"Header": {
										"GUID": {
											"GUID": "EE4E5898-3914-4259-9D6E-DC7BD79403CF"
										},
										"DataOffset": 24,
										"Attributes": 1,
										"Compression": "LZMA"
									}
								},
								"Encapsulated": [
									{
										"Type": "*uefi.Section",
										"Value": {
											"Header": {
												"Type": 25
											},
											"Type": "EFI_SECTION_RAW",
											"ExtractPath": ""
										}
									},
									{
										"Type": "*uefi.Section",
										"Value": {
											"Header": {
												"Type": 23
											},
											"Type": "EFI_SECTION_FIRMWARE_VOLUME_IMAGE",
											"ExtractPath": "",
											"Encapsulated": [
												{
													"Type": "*uefi.FirmwareVolume",
													"Value": {
														"FileSystemGUID": {
															"GUID": "8C8CE578-8A3D-4F1C-9935-896185C32DD3"
														},
														"Length": 917504,
														"Signature": 1213613663,
														"Attributes": 524031,
														"HeaderLen": 72,
														"Checksum": 63055,
														"ExtHeaderOffset": 96,
														"Revision": 2,
														"Blocks": [
															{
																"Count": 14,
																"Size": 65536
															}
														],
														"FVName": {
															"GUID": "6938079B-B503-4E3D-9D24-B28337A25806"
														},
														"ExtHeaderSize": 20,
														"Files": [
															{
																"Header": {
																	"GUID": {
																		"GUID": "1B45CC0A-156A-428A-AF62-49864DA0E6E6"
																	},
																	"Type": 2,
																	"Attributes": 0,
																	"Size": 44,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FREEFORM",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 64,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "52C05B14-0B98-496C-BC3B-04B50211D680"
																	},
																	"Type": 4,
																	"Attributes": 16,
																	"Size": 50426,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEI_CORE",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PeiCore"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9B3ADA4F-AE56-4C24-8DEA-F03B7558AE50"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 20282,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 64,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A3610442-E69F-4DF3-82CA-2360C4031A23"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 8478,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 96,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9D225237-FA01-464C-A949-BAABC02D31D0"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 8662,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 40,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "222C386D-5ABC-4FB4-B124-FBB82488ACF4"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 35202,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 120,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "86D70125-BAA3-4296-A62F-602BEBBB9081"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 19834,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "89E549B0-7CFE-449D-9BA3-10D8B2312D71"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 17734,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
																	},
																	"Type": 240,
																	"Attributes": 0,
																	"Size": 56,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FFS_PAD",
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "EDADEB9D-DDBA-48BD-9D22-C1C169C8C5C6"
																	},
																	"Type": 6,
																	"Attributes": 16,
																	"Size": 34302,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_PEIM",
																"ExtractPath": "",
																"DataOffset": 24
															}
														],
														"DataOffset": 120,
														"FVOffset": 0,
														"ExtractPath": "",
														"Resizable": true
													}
												}
											]
										}
									},
									{
										"Type": "*uefi.Section",
										"Value": {
											"Header": {
												"Type": 25
											},
											"Type": "EFI_SECTION_RAW",
											"ExtractPath": ""
										}
									},
									{
										"Type": "*uefi.Section",
										"Value": {
											"Header": {
												"Type": 23
											},
											"Type": "EFI_SECTION_FIRMWARE_VOLUME_IMAGE",
											"ExtractPath": "",
											"Encapsulated": [
												{
													"Type": "*uefi.FirmwareVolume",
													"Value": {
														"FileSystemGUID": {
															"GUID": "8C8CE578-8A3D-4F1C-9935-896185C32DD3"
														},
														"Length": 10485760,
														"Signature": 1213613663,
														"Attributes": 327423,
														"HeaderLen": 72,
														"Checksum": 62766,
														"ExtHeaderOffset": 96,
														"Revision": 2,
														"Blocks": [
															{
																"Count": 160,
																"Size": 65536
															}
														],
														"FVName": {
															"GUID": "7CB8BDC9-F8EB-4F34-AAEA-3EE4AF6516A1"
														},
														"ExtHeaderSize": 20,
														"Files": [
															{
																"Header": {
																	"GUID": {
																		"GUID": "FC510EE7-FFDC-11D4-BD41-0080C73C8881"
																	},
																	"Type": 2,
																	"Attributes": 0,
																	"Size": 92,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FREEFORM",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "D6A2CB7F-6A18-4E2F-B43B-9920A733700A"
																	},
																	"Type": 5,
																	"Attributes": 0,
																	"Size": 165950,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DXE_CORE",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DxeCore"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "D93CE3D8-A7EB-4730-8C8E-CC466A9ECC3C"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24730,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ReportStatusCodeRouterRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "6C2004EF-4E0E-4BE4-B14C-340EB4AA5891"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24738,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "86212936-0E76-41C8-A03A-2AF2FC1C39E2"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "StatusCodeHandlerRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "80CF7257-87AB-47F9-A3FE-D50B76D89541"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24754,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PcdDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "4.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "B601F8C4-43B7-4784-95B1-F4226CB40CEE"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24686,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "RuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F80697E9-7FD6-4665-8646-88E33EF71DFC"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 11766,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SecurityStubDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "13AC6DD0-73D0-11D4-B06B-00AA00BD6DE7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 21526,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "EbcDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "79CA4208-BBA1-4A9A-8456-E1E66A81484E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 7902,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Legacy8259"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A19B1FE7-C1BC-49F8-875F-54A5D542443F"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8858,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "CpuIo2Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "1A1E4886-9517-440E-9FDE-3BE44CEE2136"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 62758,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "CpuDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F2765DEC-6B41-11D5-8E71-00902707B35E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8118,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "26BACCB1-6F42-11D4-BCE7-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "38321DBA-4FE0-4E17-8AEC-413055EAEDC1"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Timer"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F6697AC4-A776-4EE1-B643-1FEFF2B615BB"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8838,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IncompatiblePciDeviceSupportDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "11A6EDF6-A9BE-426D-A6CC-B22FE51D9224"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 13306,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PciHotPlugInitDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "128FB770-5E79-4176-9E51-9BB268A17DD1"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 39482,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "AD61F191-AE5F-4C0E-B9FA-E869D288C64F"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "26BACCB2-6F42-11D4-BCE7-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "26BACCB1-6F42-11D4-BCE7-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PciHostBridgeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "93B80004-9FB3-11D4-9A3A-0090273FC14D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 65474,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PciBusDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "4B28E4C7-FF36-4E10-93CF-A82159E777C5"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 28802,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ResetSystemRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "C8339973-A563-4561-B858-D8476F9DEFC4"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8410,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Metronome"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "378D7B65-8DA9-4773-B6E4-A47826A833E1"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 28806,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "1E5668E2-8481-11D4-BCF1-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "6441F818-6362-4E44-B570-7DBA31DD2453"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PcRtc"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "33CB97AF-6C33-4C42-986B-07581FA366D4"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 11866,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "BlockMmioToBlockIoDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "83DD3B39-7CAF-4FAC-A542-E050B767E3A7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 13078,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioPciDeviceDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "0170F60C-1D40-4651-956D-F0BD9879D527"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 14146,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Virtio10"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "11D92DFB-3CA9-4F93-BA2E-4780ED3E03B5"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 14602,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioBlkDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FAB5D4F4-83C0-4AAF-8480-442D11DF6CEA"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 15818,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioScsiDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "58E26F0D-CBAC-4BBA-B70F-18221415665A"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 13066,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioRngDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "CF569F50-DE44-4F54-B4D7-F4AE25CDA599"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 10502,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "XenIoPciDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "565EC8BA-A484-11E3-802B-B8AC6F7D65E6"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 38594,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "XenBusDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "8C2487EA-9AF3-11E3-B966-B8AC6F7D65E6"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 20486,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "XenPvBlkDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F099D67F-71AE-4C36-B2A3-DCEB0EB2B7D8"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8454,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "26BACCB3-6F42-11D4-BCE7-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "WatchdogTimer"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "AD608272-D07F-4964-801E-7BD3B7888652"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 20642,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "1E5668E2-8481-11D4-BCF1-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "6441F818-6362-4E44-B570-7DBA31DD2453"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "MonotonicCounterRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "42857F0A-13F2-4B21-8A23-53D3F714B840"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24718,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "6441F818-6362-4E44-B570-7DBA31DD2453"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "CapsuleRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "51CCF399-4FDF-4E55-A45B-E123F84D456A"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 16334,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ConPlatformDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "408EDCEC-CF6D-477C-A5A8-B4844E3DE281"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 33230,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ConSplitterDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "CCCB0C28-4B24-11D5-9A5A-0090273FC14D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 25046,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "GraphicsConsoleDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9E863906-A40F-4875-977F-5B93FF237FC6"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 32966,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "TerminalDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "EBF8ED7C-0DD1-4787-84F1-F48D537DCACF"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 26266,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "B9D4C360-BCFB-4F9B-9298-53C136982258"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DriverHealthManagerDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "6D33944A-EC75-4855-A54D-809C75241F6C"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 111446,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "TRUE"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "6441F818-6362-4E44-B570-7DBA31DD2453"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "BdsDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "462CAA21-7614-4503-836E-8AB6F4662331"
																	},
																	"Type": 9,
																	"Attributes": 0,
																	"Size": 152942,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_APPLICATION",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UiApp"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9B680FCE-AD6B-4F3A-B60B-F59899003443"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 46098,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "TRUE"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DevicePathDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "79E4A61C-ED73-4312-94FE-E3E7563362A9"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 11802,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PrintDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "6B38F7B4-AD98-40E9-9093-ACA2B5A253C4"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 20610,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DiskIoDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "1FA1F39E-FEFF-4AAE-BD7B-38A070A3B609"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24778,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PartitionDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "28A03FF4-12B3-4305-A417-BB1A4F94081E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 45420,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "B9D4C360-BCFB-4F9B-9298-53C136982258"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "RamDiskDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "CD3BAFB6-50FB-4FE8-8E4E-AB74D2C1A600"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8966,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "EnglishDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "0167CCC4-D0F7-4F21-A3EF-9E64B7CDCE8B"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 17278,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ScsiBus"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "0A66E322-3740-4CCE-AD62-BD172CECCA35"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 39938,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ScsiDisk"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "021722D8-522B-4079-852A-FE44C2C13F49"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 13902,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SataController"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "5E523CB4-D397-4986-87BD-A6DD8B22F455"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 41750,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "AtaAtapiPassThruDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "19DF145A-B1D4-453F-8507-38816676D7F6"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 27586,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "AtaBusDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "5BE3BDF4-53CF-46A3-A6A9-73C34A6E5EE3"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 43210,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "NvmExpressDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "348C4D62-BFBD-4882-9ECE-C80BB1C4783B"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 124654,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "HiiDatabase"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "EBF342FE-B1D3-4EF8-957C-8048606FF671"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 106666,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SetupBrowser"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "2.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "E660EA85-058E-4B55-A54B-F02F83A24707"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 80534,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "A770C357-B693-4E6D-A6CF-D21C728E550B"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DisplayEngine"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "96B5C032-DF4C-4B6E-8232-438DCF448D0E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 9018,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "NullMemoryTestDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "38A0EC22-FBE7-4911-8BC1-176E0D6C1DBD"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 11390,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IsaAcpi"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "240612B5-A063-11D4-9A3A-0090273FC14D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 16642,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IsaBusDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "93B80003-9FB3-11D4-9A3A-0090273FC14D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 21386,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IsaSerialDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "3DC82376-637B-40A6-A8FC-A565417F2C38"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24206,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Ps2KeyboardDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "0ABD8284-6DA3-4616-971A-83A5148067BA"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 21514,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IsaFloppyDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F9D88642-0737-49BC-81B5-6889CD57D9EA"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 22738,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "TRUE"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SmbiosDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "4110465D-5FF3-4F4B-B580-24ED0D06747A"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 13618,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "03583FF6-CB36-4940-947E-B9B39F4AFAF7"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SmbiosPlatformDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9622E42C-8E38-4A08-9E8F-54F784652F6B"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 29490,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "AcpiTableDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "49970331-E3FA-4637-9ABC-3B7868676970"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 33898,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "FFE06BDD-6107-46A6-7BB2-5A9C7EC5275C"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "AcpiPlatform"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "7E374E25-8E01-4FEE-87F2-390C23C606CD"
																	},
																	"Type": 2,
																	"Attributes": 0,
																	"Size": 4392,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_FREEFORM",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "BDCE85BB-FBAA-4F4E-9264-501A2C249581"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 27742,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "TRUE"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "S3SaveStateDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FA20568B-548B-4B2B-81EF-1BA08D4A3CEC"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 59130,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "BD445D79-B7AD-4F04-9AD8-29BD2040EB3C"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "4E939DE9-D948-4B0F-88ED-E6E1CE517C1E"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "F8775D50-8ABD-4ADF-92AC-853E51F6C8DC"
																				}
																			},
																			{
																				"OpCode": "OR"
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "BootScriptExecutorDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "B8E62775-BB0A-43F0-A843-5BE8B14F8CCD"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 10538,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "BootGraphicsResourceTableDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "961578FE-B6B7-44C3-AF35-6BC705CD2B1F"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 42742,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Fat"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A487A478-51EF-48AA-8794-7BEE2A0562F1"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 44406,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "tftpDynamicCommand"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1"
																	},
																	"Type": 9,
																	"Attributes": 0,
																	"Size": 920214,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_APPLICATION",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Shell"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "F74D20EE-37E7-48FC-97F7-9B1047749C69"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 19706,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "1A1241E6-8F19-41A9-BC0E-E8EF39E06546"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "LogoDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A2F436EA-A127-4EF8-957C-8048606FF670"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 31614,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "SnpDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A210F973-229D-4F4D-AA37-9895E6C9EABA"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 8918,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "DpcDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "025BBFC7-E6A9-4B8B-82AD-6815A1AEAF4A"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 45950,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "MnpDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "E4F61863-FE2C-4B56-A8F4-08519BC439DF"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 29886,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VlanConfigDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "529D3F93-E8E9-4E73-B1E1-BDF6A9D50113"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 25982,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "ArpDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "94734718-0BBC-47FB-96A5-EE7A5AE6A2AD"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 45378,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Dhcp4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9FB1A1F3-3B71-4324-B39A-745CBB015FFF"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 82930,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Ip4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "DC3641B8-2FA8-4ED3-BC1F-F9962A03454B"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 40258,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Mtftp4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "6D6963AB-906D-4A65-A7CA-BD40E5D6AF2B"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 38590,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Udp4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "6D6963AB-906D-4A65-A7CA-BD40E5D6AF4D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 70078,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "Tcp4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "3B1DEAB5-C75D-442E-9238-8E2FFB62B0BB"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 44426,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UefiPxe4BcDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "4579B72D-7EC4-4DD4-8486-083C86B182A7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 75382,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IScsi4Dxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "A92CDB4B-82F1-4E0B-A516-8A655D371524"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24138,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioNetDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "2FB92EFA-2EE0-4BAE-9EB6-7464125E1EF7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 30398,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UhciDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "BDFE430E-8F2A-4DB0-9991-6F856594777E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 37054,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "EhciDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "B7F50E91-A759-412C-ADE4-DCD03E7F7C28"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 54398,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "XhciDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "240612B7-A063-11D4-9A3A-0090273FC14D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 39170,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UsbBusDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "2D2E62CF-9ECF-43B7-8219-94E7FC713DFE"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 27586,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UsbKbDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "9FB4B4A7-42C0-4BCD-8540-9BCC6711F83E"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24850,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "UsbMassStorageDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "E3752948-B9A1-4770-90C4-DF41C38986BE"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 28170,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "QemuVideoDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "D6099B94-CD97-4CC5-8714-7F6312701A8A"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 25418,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VirtioGpuDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "D9DCC5DF-4007-435E-9098-8970935504B2"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 21118,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "587E72D7-CC50-4F79-8209-CA291FC1A10F"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "EF9FC172-A1B2-4693-B327-6D32FC416042"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "1E5668E2-8481-11D4-BCF1-0080C73C8881"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "6441F818-6362-4E44-B570-7DBA31DD2453"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0FD96974-23AA-4CDC-B9CB-98D17750322A"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 25
																		},
																		"Type": "EFI_SECTION_RAW",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "PlatformDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "2EC9DA37-EE35-4DE9-86C5-6D9A81DC38A7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 10730,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "AmdSevDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "8657015B-EA43-440D-949A-AF3BE365C0FC"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 14874,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "IoMmuDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "733CBAC2-B23F-4B92-BC8E-FB01CE5907B7"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 28802,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "FvbServicesRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "22DC2B60-FE40-42AC-B01F-3AB1FAD9AAD8"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 24714,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "EmuVariableFvbRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "FE5CEA76-4F72-49E8-986F-2CD899DFFE5D"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 23334,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "8F644FA9-E850-4DB1-9CE2-0B44698E8DA4"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "B7DFB4E1-052F-449F-87BE-9818FC91B733"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "FaultTolerantWriteDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															},
															{
																"Header": {
																	"GUID": {
																		"GUID": "CBD2E4D5-7068-4FF5-B462-9822B4AD8D60"
																	},
																	"Type": 7,
																	"Attributes": 0,
																	"Size": 57470,
																	"State": 248
																},
																"Type": "EFI_FV_FILETYPE_DRIVER",
																"Sections": [
																	{
																		"Header": {
																			"Type": 19
																		},
																		"Type": "EFI_SECTION_DXE_DEPEX",
																		"ExtractPath": "",
																		"DepEx": [
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "13A3F0F6-264A-3EF0-F2E0-DEC512342F34"
																				}
																			},
																			{
																				"OpCode": "PUSH",
																				"GUID": {
																					"GUID": "0379BE4E-D706-437D-B037-EDB82FB772A4"
																				}
																			},
																			{
																				"OpCode": "AND"
																			},
																			{
																				"OpCode": "END"
																			}
																		]
																	},
																	{
																		"Header": {
																			"Type": 16
																		},
																		"Type": "EFI_SECTION_PE32",
																		"ExtractPath": ""
																	},
																	{
																		"Header": {
																			"Type": 21
																		},
																		"Type": "EFI_SECTION_USER_INTERFACE",
																		"ExtractPath": "",
																		"Name": "VariableRuntimeDxe"
																	},
																	{
																		"Header": {
																			"Type": 20
																		},
																		"Type": "EFI_SECTION_VERSION",
																		"ExtractPath": "",
																		"Version": "1.0"
																	}
																],
																"ExtractPath": "",
																"DataOffset": 24
															}
														],
														"DataOffset": 120,
														"FVOffset": 0,
														"ExtractPath": "",
														"Resizable": true
													}
												}
											]
										}
									}
								]
							}
						],
						"ExtractPath": "",
						"DataOffset": 24
					}
				],
				"DataOffset": 120,
				"FVOffset": 540672,
				"ExtractPath": "",
				"Resizable": false
			}
		},
		{
			"Type": "*uefi.FirmwareVolume",
			"Value": {
				"FileSystemGUID": {
					"GUID": "8C8CE578-8A3D-4F1C-9935-896185C32DD3"
				},
				"Length": 212992,
				"Signature": 1213613663,
				"Attributes": 327423,
				"HeaderLen": 72,
				"Checksum": 42552,
				"ExtHeaderOffset": 96,
				"Revision": 2,
				"Blocks": [
					{
						"Count": 52,
						"Size": 4096
					}
				],
				"FVName": {
					"GUID": "763BED0D-DE9F-48F5-81F1-3E90E1B1A015"
				},
				"ExtHeaderSize": 20,
				"Files": [
					{
						"Header": {
							"GUID": {
								"GUID": "DF1CCEF6-F301-4A63-9661-FC6030DCC880"
							},
							"Type": 3,
							"Attributes": 0,
							"Size": 21950,
							"State": 248
						},
						"Type": "EFI_FV_FILETYPE_SECURITY_CORE",
						"Sections": [
							{
								"Header": {
									"Type": 16
								},
								"Type": "EFI_SECTION_PE32",
								"ExtractPath": ""
							},
							{
								"Header": {
									"Type": 21
								},
								"Type": "EFI_SECTION_USER_INTERFACE",
								"ExtractPath": "",
								"Name": "SecMain"
							},
							{
								"Header": {
									"Type": 20
								},
								"Type": "EFI_SECTION_VERSION",
								"ExtractPath": "",
								"Version": "1.0"
							}
						],
						"ExtractPath": "",
						"DataOffset": 24
					},
					{
						"Header": {
							"GUID": {
								"GUID": "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF"
							},
							"Type": 240,
							"Attributes": 0,
							"Size": 190160,
							"State": 248
						},
						"Type": "EFI_FV_FILETYPE_FFS_PAD",
						"ExtractPath": "",
						"DataOffset": 24
					},
					{
						"Header": {
							"GUID": {
								"GUID": "1BA0062E-C779-4582-8566-336AE8F78F09"
							},
							"Type": 1,
							"Attributes": 8,
							"Size": 760,
							"State": 248
						},
						"Type": "EFI_FV_FILETYPE_RAW",
						"ExtractPath": "",
						"DataOffset": 24
					}
				],
				"DataOffset": 120,
				"FVOffset": 3981312,
				"ExtractPath": "",
				"Resizable": false
			}
		}
	],
	"ExtractPath": "",
	"Length": 4194304,
	"FRegion": null,
	"RegionType": 0
}

```

`integration/roms/OVMF.md`:

```md
# OVMF

EDK2 is open-source UEFI firmware, governed under a BSD license and can be
redistributed. OVMF is a EDK2 configuration which can run under QEMU.

In this folder, you will find:

- `OVMF.rom`: EDK2 firmware image
- `OVMF_target.txt`: Configuration used to build the OVMF image. To rebuild,
  copy this file to `conf/target.txt` in the EDK2 source tree.


## Build Notes

- OS: `Ubuntu 16.04.4 LTS xenial`
- Git tag: `vUDK2018`
- GCC version: `gcc (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609`
- Build is not reproducible.
- Find instructions at: https://wiki.ubuntu.com/UEFI/EDK2


## Running in QEMU

    qemu-system-x86_64 -bios OVMF.rom -nographic -net none

```

`integration/roms/OVMF_target.txt`:

```txt
#
#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
#
#  This program and the accompanying materials
#  are licensed and made available under the terms and conditions of the BSD License
#  which accompanies this distribution.  The full text of the license may be found at
#  http://opensource.org/licenses/bsd-license.php

#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
#
#
#  ALL Paths are Relative to WORKSPACE

#  Separate multiple LIST entries with a SINGLE SPACE character, do not use comma characters.
#  Un-set an option by either commenting out the line, or not setting a value.

#
#  PROPERTY              Type       Use         Description
#  ----------------      --------   --------    -----------------------------------------------------------
#  ACTIVE_PLATFORM       Filename   Recommended Specify the WORKSPACE relative Path and Filename
#                                               of the platform description file that will be used for the
#                                               build. This line is required if and only if the current
#                                               working directory does not contain one or more description
#                                               files.
ACTIVE_PLATFORM       = OvmfPkg/OvmfPkgX64.dsc

#  TARGET                List       Optional    Zero or more of the following: DEBUG, RELEASE, NOOPT
#                                               UserDefined; separated by a space character.
#                                               If the line is missing or no value is specified, all
#                                               valid targets specified in the platform description file
#                                               will attempt to be built. The following line will build
#                                               DEBUG platform target.
TARGET                = DEBUG

#  TARGET_ARCH           List       Optional    What kind of architecture is the binary being target for.
#                                               One, or more, of the following, IA32, IPF, X64, EBC, ARM
#                                               or AArch64.
#                                               Multiple values can be specified on a single line, using
#                                               space charaters to separate the values.  These are used
#                                               during the parsing of a platform description file,
#                                               restricting the build output target(s.)
#                                               The Build Target ARCH is determined by (precedence high to low):
#                                                 Command-line: -a ARCH option
#                                                 target.txt: TARGET_ARCH values
#                                                 DSC file: [Defines] SUPPORTED_ARCHITECTURES tag
#                                               If not specified, then all valid architectures specified
#                                               in the platform file, for which tools are available, will be
#                                               built.
TARGET_ARCH           = X64

#  TOOL_DEFINITION_FILE  Filename  Optional   Specify the name of the filename to use for specifying
#                                             the tools to use for the build.  If not specified,
#                                             WORKSPACE/Conf/tools_def.txt will be used for the build.
TOOL_CHAIN_CONF       = Conf/tools_def.txt

#  TAGNAME               List      Optional   Specify the name(s) of the tools_def.txt TagName to use.
#                                             If not specified, all applicable TagName tools will be
#                                             used for the build.  The list uses space character separation.
TOOL_CHAIN_TAG        = GCC5

# MAX_CONCURRENT_THREAD_NUMBER  NUMBER  Optional  The number of concurrent threads. If not specified or set
#                                                 to zero, tool automatically detect number of processor
#                                                 threads. Recommend to set this value to one less than the
#                                                 number of your computer cores or CPUs. When value set to 1,
#                                                 means disable multi-thread build, value set to more than 1,
#                                                 means user specify the thread number to build. Not specify
#                                                 the default value in this file.
# MAX_CONCURRENT_THREAD_NUMBER = 1


# BUILD_RULE_CONF  Filename Optional  Specify the file name to use for the build rules that are followed
#                                     when generating Makefiles. If not specified, the file:
#                                     WORKSPACE/Conf/build_rule.txt will be used
BUILD_RULE_CONF = Conf/build_rule.txt

```

`integration/roms/nvartest/old0`:

```
old0
```

`integration/roms/nvartest/summary.json`:

```json
{
    "FType": "*uefi.BIOSRegion",
    "FirmwareElement": {
        "Elements": [
            {
                "Type": "*uefi.FirmwareVolume",
                "Value": {
                    "FileSystemGUID": {
                        "GUID": "8C8CE578-8A3D-4F1C-9935-896185C32DD3"
                    },
                    "Length": 65536,
                    "Signature": 1213613663,
                    "Attributes": 261887,
                    "HeaderLen": 72,
                    "Checksum": 63179,
                    "ExtHeaderOffset": 0,
                    "Revision": 2,
                    "Blocks": [
                        {
                            "Count": 1,
                            "Size": 65536
                        }
                    ],
                    "FVName": {
                        "GUID": "00000000-0000-0000-0000-000000000000"
                    },
                    "ExtHeaderSize": 0,
                    "Files": [
                        {
                            "Header": {
                                "GUID": {
                                    "GUID": "CEF5B9A3-476D-497F-9FDC-E98143E0422C"
                                },
                                "Type": 1,
                                "Attributes": 0,
                                "State": 248
                            },
                            "Type": "EFI_FV_FILETYPE_RAW",
                            "NVarStore": {
                                "Entries": [
                                    {
                                        "Header": {
                                            "Size": 98,
                                            "Attributes": 131
                                        },
                                        "GUID": {
                                            "GUID": "7E577E57-0123-4567-89AB-CDEF0000B10C"
                                        },
                                        "GUIDIndex": 0,
                                        "Name": "Group1",
                                        "NVarStore": {
                                            "Entries": [
                                                {
                                                    "Header": {
                                                        "Size": 21,
                                                        "Attributes": 131
                                                    },
                                                    "GUID": {
                                                        "GUID": "7E577E57-0123-4567-89AB-CDEF00000000"
                                                    },
                                                    "GUIDIndex": 0,
                                                    "Name": "Test0",
                                                    "Type": 4,
                                                    "Offset": 0,
                                                    "NextOffset": 0,
                                                    "ExtractPath": "test",
                                                    "DataOffset": 17
                                                },
                                                {
                                                    "Header": {
                                                        "Size": 21,
                                                        "Attributes": 131
                                                    },
                                                    "GUID": {
                                                        "GUID": "7E577E57-0123-4567-89AB-CDEF00000001"
                                                    },
                                                    "GUIDIndex": 1,
                                                    "Name": "Test1",
                                                    "Type": 4,
                                                    "Offset": 21,
                                                    "NextOffset": 0,
                                                    "ExtractPath": "test",
                                                    "DataOffset": 17
                                                }
                                            ],
                                            "GUIDStore": [
                                                {
                                                    "GUID": "7E577E57-0123-4567-89AB-CDEF00000000"
                                                },
                                                {
                                                    "GUID": "7E577E57-0123-4567-89AB-CDEF00000001"
                                                }
                                            ],
                                            "FreeSpaceOffset": 42,
                                            "GUIDStoreOffset": 48,
                                            "Length": 80
                                        },
                                        "Type": 4,
                                        "Offset": 0,
                                        "NextOffset": 0,
                                        "ExtractPath": "",
                                        "DataOffset": 18
                                    },
                                    {
                                        "Header": {
                                            "Size": 21,
                                            "Attributes": 131
                                        },
                                        "GUID": {
                                            "GUID": "7E577E57-0123-4567-89AB-CDEF00000000"
                                        },
                                        "GUIDIndex": 1,
                                        "Name": "Test0",
                                        "Type": 2,
                                        "Offset": 98,
                                        "NextOffset": 140,
                                        "ExtractPath": "test",
                                        "DataOffset": 17
                                    },
                                    {
                                        "Header": {
                                            "Size": 21,
                                            "Attributes": 131
                                        },
                                        "GUID": {
                                            "GUID": "7E577E57-0123-4567-89AB-CDEF00000001"
                                        },
                                        "GUIDIndex": 2,
                                        "Name": "Test1",
                                        "Type": 4,
                                        "Offset": 119,
                                        "NextOffset": 0,
                                        "ExtractPath": "test",
                                        "DataOffset": 17
                                    },
                                    {
                                        "Header": {
                                            "Size": 14,
                                            "Attributes": 136
                                        },
                                        "GUID": {
                                            "GUID": "7E577E57-0123-4567-89AB-CDEF00000000"
                                        },
                                        "GUIDIndex": 1,
                                        "Name": "Test0",
                                        "Type": 4,
                                        "Offset": 140,
                                        "NextOffset": 0,
                                        "ExtractPath": "test",
                                        "DataOffset": 10
                                    }
                                ],
                                "GUIDStore": [
                                    {
                                        "GUID": "7E577E57-0123-4567-89AB-CDEF0000B10C"
                                    },
                                    {
                                        "GUID": "7E577E57-0123-4567-89AB-CDEF00000000"
                                    },
                                    {
                                        "GUID": "7E577E57-0123-4567-89AB-CDEF00000001"
                                    }
                                ],
                                "FreeSpaceOffset": 154,
                                "GUIDStoreOffset": 65392,
                                "Length": 65440
                            },
                            "ExtractPath": "",
                            "DataOffset": 24
                        }
                    ],
                    "DataOffset": 72,
                    "FVOffset": 0,
                    "ExtractPath": "fvh.bin",
                    "Resizable": false
                }
            }
        ],
        "ExtractPath": "",
        "Length": 65536,
        "FRegion": null,
        "RegionType": 0
    }
}

```

`integration/roms/nvartest/test`:

```
test
```

`integration/utk_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package utk_test

import (
	"bytes"
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/linuxboot/fiano/pkg/uefi"
	"github.com/linuxboot/fiano/pkg/utk"
	"github.com/linuxboot/fiano/pkg/visitors"
)

// Returns all the ROM names (files which end in .rom) inside the roms folder.
func romList(t *testing.T) []string {
	roms, err := filepath.Glob("roms/*.rom")
	if err != nil {
		t.Fatalf("could not glob roms/*.rom, %v", err)
	}
	if len(roms) == 0 {
		t.Fatal("no ROMs found with roms/*.rom")
	}
	return roms
}

// TestExtractAssembleExtract tests the extract and assemble subcommand of UTK.
// The subcommands are run in this order:
//
// 1. utk extract tt.rom dir1
// 2. utk assemble dir1 tmp.rom
// 3. utk extract tmp.rom dir2
//
// The test passes iff the contents or dir1 and dir2 recursively equal. This
// roundabout method is used because UTK can re-assemble a ROM image which is
// logically equal to the original, but not bitwise equal (due to a different
// compression algorithm being used). To compare the ROMs logically, step 3 is
// required to decompresses it.
func TestExtractAssembleExtract(t *testing.T) {
	tmpDir := t.TempDir()
	// For debugging, use os.Exit to prevent deletion of tmpDir
	re := `"Size".*:.*[0-9].*\n`
	szre, err := regexp.Compile(re)
	if err != nil {
		t.Fatalf("Compiling re %q: got %v, want nil", re, err)
	}

	for _, tt := range romList(t) {
		t.Run(tt, func(t *testing.T) {
			tmpDirT := filepath.Join(tmpDir, filepath.Base(tt))
			if err := os.Mkdir(tmpDirT, 0777); err != nil {
				t.Fatal(err)
			}

			// Test paths
			var (
				dir1   = filepath.Join(tmpDirT, "dir1")
				tmpRom = filepath.Join(tmpDirT, "tmp.rom")
				dir2   = filepath.Join(tmpDirT, "dir2")
			)

			// Extract
			if err := utk.Run(tt, "extract", dir1); err != nil {
				t.Fatal(err)
			}
			// Assemble
			if err := utk.Run(dir1, "save", tmpRom); err != nil {
				t.Fatal(err)
			}
			// Extract
			if err := utk.Run(tmpRom, "extract", dir2); err != nil {
				t.Fatal(err)
			}

			// Output directories must not be empty.
			for _, d := range []string{dir1, dir2} {
				files, err := os.ReadDir(d)
				if err != nil {
					t.Fatalf("cannot read directory %q: %v", d, err)
				}
				if len(files) == 0 {
					t.Errorf("no files in directory %q", d)
				}
			}

			if err := filepath.Walk(dir1, func(n1 string, s1 fs.FileInfo, err error) error {
				if err != nil {
					return err
				}
				n2, err := filepath.Rel(dir1, n1)
				if err != nil {
					return fmt.Errorf("filepath.Rel(%q,%q):got %v, want nil", n1, dir1, err)
				}
				n2 = filepath.Join(dir2, n2)
				s2, err := os.Stat(n2)
				if err != nil {
					return fmt.Errorf("Stat %q: got %w, want nil", n2, err)
				}
				if s2.IsDir() != s1.IsDir() {
					return fmt.Errorf("%q.IsDir() != %q.Isdir:%w", s1, s2, os.ErrInvalid)
				}
				if s2.IsDir() {
					return nil
				}
				d1, err := os.ReadFile(n1)
				if err != nil {
					return fmt.Errorf("Reading %q:got %v, want nil", n1, err)
				}
				d1 = szre.ReplaceAll(d1, []byte{})
				d2, err := os.ReadFile(n2)
				if err != nil {
					return fmt.Errorf("Reading %q:got %v, want nil", n2, err)
				}
				d2 = szre.ReplaceAll(d2, []byte{})
				if string(d1) != string(d2) {
					return fmt.Errorf("%q(%q) != %q(%q):%w", n1, d1, n2, d2, os.ErrInvalid)
				}
				return nil
			}); err != nil {
				t.Fatalf("%q != %q:%v", dir1, dir2, os.ErrInvalid)
			}

		})
	}
}

// TestRegressionJson tests for regression in the JSON. After making a change
// which affects the tree, you must commit changes to the golden JSON files
// with:
//
//	utk integration/roms/OVMF.rom json > integration/roms/OVMF.json
//
// Otherwise, this test will fail. This gives you a chance to review how your
// code affects the tree and identify any mistakes.
func TestRegressionJson(t *testing.T) {
	tmpDir := t.TempDir()

	for _, tt := range romList(t) {
		t.Run(tt, func(t *testing.T) {
			goldenJSONFile := strings.TrimSuffix(tt, ".rom") + ".json"
			newJSONFile := filepath.Join(tmpDir, filepath.Base(goldenJSONFile))
			if _, err := os.Stat(goldenJSONFile); os.IsNotExist(err) {
				t.Skip("skipping test because no golden JSON file exists")
			}

			// Read and parse the image.
			image, err := os.ReadFile(tt)
			if err != nil {
				t.Fatal(err)
			}
			parsedRoot, err := uefi.Parse(image)
			if err != nil {
				t.Fatal(err)
			}

			buf := &bytes.Buffer{}
			json := &visitors.JSON{W: buf}
			if err := json.Run(parsedRoot); err != nil {
				t.Fatal(err)
			}
			if buf.String() == "" || buf.String() == "null" {
				t.Fatal("no json")
			}
			if err := os.WriteFile(newJSONFile, buf.Bytes(), 0666); err != nil {
				t.Fatal(err)
			}

			// Print diff.
			cmd := exec.Command("diff", goldenJSONFile, newJSONFile)
			cmd.Stdout = os.Stdout
			if err := cmd.Run(); err != nil {
				t.Error("json files did not compare equal")
			}
		})
	}
}

```

`pkg/amd/apcb/apcb.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package apcb

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"
)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// APCB config consists of tokens, all tokens have the following attributes: ID, type, priority, boardMask, value
// ID - is token's unique identifier. Note APCB config may contain multiple tokens with same ID. The used one is determined by priority and board
// Type - boolean, 1, 2 or 4 bytes value
// Priority - see PriorityLevel
// BoardMask - determines type of hardware for which the token is applicable
// Value - token's value according to its type
//
// Structure of APCB/APCB recovery config is the following:
// All tokens are grouped by a type, that has own TypeHeaderV3 followed by token pairs <ID, Value>.
// Each type contains tokens in a sorted order by their ID.
// All types are put into groups, that have GroupHeader followed by a number of 'types'
// Note that the groups have different purposes, the one with tokens should have a value of groupID = 0x3000
//
// Below is example of APCB header consisting of a single group with two types:
// | APCB header | group header | type header | <tokenID, tokenValue> ... | type header | <tokenID, tokenValue> ... |
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// TokenID is a unique token identifier
type TokenID uint32

// See: AgesaPkg/Addendum/Apcb/Inc/GN/ApcbV3TokenUid.h
const (
	TokenIDPSPMeasureConfig   TokenID = 0xDD3AD029
	TokenIDPSPEnableDebugMode TokenID = 0xD1091CD0
	TokenIDPSPErrorDisplay    TokenID = 0xDC33FF21
	TokenIDPSPStopOnError     TokenID = 0xE7024A21
)

// GetTokenIDString returns literal representation of known Token IDs otherwise an empty string
func GetTokenIDString(tokenID TokenID) string {
	switch tokenID {
	case TokenIDPSPMeasureConfig:
		return "APCB_TOKEN_UID_PSP_MEASURE_CONFIG"
	case TokenIDPSPEnableDebugMode:
		return "APCB_TOKEN_UID_PSP_ENABLE_DEBUG_MODE"
	case TokenIDPSPErrorDisplay:
		return "APCB_TOKEN_UID_PSP_ERROR_DISPLAY"
	case TokenIDPSPStopOnError:
		return "APCB_TOKEN_UID_PSP_STOP_ON_ERROR"
	}
	return ""
}

// See: AgesaPkg/Addendum/Apcb/Inc/CommonV3/ApcbV3Priority.h

// An APCB token may be saved in different instances or purpose levels and can have instances of the token at
// multiple purpose levels. These purpose levels provide a hierarchy of priority such that a token entry at one
// purpose level can be added to override the same token value set at a lower purpose level. The classic example is
// a priority system such that ADMIN -> DEBUGGING -> NORMAL, which means something occurring at a
// higher priority level would override another at a lower one. If the user set a token to TRUE at the debugging
// level and set the same one to FALSE at the normal level, the token readout would be TRUE. The intent is that a
// token can be temporarily changed for debug or evaluation; but should eventually be migrated to the 'Normal'
// purpose.

// PriorityLevel describes APCB BInary token priority level (APCB_PRIORITY_LEVEL in AGESA source code)
type PriorityLevel uint8

func (pl PriorityLevel) String() string {
	switch pl {
	case PriorityLevelHardForce:
		return "HardForce"
	case PriorityLevelHigh:
		return "High"
	case PriorityLevelMedium:
		return "Medium"
	case PriorityLevelEventLogging:
		return "EventLogging"
	case PriorityLevelLow:
		return "Low"
	case PriorityLevelDefault:
		return "Default"
	}
	return fmt.Sprintf("PriorityLevel_%d", pl)
}

// Defines existing APCB token priority levels
const (
	PriorityLevelHardForce    PriorityLevel = 1
	PriorityLevelHigh         PriorityLevel = 2
	PriorityLevelMedium       PriorityLevel = 3
	PriorityLevelEventLogging PriorityLevel = 4
	PriorityLevelLow          PriorityLevel = 5
	PriorityLevelDefault      PriorityLevel = 6
)

// PriorityMask specifies a combined set of APCBPriorityLevels
type PriorityMask uint8

func (m PriorityMask) String() string {
	var s strings.Builder
	for level := PriorityLevelHardForce; level <= PriorityLevelDefault; level++ {
		flag := uint8(1 << (uint8(level) - 1))
		if uint8(m)&flag != uint8(0) {
			if s.Len() > 0 {
				s.WriteString("|")
			}
			s.WriteString(level.String())
		}
	}
	if s.Len() == 0 {
		return "none"
	}
	return s.String()
}

// CreatePriorityMask combines PriorityLevel into a APCBPriorityMask
func CreatePriorityMask(levels ...PriorityLevel) PriorityMask {
	var result uint8
	for _, l := range levels {
		result |= 1 << (uint8(l) - 1)
	}
	return PriorityMask(result)
}

// Token represents an APCB token
type Token struct {
	ID           TokenID
	PriorityMask PriorityMask
	BoardMask    uint16
	Value        interface{} // One of the following bool, uint8, uint16, uint32
}

// NumValue returns Token's value as uint32
func (t Token) NumValue() uint32 {
	if t.Value == nil {
		panic("Value is nil")
	}

	_, result, err := parseValue(t.Value)
	if err != nil {
		panic(fmt.Sprintf("unknown value type: %T", t.Value))
	}
	return result
}

// ParseAPCBBinaryTokens returns all tokens contained in the APCB Binary
func ParseAPCBBinaryTokens(apcbBinary []byte) ([]Token, error) {
	_, remainBytes, err := parseAPCBHeader(apcbBinary)
	if err != nil {
		return nil, err
	}

	// We should iterate through each groups->types and collect all the tokens we encounter
	var result []Token
	err = iterateTokenGroups(remainBytes, func(groupHeader groupHeader, groupOffset uint32) error {
		groupData := remainBytes[groupOffset+uint32(groupHeader.SizeOfHeader) : groupOffset+groupHeader.SizeOfGroup]
		return iterateTypes(groupData, func(typeHeader typeHeaderV3, typeOffset uint32) error {
			typeData := groupData[typeOffset+uint32(binary.Size(typeHeader)) : typeOffset+uint32(typeHeader.SizeOfType)]
			return iterateTokens(typeData, typeHeader, func(tokenPairOffset uint32, tp tokenPair) error {
				val, err := processValue(typeHeader.TypeID, tp.Value)
				if err != nil {
					return err
				}
				result = append(result, Token{
					ID:           tp.ID,
					PriorityMask: typeHeader.PriorityMask,
					BoardMask:    typeHeader.BoardMask,
					Value:        val,
				})
				return nil
			})
		})
	})
	return result, err
}

// UpsertToken inserts a new token or updates current into apcb binary
func UpsertToken(tokenID TokenID, priorityMask PriorityMask, boardMask uint16, newValue interface{}, apcbBinary []byte) error {
	typeID, numValue, err := parseValue(newValue)
	if err != nil {
		return err
	}
	header, remainBytes, err := parseAPCBHeader(apcbBinary)
	if err != nil {
		return err
	}

	// There are three ways to do that:
	// 1. We do already have a token with such ID/PriorityMask/BoardMask. Just - change the value of this token
	// 2. We do have a group with tokens. Try to find a Type of the inserted value, if there is one - place token there, otherwise create a new Type.
	// And place a new token with input tokenID and value in this type.
	// 3. We don't have a group with tokens. Create an approperiate group, type and place a new token in this type.
	// Not that APCB binary has conigues structure, so if one "inserts" something, one should not forged to shift the remaining bytes

	var (
		matchedGroupHeader *groupHeader
		matchedGroupOffset uint32
		matchedTypeHeader  *typeHeaderV3
		matchedTypeOffset  uint32
		matchedTokenOffset uint32
	)
	tokenBytesCount := uint32(binary.Size(tokenPair{}))

	var tokenChanged bool
	err = iterateTokenGroups(remainBytes, func(groupHeader groupHeader, groupOffset uint32) error {
		if matchedTypeHeader == nil {
			matchedGroupHeader = &groupHeader
			matchedGroupOffset = groupOffset
		}

		groupData := remainBytes[groupOffset+uint32(groupHeader.SizeOfHeader) : groupOffset+groupHeader.SizeOfGroup]
		return iterateTypes(groupData, func(typeHeader typeHeaderV3, typeOffset uint32) error {
			if typeID != typeHeader.TypeID || typeHeader.BoardMask&boardMask == 0 || typeHeader.PriorityMask&priorityMask == 0 {
				return nil
			}

			matchedGroupHeader = &groupHeader
			matchedGroupOffset = groupOffset
			matchedTypeHeader = &typeHeader
			matchedTypeOffset = typeOffset
			matchedTokenOffset = 0

			typeData := groupData[typeOffset+uint32(binary.Size(typeHeader)) : typeOffset+uint32(typeHeader.SizeOfType)]
			return iterateTokens(typeData, typeHeader, func(tokenPairOffset uint32, tp tokenPair) error {
				if tp.ID <= tokenID {
					matchedTokenOffset = tokenPairOffset + tokenBytesCount
				}
				if tp.ID != tokenID {
					return nil
				}
				newTokenPair := tp
				newTokenPair.Value = numValue

				if err := writeFixedBuffer(typeData[tokenPairOffset:], newTokenPair); err != nil {
					return err
				}
				tokenChanged = true
				return nil
			})
		})
	})
	if err != nil {
		return err
	}
	if tokenChanged {
		return nil
	}

	var (
		insertionOffset uint32
		addedBytes      uint32
		writeNewToken   func(wb io.Writer) error
	)

	// Add headers to offsets
	matchedGroupOffset += uint32(binary.Size(header))
	if matchedGroupHeader != nil {
		matchedTypeOffset += uint32(matchedGroupHeader.SizeOfHeader)
	}

	if matchedTypeHeader != nil {
		// case 1: There exists a type for a upserted token
		insertionOffset = matchedGroupOffset + matchedTypeOffset + uint32(binary.Size(matchedTypeHeader)) + matchedTokenOffset
		addedBytes = tokenBytesCount

		writeNewToken = func(wb io.Writer) error {
			newToken := tokenPair{
				ID:    tokenID,
				Value: numValue,
			}
			if err := binary.Write(wb, binary.LittleEndian, newToken); err != nil {
				return fmt.Errorf("failed to write inserted token pair: '%w'", err)
			}
			return nil
		}
	} else {
		if matchedGroupHeader != nil {
			// case 2: There exists a tokens group, but no type for upserted token
			insertionOffset = matchedGroupOffset + matchedGroupHeader.SizeOfGroup
			addedBytes, writeNewToken = constructNewTypeForToken(
				tokenID,
				priorityMask,
				boardMask,
				typeID,
				numValue,
			)
		} else {
			// case 3: We need to create a new tokens group with a new type and a new token
			insertionOffset = header.V2Header.SizeOfAPCB
			addedBytes, writeNewToken = constructNewGroupForToken(
				tokenID,
				priorityMask,
				boardMask,
				typeID,
				numValue,
			)
		}
	}

	if header.V2Header.SizeOfAPCB+addedBytes > uint32(len(apcbBinary)) {
		return fmt.Errorf(
			"impossible to insert a new token because apcb binary length is small, required: '%d', have: '%d'",
			header.V2Header.SizeOfAPCB+addedBytes,
			len(apcbBinary))
	}

	// we want to insert "addedBytes" bytes at insertionOffset that will invalidate all bytes after insertionOffset
	// so copy invalidated bytes first
	copy(apcbBinary[insertionOffset+addedBytes:], apcbBinary[insertionOffset:header.V2Header.SizeOfAPCB])
	if err := writeNewToken(newFixedSizeBuffer(apcbBinary[insertionOffset:])); err != nil {
		return err
	}

	// Fix sizes of touched elements
	if matchedTypeHeader != nil {
		matchedTypeHeader.SizeOfType += uint16(tokenBytesCount)
		if err := writeFixedBuffer(apcbBinary[matchedGroupOffset+matchedTypeOffset:], matchedTypeHeader); err != nil {
			return fmt.Errorf("failed to write inserted token pair: '%w'", err)
		}
	}
	if matchedGroupHeader != nil {
		matchedGroupHeader.SizeOfGroup += addedBytes
		if err := writeFixedBuffer(apcbBinary[matchedGroupOffset:], matchedGroupHeader); err != nil {
			return fmt.Errorf("failed to update token group: '%w'", err)
		}
	}
	header.V2Header.SizeOfAPCB += addedBytes
	if err := writeFixedBuffer(apcbBinary, header); err != nil {
		return fmt.Errorf("failed to update APCB binary header: '%w'", err)
	}
	return nil
}

func constructNewTypeForToken(
	tokenID TokenID,
	priorityMask PriorityMask,
	boardMask uint16,
	typeID tokenType,
	value uint32,
) (uint32, func(wb io.Writer) error) {
	newTypeHeader := typeHeaderV3{
		GroupID:       tokensGroupID,
		TypeID:        typeID,
		InstanceID:    0,
		ContextType:   tokenV3ContextType,
		ContextFormat: sortAscByUnitSizeContextFormat,
		BoardMask:     boardMask,
		PriorityMask:  priorityMask,
		UnitSize:      8, // hardcode for tokenV3ContextType
		KeySize:       uint8(binary.Size(tokenID)),
		KeyPos:        0,
	}
	newToken := tokenPair{
		ID:    tokenID,
		Value: value,
	}
	newTokenBytesCount := uint32(binary.Size(newToken))
	newTypeHeader.SizeOfType = uint16(binary.Size(newTypeHeader)) + uint16(newTokenBytesCount)

	return uint32(newTypeHeader.SizeOfType), func(wb io.Writer) error {
		if err := binary.Write(wb, binary.LittleEndian, newTypeHeader); err != nil {
			return fmt.Errorf("failed to write inserted type: '%w'", err)
		}
		if err := binary.Write(wb, binary.LittleEndian, newToken); err != nil {
			return fmt.Errorf("failed to write inserted token pair: '%w'", err)
		}
		return nil
	}
}

func constructNewGroupForToken(
	tokenID TokenID,
	priorityMask PriorityMask,
	boardMask uint16,
	typeID tokenType,
	value uint32,
) (uint32, func(wb io.Writer) error) {
	newTypeLength, insertNewTypeWithToken := constructNewTypeForToken(
		tokenID,
		priorityMask,
		boardMask,
		typeID,
		value,
	)
	newGroupHeader := groupHeader{
		Signature: tokenGroupSignature,
		GroupID:   tokensGroupID,
		Version:   1,
	}
	newGroupHeader.SizeOfHeader = uint16(binary.Size(newGroupHeader))
	newGroupHeader.SizeOfGroup = uint32(newGroupHeader.SizeOfHeader) + newTypeLength

	return newGroupHeader.SizeOfGroup, func(wb io.Writer) error {
		if err := binary.Write(wb, binary.LittleEndian, newGroupHeader); err != nil {
			return fmt.Errorf("failed to write inserted token pair: '%w'", err)
		}
		if err := insertNewTypeWithToken(wb); err != nil {
			return err
		}
		return nil
	}
}

func parseAPCBHeader(apcbBinary []byte) (headerV3, []byte, error) {
	var header headerV3
	if err := binary.Read(bytes.NewBuffer(apcbBinary), binary.LittleEndian, &header); err != nil {
		return header, nil, fmt.Errorf("failed to read input header: %w", err)
	}

	if header.V2Header.Signature != headerV2Signature {
		return header, nil, fmt.Errorf(
			"APCB header v2 signature mismatch, got '0x%X', expected: '0x%X'",
			header.V2Header.Signature, headerV2Signature)
	}
	if header.Signature2 != headerV3Signature {
		return header, nil, fmt.Errorf(
			"APCB header v3 signature mismatch, got '0x%X', expected: '0x%X'",
			header.Signature2, headerV3Signature)
	}
	if header.SignatureEnding != headerV3EndingSignature {
		return header, nil, fmt.Errorf(
			"APCB header v3 signature ending mismatch, got '0x%X', expected: '0x%X'",
			header.Signature2, headerV3EndingSignature)
	}

	if header.V2Header.SizeOfAPCB > uint32(len(apcbBinary)) {
		return header, nil, fmt.Errorf("input buffer '%d' is smaller than expected APCB size '%d'",
			len(apcbBinary), header.V2Header.SizeOfAPCB)
	}

	if uint32(len(apcbBinary)) < header.V2Header.SizeOfAPCB {
		return header, nil, fmt.Errorf(
			"invalid apcb binary header, expected size of APCB is %d, but having only %d",
			header.V2Header.SizeOfAPCB,
			len(apcbBinary),
		)
	}

	return header, apcbBinary[uint32(binary.Size(header)):header.V2Header.SizeOfAPCB], nil
}

// See: AgesaModulePkg/Library/ApcbLibV3/CoreApcbInterface.c
func iterateTokenGroups(apcbBody []byte, onGroupFound func(groupHeader groupHeader, offset uint32) error) error {
	groupHeaderSize := uint32(binary.Size(groupHeader{}))

	var offset uint32
	remainBytes := apcbBody
	for len(remainBytes) > 0 {
		var groupHeader groupHeader
		if err := binary.Read(bytes.NewReader(remainBytes), binary.LittleEndian, &groupHeader); err != nil {
			return fmt.Errorf("failed to read group header: '%v'", err)
		}
		if groupHeader.SizeOfGroup < groupHeaderSize {
			return fmt.Errorf("size of group is less than size of group header: %d < %d", groupHeader.SizeOfGroup, groupHeaderSize)
		}
		if groupHeader.SizeOfGroup > uint32(len(remainBytes)) {
			return fmt.Errorf("size of group exceeds the length of remaining data '%d' > '%d'", groupHeader.SizeOfGroup, len(remainBytes))
		}
		if groupHeader.GroupID == tokensGroupID {
			if err := onGroupFound(groupHeader, offset); err != nil {
				return err
			}
		}
		offset += groupHeader.SizeOfGroup
		remainBytes = remainBytes[groupHeader.SizeOfGroup:]
	}
	return nil
}

func iterateTypes(group []byte, onTypeFound func(typeHeader typeHeaderV3, offset uint32) error) error {
	typeHeaderSize := uint16(binary.Size(typeHeaderV3{}))

	var offset uint32
	remainBytes := group
	for len(remainBytes) > 0 {
		var typeHeader typeHeaderV3
		if err := binary.Read(bytes.NewReader(remainBytes), binary.LittleEndian, &typeHeader); err != nil {
			return fmt.Errorf("failed to read type header: '%v'", err)
		}
		if typeHeader.SizeOfType < typeHeaderSize {
			return fmt.Errorf("size of type is less than size of type header: %d < %d", typeHeader.SizeOfType, typeHeaderSize)
		}
		if typeHeader.SizeOfType > uint16(len(remainBytes)) {
			return fmt.Errorf("size of type '%d' is bigger than bytes left '%d'", typeHeader.SizeOfType, uint16(len(remainBytes)))
		}
		if err := onTypeFound(typeHeader, offset); err != nil {
			return err
		}

		offset += uint32(typeHeader.SizeOfType)
		remainBytes = remainBytes[typeHeader.SizeOfType:]
	}
	return nil
}

func iterateTokens(typeData []byte, typeHeader typeHeaderV3, onTokenFound func(offset uint32, tp tokenPair) error) error {
	tokenPairSize := binary.Size(tokenPair{})
	if len(typeData)%tokenPairSize != 0 {
		return fmt.Errorf("incorrect APCB type header SizeOfType: '%d'", typeHeader.SizeOfType)
	}

	b := bytes.NewReader(typeData)
	tokensCount := len(typeData) / tokenPairSize
	for i := 0; i < tokensCount; i++ {
		var token tokenPair
		if err := binary.Read(b, binary.LittleEndian, &token); err != nil {
			return fmt.Errorf("failed to read token pair: '%v'", err)
		}
		if err := onTokenFound(uint32(i*tokenPairSize), token); err != nil {
			return err
		}
	}
	return nil
}

func processValue(tokenType tokenType, val uint32) (interface{}, error) {
	switch tokenType {
	case booleanTokenType:
		return val&1 != 0, nil
	case oneByteTokenType:
		return uint8(val & 0xff), nil
	case twoBytesTokenType:
		return uint16(val & 0xffff), nil
	case fourBytesTokenType:
		return val, nil
	}
	return nil, fmt.Errorf("unknown token type: '%d'", tokenType)
}

func parseValue(v interface{}) (tokenType, uint32, error) {
	switch value := v.(type) {
	case bool:
		if value {
			return booleanTokenType, 1, nil
		}
		return booleanTokenType, 0, nil
	case uint8:
		return oneByteTokenType, uint32(value), nil
	case uint16:
		return twoBytesTokenType, uint32(value), nil
	case uint32:
		return fourBytesTokenType, value, nil
	}
	return 0, 0, fmt.Errorf("unknown type: '%T'", v)
}

type fixedSizeBuffer struct {
	buffer []byte
	offset int
}

func newFixedSizeBuffer(buf []byte) io.Writer {
	return &fixedSizeBuffer{buffer: buf}
}

func (fb *fixedSizeBuffer) Write(p []byte) (int, error) {
	remain := fb.buffer[fb.offset:]
	n := copy(remain, p)
	fb.offset += n
	if n < len(p) {
		return n, io.EOF
	}
	return n, nil
}

func writeFixedBuffer(buf []byte, v interface{}) error {
	return binary.Write(newFixedSizeBuffer(buf), binary.LittleEndian, v)
}

```

`pkg/amd/apcb/apcb_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package apcb

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"os"
	"path"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/ulikunitz/xz"
)

func TestParsingTokens(t *testing.T) {
	apcbBinary, err := getFile("apcb_binary.xz")
	require.NoError(t, err)
	require.NotEmpty(t, apcbBinary)

	tokens, err := ParseAPCBBinaryTokens(apcbBinary)
	require.NoError(t, err)
	require.Len(t, tokens, 40)

	token := findToken(0x3E7D5274, tokens)
	require.NotNil(t, token)
	require.Equal(t, CreatePriorityMask(PriorityLevelMedium), token.PriorityMask)
	require.Equal(t, uint16(0xFFFF), token.BoardMask)
	require.Equal(t, uint32(2044), token.Value)
	require.Equal(t, uint32(2044), token.NumValue())

	token = findToken(0xE1CC135E, tokens)
	require.NotNil(t, token)
	require.Equal(t, CreatePriorityMask(PriorityLevelMedium), token.PriorityMask)
	require.Equal(t, uint16(0xFFFF), token.BoardMask)
	require.Equal(t, false, token.Value)
	require.Equal(t, uint32(0), token.NumValue())
}

func TestUpsertToken(t *testing.T) {
	t.Run("update_existing_token", func(t *testing.T) {
		apcbBinary, err := getFile("apcb_binary.xz")
		require.NoError(t, err)
		require.NotEmpty(t, apcbBinary)

		require.NoError(t, UpsertToken(0x3E7D5274, 0xff, 0xffff, uint32(0xffffffff), apcbBinary))

		tokens, err := ParseAPCBBinaryTokens(apcbBinary)
		require.NoError(t, err)
		require.Len(t, tokens, 40)

		token := findToken(0x3E7D5274, tokens)
		require.NotNil(t, token)
		require.Equal(t, uint32(0xffffffff), token.NumValue())
	})

	t.Run("insert_new_token", func(t *testing.T) {
		apcbBinary, err := getFile("apcb_binary.xz")
		require.NoError(t, err)
		require.NotEmpty(t, apcbBinary)

		require.NoError(t, UpsertToken(0xFFFFAAAA, 0xff, 0xffff, uint32(0xffffffff), apcbBinary))

		tokens, err := ParseAPCBBinaryTokens(apcbBinary)
		require.NoError(t, err)
		require.Len(t, tokens, 41)

		token := findToken(0xFFFFAAAA, tokens)
		require.NotNil(t, token)
		require.Equal(t, uint32(0xffffffff), token.NumValue())
	})

	t.Run("insert_new_token_no_type", func(t *testing.T) {
		apcbBinary, err := getFile("apcb_binary.xz")
		require.NoError(t, err)
		require.NotEmpty(t, apcbBinary)

		h, _, err := parseAPCBHeader(apcbBinary)
		require.NoError(t, err)
		h.V2Header.SizeOfAPCB = uint32(binary.Size(h))

		resultBuffer := make([]byte, binary.Size(h)+1000)
		require.NoError(t, writeFixedBuffer(resultBuffer, h))
		tokens, err := ParseAPCBBinaryTokens(resultBuffer)
		require.NoError(t, err)
		require.Empty(t, tokens)

		require.NoError(t, UpsertToken(0xFFFFAAAA, 0xff, 0xffff, uint32(0xffffffff), resultBuffer))

		tokens, err = ParseAPCBBinaryTokens(resultBuffer)
		require.NoError(t, err)
		require.Len(t, tokens, 1)

		require.NoError(t, UpsertToken(0xFFFFBBBB, 0xff, 0xffff, bool(true), resultBuffer))
		tokens, err = ParseAPCBBinaryTokens(resultBuffer)
		require.NoError(t, err)
		require.Len(t, tokens, 2)
	})
}

func findToken(tokenID TokenID, tokens []Token) *Token {
	for _, token := range tokens {
		if token.ID == tokenID {
			return &token
		}
	}
	return nil
}

func getFile(filename string) ([]byte, error) {
	compressedImage, err := os.ReadFile(path.Join("testdata", filename))
	if err != nil {
		return nil, fmt.Errorf("failed to read firmware image: %w", err)
	}

	r, err := xz.NewReader(bytes.NewReader(compressedImage))
	if err != nil {
		return nil, fmt.Errorf("unable to create an xz reader for a cached image: %w", err)
	}

	decompressedImage, err := io.ReadAll(r)
	if err != nil {
		return nil, fmt.Errorf("unable to decompress the image: %w", err)
	}

	return decompressedImage, nil
}

```

`pkg/amd/apcb/internal.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package apcb

//
// See: AgesaPkg/Addendum/Apcb/Inc/CommonV3/ApcbV3Arch.h for more details
//

type headerSignature uint32

const (
	headerV2Signature       headerSignature = 0x42435041
	headerV3Signature       headerSignature = 0x32424345
	headerV3EndingSignature headerSignature = 0x41424342
	tokenGroupSignature     headerSignature = 0x4E4B4F54 // NKOT
)

type headerV2 struct {
	// ASCII "APCB", 'A' is LSB
	Signature headerSignature
	// Size of header
	SizeOfHeader uint16
	// Version, BCD. Version 1.2 is 0x12
	Version uint16
	// SizeOfAPCB is size of APCB
	SizeOfAPCB uint32
	// UniqueAPCBInstance to ensure compatibility for given flashed BIOS life cycle
	UniqueAPCBInstance uint32
	// CheckSumByte is APCB Checksum Byte
	CheckSumByte uint8
	// Reserved1 is reserved, should be zeros
	Reserved1 [3]uint8
	// Reserved2 is reserved, should be zeros
	Reserved2 [3]uint32
}

type headerV3 struct {
	V2Header headerV2

	// Signature2 is "ECB2", 'E' is LSB
	Signature2 headerSignature
	// ReservedFixed1 fixed with 0. To be compatible with APCB_GROUP_HEADER_COMP.GroupId
	ReservedFixed1 uint16
	// Reserved, fixed with 0x10. To be compatible with APCB_GROUP_HEADER_COMP.SizeOfHeader
	ReservedFixed2 uint16

	// StructVersion integer. 0x12 is Version 18.
	StructVersion uint16 // Version, Hex. integer. 0x12 is Version 18.
	// DataVersion 0x100 is Version 256.
	DataVersion uint16
	// SizeOfExtendedHeader - size of extended header (size of APCB_v3_HEADER minus APCB_v2_HEADER). To be compatible with APCB_GROUP_HEADER_COMP.SizeOfGroup
	SizeOfExtendedHeader uint32

	// ReservedFixed3 fixed with 0. To be compatible with APCB_TYPE_HEADER.GroupId
	ReservedFixed3 uint16
	// ReservedFixed4 fixed with 0xFFFF. To be compatible with APCB_TYPE_HEADER.TypeId
	ReservedFixed4 uint16
	//  ReservedFixed5 fixed with 64d, 0x40, value to include extended header. To be compatible with APCB_TYPE_HEADER.SizeOfType
	ReservedFixed5 uint16
	// ReservedFixed6 fixed with 0x0000. To be compatible with APCB_TYPE_HEADER.InstanceId
	ReservedFixed6 uint16
	// Reserved3 should be zeros
	Reserved3 [2]uint32

	// DataOffset defines data starting offset, defined per APCB version. Fixed at size of APCB_V3_HEADER (88d, 0x58)
	DataOffset uint16

	// HeaderCheckSum is headerV3 Checksum Byte, needs to be filled
	HeaderCheckSum uint8
	// Reserved4 should be zeros
	Reserved4 uint8
	// Reserved5 should be zeros
	Reserved5 [3]uint32

	// APCB integrity signature, 0x20, 32 bytes
	IntegritySignature [32]uint8
	// Reserved6 should be zeros
	Reserved6 [3]uint32
	// SignatureEnding should be ASCII "BCPA", 'B' is LSB, Mark ending of header
	SignatureEnding headerSignature
}

type groupHeader struct {
	// ASCII Signature
	Signature    headerSignature
	GroupID      groupID
	SizeOfHeader uint16
	// Version, BCD. Version 1.2 is 0x12
	Version     uint16
	Reserved    uint16
	SizeOfGroup uint32
}

type contextType uint8

const (
	structureContextType contextType = 0
	parameterContextType contextType = 1
	tokenV3ContextType   contextType = 2
)

type contextFormat uint8

const (
	nativeRawContextFormat          contextFormat = 0
	sortAscByUnitSizeContextFormat  contextFormat = 1
	sortDescByUnitSizeContextFormat contextFormat = 2
)

type tokenType uint16

const (
	booleanTokenType   tokenType = 0
	oneByteTokenType   tokenType = 1
	twoBytesTokenType  tokenType = 2
	fourBytesTokenType tokenType = 4
)

type groupID uint16

const (
	tokensGroupID groupID = 0x3000
)

type typeHeaderV3 struct {
	GroupID groupID
	TypeID  tokenType
	// SizeOfType defines size of type, in bytes
	SizeOfType uint16
	InstanceID uint16

	ContextType   contextType
	ContextFormat contextFormat
	// UnitSize determines size in byte. Applicable when ContextType = 2, value should be 8.
	UnitSize     uint8
	PriorityMask PriorityMask
	// KeySize defines sorting key size. Should be smaller than or equal to UnitSize. Applicable when ContextFormat = 1. (or != 0)
	KeySize uint8
	// KeyPos defines Sorting key position of the unit specified of UnitSize.
	KeyPos uint8
	// Board specific APCB instance mask
	BoardMask uint16
}

type tokenPair struct {
	ID    TokenID
	Value uint32
}

```

`pkg/amd/manifest/bios_directory_table.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	bytes2 "github.com/linuxboot/fiano/pkg/bytes"
)

// Refer to: AMD Platform Security Processor BIOS Architecture Design Guide for AMD Family 17h and Family 19h
// Processors (NDA), Publication # 55758 Revision: 1.11 Issue Date: August 2020 (1)

// BIOSDirectoryTableCookie is a special identifier of BIOS Directory table level 1
const BIOSDirectoryTableCookie = 0x44484224 // $BHD
// BIOSDirectoryTableLevel2Cookie is a special identifier of BIOS Directory table level 2
const BIOSDirectoryTableLevel2Cookie = 0x324C4224 // $BL2

// BIOSDirectoryTableEntryType is an entry type of BIOS Directory table
type BIOSDirectoryTableEntryType uint8

const (
	// APCBDataEntry represents APCB data entry in BIOS Directory table
	APCBDataEntry BIOSDirectoryTableEntryType = 0x60
	// APOBBinaryEntry denotes APOB binary in BIOS Directory table
	APOBBinaryEntry BIOSDirectoryTableEntryType = 0x61
	// BIOSRTMVolumeEntry represents BIOS RTM Volume entry in BIOS Directory table
	BIOSRTMVolumeEntry BIOSDirectoryTableEntryType = 0x62
	// PMUFirmwareInstructionsEntry represents the instruction portion of PMU firmware
	PMUFirmwareInstructionsEntry BIOSDirectoryTableEntryType = 0x64
	// PMUFirmwareDataEntry represents the data portion of PMU firmware
	PMUFirmwareDataEntry BIOSDirectoryTableEntryType = 0x65
	// MicrocodePatchEntry represents the microcode patch file location
	MicrocodePatchEntry BIOSDirectoryTableEntryType = 0x66
	// APCBDataBackupEntry contains a backup copy of APCB data
	APCBDataBackupEntry BIOSDirectoryTableEntryType = 0x68
	// VideoInterpreterEntry interpreter binary that displays the video image
	VideoInterpreterEntry BIOSDirectoryTableEntryType = 0x69
	// BIOSDirectoryTableLevel2Entry denotes an entry that points to BIOS Directory table level 2
	BIOSDirectoryTableLevel2Entry BIOSDirectoryTableEntryType = 0x70
)

// BIOSDirectoryTableEntry represents a single entry in BIOS Directory Table
// Table 12 from (1)
type BIOSDirectoryTableEntry struct {
	Type       BIOSDirectoryTableEntryType
	RegionType uint8

	ResetImage bool
	CopyImage  bool
	ReadOnly   bool
	Compressed bool
	Instance   uint8
	Subprogram uint8
	RomID      uint8

	Size               uint32
	SourceAddress      uint64
	DestinationAddress uint64
}

const BIOSDirectoryTableEntrySize = 16

// BIOSDirectoryTableHeader represents a BIOS Directory Table Header
// Table 11 from (1)
type BIOSDirectoryTableHeader struct {
	BIOSCookie   uint32
	Checksum     uint32
	TotalEntries uint32
	Reserved     uint32
}

// BIOSDirectoryTable represents a BIOS Directory Table Header with all entries
// Table 11 & Table 12 from (1)
type BIOSDirectoryTable struct {
	BIOSDirectoryTableHeader

	Entries []BIOSDirectoryTableEntry
}

func (b BIOSDirectoryTable) String() string {
	var s strings.Builder
	cookieBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(cookieBytes, b.BIOSCookie)
	fmt.Fprintf(&s, "BIOS Cookie: 0x%x (%s)\n", b.BIOSCookie, cookieBytes)
	fmt.Fprintf(&s, "Checksum: %d\n", b.Checksum)
	fmt.Fprintf(&s, "Total Entries: %d\n", b.TotalEntries)
	fmt.Fprintf(&s, "%-5s | %-10s | %-10s | %-9s | %-8s | %-10s | %-8s | %-10s | %-5s | %-6s | %-13s | %-18s\n",
		"Type",
		"RegionType",
		"ResetImage",
		"CopyImage",
		"ReadOnly",
		"Compressed",
		"Instance",
		"Subprogram",
		"RomID",
		"Size",
		"SourceAddress",
		"DestinationAddress")
	fmt.Fprintf(&s, "%s\n", "----------------------------------------------------------------------------------------------------------------------------------------------------------------")
	for _, entry := range b.Entries {
		fmt.Fprintf(&s, "0x%-3x | 0x%-8x | %-10v | %-9v | %-8v | %-10v | 0x%-6x | 0x%-8x | 0x%-3x | %-6d | 0x%-11x | 0x%-18x\n",
			entry.Type,
			entry.RegionType,
			entry.ResetImage,
			entry.CopyImage,
			entry.ReadOnly,
			entry.Compressed,
			entry.Instance,
			entry.Subprogram,
			entry.RomID,
			entry.Size,
			entry.SourceAddress,
			entry.DestinationAddress)
	}
	return s.String()
}

// FindBIOSDirectoryTable scans firmware for BIOSDirectoryTableCookie
// and treats remaining bytes as BIOSDirectoryTable
func FindBIOSDirectoryTable(image []byte) (*BIOSDirectoryTable, bytes2.Range, error) {
	// there is no predefined address, search through the whole memory
	var cookieBytes [4]byte
	binary.LittleEndian.PutUint32(cookieBytes[:], BIOSDirectoryTableCookie)

	var offset uint64
	for {
		idx := bytes.Index(image, cookieBytes[:])
		if idx == -1 {
			break
		}

		table, bytesRead, err := ParseBIOSDirectoryTable(image[idx:])
		if err != nil {
			shift := uint64(idx + len(cookieBytes))
			image = image[shift:]
			offset += shift
			continue
		}
		return table, bytes2.Range{Offset: offset + uint64(idx), Length: bytesRead}, err
	}
	return nil, bytes2.Range{}, fmt.Errorf("BIOSDirectoryTable is not found")
}

// ParseBIOSDirectoryTable converts input bytes into BIOSDirectoryTable
func ParseBIOSDirectoryTable(data []byte) (*BIOSDirectoryTable, uint64, error) {
	var table BIOSDirectoryTable
	var totalLength uint64

	r := bytes.NewBuffer(data)
	if err := readAndCountSize(r, binary.LittleEndian, &table.BIOSCookie, &totalLength); err != nil {
		return nil, 0, err
	}
	if table.BIOSCookie != BIOSDirectoryTableCookie && table.BIOSCookie != BIOSDirectoryTableLevel2Cookie {
		return nil, 0, fmt.Errorf("incorrect cookie: %d", table.BIOSCookie)
	}

	if err := readAndCountSize(r, binary.LittleEndian, &table.Checksum, &totalLength); err != nil {
		return nil, 0, err
	}

	if err := readAndCountSize(r, binary.LittleEndian, &table.TotalEntries, &totalLength); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &table.Reserved, &totalLength); err != nil {
		return nil, 0, err
	}

	sizeRequired := uint64(table.TotalEntries) * BIOSDirectoryTableEntrySize
	if uint64(r.Len()) < sizeRequired {
		return nil, 0, fmt.Errorf("not enough data, required: %d, actual: %d", sizeRequired+totalLength, len(data))
	}

	table.Entries = make([]BIOSDirectoryTableEntry, 0, table.TotalEntries)
	for idx := uint32(0); idx < table.TotalEntries; idx++ {
		entry, length, err := ParseBIOSDirectoryTableEntry(r)
		if err != nil {
			return nil, 0, err
		}
		table.Entries = append(table.Entries, *entry)
		totalLength += length
	}
	return &table, totalLength, nil
}

// ParseBIOSDirectoryTableEntry converts input bytes into BIOSDirectoryTableEntry
func ParseBIOSDirectoryTableEntry(r io.Reader) (*BIOSDirectoryTableEntry, uint64, error) {
	var entry BIOSDirectoryTableEntry
	var length uint64
	if err := readAndCountSize(r, binary.LittleEndian, &entry.Type, &length); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &entry.RegionType, &length); err != nil {
		return nil, 0, err
	}

	var flags uint8
	if err := readAndCountSize(r, binary.LittleEndian, &flags, &length); err != nil {
		return nil, 0, err
	}
	entry.ResetImage = flags&0x1 != 0
	entry.CopyImage = (flags>>1)&0x1 != 0
	entry.ReadOnly = (flags>>2)&0x1 != 0
	entry.Compressed = (flags>>3)&0x1 != 0
	entry.Instance = flags >> 4

	if err := readAndCountSize(r, binary.LittleEndian, &flags, &length); err != nil {
		return nil, 0, err
	}
	entry.Subprogram = flags & 7
	entry.RomID = (flags >> 3) & 0x3

	if err := readAndCountSize(r, binary.LittleEndian, &entry.Size, &length); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &entry.SourceAddress, &length); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &entry.DestinationAddress, &length); err != nil {
		return nil, 0, err
	}
	return &entry, length, nil
}

```

`pkg/amd/manifest/bios_directory_table_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"encoding/binary"
	"testing"
)

var biosDirectoryTableDataChunk = []byte{
	0x24, 0x42, 0x48, 0x44,
	0xd0, 0x75, 0xc5, 0xac,
	0x01, 0x00, 0x00, 0x00,
	0x40, 0x04, 0x00, 0x20,

	0x68,
	0x00,
	0x10,
	0x01,
	0x00, 0x20, 0x00, 0x00,
	0x00, 0x30, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
}

func TestBIOSDirectoryTableHeaderSize(t *testing.T) {
	const expectedBIOSDirectoryTableHeaderSize = 0x10
	actualSize := binary.Size(BIOSDirectoryTableHeader{})
	if actualSize != expectedBIOSDirectoryTableHeaderSize {
		t.Errorf("BIOSDirectoryTableHeader is incorrect: %d, expected %d", actualSize, expectedBIOSDirectoryTableHeaderSize)
	}
}

func TestFindBIOSDirectoryTable(t *testing.T) {
	firmwareChunk := []byte{
		0x12, 0x00, 0x15, 0x00, 0x15, // some prefix
	}

	t.Run("no_bios_table_cookie", func(t *testing.T) {
		table, _, err := FindBIOSDirectoryTable(firmwareChunk)
		if err == nil {
			t.Errorf("Expected an error when finding bios directory table in a broken firmware")
		}
		if table != nil {
			t.Errorf("Returned BIOS Directory table is not nil")
		}
	})

	t.Run("bios_table_cookie_found", func(t *testing.T) {
		table, r, err := FindBIOSDirectoryTable(append(firmwareChunk, biosDirectoryTableDataChunk...))
		if err != nil {
			t.Fatalf("Unexecpted error when finding BIOS Directory table: %v", err)
		}
		if r.Offset != uint64(len(firmwareChunk)) {
			t.Errorf("BIOS Directory Table address is incorrect: %d, expected: %d", r.Offset, uint64(len(firmwareChunk)))
		}
		if r.Length != uint64(len(biosDirectoryTableDataChunk)) {
			t.Errorf("BIOS Directory Table size is incorrect: %d, expected: %d", r.Length, uint64(len(biosDirectoryTableDataChunk)))
		}
		if table == nil {
			t.Errorf("Returned BIOS Directory table is nil")
		}
	})
}

func TestBiosDirectoryTableParsing(t *testing.T) {
	table, readBytes, err := ParseBIOSDirectoryTable(append(biosDirectoryTableDataChunk, 0xff))
	if err != nil {
		t.Fatalf("Failed to parse BIOS Directory table, err: %v", err)
	}
	if readBytes != uint64(len(biosDirectoryTableDataChunk)) {
		t.Errorf("BIOS Directory table read bytes is incorrect: %d, expected: %d", readBytes, len(biosDirectoryTableDataChunk))
	}
	if table == nil {
		t.Fatalf("result BIOS Directory table is nil")
	}

	if table.BIOSCookie != BIOSDirectoryTableCookie {
		t.Errorf("BIOSCookie is incorrect: %d, expected: %d", table.BIOSCookie, BIOSDirectoryTableCookie)
	}
	if table.Checksum != 0xacc575d0 {
		t.Errorf("Checksum is incorrect: %d, expected: %d", table.Checksum, 0xacc575d0)
	}
	if table.TotalEntries != 1 {
		t.Errorf("TotalEntries is incorrect: %d, expected: %d", table.TotalEntries, 1)
	}
	if len(table.Entries) != 1 {
		t.Fatalf("Result number of entries is incorrect: %d, expected: %d", len(table.Entries), 1)
	}

	entry := table.Entries[0]
	if entry.Type != 0x68 {
		t.Errorf("Table entry [0] type is incorrect: %d, expected: %d", table.Entries[0].Type, 0x68)
	}
	if entry.ResetImage {
		t.Errorf("Table entry [0] reset image is incorrect, expected false")
	}
	if entry.CopyImage {
		t.Errorf("Table entry [0] copy image is incorrect, expected false")
	}
	if entry.ReadOnly {
		t.Errorf("Table entry [0] read only is incorrect, expected false")
	}
	if entry.Compressed {
		t.Errorf("Table entry [0] compress is incorrect, expected false")
	}
	if entry.Instance != 1 {
		t.Errorf("Table entry [0] instance is incorrect, expected 1, got: %d", entry.Instance)
	}
	if entry.Subprogram != 1 {
		t.Errorf("Table entry [0] subprogram is incorrect, expected 1, got: %d", entry.Subprogram)
	}
	if entry.RomID != 0 {
		t.Errorf("Table entry [0] subprogram is incorrect, expected 9, got: %d", entry.RomID)
	}
	if entry.SourceAddress != 0x173000 {
		t.Errorf("Table entry [0] source address is incorrect: %x, expected: 0x173000",
			table.Entries[0].SourceAddress)
	}
	if entry.DestinationAddress != 0xffffffffffffffff {
		t.Errorf("Table entry [0] destination address is incorrect: %x, expected: 0xffffffffffffffff",
			table.Entries[0].DestinationAddress)
	}
}

func TestBrokenTotalEntriesBiosDirectoryParsing(t *testing.T) {
	biosDirectoryTableData := make([]byte, len(biosDirectoryTableDataChunk))
	copy(biosDirectoryTableData, biosDirectoryTableDataChunk)

	// 8 is offset of TotalEntries field
	biosDirectoryTableData[8] = 0xff
	biosDirectoryTableData[9] = 0xff
	biosDirectoryTableData[10] = 0xff
	biosDirectoryTableData[11] = 0xff

	_, _, err := ParseBIOSDirectoryTable(biosDirectoryTableData)
	if err == nil {
		t.Errorf("expected error when parsing incorrect psp directory table contents")
	}
}

```

`pkg/amd/manifest/checksum.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

const (
	biosDirectoryChecksumDataOffset = 8
	pspDirectoryChecksumDataOffset  = 8
)

// CalculateBiosDirectoryCheckSum calculates expected checksum of BIOS Directory represented in serialised form
func CalculateBiosDirectoryCheckSum(biosDirRaw []byte) uint32 {
	return fletcherCRC32(biosDirRaw[biosDirectoryChecksumDataOffset:])
}

// CalculatePSPDirectoryCheckSum calculates expected checksum of PSP Directory represented in serialised form
func CalculatePSPDirectoryCheckSum(pspDirRaw []byte) uint32 {
	return fletcherCRC32(pspDirRaw[pspDirectoryChecksumDataOffset:])
}

func fletcherCRC32(data []byte) uint32 {
	var c0, c1 uint32
	var i int
	l := (len(data) + 1) & ^1

	for l > 0 {
		blockLen := l
		if blockLen > 360*2 {
			blockLen = 360 * 2
		}
		l -= blockLen

		for {
			val := uint16(data[i])
			i++
			if i < len(data) {
				val += uint16(data[i]) << 8
				i++
			}
			c0 = c0 + uint32(val)
			c1 = c1 + c0
			blockLen -= 2
			if blockLen == 0 {
				break
			}
		}

		c0 = c0 % 65535
		c1 = c1 % 65535
	}
	return c1<<16 | c0
}

```

`pkg/amd/manifest/checksum_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"testing"
)

func TestFletcherCRC32(t *testing.T) {
	assertEqual := func(expected, actual uint32) {
		if expected != actual {
			t.Errorf("Expected: %d, but got: %d", expected, actual)
		}
	}
	assertEqual(0xF04FC729, fletcherCRC32([]byte("abcde")))
	assertEqual(0x56502D2A, fletcherCRC32([]byte("abcdef")))
	assertEqual(0xEBE19591, fletcherCRC32([]byte("abcdefgh")))
}

func TestPSPDirectoryCheckSum(t *testing.T) {
	actualCheckSum := CalculatePSPDirectoryCheckSum(pspDirectoryTableDataChunk)

	table, _, err := ParsePSPDirectoryTable(pspDirectoryTableDataChunk)
	if err != nil {
		t.Fatalf("Failed to parse PSP Directory table, err: %v", err)
	}
	if table.Checksum != actualCheckSum {
		t.Errorf("Incorrect checksum: 0x%X, expected: 0x%X", actualCheckSum, table.Checksum)
	}
}

func TestBIOSDirectoryCheckSum(t *testing.T) {
	actualCheckSum := CalculateBiosDirectoryCheckSum(biosDirectoryTableDataChunk)

	table, _, err := ParseBIOSDirectoryTable(biosDirectoryTableDataChunk)
	if err != nil {
		t.Fatalf("Failed to parse PSP Directory table, err: %v", err)
	}
	if table.Checksum != actualCheckSum {
		t.Errorf("Incorrect checksum: 0x%X, expected: 0x%X", actualCheckSum, table.Checksum)
	}
}

```

`pkg/amd/manifest/embedded_firmware_structure.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"

	bytes2 "github.com/linuxboot/fiano/pkg/bytes"
)

// Refer to: AMD Platform Security Processor BIOS Architecture Design Guide for AMD Family 17h and Family 19h
// Processors (NDA), Publication # 55758 Revision: 1.11 Issue Date: August 2020 (1)

// EmbeddedFirmwareStructureSignature is a special identifier of Firmware Embedded Structure
const EmbeddedFirmwareStructureSignature = 0x55aa55aa

// EmbeddedFirmwareStructure represents Embedded Firmware Structure defined in Table 2 in (1)
type EmbeddedFirmwareStructure struct {
	Signature                uint32
	Reserved1                [16]byte
	PSPDirectoryTablePointer uint32

	BIOSDirectoryTableFamily17hModels00h0FhPointer uint32
	BIOSDirectoryTableFamily17hModels10h1FhPointer uint32
	BIOSDirectoryTableFamily17hModels30h3FhPointer uint32
	Reserved2                                      uint32
	BIOSDirectoryTableFamily17hModels60h3FhPointer uint32

	Reserved3 [30]byte
}

// FindEmbeddedFirmwareStructure locates and parses Embedded Firmware Structure
func FindEmbeddedFirmwareStructure(firmware Firmware) (*EmbeddedFirmwareStructure, bytes2.Range, error) {
	var addresses = []uint64{
		0xfffa0000,
		0xfff20000,
		0xffe20000,
		0xffc20000,
		0xff820000,
		0xff020000,
	}

	image := firmware.ImageBytes()

	for _, addr := range addresses {
		offset := firmware.PhysAddrToOffset(addr)
		if offset+4 > uint64(len(image)) {
			continue
		}

		actualSignature := binary.LittleEndian.Uint32(image[offset:])
		if actualSignature == EmbeddedFirmwareStructureSignature {
			result, length, err := ParseEmbeddedFirmwareStructure(bytes.NewBuffer(image[offset:]))
			return result, bytes2.Range{Offset: offset, Length: length}, err
		}
	}
	return nil, bytes2.Range{}, fmt.Errorf("EmbeddedFirmwareStructure is not found")
}

// ParseEmbeddedFirmwareStructure converts input bytes into EmbeddedFirmwareStructure
func ParseEmbeddedFirmwareStructure(r io.Reader) (*EmbeddedFirmwareStructure, uint64, error) {
	var result EmbeddedFirmwareStructure
	if err := binary.Read(r, binary.LittleEndian, &result); err != nil {
		return nil, 0, err
	}

	if result.Signature != EmbeddedFirmwareStructureSignature {
		return nil, 0, fmt.Errorf("incorrect signature: %d", result.Signature)
	}
	return &result, uint64(binary.Size(result)), nil
}

```

`pkg/amd/manifest/embedded_firmware_structure_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"testing"
)

const embeddedFirmwareStructureLength = 0x4A

func TestFindEmbeddedFirmwareStructure(t *testing.T) {
	embeddedFirmwareStructureDataChunk := []byte{
		0xaa, 0x55, 0xaa, 0x55,

		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,

		0xaa, 0xbb, 0xcc, 0xdd,

		0x11, 0x22, 0x33, 0x44,
		0x00, 0x00, 0x12, 0x34,
		0x55, 0x66, 0x77, 0x88,
		0x00, 0x00, 0x00, 0x00,
		0xbb, 0xee, 0xaa, 0xff,
	}
	for len(embeddedFirmwareStructureDataChunk) < embeddedFirmwareStructureLength {
		embeddedFirmwareStructureDataChunk = append(embeddedFirmwareStructureDataChunk, 0x00)
	}

	dummyPrefix := []byte{0x1, 0x2, 0x3, 0x4}
	firmwareImage := append(dummyPrefix, embeddedFirmwareStructureDataChunk...)
	firmware := newDummyFirmware(firmwareImage, t)
	firmware.addMapping(
		0xfffa0000, 0,
	).addMapping(
		0xfff20000, 0,
	).addMapping(
		0xffe20000, 0,
	).addMapping(
		0xffc20000, 0,
	).addMapping(
		0xff820000, 0,
	).addMapping(
		0xff020000, uint64(len(dummyPrefix)),
	)

	efs, r, err := FindEmbeddedFirmwareStructure(firmware)
	if err != nil {
		t.Fatalf("finding embedded firmware structure failed: '%v'", err)
	}
	if r.Offset != uint64(len(dummyPrefix)) {
		t.Errorf("returned offset: '%d', expected: '%d'", r.Offset, len(dummyPrefix))
	}
	if r.Length != embeddedFirmwareStructureLength {
		t.Errorf("returned length: '%d', expected: '%d'", r.Length, embeddedFirmwareStructureLength)
	}
	if efs == nil {
		t.Fatalf("result embedded firmware structure is nil")
	}
	if efs.Signature != EmbeddedFirmwareStructureSignature {
		t.Errorf("actual EFS.signature: '%X', expected: '%X'", efs.Signature, EmbeddedFirmwareStructureSignature)
	}
	if efs.PSPDirectoryTablePointer != 0xddccbbaa {
		t.Errorf("actual efs.PSPDirectoryTablePointer: '%X', expected: '%X'", efs.PSPDirectoryTablePointer, 0xddccbbaa)
	}
	if efs.BIOSDirectoryTableFamily17hModels00h0FhPointer != 0x44332211 {
		t.Errorf("actual EFS.BIOSDirectoryTableFamily17hModels00h0FhPointer: '%X', expected: '%X'", efs.BIOSDirectoryTableFamily17hModels00h0FhPointer, 0x44332211)
	}
	if efs.BIOSDirectoryTableFamily17hModels10h1FhPointer != 0x34120000 {
		t.Errorf("actual EFS.BIOSDirectoryTableFamily17hModels10h1FhPointer: '%X', expected: '%X'", efs.BIOSDirectoryTableFamily17hModels10h1FhPointer, 0x34120000)
	}
	if efs.BIOSDirectoryTableFamily17hModels30h3FhPointer != 0x88776655 {
		t.Errorf("actual EFS.BIOSDirectoryTableFamily17hModels30h3FhPointer: '%X', expected: '%X'", efs.BIOSDirectoryTableFamily17hModels30h3FhPointer, 0x88776655)
	}
	if efs.BIOSDirectoryTableFamily17hModels60h3FhPointer != 0xffaaeebb {
		t.Errorf("actual EFS.BIOSDirectoryTableFamily17hModels60h3FhPointer: '%X', expected: '%X'", efs.BIOSDirectoryTableFamily17hModels60h3FhPointer, 0xffaaeebb)
	}
}

type dummyFirmware struct {
	image []byte
	t     *testing.T

	physToOffset map[uint64]uint64
	offsetToPhys map[uint64]uint64
}

func newDummyFirmware(image []byte, t *testing.T) *dummyFirmware {
	return &dummyFirmware{
		image:        image,
		t:            t,
		physToOffset: make(map[uint64]uint64),
		offsetToPhys: make(map[uint64]uint64),
	}
}

func (f *dummyFirmware) addMapping(physAddr, offset uint64) *dummyFirmware {
	f.physToOffset[physAddr] = offset
	f.offsetToPhys[offset] = physAddr
	return f
}

func (f *dummyFirmware) ImageBytes() []byte {
	return f.image
}

func (f *dummyFirmware) PhysAddrToOffset(physAddr uint64) uint64 {
	result, found := f.physToOffset[physAddr]
	if !found {
		f.t.Fatalf("physical address '%d' could not be mapped", physAddr)
	}
	return result
}

func (f *dummyFirmware) OffsetToPhysAddr(offset uint64) uint64 {
	result, found := f.offsetToPhys[offset]
	if !found {
		f.t.Fatalf("image offset '%d' could not be mapped", offset)
	}
	return result
}

```

`pkg/amd/manifest/firmware.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"fmt"

	bytes2 "github.com/linuxboot/fiano/pkg/bytes"
)

// Firmware is an abstraction of a firmware image, obtained for example via flashrom
type Firmware interface {
	ImageBytes() []byte
	PhysAddrToOffset(physAddr uint64) uint64
	OffsetToPhysAddr(offset uint64) uint64
}

// PSPFirmware contains essential parts of the AMD's PSP firmware internals
type PSPFirmware struct {
	EmbeddedFirmware      EmbeddedFirmwareStructure
	EmbeddedFirmwareRange bytes2.Range

	PSPDirectoryLevel1      *PSPDirectoryTable
	PSPDirectoryLevel1Range bytes2.Range
	PSPDirectoryLevel2      *PSPDirectoryTable
	PSPDirectoryLevel2Range bytes2.Range

	BIOSDirectoryLevel1      *BIOSDirectoryTable
	BIOSDirectoryLevel1Range bytes2.Range
	BIOSDirectoryLevel2      *BIOSDirectoryTable
	BIOSDirectoryLevel2Range bytes2.Range
}

// AMDFirmware represents an instance of firmware that exposes AMD specific
// meatadata and structure.
type AMDFirmware struct {
	// firmware is a reference to a generic firmware interface
	firmware Firmware

	// pspFirmware is a reference to PSPFirmware structure. It is built at
	// construction time and not exported.
	pspFirmware *PSPFirmware
}

// Firmware returns the internal reference to Firmawre interface
func (a *AMDFirmware) Firmware() Firmware {
	return a.firmware
}

// PSPFirmware returns the PSPFirmware reference held by the AMDFirmware object
func (a *AMDFirmware) PSPFirmware() *PSPFirmware {
	return a.pspFirmware
}

// parsePSPFirmware parses input firmware as PSP firmware image and
// collects Embedded firmware, PSP directory and BIOS directory structures
func parsePSPFirmware(firmware Firmware) (*PSPFirmware, error) {
	image := firmware.ImageBytes()

	var result PSPFirmware
	efs, r, err := FindEmbeddedFirmwareStructure(firmware)
	if err != nil {
		return nil, err
	}
	result.EmbeddedFirmware = *efs
	result.EmbeddedFirmwareRange = r

	var pspDirectoryLevel1 *PSPDirectoryTable
	var pspDirectoryLevel1Range bytes2.Range
	if efs.PSPDirectoryTablePointer != 0 && efs.PSPDirectoryTablePointer < uint32(len(image)) {
		var length uint64
		pspDirectoryLevel1, length, err = ParsePSPDirectoryTable(image[efs.PSPDirectoryTablePointer:])
		if err == nil {
			pspDirectoryLevel1Range.Offset = uint64(efs.PSPDirectoryTablePointer)
			pspDirectoryLevel1Range.Length = length
		}
	}
	if pspDirectoryLevel1 == nil {
		pspDirectoryLevel1, pspDirectoryLevel1Range, _ = FindPSPDirectoryTable(image)
	}
	if pspDirectoryLevel1 != nil {
		result.PSPDirectoryLevel1 = pspDirectoryLevel1
		result.PSPDirectoryLevel1Range = pspDirectoryLevel1Range

		for _, entry := range pspDirectoryLevel1.Entries {
			if entry.Type != PSPDirectoryTableLevel2Entry {
				continue
			}
			if entry.LocationOrValue != 0 && entry.LocationOrValue < uint64(len(image)) {
				pspDirectoryLevel2, length, err := ParsePSPDirectoryTable(image[entry.LocationOrValue:])
				if err == nil {
					result.PSPDirectoryLevel2 = pspDirectoryLevel2
					result.PSPDirectoryLevel2Range.Offset = entry.LocationOrValue
					result.PSPDirectoryLevel2Range.Length = length
				}
			}
			break
		}
	}

	var biosDirectoryLevel1 *BIOSDirectoryTable
	var biosDirectoryLevel1Range bytes2.Range

	biosDirectoryOffsets := []uint32{
		efs.BIOSDirectoryTableFamily17hModels00h0FhPointer,
		efs.BIOSDirectoryTableFamily17hModels10h1FhPointer,
		efs.BIOSDirectoryTableFamily17hModels30h3FhPointer,
		efs.BIOSDirectoryTableFamily17hModels60h3FhPointer,
	}
	for _, offset := range biosDirectoryOffsets {
		if offset == 0 || int(offset) > len(image) {
			continue
		}
		var length uint64
		biosDirectoryLevel1, length, err = ParseBIOSDirectoryTable(image[offset:])
		if err != nil {
			continue
		}
		biosDirectoryLevel1Range.Offset = uint64(offset)
		biosDirectoryLevel1Range.Length = length
		break
	}

	if biosDirectoryLevel1 == nil {
		biosDirectoryLevel1, biosDirectoryLevel1Range, _ = FindBIOSDirectoryTable(image)
	}

	if biosDirectoryLevel1 != nil {
		result.BIOSDirectoryLevel1 = biosDirectoryLevel1
		result.BIOSDirectoryLevel1Range = biosDirectoryLevel1Range

		for _, entry := range biosDirectoryLevel1.Entries {
			if entry.Type != BIOSDirectoryTableLevel2Entry {
				continue
			}
			if entry.SourceAddress != 0 && entry.SourceAddress < uint64(len(image)) {
				biosDirectoryLevel2, length, err := ParseBIOSDirectoryTable(image[entry.SourceAddress:])
				if err == nil {
					result.BIOSDirectoryLevel2 = biosDirectoryLevel2
					result.BIOSDirectoryLevel2Range.Offset = entry.SourceAddress
					result.BIOSDirectoryLevel2Range.Length = length
				}
			}
			break
		}
	}

	return &result, nil
}

// NewAMDFirmware returns an AMDFirmware structure or an error if internal firmware structures cannot be parsed
func NewAMDFirmware(firmware Firmware) (*AMDFirmware, error) {
	pspFirmware, err := parsePSPFirmware(firmware)
	if err != nil {
		return nil, fmt.Errorf("could not construct AMDFirmware, cannot parse PSP firmware: %w", err)
	}
	return &AMDFirmware{firmware: firmware, pspFirmware: pspFirmware}, nil

}

// FirmwareImage implements Firmware given image content.
type FirmwareImage []byte

var _ Firmware = (*FirmwareImage)(nil)

const basePhysAddr = 1 << 32 // "4GB"

// ImageBytes returns image content.
func (img FirmwareImage) ImageBytes() []byte {
	return []byte(img)
}

// PhysAddrToOffset maps a physical address to the offset in the image.
func (img FirmwareImage) PhysAddrToOffset(physAddr uint64) uint64 {
	startAddr := uint64(basePhysAddr - len(img))
	return physAddr - startAddr
}

// OffsetToPhysAddr maps an offset in the image to the physical address.
func (img FirmwareImage) OffsetToPhysAddr(offset uint64) uint64 {
	startAddr := uint64(basePhysAddr - len(img))
	return offset + startAddr
}

```

`pkg/amd/manifest/internal.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"encoding/binary"
	"io"
)

func readAndCountSize(r io.Reader, order binary.ByteOrder, data interface{}, counter *uint64) error {
	if err := binary.Read(r, order, data); err != nil {
		return err
	}
	if counter != nil {
		*counter += uint64(binary.Size(data))
	}
	return nil
}

```

`pkg/amd/manifest/psp_directory_table.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	bytes2 "github.com/linuxboot/fiano/pkg/bytes"
)

// Refer to: AMD Platform Security Processor BIOS Architecture Design Guide for AMD Family 17h and Family 19h
// Processors (NDA), Publication # 55758 Revision: 1.11 Issue Date: August 2020 (1)

// PSPDirectoryTableCookie is a special identifier of PSP Directory table level 1
const PSPDirectoryTableCookie = 0x50535024 // "$PSP"
// PSPDirectoryTableLevel2Cookie is a special identifier of PSP Directory table level 2
const PSPDirectoryTableLevel2Cookie = 0x324C5024 // "$PL2"

// PSPDirectoryTableEntryType is an entry type of PSP Directory table
type PSPDirectoryTableEntryType uint8

const (
	// AMDPublicKeyEntry denotes AMD public key entry in PSP Directory table
	AMDPublicKeyEntry PSPDirectoryTableEntryType = 0x00
	// PSPBootloaderFirmwareEntry denotes a PSP bootloader firmware entry in PSP Directory table
	PSPBootloaderFirmwareEntry PSPDirectoryTableEntryType = 0x01
	// PSPDirectoryTableLevel2Entry denotes an entry that points to PSP Directory table level 2
	PSPDirectoryTableLevel2Entry PSPDirectoryTableEntryType = 0x40
)

// PSPDirectoryTableEntry represents a single entry in PSP Directory Table
// Table 5 in (1)
type PSPDirectoryTableEntry struct {
	Type            PSPDirectoryTableEntryType
	Subprogram      uint8
	ROMId           uint8
	Size            uint32
	LocationOrValue uint64
}

const PSPDirectoryTableEntrySize = 16

// PSPDirectoryTableHeader represents a BIOS Directory Table Header
// Tables 3&4 from (1)
type PSPDirectoryTableHeader struct {
	PSPCookie      uint32
	Checksum       uint32
	TotalEntries   uint32
	AdditionalInfo uint32
}

// PSPDirectoryTable represents PSP Directory Table Header with all entries
// Table 5 in (1)
type PSPDirectoryTable struct {
	PSPDirectoryTableHeader

	Entries []PSPDirectoryTableEntry
}

func (p PSPDirectoryTable) String() string {
	var s strings.Builder
	cookieBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(cookieBytes, p.PSPCookie)
	fmt.Fprintf(&s, "PSP Cookie: 0x%x (%s)\n", p.PSPCookie, cookieBytes)
	fmt.Fprintf(&s, "Checksum: %d\n", p.Checksum)
	fmt.Fprintf(&s, "Total Entries: %d\n", p.TotalEntries)
	fmt.Fprintf(&s, "Additional Info: 0x%x\n\n", p.AdditionalInfo)
	fmt.Fprintf(&s, "%-5s | %-8s | %-5s | %-10s | %-10s\n",
		"Type",
		"Subprogram",
		"ROMId",
		"Size",
		"Location/Value")
	fmt.Fprintf(&s, "%s\n", "------------------------------------------------------------------------")
	for _, entry := range p.Entries {
		fmt.Fprintf(&s, "0x%-3x | 0x%-8x | 0x%-3x | %-10d | 0x%-10x\n",
			entry.Type,
			entry.Subprogram,
			entry.ROMId,
			entry.Size,
			entry.LocationOrValue)
	}
	return s.String()
}

// FindPSPDirectoryTable scans firmware for PSPDirectoryTableCookie
// and treats remaining bytes as PSPDirectoryTable
func FindPSPDirectoryTable(image []byte) (*PSPDirectoryTable, bytes2.Range, error) {
	// there is no predefined address, search through the whole memory
	cookieBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(cookieBytes, PSPDirectoryTableCookie)

	var offset uint64
	for {
		idx := bytes.Index(image, cookieBytes)
		if idx == -1 {
			break
		}

		table, length, err := ParsePSPDirectoryTable(image[idx:])
		if err != nil {
			shift := uint64(idx + len(cookieBytes))
			image = image[idx+len(cookieBytes):]
			offset += shift
			continue
		}
		return table, bytes2.Range{Offset: offset + uint64(idx), Length: length}, err
	}
	return nil, bytes2.Range{}, fmt.Errorf("PSPDirectoryTable is not found")
}

// ParsePSPDirectoryTable converts input bytes into PSPDirectoryTable
func ParsePSPDirectoryTable(data []byte) (*PSPDirectoryTable, uint64, error) {
	var table PSPDirectoryTable
	var totalLength uint64

	r := bytes.NewBuffer(data)
	if err := readAndCountSize(r, binary.LittleEndian, &table.PSPCookie, &totalLength); err != nil {
		return nil, 0, err
	}
	if table.PSPCookie != PSPDirectoryTableCookie && table.PSPCookie != PSPDirectoryTableLevel2Cookie {
		return nil, 0, fmt.Errorf("incorrect cookie: %d", table.PSPCookie)
	}
	if err := readAndCountSize(r, binary.LittleEndian, &table.Checksum, &totalLength); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &table.TotalEntries, &totalLength); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &table.AdditionalInfo, &totalLength); err != nil {
		return nil, 0, err
	}

	sizeRequired := uint64(table.TotalEntries) * PSPDirectoryTableEntrySize
	if uint64(r.Len()) < sizeRequired {
		return nil, 0, fmt.Errorf("not enough data, required: %d, actual: %d", sizeRequired+totalLength, len(data))
	}

	for idx := uint32(0); idx < table.TotalEntries; idx++ {
		entry, length, err := ParsePSPDirectoryTableEntry(r)
		if err != nil {
			return nil, 0, err
		}
		totalLength += length
		table.Entries = append(table.Entries, *entry)
	}
	return &table, totalLength, nil
}

// ParsePSPDirectoryTableEntry converts input bytes into PSPDirectoryTableEntry
func ParsePSPDirectoryTableEntry(r io.Reader) (*PSPDirectoryTableEntry, uint64, error) {
	var entry PSPDirectoryTableEntry
	var length uint64

	if err := readAndCountSize(r, binary.LittleEndian, &entry.Type, &length); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &entry.Subprogram, &length); err != nil {
		return nil, 0, err
	}

	var flags uint16
	if err := readAndCountSize(r, binary.LittleEndian, &flags, &length); err != nil {
		return nil, 0, err
	}
	entry.ROMId = uint8(flags>>14) & 0x3

	if err := readAndCountSize(r, binary.LittleEndian, &entry.Size, &length); err != nil {
		return nil, 0, err
	}
	if err := readAndCountSize(r, binary.LittleEndian, &entry.LocationOrValue, &length); err != nil {
		return nil, 0, err
	}
	return &entry, length, nil
}

```

`pkg/amd/manifest/psp_directory_table_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"encoding/binary"
	"testing"
)

var pspDirectoryTableDataChunk = []byte{
	0x24, 0x50, 0x53, 0x50,
	0x57, 0x4d, 0x3f, 0xfc,
	0x01, 0x00, 0x00, 0x00,
	0x10, 0x05, 0x00, 0x20,

	0x00,
	0x00,
	0x00, 0x00,
	0x40, 0x04, 0x00, 0x00,
	0x00, 0x24, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
}

func TestPSPDirectoryTableHeaderSize(t *testing.T) {
	const expectedPSPDirectoryTableHeaderSize = 0x10
	actualSize := binary.Size(PSPDirectoryTableHeader{})
	if actualSize != expectedPSPDirectoryTableHeaderSize {
		t.Errorf("BIOSDirectoryTableHeader is incorrect: %d, expected %d", actualSize, expectedPSPDirectoryTableHeaderSize)
	}
}

func TestFindPSPDirectoryTable(t *testing.T) {
	firmwareChunk := []byte{
		0x12, 0x00, 0x15, 0x00, 0x15, // some prefix
	}

	t.Run("no_psp_table_cookie", func(t *testing.T) {
		table, _, err := FindPSPDirectoryTable(firmwareChunk)
		if err == nil {
			t.Errorf("Expected an error when finding psp directory table in a broken firmware")
		}
		if table != nil {
			t.Errorf("Returned PSP Directory table is not nil")
		}
	})

	t.Run("psp_table_cookie_found", func(t *testing.T) {
		table, r, err := FindPSPDirectoryTable(append(firmwareChunk, pspDirectoryTableDataChunk...))
		if err != nil {
			t.Fatalf("Unexecpted error when finding PSP Directory table")
		}
		if r.Offset != uint64(len(firmwareChunk)) {
			t.Fatalf("PSP Directory Table address is incorrect: %d, expected: %d", r.Offset, uint64(len(firmwareChunk)))
		}
		if r.Length != uint64(len(pspDirectoryTableDataChunk)) {
			t.Errorf("PSP Directory Table size is incorrect: %d, expected: %d", r.Length, uint64(len(pspDirectoryTableDataChunk)))
		}
		if table == nil {
			t.Fatal("Returned PSP Directory table is nil")
		}
	})
}

func TestPspDirectoryTableParsing(t *testing.T) {
	data := append(pspDirectoryTableDataChunk, 0xff)
	table, length, err := ParsePSPDirectoryTable(data)
	if err != nil {
		t.Fatalf("Failed to parse PSP Directory table, err: %v", err)
	}
	if length != uint64(len(pspDirectoryTableDataChunk)) {
		t.Errorf("PSP Directory table read bytes is incorrect: %d, expected: %d", length, len(biosDirectoryTableDataChunk))
	}
	if table == nil {
		t.Fatal("result PSP Directory table is nil")
	}

	if table.PSPCookie != PSPDirectoryTableCookie {
		t.Errorf("PSPCookie is incorrect: %d, expected: %d", table.PSPCookie, PSPDirectoryTableCookie)
	}
	if table.Checksum != 0xfc3f4d57 {
		t.Errorf("Checksum is incorrect: %d, expected: %d", table.Checksum, 0xfc3f4d57)
	}
	if table.TotalEntries != 1 {
		t.Errorf("TotalEntries is incorrect: %d, expected: %d", table.TotalEntries, 1)
	}
	if len(table.Entries) != 1 {
		t.Fatalf("Result number of entries is incorrect: %d, expected: %d", len(table.Entries), 1)
	}

	if table.Entries[0].Type != AMDPublicKeyEntry {
		t.Errorf("Table entry [0] type is incorrect: %d, expected: %d", table.Entries[0].Type, AMDPublicKeyEntry)
	}
	if table.Entries[0].Subprogram != 0 {
		t.Errorf("Table entry [0] subprogram is incorrect: %d, expected: %d", table.Entries[0].Subprogram, 0)
	}
	if table.Entries[0].LocationOrValue != 0x62400 {
		t.Errorf("Table entry [0] location is incorrect: %d, expected: 0x62400", table.Entries[0].LocationOrValue)
	}
}

func TestBrokenTotalEntriesPspDirectoryParsing(t *testing.T) {
	pspDirectoryTableData := make([]byte, len(pspDirectoryTableDataChunk))
	copy(pspDirectoryTableData, pspDirectoryTableDataChunk)

	// 8 is offset of TotalEntries field
	pspDirectoryTableData[8] = 0xff
	pspDirectoryTableData[9] = 0xff
	pspDirectoryTableData[10] = 0xff
	pspDirectoryTableData[11] = 0xff

	_, _, err := ParsePSPDirectoryTable(pspDirectoryTableData)
	if err == nil {
		t.Errorf("expected error when parsing incorrect psp directory table contents")
	}
}

```

`pkg/amd/manifest/psp_header.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"encoding/binary"
	"fmt"
	"io"
)

// PSPBootloaderCookie is a special identifier of a PSP binary
const PSPBootloaderCookie = 0x31535024 // "$PS1"

// FirmwareVersion represents PSP firmware version
type FirmwareVersion [4]byte

// String converts FirmwareVersion into a string
func (v FirmwareVersion) String() string {
	return fmt.Sprintf("%x.%x.%x.%x", v[3], v[2], v[1], v[0])
}

// PSPHeader represents a header of each firmware binary
// See: https://doc.coreboot.org/soc/amd/psp_integration.html
type PSPHeader struct {
	Reserved1 [16]byte
	Cookie    uint32
	Reserved2 [76]byte
	Version   FirmwareVersion
	Reserved3 [156]byte
}

// Reserved1Offset returns the offset in bytes of field Reserved1
func (h *PSPHeader) Reserved1Offset() uint64 {
	return 0
}

func (h *PSPHeader) Reserved1Length() uint64 {
	return uint64(binary.Size(h.Reserved1))
}

// CookieOffset returns the offset in bytes of field Cookie
func (h *PSPHeader) CookieOffset() uint64 {
	return h.Reserved1Offset() + h.Reserved1Length()
}

// CookieLength returns the size in bytes of field Cookie
func (h *PSPHeader) CookieLength() uint64 {
	return uint64(binary.Size(h.Cookie))
}

// Reserved2Offset returns the offset in bytes of field Reserved2
func (h *PSPHeader) Reserved2Offset() uint64 {
	return h.CookieOffset() + h.CookieLength()
}

// Reserved2Length returns the size in bytes of field Reserved2
func (h *PSPHeader) Reserved2Length() uint64 {
	return uint64(binary.Size(h.Reserved2))
}

// VersionOffset returns the offset in bytes of field Version
func (h *PSPHeader) VersionOffset() uint64 {
	return h.Reserved2Offset() + h.Reserved2Length()
}

// VersionLength returns the size in bytes of field Version
func (h *PSPHeader) VersionLength() uint64 {
	return uint64(binary.Size(h.Version))
}

// ParsePSPHeader parses the PSP header that is supposed to be the beginning of each PSP binary
func ParsePSPHeader(r io.Reader) (*PSPHeader, error) {
	var result PSPHeader
	if err := binary.Read(r, binary.LittleEndian, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

```

`pkg/amd/manifest/psp_header_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package manifest

import (
	"bytes"
	"testing"
)

func TestPSPHeaderParsing(t *testing.T) {
	pspHeaderRaw := []byte{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x24, 0x50, 0x53, 0x31, 0xc0, 0x50, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x1e, 0x47, 0xa9, 0x18, 0xc0, 0x14, 0xd6, 0x5d, 0x3f, 0xcd, 0xe7, 0xbe, 0x98, 0x66, 0x2b, 0xf8,
		0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92,
		0x92, 0xa7, 0xae, 0x67, 0x1d, 0x8, 0x3f, 0xb6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0,
		0x57, 0x0, 0x13, 0x0, 0xff, 0xff, 0x1, 0x17, 0x0, 0x1, 0x0, 0x0, 0xc0, 0x53, 0x1, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,
		0xe9, 0x92, 0x10, 0xa2, 0x7c, 0xc8, 0x35, 0xfa, 0xff, 0xf2, 0x77, 0x24, 0x21, 0xf6, 0x90, 0x6d,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0xee, 0x32, 0xb5, 0x3a, 0xe6, 0x2d, 0xf0, 0xe8, 0x99, 0x12, 0x15, 0x49, 0xdf, 0x9f, 0x0, 0x69,
		0xc9, 0xcc, 0x88, 0x88, 0x41, 0x7b, 0xc, 0xe4, 0x83, 0x76, 0x3, 0xc2, 0x27, 0x4e, 0xd3, 0xc5,
		0xee, 0x2d, 0x11, 0x84, 0x3c, 0x25, 0x47, 0xa4, 0x40, 0xe1, 0x25, 0xb1, 0xfa, 0x1a, 0x3a, 0x6a,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	}
	pspHeader, err := ParsePSPHeader(bytes.NewBuffer(pspHeaderRaw))
	if err != nil {
		t.Errorf("Expected no error when pasrsing PSPHeader, got: %v", err)
		t.Fail()
	}
	if pspHeader.Cookie != PSPBootloaderCookie {
		t.Errorf("Expected '%d' cookie in PSPHeader, got: '%d'", PSPBootloaderCookie, pspHeader.Cookie)
	}
	if pspHeader.Version.String() != "0.13.0.57" {
		t.Errorf("Expected '0.13.0.57' version in PSPHeader, got: '%s'", pspHeader.Version.String())
	}
}

```

`pkg/amd/psb/biosentries.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"errors"
	"fmt"
	"os"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
	bytes2 "github.com/linuxboot/fiano/pkg/bytes"

	"github.com/jedib0t/go-pretty/v6/table"
)

// BIOSEntryType defines the type to hold BIOS Entry Type fields
type BIOSEntryType uint8

/*
 * Nicely output human-readable names for BIOS Entry Types
 *
 * This doesn't have all the entries mapped, there are still
 * several more pages left. It does have all the types
 * encountered in the firmware images used to test
 * however.
 *
 */
func (_type BIOSEntryType) String() string {
	switch _type {
	case 0x05:
		return "BIOS_PUBLIC_KEY"
	case 0x07:
		return "BIOS_RTM_SIGNATURE"
	case 0x60:
		return "AGESA_PSP_CUSTOMIZATION_BLOCK"
	case 0x61:
		return "AGESA_PSP_OUTPUT_BLOCK"
	case 0x62:
		return "BIOS_BINARY"
	case 0x63:
		return "AGESA_PSP_OUTPUT_BLOCK_NV_COPY"
	case 0x64:
		return "PMU_FIRMWARE_INSTRUCTION_PORTION"
	case 0x65:
		return "PMU_FIRMWARE_DATA_PORTION"
	case 0x66:
		return "MICROCODE_PATCH"
	case 0x67:
		return "CORE_MACHINE_EXCEPTION_DATA"
	case 0x68:
		return "BACKUP_AGESA_PSP_CUSTOMIZATION_BLOCK"
	case 0x69:
		return "INTERPRETER_BINARY_VIDEO"
	case 0x6A:
		return "MP2_FIRMWARE_CONFIG"
	case 0x6B:
		return "MAIN_MEMORY"
	case 0x6C:
		return "MPM_CONFIG"
	case 0x70:
		return "BIOS_DIRECTORY_TABLE_LEVEL_2"
	}
	return "UNKNOWN"

}

func getBIOSTable(pspFirmware *amd_manifest.PSPFirmware, biosLevel uint) (*amd_manifest.BIOSDirectoryTable, error) {
	switch biosLevel {
	case 1:
		return pspFirmware.BIOSDirectoryLevel1, nil
	case 2:
		return pspFirmware.BIOSDirectoryLevel2, nil
	}
	return nil, fmt.Errorf("cannot extract key database, invalid BIOS Directory Level requested: %d", biosLevel)
}

// OutputBIOSEntries outputs the BIOS entries in an ASCII table format
func OutputBIOSEntries(amdFw *amd_manifest.AMDFirmware) error {
	biosDirectoryLevel1Table, err := getBIOSTable(amdFw.PSPFirmware(), 1)
	if err != nil {
		return fmt.Errorf("unable to retrieve BIOS Directory Level 1 Entries: %w", err)
	}

	biosDirectoryLevel2Table, err := getBIOSTable(amdFw.PSPFirmware(), 2)
	if err != nil {
		return fmt.Errorf("unable to retrieve BIOS Directory Level 2 Entries: %w", err)
	}

	biosDirectories := []amd_manifest.BIOSDirectoryTable{*biosDirectoryLevel1Table, *biosDirectoryLevel2Table}

	for idx, directory := range biosDirectories {
		// BIOS Header
		h := table.NewWriter()
		h.SetOutputMirror(os.Stdout)
		h.SetTitle("BIOS Directory Level %d Header", idx+1)
		biosCookie := fmt.Sprintf("0x%x", directory.BIOSCookie)
		biosChecksum := directory.Checksum
		biosTotalEntries := directory.TotalEntries
		h.AppendHeader(table.Row{"BIOS Cookie", "Checksum", "Total Entries"})
		h.AppendRow([]interface{}{biosCookie, biosChecksum, biosTotalEntries})
		h.Render()

		// BIOS Entries
		t := table.NewWriter()
		t.SetOutputMirror(os.Stdout)
		t.SetTitle("BIOS Directory Level %d", idx+1)
		t.AppendHeader(table.Row{
			"Type",
			"Type Hex",
			"RegionType",
			"ResetImage",
			"CopyImage",
			"ReadOnly",
			"Compressed",
			"Instance",
			"Subprogram",
			"RomID",
			"Size",
			"Source Address",
			"Destination Address",
		})
		for _, entry := range directory.Entries {
			entryType := BIOSEntryType(entry.Type)
			entryTypeHex := fmt.Sprintf("0x%-3x", entry.Type)
			entryRegionType := fmt.Sprintf("0x%-8x", entry.RegionType)
			entryResetImage := fmt.Sprintf("%-10v", entry.ResetImage)
			entryCopyImage := fmt.Sprintf("%-9v", entry.CopyImage)
			entryReadOnly := fmt.Sprintf("%-8v", entry.ReadOnly)
			entryCompressed := fmt.Sprintf("%-10v", entry.Compressed)
			entryInstance := fmt.Sprintf("0x%-6x", entry.Instance)
			entrySubprogram := fmt.Sprintf("0x%-8x", entry.Subprogram)
			entryRomID := fmt.Sprintf("0x%-3x", entry.RomID)
			entrySize := fmt.Sprintf("%-6d", entry.Size)
			entrySourceAddress := fmt.Sprintf("0x%-11x", entry.SourceAddress)
			entryDestinationAddress := fmt.Sprintf("0x%-18x", entry.DestinationAddress)
			t.AppendRow([]interface{}{
				entryType,
				entryTypeHex,
				entryRegionType,
				entryResetImage,
				entryCopyImage,
				entryReadOnly,
				entryCompressed,
				entryInstance,
				entrySubprogram,
				entryRomID,
				entrySize,
				entrySourceAddress,
				entryDestinationAddress,
			})
		}
		t.Render()
	}
	return nil
}

// ValidateRTM validates signature of RTM volume and BIOS directory table concatenated
func ValidateRTM(amdFw *amd_manifest.AMDFirmware, biosLevel uint) (*SignatureValidationResult, error) {
	pspFw := amdFw.PSPFirmware()

	// Get the byte range we'll need on the BIOS depending on the level
	var biosDirectoryRange bytes2.Range
	var directory DirectoryType
	switch biosLevel {
	case 1:
		biosDirectoryRange = pspFw.BIOSDirectoryLevel1Range
		directory = BIOSDirectoryLevel1
	case 2:
		biosDirectoryRange = pspFw.BIOSDirectoryLevel2Range
		directory = BIOSDirectoryLevel2
	default:
		return nil, fmt.Errorf("cannot extract raw BIOS entry, invalid BIOS Directory Level requested: %d", biosLevel)
	}

	// extract RTM Volume and signature
	rtmVolume, err := ExtractBIOSEntry(amdFw, biosLevel, BIOSRTMVolumeEntry, 0)
	if err != nil {
		return nil, fmt.Errorf("could not extract BIOS entry corresponding to RTM volume (%x): %w", BIOSRTMVolumeEntry, err)
	}

	oemKey, err := GetPSBSignBIOSKey(amdFw, biosLevel)
	if err != nil {
		return nil, err
	}

	rtmVolumeSignature, err := ExtractBIOSEntry(amdFw, biosLevel, BIOSRTMSignatureEntry, 0)
	if err != nil {
		return nil, fmt.Errorf("could not extract BIOS entry corresponding to RTM volume signature (%x): %w", BIOSRTMSignatureEntry, err)
	}

	// signature of RTM volume is calculated over the concatenation of RTM volume itself and
	// BIOS directory table
	firmwareBytes := amdFw.Firmware().ImageBytes()

	biosDirectoryStart := biosDirectoryRange.Offset
	biosDirectoryEnd := biosDirectoryStart + biosDirectoryRange.Length

	if err := checkBoundaries(biosDirectoryStart, biosDirectoryEnd, firmwareBytes); err != nil {
		return nil, newErrInvalidFormatWithItem(newDirectoryItem(directory),
			fmt.Errorf("could not extract BIOS Level %d directory, boundary check error: %w", biosLevel, err))
	}

	/**
	 * This is needed due to the fact in the Level 2 BIOS Directory Table,
	 * instead of RTM Volume + Level 2 Header for the signed data, it's actually
	 * RTM Volume + Level 1 Header + Level 2 Header
	 */
	if biosLevel == 2 {
		biosDirectoryLevel1Start := pspFw.BIOSDirectoryLevel1Range.Offset
		biosDirectoryLevel1End := biosDirectoryLevel1Start + pspFw.BIOSDirectoryLevel1Range.Length

		if err := checkBoundaries(biosDirectoryLevel1Start, biosDirectoryLevel1End, firmwareBytes); err != nil {
			return nil, newErrInvalidFormatWithItem(newDirectoryItem(BIOSDirectoryLevel1),
				fmt.Errorf("could not extract BIOS Level 1 directory, boundary check error: %w", err))
		}

		biosDirectoryTableBytes := firmwareBytes[biosDirectoryLevel1Start:biosDirectoryLevel1End]
		rtmVolume = append(rtmVolume, biosDirectoryTableBytes...)
	}

	biosDirectoryTableBytes := firmwareBytes[biosDirectoryStart:biosDirectoryEnd]
	rtmVolume = append(rtmVolume, biosDirectoryTableBytes...)

	_, err = NewSignedBlob(reverse(rtmVolumeSignature), rtmVolume, oemKey)
	return &SignatureValidationResult{signedElement: "RTM Volume concatenated with BIOS Directory", signingKey: oemKey, err: err}, nil
}

// GetPSBSignBIOSKey returns and OEM Key that is used to sign BIOS during PSB enabled
func GetPSBSignBIOSKey(amdFw *amd_manifest.AMDFirmware, biosLevel uint) (*Key, error) {
	keySet, err := GetKeys(amdFw, biosLevel)
	if err != nil {
		return nil, fmt.Errorf("could not extract key from firmware: %w", err)
	}

	oemKeySet, err := keySet.KeysetFromType(OEMKey)
	if err != nil {
		return nil, addFirmwareItemToError(err, newBIOSDirectoryEntryItem(uint8(biosLevel), OEMSigningKeyEntry, 0))
	}
	oemKeys := oemKeySet.AllKeyIDs()
	switch len(oemKeys) {
	case 0:
		return nil, newErrNotFound(newBIOSDirectoryEntryItem(uint8(biosLevel), OEMSigningKeyEntry, 0))
	case 1:
		// should be only 1 OEM key
	default:
		return nil, newErrInvalidFormatWithItem(
			newBIOSDirectoryEntryItem(uint8(biosLevel), OEMSigningKeyEntry, 0),
			fmt.Errorf("multiple '%d' OEM keys", len(oemKeys)),
		)
	}

	oemKey := keySet.GetKey(oemKeys[0])
	if oemKey.data.KeyUsageFlag != PSBSignBIOS {
		return nil, newErrInvalidFormatWithItem(
			newBIOSDirectoryEntryItem(uint8(biosLevel), OEMSigningKeyEntry, 0),
			fmt.Errorf("incorrect key usage '%d', expected: '%d'", oemKey.data.KeyUsageFlag, PSBSignBIOS),
		)
	}
	return oemKey, nil
}

// IsPSBEnabled checks if firmware has PSB enabled
func IsPSBEnabled(amdFw *amd_manifest.AMDFirmware) (bool, error) {
	checkPSBEnabled := func(biosLevel uint) (bool, error) {
		_, err := GetBIOSEntry(amdFw.PSPFirmware(), 2, OEMSigningKeyEntry, 0)
		if err == nil {
			return true, nil
		}
		if errors.As(err, &ErrNotFound{}) {
			return false, nil
		}
		return false, err
	}

	if amdFw.PSPFirmware().BIOSDirectoryLevel2 != nil {
		return checkPSBEnabled(2)
	}
	if amdFw.PSPFirmware().BIOSDirectoryLevel1 != nil {
		return checkPSBEnabled(1)
	}
	// Can happen in pre-ODM firmware: no bios directories -> no PSB :)
	return false, nil
}

```

`pkg/amd/psb/common.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"fmt"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
)

// ParseAMDFirmware parses AMD firmware from the image bytes
func ParseAMDFirmware(image []byte) (*amd_manifest.AMDFirmware, error) {
	amdFw, err := amd_manifest.NewAMDFirmware(amd_manifest.FirmwareImage(image))
	if err != nil {
		return nil, fmt.Errorf("could not parse AMD Firmware: %w", err)
	}
	return amdFw, nil
}

```

`pkg/amd/psb/entries.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"fmt"
	"io"
	"sort"
	"strings"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
	bytes2 "github.com/linuxboot/fiano/pkg/bytes"
)

// DirectoryType denotes specific firmware table in PSP firmware
type DirectoryType uint8

const (
	// PSPDirectoryLevel1 represents PSP directory table level 1
	PSPDirectoryLevel1 DirectoryType = iota

	// PSPDirectoryLevel2 represents PSP directory table level 2
	PSPDirectoryLevel2

	// BIOSDirectoryLevel1 represents BIOS directory table level 1
	BIOSDirectoryLevel1

	// BIOSDirectoryLevel2 represents BIOS directory table level 2
	BIOSDirectoryLevel2
)

var allDirectoryTypes = []DirectoryType{
	PSPDirectoryLevel1,
	PSPDirectoryLevel2,
	BIOSDirectoryLevel1,
	BIOSDirectoryLevel2,
}

// AllDirectoryTypes returns all directory types
func AllDirectoryTypes() []DirectoryType {
	result := make([]DirectoryType, len(allDirectoryTypes))
	copy(result, allDirectoryTypes)
	return result
}

// ShortName returns a short name of directory type
func (t DirectoryType) ShortName() string {
	switch t {
	case PSPDirectoryLevel1:
		return "PSPDirectoryLevel1"
	case PSPDirectoryLevel2:
		return "PSPDirectoryLevel2"
	case BIOSDirectoryLevel1:
		return "BIOSDirectoryLevel1"
	case BIOSDirectoryLevel2:
		return "BIOSDirectoryLevel2"
	}
	return fmt.Sprintf("Unknown firmware directory type: '%d'", t)
}

func (t DirectoryType) String() string {
	switch t {
	case PSPDirectoryLevel1:
		return "PSP directory level 1"
	case PSPDirectoryLevel2:
		return "PSP directory level 2"
	case BIOSDirectoryLevel1:
		return "BIOS directory level 1"
	case BIOSDirectoryLevel2:
		return "BIOS directory level 2"
	}
	return fmt.Sprintf("Unknown PSP firmware directory type: '%d'", t)
}

// Level returns the directory level
func (t DirectoryType) Level() uint {
	switch t {
	case PSPDirectoryLevel1:
		return 1
	case PSPDirectoryLevel2:
		return 2
	case BIOSDirectoryLevel1:
		return 1
	case BIOSDirectoryLevel2:
		return 2
	}
	panic(fmt.Sprintf("Not supported directory type: %d", t))
}

// DirectoryTypeFromString converts a string into DirectoryType
func DirectoryTypeFromString(in string) (DirectoryType, error) {
	for _, dt := range allDirectoryTypes {
		if strings.EqualFold(dt.ShortName(), in) {
			return dt, nil
		}
	}
	return 0, fmt.Errorf("unknown directory type: %s", in)
}

// GetPSPDirectoryOfLevel returns the PSP directory of a certain level
func GetPSPDirectoryOfLevel(level uint) (DirectoryType, error) {
	switch level {
	case 1:
		return PSPDirectoryLevel1, nil
	case 2:
		return PSPDirectoryLevel2, nil
	}
	return 0, fmt.Errorf("invalid PSP directory level: %d", level)
}

// GetBIOSDirectoryOfLevel returns the BIOS directory of a certain level
func GetBIOSDirectoryOfLevel(level uint) (DirectoryType, error) {
	switch level {
	case 1:
		return BIOSDirectoryLevel1, nil
	case 2:
		return BIOSDirectoryLevel2, nil
	}
	return 0, fmt.Errorf("invalid BIOS directory level: %d", level)
}

// GetBIOSEntries returns all entries of a certain type from BIOS directory sorted by instance
func GetBIOSEntries(
	pspFirmware *amd_manifest.PSPFirmware,
	biosLevel uint,
	entryID amd_manifest.BIOSDirectoryTableEntryType,
) ([]amd_manifest.BIOSDirectoryTableEntry, error) {
	biosTable, err := getBIOSTable(pspFirmware, biosLevel)
	if err != nil {
		return nil, err
	}

	if biosTable == nil {
		directory, err := GetBIOSDirectoryOfLevel(biosLevel)
		if err != nil {
			return nil, fmt.Errorf("unknown bios directory of level %d", biosLevel)
		}
		return nil, newErrNotFound(newDirectoryItem(directory))
	}

	var biosTableEntries []amd_manifest.BIOSDirectoryTableEntry
	for _, entry := range biosTable.Entries {
		if entry.Type == entryID {
			biosTableEntries = append(biosTableEntries, entry)
		}
	}

	sort.Slice(biosTableEntries, func(i, j int) bool {
		return biosTableEntries[i].Instance < biosTableEntries[j].Instance
	})
	return biosTableEntries, nil
}

// GetBIOSEntry returns a singe entry of a certain type from BIOS directory, returns error if multiple entries are found
func GetBIOSEntry(
	pspFirmware *amd_manifest.PSPFirmware,
	biosLevel uint,
	entryID amd_manifest.BIOSDirectoryTableEntryType,
	instance uint8,
) (*amd_manifest.BIOSDirectoryTableEntry, error) {
	entries, err := GetBIOSEntries(pspFirmware, biosLevel, entryID)
	if err != nil {
		return nil, err
	}

	var result *amd_manifest.BIOSDirectoryTableEntry
	for idx := range entries {
		if entries[idx].Instance == uint8(instance) {
			if result != nil {
				directory, err := GetBIOSDirectoryOfLevel(biosLevel)
				if err != nil {
					return nil, fmt.Errorf("unknown bios directory of level %d", biosLevel)
				}
				return nil, newErrInvalidFormatWithItem(
					newDirectoryItem(directory),
					fmt.Errorf("multiple entriers %x of instance %d are found in BIOS directory level %d", entryID, instance, biosLevel),
				)
			}
			result = &entries[idx]
		}
	}

	if result == nil {
		return nil, newErrNotFound(newBIOSDirectoryEntryItem(uint8(biosLevel), entryID, instance))
	}
	return result, nil
}

// GetPSPEntries returns all entries of a certain type from PSP directory
func GetPSPEntries(
	pspFirmware *amd_manifest.PSPFirmware,
	pspLevel uint,
	entryID amd_manifest.PSPDirectoryTableEntryType,
) ([]amd_manifest.PSPDirectoryTableEntry, error) {
	pspTable, err := getPSPTable(pspFirmware, pspLevel)
	if err != nil {
		return nil, err
	}
	if pspTable == nil {
		directory, err := GetPSPDirectoryOfLevel(pspLevel)
		if err != nil {
			return nil, fmt.Errorf("unknown psp directory of level %d", pspLevel)
		}
		return nil, newErrNotFound(newDirectoryItem(directory))
	}
	var entries []amd_manifest.PSPDirectoryTableEntry
	for _, entry := range pspTable.Entries {
		if entry.Type == entryID {
			entries = append(entries, entry)
		}
	}
	return entries, nil
}

// GetPSPEntry returns a singe entry of a certain type from PSP directory, returns error if multiple entries are found
func GetPSPEntry(
	pspFirmware *amd_manifest.PSPFirmware,
	pspLevel uint,
	entryID amd_manifest.PSPDirectoryTableEntryType,
) (*amd_manifest.PSPDirectoryTableEntry, error) {
	entries, err := GetPSPEntries(pspFirmware, pspLevel, entryID)
	if err != nil {
		return nil, err
	}
	if len(entries) == 0 {
		return nil, newErrNotFound(newPSPDirectoryEntryItem(uint8(pspLevel), entryID))
	}
	if len(entries) > 1 {
		directory, err := GetPSPDirectoryOfLevel(pspLevel)
		if err != nil {
			return nil, fmt.Errorf("unknown psp directory of level %d", pspLevel)
		}
		return nil, newErrInvalidFormatWithItem(
			newDirectoryItem(directory),
			fmt.Errorf("multiple entriers %x are found in PSP directory level %d", entryID, pspLevel),
		)
	}
	return &entries[0], err
}

// GetEntries returns a list of specific type PSP entries
func GetEntries(pspFirmware *amd_manifest.PSPFirmware, directory DirectoryType, entryID uint32) ([]bytes2.Range, error) {
	var entries []bytes2.Range
	switch directory {
	case PSPDirectoryLevel1, PSPDirectoryLevel2:
		pspEntries, err := GetPSPEntries(pspFirmware, directory.Level(), amd_manifest.PSPDirectoryTableEntryType(entryID))
		if err != nil {
			return nil, err
		}

		for _, entry := range pspEntries {
			entries = append(entries, bytes2.Range{Offset: entry.LocationOrValue, Length: uint64(entry.Size)})
		}
	case BIOSDirectoryLevel1, BIOSDirectoryLevel2:
		biosEntries, err := GetBIOSEntries(pspFirmware, directory.Level(), amd_manifest.BIOSDirectoryTableEntryType(entryID))
		if err != nil {
			return nil, err
		}

		for _, entry := range biosEntries {
			entries = append(entries, bytes2.Range{Offset: entry.SourceAddress, Length: uint64(entry.Size)})
		}
	default:
		return nil, fmt.Errorf("unsopprted directory type: %s", directory)
	}
	return entries, nil
}

// GetRangeBytes converts firmware range to continues bytes sequence
// TODO: should be moved to fiano's bytes2
func GetRangeBytes(image []byte, start, length uint64) ([]byte, error) {
	end := start + length
	if err := checkBoundaries(start, end, image); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("boundary check fail: %w", err))
	}
	return image[start:end], nil
}

// ExtractPSPEntry extracts a single generic raw entry from PSP Directory.
// Returns an error if multiple entries are found as PSP directory is supposed to have no more than a single entry for each type
func ExtractPSPEntry(amdFw *amd_manifest.AMDFirmware, pspLevel uint, entryID amd_manifest.PSPDirectoryTableEntryType) ([]byte, error) {
	entry, err := GetPSPEntry(amdFw.PSPFirmware(), pspLevel, entryID)
	if err != nil {
		return nil, err
	}
	data, err := GetRangeBytes(amdFw.Firmware().ImageBytes(), entry.LocationOrValue, uint64(entry.Size))
	if err != nil {
		if errInvalidFormat, ok := err.(ErrInvalidFormat); ok {
			return nil, newErrInvalidFormatWithItem(newPSPDirectoryEntryItem(uint8(pspLevel), entryID), errInvalidFormat.Unwrap())
		}
		return nil, err
	}
	return data, nil
}

// ExtractBIOSEntry extracts a single generic raw entry from BIOS Directory.
func ExtractBIOSEntry(amdFw *amd_manifest.AMDFirmware, biosLevel uint, entryID amd_manifest.BIOSDirectoryTableEntryType, instance uint8) ([]byte, error) {
	entry, err := GetBIOSEntry(amdFw.PSPFirmware(), biosLevel, entryID, instance)
	if err != nil {
		return nil, err
	}
	data, err := GetRangeBytes(amdFw.Firmware().ImageBytes(), entry.SourceAddress, uint64(entry.Size))
	if err != nil {
		if errInvalidFormat, ok := err.(ErrInvalidFormat); ok {
			return nil, newErrInvalidFormatWithItem(newBIOSDirectoryEntryItem(uint8(biosLevel), entryID, instance), errInvalidFormat.Unwrap())
		}
		return nil, err
	}
	return data, nil
}

// DumpPSPEntry dumps an entry from PSP Directory
func DumpPSPEntry(amdFw *amd_manifest.AMDFirmware, pspLevel uint, entryID amd_manifest.PSPDirectoryTableEntryType, w io.Writer) (int, error) {
	data, err := ExtractPSPEntry(amdFw, pspLevel, entryID)
	if err != nil {
		return 0, err
	}
	return w.Write(data)
}

// DumpBIOSEntry dumps an entry from BIOS directory
func DumpBIOSEntry(amdFw *amd_manifest.AMDFirmware, biosLevel uint, entryID amd_manifest.BIOSDirectoryTableEntryType, instance uint8, w io.Writer) (int, error) {
	data, err := ExtractBIOSEntry(amdFw, biosLevel, entryID, instance)
	if err != nil {
		return 0, err
	}
	return w.Write(data)
}

// PatchPSPEntry takes an AmdFirmware object and modifies one entry in PSP directory.
// The modified entry is read from `r` reader object, while the modified firmware is written into `w` writer object.
func PatchPSPEntry(amdFw *amd_manifest.AMDFirmware, pspLevel uint, entryID amd_manifest.PSPDirectoryTableEntryType, r io.Reader, w io.Writer) (int, error) {
	entry, err := GetPSPEntry(amdFw.PSPFirmware(), pspLevel, entryID)
	if err != nil {
		return 0, err
	}

	start := entry.LocationOrValue
	end := start + uint64(entry.Size)
	return patchEntry(amdFw, start, end, r, w)
}

// PatchBIOSEntry takes an AmdFirmware object and modifies one entry in BIOS directory.
// The modified entry is read from `r` reader object, while the modified firmware is written into `w` writer object.
func PatchBIOSEntry(amdFw *amd_manifest.AMDFirmware, biosLevel uint, entryID amd_manifest.BIOSDirectoryTableEntryType, instance uint8, r io.Reader, w io.Writer) (int, error) {
	entry, err := GetBIOSEntry(amdFw.PSPFirmware(), biosLevel, entryID, instance)
	if err != nil {
		return 0, err
	}

	start := entry.SourceAddress
	end := start + uint64(entry.Size)
	return patchEntry(amdFw, start, end, r, w)
}

func patchEntry(amdFw *amd_manifest.AMDFirmware, start, end uint64, r io.Reader, w io.Writer) (int, error) {
	modifiedEntry, err := io.ReadAll(r)
	if err != nil {
		return 0, fmt.Errorf("could not read modified entry: %w", err)
	}

	firmwareBytes := amdFw.Firmware().ImageBytes()

	if err := checkBoundaries(start, end, firmwareBytes); err != nil {
		return 0, newErrInvalidFormat(fmt.Errorf("cannot extract key database from firmware image, boundary check fail: %w", err))
	}

	size := end - start
	if uint64(end-start) != uint64(len(modifiedEntry)) {
		return 0, newErrInvalidFormat(fmt.Errorf("cannot write the entry to the firmware image, entry size check fail, expected %d, modified entry is %d", uint64(size), uint64(len(modifiedEntry))))
	}

	firmwareBytesFirstSection := firmwareBytes[0:start]
	firmwareBytesSecondSection := firmwareBytes[end:]

	// Write the firmware to the writer object. firmwareBytes is not modified in place because it would segfault.
	// The reason is the following:
	// * We read the firmware with uefi.ParseUEFIFirmwareFile in https://github.com/9elements/converged-security-suite/blob/master/pkg/uefi/uefi.go#L43
	// * That by default maps as read only:
	//   https://github.com/9elements/converged-security-suite/blob/81375eac5ccc858045c91323eac8e60233dc9882/pkg/ostools/file_to_bytes.go#L25
	// * Later, the behavior can be modified with ReadOnly flag in
	//   https://github.com/linuxboot/fiano/blob/master/pkg/uefi/uefi.go#L24, which is in turn consumed from NewBIOSRegion.
	// * If ReadOnly is not set, the whole slice is copied into memory from the mapped region:
	//   https://github.com/linuxboot/fiano/blob/43cb7391010ac6cb416ab6f641a3a5465b5f524e/pkg/uefi/biosregion.go#L88
	//
	// Converged security suite sets read-only to true: https://github.com/9elements/converged-security-suite/blob/master/pkg/uefi/uefi.go#L30
	// Therefore, firmwareBytes is read-only memmapped region. In order to make it read-write, we would need to enable the copy approach
	// and set ReadOnly to false (fianoUEFI.ReadOnly = false)
	// We take a more explicit approach and write the memory area before the corrupted region, the corrupted region itself,
	// and the memory area after the corrupted region.
	n, err := w.Write(firmwareBytesFirstSection)
	if err != nil {
		return n, fmt.Errorf("could not write entry to system file :  %w", err)
	}
	m, err := w.Write(modifiedEntry)
	if err != nil {
		return n, fmt.Errorf("could not write entry to system file :  %w", err)
	}
	j, err := w.Write(firmwareBytesSecondSection)
	if err != nil {
		return n, fmt.Errorf("could not write entry to system file :  %w", err)
	}

	n = n + m + j
	return n, nil
}

```

`pkg/amd/psb/entries_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestDirectoryType(t *testing.T) {
	require.Equal(t, allDirectoryTypes, AllDirectoryTypes())
	require.NotEmpty(t, allDirectoryTypes)

	for _, directory := range allDirectoryTypes {
		t.Run(directory.ShortName(), func(t *testing.T) {
			require.NotEmpty(t, directory.ShortName())
			require.NotEmpty(t, directory.String())
			resDirectory, err := DirectoryTypeFromString(strings.ToUpper(directory.ShortName()))
			require.NoError(t, err)
			require.Equal(t, directory, resDirectory)

			resDirectory, err = DirectoryTypeFromString(strings.ToLower(directory.ShortName()))
			require.NoError(t, err)
			require.Equal(t, directory, resDirectory)
		})
	}

	_, err := DirectoryTypeFromString("No such directory type")
	require.Error(t, err)
}

```

`pkg/amd/psb/errors.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"errors"
	"fmt"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
)

// SignatureCheckError is an error type which indicates that signature of an element cannot be validated against its signing key
type SignatureCheckError struct {
	signingKey    *Key
	signedElement FirmwareItem
	err           error
}

// Error returns the string representation of SignatureCheckError
func (m *SignatureCheckError) Error() string {
	if m.signedElement == nil {
		return fmt.Sprintf("signature does not validate against signing key %s: %s", m.signingKey.data.KeyID.Hex(), m.err.Error())
	}
	return fmt.Sprintf("signature of element %s does not validate against signing key %s: %s", m.signedElement, m.signingKey.data.KeyID.Hex(), m.err.Error())
}

func (m *SignatureCheckError) Unwrap() error {
	return m.err
}

// SigningKey returns the SigningKey associated to the error. Might return nil value
func (m *SignatureCheckError) SigningKey() *Key {
	return m.signingKey
}

// SignedElement returns an optional item whose signature check failed
func (m *SignatureCheckError) SignedElement() FirmwareItem {
	return m.signedElement
}

// UnknownSigningKeyError is an error type which indicates that the signing key is unknown
type UnknownSigningKeyError struct {
	signedElement FirmwareItem
	keyID         KeyID
}

// SignedElement returns an optional item whose signature check failed
func (s *UnknownSigningKeyError) SignedElement() FirmwareItem {
	return s.signedElement
}

// Error returns the string representation of the UnknownSigningKeyError
func (s *UnknownSigningKeyError) Error() string {
	if s.signedElement == nil {
		return fmt.Sprintf("key ID '%s' is unknown", s.keyID.Hex())
	}
	return fmt.Sprintf("failed to check signature of element '%s' key ID '%s' is unknown", s.signedElement, s.keyID.Hex())
}

// FirmwareItem is a special item that references a PSP firmware item and could be one of the following types:
// DirectoryType or BIOSDirectoryEntryItem or PSPDirectoryEntryItem
type FirmwareItem interface{}

func newDirectoryItem(directory DirectoryType) FirmwareItem {
	return directory
}

// BIOSDirectoryEntryItem determines a BIOS directory entry
type BIOSDirectoryEntryItem struct {
	Level    uint8
	Entry    amd_manifest.BIOSDirectoryTableEntryType
	Instance uint8
}

func (biosEntry BIOSDirectoryEntryItem) String() string {
	return fmt.Sprintf("entry '0x%X' (%s) instance %d of bios directory level %d", biosEntry.Entry, BIOSEntryType(biosEntry.Entry), biosEntry.Instance, biosEntry.Level)
}

func newBIOSDirectoryEntryItem(level uint8, entry amd_manifest.BIOSDirectoryTableEntryType, instance uint8) FirmwareItem {
	return BIOSDirectoryEntryItem{
		Level:    level,
		Entry:    entry,
		Instance: instance,
	}
}

// PSPDirectoryEntryItem determines a PSP directory entry
type PSPDirectoryEntryItem struct {
	Level uint8
	Entry amd_manifest.PSPDirectoryTableEntryType
}

func (pspEntry PSPDirectoryEntryItem) String() string {
	return fmt.Sprintf("entry '0x%X' (%s) of psp directory level %d", pspEntry.Entry, PSPEntryType(pspEntry.Entry), pspEntry.Level)
}

func newPSPDirectoryEntryItem(level uint8, entry amd_manifest.PSPDirectoryTableEntryType) PSPDirectoryEntryItem {
	return PSPDirectoryEntryItem{
		Level: level,
		Entry: entry,
	}
}

// ErrNotFound describes a situation when firmware item is not found
type ErrNotFound struct {
	item FirmwareItem
}

// GetItem returns a not found item
func (err ErrNotFound) GetItem() FirmwareItem {
	return err.item
}

// Error returns the string representation of the UnknownSigningKeyError
func (err ErrNotFound) Error() string {
	if err.item == nil {
		return "not found"
	}
	return fmt.Sprintf("'%s' is not found", err.item)
}

func newErrNotFound(item FirmwareItem) ErrNotFound {
	return ErrNotFound{
		item: item,
	}
}

// ErrInvalidFormat describes a situation when parsing of firmware failed because of invalid format
type ErrInvalidFormat struct {
	item FirmwareItem
	err  error
}

// GetItem returns the affected item (could be nil)
func (err ErrInvalidFormat) GetItem() FirmwareItem {
	return err.item
}

func (err ErrInvalidFormat) Error() string {
	return fmt.Sprintf("'%s' has invalid format format: '%s'", err.item, err.err.Error())
}

func (err ErrInvalidFormat) Unwrap() error {
	return err.err
}

func newErrInvalidFormatWithItem(item FirmwareItem, err error) ErrInvalidFormat {
	return ErrInvalidFormat{item: item, err: err}
}

func newErrInvalidFormat(err error) ErrInvalidFormat {
	return ErrInvalidFormat{err: err}
}

func addFirmwareItemToError(err error, item FirmwareItem) error {
	if err == nil {
		return nil
	}

	var sigCheckErr *SignatureCheckError
	if errors.As(err, &sigCheckErr) {
		if sigCheckErr.signedElement == nil {
			return &SignatureCheckError{signingKey: sigCheckErr.signingKey, signedElement: item, err: sigCheckErr.err}
		}
		return err
	}

	var unknownKey *UnknownSigningKeyError
	if errors.As(err, &unknownKey) {
		if unknownKey.signedElement == nil {
			return &UnknownSigningKeyError{keyID: unknownKey.keyID, signedElement: item}
		}
		return err
	}

	var notFoundErr ErrNotFound
	if errors.As(err, &notFoundErr) {
		if notFoundErr.item == nil {
			return ErrNotFound{item: item}
		}
		return err
	}

	var invalidFormatErr ErrInvalidFormat
	if errors.As(err, &invalidFormatErr) {
		if notFoundErr.item == nil {
			return ErrNotFound{item: item}
		}
		return err
	}
	return err
}

```

`pkg/amd/psb/keys.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

// Key parsing logic is based on AMD Platform Security Processor BIOS Architecture Design Guide for AMD Family 17h and Family 19h Processors
// Publication # 55758
// Issue Date: August 2020
// Revision: 1.11

import (
	"bytes"
	"crypto/rsa"
	"encoding/binary"
	"errors"
	"fmt"
	"math/big"

	"strings"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
)

// KeyID is the primary identifier of a key
type KeyID Buf16B

// Hex returns a hexadecimal string representation of a KeyID
func (kid *KeyID) Hex() string {
	var s strings.Builder
	fmt.Fprintf(&s, "%x", *kid)
	return s.String()
}

// String returns the hexadecimal string representation of a KeyID
func (kid *KeyID) String() string {
	return kid.Hex()
}

// KeyIDs represents a list of KeyID
type KeyIDs []KeyID

// String returns a string representation of all KeyIDs
func (kids KeyIDs) String() string {
	if len(kids) == 0 {
		return ""
	}

	var s strings.Builder
	fmt.Fprintf(&s, "%s", kids[0].Hex())
	for _, kid := range kids[1:] {
		fmt.Fprintf(&s, ", %s", kid.Hex())
	}
	return s.String()
}

// KeyUsageFlag describes a known values for KeyUsageFlag field of AMD PSP Key structure
type KeyUsageFlag uint32

const (
	// SignAMDBootloaderPSPSMU tells that the corresponding key is authorized to sign AMD developed PSP Boot
	// Loader and AMD developed PSP FW components and SMU FW.
	// See Table 26. RSA Key Format Fields of AMD Platform Security Processor BIOS Architecture Design Guide for AMD Family 17h and 19h Processors
	// Revision 1.11
	SignAMDBootloaderPSPSMU KeyUsageFlag = 0

	// SignBIOS tells that the corresponding key is authorized to sign BIOS
	SignBIOS KeyUsageFlag = 1

	// SignAMDOEMPSP tells that the corresponding key is authorized to sign PSP FW (both AMD developed and OEM developed)
	SignAMDOEMPSP KeyUsageFlag = 2

	// PSBSignBIOS tells that a key is authorized to sign BIOS for platform secure boot.
	// See Table 8. RSA Key Format Fields of Enabling Platform Secure Boot
	// for AMD Family 17h Models 00h–0Fh and 30h–3Fh and Family 19h Models 00h–0Fh Processor-Based Server Platforms
	// Revision 0.91
	PSBSignBIOS KeyUsageFlag = 8
)

// KeyData represents the binary format (as it is stored in an image) of the information associated with a key
type KeyData struct {
	VersionID       uint32
	KeyID           KeyID
	CertifyingKeyID Buf16B
	KeyUsageFlag    KeyUsageFlag
	Reserved        Buf16B
	ExponentSize    uint32
	ModulusSize     uint32
	Exponent        []byte
	Modulus         []byte
}

// Key structure extracted from the firmware
type Key struct {
	data KeyData
}

// PlatformBindingInfo describes information of BIOS Signing Key to Platform Binding information
type PlatformBindingInfo struct {
	VendorID        uint8
	KeyRevisionID   uint8
	PlatformModelID uint8
}

func (b PlatformBindingInfo) String() string {
	var s strings.Builder
	fmt.Fprintf(&s, "Vendor ID: %X\n", b.VendorID)
	fmt.Fprintf(&s, "Key Revision ID: %X\n", b.KeyRevisionID)
	fmt.Fprintf(&s, "Platform Model ID: %X\n", b.PlatformModelID)
	return s.String()
}

// GetPlatformBindingInfo for PSBSignBIOS key returns BIOS Signing Key to Platform Binding information
func GetPlatformBindingInfo(k *Key) (PlatformBindingInfo, error) {
	if k.data.KeyUsageFlag != PSBSignBIOS {
		return PlatformBindingInfo{}, fmt.Errorf("not a PSBSignBios key usage flag: %v", k.data.KeyUsageFlag)
	}
	return parsePlatformBinding(k.data.Reserved), nil
}

func parsePlatformBinding(reserved Buf16B) PlatformBindingInfo {
	return PlatformBindingInfo{
		VendorID:        reserved[0],
		KeyRevisionID:   reserved[1] & 7,  // Bits 0:3 => Key Revision ID
		PlatformModelID: reserved[1] << 3, // Bits 4:7 => Platform Model ID
	}
}

// SecurityFeatureVector represents a security feature selection vector of BIOS OEM key
type SecurityFeatureVector struct {
	DisableBIOSKeyAntiRollback bool
	DisableAMDBIOSKeyUse       bool
	DisableSecureDebugUnlock   bool
}

func (sfv SecurityFeatureVector) String() string {
	var s strings.Builder
	fmt.Fprintf(&s, "DISABLE_BIOS_KEY_ANTI_ROLLBACK: %t\n", sfv.DisableBIOSKeyAntiRollback)
	fmt.Fprintf(&s, "DISABLE_AMD_BIOS_KEY_USE: %t\n", sfv.DisableAMDBIOSKeyUse)
	fmt.Fprintf(&s, "DISABLE_SECURE_DEBUG_UNLOCK: %t\n", sfv.DisableSecureDebugUnlock)
	return s.String()
}

// GetSecurityFeatureVector for PSBSignBIOS key returns a security feature selection vector
func GetSecurityFeatureVector(k *Key) (SecurityFeatureVector, error) {
	if k.data.KeyUsageFlag != PSBSignBIOS {
		return SecurityFeatureVector{}, fmt.Errorf("not a PSBSignBios key usage flag: %v", k.data.KeyUsageFlag)
	}
	return parseSecurityFeatureVector(k.data.Reserved), nil
}

func parseSecurityFeatureVector(reserved Buf16B) SecurityFeatureVector {
	return SecurityFeatureVector{
		DisableBIOSKeyAntiRollback: reserved[3]&1 == 1,
		DisableAMDBIOSKeyUse:       (reserved[3]<<1)&1 == 1,
		DisableSecureDebugUnlock:   (reserved[3]<<2)&1 == 1,
	}
}

// Key creation functions manage two slightly different key structures available in firmware:
//
// 1) Those serialized into key tokens
// 2) Those serialized into the key database
//
// Format 2) is as follow:
//
// type key struct {
// 		dataSize uint32
//		version uint32
//		keyUsageFlag uint32
// 		publicExponent [4]uint8
//		keyID	[16]uint8
//		keySize uint32
//		reserved Buf44B
//		modulus []byte
// }
//
// From a bytes buffer, there is no way to distinguish between the two cases above, so an indication
// of which format to use should come from the caller (by calling NewKey<TYPE>).
//
// Both formats will be deserialized into Key structure. Some fields of Key might contain zero value
// (e.g. certifying key ID for keys extracted from the key database, which is indirectly the AMD root
// key as it signs the whole key database).
//
// If the key is a token key, the signature is validated.
// Additional safety checks are implemented during serialization:
// if a `certifyingKeyID` is retrieved from the buffer and it's not null, a KeySet must be available for validation,
// or an error will be returned. Callers however are ultimately responsible to make sure that a KeySet is passed if
// a key should be validated.

func zeroCertifyingKeyID(key *Key) bool {
	for _, v := range key.data.CertifyingKeyID {
		if v != 0 {
			return false
		}
	}
	return true
}

// readExponent reads exponent value from a buffer, assuming exponent size
// has already been populated.
func readExponent(buff *bytes.Buffer, key *Key) error {
	if key.data.ExponentSize%8 != 0 {
		return newErrInvalidFormat(fmt.Errorf("exponent size is not divisible by 8"))
	}
	exponent := make([]byte, key.data.ExponentSize/8)
	if err := binary.Read(buff, binary.LittleEndian, &exponent); err != nil {
		return newErrInvalidFormat(fmt.Errorf("could not parse exponent: %w", err))
	}
	key.data.Exponent = exponent
	return nil
}

// readModulus reads modulus value from a buffer, assuming modulus size
// has already been populated
func readModulus(buff *bytes.Buffer, key *Key) error {
	if key.data.ModulusSize%8 != 0 {
		return newErrInvalidFormat(fmt.Errorf("modulus size is not divisible by 8"))
	}

	modulus := make([]byte, key.data.ModulusSize/8)
	if err := binary.Read(buff, binary.LittleEndian, &modulus); err != nil {
		return newErrInvalidFormat(fmt.Errorf("could not parse modulus: %w", err))
	}
	key.data.Modulus = modulus
	return nil
}

// newTokenOrRootKey creates the common parts of Token and Root keys
func newTokenOrRootKey(buff *bytes.Buffer) (*Key, error) {

	key := Key{}

	if err := binary.Read(buff, binary.LittleEndian, &key.data.VersionID); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse VersionID: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.KeyID); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse KeyID: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.CertifyingKeyID); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse Certifying KeyID: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.KeyUsageFlag); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse Key Usage Flag: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.Reserved); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse reserved area: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.ExponentSize); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse exponent size: %w", err))
	}
	if err := binary.Read(buff, binary.LittleEndian, &key.data.ModulusSize); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse modulus size: %w", err))
	}

	if err := readExponent(buff, &key); err != nil {
		return nil, err
	}

	if err := readModulus(buff, &key); err != nil {
		return nil, err
	}
	return &key, nil
}

// NewRootKey creates a new root key object which is considered trusted without any need for signature check
func NewRootKey(buff *bytes.Buffer) (*Key, error) {
	key, err := newTokenOrRootKey(buff)
	if err != nil {
		return nil, fmt.Errorf("cannot parse root key: %w", err)
	}

	if key.data.KeyID != key.data.CertifyingKeyID {
		return nil, newErrInvalidFormat(fmt.Errorf("root key must have certifying key ID == key ID (key ID: %x, certifying key ID: %x)", key.data.KeyID, key.data.CertifyingKeyID))
	}
	return key, err

}

// NewTokenKey create a new key object from a signed token
func NewTokenKey(buff *bytes.Buffer, keySet KeySet) (*Key, error) {

	raw := buff.Bytes()

	key, err := newTokenOrRootKey(buff)
	if err != nil {
		return nil, fmt.Errorf("could not create new token key: %w", err)
	}

	signingKeyID := KeyID(key.data.CertifyingKeyID)
	signingKey := keySet.GetKey(signingKeyID)
	if signingKey == nil {
		return nil, fmt.Errorf("could not find signing key with ID %s for key token key", signingKeyID.Hex())
	}

	signatureSize, err := signingKey.SignatureSize()
	if err != nil {
		return nil, &SignatureCheckError{signingKey: signingKey, err: fmt.Errorf("could not get signature length of a key: %w", err)}
	}

	// validate the signature of the new token key
	signature := make([]byte, signatureSize)
	if err := binary.Read(buff, binary.LittleEndian, &signature); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse signature from key token: %w", err))
	}

	// A key extracted from a signed token has the following structure:
	// * 64 bytes header
	// * exponent
	// * modulus
	// * signature.
	//
	// Exponent, modulus and signature are all of the same size. Only the latter is not signed, hence the length
	// of the signed payload is header size + 2 * exponent/modulus size.
	lenSigned := uint64(64 + 2*key.data.ModulusSize/8)
	if uint64(len(raw)) < lenSigned {
		return nil, newErrInvalidFormat(fmt.Errorf("length of signed token is not sufficient: expected > %d, got %d", lenSigned, len(raw)))
	}

	// Validate the signature of the raw token
	if _, err := NewSignedBlob(reverse(signature), raw[:lenSigned], signingKey); err != nil {
		return nil, fmt.Errorf("could not validate the signature of token key: %w", err)
	}
	return key, nil
}

// NewKeyFromDatabase creates a new key object from key database entry
func NewKeyFromDatabase(buff *bytes.Buffer) (*Key, error) {
	key := Key{}

	var (
		dataSize uint32
		numRead  uint64
	)

	if err := readAndCountSize(buff, binary.LittleEndian, &dataSize, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse dataSize: %w", err))
	}

	// consider if we still have enough data to parse a whole key entry which is dataSize long.
	// dataSize includes the uint32 dataSize field itself
	if uint64(dataSize) > uint64(buff.Len())+4 {
		return nil, newErrInvalidFormat(fmt.Errorf("buffer is not long enough (%d) to satisfy dataSize (%d)", buff.Len(), dataSize))
	}

	if err := readAndCountSize(buff, binary.LittleEndian, &key.data.VersionID, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse VersionID: %w", err))
	}

	if err := readAndCountSize(buff, binary.LittleEndian, &key.data.KeyUsageFlag, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse key usage flags: %w", err))
	}

	var publicExponent Buf4B
	if err := readAndCountSize(buff, binary.LittleEndian, &publicExponent, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse public exponent: %w", err))
	}
	key.data.Exponent = publicExponent[:]

	if err := readAndCountSize(buff, binary.LittleEndian, &key.data.KeyID, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse key id: %w", err))
	}

	var keySize uint32
	if err := readAndCountSize(buff, binary.LittleEndian, &keySize, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse key size: %w", err))
	}
	if keySize == 0 {
		return nil, newErrInvalidFormat(fmt.Errorf("key size cannot be 0"))
	}

	if keySize%8 != 0 {
		return nil, newErrInvalidFormat(fmt.Errorf("key size is not divisible by 8 (%d)", keySize))
	}

	key.data.ExponentSize = keySize
	key.data.ModulusSize = keySize

	var reserved Buf44B
	if err := readAndCountSize(buff, binary.LittleEndian, &reserved, &numRead); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not parse reserved area: %w", err))
	}
	// check if we have enough data left, based on keySize and dataSize
	if (numRead + uint64(keySize)/8) > uint64(dataSize) {
		return nil, newErrInvalidFormat(fmt.Errorf("inconsistent header, read so far %d, total size is %d, key size to read is %d, which goes out of bound", numRead, dataSize, keySize))
	}

	if err := readModulus(buff, &key); err != nil {
		return nil, err
	}

	if !zeroCertifyingKeyID(&key) {
		return nil, newErrInvalidFormat(fmt.Errorf("key extracted from key database should have zero certifying key ID"))
	}

	return &key, nil
}

// String returns a string representation of the key
func (k *Key) String() string {
	var s strings.Builder

	pubKey, err := k.Get()
	if err != nil {
		fmt.Fprintf(&s, "could not get RSA key from raw bytes: %v\n", err)
		return s.String()
	}

	fmt.Fprintf(&s, "Version ID: 0x%x\n", k.data.VersionID)
	fmt.Fprintf(&s, "Key ID: 0x%s\n", k.data.KeyID.Hex())
	fmt.Fprintf(&s, "Certifying Key ID: 0x%x\n", k.data.CertifyingKeyID)
	fmt.Fprintf(&s, "Key Usage Flag: 0x%x\n", k.data.KeyUsageFlag)
	if k.data.KeyUsageFlag == PSBSignBIOS {
		fmt.Fprintf(&s, "%s", parsePlatformBinding(k.data.Reserved))
		fmt.Fprintf(&s, "%s", parseSecurityFeatureVector(k.data.Reserved))
	}
	fmt.Fprintf(&s, "Exponent size: 0x%x (dec %d) \n", k.data.ExponentSize, k.data.ExponentSize)
	fmt.Fprintf(&s, "Modulus size: 0x%x (dec %d)\n", k.data.ModulusSize, k.data.ModulusSize)

	switch rsaKey := pubKey.(type) {
	case *rsa.PublicKey:
		fmt.Fprintf(&s, "Exponent: 0x%d\n", rsaKey.E)
	default:
		fmt.Fprintf(&s, "Exponent: key is not RSA, cannot get decimal exponent\n")
	}

	fmt.Fprintf(&s, "Modulus: 0x%x\n", k.data.Modulus)
	return s.String()
}

// Get returns the PublicKey object from golang standard library.
// AMD Milan supports only RSA Keys (2048, 4096), future platforms
// might add support for additional key types.
func (k *Key) Get() (interface{}, error) {
	if err := k.checkValid(); err != nil {
		return nil, err
	}

	N := big.NewInt(0)
	E := big.NewInt(0)

	// modulus and exponent are read as little endian
	rsaPk := rsa.PublicKey{N: N.SetBytes(reverse(k.data.Modulus)), E: int(E.SetBytes(reverse(k.data.Exponent)).Int64())}
	return &rsaPk, nil
}

// SignatureSize returns the size of the signature
func (k *Key) SignatureSize() (int, error) {
	if err := k.checkValid(); err != nil {
		return 0, err
	}
	return len(k.data.Modulus), nil
}

func (k *Key) checkValid() error {
	if len(k.data.Exponent) == 0 {
		return fmt.Errorf("invalid key: exponent size is 0")
	}
	if len(k.data.Modulus) == 0 {
		return fmt.Errorf("invalid key: modulus size is 0")
	}
	return nil
}

// GetKeys returns all the keys known to the system in the form of a KeySet.
// The firmware itself contains a key database, but that is not comprehensive
// of all the keys known to the system (e.g. additional keys might be OEM key,
// ABL signing key, etc.).
func GetKeys(amdFw *amd_manifest.AMDFirmware, level uint) (KeySet, error) {
	keySet := NewKeySet()
	err := getKeysFromDatabase(amdFw, level, keySet)
	if err != nil {
		return keySet, fmt.Errorf("could not get key from table into KeySet: %w", err)
	}

	// Extract ABL signing key (entry 0x0A in PSP Directory), which is signed with AMD Public Key.
	pubKeyBytes, err := ExtractPSPEntry(amdFw, level, ABLPublicKey)
	if err != nil {
		return keySet, fmt.Errorf("could not extract raw PSP entry for ABL Public Key: %w", err)
	}
	ablPk, err := NewTokenKey(bytes.NewBuffer(pubKeyBytes), keySet)
	if err != nil {
		return keySet, addFirmwareItemToError(err, newPSPDirectoryEntryItem(uint8(level), ABLPublicKey))
	}

	err = keySet.AddKey(ablPk, ABLKey)
	if err != nil {
		return keySet, fmt.Errorf("could not add ABL signing key to key set: %w", err)
	}

	// Extract OEM signing key (entry 0x05 in BIOS Directory table)
	// in PSB disabled this entry doesn't exist
	pubKeyBytes, err = ExtractBIOSEntry(amdFw, level, OEMSigningKeyEntry, 0)
	if err != nil {
		if !errors.As(err, &ErrNotFound{}) {
			return keySet, fmt.Errorf("could not extract raw BIOS directory entry for OEM Public Key: %w", err)
		}
	} else {
		oemPk, err := NewTokenKey(bytes.NewBuffer(pubKeyBytes), keySet)
		if err != nil {
			return keySet, fmt.Errorf("could not extract OEM public key: %w", err)
		}

		err = keySet.AddKey(oemPk, OEMKey)
		if err != nil {
			return keySet, fmt.Errorf("could not add OEM signing key to key set: %w", err)
		}
	}
	return keySet, nil
}

```

`pkg/amd/psb/keys_artifacts_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

// Signed Token of AMD root key (entry type 0x00 in PSP Directory Table) of a PSB-enabled image.
var keyDB = []byte{
	0x80, 0x10, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x24, 0x4b, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x03, 0x11, 0x7b, 0x7e, 0x60, 0xcb, 0x40, 0x3e, 0xbf, 0x9e, 0xcd, 0x55, 0x7e, 0xcb, 0x99, 0x71,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xe9, 0xe0, 0x00, 0x60, 0x2c, 0xdc, 0xe9, 0xca, 0x7f, 0x83, 0x11, 0xd1, 0x66, 0xff, 0xfc, 0x8d,
	0x68, 0xd9, 0xff, 0xc9, 0xad, 0x96, 0x17, 0xee, 0x4c, 0x2d, 0x9b, 0x0d, 0x78, 0x3a, 0x8a, 0x67,
	0xb5, 0x85, 0x8a, 0xb0, 0x4a, 0x31, 0xd2, 0xe9, 0x6c, 0x11, 0x6b, 0xc8, 0x50, 0xb5, 0xa9, 0xbb,
	0xd2, 0x7e, 0x76, 0x79, 0x96, 0xa8, 0x6f, 0x58, 0xed, 0xd8, 0x3b, 0xa9, 0xbc, 0xa0, 0xe5, 0x29,
	0x9c, 0x02, 0xa6, 0x6b, 0x7e, 0x41, 0x0d, 0x26, 0x12, 0x8a, 0x59, 0xec, 0x2a, 0x50, 0x7a, 0xe3,
	0x96, 0x14, 0x35, 0x06, 0x9a, 0x0d, 0xb7, 0x31, 0x9d, 0x11, 0x5b, 0x68, 0x8e, 0x6c, 0x50, 0x71,
	0xb9, 0x0c, 0x59, 0xb9, 0xbe, 0xac, 0xd5, 0x0a, 0x46, 0x89, 0xc4, 0x82, 0x59, 0xc5, 0x11, 0xc6,
	0xca, 0x06, 0x9b, 0x14, 0x75, 0xef, 0x1c, 0xb9, 0xcb, 0xad, 0x16, 0xad, 0x44, 0x03, 0x0c, 0x54,
	0xa2, 0x77, 0x1a, 0x59, 0x36, 0x6a, 0x4b, 0x20, 0x1f, 0x7d, 0x4e, 0x44, 0x13, 0xca, 0x7b, 0xd1,
	0x39, 0x68, 0xb2, 0xcd, 0x52, 0x3f, 0xfd, 0x8b, 0x84, 0x36, 0xa3, 0x85, 0x93, 0x77, 0x06, 0x5a,
	0x3e, 0x78, 0xcb, 0xb8, 0xa0, 0x92, 0xe7, 0x85, 0x29, 0x88, 0xad, 0x92, 0xcb, 0x9d, 0x5f, 0x6c,
	0x80, 0x25, 0x3e, 0x05, 0x3b, 0x95, 0xd7, 0x6e, 0x51, 0xde, 0x89, 0xa0, 0xd7, 0xcd, 0x64, 0x61,
	0xb8, 0xc0, 0xee, 0xe0, 0x8e, 0xe0, 0x83, 0xc8, 0x43, 0x5b, 0xe3, 0x55, 0xef, 0x62, 0x9b, 0x78,
	0x99, 0x20, 0x14, 0x0f, 0x7f, 0x6c, 0x74, 0x64, 0xac, 0x8d, 0x55, 0xfd, 0xa9, 0x68, 0xa9, 0x63,
	0x20, 0x8e, 0xb5, 0x7a, 0x9b, 0x3e, 0x30, 0xd7, 0x5f, 0xfc, 0x71, 0x24, 0xd8, 0x04, 0xc8, 0x62,
	0xec, 0xc6, 0x95, 0xf6, 0x03, 0x5a, 0xc8, 0x77, 0xae, 0xc9, 0x36, 0x41, 0x28, 0xb0, 0xc8, 0x8d,
	0x4b, 0xe1, 0xf1, 0xb1, 0x3f, 0xfd, 0x68, 0xe8, 0xcb, 0x11, 0xe7, 0xbd, 0x38, 0x5b, 0x16, 0x64,
	0x58, 0xac, 0x10, 0xa5, 0x87, 0x71, 0xb1, 0x54, 0x81, 0x0d, 0x69, 0x18, 0x46, 0x11, 0xe3, 0x56,
	0x04, 0xca, 0xd0, 0xc4, 0xaa, 0x50, 0xb3, 0x96, 0x7e, 0xb9, 0x4d, 0x50, 0x86, 0x5a, 0xfa, 0x7f,
	0x79, 0xb3, 0xee, 0xa5, 0x76, 0xfd, 0x7a, 0xc3, 0xed, 0x2f, 0xd1, 0xb6, 0x82, 0x5f, 0xd2, 0x3b,
	0x8c, 0x60, 0x83, 0xa5, 0x9e, 0x03, 0x6f, 0x2f, 0xa2, 0xfc, 0x8a, 0xfb, 0xc4, 0xd0, 0x23, 0x1e,
	0xfe, 0x65, 0x93, 0x8d, 0x7c, 0xe9, 0xe4, 0x4e, 0x34, 0x04, 0x3d, 0x42, 0xdd, 0x8a, 0x8d, 0xac,
	0x4b, 0x04, 0x18, 0x63, 0x1a, 0x51, 0x0d, 0x2e, 0x54, 0x1c, 0x20, 0xd8, 0xfb, 0xa1, 0xed, 0x99,
	0x62, 0x91, 0xfb, 0x6c, 0xe4, 0xc4, 0x63, 0xfd, 0xfe, 0xcc, 0xca, 0x28, 0xa6, 0x42, 0xd6, 0x89,
	0x0e, 0x88, 0x48, 0x42, 0xe7, 0x02, 0xed, 0xd9, 0xd5, 0xa7, 0xc6, 0x64, 0xf4, 0x8b, 0x8b, 0x0a,
	0x97, 0xf9, 0x9b, 0xe0, 0x50, 0xdc, 0xfa, 0x9d, 0x7a, 0x76, 0x51, 0x77, 0x04, 0x03, 0x65, 0xb7,
	0x9c, 0xe5, 0xa9, 0x9c, 0xf1, 0x49, 0xd8, 0xe1, 0xb7, 0x4b, 0xc6, 0x4a, 0x26, 0x5b, 0x61, 0x02,
	0x29, 0x93, 0xd5, 0xbe, 0x99, 0x2a, 0xdf, 0x8a, 0x1c, 0x00, 0xc0, 0xa1, 0xf3, 0xab, 0x84, 0x7b,
	0xbb, 0x17, 0xe8, 0x6f, 0xe7, 0xb3, 0x63, 0x3d, 0xcf, 0x40, 0x72, 0x01, 0x00, 0x64, 0xb7, 0x44,
	0xc1, 0xb1, 0xc6, 0xb3, 0x54, 0x51, 0x7b, 0x3b, 0xee, 0x52, 0x8c, 0x88, 0x4c, 0xb1, 0x0c, 0xd6,
	0xc5, 0x1c, 0x4b, 0x39, 0xf9, 0xb6, 0x94, 0x26, 0xbc, 0x25, 0x6c, 0xf7, 0x97, 0x4b, 0x3a, 0x2e,
	0xd3, 0xd0, 0xa6, 0xa6, 0x6c, 0xf2, 0x83, 0xb1, 0xba, 0x19, 0x3f, 0xf7, 0xb3, 0xba, 0x39, 0xf1,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x25, 0x59, 0xbe, 0x9e, 0x7b, 0xef, 0x4c, 0x54, 0x99, 0x02, 0x42, 0xc4, 0xfa, 0xe1, 0x55, 0x22,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xa7, 0x96, 0xe8, 0xa5, 0x37, 0x11, 0x9e, 0xc3, 0xcd, 0x3b, 0x84, 0xfa, 0xc6, 0x19, 0x86, 0xf2,
	0x69, 0x39, 0x9f, 0x6c, 0x43, 0x1c, 0x6e, 0x78, 0xc9, 0xc2, 0x5f, 0x42, 0xb9, 0x93, 0x8a, 0x94,
	0xc6, 0x8d, 0x9c, 0x95, 0xee, 0xfc, 0x68, 0x3d, 0x9c, 0x5b, 0xe7, 0x0c, 0x3d, 0xff, 0x09, 0xe7,
	0x7f, 0xaa, 0x1a, 0xb6, 0x28, 0x8a, 0xf8, 0xaf, 0x62, 0x79, 0x5c, 0x57, 0xb4, 0x0e, 0xc6, 0x79,
	0x7d, 0x69, 0xb8, 0x45, 0x00, 0x60, 0x90, 0xde, 0x29, 0x23, 0x17, 0xcb, 0xb7, 0x57, 0x79, 0x2c,
	0x40, 0x9a, 0x55, 0xd5, 0x89, 0xff, 0x48, 0xe0, 0x1b, 0x5c, 0x11, 0x78, 0x12, 0x09, 0xf3, 0x31,
	0x7e, 0x1c, 0x36, 0x2e, 0xd5, 0x68, 0x45, 0xa8, 0xbc, 0x2e, 0xe8, 0x89, 0x89, 0xda, 0xd6, 0x2e,
	0x2b, 0xcd, 0x95, 0xb3, 0xde, 0xba, 0x22, 0x22, 0xcc, 0xcc, 0x61, 0xd6, 0x87, 0x01, 0x63, 0x45,
	0x44, 0x63, 0xe6, 0x91, 0x5b, 0xf8, 0xb7, 0x85, 0xdb, 0xfd, 0x65, 0xe1, 0x6e, 0x01, 0x41, 0xf4,
	0xdd, 0xa1, 0x63, 0x43, 0xc0, 0xb6, 0x90, 0x1c, 0xe1, 0xbe, 0x77, 0xa9, 0xb4, 0xb6, 0xe9, 0xee,
	0x5d, 0x9a, 0xe5, 0x16, 0xe2, 0x1f, 0xfe, 0x21, 0x8c, 0x37, 0x72, 0x8b, 0xef, 0xf7, 0x03, 0x8a,
	0xdd, 0xc3, 0x0a, 0xeb, 0x3f, 0x43, 0x16, 0xa3, 0x6c, 0x94, 0xf2, 0x5c, 0xa6, 0x7e, 0xd3, 0x97,
	0xeb, 0x0d, 0x8e, 0x72, 0x80, 0x47, 0xea, 0xe9, 0x90, 0xef, 0x4b, 0x7f, 0xd8, 0x56, 0x1d, 0x55,
	0x5c, 0x2e, 0x66, 0x96, 0x33, 0xd6, 0xcf, 0xe7, 0x83, 0x1b, 0xd6, 0x70, 0x93, 0xa7, 0x85, 0x18,
	0xab, 0xe8, 0xad, 0x55, 0xa7, 0x95, 0x0d, 0xaa, 0x0f, 0x97, 0x93, 0xe6, 0x2b, 0x31, 0x1a, 0xc7,
	0x1f, 0xa6, 0xfc, 0x34, 0xf8, 0xc0, 0xcc, 0xf1, 0x7d, 0x96, 0x2e, 0x38, 0x52, 0x36, 0xd9, 0x63,
	0x0d, 0x88, 0xd1, 0x84, 0x51, 0x59, 0xec, 0xd0, 0x0c, 0xb8, 0x23, 0x08, 0xf5, 0x75, 0xce, 0x88,
	0x6e, 0x55, 0xa3, 0xc0, 0xb1, 0x26, 0xc6, 0x52, 0xec, 0x43, 0xe7, 0xdb, 0x82, 0x23, 0xb1, 0x0f,
	0xc9, 0x17, 0x65, 0x25, 0x4c, 0xb4, 0xd1, 0x77, 0xb6, 0x37, 0xa4, 0x5d, 0x30, 0x7f, 0x4d, 0x93,
	0xbe, 0x40, 0x23, 0x88, 0x2c, 0x33, 0xec, 0xd7, 0x27, 0x54, 0x04, 0x2f, 0xfd, 0x2c, 0x4c, 0x02,
	0x55, 0x18, 0xc7, 0x60, 0x5c, 0xc5, 0x7d, 0xe8, 0x20, 0x8d, 0x54, 0x7b, 0xd2, 0x53, 0x21, 0x04,
	0x60, 0xd8, 0xda, 0x16, 0xbf, 0xa7, 0x03, 0x9f, 0x20, 0x8f, 0xda, 0xfc, 0xaf, 0x96, 0x64, 0x09,
	0xb1, 0xe6, 0xc1, 0x09, 0x5b, 0x58, 0x6d, 0x00, 0xd5, 0xec, 0x7d, 0x25, 0x6d, 0x65, 0x5a, 0x1e,
	0x09, 0x86, 0x87, 0xa7, 0xed, 0x12, 0x57, 0xa6, 0x4a, 0xc3, 0xc8, 0xfb, 0xc5, 0x56, 0x37, 0xb4,
	0x76, 0xf2, 0xe3, 0x06, 0x30, 0x27, 0xfc, 0xa2, 0x9a, 0x09, 0x21, 0x87, 0xdc, 0x70, 0x46, 0x7e,
	0xe7, 0x90, 0xfb, 0x36, 0x0d, 0xcc, 0xff, 0xb9, 0x84, 0x34, 0x24, 0x81, 0xdd, 0x4a, 0x31, 0xce,
	0xe5, 0x68, 0x52, 0xfa, 0x18, 0x11, 0x54, 0xda, 0xd4, 0x95, 0x2b, 0xca, 0xc7, 0xd9, 0x0a, 0x1c,
	0x62, 0x54, 0xa2, 0x88, 0x47, 0xe9, 0xc0, 0x54, 0x9e, 0x50, 0x17, 0xd6, 0x59, 0x0b, 0xa1, 0x2b,
	0x6b, 0x68, 0xfa, 0x60, 0x79, 0xc8, 0xd6, 0x67, 0xcd, 0x00, 0x84, 0x90, 0x22, 0x63, 0xa3, 0x30,
	0x88, 0xd3, 0xbf, 0x20, 0xe1, 0x59, 0xa1, 0xa1, 0x5b, 0x97, 0x36, 0x0c, 0x59, 0xf5, 0xa7, 0x78,
	0x75, 0xa2, 0xda, 0x74, 0xf5, 0xa5, 0xcf, 0x3e, 0xa2, 0xca, 0xc3, 0xe3, 0xfd, 0x45, 0xaf, 0x48,
	0xd0, 0xb0, 0x40, 0x2f, 0x85, 0x87, 0xda, 0x8b, 0xa0, 0x70, 0x1e, 0x96, 0x57, 0x79, 0x9a, 0xb5,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x6e, 0x97, 0xee, 0xe0, 0x86, 0xbd, 0x4b, 0x41, 0xb5, 0x82, 0x01, 0xce, 0x9f, 0xe3, 0x08, 0x73,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xcf, 0x36, 0x6d, 0x35, 0x73, 0x05, 0xe3, 0x15, 0xcc, 0x31, 0x1c, 0xb6, 0xb6, 0x6d, 0xde, 0xc9,
	0x92, 0x05, 0xce, 0xea, 0x7b, 0xf9, 0x3e, 0x95, 0x16, 0xe4, 0x27, 0x95, 0x8d, 0x0c, 0xcd, 0x98,
	0x7a, 0x6c, 0x79, 0x73, 0x7b, 0xc2, 0x01, 0xa7, 0xfe, 0x4d, 0xc3, 0x45, 0x08, 0xc0, 0x7a, 0x68,
	0xe2, 0xe9, 0x3d, 0x0a, 0x4f, 0x45, 0x11, 0x26, 0xaf, 0xd7, 0x1a, 0x25, 0x48, 0x47, 0x84, 0x21,
	0x8f, 0x57, 0xe3, 0xff, 0x51, 0x92, 0x41, 0xe8, 0x04, 0x66, 0x5b, 0xf4, 0xb6, 0x26, 0x41, 0x42,
	0xe2, 0xad, 0x16, 0x07, 0xba, 0xdf, 0x90, 0xe2, 0x53, 0xe8, 0xc1, 0xfb, 0xe9, 0xb2, 0x81, 0xfd,
	0x36, 0x4d, 0xb9, 0x5d, 0xa8, 0x2a, 0x84, 0x77, 0xa8, 0xa2, 0x4b, 0x56, 0x0a, 0x83, 0x99, 0x9c,
	0x1b, 0x3a, 0x42, 0x56, 0x9a, 0x20, 0xf1, 0x58, 0xbd, 0x9c, 0xb9, 0x85, 0xc3, 0x06, 0x18, 0x85,
	0xd7, 0x28, 0x1c, 0x66, 0xa7, 0xb8, 0x17, 0xec, 0x1a, 0x29, 0xf2, 0x93, 0x52, 0x89, 0xaa, 0x6b,
	0x65, 0x35, 0xe7, 0x6c, 0x33, 0x25, 0x80, 0x78, 0x8d, 0xab, 0xb7, 0xb3, 0x34, 0x77, 0xb6, 0xa2,
	0x18, 0x5c, 0x7e, 0xf9, 0x39, 0xc1, 0x83, 0xcb, 0x5d, 0x02, 0x5a, 0xb6, 0xbe, 0xbf, 0xd8, 0x8e,
	0x0d, 0x86, 0xa0, 0xe0, 0x0c, 0x10, 0xf8, 0xfd, 0x30, 0xf7, 0x49, 0x9a, 0x75, 0xc4, 0x15, 0x5c,
	0xe6, 0x5d, 0x28, 0xeb, 0x06, 0xdf, 0x15, 0xf3, 0xd8, 0xba, 0x17, 0x5a, 0xbc, 0x0d, 0x92, 0x55,
	0xb6, 0xd1, 0x3e, 0xae, 0xe3, 0xaf, 0x9d, 0x00, 0x2d, 0x83, 0xb2, 0x54, 0x30, 0x09, 0x1d, 0x11,
	0x81, 0x56, 0x66, 0xf5, 0xd0, 0x67, 0xfc, 0x6f, 0xa1, 0x35, 0x80, 0x8f, 0xeb, 0x5f, 0x37, 0x8b,
	0x8c, 0xb7, 0xed, 0xb5, 0x7b, 0x3e, 0xeb, 0x53, 0xbe, 0x56, 0xad, 0x50, 0x6a, 0x49, 0x00, 0x02,
	0xea, 0xf9, 0x7b, 0x29, 0x8b, 0x2a, 0xdd, 0x3c, 0xae, 0xf1, 0x3a, 0x40, 0x70, 0x91, 0xae, 0x72,
	0x72, 0xbc, 0x70, 0xc6, 0xf6, 0x3b, 0x29, 0xf7, 0x42, 0xc6, 0xc2, 0xf2, 0xb2, 0x19, 0xaa, 0xf2,
	0x55, 0x52, 0x2c, 0x37, 0x85, 0x99, 0xdd, 0x95, 0x13, 0x34, 0xf6, 0x4d, 0x15, 0x7d, 0x36, 0x5b,
	0xa4, 0xb8, 0xdf, 0x0d, 0x3c, 0xd3, 0x82, 0x8c, 0x58, 0xdc, 0xb2, 0x0d, 0x16, 0x12, 0x36, 0x66,
	0x06, 0x86, 0xc2, 0x71, 0x08, 0x40, 0x63, 0xa1, 0x03, 0x03, 0x4a, 0x99, 0x43, 0x85, 0x21, 0xee,
	0x49, 0x3e, 0x93, 0x74, 0x79, 0x6d, 0x75, 0xe1, 0x46, 0x37, 0x30, 0x5e, 0xf6, 0xa2, 0x3f, 0xe5,
	0xdf, 0x88, 0x9d, 0x94, 0x63, 0x0e, 0xa7, 0x0d, 0xe4, 0x4e, 0xb1, 0x28, 0x79, 0xed, 0x70, 0x8c,
	0x6d, 0x37, 0x31, 0xdf, 0xcf, 0x2c, 0x93, 0xc1, 0x33, 0xf6, 0x1d, 0xe9, 0x9d, 0xe8, 0x58, 0xe8,
	0x87, 0x53, 0x23, 0xc3, 0x86, 0xfe, 0xca, 0x47, 0x4f, 0xc8, 0xee, 0x7b, 0x81, 0x1a, 0x17, 0x94,
	0x94, 0x28, 0x13, 0xae, 0x73, 0xe9, 0x76, 0x44, 0xd2, 0xa1, 0xa3, 0xc7, 0x30, 0x8f, 0x76, 0x59,
	0x35, 0x2b, 0xfe, 0x28, 0xc7, 0xfc, 0xed, 0x7b, 0x4d, 0x22, 0x06, 0x98, 0x79, 0xa6, 0xac, 0xd2,
	0xa2, 0x57, 0xb4, 0xfc, 0x6c, 0xff, 0x38, 0x42, 0xcc, 0xdc, 0x33, 0xc3, 0x8b, 0xbb, 0x02, 0xb4,
	0xde, 0x4f, 0x20, 0xb8, 0x00, 0xca, 0xea, 0x23, 0x47, 0x6b, 0x1c, 0x17, 0x80, 0x81, 0x88, 0x89,
	0xef, 0xed, 0x13, 0xf8, 0xfb, 0xbb, 0x7a, 0xa6, 0x2b, 0xc1, 0x74, 0xfe, 0x7c, 0xfd, 0xb4, 0x05,
	0x88, 0x1d, 0xbe, 0xb3, 0x14, 0x77, 0xdb, 0xb4, 0xe9, 0x74, 0x2d, 0x4b, 0x2c, 0xfd, 0x61, 0xc0,
	0xed, 0x56, 0xc6, 0xa5, 0xec, 0xab, 0x41, 0x81, 0xf1, 0x1b, 0x65, 0x94, 0x47, 0x7b, 0x20, 0xee,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0x80, 0xac, 0x38, 0xa7, 0x85, 0x99, 0x45, 0xf8, 0xba, 0x5f, 0xb9, 0xb4, 0xc7, 0xa5, 0x79, 0x8f,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xaf, 0xf9, 0x11, 0x21, 0x07, 0xec, 0xa0, 0xe5, 0x17, 0x3f, 0x1d, 0x87, 0xa6, 0x94, 0x31, 0x4d,
	0xa8, 0x59, 0xf9, 0xb4, 0x24, 0x74, 0x45, 0x36, 0xfc, 0x19, 0x03, 0x61, 0xaf, 0x4c, 0x36, 0x47,
	0xd8, 0x30, 0xa4, 0xcd, 0xb5, 0xf7, 0x97, 0x65, 0x23, 0xc8, 0xa8, 0xeb, 0x4b, 0x7d, 0x1e, 0x55,
	0x41, 0x4d, 0xe8, 0xa8, 0x85, 0x02, 0xab, 0xb2, 0x88, 0x8d, 0x66, 0xae, 0xf7, 0xd2, 0x94, 0x0d,
	0x35, 0x78, 0xfb, 0x36, 0xe5, 0xf8, 0xef, 0x05, 0xd4, 0x9d, 0x9f, 0xe6, 0x6b, 0x71, 0x94, 0xf1,
	0xe5, 0x9b, 0xf6, 0x71, 0x24, 0xa2, 0xe0, 0x7f, 0x93, 0x36, 0x1e, 0x60, 0xaf, 0x1f, 0x2d, 0x6d,
	0x94, 0x37, 0xf2, 0x31, 0xa3, 0xb9, 0x5f, 0xaa, 0xed, 0x27, 0xe4, 0x39, 0x17, 0xb3, 0xd1, 0x04,
	0x38, 0x1b, 0x2e, 0x5e, 0xe7, 0x1a, 0x2f, 0x82, 0x23, 0x5d, 0x18, 0x75, 0xdc, 0xec, 0x11, 0x4a,
	0xa1, 0xb4, 0xc5, 0xe8, 0x10, 0xee, 0xf9, 0xca, 0xcb, 0xb0, 0xe5, 0xdc, 0x53, 0x9e, 0x08, 0xec,
	0xd9, 0x7f, 0xbe, 0x8d, 0xc8, 0x36, 0xee, 0xf3, 0x3a, 0x62, 0x8b, 0x85, 0xfc, 0xae, 0x96, 0x9a,
	0x30, 0xde, 0x31, 0xe2, 0x23, 0xb6, 0x5a, 0xc9, 0x9b, 0x0b, 0x34, 0x12, 0x47, 0xf3, 0xb5, 0xc0,
	0xe3, 0x7b, 0x85, 0xad, 0x7a, 0x51, 0x77, 0xb4, 0x70, 0xff, 0xe9, 0x76, 0x67, 0x1b, 0x89, 0xd9,
	0x20, 0x30, 0x58, 0xff, 0x56, 0x30, 0xa1, 0xc6, 0x04, 0x73, 0xd4, 0xbe, 0x01, 0x25, 0x8a, 0xfc,
	0x17, 0xad, 0x9c, 0x6c, 0x59, 0x10, 0x49, 0xd6, 0xea, 0x3b, 0xb4, 0x93, 0xd5, 0xeb, 0xc4, 0xa5,
	0x11, 0x88, 0x99, 0x95, 0xe4, 0xb1, 0xd2, 0x6c, 0x5d, 0xab, 0xc6, 0x78, 0xa8, 0xe6, 0xdb, 0x26,
	0xdb, 0x0a, 0x4c, 0xcc, 0x8e, 0xf8, 0x0b, 0x2e, 0x15, 0xb1, 0x10, 0x7c, 0xc2, 0x70, 0x78, 0x11,
	0xf2, 0x4c, 0x61, 0x99, 0x6a, 0x6d, 0x0d, 0x80, 0x9d, 0x34, 0xb9, 0x72, 0x5e, 0x73, 0x79, 0x8d,
	0x35, 0x3d, 0xca, 0xb9, 0x02, 0x9d, 0xfe, 0x7d, 0xc0, 0x64, 0x38, 0x26, 0xf5, 0x04, 0xc9, 0x0a,
	0xaa, 0x55, 0xe9, 0x7f, 0x65, 0x9e, 0xc0, 0x73, 0x29, 0x2d, 0xb9, 0xb2, 0xf5, 0x2c, 0x7c, 0x0e,
	0xb0, 0x6b, 0x32, 0xc6, 0x82, 0xd6, 0xf5, 0x9c, 0x6d, 0x8e, 0x55, 0x5e, 0x14, 0xca, 0xac, 0xae,
	0x04, 0x2e, 0xad, 0xf5, 0x89, 0x17, 0x52, 0x7c, 0x12, 0x84, 0x3c, 0xbd, 0x90, 0xa0, 0x61, 0x4e,
	0xbc, 0xce, 0xeb, 0x55, 0x2c, 0x29, 0x8b, 0x88, 0x4b, 0x29, 0x9c, 0x8c, 0xbc, 0x94, 0x42, 0x8b,
	0x62, 0x0f, 0x79, 0x3f, 0x8d, 0xba, 0xaa, 0xa4, 0xad, 0x90, 0x21, 0x42, 0xc6, 0x33, 0x10, 0x29,
	0xd5, 0xd4, 0x1d, 0x06, 0xad, 0x4c, 0x65, 0x08, 0x49, 0x3d, 0x34, 0x47, 0xcf, 0xc0, 0x3a, 0x4b,
	0xfc, 0xbe, 0x81, 0x36, 0x57, 0xf5, 0x25, 0x8d, 0xba, 0x09, 0x2f, 0x40, 0xa1, 0xc7, 0x0b, 0xf9,
	0x16, 0x72, 0x12, 0x95, 0x72, 0xd0, 0xe7, 0x4f, 0x18, 0xf3, 0x47, 0x89, 0xaf, 0xc7, 0x06, 0xc8,
	0x2f, 0x1d, 0x93, 0xf0, 0x3e, 0xc7, 0x2e, 0x01, 0xaa, 0x82, 0xa4, 0xf8, 0x39, 0x4f, 0x4a, 0x1b,
	0xfd, 0x7e, 0xfb, 0x4b, 0xef, 0x17, 0x5d, 0xc6, 0x4b, 0x19, 0x4b, 0x03, 0xe4, 0xa1, 0xd7, 0xbe,
	0x1e, 0xac, 0x57, 0x92, 0x50, 0xda, 0x5d, 0x53, 0x1b, 0x9c, 0xd4, 0x27, 0xc1, 0xe0, 0xb8, 0x3b,
	0xb3, 0x6f, 0x47, 0x68, 0x5a, 0x5f, 0x5e, 0xd3, 0xe8, 0x1b, 0x6e, 0x7b, 0xb5, 0x5a, 0x00, 0x0a,
	0x16, 0x5e, 0xce, 0x8d, 0xd8, 0xff, 0x6e, 0x1b, 0x62, 0x5f, 0xdf, 0x4c, 0x6e, 0xd7, 0x35, 0xbe,
	0x65, 0x07, 0x68, 0x6e, 0x95, 0xd8, 0xfd, 0xb7, 0x43, 0x75, 0xec, 0xce, 0x31, 0x93, 0x35, 0xa6,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0xea, 0x94, 0x0a, 0x66, 0x12, 0x38, 0x41, 0x2d, 0xb3, 0x9e, 0xab, 0xa2, 0x93, 0x4d, 0x4a, 0x9f,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xdb, 0xec, 0x7f, 0x1a, 0x1c, 0xa6, 0xb9, 0x41, 0x30, 0xe8, 0xbc, 0x66, 0xb0, 0xd1, 0xc8, 0xed,
	0xbb, 0xfb, 0xd3, 0x7f, 0xd9, 0x76, 0x9b, 0x51, 0x9f, 0x1f, 0x9e, 0xc1, 0x22, 0xb0, 0x8e, 0x3b,
	0xbf, 0x2a, 0x0c, 0x0b, 0x7a, 0xd6, 0x2e, 0x4f, 0xa7, 0xc4, 0x65, 0x4c, 0xa6, 0x63, 0x86, 0x55,
	0xe1, 0x89, 0x23, 0x00, 0x61, 0x71, 0x78, 0x41, 0x7d, 0xf9, 0xbc, 0xd8, 0x23, 0xd9, 0x5a, 0xbf,
	0x0e, 0xa1, 0x54, 0xa5, 0x39, 0xbc, 0xdb, 0xc8, 0x42, 0x68, 0x47, 0x43, 0x93, 0x62, 0x3d, 0x82,
	0x0e, 0x1e, 0xdd, 0xaa, 0x2c, 0x23, 0x39, 0x9d, 0x4e, 0xfa, 0x0e, 0x76, 0x67, 0x7f, 0x41, 0xe4,
	0xbe, 0x03, 0x84, 0xe9, 0xf2, 0x82, 0x47, 0x0b, 0xf1, 0x26, 0x85, 0xfa, 0x0e, 0xf5, 0x8b, 0x46,
	0x5c, 0xac, 0x8f, 0x3e, 0x30, 0xcb, 0x29, 0xb4, 0x73, 0x79, 0xe7, 0x11, 0x68, 0x19, 0x11, 0x97,
	0x4d, 0x3c, 0xb5, 0x29, 0x19, 0xdc, 0x36, 0xe9, 0xdd, 0x1a, 0x84, 0x98, 0xb9, 0xf7, 0x06, 0x77,
	0x6f, 0x6f, 0x10, 0x6f, 0x8a, 0x36, 0xbb, 0x99, 0x74, 0xb2, 0xb9, 0xaf, 0xb9, 0x74, 0x3c, 0x3c,
	0x88, 0x60, 0xa3, 0xb4, 0x83, 0xab, 0x6a, 0x68, 0xd0, 0x9f, 0x76, 0x54, 0x5b, 0x42, 0x76, 0xb5,
	0x28, 0x49, 0x62, 0x67, 0xec, 0x96, 0xc2, 0xba, 0x30, 0x78, 0x98, 0x29, 0x6b, 0x35, 0x79, 0xdf,
	0xfc, 0x0d, 0xeb, 0xb0, 0x53, 0x3d, 0x40, 0x22, 0x2f, 0x07, 0xfc, 0xa8, 0xa5, 0x69, 0xff, 0x7b,
	0x09, 0x50, 0x91, 0xa3, 0xe4, 0xe0, 0x74, 0x17, 0xaa, 0x59, 0x48, 0xb1, 0x83, 0x51, 0x59, 0x53,
	0xc2, 0xc0, 0x1e, 0x65, 0x29, 0x73, 0xa3, 0x99, 0x75, 0x16, 0x30, 0x6a, 0xae, 0x37, 0xff, 0xbd,
	0x7e, 0xc5, 0xe7, 0x40, 0x42, 0xd3, 0x8e, 0x9c, 0x88, 0x0c, 0xf1, 0xcf, 0x9e, 0xdf, 0x49, 0x39,
	0x5b, 0xef, 0x7a, 0xa7, 0x82, 0xb7, 0x69, 0xef, 0x80, 0x6d, 0xd4, 0x6e, 0x65, 0x72, 0x42, 0x58,
	0xfb, 0x8b, 0x27, 0x9e, 0x81, 0xb0, 0x79, 0x12, 0xfc, 0x62, 0x78, 0x3b, 0x55, 0x10, 0x8c, 0x6b,
	0xfa, 0x8d, 0xa6, 0x27, 0xa0, 0x61, 0x50, 0x2b, 0x3f, 0x4d, 0xa8, 0x46, 0x1e, 0x1b, 0xfc, 0x74,
	0x9f, 0xbc, 0x46, 0x09, 0x8e, 0xe6, 0x74, 0x9b, 0x91, 0x41, 0x39, 0xc0, 0xc0, 0xae, 0x6e, 0xff,
	0x33, 0x93, 0x73, 0xd0, 0x24, 0x54, 0xd4, 0x8c, 0xf4, 0xf2, 0x63, 0x22, 0x8c, 0xe6, 0x51, 0x70,
	0xd4, 0x56, 0xb8, 0x12, 0x64, 0x73, 0x45, 0xf2, 0x5b, 0x6e, 0xee, 0xfa, 0xbc, 0x62, 0x2e, 0xe7,
	0x57, 0x13, 0x92, 0xe9, 0x6a, 0xc6, 0xe0, 0x4c, 0x56, 0xcb, 0x43, 0x24, 0x2c, 0x87, 0x6f, 0x81,
	0x7e, 0x3e, 0xde, 0xb0, 0xa4, 0x6d, 0x47, 0x4b, 0xad, 0x51, 0x84, 0x11, 0x39, 0xca, 0xe4, 0x15,
	0x02, 0x6e, 0xc7, 0xa0, 0x31, 0x50, 0x2a, 0x46, 0x83, 0x19, 0x60, 0x80, 0x20, 0x29, 0x9b, 0xb0,
	0x16, 0x17, 0xea, 0xfb, 0xc8, 0x04, 0x8b, 0x01, 0x5d, 0x3e, 0x26, 0x9f, 0xd4, 0x43, 0xc9, 0x7a,
	0x02, 0xca, 0x91, 0xc6, 0xd2, 0xcc, 0x46, 0xde, 0x46, 0x85, 0x60, 0x47, 0x4c, 0xd6, 0x8a, 0x24,
	0x3c, 0xe4, 0x62, 0xa5, 0x62, 0x49, 0x21, 0xd4, 0x9b, 0xb6, 0x03, 0xed, 0x0d, 0x05, 0x1b, 0x40,
	0xf2, 0x96, 0x3d, 0x4e, 0xc0, 0xbd, 0x6a, 0x9a, 0xf4, 0x95, 0x1c, 0x35, 0xe9, 0x55, 0x13, 0x28,
	0x44, 0x82, 0xd4, 0x6d, 0x77, 0x9c, 0xdf, 0xd5, 0x60, 0x18, 0xd6, 0x3b, 0x00, 0xc5, 0x12, 0x36,
	0x87, 0xf6, 0x80, 0xea, 0x7d, 0x13, 0xeb, 0x44, 0xef, 0xc2, 0x8f, 0x7d, 0x55, 0x37, 0x3c, 0xc9,
	0xe0, 0x5c, 0x01, 0x0c, 0xa4, 0xa9, 0x87, 0x06, 0xfd, 0xc6, 0xc8, 0xdd, 0xfe, 0x8c, 0xf5, 0xd5,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0xf2, 0x4b, 0x7f, 0x7e, 0xdc, 0xe5, 0x45, 0xdd, 0x89, 0xb6, 0x5c, 0xd0, 0x7e, 0xf7, 0x40, 0x97,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xdf, 0x69, 0x15, 0x48, 0xcf, 0x06, 0x9b, 0x90, 0x47, 0x60, 0x5f, 0x85, 0x2d, 0x19, 0xf5, 0xdf,
	0xae, 0x83, 0x70, 0xb6, 0x16, 0xb6, 0x53, 0x56, 0xd3, 0xbf, 0x6b, 0xd9, 0xa2, 0xb8, 0xe2, 0x2d,
	0x65, 0x92, 0xbc, 0xce, 0x15, 0xf8, 0x1b, 0x33, 0x61, 0x52, 0x82, 0x55, 0xe1, 0xb7, 0x61, 0xa9,
	0xf3, 0xac, 0x3b, 0x28, 0x16, 0xaa, 0xa2, 0xe0, 0xd7, 0x1d, 0x16, 0xfd, 0x64, 0x21, 0x32, 0xb9,
	0x8e, 0x4c, 0x14, 0x1c, 0xbc, 0xf0, 0x97, 0x26, 0x89, 0xcb, 0xfe, 0x1a, 0x3f, 0x31, 0x18, 0x12,
	0x8e, 0xb7, 0x63, 0x56, 0xe5, 0xf7, 0x56, 0xd3, 0x5f, 0x47, 0x99, 0x56, 0x8e, 0x8b, 0x87, 0xa8,
	0x88, 0x42, 0xc6, 0x9c, 0x91, 0x26, 0x6b, 0x6f, 0x89, 0x12, 0xf0, 0x16, 0x3e, 0x00, 0x31, 0xc7,
	0xd0, 0x8f, 0x3f, 0xfe, 0x76, 0x66, 0x3d, 0x03, 0xb0, 0x6e, 0x7b, 0x0d, 0xd6, 0x91, 0x93, 0x61,
	0x74, 0x95, 0x40, 0x97, 0x9c, 0xae, 0x7e, 0x43, 0x16, 0x44, 0x5c, 0xca, 0x9b, 0x13, 0xf9, 0x13,
	0x1e, 0x54, 0xbc, 0x74, 0xdb, 0x17, 0x34, 0x05, 0xdf, 0x77, 0x76, 0x1f, 0xa2, 0xd3, 0x93, 0x5b,
	0xcb, 0xfb, 0x1e, 0x8f, 0xac, 0x59, 0x75, 0xcb, 0x55, 0xba, 0x94, 0xd2, 0xa5, 0x4d, 0xed, 0xa5,
	0x48, 0x5c, 0x1a, 0x94, 0xf6, 0x1b, 0x3f, 0xaa, 0xee, 0x1a, 0xf0, 0xee, 0x25, 0xf2, 0xa6, 0x5f,
	0x06, 0x2b, 0x5d, 0x16, 0x8d, 0x06, 0xd9, 0x25, 0xaa, 0x32, 0xa3, 0xff, 0xe0, 0x0b, 0xcc, 0xef,
	0x55, 0x89, 0x43, 0x49, 0x17, 0xef, 0x68, 0x30, 0x98, 0xc0, 0x3e, 0x07, 0x3f, 0xc5, 0x28, 0xe6,
	0xf8, 0x81, 0x69, 0xe5, 0x3b, 0x5c, 0x12, 0xbe, 0x7c, 0xea, 0xf0, 0x82, 0xd2, 0x4b, 0xde, 0x03,
	0xaf, 0xec, 0xb4, 0x97, 0x99, 0x21, 0x0b, 0x80, 0xc9, 0x4b, 0xfd, 0x92, 0x4a, 0x16, 0xb9, 0xcf,
	0xd7, 0x17, 0x84, 0xc1, 0xaa, 0x70, 0xc1, 0x6f, 0x5d, 0x1e, 0xe0, 0x1d, 0xfe, 0x14, 0x61, 0xa8,
	0xcb, 0xba, 0x63, 0xf9, 0xe6, 0x2d, 0x13, 0xf8, 0xad, 0xf8, 0x99, 0x9a, 0x42, 0xe3, 0xdf, 0x2e,
	0x01, 0xb9, 0xca, 0x45, 0xe4, 0x10, 0x88, 0xd7, 0x68, 0xee, 0xd6, 0xa1, 0x82, 0xcb, 0xff, 0x0a,
	0xb3, 0x55, 0xc3, 0x4d, 0x9f, 0x80, 0x28, 0x69, 0x9e, 0x3f, 0xee, 0xfe, 0x9a, 0x78, 0x24, 0x48,
	0x62, 0xa0, 0xc0, 0x1b, 0x85, 0x00, 0x56, 0x61, 0x05, 0xd4, 0x79, 0x04, 0xe3, 0x96, 0xef, 0xfc,
	0xe6, 0x53, 0x26, 0xc4, 0xe8, 0xa4, 0x9b, 0x59, 0xd0, 0x77, 0x9f, 0x7d, 0xa5, 0x0e, 0x43, 0xce,
	0xf7, 0x33, 0x95, 0x50, 0x5a, 0x76, 0xe0, 0xac, 0xea, 0x7a, 0xde, 0x9f, 0x64, 0xe9, 0x1b, 0xfd,
	0xa1, 0x27, 0x4d, 0x8b, 0x00, 0x3d, 0x6b, 0xe9, 0xc0, 0xc9, 0x58, 0x2d, 0x59, 0x8c, 0x3d, 0x30,
	0x10, 0xa9, 0xae, 0xd6, 0xd4, 0x79, 0x1a, 0x84, 0x1a, 0x60, 0xe6, 0xde, 0x88, 0x5a, 0xb9, 0xa0,
	0xc1, 0xf3, 0xaf, 0x79, 0x80, 0x37, 0x0c, 0x78, 0x6e, 0x9c, 0x7a, 0x5f, 0xea, 0x3f, 0xd3, 0x17,
	0x1d, 0xd7, 0x73, 0xc5, 0x8c, 0xa0, 0xfc, 0x71, 0xe3, 0xd5, 0x9b, 0x17, 0x60, 0x74, 0xa1, 0x67,
	0x31, 0xa8, 0x36, 0x1a, 0xe3, 0x27, 0x45, 0xd4, 0x37, 0x97, 0x0b, 0xb8, 0x95, 0x9b, 0x3a, 0x25,
	0xb7, 0xe5, 0xfc, 0x55, 0xda, 0x95, 0x31, 0xad, 0x60, 0x97, 0xad, 0x88, 0x39, 0x3d, 0xe7, 0xf8,
	0x01, 0x06, 0x4c, 0x62, 0xdc, 0xde, 0x1b, 0xa6, 0x4d, 0x52, 0x09, 0x85, 0x5a, 0x8c, 0xd7, 0x89,
	0xd9, 0x3e, 0x4e, 0xbd, 0x3b, 0x82, 0x01, 0x8f, 0x41, 0x70, 0x09, 0x61, 0xc2, 0xe8, 0x45, 0xb4,
	0x4f, 0x5b, 0xbd, 0x78, 0x8c, 0x12, 0x02, 0x30, 0xb2, 0x54, 0x62, 0x23, 0x30, 0xef, 0xd8, 0xb7,
	0x50, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
	0xff, 0xfe, 0x23, 0x6b, 0x8b, 0xcc, 0x4a, 0x2b, 0xac, 0xbb, 0x85, 0x6e, 0x12, 0x03, 0x68, 0xfd,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4d, 0xa6, 0x61, 0xc8, 0x7e, 0x6f, 0x3d, 0xa4, 0xe0, 0x5c, 0x7b, 0x40, 0xb2, 0x83, 0x44, 0x8f,
	0xb1, 0x5b, 0x42, 0x13, 0x35, 0xd8, 0x0b, 0x5b, 0xc6, 0x42, 0xa5, 0xc9, 0x0a, 0x36, 0x0e, 0x8a,
	0x51, 0x8d, 0x46, 0xd6, 0xa3, 0xdf, 0xc7, 0x21, 0x74, 0x04, 0x70, 0xa8, 0xcb, 0x59, 0x8a, 0x9f,
	0xcd, 0xd0, 0x97, 0x4f, 0x9b, 0xe6, 0xb5, 0xc5, 0xa8, 0xd4, 0xd7, 0xd1, 0x22, 0x68, 0xd6, 0x0f,
	0x65, 0xb2, 0xaa, 0x40, 0x51, 0xc5, 0x06, 0x95, 0xdd, 0xbe, 0x5a, 0x98, 0x51, 0x5c, 0x65, 0xc3,
	0x36, 0xd9, 0x94, 0xa3, 0x19, 0x8a, 0x53, 0xa2, 0xf8, 0x8c, 0x01, 0x39, 0xc3, 0xbf, 0xff, 0xb9,
	0x9e, 0x90, 0x17, 0x08, 0xec, 0x0b, 0x34, 0x41, 0x35, 0x5c, 0xd5, 0xf8, 0x47, 0x63, 0x09, 0xcc,
	0xa5, 0x95, 0xe9, 0x74, 0x85, 0x90, 0x15, 0x43, 0xcb, 0x6d, 0x06, 0x2c, 0xd5, 0x3f, 0xd7, 0xc3,
	0x13, 0x86, 0xca, 0x2c, 0xd5, 0x58, 0x0b, 0xea, 0x3e, 0x73, 0x6b, 0xe5, 0xc1, 0x23, 0x0a, 0xf5,
	0xba, 0xd2, 0x89, 0x6c, 0x1d, 0x77, 0x57, 0x8e, 0xac, 0x20, 0xdc, 0xa5, 0x1a, 0xfc, 0x01, 0x71,
	0xfc, 0xd5, 0x09, 0x34, 0x3d, 0x06, 0x5f, 0x46, 0x5a, 0x58, 0x6d, 0xde, 0xbb, 0xf2, 0x86, 0x60,
	0x4e, 0x63, 0x0c, 0x88, 0x2a, 0x75, 0x7e, 0xf3, 0x15, 0x83, 0x52, 0x55, 0xfc, 0xad, 0x0c, 0x0d,
	0x6d, 0xb6, 0x8d, 0xb2, 0x31, 0xf9, 0xc5, 0xec, 0xf6, 0xab, 0xb1, 0xaf, 0x17, 0xba, 0x66, 0x0d,
	0x47, 0xee, 0x98, 0xfb, 0x52, 0xc5, 0x54, 0xda, 0x76, 0xb2, 0xed, 0x9e, 0x89, 0x91, 0xe5, 0x01,
	0x09, 0x62, 0x63, 0xff, 0xeb, 0x77, 0xff, 0x56, 0xc4, 0x39, 0x19, 0xa1, 0xf8, 0x3d, 0xec, 0x00,
	0xaa, 0xa2, 0x41, 0x1b, 0x75, 0x74, 0x88, 0x90, 0x09, 0x75, 0xa9, 0xd9, 0xbd, 0xb0, 0x5e, 0xe4,
	0xbd, 0x9b, 0x7d, 0xd2, 0xc2, 0x05, 0xce, 0x32, 0xe5, 0x15, 0x47, 0x7c, 0xa7, 0x37, 0xbb, 0xdb,
	0xe6, 0x4e, 0x80, 0x36, 0xed, 0x34, 0x2b, 0x78, 0x17, 0xba, 0x78, 0xca, 0x9b, 0xe4, 0x36, 0xb4,
	0xa3, 0x1c, 0x37, 0x64, 0x22, 0x31, 0x10, 0x0b, 0xfc, 0x68, 0xe8, 0x6e, 0x0a, 0xe5, 0x10, 0xa2,
	0x40, 0x20, 0xba, 0x29, 0xaf, 0x35, 0xd0, 0x54, 0xfe, 0x57, 0x6d, 0xb8, 0xae, 0xac, 0xbe, 0xc0,
	0x6a, 0x8c, 0x6a, 0x1b, 0xd7, 0x87, 0xb3, 0x13, 0x6f, 0x8f, 0xfd, 0x2e, 0xf0, 0x54, 0x1a, 0xd1,
	0x65, 0xdb, 0xa0, 0x8f, 0xad, 0x61, 0xae, 0xa4, 0xf1, 0x8a, 0x6c, 0x54, 0x55, 0x08, 0x14, 0xa2,
	0xd1, 0xfc, 0x87, 0xdd, 0x4c, 0x38, 0xdb, 0xae, 0x89, 0xad, 0xbe, 0xc9, 0x4c, 0x46, 0xd5, 0xaf,
	0xe6, 0x03, 0x88, 0x64, 0xc3, 0xce, 0x1b, 0xc2, 0x96, 0xa9, 0xd8, 0x75, 0xf6, 0x44, 0xb9, 0x4b,
	0xc0, 0x32, 0x5c, 0xf5, 0x89, 0x73, 0x57, 0x0c, 0xa0, 0x5b, 0xd9, 0x5c, 0xfc, 0x14, 0x65, 0x33,
	0x3a, 0xc7, 0x17, 0x23, 0x01, 0x37, 0x42, 0xa9, 0x9b, 0x2b, 0xe2, 0x8f, 0x12, 0x50, 0xc5, 0x31,
	0xc3, 0xca, 0xf7, 0x5d, 0x45, 0x8a, 0x2c, 0xdf, 0xa0, 0x42, 0x55, 0x97, 0x6c, 0x17, 0xec, 0x6a,
	0x56, 0x68, 0xd2, 0x07, 0x14, 0xf8, 0x23, 0x35, 0x54, 0x74, 0x4e, 0xb9, 0xe1, 0xd9, 0x7c, 0xcc,
	0x38, 0xc5, 0x47, 0xf8, 0xd2, 0x8e, 0xba, 0x73, 0x09, 0x47, 0x6b, 0x03, 0xb4, 0x45, 0x49, 0xf1,
	0xe2, 0xcd, 0xf1, 0xdb, 0xbb, 0x14, 0xcd, 0x95, 0xc0, 0xd2, 0x60, 0x1e, 0xcd, 0x60, 0x6f, 0xba,
	0x3b, 0x7e, 0x06, 0x95, 0xe9, 0x1e, 0x1c, 0xad, 0xff, 0x3f, 0x8b, 0x6f, 0xfc, 0x72, 0x0d, 0xe4,
	0x53, 0xaa, 0xb2, 0x32, 0x14, 0xe1, 0xa4, 0xb1, 0x64, 0xbb, 0x53, 0xb7, 0xd8, 0x0d, 0x4b, 0xc8,
}

// Signed Token of AMD root key (entry type 0x00 in PSP Directory Table) of a PSB-enabled image.
var amdRootKey = []byte{
	0x01, 0x00, 0x00, 0x00, 0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67,
	0x1d, 0x08, 0x3f, 0xb6, 0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67,
	0x1d, 0x08, 0x3f, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xab, 0x65, 0x45, 0x12, 0x5a, 0x63, 0x5d, 0x86, 0xdf, 0x23, 0x0b, 0xf4, 0x41, 0x6e, 0xdf, 0xf1,
	0x40, 0xe8, 0xb5, 0x20, 0x7f, 0x72, 0x7a, 0xef, 0x72, 0xc3, 0x14, 0x0c, 0x99, 0xe5, 0x83, 0x75,
	0xc7, 0xb3, 0xfb, 0xa6, 0x70, 0x79, 0xed, 0x5c, 0x64, 0xd1, 0x4b, 0x01, 0xd6, 0xc9, 0x4f, 0x8c,
	0x53, 0xd2, 0xf5, 0x7c, 0x7c, 0x7c, 0xcd, 0xf4, 0xe8, 0xe2, 0xda, 0xad, 0xd8, 0x30, 0xa8, 0x20,
	0xa4, 0xa0, 0xe3, 0xef, 0xaa, 0x90, 0xbe, 0x42, 0x8c, 0x3d, 0x9b, 0x31, 0xb6, 0x78, 0xa4, 0xd6,
	0xaa, 0xc6, 0xa8, 0x68, 0xe9, 0xc3, 0x1c, 0x69, 0xb0, 0x9e, 0x31, 0xbb, 0x72, 0x4b, 0x05, 0xcc,
	0x4d, 0xc3, 0x9f, 0x31, 0x79, 0x50, 0x93, 0xd1, 0x2b, 0x1e, 0xc2, 0xf7, 0xed, 0xd2, 0x48, 0x9e,
	0xcf, 0xea, 0x09, 0x7e, 0x49, 0x7a, 0xda, 0x9b, 0x24, 0x23, 0x61, 0xdc, 0x78, 0x3d, 0x43, 0x67,
	0x33, 0xfc, 0xac, 0xcf, 0x45, 0x2e, 0x5b, 0x86, 0xac, 0x62, 0x4b, 0x17, 0xb4, 0x00, 0x93, 0xe6,
	0x27, 0x80, 0xfe, 0x2d, 0x42, 0xe2, 0x9b, 0xb7, 0xe4, 0x9d, 0x43, 0x77, 0x73, 0xaa, 0x50, 0x32,
	0xf5, 0x95, 0xad, 0xbd, 0x6b, 0x1c, 0x90, 0x5e, 0xec, 0xad, 0x5c, 0xcc, 0x13, 0xe6, 0x7a, 0x62,
	0x89, 0x68, 0x2c, 0xbb, 0x8f, 0xf1, 0x38, 0xf3, 0x62, 0x60, 0x13, 0x21, 0xf3, 0xc9, 0x86, 0x4f,
	0xe5, 0x92, 0x43, 0x05, 0xfa, 0xec, 0x0a, 0x41, 0x1b, 0x47, 0xd5, 0xb1, 0x45, 0x34, 0x44, 0x79,
	0x82, 0x64, 0x70, 0xb8, 0xac, 0x2b, 0x9e, 0x52, 0xfc, 0xff, 0x03, 0x29, 0x07, 0xac, 0xf9, 0x22,
	0x5b, 0x33, 0x72, 0xcf, 0xc5, 0x44, 0x6c, 0xc9, 0x60, 0x13, 0x87, 0x28, 0xf2, 0xed, 0x9b, 0xe5,
	0x6d, 0x6a, 0x1e, 0xa0, 0x6c, 0xa0, 0x03, 0xcc, 0xc4, 0xc4, 0x92, 0xe3, 0x7e, 0xc5, 0x0a, 0x2f,
	0xff, 0x9d, 0xa1, 0xa6, 0xd7, 0xb7, 0x03, 0x7b, 0x3f, 0x8c, 0x27, 0xe3, 0xdf, 0xb1, 0x7a, 0x3d,
	0x48, 0xfd, 0x87, 0x1d, 0x4a, 0x87, 0xe9, 0xc2, 0x65, 0xe9, 0x5b, 0xcd, 0x6e, 0xb8, 0xb4, 0xa2,
	0xf3, 0x4f, 0x34, 0x62, 0x82, 0x39, 0x0d, 0xa2, 0x5c, 0x0b, 0x26, 0xe6, 0xd5, 0xe7, 0xcf, 0x85,
	0x15, 0xca, 0xed, 0xee, 0x51, 0x05, 0x65, 0x80, 0xdb, 0x3e, 0x9a, 0x5e, 0x68, 0x3f, 0xa8, 0x2a,
	0x64, 0x2e, 0xd9, 0xe2, 0x07, 0xaa, 0xbc, 0xb8, 0x7a, 0x0c, 0xfe, 0x38, 0xae, 0x57, 0x2c, 0x3d,
	0x36, 0xee, 0x77, 0x47, 0xeb, 0xb4, 0xc0, 0x8e, 0xaf, 0xef, 0xf8, 0x81, 0x6d, 0xe6, 0xb3, 0xd6,
	0xd8, 0x39, 0xe2, 0x1d, 0x46, 0x17, 0x39, 0x6b, 0xde, 0x4b, 0x8e, 0x9a, 0x32, 0x7c, 0x3f, 0xee,
	0x4f, 0x4d, 0x73, 0xd4, 0x8b, 0x5f, 0x52, 0x72, 0x3d, 0xee, 0x3a, 0x50, 0x26, 0x26, 0xab, 0x61,
	0x80, 0x27, 0x6a, 0x3c, 0x4b, 0xb6, 0xb1, 0x52, 0x43, 0xdc, 0xe9, 0xfe, 0xdd, 0x5f, 0xbc, 0x3b,
	0xd6, 0x52, 0xad, 0x37, 0x47, 0x39, 0xf2, 0x04, 0x87, 0x44, 0x73, 0xff, 0x57, 0x38, 0xf7, 0x6d,
	0x91, 0xf1, 0x29, 0x7e, 0x3e, 0x5d, 0xe6, 0x4e, 0xaa, 0xac, 0xd8, 0x73, 0x58, 0xc7, 0x8a, 0xcd,
	0xcc, 0xd2, 0xc0, 0x44, 0xd6, 0x5a, 0x5b, 0x34, 0xac, 0x47, 0xd4, 0x94, 0xa8, 0x90, 0x6d, 0x5e,
	0xd1, 0xd4, 0xc7, 0xd4, 0xf1, 0x28, 0xbf, 0x5f, 0x72, 0xb2, 0x18, 0xe6, 0x6d, 0x71, 0x23, 0x25,
	0xe0, 0x5b, 0x46, 0xc7, 0xd0, 0xbb, 0x42, 0x3f, 0x2f, 0xa1, 0x49, 0x49, 0x21, 0x71, 0xd4, 0xf3,
	0xd5, 0x63, 0x57, 0x8d, 0x5b, 0x60, 0xf3, 0xd5, 0x17, 0x6c, 0xb5, 0xa8, 0xdb, 0x92, 0xc5, 0x3e,
	0x98, 0x15, 0xdb, 0x25, 0xb6, 0xa2, 0x96, 0x89, 0xe8, 0x75, 0x4e, 0x12, 0xd9, 0x79, 0xb7, 0xd0,
}

// Signed Token of OEM signing key (entry type 0x05 in BIOS Directory Table) of a PSB-enabled image.
var oemSigningKey = []byte{
	0x01, 0x00, 0x00, 0x00, 0xef, 0x99, 0x1d, 0xb4, 0x41, 0x42, 0x44, 0x67, 0x92, 0x65, 0x92, 0x3d,
	0xe8, 0xbc, 0x51, 0xd8, 0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67,
	0x1d, 0x08, 0x3f, 0xb6, 0x08, 0x00, 0x00, 0x00, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1b, 0x91, 0x26, 0xfe, 0xc7, 0xb7, 0xdd, 0xc2, 0xfe, 0x1c, 0xde, 0xc7, 0xe0, 0x4a, 0x35, 0x9d,
	0xe8, 0x68, 0x24, 0x19, 0x2c, 0x05, 0xcd, 0x71, 0xda, 0xbe, 0xbd, 0xeb, 0xf5, 0x67, 0x73, 0xbe,
	0xfc, 0xb3, 0x03, 0x02, 0x92, 0xe5, 0x9c, 0x3c, 0xdd, 0x81, 0x0d, 0x80, 0xe8, 0x3e, 0x24, 0xd8,
	0x92, 0x30, 0x97, 0x98, 0x88, 0x64, 0xd8, 0x60, 0xa4, 0x02, 0x22, 0xc7, 0x89, 0x75, 0x19, 0x26,
	0xc1, 0x8d, 0xa1, 0x6b, 0xa6, 0xac, 0x8f, 0xe5, 0x40, 0x14, 0xc4, 0x06, 0xd0, 0x93, 0x23, 0x4f,
	0x98, 0xc5, 0xd3, 0x55, 0x42, 0x63, 0x37, 0x76, 0x5e, 0x8b, 0x9d, 0xf7, 0xcb, 0xa6, 0x39, 0xfd,
	0x17, 0x2a, 0x6c, 0xca, 0x40, 0xfc, 0x3d, 0xeb, 0x47, 0x46, 0x9e, 0x3a, 0x31, 0xbf, 0x4b, 0xfa,
	0x76, 0xfb, 0x8c, 0x02, 0x8c, 0x0a, 0xd6, 0x59, 0x62, 0x38, 0x96, 0x90, 0x33, 0x96, 0xf3, 0x76,
	0xf4, 0x4b, 0x8e, 0x2b, 0xf8, 0x9d, 0xb6, 0x49, 0x38, 0x1b, 0x4a, 0x4e, 0xe8, 0x2a, 0x09, 0xae,
	0xf2, 0x6e, 0xd0, 0x4e, 0x3e, 0x77, 0xad, 0x8a, 0x01, 0xc4, 0xbf, 0xd0, 0xdc, 0xd1, 0x46, 0xf1,
	0x66, 0x5f, 0xac, 0xb8, 0x1d, 0x71, 0x14, 0xfd, 0x4b, 0xdb, 0xfa, 0x7e, 0xd0, 0x2a, 0x8b, 0x8f,
	0x5b, 0xe7, 0x45, 0x81, 0xca, 0x01, 0x27, 0x6b, 0x0c, 0xaa, 0xbe, 0xfe, 0x45, 0x0a, 0xb8, 0x32,
	0x48, 0xe6, 0x91, 0x6b, 0xed, 0x51, 0x9a, 0x5b, 0x5b, 0xb0, 0x58, 0xe4, 0x91, 0x3e, 0x93, 0xf6,
	0x6d, 0x40, 0x8b, 0x52, 0x80, 0x07, 0x55, 0x67, 0x5d, 0x7b, 0xa3, 0xbf, 0x0b, 0x34, 0x92, 0x59,
	0x1c, 0x26, 0x55, 0xaf, 0x84, 0xc3, 0xb7, 0xf5, 0x1d, 0x12, 0xea, 0x32, 0x39, 0xc1, 0x34, 0x9a,
	0xb8, 0x14, 0x8a, 0xca, 0x7f, 0xc5, 0x5e, 0xb5, 0x6f, 0x1a, 0x57, 0xf1, 0x8d, 0x97, 0x78, 0x09,
	0xc1, 0x2a, 0x38, 0x5a, 0xf7, 0x6f, 0xd4, 0x73, 0x7c, 0xb8, 0x6f, 0x41, 0xb6, 0x85, 0xdd, 0x71,
	0x61, 0xe4, 0x42, 0xf5, 0xa9, 0x0b, 0x8c, 0x11, 0xaa, 0x9d, 0xa8, 0x28, 0x97, 0xce, 0xec, 0x89,
	0xac, 0x50, 0xe9, 0x58, 0x9c, 0x60, 0x77, 0x31, 0x81, 0x97, 0x8f, 0xa6, 0xeb, 0x30, 0x26, 0xd0,
	0x0c, 0xd5, 0x2b, 0x74, 0x40, 0xa9, 0x25, 0x41, 0x5d, 0x04, 0x68, 0xe3, 0xe4, 0x2c, 0x28, 0xa3,
	0xd5, 0xaf, 0x44, 0xc8, 0x3a, 0xc2, 0x2d, 0xad, 0x6b, 0x51, 0xd4, 0x19, 0x4b, 0x24, 0x2f, 0xdc,
	0x53, 0x32, 0xe0, 0x1f, 0x29, 0xf2, 0xe2, 0x20, 0x28, 0xa0, 0x99, 0xab, 0x64, 0x93, 0xd3, 0xad,
	0xcd, 0xda, 0xe3, 0x14, 0x0d, 0xa9, 0x96, 0x63, 0x7e, 0x37, 0xbd, 0xe2, 0x70, 0x3a, 0x88, 0xba,
	0x79, 0x10, 0x57, 0x6c, 0x92, 0xef, 0x90, 0xd4, 0x01, 0x0f, 0x2d, 0xe9, 0x46, 0x73, 0xcc, 0x68,
	0x12, 0x60, 0x0c, 0x84, 0x39, 0xdf, 0xd4, 0x25, 0x24, 0x13, 0xbf, 0xa9, 0xc2, 0xc2, 0xfb, 0x97,
	0x12, 0xcf, 0x0e, 0xd2, 0x99, 0x3a, 0x5e, 0xec, 0x13, 0x5d, 0x00, 0x44, 0x9c, 0xc1, 0x4d, 0xa0,
	0x7f, 0x01, 0x2c, 0x0b, 0xf9, 0x23, 0x6c, 0x8d, 0x4b, 0xe0, 0x90, 0xf8, 0xf6, 0xce, 0x2e, 0xbd,
	0x2b, 0x2a, 0x33, 0xf6, 0x58, 0x50, 0x80, 0x50, 0x54, 0x47, 0xa5, 0x1d, 0x21, 0xf3, 0x59, 0x81,
	0x61, 0xc8, 0xdb, 0x73, 0x3c, 0xa0, 0x13, 0x3b, 0xa7, 0x10, 0x3f, 0xa8, 0x5a, 0xb5, 0x27, 0x46,
	0x99, 0x12, 0xdb, 0x7d, 0x51, 0xe1, 0xbe, 0xbf, 0x47, 0xea, 0x43, 0x4e, 0xce, 0x25, 0x75, 0x06,
	0xb7, 0xab, 0x24, 0x23, 0xeb, 0xe8, 0xaf, 0xb3, 0x6c, 0xc4, 0x90, 0x07, 0x34, 0x28, 0xc9, 0xb7,
	0xe9, 0x39, 0x51, 0x74, 0xf8, 0xed, 0xaa, 0xb4, 0x62, 0x26, 0x55, 0xdf, 0x24, 0xfa, 0xbd, 0xac,
	0x89, 0x94, 0x59, 0x29, 0x55, 0xe9, 0x09, 0x66, 0xb2, 0xb0, 0x06, 0x2f, 0xd0, 0x90, 0xee, 0x9b,
	0xb4, 0xab, 0xe0, 0xb3, 0x6a, 0x29, 0x35, 0x0c, 0x45, 0x47, 0x88, 0xba, 0x3c, 0x81, 0x20, 0x59,
	0x8e, 0xd1, 0x07, 0x01, 0xc2, 0xc2, 0x54, 0x53, 0x6b, 0xac, 0xd1, 0x51, 0x1f, 0x23, 0xd2, 0xe6,
	0xba, 0x7b, 0x5d, 0xad, 0xb8, 0x49, 0x48, 0x41, 0x0f, 0x5a, 0x54, 0x02, 0x78, 0x37, 0x2b, 0xa2,
	0x67, 0xc9, 0xc8, 0x71, 0x83, 0xd7, 0x97, 0xe7, 0x98, 0x4a, 0x10, 0x93, 0xc7, 0xed, 0x66, 0xb6,
	0x9f, 0x6d, 0x78, 0xf6, 0x71, 0xc0, 0xa9, 0x51, 0x17, 0xbd, 0x03, 0x7c, 0xf0, 0x24, 0x84, 0xc0,
	0x69, 0x95, 0x6a, 0x07, 0xde, 0x22, 0xea, 0x8c, 0xe5, 0xc3, 0x2c, 0x5a, 0x19, 0xd1, 0xd6, 0x7c,
	0xe1, 0x51, 0xcd, 0xaa, 0xee, 0x57, 0x6e, 0x9e, 0x95, 0x22, 0x8b, 0x68, 0x27, 0xac, 0xdd, 0x64,
	0xe1, 0xa4, 0xb7, 0xd5, 0xbe, 0xd8, 0x99, 0xb9, 0xcf, 0xd9, 0xbf, 0x23, 0x55, 0x98, 0x7d, 0x09,
	0x4c, 0xac, 0x34, 0x30, 0x85, 0x5f, 0x63, 0x51, 0xdc, 0xb1, 0x0c, 0x54, 0x73, 0x66, 0x75, 0xde,
	0xed, 0x8c, 0x92, 0x2f, 0xe3, 0x3b, 0xe6, 0xcf, 0x1a, 0x39, 0x01, 0xb9, 0x47, 0x60, 0x3d, 0xdc,
	0x56, 0x3e, 0x80, 0xcd, 0xc0, 0x62, 0x52, 0xf0, 0x3b, 0x95, 0x64, 0x2a, 0xc5, 0x79, 0x3c, 0x8a,
	0xbd, 0x50, 0x85, 0x6e, 0x37, 0xca, 0x49, 0xe1, 0xcc, 0xd2, 0xfe, 0x80, 0xcd, 0x85, 0xbe, 0x32,
	0xa0, 0x6a, 0x39, 0xc1, 0x3a, 0x88, 0xcb, 0xf7, 0xc6, 0xb2, 0x80, 0x8b, 0xeb, 0xdb, 0x7a, 0xdb,
	0x67, 0x73, 0x20, 0xe4, 0x2e, 0x4d, 0xb1, 0x0d, 0xf6, 0x07, 0x17, 0x56, 0xfa, 0xd6, 0xf4, 0xe0,
	0x1c, 0x43, 0x80, 0x98, 0x57, 0x8f, 0xd0, 0x96, 0xce, 0x58, 0x9a, 0x60, 0xc3, 0xdd, 0x29, 0xfb,
	0xf5, 0x09, 0x24, 0x7d, 0xf2, 0x5d, 0x34, 0x4f, 0x5a, 0x76, 0x31, 0x6b, 0xd3, 0x2e, 0x36, 0x52,
	0x23, 0x55, 0x2d, 0x05, 0x43, 0x51, 0x5e, 0x6e, 0x85, 0x53, 0x77, 0x16, 0xdf, 0xe2, 0x44, 0x31,
	0x86, 0xe1, 0x52, 0x92, 0x48, 0x35, 0x6f, 0x4d, 0xb7, 0x0f, 0xc5, 0xcb, 0x49, 0x1b, 0x24, 0xa9,
	0xce, 0xc3, 0x26, 0xc4, 0xf0, 0x54, 0xc0, 0x8b, 0x5f, 0xfe, 0x75, 0xed, 0x9f, 0x51, 0x25, 0x0f,
	0x0c, 0xb2, 0x67, 0x60, 0x9c, 0x6d, 0x1d, 0x10, 0xed, 0xcc, 0xcc, 0x60, 0x09, 0xcc, 0x75, 0x8d,
	0x95, 0xbd, 0xa5, 0xc8, 0x15, 0xcf, 0xcf, 0x43, 0x8c, 0x40, 0x06, 0x18, 0x2d, 0x81, 0x66, 0xde,
	0xbe, 0xeb, 0xf1, 0x4f, 0x01, 0xb0, 0x6e, 0xf2, 0x55, 0x2c, 0x60, 0xdf, 0xa0, 0x73, 0x6e, 0x55,
	0xe1, 0x87, 0x00, 0xbc, 0xad, 0x89, 0x31, 0xa2, 0xf3, 0x96, 0x39, 0xaf, 0x17, 0x03, 0xb6, 0xa2,
	0x06, 0xf7, 0xe9, 0x0c, 0x63, 0x59, 0x80, 0x3e, 0xe2, 0x67, 0x25, 0x76, 0x13, 0x22, 0xe8, 0x40,
	0x51, 0x0a, 0xad, 0x31, 0xe5, 0x0c, 0xaf, 0x71, 0xa3, 0x36, 0xe7, 0x20, 0xfc, 0x61, 0xd4, 0x79,
	0x96, 0x9e, 0x02, 0x10, 0x50, 0xa0, 0x1e, 0x13, 0x4e, 0xf3, 0xe2, 0x3b, 0x7d, 0x9d, 0xba, 0x2b,
	0xdd, 0xea, 0x54, 0xce, 0x18, 0x49, 0x85, 0x36, 0x8a, 0x9b, 0xed, 0xbb, 0x9b, 0xe9, 0x64, 0x9c,
	0x19, 0x7f, 0x7d, 0xec, 0xd6, 0x9a, 0x14, 0x79, 0x72, 0x77, 0x5f, 0xff, 0xde, 0xec, 0x10, 0x53,
	0x99, 0x23, 0x64, 0xeb, 0x5b, 0x01, 0xcb, 0x5f, 0x6b, 0x17, 0xde, 0x8e, 0x6b, 0x06, 0x69, 0x56,
	0xfa, 0x0c, 0x4e, 0xf0, 0x71, 0x09, 0xb0, 0xc5, 0x8e, 0xcb, 0xdc, 0x9b, 0x35, 0x5e, 0x1f, 0xd8,
	0xc4, 0xed, 0x4e, 0xb4, 0xf4, 0x52, 0x64, 0x0a, 0x03, 0xa3, 0xa9, 0x7b, 0x4f, 0x2c, 0x17, 0x55,
}

```

`pkg/amd/psb/keys_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"bytes"
	"crypto/sha256"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// SHA256 of the common RSA exponent, 0x10001
var (
	rsaCommonExponentSHA256 = [32]uint8{0xc8, 0xa2, 0x22, 0xa2, 0x60, 0xf3, 0x57, 0xf5, 0xfd, 0x2b, 0x6d, 0x22, 0x49, 0x2, 0x2e, 0xef, 0xea, 0xa2, 0x8, 0xbd, 0x12, 0x13, 0x7, 0x89, 0xa2, 0x60, 0x0, 0x9b, 0x6a, 0xea, 0x58, 0xbb}
	// Key ID of the root key belonging to AMD
	rootKeyID = Buf16B{0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67, 0x1d, 0x08, 0x3f, 0xb6}
	// KeyID of the OEM signing key
	oemKeyID = Buf16B{0xef, 0x99, 0x1d, 0xb4, 0x41, 0x42, 0x44, 0x67, 0x92, 0x65, 0x92, 0x3d, 0xe8, 0xbc, 0x51, 0xd8}
	// KeyID of the signing key for SMU off chip (0x08, 0x12) firmware and MP5 firmware (0x2A)
	smuSigningKeyID = Buf16B{0x6e, 0x97, 0xee, 0xe0, 0x86, 0xbd, 0x4b, 0x41, 0xb5, 0x82, 0x01, 0xce, 0x9f, 0xe3, 0x08, 0x73}
	// KeyID of the signing key for PSP early secure unblock debug image
	earlySecurePSPKeyID = Buf16B{0x80, 0xac, 0x38, 0xa7, 0x85, 0x99, 0x45, 0xf8, 0xba, 0x5f, 0xb9, 0xb4, 0xc7, 0xa5, 0x79, 0x8f}
	// KeyID of the signing key for security policy binary
	securityPolicyBinaryKeyID = Buf16B{0xf2, 0x4b, 0x7f, 0x7e, 0xdc, 0xe5, 0x45, 0xdd, 0x89, 0xb6, 0x5c, 0xd0, 0x7e, 0xf7, 0x40, 0x97}
	// KeyID of the signing key for PSP AGESA Binary
	agesaKeyID = Buf16B{0x28, 0x9a, 0xfe, 0x36, 0xf6, 0x3c, 0x4f, 0x88, 0xbc, 0x13, 0x85, 0xaa, 0x6d, 0x92, 0x38, 0x91}
	// KeyID of the signing key for SEV Code (0x39)
	sevCodeKeyID = Buf16B{0x03, 0x11, 0x7b, 0x7e, 0x60, 0xcb, 0x40, 0x3e, 0xbf, 0x9e, 0xcd, 0x55, 0x7e, 0xcb, 0x99, 0x71}
	// KeyID of the signing key for DXIO PHY SRAM FW (0x42)
	dxioKeyID = Buf16B{0xff, 0xfe, 0x23, 0x6b, 0x8b, 0xcc, 0x4a, 0x2b, 0xac, 0xbb, 0x85, 0x6e, 0x12, 0x03, 0x68, 0xfd}
	// KeyID of the signing key DRTM TA (0x47)
	drtmTaKeyID = Buf16B{0x25, 0x59, 0xbe, 0x9e, 0x7b, 0xef, 0x4c, 0x54, 0x99, 0x02, 0x42, 0xc4, 0xfa, 0xe1, 0x55, 0x22}

	// Unknown keys (i.e. for which it is not clear what they sign)
	unknownKey1 = Buf16B{0xea, 0x94, 0x0a, 0x66, 0x12, 0x38, 0x41, 0x2d, 0xb3, 0x9e, 0xab, 0xa2, 0x93, 0x4d, 0x4a, 0x9f}
)

type KeySuite struct {
	suite.Suite
}

func (suite *KeySuite) TestKeySetAddKey() {

	rootKey, err := NewRootKey(bytes.NewBuffer(amdRootKey))
	assert.NoError(suite.T(), err)

	keySet := NewKeySet()
	err = keySet.AddKey(rootKey, AMDRootKey)
	assert.NoError(suite.T(), err)

	assert.Equal(suite.T(), 1, len(keySet.AllKeyIDs()))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(rootKeyID)))

}

func (suite *KeySuite) TestRootKeyFields() {
	key, err := NewRootKey(bytes.NewBuffer(amdRootKey))
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), uint32(0x01), key.data.VersionID)

	assert.Equal(suite.T(), KeyID(rootKeyID), key.data.KeyID)
	assert.Equal(suite.T(), rootKeyID, key.data.CertifyingKeyID)
	assert.Equal(suite.T(), SignAMDBootloaderPSPSMU, key.data.KeyUsageFlag)

	assert.Equal(suite.T(), uint32(0x1000), key.data.ExponentSize)
	assert.Equal(suite.T(), uint32(0x1000), key.data.ModulusSize)

	hashExponent := sha256.Sum256(key.data.Exponent)
	hashModulus := sha256.Sum256(key.data.Modulus)

	expectedModulusHash := [32]uint8{0x87, 0xdb, 0xd4, 0x5, 0x40, 0x23, 0x7d, 0xf3, 0x9c, 0x7, 0x2e, 0xfc, 0x2b, 0xa9, 0x1e, 0xc2, 0x3a, 0xe, 0xe5, 0x7e, 0x2a, 0xf0, 0x74, 0xdd, 0xe8, 0x44, 0xa4, 0x61, 0x4d, 0xc4, 0x57, 0x7b}

	assert.Equal(suite.T(), rsaCommonExponentSHA256, hashExponent)
	assert.Equal(suite.T(), expectedModulusHash, hashModulus)

}

func (suite *KeySuite) TestOEMKeyFields() {
	rootKey, err := NewRootKey(bytes.NewBuffer(amdRootKey))
	assert.NoError(suite.T(), err)

	// parse root key and use it to validate token key
	keySet := NewKeySet()
	err = keySet.AddKey(rootKey, AMDRootKey)
	assert.NoError(suite.T(), err)

	key, err := NewTokenKey(bytes.NewBuffer(oemSigningKey), keySet)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), uint32(0x01), key.data.VersionID)

	assert.Equal(suite.T(), KeyID(oemKeyID), key.data.KeyID)
	assert.Equal(suite.T(), rootKey.data.KeyID, KeyID(key.data.CertifyingKeyID))

	assert.Equal(suite.T(), PSBSignBIOS, key.data.KeyUsageFlag)
	platSignInfo, err := GetPlatformBindingInfo(key)
	require.NoError(suite.T(), err)
	assert.Equal(suite.T(), byte(0x8D), platSignInfo.VendorID)
	assert.Zero(suite.T(), platSignInfo.KeyRevisionID)
	assert.Zero(suite.T(), platSignInfo.PlatformModelID)

	secutiryFeatures, err := GetSecurityFeatureVector(key)
	require.NoError(suite.T(), err)
	assert.False(suite.T(), secutiryFeatures.DisableAMDBIOSKeyUse)
	assert.False(suite.T(), secutiryFeatures.DisableBIOSKeyAntiRollback)
	assert.False(suite.T(), secutiryFeatures.DisableSecureDebugUnlock)

	assert.Equal(suite.T(), uint32(0x1000), key.data.ExponentSize)
	assert.Equal(suite.T(), uint32(0x1000), key.data.ModulusSize)

	hashExponent := sha256.Sum256(key.data.Exponent)
	hashModulus := sha256.Sum256(key.data.Modulus)

	expectedModulusHash := [32]uint8{0x53, 0xbf, 0x68, 0xb9, 0x67, 0x97, 0xc5, 0x1f, 0xdd, 0xd3, 0xe6, 0x65, 0x2b, 0x2d, 0xdd, 0x2c, 0x6e, 0x57, 0x37, 0xee, 0x69, 0x6c, 0x50, 0x83, 0xa1, 0x25, 0xa9, 0x74, 0x24, 0xc1, 0xaf, 0x91}

	assert.Equal(suite.T(), rsaCommonExponentSHA256, hashExponent)
	assert.Equal(suite.T(), expectedModulusHash, hashModulus)
}

func (suite *KeySuite) TestKeyDBParsing() {

	keySet := NewKeySet()
	err := parseKeyDatabase(keyDB, keySet)
	assert.NoError(suite.T(), err)

	assert.Equal(suite.T(), 7, len(keySet.AllKeyIDs()))

	// assert presence of all known keys
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(securityPolicyBinaryKeyID)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(sevCodeKeyID)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(smuSigningKeyID)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(earlySecurePSPKeyID)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(unknownKey1)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(dxioKeyID)))
	assert.NotNil(suite.T(), keySet.GetKey(KeyID(drtmTaKeyID)))

	// assert absence of keys which are not included in the key database
	assert.Nil(suite.T(), keySet.GetKey(KeyID(oemKeyID)))
	assert.Nil(suite.T(), keySet.GetKey(KeyID(agesaKeyID)))

}

func TestKeySuite(t *testing.T) {
	suite.Run(t, new(KeySuite))
}

```

`pkg/amd/psb/keyset.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
)

// KeyType represents the type of the key stored in KeySet
type KeyType string

const (
	// OEMKey represents the OEM signing key
	OEMKey KeyType = "OEMKey"
	// AMDRootKey represents the AMD signing key
	AMDRootKey KeyType = "AMDRootKey"
	// KeyDatabaseKey represents a key extracted from KeyDatabase
	KeyDatabaseKey KeyType = "KeyDatabaseKey"
	// ABLKey represents the ABL signing key
	ABLKey KeyType = "ALBKey"
)

// KeySet is a container for all keys known to the system
type KeySet struct {
	// db holds a mapping between keyID and key
	db map[KeyID]*Key
	// keyType holds a mapping betweek KeyType and KeyID
	keyType map[KeyType][]KeyID
}

// String returns a string representation of the key in the set
func (kdb *KeySet) String() string {
	var s strings.Builder
	fmt.Fprintf(&s, "Number of keys in key set: %d\n\n", len(kdb.db))

	for _, key := range kdb.db {
		fmt.Fprintf(&s, "%s\n\n", key.String())
	}
	return s.String()
}

// AddKey adds a key to the key set
func (kdb KeySet) AddKey(k *Key, keyType KeyType) error {
	if _, ok := kdb.db[k.data.KeyID]; ok {
		return fmt.Errorf("cannot add key id %s to set, key with same id already exists", k.data.KeyID.Hex())
	}

	kdb.db[k.data.KeyID] = k
	// assume the key cannot be already present in the keyType mapping
	kdb.keyType[keyType] = append(kdb.keyType[keyType], k.data.KeyID)
	return nil
}

// NewKeySet builds an empty key set object
func NewKeySet() KeySet {
	keySet := KeySet{}
	keySet.db = make(map[KeyID]*Key)
	keySet.keyType = make(map[KeyType][]KeyID)
	return keySet
}

// GetKey returns a key if known to the KeySet. If the key is not known, null is returned
func (kdb KeySet) GetKey(id KeyID) *Key {
	if kdb.db == nil {
		return nil
	}
	return kdb.db[id]
}

// AllKeyIDs returns a list of all KeyIDs stored in the KeySet
func (kdb KeySet) AllKeyIDs() KeyIDs {
	keyIDs := make(KeyIDs, 0, len(kdb.db))
	for keyID := range kdb.db {
		keyIDs = append(keyIDs, keyID)
	}
	return keyIDs
}

// KeysetFromType returns a KeySet containing all KeyIDs of a specific type
func (kdb KeySet) KeysetFromType(keyType KeyType) (KeySet, error) {
	if _, ok := kdb.keyType[keyType]; !ok {
		return NewKeySet(), newErrNotFound(nil)
	}
	keySet := NewKeySet()
	for _, keyID := range kdb.keyType[keyType] {
		key := kdb.GetKey(keyID)
		if key == nil {
			return NewKeySet(), newErrInvalidFormat(fmt.Errorf("KeySet in inconsistent state, no key is present with keyID %s", keyID.Hex()))
		}

		err := keySet.AddKey(key, keyType)
		if err != nil {
			return NewKeySet(), fmt.Errorf("unable to add key %s: %w", keyID, err)
		}
	}
	return keySet, nil
}

// keyDBHeader represents the header pre-pended to keydb structure
type keyDBHeader struct {
	DataSize        uint32
	Version         uint32
	Cookie          uint32
	Reserved        Buf36B
	CustomerDefined Buf32B
}

func readAndCountSize(r io.Reader, order binary.ByteOrder, data interface{}, counter *uint64) error {
	if err := binary.Read(r, order, data); err != nil {
		return err
	}
	if counter != nil {
		*counter += uint64(binary.Size(data))
	}
	return nil
}

// extractKeydbHeader parses keydbHeader from binary buffer. KeyDB header is supposed to be 80 bytes long
func extractKeydbHeader(buff io.Reader) (*keyDBHeader, error) {
	header := keyDBHeader{}

	if err := binary.Read(buff, binary.LittleEndian, &header); err != nil {
		return nil, fmt.Errorf("could not read key database header: %w", err)
	}

	return &header, nil
}

// parseKeyDatabase parses a raw buffer representing a key database and adds all extracted key
// to the associated keySet. The raw buffer must be stripped off of the PSP header and the signature
// appended at the end.
func parseKeyDatabase(rawDB []byte, keySet KeySet) error {

	buff := bytes.NewBuffer(rawDB)
	_, err := extractKeydbHeader(buff)
	if err != nil {
		return fmt.Errorf("could not extract keydb header: %w", err)
	}

	for {
		if buff.Len() == 0 {
			break
		}
		key, err := NewKeyFromDatabase(buff)
		if err != nil {
			return fmt.Errorf("could not extract key entry from key database: %w", err)
		}
		if err := keySet.AddKey(key, KeyDatabaseKey); err != nil {
			return fmt.Errorf("cannot add key to key database: %w", err)
		}
	}

	return nil
}

// getKeysFromDatabase extracts the keys in the firmware key database and adds them to the KeySet passed
// as argument after validating the signature of the database itself
func getKeysFromDatabase(amdFw *amd_manifest.AMDFirmware, pspLevel uint, keySet KeySet) error {

	/**
	 * PSP Directory Level 2 does not contain the AMD
	 * Public Root Keys, so we are forced to use PSP Directory
	 * Level 1 to get them, and not have it configurable
	 */
	pubKeyBytes, err := ExtractPSPEntry(amdFw, 1, AMDPublicKeyEntry)
	if err != nil {
		return fmt.Errorf("could not extract raw PSP entry for AMD Public Key: %w", err)
	}
	amdPk, err := NewRootKey(bytes.NewBuffer(pubKeyBytes))
	if err != nil {
		return addFirmwareItemToError(err, newPSPDirectoryEntryItem(uint8(pspLevel), AMDPublicKeyEntry))
	}

	// All keys which get added the KeySet are supposed to be trusted. AMD root key is trusted as a result of being matched against a
	// "source of truth" (in hardware, this is a hash burnt into the CPU. Software tooling should check it against some external
	// reference).
	if err := keySet.AddKey(amdPk, AMDRootKey); err != nil {
		return fmt.Errorf("could not add AMD key to the key database: %w", err)
	}

	data, err := ExtractPSPEntry(amdFw, pspLevel, KeyDatabaseEntry)
	if err != nil {
		return fmt.Errorf("could not extract entry 0x%x (KeyDatabaseEntry) from PSP table: %w", KeyDatabaseEntry, err)
	}

	binary, err := newPSPBinary(data)
	if err != nil {
		return newErrInvalidFormatWithItem(newPSPDirectoryEntryItem(uint8(pspLevel), KeyDatabaseEntry),
			fmt.Errorf("could not create PSB binary from raw data for entry 0x%x (KeyDatabaseEntry): %w", KeyDatabaseEntry, err))
	}

	// getSignedBlob returns the whole PSP blob as a signature-validated structure.
	signedBlob, err := binary.getSignedBlob(keySet)
	if err != nil {
		return addFirmwareItemToError(err, newPSPDirectoryEntryItem(uint8(pspLevel), KeyDatabaseEntry))
	}

	// We need to strip off pspHeader to get the content which actually represents the keys database
	signedData := signedBlob.SignedData()
	if len(signedData) <= pspHeaderSize {
		return newErrInvalidFormatWithItem(newPSPDirectoryEntryItem(uint8(pspLevel), KeyDatabaseEntry),
			fmt.Errorf("length of key database entry (%d) is less than pspHeader length (%d)", len(signedData), pspHeaderSize))
	}

	return parseKeyDatabase(signedData[pspHeaderSize:], keySet)
}

```

`pkg/amd/psb/psbbinary.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

// pspHeaderSize represents the size of the header pre-pended to PSP binaries
const pspHeaderSize = 0x100

// signedDataStart indicates the start address of signed data content within a PSP binary
const signedDataStart = 0x0

// PSPHeaderData embeds the data of PspHeader
type PSPHeaderData struct {
	Nonce                 Buf16B
	HeaderVersion         uint32
	SizeSigned            uint32
	EncryptionOptions     uint32
	IKEKType              uint8
	Reserved0             Buf3B
	EncryptionParameters  Buf16B
	SignatureOption       uint32
	SignatureAlgorithmID  uint32
	SignatureParameters   Buf16B
	CompressionOptions    uint32
	SecurityPatchLevel    uint32
	UncompressedImageSize uint32
	CompressedImageSize   uint32
	CompressionParameters Buf8B
	ImageVersion          uint32
	ApuFamilyID           uint32
	FirmwareLoadAddress   uint32
	SizeImage             uint32
	SizeFwUnsigned        uint32
	FirmwareSplitAddress  uint32
	Reserved              Buf4B
	FwType                uint8
	FwSubType             uint8
	Reserved1             uint16
	EncryptionKey         Buf16B
	SigningInfo           Buf16B
	FwSpecificData        Buf32B
	DebugEncKey           Buf16B
}

// PspHeader models the header pre-pended to PSP binaries
type PspHeader struct {
	data PSPHeaderData

	// There should be 48 bytes of padding after the last field of the header,
	// which can be ignored. What we care about is the signature of the binary,
	// stored at the bottom of the image described by the header. This can be
	// looked up via sizeSigned and sizeImage

}

// newPspHeader returns a PspHeader object deserialized from binary format
func newPspHeader(data []byte) (*PspHeader, error) {
	hdr := PspHeader{}
	if err := binary.Read(bytes.NewBuffer(data), binary.LittleEndian, &hdr.data); err != nil {
		return nil, err
	}
	return &hdr, nil
}

// Version returns the headerVersion field of the pspHeader structure
func (h *PspHeader) Version() uint32 {
	return h.data.HeaderVersion
}

// PSPBinary represents a generic PSPBinary with pre-pended header structure
type PSPBinary struct {

	// header of the binary
	header PspHeader

	// raw data of the whole PSP binary, including header. Signature includes
	// the header, keeping track of the whole raw content of the image allows
	// to easily build structures necessary for signature validation.
	raw []byte
}

// Header returns a pointer to the PspHeader structure of the binary. Fields of the PspHeader structure are not exported
func (b *PSPBinary) Header() *PspHeader {
	return &b.header
}

// getSignedBlob returns the PSP binary object as a signature-validated SignedBlob structure
func (b *PSPBinary) getSignedBlob(keyDB KeySet) (*SignedBlob, error) {
	if b.header.data.SizeSigned == 0 {
		return nil, newErrInvalidFormat(fmt.Errorf("size of signed data cannot be 0 for PSPBinary"))
	}
	if b.header.data.SizeImage == 0 {
		return nil, newErrInvalidFormat(fmt.Errorf("size of image cannot be 0 for PSPBinary"))
	}

	// Try use signatureParameters as KeyID field for the signing key which signed the PSP binary.
	// We need to look-up the signing key to infer the expected size of the signature.
	signingKeyID := KeyID(b.header.data.SignatureParameters)
	signingKey := keyDB.GetKey(signingKeyID)
	if signingKey == nil {
		return nil, &UnknownSigningKeyError{keyID: signingKeyID}
	}

	// The recommended value for RSA exponent is 0x10001. The specification does not enforce
	// that modulus and exponent buffer size should be the same, but so far this has been the
	// case. This should probably be clarified with AMD and possibly be removed in the future.
	if signingKey.data.ModulusSize != signingKey.data.ExponentSize {
		return nil, fmt.Errorf("exponent size (%d) and modulus size (%d) do not match", signingKey.data.ModulusSize, signingKey.data.ExponentSize)
	}

	sizeSignature := signingKey.data.ModulusSize / 8

	sizeImage := uint32(0)
	sizeSignedImage := uint32(0)
	if b.header.data.CompressionOptions == 0x0 {
		// the image is not compressed, sizeSigned and sizeImage constitute the source of truth
		if b.header.data.SizeSigned > b.header.data.SizeImage {
			return nil, newErrInvalidFormat(fmt.Errorf("size of signed image cannot be > size of image (%d > %d)", b.header.data.SizeSigned, b.header.data.SizeImage))
		}
		// sizeSigned does not include the size of the header
		sizeSignedImage = b.header.data.SizeSigned + pspHeaderSize
		sizeImage = b.header.data.SizeImage
	} else {
		// the image is compressed, SizeFWSigned is to be ignored and instead compressedImageSize should be
		// taken into consideration and aligned to 16 bits. PSP header size is not included in compressedImageSize.
		alignment := uint32(0x10)
		sizeSignedImage = (b.header.data.CompressedImageSize+alignment-1) & ^(alignment-1) + pspHeaderSize
		sizeImage = sizeSignedImage + sizeSignature
	}

	if sizeImage <= sizeSignature {
		return nil, newErrInvalidFormat(fmt.Errorf("sizeImage (%d) cannot be <= of sizeSignature (%d)", sizeImage, sizeSignature))
	}
	signatureStart := sizeImage - sizeSignature
	signatureEnd := signatureStart + sizeSignature

	if err := checkBoundaries(uint64(signatureStart), uint64(signatureEnd), b.raw); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not extract signature from raw PSPBinary: %w", err))
	}

	signedDataEnd := signedDataStart + sizeSignedImage
	if err := checkBoundaries(uint64(signedDataStart), uint64(signedDataEnd), b.raw); err != nil {
		return nil, newErrInvalidFormat(fmt.Errorf("could not extract signed data from raw PSPBinary: %w", err))
	}

	signature := b.raw[signatureStart:signatureEnd]

	signedData := b.raw[signedDataStart:signedDataEnd]
	if len(signedData) <= pspHeaderSize {
		return nil, newErrInvalidFormat(fmt.Errorf("PSP binary cannot be smaller than or equal to header size"))
	}
	return NewSignedBlob(signature, signedData, signingKey)
}

// newPSPBinary creates a PSPBinary object, with associated header
func newPSPBinary(data []byte) (*PSPBinary, error) {

	pspBinary := PSPBinary{}
	pspBinary.raw = make([]byte, len(data))
	copied := copy(pspBinary.raw, data)
	if copied != len(data) {
		return nil, fmt.Errorf("expected %d copied data for raw PSP binary, got %d", len(data), copied)
	}

	header, err := newPspHeader(pspBinary.raw)
	if err != nil {
		return nil, err
	}
	pspBinary.header = *header

	return &pspBinary, nil
}

```

`pkg/amd/psb/psbbinary_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"bytes"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"math/big"
	"testing"

	"github.com/klauspost/compress/zstd"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// SMU off chip firmware signing key information
var N = "971472917905694235859527690907502923402301948031921241171273698806712501341143764872164817936205323093673268936716169271014956780829744939605805336378355604317689589643879933296619769853977997537504409513857548495835554760316169706145871580241299859391727532123062316131763291333497897666085493912196453830838835409116482525805019707393297818644968410993413227674593522445365251216146843534545538446317137254095278019564256619548518070446087126473960778214502148894932879929259282158773739433517309889480032232186219446391610435919379779378252560032397509979809202392043110002380553502817271070140095904800150060054898411959116413989750574319580379588063907374731560190664369153626299598002608484164204182073967364520170387618360414494928968064669008506200599321614764379343663974785424808230448954042498800415697272404985468748776993396194504501173460207698442122815473122167399338113883863561341937240713815386295760840924504030444583243381824402019007306020777513381800531855947355754646526659806863711949295870720607069380951550984974668335178048036250641301510976999844724811954772642716092471925323531085871838421575832526959241303117218657087055880924069551198635498158413029865582648473844773084423426422930595846516126856911"
var expectedSmuOffChipFirmwareHash = [32]byte{
	0xd8, 0xdc, 0x03, 0xff, 0x18, 0x1a, 0xcc, 0x9d, 0x09, 0xac, 0x5a, 0xe7, 0x59, 0x67, 0xdc, 0x96,
	0x60, 0xe7, 0xbb, 0x08, 0xd0, 0x3f, 0xa3, 0xb1, 0xbf, 0x64, 0x17, 0x0e, 0x43, 0xdc, 0xb2, 0xf2,
}
var expectedZeroSmuOffChipFirmwareHash = [32]byte{
	0x10, 0xe2, 0x10, 0x3e, 0xe7, 0x39, 0x21, 0x93, 0x1a, 0x78, 0x28, 0xeb, 0xdf, 0x32, 0x5d, 0x3a,
	0x3a, 0x64, 0xc7, 0xa9, 0x0c, 0xc1, 0xda, 0x5c, 0x0c, 0xa6, 0xfe, 0x17, 0xb1, 0xe3, 0xdd, 0x78,
}

const FirmwareLen = 16777216

type PsbBinarySuite struct {
	suite.Suite

	firmwareImage []byte
}

func (suite *PsbBinarySuite) SetupTest() {
	suite.firmwareImage = make([]byte, 0)
	reader, err := zstd.NewReader(nil)
	if err != nil {
		panic("could not create zstd reader")
	}
	suite.firmwareImage, err = reader.DecodeAll(firmwareImageCompressed, nil)
	if err != nil {
		panic("could not decompress zstd firmware")
	}
}

func (suite *PsbBinarySuite) TestPSBBinaryIsParsedCorrectly() {
	psbBinary, err := newPSPBinary(smuOffChipFirmware)
	require.NoError(suite.T(), err)

	hdr := psbBinary.Header()
	require.Equal(suite.T(), uint32(0x31535024), hdr.Version())
}

func (suite *PsbBinarySuite) TestPSBBinarySignedData() {
	// we are using SMU off-chip firmware for testing PSB binary control
	// paths and we need the corresponding signing key, which is contained
	// in the key database. We could just extract the single key from the
	// database, but it's easier to parse the database as a whole
	keySet := NewKeySet()
	err := parseKeyDatabase(keyDB, keySet)
	require.NoError(suite.T(), err)

	psbBinary, err := newPSPBinary(smuOffChipFirmware)
	require.NoError(suite.T(), err)

	blob, err := psbBinary.getSignedBlob(keySet)

	require.NoError(suite.T(), err)

	// verify that the signed data matches the content of the blob, excluding the final signature
	require.Equal(suite.T(), smuOffChipFirmware[:len(smuOffChipFirmware)-512], blob.SignedData())

	sig := blob.Signature()
	require.NotNil(suite.T(), sig)
	key := sig.SigningKey()
	require.NotNil(suite.T(), key)
	require.Equal(suite.T(), hex.EncodeToString(smuSigningKeyID[:]), key.data.KeyID.String())

	// obtain the RSA key from the generic Key object
	pubKey, err := key.Get()
	require.NoError(suite.T(), err)
	rsaKey := pubKey.(*rsa.PublicKey)
	require.NotNil(suite.T(), rsaKey)

	n := big.Int{}
	n.SetString(N, 10)
	require.Equal(suite.T(), n, *rsaKey.N)
	require.Equal(suite.T(), int(65537), rsaKey.E)
}

func (suite *PsbBinarySuite) TestPSBBinaryPSPDirectoryLevel2Entry() {
	// Test full extraction from firmware of entry from PSP Directory
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	smuOffChipFirmwareType := amd_manifest.PSPDirectoryTableEntryType(0x12)

	data, err := ExtractPSPEntry(amdFw, 2, smuOffChipFirmwareType)
	require.NoError(suite.T(), err)
	shaSmuOffChipFirmwareHash := sha256.Sum256(data)

	require.Equal(suite.T(), expectedSmuOffChipFirmwareHash, shaSmuOffChipFirmwareHash)

	// if we dump the SMU off-chip firmware level 1 entry, we expect to find a region of all zeros
	data, err = ExtractPSPEntry(amdFw, 1, smuOffChipFirmwareType)
	require.NoError(suite.T(), err)
	shaSmuOffChipFirmwareHash = sha256.Sum256(data)

	require.Equal(suite.T(), expectedZeroSmuOffChipFirmwareHash, shaSmuOffChipFirmwareHash)
}

func (suite *PsbBinarySuite) TestPSBBinaryPSPDirectoryLevel2EntryValidation() {
	// Test positive validation of PSP Directory entry
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	keyDB, err := GetKeys(amdFw, 2)
	require.NoError(suite.T(), err)

	signatureValidation, err := ValidatePSPEntries(amdFw, keyDB, PSPDirectoryLevel2, []uint32{0x12})

	require.NoError(suite.T(), err)
	require.Equal(suite.T(), 1, len(signatureValidation))
	require.NoError(suite.T(), signatureValidation[0].err)
	require.NotNil(suite.T(), signatureValidation[0].signingKey)

	signingKey := signatureValidation[0].signingKey

	require.Equal(suite.T(), hex.EncodeToString(smuSigningKeyID[:]), signingKey.data.KeyID.String())
}

func (suite *PsbBinarySuite) TestPSBBinaryPSPDirectoryLevel2EntryWrongSignature() {
	// Test negative validation of PSP Directory entry after corruption
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	smuOffChipFirmwareType := 0x12

	// obtain the ranges of entry 0x12 within PSP Directory Level 2 (SMU off-chip firmware)
	// and corrupt the very beginning of the blob
	pspFirmware := amdFw.PSPFirmware()
	for _, entry := range pspFirmware.PSPDirectoryLevel2.Entries {
		if entry.Type == amd_manifest.PSPDirectoryTableEntryType(smuOffChipFirmwareType) {
			amdFw.Firmware().ImageBytes()[entry.LocationOrValue] = 0x0
		}
	}

	keyDB, err := GetKeys(amdFw, 2)
	require.NoError(suite.T(), err)

	// ValidatePSPEntries will succeed, but the signature validation object returned will hold a signature check error
	signatureValidation, err := ValidatePSPEntries(amdFw, keyDB, PSPDirectoryLevel2, []uint32{uint32(smuOffChipFirmwareType)})
	require.NoError(suite.T(), err)

	require.Equal(suite.T(), 1, len(signatureValidation))
	require.Error(suite.T(), signatureValidation[0].err)
	var sigErr *SignatureCheckError
	require.True(suite.T(), errors.As(signatureValidation[0].err, &sigErr))

	require.NotNil(suite.T(), signatureValidation[0].signingKey)
	signingKey := signatureValidation[0].signingKey
	require.Equal(suite.T(), hex.EncodeToString(smuSigningKeyID[:]), signingKey.data.KeyID.String())
}

func (suite *PsbBinarySuite) TestPSBBinaryPSPDirectoryLevel2EntryWrongKeys() {
	// Test negative validation of PSP Directory entry after corruption
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	smuOffChipFirmwareType := 0x12

	// signatureParameters indicates the id of the signing key and is placed at 56 bytes offset
	// from the beginning of the blob
	signatureParametersOffset := uint64(56)

	// obtain the ranges of entry 0x12 within PSP Directory Level 2 (SMU off-chip firmware)
	// and modify the fingerprint of the signing key for the blob so that the key becomes
	// effectively unknown
	pspFirmware := amdFw.PSPFirmware()
	for _, entry := range pspFirmware.PSPDirectoryLevel2.Entries {
		if entry.Type == amd_manifest.PSPDirectoryTableEntryType(smuOffChipFirmwareType) {
			amdFw.Firmware().ImageBytes()[entry.LocationOrValue+signatureParametersOffset] = 0x99
		}
	}

	keyDB, err := GetKeys(amdFw, 2)
	require.NoError(suite.T(), err)

	// ValidatePSPEntries will succeed, but the signature validation object returned will hold a signature check error
	signatureValidation, err := ValidatePSPEntries(amdFw, keyDB, PSPDirectoryLevel2, []uint32{uint32(smuOffChipFirmwareType)})
	require.NoError(suite.T(), err)

	require.Equal(suite.T(), 1, len(signatureValidation))
	require.Error(suite.T(), signatureValidation[0].err)

	var unknownSigningKeyErr *UnknownSigningKeyError
	require.True(suite.T(), errors.As(signatureValidation[0].err, &unknownSigningKeyErr))
}

func (suite *PsbBinarySuite) TestPSBBinaryDumpEntry() {
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	var buff bytes.Buffer

	// dump SMU off-chip firmware
	smuOffChipFirmwareType := amd_manifest.PSPDirectoryTableEntryType(0x12)
	n, err := DumpPSPEntry(amdFw, 2, smuOffChipFirmwareType, &buff)

	require.NoError(suite.T(), err)
	require.Equal(suite.T(), n, len(smuOffChipFirmware))

	shaSmuOffChipFirmwareHash := sha256.Sum256(buff.Bytes())
	expectedSmuOffChipFirmwareHash := [32]byte{
		0xd8, 0xdc, 0x03, 0xff, 0x18, 0x1a, 0xcc, 0x9d, 0x09, 0xac, 0x5a, 0xe7, 0x59, 0x67, 0xdc, 0x96,
		0x60, 0xe7, 0xbb, 0x08, 0xd0, 0x3f, 0xa3, 0xb1, 0xbf, 0x64, 0x17, 0x0e, 0x43, 0xdc, 0xb2, 0xf2,
	}
	require.Equal(suite.T(), expectedSmuOffChipFirmwareHash, shaSmuOffChipFirmwareHash)

	// dump Key database
	keyDatabaseLen := 4992

	buff.Reset()
	n, err = DumpPSPEntry(amdFw, 2, KeyDatabaseEntry, &buff)

	require.NoError(suite.T(), err)
	require.Equal(suite.T(), n, keyDatabaseLen)

	keyDBHash := sha256.Sum256(buff.Bytes())

	expectedKeyDBHash := [32]byte{
		0xec, 0x16, 0x0f, 0xfa, 0x63, 0xae, 0xcd, 0xc9, 0x23, 0xb0, 0x34, 0x16, 0x70, 0x85, 0x50, 0xe7,
		0x49, 0x48, 0xba, 0x6c, 0xf7, 0x7f, 0x01, 0x49, 0x53, 0x1b, 0x2a, 0x6a, 0x66, 0x28, 0x2a, 0x2c,
	}

	require.Equal(suite.T(), expectedKeyDBHash, keyDBHash)
}

func (suite *PsbBinarySuite) TestPSBBinaryPatchEntry() {
	require.Equal(suite.T(), FirmwareLen, len(suite.firmwareImage))

	amdFw, err := ParseAMDFirmware(suite.firmwareImage)
	require.NoError(suite.T(), err)

	smuOffChipFirmwareType := amd_manifest.PSPDirectoryTableEntryType(0x12)
	patchedEntry := make([]byte, len(smuOffChipFirmware))
	buff := bytes.NewBuffer(patchedEntry)

	firmwareImageCopy := make([]byte, 0, len(suite.firmwareImage))
	buffImage := bytes.NewBuffer(firmwareImageCopy)

	n, err := PatchPSPEntry(amdFw, 2, smuOffChipFirmwareType, buff, buffImage)

	require.NoError(suite.T(), err)
	require.Equal(suite.T(), len(suite.firmwareImage), n)

	start := uint64(0)
	end := uint64(0)
	pspFirmware := amdFw.PSPFirmware()
	for _, entry := range pspFirmware.PSPDirectoryLevel2.Entries {
		if entry.Type == amd_manifest.PSPDirectoryTableEntryType(smuOffChipFirmwareType) {
			start = entry.LocationOrValue
			end = entry.LocationOrValue + uint64(entry.Size)
		}
	}

	require.NotEqual(suite.T(), 0, start)
	require.NotEqual(suite.T(), 0, end)

	require.Equal(suite.T(), sha256.Sum256(firmwareImageCopy[:start]), sha256.Sum256(suite.firmwareImage[:start]))

	require.Equal(suite.T(), expectedSmuOffChipFirmwareHash, sha256.Sum256(suite.firmwareImage[start:end]))
	require.Equal(suite.T(), expectedZeroSmuOffChipFirmwareHash, sha256.Sum256(buffImage.Bytes()[start:end]))

	require.Equal(suite.T(), sha256.Sum256(buffImage.Bytes()[end:]), sha256.Sum256(suite.firmwareImage[end:]))
}

func TestPsbBinarySuite(t *testing.T) {
	suite.Run(t, new(PsbBinarySuite))
}

```

`pkg/amd/psb/pspbinary_artifacts_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

var smuOffChipFirmware = []byte{
	0xa9, 0x30, 0xf8, 0xf1, 0x34, 0x74, 0x22, 0x9e, 0x55, 0xc1, 0x71, 0xf0, 0x4b, 0xa7, 0x22, 0x93,
	0x24, 0x50, 0x53, 0x31, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x6e, 0x97, 0xee, 0xe0, 0x86, 0xbd, 0x4b, 0x41,
	0xb5, 0x82, 0x01, 0xce, 0x9f, 0xe3, 0x08, 0x73, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x04, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x4b, 0x2d, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x80, 0xb6, 0xa3, 0xe8, 0x08, 0xbe, 0x41, 0xb1, 0x34, 0x00, 0xc8, 0xfb, 0x14, 0x4b, 0x7f, 0x4e,
	0xc0, 0x11, 0xe0, 0x0d, 0xe9, 0x5c, 0x54, 0x02, 0xc2, 0x2f, 0x8b, 0xd2, 0x75, 0x4b, 0x09, 0xae,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x78, 0xda, 0xed, 0xc1, 0xc1, 0x00, 0x00, 0x00, 0x08, 0x04, 0xb0, 0x53, 0x48, 0x21, 0x85, 0x14,
	0xf2, 0x67, 0xea, 0x99, 0xc4, 0xb6, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xe0, 0xed, 0x74, 0x1d, 0x02, 0x3a, 0x00, 0xab, 0x00, 0x00, 0x00, 0x00,
	0xce, 0x76, 0xd2, 0x66, 0xf8, 0x65, 0x46, 0x6e, 0xa3, 0x99, 0xbb, 0x2a, 0x8f, 0x02, 0x6b, 0x42,
	0xcb, 0x28, 0x7e, 0xac, 0x60, 0x86, 0xa7, 0xef, 0xea, 0x29, 0xd3, 0x33, 0x9e, 0x69, 0x16, 0x44,
	0x24, 0x97, 0x7c, 0x8c, 0x6b, 0x17, 0x62, 0x0c, 0x87, 0xdb, 0x1d, 0x29, 0xe8, 0xd1, 0xb2, 0xb6,
	0xee, 0x34, 0x47, 0x5e, 0xe4, 0xb8, 0xe1, 0x68, 0xd9, 0x99, 0xba, 0xa0, 0xde, 0x75, 0x5e, 0xd1,
	0xd6, 0xbe, 0x00, 0x1f, 0x8a, 0x8a, 0xdc, 0xa4, 0xba, 0x8e, 0xc4, 0x75, 0xc4, 0x62, 0xf5, 0x99,
	0x14, 0xeb, 0x34, 0xf1, 0x3d, 0xb0, 0x4a, 0xab, 0xea, 0x0b, 0x9f, 0xa8, 0xcf, 0xdd, 0xb4, 0x8c,
	0x87, 0x0a, 0x2c, 0xe6, 0xf3, 0x67, 0x91, 0xb8, 0x0b, 0xb2, 0x56, 0xe0, 0xb8, 0xf0, 0x7b, 0xaf,
	0x08, 0x83, 0xd6, 0x0a, 0xb9, 0xb2, 0xd7, 0x3c, 0x0d, 0x7b, 0x52, 0x38, 0x83, 0x2e, 0x3c, 0x25,
	0xd6, 0xe2, 0x75, 0xc1, 0x01, 0xd7, 0xc1, 0x7f, 0x09, 0x4e, 0x69, 0xb7, 0x6d, 0x19, 0x6c, 0x19,
	0xa7, 0xe2, 0x9e, 0x9e, 0xae, 0x27, 0x31, 0xa6, 0x0c, 0x2d, 0xce, 0xbc, 0x42, 0xd7, 0x30, 0xab,
	0x8b, 0xc0, 0xf4, 0x11, 0xd1, 0xae, 0x3f, 0x8d, 0xea, 0xa4, 0x28, 0x28, 0x32, 0xa9, 0xa4, 0x79,
	0xab, 0x85, 0xfa, 0xa1, 0x05, 0x28, 0xdb, 0x65, 0xd9, 0xa7, 0xf5, 0xa2, 0x3c, 0x74, 0x97, 0xd4,
	0x9a, 0x09, 0xb8, 0x62, 0x41, 0x40, 0x96, 0xa8, 0x15, 0x76, 0x1c, 0xf8, 0x39, 0x5d, 0x3f, 0x90,
	0x6f, 0xca, 0x8b, 0x9b, 0x12, 0x1d, 0x30, 0x63, 0x1b, 0x41, 0x5a, 0x25, 0x66, 0x60, 0x29, 0xc2,
	0x99, 0xbe, 0x2f, 0x7b, 0xb3, 0x34, 0x52, 0x64, 0xc9, 0x0c, 0x09, 0x0c, 0x1e, 0x94, 0x1b, 0xcd,
	0xf2, 0x58, 0x0c, 0xb8, 0xc8, 0x68, 0x1c, 0xb4, 0x34, 0x9a, 0x8d, 0x06, 0xfc, 0x20, 0x9e, 0xb8,
	0x0f, 0x96, 0x5a, 0x10, 0xa2, 0x89, 0x89, 0x9c, 0x70, 0xae, 0x44, 0x5b, 0x55, 0x2a, 0xe6, 0x8d,
	0x49, 0xca, 0x07, 0x40, 0xb3, 0x21, 0xdd, 0x70, 0x05, 0x6c, 0xa1, 0x49, 0xd8, 0x48, 0xf2, 0xc5,
	0x5e, 0x47, 0xcf, 0x80, 0x1b, 0xf6, 0xcd, 0x5d, 0x58, 0x03, 0x1f, 0x44, 0x2d, 0x6e, 0x29, 0x99,
	0x26, 0x17, 0x81, 0x66, 0xca, 0x8b, 0x80, 0x36, 0x00, 0xfc, 0x6b, 0xab, 0xb0, 0xb2, 0xfe, 0x88,
	0x56, 0x72, 0xfe, 0x6e, 0xe6, 0xd0, 0xbf, 0x18, 0x7f, 0x8a, 0xe8, 0x48, 0x57, 0x00, 0x6f, 0xe5,
	0xeb, 0xd1, 0x3a, 0x41, 0xed, 0xab, 0xd4, 0x59, 0xa7, 0xfa, 0x51, 0x29, 0xcb, 0x8c, 0x5d, 0x66,
	0xc0, 0xa7, 0x01, 0x29, 0xdf, 0xb9, 0xd6, 0x1e, 0x40, 0x61, 0x37, 0x9a, 0xb2, 0x96, 0x29, 0x6c,
	0xce, 0xfc, 0xd7, 0x0b, 0x8e, 0x1d, 0xb1, 0xab, 0xd4, 0xed, 0xdb, 0xac, 0x4b, 0x4e, 0x8e, 0x3d,
	0x77, 0x6f, 0x40, 0xd1, 0xe1, 0xf6, 0xcb, 0x97, 0x08, 0xed, 0xf2, 0x7d, 0x6d, 0x0e, 0x40, 0xaf,
	0x28, 0x46, 0xf9, 0x55, 0x8b, 0x02, 0x8f, 0xb8, 0x75, 0x1e, 0x0f, 0xf3, 0xaf, 0x01, 0xfe, 0x3d,
	0x96, 0xa6, 0x0d, 0x6b, 0x07, 0xc7, 0x93, 0x7e, 0x00, 0x54, 0x05, 0x72, 0x4a, 0x32, 0x14, 0x29,
	0x2a, 0x33, 0x7c, 0x9f, 0xd3, 0x7f, 0x2f, 0x3d, 0xea, 0x91, 0x92, 0x9a, 0xad, 0xee, 0xda, 0x8f,
	0x8f, 0xdb, 0xa1, 0xf2, 0x34, 0xc6, 0x32, 0x8c, 0x88, 0xe1, 0x48, 0x3c, 0xf7, 0x89, 0x06, 0x0c,
	0xcd, 0xc9, 0xbc, 0x28, 0x2b, 0x4e, 0x6b, 0xf1, 0x1d, 0x9c, 0xa1, 0xa2, 0x8b, 0x26, 0xf7, 0xb3,
	0xb5, 0x42, 0xbf, 0x03, 0xb8, 0x43, 0x63, 0x28, 0x32, 0x3a, 0x0b, 0x25, 0x4a, 0xf5, 0x26, 0x47,
	0xb6, 0x7b, 0x68, 0xf0, 0x7c, 0xb3, 0x34, 0x9d, 0x76, 0xcb, 0xe6, 0xaa, 0x67, 0x84, 0x21, 0x26,
}

// Test image built by laying over a 16 MiB zero file the following sections of the firmware:
// * Embedded Firmware Range
// * PSPDirectoryLevel1 Range
// * PSPDirectoryLevel2 Range
// * BIOSDirectoryLevel1 Range
// * BIOSDirectoryLevel2 Range
// * SMU off-chip firmware Range (PSP Directory, 0x12, level 2)
// * Key database (PSP Directory, 0x50, level 2)
// * ABL Public Key (PSP Directory, 0xA, level 2)
// * OEM Signing Key (BIOS Directory, 0x05, level 2)
// * AMD Public Key (PSP Directory, 0x00, level 1)
// * PMU Firmware Data Portion (BIOS Directory, 0x65, level 2)
//
// The resulting image has been zstd compressed

var firmwareImageCompressed = []byte{
	0x28, 0xb5, 0x2f, 0xfd, 0x84, 0x58, 0x00, 0x00, 0x00, 0x01, 0x54, 0x00, 0x00, 0x10, 0x00, 0x00,
	0x01, 0x00, 0xfb, 0xff, 0x39, 0xc0, 0x02, 0xf4, 0x00, 0x00, 0x90, 0xaa, 0x55, 0xaa, 0x55, 0x00,
	0x20, 0x06, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x00, 0x20, 0x17, 0x00, 0xff, 0x00, 0x04, 0x10, 0x00,
	0xb2, 0xff, 0xb9, 0xb8, 0x0f, 0x37, 0x10, 0x2d, 0x02, 0x00, 0x10, 0x00, 0xfc, 0x18, 0x00, 0x24,
	0x2d, 0x00, 0x24, 0x50, 0x53, 0x50, 0x19, 0xde, 0x5c, 0x92, 0x11, 0x00, 0x00, 0x00, 0x10, 0x05,
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x24, 0x01, 0x02, 0x00, 0x00,
	0x24, 0x1b, 0x03, 0x00, 0x00, 0x00, 0x80, 0x66, 0x01, 0x00, 0x00, 0x29, 0x06, 0x08, 0x00, 0x00,
	0x00, 0xa0, 0xf4, 0x01, 0x00, 0x00, 0x90, 0x07, 0x0a, 0x00, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00,
	0x00, 0x85, 0x09, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00,
	0x00, 0x8c, 0x13, 0x00, 0x00, 0x00, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x91, 0x09, 0x21, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0xce, 0x22, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	0xd0, 0x24, 0x00, 0x00, 0x00, 0x50, 0xb7, 0x00, 0x00, 0x00, 0xe0, 0x2a, 0x00, 0x00, 0x00, 0xa0,
	0xe8, 0x00, 0x00, 0x00, 0x98, 0x0a, 0x30, 0x00, 0x00, 0x00, 0x10, 0xb7, 0x08, 0x00, 0x00, 0x81,
	0x0b, 0x40, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x20, 0x1b, 0x42, 0x00, 0x00, 0x00,
	0xc0, 0x14, 0x00, 0x00, 0x00, 0x39, 0x14, 0x47, 0x00, 0x00, 0x00, 0x80, 0x26, 0x00, 0x00, 0x00,
	0x4e, 0x14, 0x50, 0x00, 0x00, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x75, 0x01, 0x00, 0x00, 0x00,
	0x94, 0xc3, 0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67, 0x1d, 0x08, 0x3f, 0xb6,
	0x10, 0x01, 0x00, 0xab, 0x65, 0x45, 0x12, 0x5a, 0x63, 0x5d, 0x86, 0xdf, 0x23, 0x0b, 0xf4, 0x41,
	0x6e, 0xdf, 0xf1, 0x40, 0xe8, 0xb5, 0x20, 0x7f, 0x72, 0x7a, 0xef, 0x72, 0xc3, 0x14, 0x0c, 0x99,
	0xe5, 0x83, 0x75, 0xc7, 0xb3, 0xfb, 0xa6, 0x70, 0x79, 0xed, 0x5c, 0x64, 0xd1, 0x4b, 0x01, 0xd6,
	0xc9, 0x4f, 0x8c, 0x53, 0xd2, 0xf5, 0x7c, 0x7c, 0x7c, 0xcd, 0xf4, 0xe8, 0xe2, 0xda, 0xad, 0xd8,
	0x30, 0xa8, 0x20, 0xa4, 0xa0, 0xe3, 0xef, 0xaa, 0x90, 0xbe, 0x42, 0x8c, 0x3d, 0x9b, 0x31, 0xb6,
	0x78, 0xa4, 0xd6, 0xaa, 0xc6, 0xa8, 0x68, 0xe9, 0xc3, 0x1c, 0x69, 0xb0, 0x9e, 0x31, 0xbb, 0x72,
	0x4b, 0x05, 0xcc, 0x4d, 0xc3, 0x9f, 0x31, 0x79, 0x50, 0x93, 0xd1, 0x2b, 0x1e, 0xc2, 0xf7, 0xed,
	0xd2, 0x48, 0x9e, 0xcf, 0xea, 0x09, 0x7e, 0x49, 0x7a, 0xda, 0x9b, 0x24, 0x23, 0x61, 0xdc, 0x78,
	0x3d, 0x43, 0x67, 0x33, 0xfc, 0xac, 0xcf, 0x45, 0x2e, 0x5b, 0x86, 0xac, 0x62, 0x4b, 0x17, 0xb4,
	0x00, 0x93, 0xe6, 0x27, 0x80, 0xfe, 0x2d, 0x42, 0xe2, 0x9b, 0xb7, 0xe4, 0x9d, 0x43, 0x77, 0x73,
	0xaa, 0x50, 0x32, 0xf5, 0x95, 0xad, 0xbd, 0x6b, 0x1c, 0x90, 0x5e, 0xec, 0xad, 0x5c, 0xcc, 0x13,
	0xe6, 0x7a, 0x62, 0x89, 0x68, 0x2c, 0xbb, 0x8f, 0xf1, 0x38, 0xf3, 0x62, 0x60, 0x13, 0x21, 0xf3,
	0xc9, 0x86, 0x4f, 0xe5, 0x92, 0x43, 0x05, 0xfa, 0xec, 0x0a, 0x41, 0x1b, 0x47, 0xd5, 0xb1, 0x45,
	0x34, 0x44, 0x79, 0x82, 0x64, 0x70, 0xb8, 0xac, 0x2b, 0x9e, 0x52, 0xfc, 0xff, 0x03, 0x29, 0x07,
	0xac, 0xf9, 0x22, 0x5b, 0x33, 0x72, 0xcf, 0xc5, 0x44, 0x6c, 0xc9, 0x60, 0x13, 0x87, 0x28, 0xf2,
	0xed, 0x9b, 0xe5, 0x6d, 0x6a, 0x1e, 0xa0, 0x6c, 0xa0, 0x03, 0xcc, 0xc4, 0xc4, 0x92, 0xe3, 0x7e,
	0xc5, 0x0a, 0x2f, 0xff, 0x9d, 0xa1, 0xa6, 0xd7, 0xb7, 0x03, 0x7b, 0x3f, 0x8c, 0x27, 0xe3, 0xdf,
	0xb1, 0x7a, 0x3d, 0x48, 0xfd, 0x87, 0x1d, 0x4a, 0x87, 0xe9, 0xc2, 0x65, 0xe9, 0x5b, 0xcd, 0x6e,
	0xb8, 0xb4, 0xa2, 0xf3, 0x4f, 0x34, 0x62, 0x82, 0x39, 0x0d, 0xa2, 0x5c, 0x0b, 0x26, 0xe6, 0xd5,
	0xe7, 0xcf, 0x85, 0x15, 0xca, 0xed, 0xee, 0x51, 0x05, 0x65, 0x80, 0xdb, 0x3e, 0x9a, 0x5e, 0x68,
	0x3f, 0xa8, 0x2a, 0x64, 0x2e, 0xd9, 0xe2, 0x07, 0xaa, 0xbc, 0xb8, 0x7a, 0x0c, 0xfe, 0x38, 0xae,
	0x57, 0x2c, 0x3d, 0x36, 0xee, 0x77, 0x47, 0xeb, 0xb4, 0xc0, 0x8e, 0xaf, 0xef, 0xf8, 0x81, 0x6d,
	0xe6, 0xb3, 0xd6, 0xd8, 0x39, 0xe2, 0x1d, 0x46, 0x17, 0x39, 0x6b, 0xde, 0x4b, 0x8e, 0x9a, 0x32,
	0x7c, 0x3f, 0xee, 0x4f, 0x4d, 0x73, 0xd4, 0x8b, 0x5f, 0x52, 0x72, 0x3d, 0xee, 0x3a, 0x50, 0x26,
	0x26, 0xab, 0x61, 0x80, 0x27, 0x6a, 0x3c, 0x4b, 0xb6, 0xb1, 0x52, 0x43, 0xdc, 0xe9, 0xfe, 0xdd,
	0x5f, 0xbc, 0x3b, 0xd6, 0x52, 0xad, 0x37, 0x47, 0x39, 0xf2, 0x04, 0x87, 0x44, 0x73, 0xff, 0x57,
	0x38, 0xf7, 0x6d, 0x91, 0xf1, 0x29, 0x7e, 0x3e, 0x5d, 0xe6, 0x4e, 0xaa, 0xac, 0xd8, 0x73, 0x58,
	0xc7, 0x8a, 0xcd, 0xcc, 0xd2, 0xc0, 0x44, 0xd6, 0x5a, 0x5b, 0x34, 0xac, 0x47, 0xd4, 0x94, 0xa8,
	0x90, 0x6d, 0x5e, 0xd1, 0xd4, 0xc7, 0xd4, 0xf1, 0x28, 0xbf, 0x5f, 0x72, 0xb2, 0x18, 0xe6, 0x6d,
	0x71, 0x23, 0x25, 0xe0, 0x5b, 0x46, 0xc7, 0xd0, 0xbb, 0x42, 0x3f, 0x2f, 0xa1, 0x49, 0x49, 0x21,
	0x71, 0xd4, 0xf3, 0xd5, 0x63, 0x57, 0x8d, 0x5b, 0x60, 0xf3, 0xd5, 0x17, 0x6c, 0xb5, 0xa8, 0xdb,
	0x92, 0xc5, 0x3e, 0x98, 0x15, 0xdb, 0x25, 0xb6, 0xa2, 0x96, 0x89, 0xe8, 0x75, 0x4e, 0x12, 0xd9,
	0x79, 0xb7, 0xd0, 0x1c, 0x00, 0xc9, 0xd5, 0x20, 0x07, 0x00, 0xc4, 0xdf, 0x17, 0x6a, 0xce, 0xe7,
	0x94, 0xed, 0x2e, 0x1e, 0x6e, 0x16, 0x18, 0x17, 0x14, 0x9f, 0x35, 0x13, 0xe1, 0x6e, 0xb9, 0x0a,
	0xc0, 0x20, 0x70, 0x1e, 0x34, 0x0f, 0xc4, 0x83, 0xf3, 0xa0, 0x79, 0x80, 0x11, 0x18, 0x08, 0x0c,
	0x02, 0xd7, 0x0f, 0x1d, 0xb9, 0x84, 0x01, 0x3b, 0x20, 0xa0, 0x1b, 0xa0, 0x79, 0x20, 0x1e, 0x9c,
	0x67, 0x01, 0xb5, 0x29, 0x10, 0xcc, 0x03, 0x10, 0xd0, 0x80, 0xf9, 0xbf, 0x07, 0x42, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0xfc, 0x06, 0x00, 0x92, 0x88, 0x1e,
	0x2a, 0x80, 0x55, 0x19, 0x0e, 0x33, 0xc0, 0x66, 0x04, 0x18, 0xf4, 0x82, 0xe5, 0x02, 0x08, 0x4a,
	0x3a, 0x75, 0x62, 0x7a, 0x3d, 0x09, 0x34, 0x39, 0x62, 0x87, 0xc6, 0x3b, 0xf6, 0x6f, 0x57, 0x69,
	0xb1, 0x2f, 0x2c, 0xfb, 0xdc, 0x56, 0x60, 0xcc, 0x7f, 0x99, 0x02, 0x8c, 0x8b, 0xc5, 0x75, 0x42,
	0xf8, 0xcb, 0x4d, 0x27, 0x2c, 0xc8, 0xca, 0xcf, 0x4f, 0x69, 0x2a, 0x3d, 0x53, 0x27, 0xca, 0x0f,
	0x01, 0xe8, 0x14, 0x45, 0xa4, 0xaf, 0xa8, 0xfd, 0xd5, 0xac, 0xb4, 0xf5, 0x02, 0xfe, 0x86, 0x35,
	0x7e, 0x75, 0xfe, 0x07, 0xd6, 0xb8, 0xf5, 0x38, 0x7f, 0x9b, 0x75, 0x5f, 0xd5, 0xdf, 0x00, 0xd5,
	0x6d, 0xfd, 0x63, 0xb2, 0xec, 0x47, 0x4c, 0x24, 0xd4, 0x1f, 0x18, 0x3c, 0x29, 0x78, 0x52, 0xbf,
	0x12, 0x09, 0x07, 0x47, 0x26, 0xa4, 0x58, 0x24, 0x0c, 0x07, 0x28, 0x20, 0x81, 0x06, 0x13, 0xd0,
	0x50, 0x30, 0xf1, 0x4c, 0x7c, 0x2d, 0xde, 0x15, 0x2e, 0x0b, 0x64, 0x39, 0x24, 0xe0, 0xde, 0x32,
	0x40, 0x28, 0x58, 0x11, 0xec, 0xd0, 0x9d, 0x8d, 0xad, 0x11, 0xe1, 0xc8, 0x02, 0x17, 0x89, 0xb9,
	0xb7, 0x79, 0x70, 0x67, 0xd0, 0xba, 0x26, 0x95, 0xbd, 0x7b, 0x21, 0x04, 0x6f, 0x29, 0x72, 0xbd,
	0x4e, 0x8b, 0x00, 0xa2, 0xc2, 0xda, 0xff, 0x70, 0x2e, 0x8b, 0x84, 0xb3, 0x77, 0x8b, 0x62, 0x5e,
	0xb3, 0xc2, 0x04, 0x6e, 0xff, 0x83, 0x84, 0xeb, 0x3f, 0xca, 0x93, 0xe5, 0x00, 0xe1, 0xe1, 0x04,
	0x80, 0x78, 0xd3, 0xfb, 0xff, 0x10, 0x3b, 0xfe, 0x8f, 0x5c, 0xb8, 0x02, 0x02, 0x00, 0x10, 0x00,
	0xc4, 0x03, 0x00, 0x54, 0x03, 0x00, 0x24, 0x50, 0x4c, 0x32, 0xe5, 0xa9, 0xc5, 0xd0, 0x07, 0x00,
	0x20, 0x24, 0x1d, 0x09, 0x19, 0x1f, 0x20, 0x1f, 0x27, 0x1f, 0x2c, 0x1f, 0x69, 0x1f, 0x70, 0x1f,
	0x80, 0x1f, 0x38, 0x20, 0x21, 0x21, 0x38, 0x80, 0x00, 0x00, 0x00, 0xe0, 0x29, 0x39, 0x33, 0x01,
	0x00, 0x00, 0x60, 0x2a, 0x94, 0x2b, 0xa9, 0x2b, 0xd0, 0x2b, 0x19, 0x00, 0xfd, 0xdb, 0x9c, 0x0e,
	0xc4, 0x81, 0x0a, 0x03, 0x19, 0x03, 0x89, 0x03, 0x00, 0xd5, 0x34, 0x80, 0x2e, 0xb0, 0x2e, 0x90,
	0x02, 0x71, 0xc1, 0x85, 0x81, 0x8c, 0x81, 0x8c, 0x81, 0x8c, 0x81, 0x8c, 0x81, 0x8c, 0x81, 0x8c,
	0x81, 0x40, 0xa0, 0x01, 0x34, 0x04, 0x8f, 0x01, 0xd1, 0xe3, 0xff, 0xd4, 0x0a, 0x3b, 0xff, 0x4f,
	0x0d, 0xc7, 0x00, 0x40, 0xb5, 0x8b, 0xf9, 0x3f, 0x72, 0xc0, 0x06, 0x02, 0x00, 0x10, 0x00, 0x3c,
	0x36, 0x00, 0x94, 0x68, 0x00, 0x01, 0x00, 0x00, 0x00, 0x28, 0x9a, 0xfe, 0x36, 0xf6, 0x3c, 0x4f,
	0x88, 0xbc, 0x13, 0x85, 0xaa, 0x6d, 0x92, 0x38, 0x91, 0x02, 0x39, 0x9e, 0xe5, 0x9d, 0x7a, 0xe1,
	0xa2, 0xce, 0x70, 0xaf, 0x37, 0x06, 0x01, 0x98, 0xfd, 0xb2, 0x44, 0x0a, 0xae, 0xbf, 0xcb, 0x24,
	0x42, 0x3a, 0x8e, 0xb1, 0xe7, 0xdb, 0x34, 0x50, 0xa0, 0xec, 0x4c, 0x47, 0x44, 0x22, 0xf3, 0xc3,
	0x50, 0x94, 0x6a, 0x9d, 0x93, 0xda, 0x1a, 0x23, 0xc4, 0x5d, 0xa2, 0xe9, 0xb4, 0x23, 0x25, 0x19,
	0x29, 0x62, 0x64, 0x0b, 0x45, 0xa4, 0xe3, 0xa6, 0x08, 0x71, 0xb5, 0x5d, 0x02, 0x58, 0x58, 0xf3,
	0x40, 0x40, 0x8b, 0x25, 0xdb, 0x70, 0xf1, 0x43, 0x0f, 0xc0, 0x77, 0x86, 0xa6, 0x74, 0x9c, 0x08,
	0x34, 0x88, 0x9d, 0x0f, 0xd6, 0x9c, 0x1d, 0xae, 0xd3, 0x45, 0xfa, 0xf0, 0x28, 0xf4, 0xa1, 0xd9,
	0x61, 0xc3, 0xf2, 0xd9, 0x48, 0xee, 0x12, 0x47, 0xe2, 0x70, 0xa0, 0x4f, 0x3f, 0xca, 0xc4, 0x8d,
	0xe9, 0xc7, 0x27, 0x8c, 0x0c, 0xf0, 0x91, 0x27, 0x76, 0x10, 0x81, 0x0f, 0x6a, 0x8d, 0x7f, 0x92,
	0xc1, 0xab, 0x77, 0xde, 0x53, 0xb7, 0x08, 0xf0, 0x97, 0x37, 0xed, 0x23, 0xbe, 0x4a, 0xdb, 0x2b,
	0xd3, 0x50, 0xeb, 0x6f, 0xee, 0x07, 0x8c, 0x0a, 0x6e, 0x08, 0x64, 0x29, 0xd2, 0xa2, 0xbd, 0x72,
	0x17, 0x2f, 0x57, 0xa9, 0x8d, 0x7a, 0x63, 0xc6, 0xbc, 0x14, 0x3c, 0x88, 0x65, 0x9f, 0xf7, 0xd0,
	0x6d, 0xe3, 0xa5, 0xb4, 0x4f, 0xe2, 0x08, 0x3d, 0x15, 0xff, 0xb2, 0x1e, 0x1f, 0xfa, 0x26, 0x7f,
	0x51, 0xb2, 0x53, 0x6b, 0x4b, 0x0f, 0xe7, 0x70, 0xbd, 0x1f, 0x48, 0x8b, 0xdc, 0x44, 0xf6, 0xdb,
	0x13, 0xbb, 0x87, 0x98, 0x34, 0xbb, 0xd2, 0x9c, 0xc7, 0x9c, 0x1b, 0xea, 0xf3, 0xe5, 0x90, 0xba,
	0xc5, 0x74, 0xd8, 0x3a, 0xf8, 0x5e, 0xc7, 0xfa, 0xe2, 0xdc, 0xb7, 0xff, 0x02, 0x26, 0x0f, 0xea,
	0xdd, 0x16, 0x19, 0xe3, 0x2c, 0xc7, 0xc2, 0xab, 0x3a, 0x83, 0xaa, 0x8d, 0xe6, 0xbc, 0xc3, 0x45,
	0x7c, 0x28, 0x75, 0x46, 0x9e, 0x71, 0x8c, 0x60, 0x43, 0xec, 0x0c, 0x97, 0xa3, 0x09, 0xf5, 0xbc,
	0xab, 0x70, 0x33, 0x20, 0x14, 0xb3, 0x4b, 0xcc, 0x37, 0x58, 0x98, 0x43, 0x75, 0x3d, 0x55, 0xe9,
	0x62, 0x97, 0x2a, 0x76, 0x90, 0x41, 0x8a, 0x84, 0x08, 0xb6, 0xd0, 0x2c, 0x7c, 0x67, 0x81, 0xca,
	0xc1, 0x89, 0x6f, 0xcf, 0xb8, 0x6c, 0xaa, 0x47, 0xe2, 0x13, 0xb5, 0xfd, 0xac, 0x71, 0xf7, 0x91,
	0x33, 0xef, 0x2b, 0x42, 0x6a, 0xc4, 0xcd, 0x85, 0x48, 0x1e, 0x6f, 0x9c, 0xf7, 0x57, 0xa0, 0x00,
	0xbc, 0xe3, 0x35, 0xd5, 0x4c, 0xd3, 0x47, 0x19, 0xf5, 0xda, 0x9b, 0xe9, 0x4e, 0x92, 0xc1, 0x30,
	0x47, 0xdd, 0x3f, 0xce, 0x6c, 0xc7, 0xd9, 0xae, 0x0c, 0x87, 0xf5, 0x99, 0x68, 0x2f, 0xa3, 0xfe,
	0x23, 0x42, 0x4b, 0x7a, 0x17, 0x21, 0x3e, 0x33, 0x06, 0x61, 0x50, 0x28, 0x95, 0xdd, 0x96, 0x29,
	0xa8, 0x2a, 0x87, 0xaa, 0x67, 0x4c, 0x71, 0x19, 0x1d, 0xc0, 0xa9, 0x37, 0x89, 0x52, 0x6a, 0xfa,
	0x25, 0xd5, 0xf7, 0xbb, 0x6c, 0xd1, 0x2f, 0x1d, 0x66, 0x1f, 0x98, 0x4f, 0x1a, 0x47, 0xcb, 0xcb,
	0xca, 0x1a, 0x4a, 0x5d, 0xa6, 0xec, 0x1b, 0x1a, 0xe7, 0x2b, 0x4d, 0x55, 0x4f, 0x46, 0x93, 0x15,
	0x78, 0xc9, 0x91, 0xa2, 0xba, 0xf7, 0x97, 0x1a, 0xb4, 0x17, 0x63, 0xae, 0x71, 0x65, 0x34, 0x12,
	0xfa, 0xa8, 0x10, 0x34, 0xcf, 0x67, 0x01, 0x05, 0x6c, 0x88, 0x55, 0x90, 0x3f, 0xab, 0xe5, 0x4a,
	0x4c, 0x22, 0x27, 0x07, 0xa4, 0xd1, 0x2f, 0xa6, 0x0d, 0x1d, 0x3c, 0x07, 0xfa, 0xb5, 0x13, 0x94,
	0x2f, 0x92, 0x36, 0xf7, 0x5a, 0x97, 0x1b, 0xf0, 0x9e, 0x73, 0x2b, 0x5c, 0x2b, 0x03, 0xfb, 0xc5,
	0x74, 0x76, 0x3a, 0x08, 0xc2, 0xfc, 0xf8, 0x1a, 0xcf, 0xcc, 0xb8, 0x38, 0x19, 0xa7, 0xf4, 0x99,
	0x51, 0x34, 0xa7, 0xc6, 0x4d, 0x01, 0x94, 0x2a, 0xe1, 0x80, 0xa1, 0xda, 0xa6, 0xb6, 0x2e, 0x80,
	0xa1, 0xc1, 0xd4, 0xc2, 0xc0, 0x15, 0x06, 0x4c, 0xb6, 0xe9, 0xd2, 0x16, 0xaa, 0x51, 0x67, 0xa1,
	0x0e, 0x1d, 0xf9, 0x15, 0x8c, 0xcb, 0x7d, 0xc7, 0x14, 0xc9, 0xb4, 0x99, 0xe7, 0x8e, 0xab, 0xc0,
	0x25, 0x31, 0xf9, 0x69, 0x59, 0x8a, 0x02, 0x0b, 0xab, 0xc9, 0x2a, 0x3a, 0xd4, 0x40, 0xa8, 0x23,
	0x67, 0x0a, 0xec, 0x38, 0xcb, 0xcc, 0xd9, 0xf4, 0xb4, 0xe0, 0x4e, 0xa6, 0x09, 0x2c, 0xe2, 0x37,
	0x87, 0xd0, 0x03, 0x09, 0x45, 0xe9, 0x9c, 0xe7, 0x01, 0x0a, 0x95, 0x84, 0x40, 0x00, 0x54, 0x2c,
	0xae, 0xd1, 0x0d, 0xfc, 0x83, 0x1b, 0xbd, 0xb7, 0xe0, 0x71, 0x63, 0xc7, 0x02, 0x9d, 0xee, 0x4b,
	0x89, 0x5c, 0x5f, 0xc3, 0xc5, 0x77, 0xf6, 0xe9, 0x75, 0xa2, 0x40, 0x43, 0x26, 0x91, 0x26, 0x1a,
	0xee, 0x8c, 0x90, 0x00, 0x45, 0xc4, 0x8f, 0xdc, 0xce, 0x89, 0x03, 0xd7, 0x9a, 0x55, 0x4c, 0x37,
	0x4c, 0xc7, 0x81, 0xe1, 0x4c, 0x5b, 0x4a, 0x75, 0x5c, 0x7b, 0x2f, 0x15, 0xbc, 0x88, 0xe7, 0x9b,
	0xa8, 0x29, 0xe7, 0xef, 0x76, 0x20, 0x12, 0xba, 0x86, 0xbc, 0x6b, 0xd2, 0xdb, 0x66, 0xf2, 0xfb,
	0x4e, 0x6d, 0x60, 0xa9, 0xdd, 0x23, 0x48, 0xf8, 0xf5, 0x33, 0x1a, 0x6f, 0x59, 0xa8, 0x1d, 0xd9,
	0x53, 0x11, 0x08, 0x09, 0x0d, 0x2b, 0xda, 0x31, 0x45, 0xc9, 0x50, 0xbd, 0xbd, 0x46, 0xd7, 0x9b,
	0x10, 0xae, 0xcd, 0x38, 0x4c, 0xb6, 0xaf, 0x80, 0xb7, 0xd8, 0xae, 0x3a, 0x1a, 0xc1, 0x77, 0x54,
	0x6e, 0x92, 0x21, 0xfc, 0xf6, 0xc0, 0x70, 0x35, 0xef, 0xf5, 0x1a, 0xa2, 0xf8, 0x2f, 0x2e, 0x25,
	0xbe, 0xa6, 0xd6, 0xdc, 0x67, 0x41, 0x69, 0xac, 0x63, 0x30, 0x65, 0x0d, 0x07, 0xfa, 0xae, 0x89,
	0x64, 0x70, 0x6b, 0xbb, 0xca, 0xa7, 0x59, 0x7f, 0x0d, 0x25, 0x96, 0xfb, 0xa3, 0xe0, 0xa5, 0x1a,
	0x31, 0x3f, 0x6c, 0x2d, 0xdf, 0x60, 0x26, 0x25, 0x18, 0x64, 0x4e, 0x9d, 0xea, 0x18, 0xc7, 0x2d,
	0xb0, 0x96, 0xd6, 0x38, 0x63, 0x95, 0x3c, 0xb8, 0x9e, 0x76, 0xba, 0xea, 0x53, 0xe1, 0xe6, 0x08,
	0x57, 0xe3, 0xbc, 0xb8, 0xb1, 0xd1, 0x4a, 0xd1, 0x35, 0xd1, 0x39, 0x23, 0xab, 0x1d, 0x4d, 0x3e,
	0x9f, 0x9d, 0xec, 0x11, 0x70, 0x01, 0x23, 0xe1, 0x68, 0xfc, 0x71, 0x53, 0x2f, 0xc6, 0x54, 0xd1,
	0x97, 0x2f, 0xa7, 0x0e, 0x66, 0x07, 0x7b, 0x01, 0x94, 0x8f, 0xf3, 0x83, 0x9c, 0x4e, 0xce, 0x03,
	0xac, 0x18, 0x64, 0x22, 0x2d, 0x93, 0xb5, 0xfb, 0x41, 0xd4, 0xfb, 0x7e, 0x4f, 0x1a, 0xf0, 0x57,
	0xb5, 0x6b, 0x93, 0x89, 0x9f, 0xa8, 0xd5, 0xbe, 0xde, 0x27, 0x75, 0x2f, 0xf2, 0x59, 0x32, 0xe9,
	0x95, 0xe4, 0xbe, 0x38, 0xf4, 0x4b, 0x9d, 0xda, 0xdf, 0xde, 0xad, 0x57, 0x04, 0x8a, 0x8f, 0x5c,
	0x3c, 0xfc, 0xab, 0xd7, 0x9d, 0xab, 0x2c, 0x03, 0xe6, 0xbc, 0x9a, 0x3a, 0x38, 0xde, 0xbd, 0xa6,
	0xf7, 0x8c, 0x24, 0x89, 0xb3, 0x02, 0x54, 0x11, 0xa4, 0x34, 0xd5, 0x0e, 0xee, 0xa1, 0xb5, 0x48,
	0xd1, 0xf3, 0x65, 0xea, 0x90, 0x48, 0xb1, 0x0d, 0xe1, 0x91, 0x5a, 0xa7, 0x56, 0x93, 0xfc, 0x26,
	0x7c, 0xc7, 0xed, 0xae, 0xba, 0x57, 0x9d, 0x77, 0xa3, 0x95, 0x2b, 0xd8, 0x1f, 0x76, 0xc6, 0x39,
	0xb9, 0x2c, 0x12, 0xfa, 0x05, 0x61, 0xb3, 0x91, 0xc4, 0x51, 0x04, 0xcd, 0xb7, 0xc4, 0x98, 0x50,
	0x3f, 0x2f, 0x92, 0xcb, 0x2a, 0xc6, 0x72, 0xdb, 0x14, 0x13, 0xe7, 0xe1, 0xc6, 0xaf, 0xdc, 0x0b,
	0xc1, 0xeb, 0x3b, 0x77, 0x2d, 0x20, 0xbe, 0x85, 0x28, 0xc7, 0x00, 0x00, 0x00, 0xa4, 0x98, 0xa1,
	0x34, 0x03, 0x42, 0xed, 0x7a, 0x0e, 0x19, 0x63, 0x5d, 0x08, 0xdf, 0x91, 0x95, 0x24, 0x50, 0x53,
	0x31, 0x01, 0x6e, 0x97, 0xee, 0xe0, 0x86, 0xbd, 0x4b, 0x41, 0xb5, 0x82, 0x01, 0xce, 0x9f, 0xe3,
	0x08, 0x73, 0x01, 0x04, 0x00, 0x1c, 0x01, 0x00, 0x00, 0x51, 0x2d, 0x00, 0x12, 0x80, 0xb6, 0xa3,
	0xe8, 0x08, 0xbe, 0x41, 0xb1, 0x34, 0x00, 0xc8, 0xfb, 0x14, 0x4b, 0x7f, 0x4e, 0xc0, 0x11, 0xe0,
	0x0d, 0xe9, 0x5c, 0x54, 0x02, 0xc2, 0x2f, 0x8b, 0xd2, 0x75, 0x4b, 0x09, 0xae, 0x78, 0xda, 0xed,
	0xc1, 0xc1, 0x00, 0x00, 0x00, 0x08, 0x04, 0xb0, 0x53, 0x48, 0x21, 0x85, 0x14, 0xf2, 0x67, 0xea,
	0x99, 0xc4, 0xb6, 0x04, 0xe0, 0xed, 0x74, 0x1d, 0x02, 0x3a, 0x00, 0xab, 0x52, 0xed, 0xe4, 0x72,
	0x95, 0x84, 0x8a, 0x82, 0xb7, 0x2b, 0x23, 0xbb, 0x88, 0xc1, 0xe8, 0x8e, 0x3e, 0x01, 0x70, 0x85,
	0x39, 0x79, 0x97, 0x9a, 0x62, 0x8a, 0xe7, 0x12, 0x32, 0x46, 0xf3, 0xec, 0xdf, 0x51, 0x34, 0x5f,
	0x5e, 0xf6, 0x3a, 0x66, 0xe2, 0x92, 0x6f, 0x85, 0x65, 0xd3, 0x4a, 0xb3, 0x05, 0x18, 0x11, 0x90,
	0x6d, 0xaa, 0x2f, 0x9c, 0x83, 0x84, 0x87, 0xb7, 0xc1, 0xbf, 0xb9, 0x3a, 0xe1, 0x43, 0x2c, 0x2b,
	0xad, 0x4f, 0xa7, 0x2e, 0xa3, 0x1d, 0xb2, 0xbe, 0x73, 0x9d, 0x88, 0xe1, 0x6b, 0x96, 0x93, 0x09,
	0x79, 0x18, 0x98, 0x29, 0x83, 0xe2, 0x15, 0xb4, 0x18, 0x25, 0x88, 0x20, 0x3a, 0xe7, 0xfe, 0xca,
	0xce, 0x4a, 0x7e, 0x2c, 0x7f, 0xdb, 0x92, 0x4b, 0xd8, 0xd3, 0x3a, 0x9c, 0x25, 0x74, 0xd0, 0xc6,
	0x69, 0x80, 0x11, 0x4e, 0x07, 0xec, 0xf1, 0x58, 0x47, 0x6c, 0x79, 0xe9, 0xfc, 0xf3, 0xe6, 0xd4,
	0xb8, 0xd0, 0xc5, 0xf7, 0xe4, 0x30, 0x64, 0x1d, 0xc3, 0xf3, 0xde, 0xf2, 0xd5, 0x8e, 0x03, 0xb2,
	0x67, 0x3d, 0x6d, 0xdb, 0x35, 0x88, 0xa3, 0xe6, 0xf5, 0xd0, 0xcc, 0xf4, 0x2d, 0x01, 0x1a, 0x62,
	0x5e, 0xcc, 0x9e, 0xfd, 0xb6, 0xbc, 0x5b, 0xca, 0x99, 0x24, 0x52, 0xb9, 0xb1, 0x3e, 0xdf, 0x85,
	0x53, 0x3e, 0xb8, 0xb3, 0x4b, 0x6d, 0x82, 0xc7, 0x7b, 0x3b, 0x71, 0x21, 0xbb, 0x83, 0x3a, 0xa5,
	0xc3, 0x6b, 0x37, 0x60, 0xf3, 0x2c, 0x71, 0xc6, 0x87, 0xe5, 0x13, 0xa9, 0xb6, 0xc9, 0x3f, 0x59,
	0x63, 0x7a, 0xba, 0x28, 0xcc, 0xa4, 0x00, 0x0b, 0xb1, 0x13, 0x00, 0xb4, 0x5a, 0x1d, 0x53, 0x20,
	0xbf, 0xf4, 0xd8, 0x74, 0xc6, 0x6b, 0x5a, 0x22, 0xe3, 0x5b, 0xe4, 0xbe, 0x64, 0x4c, 0xe2, 0x17,
	0x36, 0xae, 0x23, 0xa4, 0x70, 0x03, 0x3b, 0x7d, 0x21, 0x28, 0xeb, 0x66, 0x5b, 0xa6, 0x35, 0xdc,
	0x0e, 0x69, 0x5f, 0x11, 0x86, 0xae, 0xb3, 0x48, 0x54, 0xd8, 0x51, 0x53, 0x2b, 0x02, 0x1b, 0x69,
	0xd0, 0xc5, 0x21, 0xef, 0xd1, 0x2f, 0x6e, 0x65, 0x3e, 0x62, 0x38, 0x3c, 0xd4, 0x20, 0x53, 0x3e,
	0x1c, 0x24, 0xac, 0x8f, 0x4e, 0xbf, 0x0a, 0xa0, 0x20, 0xf4, 0xe7, 0xc3, 0x72, 0xc6, 0xce, 0x6d,
	0x1d, 0x0b, 0x0a, 0xb4, 0xab, 0x57, 0x85, 0x92, 0x48, 0x5a, 0x54, 0x2e, 0x29, 0xa2, 0x1e, 0x59,
	0x5f, 0x7d, 0x17, 0xc4, 0xa1, 0xd5, 0x8b, 0x7a, 0x2c, 0x03, 0x2a, 0xb2, 0xa5, 0x77, 0xf2, 0x65,
	0x91, 0x1f, 0x0b, 0xd7, 0x50, 0x27, 0xde, 0x2c, 0xa2, 0x28, 0x35, 0xff, 0xd1, 0x6a, 0xee, 0x94,
	0xf5, 0x97, 0xbd, 0x74, 0xca, 0x93, 0x1b, 0x62, 0x95, 0xec, 0xa5, 0x7f, 0x4e, 0x16, 0x1e, 0x1d,
	0x9c, 0xa2, 0x51, 0xa8, 0x39, 0x39, 0xd4, 0x35, 0xd9, 0x70, 0xb2, 0x2a, 0x63, 0x8b, 0x8c, 0x83,
	0x53, 0x7c, 0x71, 0xd9, 0x03, 0xa2, 0x8e, 0xa8, 0x50, 0x34, 0xe5, 0x51, 0x63, 0x0a, 0xc8, 0xe5,
	0x71, 0x3e, 0xcf, 0x6e, 0x05, 0xac, 0x34, 0xaf, 0x68, 0x53, 0x21, 0x0c, 0xc3, 0x9c, 0x3e, 0xda,
	0x1b, 0x9b, 0x66, 0x06, 0xf6, 0xf7, 0xa5, 0x70, 0x73, 0x61, 0x7a, 0xec, 0x62, 0xe0, 0x13, 0xed,
	0xe3, 0x88, 0x60, 0xa2, 0xcf, 0x5a, 0x3e, 0x5b, 0x95, 0xa5, 0xe5, 0x68, 0xc2, 0x13, 0x15, 0xe3,
	0x26, 0x08, 0xd3, 0x91, 0x2b, 0x39, 0xde, 0x5a, 0xf5, 0xe4, 0x39, 0x45, 0xc6, 0xbd, 0xbd, 0x2d,
	0x05, 0x35, 0x08, 0x3c, 0xd3, 0x4e, 0xad, 0xbe, 0xfd, 0xbb, 0x2a, 0x2a, 0x1a, 0x3a, 0xff, 0xfe,
	0x42, 0x17, 0x73, 0x30, 0x94, 0x7e, 0x82, 0x71, 0x62, 0xc2, 0x3e, 0xaf, 0xeb, 0x3a, 0x3c, 0x2b,
	0xc6, 0xbd, 0x5b, 0xc9, 0xc7, 0x65, 0xf4, 0xe1, 0x1b, 0x5a, 0x6a, 0xb5, 0x00, 0x12, 0x00, 0x01,
	0xb8, 0xa9, 0x40, 0x13, 0x60, 0x63, 0x3d, 0xa0, 0x04, 0x00, 0x42, 0x00, 0x4c, 0x01, 0x06, 0xf6,
	0x0d, 0xb2, 0xd1, 0x7d, 0x2d, 0x80, 0x3d, 0xf2, 0x3a, 0x37, 0x00, 0x8b, 0x04, 0x7a, 0xe5, 0x0d,
	0x60, 0xb3, 0x03, 0x2a, 0x60, 0x2b, 0x80, 0x1d, 0x98, 0x01, 0x74, 0x80, 0x22, 0x0c, 0xa0, 0x62,
	0x06, 0xf8, 0xb1, 0x21, 0x97, 0xff, 0x23, 0x07, 0x42, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10,
	0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x64, 0x88, 0x00,
	0x8c, 0x0a, 0x01, 0x00, 0x80, 0x10, 0x00, 0x53, 0x00, 0x13, 0x80, 0x13, 0x50, 0x98, 0x6b, 0xab,
	0x05, 0xf2, 0x70, 0x72, 0xab, 0x67, 0x80, 0xec, 0x89, 0x89, 0x12, 0x50, 0x84, 0x2e, 0x49, 0x42,
	0xe1, 0x2c, 0x95, 0xa2, 0x29, 0xff, 0x74, 0xbc, 0xf4, 0xcc, 0x84, 0xee, 0x55, 0x80, 0x10, 0x24,
	0x4b, 0x44, 0x42, 0x00, 0x50, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x03, 0x11, 0x7b,
	0x7e, 0x60, 0xcb, 0x40, 0x3e, 0xbf, 0x9e, 0xcd, 0x55, 0x7e, 0xcb, 0x99, 0x71, 0x00, 0x10, 0xe9,
	0xe0, 0x00, 0x60, 0x2c, 0xdc, 0xe9, 0xca, 0x7f, 0x83, 0x11, 0xd1, 0x66, 0xff, 0xfc, 0x8d, 0x68,
	0xd9, 0xff, 0xc9, 0xad, 0x96, 0x17, 0xee, 0x4c, 0x2d, 0x9b, 0x0d, 0x78, 0x3a, 0x8a, 0x67, 0xb5,
	0x85, 0x8a, 0xb0, 0x4a, 0x31, 0xd2, 0xe9, 0x6c, 0x11, 0x6b, 0xc8, 0x50, 0xb5, 0xa9, 0xbb, 0xd2,
	0x7e, 0x76, 0x79, 0x96, 0xa8, 0x6f, 0x58, 0xed, 0xd8, 0x3b, 0xa9, 0xbc, 0xa0, 0xe5, 0x29, 0x9c,
	0x02, 0xa6, 0x6b, 0x7e, 0x41, 0x0d, 0x26, 0x12, 0x8a, 0x59, 0xec, 0x2a, 0x50, 0x7a, 0xe3, 0x96,
	0x14, 0x35, 0x06, 0x9a, 0x0d, 0xb7, 0x31, 0x9d, 0x11, 0x5b, 0x68, 0x8e, 0x6c, 0x50, 0x71, 0xb9,
	0x0c, 0x59, 0xb9, 0xbe, 0xac, 0xd5, 0x0a, 0x46, 0x89, 0xc4, 0x82, 0x59, 0xc5, 0x11, 0xc6, 0xca,
	0x06, 0x9b, 0x14, 0x75, 0xef, 0x1c, 0xb9, 0xcb, 0xad, 0x16, 0xad, 0x44, 0x03, 0x0c, 0x54, 0xa2,
	0x77, 0x1a, 0x59, 0x36, 0x6a, 0x4b, 0x20, 0x1f, 0x7d, 0x4e, 0x44, 0x13, 0xca, 0x7b, 0xd1, 0x39,
	0x68, 0xb2, 0xcd, 0x52, 0x3f, 0xfd, 0x8b, 0x84, 0x36, 0xa3, 0x85, 0x93, 0x77, 0x06, 0x5a, 0x3e,
	0x78, 0xcb, 0xb8, 0xa0, 0x92, 0xe7, 0x85, 0x29, 0x88, 0xad, 0x92, 0xcb, 0x9d, 0x5f, 0x6c, 0x80,
	0x25, 0x3e, 0x05, 0x3b, 0x95, 0xd7, 0x6e, 0x51, 0xde, 0x89, 0xa0, 0xd7, 0xcd, 0x64, 0x61, 0xb8,
	0xc0, 0xee, 0xe0, 0x8e, 0xe0, 0x83, 0xc8, 0x43, 0x5b, 0xe3, 0x55, 0xef, 0x62, 0x9b, 0x78, 0x99,
	0x20, 0x14, 0x0f, 0x7f, 0x6c, 0x74, 0x64, 0xac, 0x8d, 0x55, 0xfd, 0xa9, 0x68, 0xa9, 0x63, 0x20,
	0x8e, 0xb5, 0x7a, 0x9b, 0x3e, 0x30, 0xd7, 0x5f, 0xfc, 0x71, 0x24, 0xd8, 0x04, 0xc8, 0x62, 0xec,
	0xc6, 0x95, 0xf6, 0x03, 0x5a, 0xc8, 0x77, 0xae, 0xc9, 0x36, 0x41, 0x28, 0xb0, 0xc8, 0x8d, 0x4b,
	0xe1, 0xf1, 0xb1, 0x3f, 0xfd, 0x68, 0xe8, 0xcb, 0x11, 0xe7, 0xbd, 0x38, 0x5b, 0x16, 0x64, 0x58,
	0xac, 0x10, 0xa5, 0x87, 0x71, 0xb1, 0x54, 0x81, 0x0d, 0x69, 0x18, 0x46, 0x11, 0xe3, 0x56, 0x04,
	0xca, 0xd0, 0xc4, 0xaa, 0x50, 0xb3, 0x96, 0x7e, 0xb9, 0x4d, 0x50, 0x86, 0x5a, 0xfa, 0x7f, 0x79,
	0xb3, 0xee, 0xa5, 0x76, 0xfd, 0x7a, 0xc3, 0xed, 0x2f, 0xd1, 0xb6, 0x82, 0x5f, 0xd2, 0x3b, 0x8c,
	0x60, 0x83, 0xa5, 0x9e, 0x03, 0x6f, 0x2f, 0xa2, 0xfc, 0x8a, 0xfb, 0xc4, 0xd0, 0x23, 0x1e, 0xfe,
	0x65, 0x93, 0x8d, 0x7c, 0xe9, 0xe4, 0x4e, 0x34, 0x04, 0x3d, 0x42, 0xdd, 0x8a, 0x8d, 0xac, 0x4b,
	0x04, 0x18, 0x63, 0x1a, 0x51, 0x0d, 0x2e, 0x54, 0x1c, 0x20, 0xd8, 0xfb, 0xa1, 0xed, 0x99, 0x62,
	0x91, 0xfb, 0x6c, 0xe4, 0xc4, 0x63, 0xfd, 0xfe, 0xcc, 0xca, 0x28, 0xa6, 0x42, 0xd6, 0x89, 0x0e,
	0x88, 0x48, 0x42, 0xe7, 0x02, 0xed, 0xd9, 0xd5, 0xa7, 0xc6, 0x64, 0xf4, 0x8b, 0x8b, 0x0a, 0x97,
	0xf9, 0x9b, 0xe0, 0x50, 0xdc, 0xfa, 0x9d, 0x7a, 0x76, 0x51, 0x77, 0x04, 0x03, 0x65, 0xb7, 0x9c,
	0xe5, 0xa9, 0x9c, 0xf1, 0x49, 0xd8, 0xe1, 0xb7, 0x4b, 0xc6, 0x4a, 0x26, 0x5b, 0x61, 0x02, 0x29,
	0x93, 0xd5, 0xbe, 0x99, 0x2a, 0xdf, 0x8a, 0x1c, 0x00, 0xc0, 0xa1, 0xf3, 0xab, 0x84, 0x7b, 0xbb,
	0x17, 0xe8, 0x6f, 0xe7, 0xb3, 0x63, 0x3d, 0xcf, 0x40, 0x72, 0x01, 0x00, 0x64, 0xb7, 0x44, 0xc1,
	0xb1, 0xc6, 0xb3, 0x54, 0x51, 0x7b, 0x3b, 0xee, 0x52, 0x8c, 0x88, 0x4c, 0xb1, 0x0c, 0xd6, 0xc5,
	0x1c, 0x4b, 0x39, 0xf9, 0xb6, 0x94, 0x26, 0xbc, 0x25, 0x6c, 0xf7, 0x97, 0x4b, 0x3a, 0x2e, 0xd3,
	0xd0, 0xa6, 0xa6, 0x6c, 0xf2, 0x83, 0xb1, 0xba, 0x19, 0x3f, 0xf7, 0xb3, 0xba, 0x39, 0xf1, 0x26,
	0x25, 0x59, 0xbe, 0x9e, 0x7b, 0xef, 0x4c, 0x54, 0x99, 0x02, 0x42, 0xc4, 0xfa, 0xe1, 0x55, 0x22,
	0xa7, 0x96, 0xe8, 0xa5, 0x37, 0x11, 0x9e, 0xc3, 0xcd, 0x3b, 0x84, 0xfa, 0xc6, 0x19, 0x86, 0xf2,
	0x69, 0x39, 0x9f, 0x6c, 0x43, 0x1c, 0x6e, 0x78, 0xc9, 0xc2, 0x5f, 0x42, 0xb9, 0x93, 0x8a, 0x94,
	0xc6, 0x8d, 0x9c, 0x95, 0xee, 0xfc, 0x68, 0x3d, 0x9c, 0x5b, 0xe7, 0x0c, 0x3d, 0xff, 0x09, 0xe7,
	0x7f, 0xaa, 0x1a, 0xb6, 0x28, 0x8a, 0xf8, 0xaf, 0x62, 0x79, 0x5c, 0x57, 0xb4, 0x0e, 0xc6, 0x79,
	0x7d, 0x69, 0xb8, 0x45, 0x00, 0x60, 0x90, 0xde, 0x29, 0x23, 0x17, 0xcb, 0xb7, 0x57, 0x79, 0x2c,
	0x40, 0x9a, 0x55, 0xd5, 0x89, 0xff, 0x48, 0xe0, 0x1b, 0x5c, 0x11, 0x78, 0x12, 0x09, 0xf3, 0x31,
	0x7e, 0x1c, 0x36, 0x2e, 0xd5, 0x68, 0x45, 0xa8, 0xbc, 0x2e, 0xe8, 0x89, 0x89, 0xda, 0xd6, 0x2e,
	0x2b, 0xcd, 0x95, 0xb3, 0xde, 0xba, 0x22, 0x22, 0xcc, 0xcc, 0x61, 0xd6, 0x87, 0x01, 0x63, 0x45,
	0x44, 0x63, 0xe6, 0x91, 0x5b, 0xf8, 0xb7, 0x85, 0xdb, 0xfd, 0x65, 0xe1, 0x6e, 0x01, 0x41, 0xf4,
	0xdd, 0xa1, 0x63, 0x43, 0xc0, 0xb6, 0x90, 0x1c, 0xe1, 0xbe, 0x77, 0xa9, 0xb4, 0xb6, 0xe9, 0xee,
	0x5d, 0x9a, 0xe5, 0x16, 0xe2, 0x1f, 0xfe, 0x21, 0x8c, 0x37, 0x72, 0x8b, 0xef, 0xf7, 0x03, 0x8a,
	0xdd, 0xc3, 0x0a, 0xeb, 0x3f, 0x43, 0x16, 0xa3, 0x6c, 0x94, 0xf2, 0x5c, 0xa6, 0x7e, 0xd3, 0x97,
	0xeb, 0x0d, 0x8e, 0x72, 0x80, 0x47, 0xea, 0xe9, 0x90, 0xef, 0x4b, 0x7f, 0xd8, 0x56, 0x1d, 0x55,
	0x5c, 0x2e, 0x66, 0x96, 0x33, 0xd6, 0xcf, 0xe7, 0x83, 0x1b, 0xd6, 0x70, 0x93, 0xa7, 0x85, 0x18,
	0xab, 0xe8, 0xad, 0x55, 0xa7, 0x95, 0x0d, 0xaa, 0x0f, 0x97, 0x93, 0xe6, 0x2b, 0x31, 0x1a, 0xc7,
	0x1f, 0xa6, 0xfc, 0x34, 0xf8, 0xc0, 0xcc, 0xf1, 0x7d, 0x96, 0x2e, 0x38, 0x52, 0x36, 0xd9, 0x63,
	0x0d, 0x88, 0xd1, 0x84, 0x51, 0x59, 0xec, 0xd0, 0x0c, 0xb8, 0x23, 0x08, 0xf5, 0x75, 0xce, 0x88,
	0x6e, 0x55, 0xa3, 0xc0, 0xb1, 0x26, 0xc6, 0x52, 0xec, 0x43, 0xe7, 0xdb, 0x82, 0x23, 0xb1, 0x0f,
	0xc9, 0x17, 0x65, 0x25, 0x4c, 0xb4, 0xd1, 0x77, 0xb6, 0x37, 0xa4, 0x5d, 0x30, 0x7f, 0x4d, 0x93,
	0xbe, 0x40, 0x23, 0x88, 0x2c, 0x33, 0xec, 0xd7, 0x27, 0x54, 0x04, 0x2f, 0xfd, 0x2c, 0x4c, 0x02,
	0x55, 0x18, 0xc7, 0x60, 0x5c, 0xc5, 0x7d, 0xe8, 0x20, 0x8d, 0x54, 0x7b, 0xd2, 0x53, 0x21, 0x04,
	0x60, 0xd8, 0xda, 0x16, 0xbf, 0xa7, 0x03, 0x9f, 0x20, 0x8f, 0xda, 0xfc, 0xaf, 0x96, 0x64, 0x09,
	0xb1, 0xe6, 0xc1, 0x09, 0x5b, 0x58, 0x6d, 0x00, 0xd5, 0xec, 0x7d, 0x25, 0x6d, 0x65, 0x5a, 0x1e,
	0x09, 0x86, 0x87, 0xa7, 0xed, 0x12, 0x57, 0xa6, 0x4a, 0xc3, 0xc8, 0xfb, 0xc5, 0x56, 0x37, 0xb4,
	0x76, 0xf2, 0xe3, 0x06, 0x30, 0x27, 0xfc, 0xa2, 0x9a, 0x09, 0x21, 0x87, 0xdc, 0x70, 0x46, 0x7e,
	0xe7, 0x90, 0xfb, 0x36, 0x0d, 0xcc, 0xff, 0xb9, 0x84, 0x34, 0x24, 0x81, 0xdd, 0x4a, 0x31, 0xce,
	0xe5, 0x68, 0x52, 0xfa, 0x18, 0x11, 0x54, 0xda, 0xd4, 0x95, 0x2b, 0xca, 0xc7, 0xd9, 0x0a, 0x1c,
	0x62, 0x54, 0xa2, 0x88, 0x47, 0xe9, 0xc0, 0x54, 0x9e, 0x50, 0x17, 0xd6, 0x59, 0x0b, 0xa1, 0x2b,
	0x6b, 0x68, 0xfa, 0x60, 0x79, 0xc8, 0xd6, 0x67, 0xcd, 0x00, 0x84, 0x90, 0x22, 0x63, 0xa3, 0x30,
	0x88, 0xd3, 0xbf, 0x20, 0xe1, 0x59, 0xa1, 0xa1, 0x5b, 0x97, 0x36, 0x0c, 0x59, 0xf5, 0xa7, 0x78,
	0x75, 0xa2, 0xda, 0x74, 0xf5, 0xa5, 0xcf, 0x3e, 0xa2, 0xca, 0xc3, 0xe3, 0xfd, 0x45, 0xaf, 0x48,
	0xd0, 0xb0, 0x40, 0x2f, 0x85, 0x87, 0xda, 0x8b, 0xa0, 0x70, 0x1e, 0x96, 0x57, 0x79, 0x9a, 0xb5,
	0x50, 0x00, 0xcf, 0x36, 0x6d, 0x35, 0x73, 0x05, 0xe3, 0x15, 0xcc, 0x31, 0x1c, 0xb6, 0xb6, 0x6d,
	0xde, 0xc9, 0x92, 0x05, 0xce, 0xea, 0x7b, 0xf9, 0x3e, 0x95, 0x16, 0xe4, 0x27, 0x95, 0x8d, 0x0c,
	0xcd, 0x98, 0x7a, 0x6c, 0x79, 0x73, 0x7b, 0xc2, 0x01, 0xa7, 0xfe, 0x4d, 0xc3, 0x45, 0x08, 0xc0,
	0x7a, 0x68, 0xe2, 0xe9, 0x3d, 0x0a, 0x4f, 0x45, 0x11, 0x26, 0xaf, 0xd7, 0x1a, 0x25, 0x48, 0x47,
	0x84, 0x21, 0x8f, 0x57, 0xe3, 0xff, 0x51, 0x92, 0x41, 0xe8, 0x04, 0x66, 0x5b, 0xf4, 0xb6, 0x26,
	0x41, 0x42, 0xe2, 0xad, 0x16, 0x07, 0xba, 0xdf, 0x90, 0xe2, 0x53, 0xe8, 0xc1, 0xfb, 0xe9, 0xb2,
	0x81, 0xfd, 0x36, 0x4d, 0xb9, 0x5d, 0xa8, 0x2a, 0x84, 0x77, 0xa8, 0xa2, 0x4b, 0x56, 0x0a, 0x83,
	0x99, 0x9c, 0x1b, 0x3a, 0x42, 0x56, 0x9a, 0x20, 0xf1, 0x58, 0xbd, 0x9c, 0xb9, 0x85, 0xc3, 0x06,
	0x18, 0x85, 0xd7, 0x28, 0x1c, 0x66, 0xa7, 0xb8, 0x17, 0xec, 0x1a, 0x29, 0xf2, 0x93, 0x52, 0x89,
	0xaa, 0x6b, 0x65, 0x35, 0xe7, 0x6c, 0x33, 0x25, 0x80, 0x78, 0x8d, 0xab, 0xb7, 0xb3, 0x34, 0x77,
	0xb6, 0xa2, 0x18, 0x5c, 0x7e, 0xf9, 0x39, 0xc1, 0x83, 0xcb, 0x5d, 0x02, 0x5a, 0xb6, 0xbe, 0xbf,
	0xd8, 0x8e, 0x0d, 0x86, 0xa0, 0xe0, 0x0c, 0x10, 0xf8, 0xfd, 0x30, 0xf7, 0x49, 0x9a, 0x75, 0xc4,
	0x15, 0x5c, 0xe6, 0x5d, 0x28, 0xeb, 0x06, 0xdf, 0x15, 0xf3, 0xd8, 0xba, 0x17, 0x5a, 0xbc, 0x0d,
	0x92, 0x55, 0xb6, 0xd1, 0x3e, 0xae, 0xe3, 0xaf, 0x9d, 0x00, 0x2d, 0x83, 0xb2, 0x54, 0x30, 0x09,
	0x1d, 0x11, 0x81, 0x56, 0x66, 0xf5, 0xd0, 0x67, 0xfc, 0x6f, 0xa1, 0x35, 0x80, 0x8f, 0xeb, 0x5f,
	0x37, 0x8b, 0x8c, 0xb7, 0xed, 0xb5, 0x7b, 0x3e, 0xeb, 0x53, 0xbe, 0x56, 0xad, 0x50, 0x6a, 0x49,
	0x00, 0x02, 0xea, 0xf9, 0x7b, 0x29, 0x8b, 0x2a, 0xdd, 0x3c, 0xae, 0xf1, 0x3a, 0x40, 0x70, 0x91,
	0xae, 0x72, 0x72, 0xbc, 0x70, 0xc6, 0xf6, 0x3b, 0x29, 0xf7, 0x42, 0xc6, 0xc2, 0xf2, 0xb2, 0x19,
	0xaa, 0xf2, 0x55, 0x52, 0x2c, 0x37, 0x85, 0x99, 0xdd, 0x95, 0x13, 0x34, 0xf6, 0x4d, 0x15, 0x7d,
	0x36, 0x5b, 0xa4, 0xb8, 0xdf, 0x0d, 0x3c, 0xd3, 0x82, 0x8c, 0x58, 0xdc, 0xb2, 0x0d, 0x16, 0x12,
	0x36, 0x66, 0x06, 0x86, 0xc2, 0x71, 0x08, 0x40, 0x63, 0xa1, 0x03, 0x03, 0x4a, 0x99, 0x43, 0x85,
	0x21, 0xee, 0x49, 0x3e, 0x93, 0x74, 0x79, 0x6d, 0x75, 0xe1, 0x46, 0x37, 0x30, 0x5e, 0xf6, 0xa2,
	0x3f, 0xe5, 0xdf, 0x88, 0x9d, 0x94, 0x63, 0x0e, 0xa7, 0x0d, 0xe4, 0x4e, 0xb1, 0x28, 0x79, 0xed,
	0x70, 0x8c, 0x6d, 0x37, 0x31, 0xdf, 0xcf, 0x2c, 0x93, 0xc1, 0x33, 0xf6, 0x1d, 0xe9, 0x9d, 0xe8,
	0x58, 0xe8, 0x87, 0x53, 0x23, 0xc3, 0x86, 0xfe, 0xca, 0x47, 0x4f, 0xc8, 0xee, 0x7b, 0x81, 0x1a,
	0x17, 0x94, 0x94, 0x28, 0x13, 0xae, 0x73, 0xe9, 0x76, 0x44, 0xd2, 0xa1, 0xa3, 0xc7, 0x30, 0x8f,
	0x76, 0x59, 0x35, 0x2b, 0xfe, 0x28, 0xc7, 0xfc, 0xed, 0x7b, 0x4d, 0x22, 0x06, 0x98, 0x79, 0xa6,
	0xac, 0xd2, 0xa2, 0x57, 0xb4, 0xfc, 0x6c, 0xff, 0x38, 0x42, 0xcc, 0xdc, 0x33, 0xc3, 0x8b, 0xbb,
	0x02, 0xb4, 0xde, 0x4f, 0x20, 0xb8, 0x00, 0xca, 0xea, 0x23, 0x47, 0x6b, 0x1c, 0x17, 0x80, 0x81,
	0x88, 0x89, 0xef, 0xed, 0x13, 0xf8, 0xfb, 0xbb, 0x7a, 0xa6, 0x2b, 0xc1, 0x74, 0xfe, 0x7c, 0xfd,
	0xb4, 0x05, 0x88, 0x1d, 0xbe, 0xb3, 0x14, 0x77, 0xdb, 0xb4, 0xe9, 0x74, 0x2d, 0x4b, 0x2c, 0xfd,
	0x61, 0xc0, 0xed, 0x56, 0xc6, 0xa5, 0xec, 0xab, 0x41, 0x81, 0xf1, 0x1b, 0x65, 0x94, 0x47, 0x7b,
	0x20, 0xee, 0x50, 0x23, 0x80, 0xac, 0x38, 0xa7, 0x85, 0x99, 0x45, 0xf8, 0xba, 0x5f, 0xb9, 0xb4,
	0xc7, 0xa5, 0x79, 0x8f, 0xaf, 0xf9, 0x11, 0x21, 0x07, 0xec, 0xa0, 0xe5, 0x17, 0x3f, 0x1d, 0x87,
	0xa6, 0x94, 0x31, 0x4d, 0xa8, 0x59, 0xf9, 0xb4, 0x24, 0x74, 0x45, 0x36, 0xfc, 0x19, 0x03, 0x61,
	0xaf, 0x4c, 0x36, 0x47, 0xd8, 0x30, 0xa4, 0xcd, 0xb5, 0xf7, 0x97, 0x65, 0x23, 0xc8, 0xa8, 0xeb,
	0x4b, 0x7d, 0x1e, 0x55, 0x41, 0x4d, 0xe8, 0xa8, 0x85, 0x02, 0xab, 0xb2, 0x88, 0x8d, 0x66, 0xae,
	0xf7, 0xd2, 0x94, 0x0d, 0x35, 0x78, 0xfb, 0x36, 0xe5, 0xf8, 0xef, 0x05, 0xd4, 0x9d, 0x9f, 0xe6,
	0x6b, 0x71, 0x94, 0xf1, 0xe5, 0x9b, 0xf6, 0x71, 0x24, 0xa2, 0xe0, 0x7f, 0x93, 0x36, 0x1e, 0x60,
	0xaf, 0x1f, 0x2d, 0x6d, 0x94, 0x37, 0xf2, 0x31, 0xa3, 0xb9, 0x5f, 0xaa, 0xed, 0x27, 0xe4, 0x39,
	0x17, 0xb3, 0xd1, 0x04, 0x38, 0x1b, 0x2e, 0x5e, 0xe7, 0x1a, 0x2f, 0x82, 0x23, 0x5d, 0x18, 0x75,
	0xdc, 0xec, 0x11, 0x4a, 0xa1, 0xb4, 0xc5, 0xe8, 0x10, 0xee, 0xf9, 0xca, 0xcb, 0xb0, 0xe5, 0xdc,
	0x53, 0x9e, 0x08, 0xec, 0xd9, 0x7f, 0xbe, 0x8d, 0xc8, 0x36, 0xee, 0xf3, 0x3a, 0x62, 0x8b, 0x85,
	0xfc, 0xae, 0x96, 0x9a, 0x30, 0xde, 0x31, 0xe2, 0x23, 0xb6, 0x5a, 0xc9, 0x9b, 0x0b, 0x34, 0x12,
	0x47, 0xf3, 0xb5, 0xc0, 0xe3, 0x7b, 0x85, 0xad, 0x7a, 0x51, 0x77, 0xb4, 0x70, 0xff, 0xe9, 0x76,
	0x67, 0x1b, 0x89, 0xd9, 0x20, 0x30, 0x58, 0xff, 0x56, 0x30, 0xa1, 0xc6, 0x04, 0x73, 0xd4, 0xbe,
	0x01, 0x25, 0x8a, 0xfc, 0x17, 0xad, 0x9c, 0x6c, 0x59, 0x10, 0x49, 0xd6, 0xea, 0x3b, 0xb4, 0x93,
	0xd5, 0xeb, 0xc4, 0xa5, 0x11, 0x88, 0x99, 0x95, 0xe4, 0xb1, 0xd2, 0x6c, 0x5d, 0xab, 0xc6, 0x78,
	0xa8, 0xe6, 0xdb, 0x26, 0xdb, 0x0a, 0x4c, 0xcc, 0x8e, 0xf8, 0x0b, 0x2e, 0x15, 0xb1, 0x10, 0x7c,
	0xc2, 0x70, 0x78, 0x11, 0xf2, 0x4c, 0x61, 0x99, 0x6a, 0x6d, 0x0d, 0x80, 0x9d, 0x34, 0xb9, 0x72,
	0x5e, 0x73, 0x79, 0x8d, 0x35, 0x3d, 0xca, 0xb9, 0x02, 0x9d, 0xfe, 0x7d, 0xc0, 0x64, 0x38, 0x26,
	0xf5, 0x04, 0xc9, 0x0a, 0xaa, 0x55, 0xe9, 0x7f, 0x65, 0x9e, 0xc0, 0x73, 0x29, 0x2d, 0xb9, 0xb2,
	0xf5, 0x2c, 0x7c, 0x0e, 0xb0, 0x6b, 0x32, 0xc6, 0x82, 0xd6, 0xf5, 0x9c, 0x6d, 0x8e, 0x55, 0x5e,
	0x14, 0xca, 0xac, 0xae, 0x04, 0x2e, 0xad, 0xf5, 0x89, 0x17, 0x52, 0x7c, 0x12, 0x84, 0x3c, 0xbd,
	0x90, 0xa0, 0x61, 0x4e, 0xbc, 0xce, 0xeb, 0x55, 0x2c, 0x29, 0x8b, 0x88, 0x4b, 0x29, 0x9c, 0x8c,
	0xbc, 0x94, 0x42, 0x8b, 0x62, 0x0f, 0x79, 0x3f, 0x8d, 0xba, 0xaa, 0xa4, 0xad, 0x90, 0x21, 0x42,
	0xc6, 0x33, 0x10, 0x29, 0xd5, 0xd4, 0x1d, 0x06, 0xad, 0x4c, 0x65, 0x08, 0x49, 0x3d, 0x34, 0x47,
	0xcf, 0xc0, 0x3a, 0x4b, 0xfc, 0xbe, 0x81, 0x36, 0x57, 0xf5, 0x25, 0x8d, 0xba, 0x09, 0x2f, 0x40,
	0xa1, 0xc7, 0x0b, 0xf9, 0x16, 0x72, 0x12, 0x95, 0x72, 0xd0, 0xe7, 0x4f, 0x18, 0xf3, 0x47, 0x89,
	0xaf, 0xc7, 0x06, 0xc8, 0x2f, 0x1d, 0x93, 0xf0, 0x3e, 0xc7, 0x2e, 0x01, 0xaa, 0x82, 0xa4, 0xf8,
	0x39, 0x4f, 0x4a, 0x1b, 0xfd, 0x7e, 0xfb, 0x4b, 0xef, 0x17, 0x5d, 0xc6, 0x4b, 0x19, 0x4b, 0x03,
	0xe4, 0xa1, 0xd7, 0xbe, 0x1e, 0xac, 0x57, 0x92, 0x50, 0xda, 0x5d, 0x53, 0x1b, 0x9c, 0xd4, 0x27,
	0xc1, 0xe0, 0xb8, 0x3b, 0xb3, 0x6f, 0x47, 0x68, 0x5a, 0x5f, 0x5e, 0xd3, 0xe8, 0x1b, 0x6e, 0x7b,
	0xb5, 0x5a, 0x00, 0x0a, 0x16, 0x5e, 0xce, 0x8d, 0xd8, 0xff, 0x6e, 0x1b, 0x62, 0x5f, 0xdf, 0x4c,
	0x6e, 0xd7, 0x35, 0xbe, 0x65, 0x07, 0x68, 0x6e, 0x95, 0xd8, 0xfd, 0xb7, 0x43, 0x75, 0xec, 0xce,
	0x31, 0x93, 0x35, 0xa6, 0x50, 0x27, 0xea, 0x94, 0x0a, 0x66, 0x12, 0x38, 0x41, 0x2d, 0xb3, 0x9e,
	0xab, 0xa2, 0x93, 0x4d, 0x4a, 0x9f, 0xdb, 0xec, 0x7f, 0x1a, 0x1c, 0xa6, 0xb9, 0x41, 0x30, 0xe8,
	0xbc, 0x66, 0xb0, 0xd1, 0xc8, 0xed, 0xbb, 0xfb, 0xd3, 0x7f, 0xd9, 0x76, 0x9b, 0x51, 0x9f, 0x1f,
	0x9e, 0xc1, 0x22, 0xb0, 0x8e, 0x3b, 0xbf, 0x2a, 0x0c, 0x0b, 0x7a, 0xd6, 0x2e, 0x4f, 0xa7, 0xc4,
	0x65, 0x4c, 0xa6, 0x63, 0x86, 0x55, 0xe1, 0x89, 0x23, 0x00, 0x61, 0x71, 0x78, 0x41, 0x7d, 0xf9,
	0xbc, 0xd8, 0x23, 0xd9, 0x5a, 0xbf, 0x0e, 0xa1, 0x54, 0xa5, 0x39, 0xbc, 0xdb, 0xc8, 0x42, 0x68,
	0x47, 0x43, 0x93, 0x62, 0x3d, 0x82, 0x0e, 0x1e, 0xdd, 0xaa, 0x2c, 0x23, 0x39, 0x9d, 0x4e, 0xfa,
	0x0e, 0x76, 0x67, 0x7f, 0x41, 0xe4, 0xbe, 0x03, 0x84, 0xe9, 0xf2, 0x82, 0x47, 0x0b, 0xf1, 0x26,
	0x85, 0xfa, 0x0e, 0xf5, 0x8b, 0x46, 0x5c, 0xac, 0x8f, 0x3e, 0x30, 0xcb, 0x29, 0xb4, 0x73, 0x79,
	0xe7, 0x11, 0x68, 0x19, 0x11, 0x97, 0x4d, 0x3c, 0xb5, 0x29, 0x19, 0xdc, 0x36, 0xe9, 0xdd, 0x1a,
	0x84, 0x98, 0xb9, 0xf7, 0x06, 0x77, 0x6f, 0x6f, 0x10, 0x6f, 0x8a, 0x36, 0xbb, 0x99, 0x74, 0xb2,
	0xb9, 0xaf, 0xb9, 0x74, 0x3c, 0x3c, 0x88, 0x60, 0xa3, 0xb4, 0x83, 0xab, 0x6a, 0x68, 0xd0, 0x9f,
	0x76, 0x54, 0x5b, 0x42, 0x76, 0xb5, 0x28, 0x49, 0x62, 0x67, 0xec, 0x96, 0xc2, 0xba, 0x30, 0x78,
	0x98, 0x29, 0x6b, 0x35, 0x79, 0xdf, 0xfc, 0x0d, 0xeb, 0xb0, 0x53, 0x3d, 0x40, 0x22, 0x2f, 0x07,
	0xfc, 0xa8, 0xa5, 0x69, 0xff, 0x7b, 0x09, 0x50, 0x91, 0xa3, 0xe4, 0xe0, 0x74, 0x17, 0xaa, 0x59,
	0x48, 0xb1, 0x83, 0x51, 0x59, 0x53, 0xc2, 0xc0, 0x1e, 0x65, 0x29, 0x73, 0xa3, 0x99, 0x75, 0x16,
	0x30, 0x6a, 0xae, 0x37, 0xff, 0xbd, 0x7e, 0xc5, 0xe7, 0x40, 0x42, 0xd3, 0x8e, 0x9c, 0x88, 0x0c,
	0xf1, 0xcf, 0x9e, 0xdf, 0x49, 0x39, 0x5b, 0xef, 0x7a, 0xa7, 0x82, 0xb7, 0x69, 0xef, 0x80, 0x6d,
	0xd4, 0x6e, 0x65, 0x72, 0x42, 0x58, 0xfb, 0x8b, 0x27, 0x9e, 0x81, 0xb0, 0x79, 0x12, 0xfc, 0x62,
	0x78, 0x3b, 0x55, 0x10, 0x8c, 0x6b, 0xfa, 0x8d, 0xa6, 0x27, 0xa0, 0x61, 0x50, 0x2b, 0x3f, 0x4d,
	0xa8, 0x46, 0x1e, 0x1b, 0xfc, 0x74, 0x9f, 0xbc, 0x46, 0x09, 0x8e, 0xe6, 0x74, 0x9b, 0x91, 0x41,
	0x39, 0xc0, 0xc0, 0xae, 0x6e, 0xff, 0x33, 0x93, 0x73, 0xd0, 0x24, 0x54, 0xd4, 0x8c, 0xf4, 0xf2,
	0x63, 0x22, 0x8c, 0xe6, 0x51, 0x70, 0xd4, 0x56, 0xb8, 0x12, 0x64, 0x73, 0x45, 0xf2, 0x5b, 0x6e,
	0xee, 0xfa, 0xbc, 0x62, 0x2e, 0xe7, 0x57, 0x13, 0x92, 0xe9, 0x6a, 0xc6, 0xe0, 0x4c, 0x56, 0xcb,
	0x43, 0x24, 0x2c, 0x87, 0x6f, 0x81, 0x7e, 0x3e, 0xde, 0xb0, 0xa4, 0x6d, 0x47, 0x4b, 0xad, 0x51,
	0x84, 0x11, 0x39, 0xca, 0xe4, 0x15, 0x02, 0x6e, 0xc7, 0xa0, 0x31, 0x50, 0x2a, 0x46, 0x83, 0x19,
	0x60, 0x80, 0x20, 0x29, 0x9b, 0xb0, 0x16, 0x17, 0xea, 0xfb, 0xc8, 0x04, 0x8b, 0x01, 0x5d, 0x3e,
	0x26, 0x9f, 0xd4, 0x43, 0xc9, 0x7a, 0x02, 0xca, 0x91, 0xc6, 0xd2, 0xcc, 0x46, 0xde, 0x46, 0x85,
	0x60, 0x47, 0x4c, 0xd6, 0x8a, 0x24, 0x3c, 0xe4, 0x62, 0xa5, 0x62, 0x49, 0x21, 0xd4, 0x9b, 0xb6,
	0x03, 0xed, 0x0d, 0x05, 0x1b, 0x40, 0xf2, 0x96, 0x3d, 0x4e, 0xc0, 0xbd, 0x6a, 0x9a, 0xf4, 0x95,
	0x1c, 0x35, 0xe9, 0x55, 0x13, 0x28, 0x44, 0x82, 0xd4, 0x6d, 0x77, 0x9c, 0xdf, 0xd5, 0x60, 0x18,
	0xd6, 0x3b, 0x00, 0xc5, 0x12, 0x36, 0x87, 0xf6, 0x80, 0xea, 0x7d, 0x13, 0xeb, 0x44, 0xef, 0xc2,
	0x8f, 0x7d, 0x55, 0x37, 0x3c, 0xc9, 0xe0, 0x5c, 0x01, 0x0c, 0xa4, 0xa9, 0x87, 0x06, 0xfd, 0xc6,
	0xc8, 0xdd, 0xfe, 0x8c, 0xf5, 0xd5, 0x50, 0x1f, 0xf2, 0x4b, 0x7f, 0x7e, 0xdc, 0xe5, 0x45, 0xdd,
	0x89, 0xb6, 0x5c, 0xd0, 0x7e, 0xf7, 0x40, 0x97, 0xdf, 0x69, 0x15, 0x48, 0xcf, 0x06, 0x9b, 0x90,
	0x47, 0x60, 0x5f, 0x85, 0x2d, 0x19, 0xf5, 0xdf, 0xae, 0x83, 0x70, 0xb6, 0x16, 0xb6, 0x53, 0x56,
	0xd3, 0xbf, 0x6b, 0xd9, 0xa2, 0xb8, 0xe2, 0x2d, 0x65, 0x92, 0xbc, 0xce, 0x15, 0xf8, 0x1b, 0x33,
	0x61, 0x52, 0x82, 0x55, 0xe1, 0xb7, 0x61, 0xa9, 0xf3, 0xac, 0x3b, 0x28, 0x16, 0xaa, 0xa2, 0xe0,
	0xd7, 0x1d, 0x16, 0xfd, 0x64, 0x21, 0x32, 0xb9, 0x8e, 0x4c, 0x14, 0x1c, 0xbc, 0xf0, 0x97, 0x26,
	0x89, 0xcb, 0xfe, 0x1a, 0x3f, 0x31, 0x18, 0x12, 0x8e, 0xb7, 0x63, 0x56, 0xe5, 0xf7, 0x56, 0xd3,
	0x5f, 0x47, 0x99, 0x56, 0x8e, 0x8b, 0x87, 0xa8, 0x88, 0x42, 0xc6, 0x9c, 0x91, 0x26, 0x6b, 0x6f,
	0x89, 0x12, 0xf0, 0x16, 0x3e, 0x00, 0x31, 0xc7, 0xd0, 0x8f, 0x3f, 0xfe, 0x76, 0x66, 0x3d, 0x03,
	0xb0, 0x6e, 0x7b, 0x0d, 0xd6, 0x91, 0x93, 0x61, 0x74, 0x95, 0x40, 0x97, 0x9c, 0xae, 0x7e, 0x43,
	0x16, 0x44, 0x5c, 0xca, 0x9b, 0x13, 0xf9, 0x13, 0x1e, 0x54, 0xbc, 0x74, 0xdb, 0x17, 0x34, 0x05,
	0xdf, 0x77, 0x76, 0x1f, 0xa2, 0xd3, 0x93, 0x5b, 0xcb, 0xfb, 0x1e, 0x8f, 0xac, 0x59, 0x75, 0xcb,
	0x55, 0xba, 0x94, 0xd2, 0xa5, 0x4d, 0xed, 0xa5, 0x48, 0x5c, 0x1a, 0x94, 0xf6, 0x1b, 0x3f, 0xaa,
	0xee, 0x1a, 0xf0, 0xee, 0x25, 0xf2, 0xa6, 0x5f, 0x06, 0x2b, 0x5d, 0x16, 0x8d, 0x06, 0xd9, 0x25,
	0xaa, 0x32, 0xa3, 0xff, 0xe0, 0x0b, 0xcc, 0xef, 0x55, 0x89, 0x43, 0x49, 0x17, 0xef, 0x68, 0x30,
	0x98, 0xc0, 0x3e, 0x07, 0x3f, 0xc5, 0x28, 0xe6, 0xf8, 0x81, 0x69, 0xe5, 0x3b, 0x5c, 0x12, 0xbe,
	0x7c, 0xea, 0xf0, 0x82, 0xd2, 0x4b, 0xde, 0x03, 0xaf, 0xec, 0xb4, 0x97, 0x99, 0x21, 0x0b, 0x80,
	0xc9, 0x4b, 0xfd, 0x92, 0x4a, 0x16, 0xb9, 0xcf, 0xd7, 0x17, 0x84, 0xc1, 0xaa, 0x70, 0xc1, 0x6f,
	0x5d, 0x1e, 0xe0, 0x1d, 0xfe, 0x14, 0x61, 0xa8, 0xcb, 0xba, 0x63, 0xf9, 0xe6, 0x2d, 0x13, 0xf8,
	0xad, 0xf8, 0x99, 0x9a, 0x42, 0xe3, 0xdf, 0x2e, 0x01, 0xb9, 0xca, 0x45, 0xe4, 0x10, 0x88, 0xd7,
	0x68, 0xee, 0xd6, 0xa1, 0x82, 0xcb, 0xff, 0x0a, 0xb3, 0x55, 0xc3, 0x4d, 0x9f, 0x80, 0x28, 0x69,
	0x9e, 0x3f, 0xee, 0xfe, 0x9a, 0x78, 0x24, 0x48, 0x62, 0xa0, 0xc0, 0x1b, 0x85, 0x00, 0x56, 0x61,
	0x05, 0xd4, 0x79, 0x04, 0xe3, 0x96, 0xef, 0xfc, 0xe6, 0x53, 0x26, 0xc4, 0xe8, 0xa4, 0x9b, 0x59,
	0xd0, 0x77, 0x9f, 0x7d, 0xa5, 0x0e, 0x43, 0xce, 0xf7, 0x33, 0x95, 0x50, 0x5a, 0x76, 0xe0, 0xac,
	0xea, 0x7a, 0xde, 0x9f, 0x64, 0xe9, 0x1b, 0xfd, 0xa1, 0x27, 0x4d, 0x8b, 0x00, 0x3d, 0x6b, 0xe9,
	0xc0, 0xc9, 0x58, 0x2d, 0x59, 0x8c, 0x3d, 0x30, 0x10, 0xa9, 0xae, 0xd6, 0xd4, 0x79, 0x1a, 0x84,
	0x1a, 0x60, 0xe6, 0xde, 0x88, 0x5a, 0xb9, 0xa0, 0xc1, 0xf3, 0xaf, 0x79, 0x80, 0x37, 0x0c, 0x78,
	0x6e, 0x9c, 0x7a, 0x5f, 0xea, 0x3f, 0xd3, 0x17, 0x1d, 0xd7, 0x73, 0xc5, 0x8c, 0xa0, 0xfc, 0x71,
	0xe3, 0xd5, 0x9b, 0x17, 0x60, 0x74, 0xa1, 0x67, 0x31, 0xa8, 0x36, 0x1a, 0xe3, 0x27, 0x45, 0xd4,
	0x37, 0x97, 0x0b, 0xb8, 0x95, 0x9b, 0x3a, 0x25, 0xb7, 0xe5, 0xfc, 0x55, 0xda, 0x95, 0x31, 0xad,
	0x60, 0x97, 0xad, 0x88, 0x39, 0x3d, 0xe7, 0xf8, 0x01, 0x06, 0x4c, 0x62, 0xdc, 0xde, 0x1b, 0xa6,
	0x4d, 0x52, 0x09, 0x85, 0x5a, 0x8c, 0xd7, 0x89, 0xd9, 0x3e, 0x4e, 0xbd, 0x3b, 0x82, 0x01, 0x8f,
	0x41, 0x70, 0x09, 0x61, 0xc2, 0xe8, 0x45, 0xb4, 0x4f, 0x5b, 0xbd, 0x78, 0x8c, 0x12, 0x02, 0x30,
	0xb2, 0x54, 0x62, 0x23, 0x30, 0xef, 0xd8, 0xb7, 0x50, 0x02, 0xff, 0xfe, 0x23, 0x6b, 0x8b, 0xcc,
	0x4a, 0x2b, 0xac, 0xbb, 0x85, 0x6e, 0x12, 0x03, 0x68, 0xfd, 0x4d, 0xa6, 0x61, 0xc8, 0x7e, 0x6f,
	0x3d, 0xa4, 0xe0, 0x5c, 0x7b, 0x40, 0xb2, 0x83, 0x44, 0x8f, 0xb1, 0x5b, 0x42, 0x13, 0x35, 0xd8,
	0x0b, 0x5b, 0xc6, 0x42, 0xa5, 0xc9, 0x0a, 0x36, 0x0e, 0x8a, 0x51, 0x8d, 0x46, 0xd6, 0xa3, 0xdf,
	0xc7, 0x21, 0x74, 0x04, 0x70, 0xa8, 0xcb, 0x59, 0x8a, 0x9f, 0xcd, 0xd0, 0x97, 0x4f, 0x9b, 0xe6,
	0xb5, 0xc5, 0xa8, 0xd4, 0xd7, 0xd1, 0x22, 0x68, 0xd6, 0x0f, 0x65, 0xb2, 0xaa, 0x40, 0x51, 0xc5,
	0x06, 0x95, 0xdd, 0xbe, 0x5a, 0x98, 0x51, 0x5c, 0x65, 0xc3, 0x36, 0xd9, 0x94, 0xa3, 0x19, 0x8a,
	0x53, 0xa2, 0xf8, 0x8c, 0x01, 0x39, 0xc3, 0xbf, 0xff, 0xb9, 0x9e, 0x90, 0x17, 0x08, 0xec, 0x0b,
	0x34, 0x41, 0x35, 0x5c, 0xd5, 0xf8, 0x47, 0x63, 0x09, 0xcc, 0xa5, 0x95, 0xe9, 0x74, 0x85, 0x90,
	0x15, 0x43, 0xcb, 0x6d, 0x06, 0x2c, 0xd5, 0x3f, 0xd7, 0xc3, 0x13, 0x86, 0xca, 0x2c, 0xd5, 0x58,
	0x0b, 0xea, 0x3e, 0x73, 0x6b, 0xe5, 0xc1, 0x23, 0x0a, 0xf5, 0xba, 0xd2, 0x89, 0x6c, 0x1d, 0x77,
	0x57, 0x8e, 0xac, 0x20, 0xdc, 0xa5, 0x1a, 0xfc, 0x01, 0x71, 0xfc, 0xd5, 0x09, 0x34, 0x3d, 0x06,
	0x5f, 0x46, 0x5a, 0x58, 0x6d, 0xde, 0xbb, 0xf2, 0x86, 0x60, 0x4e, 0x63, 0x0c, 0x88, 0x2a, 0x75,
	0x7e, 0xf3, 0x15, 0x83, 0x52, 0x55, 0xfc, 0xad, 0x0c, 0x0d, 0x6d, 0xb6, 0x8d, 0xb2, 0x31, 0xf9,
	0xc5, 0xec, 0xf6, 0xab, 0xb1, 0xaf, 0x17, 0xba, 0x66, 0x0d, 0x47, 0xee, 0x98, 0xfb, 0x52, 0xc5,
	0x54, 0xda, 0x76, 0xb2, 0xed, 0x9e, 0x89, 0x91, 0xe5, 0x01, 0x09, 0x62, 0x63, 0xff, 0xeb, 0x77,
	0xff, 0x56, 0xc4, 0x39, 0x19, 0xa1, 0xf8, 0x3d, 0xec, 0x00, 0xaa, 0xa2, 0x41, 0x1b, 0x75, 0x74,
	0x88, 0x90, 0x09, 0x75, 0xa9, 0xd9, 0xbd, 0xb0, 0x5e, 0xe4, 0xbd, 0x9b, 0x7d, 0xd2, 0xc2, 0x05,
	0xce, 0x32, 0xe5, 0x15, 0x47, 0x7c, 0xa7, 0x37, 0xbb, 0xdb, 0xe6, 0x4e, 0x80, 0x36, 0xed, 0x34,
	0x2b, 0x78, 0x17, 0xba, 0x78, 0xca, 0x9b, 0xe4, 0x36, 0xb4, 0xa3, 0x1c, 0x37, 0x64, 0x22, 0x31,
	0x10, 0x0b, 0xfc, 0x68, 0xe8, 0x6e, 0x0a, 0xe5, 0x10, 0xa2, 0x40, 0x20, 0xba, 0x29, 0xaf, 0x35,
	0xd0, 0x54, 0xfe, 0x57, 0x6d, 0xb8, 0xae, 0xac, 0xbe, 0xc0, 0x6a, 0x8c, 0x6a, 0x1b, 0xd7, 0x87,
	0xb3, 0x13, 0x6f, 0x8f, 0xfd, 0x2e, 0xf0, 0x54, 0x1a, 0xd1, 0x65, 0xdb, 0xa0, 0x8f, 0xad, 0x61,
	0xae, 0xa4, 0xf1, 0x8a, 0x6c, 0x54, 0x55, 0x08, 0x14, 0xa2, 0xd1, 0xfc, 0x87, 0xdd, 0x4c, 0x38,
	0xdb, 0xae, 0x89, 0xad, 0xbe, 0xc9, 0x4c, 0x46, 0xd5, 0xaf, 0xe6, 0x03, 0x88, 0x64, 0xc3, 0xce,
	0x1b, 0xc2, 0x96, 0xa9, 0xd8, 0x75, 0xf6, 0x44, 0xb9, 0x4b, 0xc0, 0x32, 0x5c, 0xf5, 0x89, 0x73,
	0x57, 0x0c, 0xa0, 0x5b, 0xd9, 0x5c, 0xfc, 0x14, 0x65, 0x33, 0x3a, 0xc7, 0x17, 0x23, 0x01, 0x37,
	0x42, 0xa9, 0x9b, 0x2b, 0xe2, 0x8f, 0x12, 0x50, 0xc5, 0x31, 0xc3, 0xca, 0xf7, 0x5d, 0x45, 0x8a,
	0x2c, 0xdf, 0xa0, 0x42, 0x55, 0x97, 0x6c, 0x17, 0xec, 0x6a, 0x56, 0x68, 0xd2, 0x07, 0x14, 0xf8,
	0x23, 0x35, 0x54, 0x74, 0x4e, 0xb9, 0xe1, 0xd9, 0x7c, 0xcc, 0x38, 0xc5, 0x47, 0xf8, 0xd2, 0x8e,
	0xba, 0x73, 0x09, 0x47, 0x6b, 0x03, 0xb4, 0x45, 0x49, 0xf1, 0xe2, 0xcd, 0xf1, 0xdb, 0xbb, 0x14,
	0xcd, 0x95, 0xc0, 0xd2, 0x60, 0x1e, 0xcd, 0x60, 0x6f, 0xba, 0x3b, 0x7e, 0x06, 0x95, 0xe9, 0x1e,
	0x1c, 0xad, 0xff, 0x3f, 0x8b, 0x6f, 0xfc, 0x72, 0x0d, 0xe4, 0x53, 0xaa, 0xb2, 0x32, 0x14, 0xe1,
	0xa4, 0xb1, 0x64, 0xbb, 0x53, 0xb7, 0xd8, 0x0d, 0x4b, 0xc8, 0xbb, 0x74, 0x88, 0x5a, 0x1f, 0x1f,
	0xf0, 0x68, 0xcd, 0x74, 0xd1, 0x89, 0xd0, 0xb3, 0x16, 0x0b, 0x57, 0xf5, 0xfd, 0x1f, 0xd7, 0x1e,
	0x60, 0x44, 0xd0, 0xbf, 0x64, 0x23, 0xd7, 0x53, 0x7d, 0xc6, 0x55, 0x15, 0xd1, 0x68, 0x02, 0x54,
	0x93, 0x16, 0xef, 0x10, 0x84, 0xb0, 0x87, 0x8c, 0x51, 0xee, 0x77, 0x6a, 0x58, 0x5b, 0x63, 0xd5,
	0x78, 0x6e, 0x35, 0x9c, 0x1d, 0xd9, 0xf0, 0x2a, 0x1e, 0x74, 0x73, 0x27, 0xd6, 0x28, 0x69, 0xe5,
	0xf7, 0x8c, 0xda, 0x6b, 0x4a, 0x1d, 0x35, 0x5a, 0x56, 0xfd, 0x47, 0x86, 0x41, 0x4c, 0x98, 0x5d,
	0xa3, 0x84, 0xa9, 0xc0, 0x8a, 0x7b, 0x6e, 0x3d, 0xe8, 0x37, 0x41, 0x2e, 0xdc, 0x91, 0xc7, 0x4c,
	0x69, 0x7b, 0x54, 0x41, 0xe6, 0x1e, 0x08, 0x53, 0x94, 0x0f, 0xa8, 0xed, 0xac, 0xba, 0x27, 0x00,
	0x97, 0xfa, 0x52, 0x29, 0xf9, 0x4b, 0xd3, 0xad, 0x16, 0x7e, 0xd6, 0xf0, 0xdd, 0xbc, 0x7f, 0x0c,
	0x8b, 0xee, 0x09, 0x41, 0xfd, 0x6c, 0x9a, 0x03, 0x42, 0xf0, 0x21, 0x4b, 0xfc, 0x93, 0xf4, 0xd2,
	0x41, 0xff, 0x40, 0x9d, 0x0e, 0x9c, 0x6a, 0x98, 0x86, 0x72, 0x90, 0x36, 0x0a, 0x38, 0x54, 0x04,
	0x5c, 0xf9, 0x32, 0xf4, 0xd0, 0xb4, 0xe8, 0x34, 0xc6, 0x26, 0x2b, 0x71, 0x4c, 0x5f, 0x2c, 0x95,
	0xd6, 0x6f, 0x12, 0xe1, 0x84, 0x62, 0x97, 0x63, 0xe1, 0xfd, 0xc2, 0xb9, 0xdf, 0x00, 0x70, 0xb8,
	0x9d, 0xd2, 0x1a, 0xc8, 0x0e, 0xd5, 0xf1, 0xa4, 0x25, 0xdf, 0xb5, 0x33, 0xad, 0xbf, 0x0f, 0xa3,
	0xc3, 0xa5, 0xb3, 0x95, 0x1a, 0x68, 0xdf, 0x68, 0x2d, 0x82, 0x48, 0x90, 0x67, 0xdc, 0xaa, 0x7b,
	0xae, 0xfc, 0x53, 0xe2, 0xec, 0xa5, 0x7b, 0x0f, 0x66, 0xdb, 0x01, 0x74, 0xd6, 0x72, 0x15, 0x5f,
	0xb1, 0x78, 0x26, 0x29, 0xbc, 0x48, 0x6a, 0xb1, 0xb3, 0x2e, 0x5c, 0xb1, 0x2c, 0xd8, 0x0b, 0x03,
	0xfa, 0x3f, 0x02, 0x2c, 0x00, 0x1c, 0x96, 0x38, 0xd0, 0x3d, 0xd5, 0x3c, 0x65, 0x69, 0xf3, 0x4a,
	0xe5, 0x42, 0xd9, 0xcf, 0x72, 0xf3, 0x63, 0x8c, 0x23, 0x3e, 0xf2, 0xa2, 0x6e, 0xeb, 0x50, 0xc1,
	0x6e, 0x15, 0x07, 0x57, 0x77, 0x4c, 0x53, 0xe3, 0xbf, 0x81, 0x41, 0xe8, 0x97, 0xb0, 0x43, 0xc2,
	0xab, 0xb5, 0x70, 0xe2, 0x78, 0x0f, 0xae, 0x0b, 0x62, 0x63, 0x27, 0x49, 0xa4, 0x87, 0xef, 0x50,
	0x7b, 0x7b, 0x2f, 0x25, 0x27, 0x17, 0x8e, 0x50, 0x3c, 0x9d, 0xfa, 0x54, 0x27, 0x59, 0xc6, 0xe0,
	0x73, 0x70, 0xc8, 0xfe, 0x49, 0xef, 0xd2, 0x83, 0x86, 0x9f, 0x16, 0x6c, 0xc7, 0x39, 0x5c, 0xb9,
	0xe0, 0xf5, 0xc6, 0x6d, 0xd1, 0x86, 0xea, 0xbf, 0x62, 0x34, 0xe6, 0x57, 0xf9, 0x12, 0x08, 0x39,
	0x4a, 0x2f, 0xe7, 0x52, 0xa9, 0x0c, 0x62, 0x16, 0x4c, 0x9c, 0x75, 0x48, 0x53, 0x0a, 0x69, 0x53,
	0xc0, 0xdd, 0x81, 0x61, 0x39, 0xe8, 0x94, 0x1b, 0x67, 0x06, 0xe5, 0x14, 0x26, 0x97, 0xe2, 0x88,
	0x1f, 0x10, 0x1b, 0x8d, 0x16, 0xcb, 0x68, 0xbb, 0xa5, 0xdd, 0x9c, 0x14, 0x90, 0xd7, 0x93, 0x17,
	0x76, 0x0f, 0xf9, 0x69, 0x3b, 0x4d, 0x0e, 0xd4, 0xcf, 0x0f, 0xf0, 0x75, 0x6c, 0x49, 0x34, 0xb4,
	0x0a, 0x30, 0x11, 0x09, 0xec, 0x6a, 0xe9, 0xbc, 0xf3, 0xd7, 0x8f, 0xf3, 0x21, 0xe0, 0xf9, 0x56,
	0x50, 0xf4, 0xea, 0x12, 0x30, 0x8d, 0x13, 0x6a, 0x94, 0x78, 0x9d, 0xde, 0x13, 0x43, 0x25, 0x06,
	0x3b, 0x0b, 0x20, 0x5c, 0x8a, 0x99, 0xda, 0x65, 0xb7, 0x60, 0x96, 0xbf, 0x9a, 0x96, 0x73, 0x69,
	0x64, 0xaf, 0xa4, 0xf9, 0x6c, 0x4b, 0x05, 0xcd, 0x25, 0x91, 0x76, 0xf7, 0x8c, 0x16, 0x11, 0x83,
	0x21, 0xad, 0xc4, 0x5d, 0xc8, 0xd2, 0x8e, 0x07, 0x9b, 0xe0, 0x00, 0x26, 0x20, 0xf1, 0x06, 0x13,
	0x50, 0x30, 0x69, 0xd2, 0xb2, 0x0f, 0x4e, 0x5c, 0xe9, 0x81, 0x00, 0x96, 0x90, 0x26, 0x55, 0x5c,
	0xf9, 0x0a, 0x90, 0x25, 0x89, 0x20, 0x0b, 0x01, 0x64, 0x49, 0x11, 0x64, 0x21, 0x80, 0x2c, 0x29,
	0x82, 0x59, 0x08, 0x90, 0x65, 0x8f, 0x6c, 0xd9, 0x95, 0x50, 0xe4, 0x2b, 0xc0, 0x2c, 0x29, 0x82,
	0x9c, 0x05, 0x00, 0x53, 0x88, 0xd4, 0xd0, 0xe0, 0x89, 0xdb, 0x42, 0xa1, 0x1b, 0x70, 0x74, 0xc2,
	0x9a, 0xca, 0x03, 0x06, 0xf2, 0x60, 0x5e, 0x0e, 0x99, 0x71, 0x27, 0x33, 0x40, 0xbd, 0x3b, 0x81,
	0xe5, 0xa3, 0x18, 0x48, 0x25, 0x01, 0xda, 0x08, 0x01, 0x9d, 0x2b, 0x6c, 0x02, 0x00, 0x10, 0x00,
	0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00,
	0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00,
	0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00,
	0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0xa4, 0x2b, 0x00, 0xd4,
	0x50, 0x00, 0x24, 0x42, 0x4c, 0x32, 0x3f, 0xa7, 0x2b, 0xb9, 0x1a, 0x00, 0x00, 0x00, 0x80, 0x04,
	0x00, 0x20, 0x68, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x30, 0x4c, 0xff, 0x68, 0x00,
	0x80, 0x01, 0x58, 0x02, 0x00, 0x00, 0x00, 0x50, 0x90, 0x01, 0xa0, 0x60, 0x60, 0x00, 0x00, 0x01,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x10, 0x80, 0x61, 0x30, 0x62, 0x00, 0x03, 0x00, 0x00, 0x00,
	0x39, 0x00, 0x00, 0x00, 0xc7, 0xc7, 0x75, 0x69, 0x00, 0x00, 0x00, 0xf6, 0x5a, 0x01, 0x00, 0x00,
	0x90, 0x4c, 0x05, 0x00, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00, 0x00, 0xeb, 0x4d, 0x07, 0x00, 0x00,
	0x00, 0x00, 0xf2, 0x4d, 0x64, 0x00, 0x10, 0x01, 0xc0, 0x4d, 0x00, 0x00, 0x00, 0xf4, 0x4d, 0x65,
	0x00, 0x10, 0x01, 0x60, 0x04, 0x00, 0x00, 0x00, 0x42, 0x4e, 0x64, 0x00, 0x20, 0x01, 0x80, 0x52,
	0x00, 0x00, 0x00, 0x47, 0x4e, 0x65, 0x00, 0x20, 0x01, 0x80, 0x04, 0x00, 0x00, 0x00, 0x9a, 0x4e,
	0x64, 0x00, 0x30, 0x01, 0x60, 0x59, 0x00, 0x00, 0x00, 0x9f, 0x4e, 0x65, 0x00, 0x30, 0xf9, 0x40,
	0x01, 0xe0, 0x53, 0x00, 0x00, 0x00, 0xfe, 0x40, 0x01, 0x40, 0x52, 0x4f, 0x50, 0x01, 0x90, 0x57,
	0x00, 0x00, 0x00, 0x57, 0x4f, 0x50, 0x01, 0x50, 0xaf, 0x60, 0x01, 0xa0, 0x50, 0x00, 0x00, 0x00,
	0xb4, 0x60, 0x01, 0x10, 0x05, 0x50, 0x66, 0x00, 0x00, 0x00, 0xc0, 0x15, 0x00, 0x00, 0x00, 0x0a,
	0x50, 0x66, 0x00, 0x10, 0x20, 0x20, 0x36, 0x30, 0x4c, 0x00, 0x01, 0x00, 0x00, 0x00, 0xef, 0x99,
	0x1d, 0xb4, 0x41, 0x42, 0x44, 0x67, 0x92, 0x65, 0x92, 0x3d, 0xe8, 0xbc, 0x51, 0xd8, 0x94, 0xc3,
	0x8e, 0x41, 0x77, 0xd0, 0x47, 0x92, 0x92, 0xa7, 0xae, 0x67, 0x1d, 0x08, 0x3f, 0xb6, 0x08, 0x00,
	0x00, 0x00, 0x8d, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x1b, 0x91, 0x26, 0xfe, 0xc7,
	0xb7, 0xdd, 0xc2, 0xfe, 0x1c, 0xde, 0xc7, 0xe0, 0x4a, 0x35, 0x9d, 0xe8, 0x68, 0x24, 0x19, 0x2c,
	0x05, 0xcd, 0x71, 0xda, 0xbe, 0xbd, 0xeb, 0xf5, 0x67, 0x73, 0xbe, 0xfc, 0xb3, 0x03, 0x02, 0x92,
	0xe5, 0x9c, 0x3c, 0xdd, 0x81, 0x0d, 0x80, 0xe8, 0x3e, 0x24, 0xd8, 0x92, 0x30, 0x97, 0x98, 0x88,
	0x64, 0xd8, 0x60, 0xa4, 0x02, 0x22, 0xc7, 0x89, 0x75, 0x19, 0x26, 0xc1, 0x8d, 0xa1, 0x6b, 0xa6,
	0xac, 0x8f, 0xe5, 0x40, 0x14, 0xc4, 0x06, 0xd0, 0x93, 0x23, 0x4f, 0x98, 0xc5, 0xd3, 0x55, 0x42,
	0x63, 0x37, 0x76, 0x5e, 0x8b, 0x9d, 0xf7, 0xcb, 0xa6, 0x39, 0xfd, 0x17, 0x2a, 0x6c, 0xca, 0x40,
	0xfc, 0x3d, 0xeb, 0x47, 0x46, 0x9e, 0x3a, 0x31, 0xbf, 0x4b, 0xfa, 0x76, 0xfb, 0x8c, 0x02, 0x8c,
	0x0a, 0xd6, 0x59, 0x62, 0x38, 0x96, 0x90, 0x33, 0x96, 0xf3, 0x76, 0xf4, 0x4b, 0x8e, 0x2b, 0xf8,
	0x9d, 0xb6, 0x49, 0x38, 0x1b, 0x4a, 0x4e, 0xe8, 0x2a, 0x09, 0xae, 0xf2, 0x6e, 0xd0, 0x4e, 0x3e,
	0x77, 0xad, 0x8a, 0x01, 0xc4, 0xbf, 0xd0, 0xdc, 0xd1, 0x46, 0xf1, 0x66, 0x5f, 0xac, 0xb8, 0x1d,
	0x71, 0x14, 0xfd, 0x4b, 0xdb, 0xfa, 0x7e, 0xd0, 0x2a, 0x8b, 0x8f, 0x5b, 0xe7, 0x45, 0x81, 0xca,
	0x01, 0x27, 0x6b, 0x0c, 0xaa, 0xbe, 0xfe, 0x45, 0x0a, 0xb8, 0x32, 0x48, 0xe6, 0x91, 0x6b, 0xed,
	0x51, 0x9a, 0x5b, 0x5b, 0xb0, 0x58, 0xe4, 0x91, 0x3e, 0x93, 0xf6, 0x6d, 0x40, 0x8b, 0x52, 0x80,
	0x07, 0x55, 0x67, 0x5d, 0x7b, 0xa3, 0xbf, 0x0b, 0x34, 0x92, 0x59, 0x1c, 0x26, 0x55, 0xaf, 0x84,
	0xc3, 0xb7, 0xf5, 0x1d, 0x12, 0xea, 0x32, 0x39, 0xc1, 0x34, 0x9a, 0xb8, 0x14, 0x8a, 0xca, 0x7f,
	0xc5, 0x5e, 0xb5, 0x6f, 0x1a, 0x57, 0xf1, 0x8d, 0x97, 0x78, 0x09, 0xc1, 0x2a, 0x38, 0x5a, 0xf7,
	0x6f, 0xd4, 0x73, 0x7c, 0xb8, 0x6f, 0x41, 0xb6, 0x85, 0xdd, 0x71, 0x61, 0xe4, 0x42, 0xf5, 0xa9,
	0x0b, 0x8c, 0x11, 0xaa, 0x9d, 0xa8, 0x28, 0x97, 0xce, 0xec, 0x89, 0xac, 0x50, 0xe9, 0x58, 0x9c,
	0x60, 0x77, 0x31, 0x81, 0x97, 0x8f, 0xa6, 0xeb, 0x30, 0x26, 0xd0, 0x0c, 0xd5, 0x2b, 0x74, 0x40,
	0xa9, 0x25, 0x41, 0x5d, 0x04, 0x68, 0xe3, 0xe4, 0x2c, 0x28, 0xa3, 0xd5, 0xaf, 0x44, 0xc8, 0x3a,
	0xc2, 0x2d, 0xad, 0x6b, 0x51, 0xd4, 0x19, 0x4b, 0x24, 0x2f, 0xdc, 0x53, 0x32, 0xe0, 0x1f, 0x29,
	0xf2, 0xe2, 0x20, 0x28, 0xa0, 0x99, 0xab, 0x64, 0x93, 0xd3, 0xad, 0xcd, 0xda, 0xe3, 0x14, 0x0d,
	0xa9, 0x96, 0x63, 0x7e, 0x37, 0xbd, 0xe2, 0x70, 0x3a, 0x88, 0xba, 0x79, 0x10, 0x57, 0x6c, 0x92,
	0xef, 0x90, 0xd4, 0x01, 0x0f, 0x2d, 0xe9, 0x46, 0x73, 0xcc, 0x68, 0x12, 0x60, 0x0c, 0x84, 0x39,
	0xdf, 0xd4, 0x25, 0x24, 0x13, 0xbf, 0xa9, 0xc2, 0xc2, 0xfb, 0x97, 0x12, 0xcf, 0x0e, 0xd2, 0x99,
	0x3a, 0x5e, 0xec, 0x13, 0x5d, 0x00, 0x44, 0x9c, 0xc1, 0x4d, 0xa0, 0x7f, 0x01, 0x2c, 0x0b, 0xf9,
	0x23, 0x6c, 0x8d, 0x4b, 0xe0, 0x90, 0xf8, 0xf6, 0xce, 0x2e, 0xbd, 0x2b, 0x2a, 0x33, 0xf6, 0x58,
	0x50, 0x80, 0x50, 0x54, 0x47, 0xa5, 0x1d, 0x21, 0xf3, 0x59, 0x81, 0x61, 0xc8, 0xdb, 0x73, 0x3c,
	0xa0, 0x13, 0x3b, 0xa7, 0x10, 0x3f, 0xa8, 0x5a, 0xb5, 0x27, 0x46, 0x99, 0x12, 0xdb, 0x7d, 0x51,
	0xe1, 0xbe, 0xbf, 0x47, 0xea, 0x43, 0x4e, 0xce, 0x25, 0x75, 0x06, 0xb7, 0xab, 0x24, 0x23, 0xeb,
	0xe8, 0xaf, 0xb3, 0x6c, 0xc4, 0x90, 0x07, 0x34, 0x28, 0xc9, 0xb7, 0xe9, 0x39, 0x51, 0x74, 0xf8,
	0xed, 0xaa, 0xb4, 0x62, 0x26, 0x55, 0xdf, 0x24, 0xfa, 0xbd, 0xac, 0x89, 0x94, 0x59, 0x29, 0x55,
	0xe9, 0x09, 0x66, 0xb2, 0xb0, 0x06, 0x2f, 0xd0, 0x90, 0xee, 0x9b, 0xb4, 0xab, 0xe0, 0xb3, 0x6a,
	0x29, 0x35, 0x0c, 0x45, 0x47, 0x88, 0xba, 0x3c, 0x81, 0x20, 0x59, 0x8e, 0xd1, 0x07, 0x01, 0xc2,
	0xc2, 0x54, 0x53, 0x6b, 0xac, 0xd1, 0x51, 0x1f, 0x23, 0xd2, 0xe6, 0xba, 0x7b, 0x5d, 0xad, 0xb8,
	0x49, 0x48, 0x41, 0x0f, 0x5a, 0x54, 0x02, 0x78, 0x37, 0x2b, 0xa2, 0x67, 0xc9, 0xc8, 0x71, 0x83,
	0xd7, 0x97, 0xe7, 0x98, 0x4a, 0x10, 0x93, 0xc7, 0xed, 0x66, 0xb6, 0x9f, 0x6d, 0x78, 0xf6, 0x71,
	0xc0, 0xa9, 0x51, 0x17, 0xbd, 0x03, 0x7c, 0xf0, 0x24, 0x84, 0xc0, 0x69, 0x95, 0x6a, 0x07, 0xde,
	0x22, 0xea, 0x8c, 0xe5, 0xc3, 0x2c, 0x5a, 0x19, 0xd1, 0xd6, 0x7c, 0xe1, 0x51, 0xcd, 0xaa, 0xee,
	0x57, 0x6e, 0x9e, 0x95, 0x22, 0x8b, 0x68, 0x27, 0xac, 0xdd, 0x64, 0xe1, 0xa4, 0xb7, 0xd5, 0xbe,
	0xd8, 0x99, 0xb9, 0xcf, 0xd9, 0xbf, 0x23, 0x55, 0x98, 0x7d, 0x09, 0x4c, 0xac, 0x34, 0x30, 0x85,
	0x5f, 0x63, 0x51, 0xdc, 0xb1, 0x0c, 0x54, 0x73, 0x66, 0x75, 0xde, 0xed, 0x8c, 0x92, 0x2f, 0xe3,
	0x3b, 0xe6, 0xcf, 0x1a, 0x39, 0x01, 0xb9, 0x47, 0x60, 0x3d, 0xdc, 0x56, 0x3e, 0x80, 0xcd, 0xc0,
	0x62, 0x52, 0xf0, 0x3b, 0x95, 0x64, 0x2a, 0xc5, 0x79, 0x3c, 0x8a, 0xbd, 0x50, 0x85, 0x6e, 0x37,
	0xca, 0x49, 0xe1, 0xcc, 0xd2, 0xfe, 0x80, 0xcd, 0x85, 0xbe, 0x32, 0xa0, 0x6a, 0x39, 0xc1, 0x3a,
	0x88, 0xcb, 0xf7, 0xc6, 0xb2, 0x80, 0x8b, 0xeb, 0xdb, 0x7a, 0xdb, 0x67, 0x73, 0x20, 0xe4, 0x2e,
	0x4d, 0xb1, 0x0d, 0xf6, 0x07, 0x17, 0x56, 0xfa, 0xd6, 0xf4, 0xe0, 0x1c, 0x43, 0x80, 0x98, 0x57,
	0x8f, 0xd0, 0x96, 0xce, 0x58, 0x9a, 0x60, 0xc3, 0xdd, 0x29, 0xfb, 0xf5, 0x09, 0x24, 0x7d, 0xf2,
	0x5d, 0x34, 0x4f, 0x5a, 0x76, 0x31, 0x6b, 0xd3, 0x2e, 0x36, 0x52, 0x23, 0x55, 0x2d, 0x05, 0x43,
	0x51, 0x5e, 0x6e, 0x85, 0x53, 0x77, 0x16, 0xdf, 0xe2, 0x44, 0x31, 0x86, 0xe1, 0x52, 0x92, 0x48,
	0x35, 0x6f, 0x4d, 0xb7, 0x0f, 0xc5, 0xcb, 0x49, 0x1b, 0x24, 0xa9, 0xce, 0xc3, 0x26, 0xc4, 0xf0,
	0x54, 0xc0, 0x8b, 0x5f, 0xfe, 0x75, 0xed, 0x9f, 0x51, 0x25, 0x0f, 0x0c, 0xb2, 0x67, 0x60, 0x9c,
	0x6d, 0x1d, 0x10, 0xed, 0xcc, 0xcc, 0x60, 0x09, 0xcc, 0x75, 0x8d, 0x95, 0xbd, 0xa5, 0xc8, 0x15,
	0xcf, 0xcf, 0x43, 0x8c, 0x40, 0x06, 0x18, 0x2d, 0x81, 0x66, 0xde, 0xbe, 0xeb, 0xf1, 0x4f, 0x01,
	0xb0, 0x6e, 0xf2, 0x55, 0x2c, 0x60, 0xdf, 0xa0, 0x73, 0x6e, 0x55, 0xe1, 0x87, 0x00, 0xbc, 0xad,
	0x89, 0x31, 0xa2, 0xf3, 0x96, 0x39, 0xaf, 0x17, 0x03, 0xb6, 0xa2, 0x06, 0xf7, 0xe9, 0x0c, 0x63,
	0x59, 0x80, 0x3e, 0xe2, 0x67, 0x25, 0x76, 0x13, 0x22, 0xe8, 0x40, 0x51, 0x0a, 0xad, 0x31, 0xe5,
	0x0c, 0xaf, 0x71, 0xa3, 0x36, 0xe7, 0x20, 0xfc, 0x61, 0xd4, 0x79, 0x96, 0x9e, 0x02, 0x10, 0x50,
	0xa0, 0x1e, 0x13, 0x4e, 0xf3, 0xe2, 0x3b, 0x7d, 0x9d, 0xba, 0x2b, 0xdd, 0xea, 0x54, 0xce, 0x18,
	0x49, 0x85, 0x36, 0x8a, 0x9b, 0xed, 0xbb, 0x9b, 0xe9, 0x64, 0x9c, 0x19, 0x7f, 0x7d, 0xec, 0xd6,
	0x9a, 0x14, 0x79, 0x72, 0x77, 0x5f, 0xff, 0xde, 0xec, 0x10, 0x53, 0x99, 0x23, 0x64, 0xeb, 0x5b,
	0x01, 0xcb, 0x5f, 0x6b, 0x17, 0xde, 0x8e, 0x6b, 0x06, 0x69, 0x56, 0xfa, 0x0c, 0x4e, 0xf0, 0x71,
	0x09, 0xb0, 0xc5, 0x8e, 0xcb, 0xdc, 0x9b, 0x35, 0x5e, 0x1f, 0xd8, 0xc4, 0xed, 0x4e, 0xb4, 0xf4,
	0x52, 0x64, 0x0a, 0x03, 0xa3, 0xa9, 0x7b, 0x4f, 0x2c, 0x17, 0x55, 0x00, 0x00, 0x00, 0x31, 0x20,
	0x11, 0x07, 0x14, 0x90, 0x28, 0x35, 0xae, 0x01, 0x03, 0xe8, 0xda, 0xa7, 0x7b, 0x53, 0xa1, 0xe8,
	0x05, 0x9e, 0x4a, 0xe4, 0x42, 0x0a, 0x0d, 0xb9, 0x69, 0x0d, 0xcb, 0xf8, 0x11, 0x93, 0x0c, 0x93,
	0xe8, 0x06, 0x06, 0x90, 0xd8, 0x61, 0x38, 0xfc, 0xe1, 0x60, 0x44, 0x18, 0xd9, 0xc0, 0x75, 0xb2,
	0x5b, 0xcb, 0x21, 0xd1, 0x43, 0x62, 0x0e, 0xe3, 0xe1, 0xed, 0xf8, 0x8e, 0xc2, 0xe5, 0x0f, 0xff,
	0xf0, 0x87, 0x05, 0x1a, 0x38, 0xbe, 0x42, 0xe1, 0x7c, 0x8b, 0xd3, 0xd1, 0x62, 0x8a, 0xa0, 0x27,
	0xf2, 0x62, 0x0c, 0x69, 0x61, 0x93, 0x75, 0x1b, 0xa8, 0xd9, 0xc9, 0xe6, 0x00, 0x2d, 0xe6, 0xff,
	0xfe, 0x15, 0x02, 0x4c, 0x1e, 0x00, 0x14, 0x39, 0x00, 0x05, 0x00, 0x00, 0x00, 0x20, 0x40, 0x01,
	0xea, 0x94, 0x0a, 0x66, 0x12, 0x38, 0x41, 0x2d, 0xb3, 0x9e, 0xab, 0xa2, 0x93, 0x4d, 0x4a, 0x9f,
	0x20, 0x40, 0x00, 0x00, 0x58, 0x01, 0x01, 0x09, 0x10, 0x00, 0x01, 0x00, 0x00, 0x65, 0x31, 0x7d,
	0x33, 0x55, 0x02, 0x9e, 0x76, 0xb1, 0x3e, 0xde, 0xe7, 0x2b, 0x0e, 0xbc, 0x50, 0x48, 0xee, 0x7c,
	0x00, 0x3a, 0x6b, 0x1b, 0x64, 0xdb, 0x48, 0x87, 0x77, 0x14, 0x05, 0x35, 0x3e, 0x59, 0xfb, 0x50,
	0x1c, 0xd3, 0x67, 0x78, 0xda, 0xed, 0xd5, 0xbf, 0x4a, 0x03, 0x41, 0x10, 0xc7, 0xf1, 0xd9, 0xf5,
	0x12, 0xd3, 0x99, 0x9c, 0x8d, 0x85, 0x60, 0x1a, 0xb5, 0x17, 0x02, 0xa2, 0x95, 0x96, 0x56, 0x69,
	0x85, 0x20, 0x31, 0x70, 0xad, 0xfa, 0x0a, 0xbe, 0x41, 0xde, 0xc0, 0xd6, 0x22, 0x85, 0x84, 0x34,
	0xea, 0x03, 0xd8, 0xf8, 0x20, 0x96, 0x57, 0xa4, 0xf0, 0x5f, 0x38, 0x67, 0x26, 0x87, 0x82, 0x31,
	0xa0, 0x29, 0xe5, 0xfb, 0x39, 0xf2, 0x63, 0xc9, 0x6d, 0x66, 0x67, 0x97, 0xe3, 0x72, 0xd8, 0x6e,
	0x1f, 0x34, 0x45, 0x24, 0xea, 0xe7, 0xb1, 0x2a, 0x92, 0x05, 0x01, 0x80, 0x6f, 0x0a, 0xcf, 0xa3,
	0x70, 0x19, 0xd6, 0xf4, 0x3a, 0xd7, 0xeb, 0x58, 0xc7, 0x4d, 0xbd, 0xec, 0xfb, 0xf5, 0x8b, 0xeb,
	0xd3, 0x41, 0x6b, 0xd0, 0xea, 0xa4, 0x9d, 0x74, 0xf7, 0x61, 0x7c, 0xd3, 0xcf, 0xfa, 0xd9, 0xe6,
	0xd5, 0xc9, 0x4c, 0x95, 0x8d, 0xdc, 0xa6, 0x8f, 0x8a, 0x20, 0x41, 0x46, 0xd3, 0xf1, 0xd8, 0xf2,
	0xd6, 0xc7, 0x77, 0x9e, 0xf7, 0x9e, 0xc1, 0x73, 0xd5, 0xf3, 0x25, 0x4f, 0xf4, 0x15, 0xf5, 0x6a,
	0x29, 0x6f, 0x96, 0xa1, 0x9b, 0x2f, 0x4b, 0x4d, 0x32, 0x4d, 0x91, 0x5e, 0x61, 0x73, 0xa2, 0xce,
	0x6c, 0xc6, 0xbf, 0xd6, 0xff, 0xb9, 0x72, 0xc5, 0x2b, 0x17, 0xa1, 0xa1, 0x59, 0x2f, 0xeb, 0xf7,
	0x9e, 0x83, 0x4c, 0x16, 0x5c, 0xa5, 0x91, 0xdb, 0xcc, 0xd4, 0xc6, 0xf9, 0x9a, 0x8f, 0xe7, 0xed,
	0xab, 0x5c, 0x4b, 0xef, 0xae, 0x48, 0x4f, 0x6b, 0xe6, 0xbe, 0x62, 0x52, 0xae, 0xb8, 0x9f, 0x47,
	0xfd, 0xed, 0xd0, 0xe7, 0x0c, 0xbd, 0xce, 0x70, 0xec, 0x3d, 0xfc, 0xba, 0x13, 0xdb, 0x5d, 0x28,
	0x77, 0xb7, 0x55, 0x68, 0x16, 0xdb, 0x9e, 0xd6, 0x4f, 0x94, 0x1d, 0xab, 0x5c, 0xff, 0xea, 0x21,
	0x78, 0x0f, 0x75, 0xef, 0xa1, 0x56, 0xf6, 0xb0, 0xd8, 0xea, 0x7e, 0x02, 0x21, 0xfd, 0xdc, 0x7b,
	0x94, 0xe9, 0x39, 0xcc, 0xeb, 0x67, 0xb6, 0x07, 0xef, 0xad, 0x66, 0x9d, 0xd4, 0xf5, 0xcf, 0x6a,
	0xa9, 0x5a, 0x49, 0x62, 0x90, 0x33, 0xb1, 0x03, 0x99, 0x48, 0xa2, 0xc7, 0xd5, 0x15, 0x7b, 0x18,
	0x9e, 0x74, 0x5c, 0xc8, 0xbb, 0x66, 0x92, 0xec, 0xe9, 0xdd, 0x28, 0x0d, 0xb1, 0x47, 0x05, 0xe0,
	0x9f, 0xf8, 0x00, 0xac, 0x06, 0xae, 0x2c, 0x00, 0x4f, 0xb9, 0x26, 0xc7, 0x33, 0x4e, 0x37, 0x13,
	0xd0, 0x0f, 0x18, 0xda, 0x9a, 0x2d, 0xb7, 0x67, 0x05, 0xf0, 0xb8, 0xd4, 0x3c, 0x98, 0x5a, 0x29,
	0x2d, 0xa4, 0xe6, 0xfa, 0x2b, 0x7c, 0xfe, 0x32, 0x83, 0xf1, 0xb8, 0x81, 0x71, 0x29, 0x49, 0x96,
	0x2c, 0x68, 0x5d, 0x70, 0xf7, 0x29, 0xc4, 0xa3, 0x6b, 0x7a, 0x69, 0xd9, 0x7a, 0x84, 0xe8, 0xf7,
	0x5e, 0x5d, 0xcc, 0x8f, 0x75, 0xb6, 0x6c, 0x4b, 0xe1, 0x18, 0x16, 0xbc, 0x15, 0xac, 0x28, 0xa4,
	0x63, 0x1c, 0xa7, 0xc7, 0x9e, 0x31, 0xf0, 0xd9, 0xcb, 0x36, 0xc3, 0x62, 0x38, 0xe3, 0xbb, 0x3e,
	0x09, 0x44, 0x24, 0x7a, 0xc5, 0xc3, 0xe8, 0xa6, 0x16, 0xba, 0x1d, 0xa5, 0xca, 0x4c, 0x61, 0x43,
	0x97, 0x39, 0xfb, 0x74, 0x17, 0x09, 0x27, 0x18, 0x7d, 0x91, 0x50, 0x06, 0xce, 0xdf, 0x66, 0x3e,
	0xfd, 0x4e, 0x7a, 0x31, 0xd8, 0xb6, 0xf3, 0x04, 0x52, 0xfa, 0x75, 0x39, 0x6d, 0x42, 0xc3, 0x21,
	0x41, 0xb4, 0x6a, 0xaf, 0x43, 0x6f, 0x1a, 0xb3, 0x02, 0xea, 0x9f, 0xab, 0x02, 0x39, 0x4e, 0x1a,
	0xa0, 0xcc, 0x62, 0x73, 0xbf, 0x34, 0xea, 0xe6, 0x3c, 0xd7, 0x78, 0x65, 0x1a, 0x5f, 0xb8, 0xc3,
	0x2a, 0xb4, 0x75, 0x3a, 0xeb, 0xbd, 0x5c, 0x59, 0xcf, 0x23, 0x73, 0xef, 0x74, 0x4e, 0x53, 0x0b,
	0x3f, 0x12, 0x96, 0x9f, 0x7a, 0x6c, 0xc3, 0xc9, 0x71, 0xa4, 0x0e, 0xb3, 0xa3, 0x07, 0x6d, 0xc2,
	0x88, 0x70, 0x20, 0x3e, 0xee, 0x6f, 0x3b, 0x4d, 0xa6, 0xff, 0xb1, 0x34, 0x6e, 0x30, 0xd3, 0xd5,
	0x14, 0x1a, 0x24, 0x05, 0x44, 0xfc, 0xb8, 0xe5, 0xad, 0xe7, 0xc3, 0x97, 0xef, 0x54, 0x90, 0x86,
	0xa7, 0x65, 0xc3, 0x6a, 0x69, 0x32, 0x37, 0x5f, 0xc4, 0xf5, 0x26, 0xf4, 0x19, 0x47, 0xb1, 0xf8,
	0xde, 0xd0, 0x07, 0x74, 0x71, 0x97, 0x3b, 0xfb, 0x93, 0xf3, 0xfd, 0x22, 0x72, 0x7d, 0x12, 0x75,
	0x9e, 0xbc, 0xdc, 0x55, 0xad, 0x30, 0xc9, 0xae, 0x25, 0x7b, 0x80, 0xfc, 0x86, 0x47, 0xd3, 0x97,
	0x15, 0xd2, 0xc0, 0x56, 0xdf, 0xff, 0x6c, 0x9d, 0x7f, 0x34, 0x66, 0x05, 0x5a, 0xc7, 0x70, 0xc9,
	0xb7, 0x0b, 0x24, 0xf7, 0x44, 0x26, 0x01, 0x29, 0xf2, 0x6b, 0x3e, 0xb6, 0x63, 0xcf, 0xd3, 0xe8,
	0x0a, 0x0d, 0x94, 0xb8, 0x1b, 0x43, 0x2a, 0x27, 0x0f, 0x94, 0xe6, 0xd6, 0x27, 0x83, 0x6a, 0x66,
	0x61, 0x6b, 0x0e, 0x2c, 0x7b, 0x9e, 0xbd, 0x05, 0x2c, 0x31, 0xd4, 0x00, 0x06, 0x36, 0x8c, 0x9f,
	0x6c, 0xd4, 0xd3, 0x55, 0xc2, 0xbb, 0x4c, 0xf8, 0xb5, 0x4a, 0x5e, 0x77, 0xfe, 0x44, 0x97, 0x09,
	0x57, 0x26, 0xc6, 0xb4, 0x4b, 0x93, 0x37, 0x67, 0x1b, 0xba, 0xd1, 0x42, 0xd9, 0x4c, 0xda, 0xee,
	0x38, 0xe8, 0x22, 0xa8, 0x24, 0x28, 0x84, 0x7e, 0x31, 0x71, 0xb3, 0xe8, 0x36, 0x0c, 0x1e, 0x7d,
	0x03, 0xd5, 0x77, 0xd1, 0x3e, 0xd5, 0xf2, 0x56, 0xc4, 0xd0, 0x45, 0x60, 0x1a, 0x23, 0xfb, 0x86,
	0x7f, 0x29, 0x63, 0x5d, 0xf7, 0xb9, 0xd0, 0x04, 0x07, 0xb3, 0x14, 0x59, 0x58, 0xdf, 0x19, 0x1a,
	0xac, 0x1f, 0xf7, 0xcc, 0x83, 0x24, 0x77, 0xa0, 0x63, 0x85, 0xfb, 0xd2, 0x1d, 0x74, 0x20, 0x20,
	0x73, 0x3d, 0x1c, 0x04, 0xa0, 0x47, 0x9c, 0x74, 0x44, 0x62, 0x1f, 0xd8, 0xa6, 0xf0, 0x6c, 0x28,
	0x66, 0xa3, 0x61, 0x0c, 0xa7, 0x92, 0x4f, 0x11, 0xe0, 0x86, 0xa0, 0xe4, 0x96, 0x0b, 0x0c, 0xd7,
	0x63, 0x3a, 0xb4, 0x25, 0x29, 0x7c, 0xa7, 0x7f, 0x5c, 0x86, 0x15, 0x14, 0x52, 0x6e, 0xbb, 0xce,
	0x92, 0x63, 0x0a, 0x2d, 0x94, 0xdb, 0x17, 0xc8, 0xc7, 0xc5, 0xb5, 0x30, 0x92, 0xae, 0xda, 0x60,
	0xbb, 0x04, 0x73, 0xe2, 0xe9, 0x98, 0x19, 0xbe, 0x00, 0x12, 0x00, 0x01, 0x38, 0x73, 0x41, 0x4e,
	0xc0, 0x09, 0x8e, 0xad, 0x3c, 0x4d, 0x2b, 0x4f, 0x24, 0x01, 0xf9, 0xf0, 0xa0, 0x0e, 0x97, 0x02,
	0x1b, 0x2d, 0xfa, 0x72, 0x16, 0xa6, 0x42, 0xc4, 0x4b, 0x4e, 0x42, 0xc4, 0x41, 0x10, 0x0c, 0x5c,
	0x28, 0xe1, 0x62, 0x04, 0x28, 0x85, 0x88, 0x99, 0x00, 0x76, 0x31, 0x08, 0x3b, 0xb8, 0x02, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02,
	0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x44,
	0x00, 0x00, 0x00, 0x01, 0x00, 0xfd, 0xff, 0xcd, 0x0b, 0x10, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00, 0x10, 0x00, 0x02, 0x00,
	0x10, 0x00, 0x03, 0x00, 0x10, 0x00, 0x99, 0xcf, 0x47, 0x99,
}

```

`pkg/amd/psb/pspentries.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"errors"
	"fmt"
	"os"
	"strings"

	amd_manifest "github.com/linuxboot/fiano/pkg/amd/manifest"

	"github.com/jedib0t/go-pretty/v6/table"
)

const (
	// AMDPublicKeyEntry denotes AMD public key entry in PSP Directory table
	AMDPublicKeyEntry amd_manifest.PSPDirectoryTableEntryType = 0x00

	// PSPRecoveryBootloader is a recovery instance of PSP bootloader
	PSPRecoveryBootloader amd_manifest.PSPDirectoryTableEntryType = 0x03

	// SMUOffChipFirmwareEntry points to a region of firmware containing SMU offchip firmware
	SMUOffChipFirmwareEntry amd_manifest.PSPDirectoryTableEntryType = 0x08

	// ABLPublicKey represents the key used to sign ABL firmware
	ABLPublicKey amd_manifest.PSPDirectoryTableEntryType = 0x0A

	// SMUOffChipFirmware2Entry points to a region of firmware containing SMU offchip firmware
	SMUOffChipFirmware2Entry amd_manifest.PSPDirectoryTableEntryType = 0x12

	// UnlockDebugImageEntry points to a region of firmware containing PSP early secure unlock debug image
	UnlockDebugImageEntry amd_manifest.PSPDirectoryTableEntryType = 0x13

	// SecurityPolicyBinaryEntry points to a region of firmware containing Security Policy Binary
	SecurityPolicyBinaryEntry amd_manifest.PSPDirectoryTableEntryType = 0x24

	// MP5FirmwareEntry points to a region of firmware containing MP5 Firmware
	MP5FirmwareEntry amd_manifest.PSPDirectoryTableEntryType = 0x2A

	// AGESABinary0Entry points to a region of firmware containing PSP AGESA Binary 0
	AGESABinary0Entry amd_manifest.PSPDirectoryTableEntryType = 0x30

	// SEVCodeEntry points to a region of firmware containing SEV Code
	SEVCodeEntry amd_manifest.PSPDirectoryTableEntryType = 0x39

	// DXIOPHYSRAMFirmwareEntry points to a region of firmware containing DXIO PHY SRAM firmware
	DXIOPHYSRAMFirmwareEntry amd_manifest.PSPDirectoryTableEntryType = 0x42

	//DRTMTAEntry points to a region of firmware containing DRTM TA
	DRTMTAEntry amd_manifest.PSPDirectoryTableEntryType = 0x47

	// KeyDatabaseEntry points to region of firmware containing key database
	KeyDatabaseEntry amd_manifest.PSPDirectoryTableEntryType = 0x50

	// OEMSigningKeyEntry represents the OEM signing key
	OEMSigningKeyEntry amd_manifest.BIOSDirectoryTableEntryType = 0x05

	// BIOSRTMVolumeEntry represents the RTM volume
	BIOSRTMVolumeEntry amd_manifest.BIOSDirectoryTableEntryType = 0x62

	// BIOSRTMSignatureEntry represents the entry holding the RTM volume signature
	BIOSRTMSignatureEntry amd_manifest.BIOSDirectoryTableEntryType = 0x07
)

// PSPEntryType defines the type to hold PSP Entry Type fields
type PSPEntryType uint8

/*
 * Nicely output human-readable names for PSP Entry Types
 *
 * This doesn't have all the entries mapped, there are still
 * several more pages left. It does have all the types
 * encountered in the firmware images used to test
 * however.
 *
 */
func (_type PSPEntryType) String() string {
	switch _type {
	case 0x00:
		return "AMD_PUBLIC_KEYS"
	case 0x01:
		return "PSP_BOOT_LOADER"
	case 0x02:
		return "PSP_SECURE_OS"
	case 0x03:
		return "PSP_RECOVERY_BOOTLOADER"
	case 0x04:
		return "PSP_NON_VOLATILE_DATA"
	case 0x08:
		return "SMU_OFF_CHIP_FIRMWARE"
	case 0x09:
		return "AMD_SECURE_DEBUG_KEY"
	case 0x0A:
		return "ABL_PUBLIC_KEY"
	case 0x0B:
		return "PSP_SOFT_FUSE_CHAIN"
	case 0x0C:
		return "PSP_BOOT_LOADED_TRUSTLETS"
	case 0x0D:
		return "PSP_TRUSTLET_PUBLIC_KEY"
	case 0x12:
		return "SMU_OFF_CHIP_FIRMWARE"
	case 0x13:
		return "UNLOCK_DEBUG_IMAGE"
	case 0x20:
		return "IP_DISCOVERY_BINARY"
	case 0x21:
		return "WRAPPED_IKEK"
	case 0x22:
		return "PSP_TOKEN_UNLOCK_DATA"
	case 0x24:
		return "SEC_POLICY_BINARY"
	case 0x25:
		return "MP2_FIRMWARE"
	case 0x26:
		return "MP2_FIRMWARE_PART_TWO"
	case 0x27:
		return "USER_MODE_UNIT_TESTS"
	case 0x28:
		return "SYSTEM_DRIVER_IN_SPI"
	case 0x29:
		return "KVM_IMAGE"
	case 0x2A:
		return "MP5_FIRMWARE"
	case 0x2B:
		return "EMBEDDED_FIRMWARE_STRUCTURE"
	case 0x2C:
		return "TEE_WRITE_ONCE_NVRAM"
	case 0x2D:
		return "EXTERNAL_PSP_BOOTLOADER"
	case 0x2E:
		return "EXTERNAL_MP0"
	case 0x2F:
		return "EXTERNAL_MP1"
	case 0x30:
		return "AGESA_BINARY_0"
	case 0x31:
		return "AGESA_BINARY_1"
	case 0x32:
		return "AGESA_BINARY_2"
	case 0x33:
		return "AGESA_BINARY_3"
	case 0x34:
		return "AGESA_BINARY_4"
	case 0x35:
		return "AGESA_BINARY_5"
	case 0x36:
		return "AGESA_BINARY_6"
	case 0x37:
		return "AGESA_BINARY_7"
	case 0x38:
		return "SEV_DATA"
	case 0x39:
		return "SEV_CODE"
	case 0x3A:
		return "PROCESSOR_SERIAL_WHITELIST"
	case 0x3B:
		return "SERDES_MICROCODE"
	case 0x3C:
		return "VBIOS_PRELOAD"
	case 0x3D:
		return "WLAN_UMAC"
	case 0x3E:
		return "WLAN_IMAC"
	case 0x3F:
		return "WLAN_BLUETOOTH"
	case 0x40:
		return "PSP_DIRECTORY_LEVEL_2"
	case 0x41:
		return "EXTERNAL_MP0_BOOTLOADER"
	case 0x42:
		return "EXTERNAL_DXIO_SRAM_FIRMWARE"
	case 0x43:
		return "EXTERNAL_DXIO_SRAM_PUBLIC_KEY"
	case 0x44:
		return "USB_UNIFIED_PHY_FIRMWARE"
	case 0x45:
		return "SEC_POLICY_BINARY_TOS"
	case 0x46:
		return "EXTERNAL_PSP_BOOTLOADER"
	case 0x47:
		return "DRTM_TA"
	// ... skipped entries ...
	case 0x50:
		return "SPI_ROM_PUBLIC_KEYS"
	}
	return "UNKNOWN"
}

func getPSPTable(pspFirmware *amd_manifest.PSPFirmware, pspLevel uint) (*amd_manifest.PSPDirectoryTable, error) {
	switch pspLevel {
	case 1:
		return pspFirmware.PSPDirectoryLevel1, nil
	case 2:
		return pspFirmware.PSPDirectoryLevel2, nil
	}
	return nil, fmt.Errorf("cannot extract raw PSP entry, invalid PSP Directory Level requested: %d", pspLevel)
}

// OutputPSPEntries outputs the PSP entries in an ASCII table format
func OutputPSPEntries(amdFw *amd_manifest.AMDFirmware) error {
	pspDirectoryLevel1Table, err := getPSPTable(amdFw.PSPFirmware(), 1)
	if err != nil {
		return fmt.Errorf("unable to retrieve PSP Directory Level 1 Entries: %w", err)
	}

	pspDirectoryLevel2Table, err := getPSPTable(amdFw.PSPFirmware(), 2)
	if err != nil {
		return fmt.Errorf("unable to retrieve PSP Directory Level 2 Entries: %w", err)
	}

	pspDirectories := []amd_manifest.PSPDirectoryTable{*pspDirectoryLevel1Table, *pspDirectoryLevel2Table}

	for idx, directory := range pspDirectories {
		// PSP Header
		h := table.NewWriter()
		h.SetOutputMirror(os.Stdout)
		h.SetTitle("PSP Directory Level %d Header", idx+1)
		pspCookie := fmt.Sprintf("0x%x", directory.PSPCookie)
		pspChecksum := directory.Checksum
		pspTotalEntries := directory.TotalEntries
		pspAdditionalInfo := fmt.Sprintf("0x%x", directory.AdditionalInfo)
		h.AppendHeader(table.Row{"PSP Cookie", "Checksum", "Total Entries", "Additional Info"})
		h.AppendRow([]interface{}{pspCookie, pspChecksum, pspTotalEntries, pspAdditionalInfo})
		h.Render()

		// PSP Entries
		t := table.NewWriter()
		t.SetOutputMirror(os.Stdout)
		t.SetTitle("PSP Directory Level %d", idx+1)
		t.AppendHeader(table.Row{"Type", "Hex Type", "SubProgram", "ROM ID", "Size", "Location/Value"})
		for _, entry := range directory.Entries {
			entryType := PSPEntryType(entry.Type)
			entryTypeHex := fmt.Sprintf("0x%-3x", entry.Type)
			entrySubprogram := fmt.Sprintf("0x%-8x", entry.Subprogram)
			entryRomID := fmt.Sprintf("0x%-3x", entry.ROMId)
			entrySize := fmt.Sprintf("%-10d", entry.Size)
			entryLocation := fmt.Sprintf("0x%-10x", entry.LocationOrValue)
			t.AppendRow([]interface{}{entryType, entryTypeHex, entrySubprogram, entryRomID, entrySize, entryLocation})
		}
		t.Render()
	}
	return nil
}

// ValidatePSPEntries validates signature of PSP entries given their entry values in PSP/BIOS Table
func ValidatePSPEntries(amdFw *amd_manifest.AMDFirmware, keyDB KeySet, directory DirectoryType, entries []uint32) ([]SignatureValidationResult, error) {
	validationResults := make([]SignatureValidationResult, 0, len(entries))

	for _, entry := range entries {
		entries, err := GetEntries(amdFw.PSPFirmware(), directory, entry)
		if err != nil {
			return nil, fmt.Errorf("could not extract entry 0x%x from PSP table: %w", entry, err)
		}
		if len(entries) == 0 {
			return nil, fmt.Errorf("no entries %d are found in '%s'", entry, directory)
		}

		for _, entry := range entries {
			validationResult, err := ValidatePSPEntry(amdFw, keyDB, entry.Offset, entry.Length)
			if err != nil {
				return nil, err
			}
			validationResults = append(validationResults, validationResult)
		}
	}
	return validationResults, nil
}

// ValidatePSPEntry validates signature of a PSP entry
func ValidatePSPEntry(amdFw *amd_manifest.AMDFirmware, keyDB KeySet, offset, length uint64) (SignatureValidationResult, error) {
	image := amdFw.Firmware().ImageBytes()
	data, err := GetRangeBytes(image, offset, length)
	if err != nil {
		return SignatureValidationResult{}, err
	}

	binary, err := newPSPBinary(data)
	if err != nil {
		return SignatureValidationResult{}, fmt.Errorf("could not create PSB binary from raw data for entry: 0x%x-0x%x: %w", offset, offset+length, err)
	}
	signedBlob, err := binary.getSignedBlob(keyDB)
	var signedElement strings.Builder
	fmt.Fprintf(&signedElement, "PSP entry 0x%x-0x%x", offset, offset+length)

	if err != nil {
		var sigError *SignatureCheckError
		if errors.As(err, &sigError) {
			return SignatureValidationResult{signedElement: signedElement.String(), signingKey: sigError.SigningKey(), err: err}, nil
		}
		return SignatureValidationResult{signedElement: signedElement.String(), err: err}, nil
	}

	signature := signedBlob.Signature()
	return SignatureValidationResult{signedElement: signedElement.String(), signingKey: signature.SigningKey()}, nil
}

```

`pkg/amd/psb/signature.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/sha512"
	"fmt"
	"strings"
)

// SignedBlob represents an object whose signature is guaranteed to be validated
type SignedBlob struct {
	signature  *Signature
	signedData []byte
}

// SignedData returns a buffer of signed data held by the SignedBlob object
func (b *SignedBlob) SignedData() []byte {
	return b.signedData
}

// Signature returns the signature of the blob
func (b *SignedBlob) Signature() *Signature {
	return b.signature
}

// NewSignedBlob creates a new signed blob object and validates its signature
func NewSignedBlob(signature []byte, signedData []byte, signingKey *Key) (*SignedBlob, error) {
	structuredKey, err := signingKey.Get()
	if err != nil {
		return nil, &SignatureCheckError{signingKey: signingKey, err: fmt.Errorf("could not get structured key data from key in signature object: %w", err)}
	}

	switch rsaKey := structuredKey.(type) {
	case *rsa.PublicKey:
		var (
			hashAlg crypto.Hash
			digest  []byte
		)
		switch size := rsaKey.Size(); size {
		case sha512.Size * 8:
			hashAlg = crypto.SHA384
			hash := sha512.New384()
			hash.Write(signedData)
			digest = hash.Sum(nil)
		case sha256.Size * 8:
			hashAlg = crypto.SHA256
			hash := sha256.New()
			hash.Write(signedData)
			digest = hash.Sum(nil)
		default:
			return nil, fmt.Errorf("signature validation for RSA key with size != 4096/2048 bit (%d) is not supported", size)
		}

		if err := rsa.VerifyPSS(rsaKey, hashAlg, digest, signature, nil); err != nil {
			return nil, &SignatureCheckError{signingKey: signingKey, err: err}
		}
		signature := NewSignature(signature, signingKey)
		return &SignedBlob{signedData: signedData, signature: &signature}, nil
	}
	return nil, fmt.Errorf("signature validation with key type != RSA is not supported")
}

// NewMultiKeySignedBlob validates the signature of a blob against multiple possible keys stored in a KeySet,
// returning the key which validates the signature of the blob
func NewMultiKeySignedBlob(signature []byte, signedData []byte, keySet KeySet) (*SignedBlob, *Key, error) {
	allKeyIDs := keySet.AllKeyIDs()
	for _, keyID := range allKeyIDs {
		key := keySet.GetKey(keyID)
		if key == nil {
			return nil, nil, fmt.Errorf("KeySet is inconsistent, KeyID %s was returned but corresponding key is not present", keyID.Hex())
		}

		blob, err := NewSignedBlob(signature, signedData, key)
		if err == nil {
			return blob, key, nil
		}
	}

	return nil, nil, fmt.Errorf("cannot validate signed blob with any of the %d keys available (%s)", len(allKeyIDs), allKeyIDs.String())
}

// Signature represents the raw signature bytes of a blob
type Signature struct {
	signature  []byte
	signingKey *Key
}

// String returns a string representation of the signature
func (s *Signature) String() string {
	keyID := s.signingKey.data.KeyID
	var str strings.Builder
	fmt.Fprintf(&str, "KeyID: %s\n", keyID.Hex())
	fmt.Fprintf(&str, "Signature: 0x%x\n", s.signature)
	return str.String()
}

// SigningKey returns the signing key associated to the signature
func (s *Signature) SigningKey() *Key {
	return s.signingKey
}

// NewSignature creates a new signature object
func NewSignature(signature []byte, signingKey *Key) Signature {
	return Signature{signature: signature, signingKey: signingKey}
}

// SignatureValidationResult represents the result of a signature validate
type SignatureValidationResult struct {
	signingKey    *Key
	signedElement string
	err           error
}

// String returns a string representation of the signature validation result
func (v *SignatureValidationResult) String() string {

	var str strings.Builder
	fmt.Fprintf(&str, "Signed element: %s\n", v.signedElement)
	if v.signingKey != nil {
		keyID := v.signingKey.data.KeyID
		fmt.Fprintf(&str, "Signing key ID: 0x%s\n", keyID.Hex())
	} else {
		fmt.Fprintf(&str, "Signing key ID: UNKNOWN\n")
	}
	if v.err != nil {
		fmt.Fprintf(&str, "Signature: FAIL (%s)\n", v.err.Error())
	} else {
		fmt.Fprintf(&str, "Signature: OK\n")
	}
	return str.String()
}

// SigningKey returns a key that was used to validate the signature
func (v *SignatureValidationResult) SigningKey() *Key {
	return v.signingKey
}

// Error returns a signature verification error if any
func (v *SignatureValidationResult) Error() error {
	return v.err
}

```

`pkg/amd/psb/types.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

// Buf44B is a binary buffer 44 bytes long
type Buf44B = [44]uint8

// Buf36B is a binary buffer 36 bytes long
type Buf36B = [36]uint8

// Buf32B is a binary buffer 32 bytes long
type Buf32B = [32]uint8

// Buf16B is a binary buffer 16 bytes long
type Buf16B = [16]uint8

// Buf8B is a binary buffer 8 bytes long
type Buf8B = [8]uint8

// Buf4B is a binary buffer 4 bytes long
type Buf4B = [4]uint8

// Buf3B is a binary buffer 3 bytes long
type Buf3B = [3]uint8

```

`pkg/amd/psb/util.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package psb

import (
	"fmt"
)

func reverse(s []byte) []byte {
	if len(s) == 0 {
		return nil
	}
	d := make([]byte, len(s))
	copy(d, s)

	for right := len(d)/2 - 1; right >= 0; right-- {
		left := len(d) - 1 - right
		d[right], d[left] = d[left], d[right]
	}
	return d
}

func checkBoundaries(start, end uint64, blob []byte) error {
	if start > uint64(len(blob)) {
		return fmt.Errorf("boundary check error: start is beyond blob boundary (%d > %d)", start, len(blob))
	}
	if end > uint64(len(blob)) {
		return fmt.Errorf("boundary check error: start is beyond blob boundary (%d > %d)", end, len(blob))
	}
	if start > end {
		return fmt.Errorf("boundary check error: start > end (%d > %d)", start, end)
	}
	return nil
}

```

`pkg/bytes/README.md`:

```md
```
goos: linux
goarch: amd64
BenchmarkIsZeroFilled/size_0/default-8 	1000000000	         3.03 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_0/simple-8  	1000000000	         2.93 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_1/default-8 	1000000000	         4.74 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_1/simple-8  	1000000000	         3.31 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_256/default-8         	212255557	        28.4 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_256/simple-8          	71001369	        86.8 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_65536/default-8       	 1466428	      3961 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_65536/simple-8        	  308932	     19780 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_1048576/default-8     	  106068	     65791 ns/op	       0 B/op	       0 allocs/op
BenchmarkIsZeroFilled/size_1048576/simple-8      	   17924	    335547 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	_/home/xaionaro/go/src/github.com/9elements/converged-security-suite/v2/cmd/pcr0tool/pkg/bytes	63.711s
```
```

`pkg/bytes/is_zero_filled.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bytes

//go:nosplit
func isZeroFilledSimple(b []byte) bool {
	for _, v := range b {
		if v != 0 {
			return false
		}
	}
	return true
}

```

`pkg/bytes/is_zero_filled_amd64.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build amd64
// +build amd64

package bytes

import (
	"unsafe"
)

// IsZeroFilled returns true if b consists of zeros only.
func IsZeroFilled(b []byte) bool {
	length := len(b)
	if length == 0 {
		return true
	}
	var data = unsafe.Pointer(&b[0])

	if uintptr(data)&0x07 != 0 {
		// the data is not aligned, fallback to a simple way
		return isZeroFilledSimple(b)
	}

	dataEnd := uintptr(data) + uintptr(length)
	dataWordsEnd := uintptr(dataEnd) & ^uintptr(0x07)
	// example:
	//
	//     012345678901234567
	//     wwwwwwwwWWWWWWWWtt : w -- word 0; W -- word 1; t -- tail
	//                     ^
	//                     |
	//                     +-- dataWordsEnd
	for ; uintptr(data) < dataWordsEnd; data = unsafe.Pointer(uintptr(data) + 8) {
		if *(*uint64)(data) != 0 {
			return false
		}
	}
	for ; uintptr(data) < dataEnd; data = unsafe.Pointer(uintptr(data) + 1) {
		if *(*uint8)(data) != 0 {
			return false
		}
	}
	return true
}

```

`pkg/bytes/is_zero_filled_other.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !amd64
// +build !amd64

package bytes

// IsZeroFilled returns true if b consists of zeros only.
//
//go:nosplit
func IsZeroFilled(b []byte) bool {
	return isZeroFilledSimple(b)
}

```

`pkg/bytes/is_zero_filled_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bytes

import (
	"fmt"
	"testing"
)

func BenchmarkIsZeroFilled(b *testing.B) {
	for _, size := range []uint64{0, 1, 256, 65536, 1 << 20} {
		d := make([]byte, size)
		b.Run(fmt.Sprintf("size_%d", size), func(b *testing.B) {
			b.Run("default", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()
				for i := 0; i < b.N; i++ {
					IsZeroFilled(d)
				}
			})
			b.Run("simple", func(b *testing.B) {
				b.ReportAllocs()
				b.ResetTimer()
				for i := 0; i < b.N; i++ {
					isZeroFilledSimple(d)
				}
			})
		})
	}
}

```

`pkg/bytes/range.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bytes

import (
	"fmt"
	"sort"
	"strings"
)

// Range defines is a generic bytes range headers.
type Range struct {
	Offset uint64
	Length uint64
}

func (r Range) String() string {
	return fmt.Sprintf(`{"Offset":"0x%x", "Length":"0x%x"}`, r.Offset, r.Length)
}

// Intersect returns True if ranges "r" and "cmp" has at least
// one byte with the same offset.
func (r Range) Intersect(cmp Range) bool {
	if r.Length == 0 || cmp.Length == 0 {
		return false
	}

	startIdx0 := r.Offset
	startIdx1 := cmp.Offset
	endIdx0 := startIdx0 + r.Length
	endIdx1 := startIdx1 + cmp.Length

	if endIdx0 <= startIdx1 {
		return false
	}
	if startIdx0 >= endIdx1 {
		return false
	}

	return true
}

// End returns the first offset after the range.
func (r Range) End() uint64 {
	return r.Offset + r.Length
}

// Exclude returns the parts of the range, which excludes the selected ones.
func (r Range) Exclude(_toExcludes ...Range) Ranges {
	toExcludes := Ranges(_toExcludes)
	toExcludes.SortAndMerge()

	var result Ranges
	curStart := r.Offset
	curEnd := r.End()
	for _, toExclude := range toExcludes {
		excStart := toExclude.Offset
		excEnd := toExclude.End()
		if excEnd <= curStart {
			continue
		}
		if excStart >= curEnd {
			continue
		}

		if curStart < excStart {
			result = append(result, Range{
				Offset: curStart,
				Length: excStart - curStart,
			})
		}

		curStart = excEnd
		if curStart >= curEnd {
			return result
		}
	}

	result = append(result, Range{
		Offset: curStart,
		Length: curEnd - curStart,
	})
	return result
}

// Ranges is a helper to manipulate multiple `Range`-s at once
type Ranges []Range

func (s Ranges) String() string {
	r := make([]string, 0, len(s))
	for _, oneRange := range s {
		r = append(r, oneRange.String())
	}
	return `[` + strings.Join(r, `, `) + `]`
}

// Sort sorts the slice by field Offset
func (s Ranges) Sort() {
	sort.Slice(s, func(i, j int) bool {
		return s[i].Offset < s[j].Offset
	})
}

func maxUint64(a, b uint64) uint64 {
	if a >= b {
		return a
	}
	return b
}

// MergeRanges just merges ranges which has distance less or equal to
// mergeDistance.
//
// Warning: should be called only on sorted ranges!
func MergeRanges(in Ranges, mergeDistance uint64) Ranges {
	if len(in) < 2 {
		return in
	}

	var result Ranges
	entry := in[0]
	for _, nextEntry := range in[1:] {
		// merge "nextEntry" to "entry" if the distance is lower or equal to
		// mergeDistance.

		if entry.Offset+entry.Length+mergeDistance >= nextEntry.Offset {
			newRangeEnd := maxUint64(nextEntry.Offset+nextEntry.Length, entry.Offset+entry.Length)
			entry.Length = newRangeEnd - entry.Offset
			continue
		}

		result = append(result, entry)
		entry = nextEntry
	}
	result = append(result, entry)

	return result
}

// SortAndMerge sorts the slice (by field Offset) and the merges ranges
// which could be merged.
func (s *Ranges) SortAndMerge() {
	// See also TestDiffEntriesSortAndMerge

	if len(*s) < 2 {
		return
	}
	s.Sort()

	*s = MergeRanges(*s, 0)
}

// Compile returns the bytes from `b` which are referenced by `Range`-s `s`.
func (s Ranges) Compile(b []byte) []byte {
	var result []byte
	for _, r := range s {
		result = append(result, b[r.Offset:r.Offset+r.Length]...)
	}
	return result
}

// IsIn returns if the index is covered by this ranges
func (s Ranges) IsIn(index uint64) bool {
	for _, r := range s {
		startIdx := r.Offset
		endIdx := r.Offset + r.Length
		// `startIdx` is inclusive, while `endIdx` is exclusive.
		// The same as usual slice indices works:
		//
		//     slice[startIdx:endIdx]

		if startIdx <= index && index < endIdx {
			return true
		}
	}
	return false
}

```

`pkg/bytes/range_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bytes

import (
	"testing"
)

func TestRangesSortAndMerge(t *testing.T) {
	t.Run("nothing_to_merge", func(t *testing.T) {
		entries := Ranges{{
			Offset: 2,
			Length: 1,
		}, {
			Offset: 0,
			Length: 1,
		}}
		entries.SortAndMerge()
		assertEqualRanges(t, Ranges{{
			Offset: 0,
			Length: 1,
		}, {
			Offset: 2,
			Length: 1,
		}}, entries)
	})
	t.Run("merge_overlapping", func(t *testing.T) {
		entries := Ranges{{
			Offset: 2,
			Length: 3,
		}, {
			Offset: 0,
			Length: 3,
		}}
		entries.SortAndMerge()
		assertEqualRanges(t, Ranges{{
			Offset: 0,
			Length: 5,
		}}, entries)
	})
	t.Run("merge_no_distance", func(t *testing.T) {
		entries := Ranges{{
			Offset: 2,
			Length: 2,
		}, {
			Offset: 0,
			Length: 2,
		}}
		entries.SortAndMerge()
		assertEqualRanges(t, Ranges{{
			Offset: 0,
			Length: 4,
		}}, entries)
	})
	t.Run("merge_next_range_inside_previous", func(t *testing.T) {
		entries := Ranges{
			{
				Offset: 0,
				Length: 0,
			},
			{
				Offset: 12320788,
				Length: 4,
			},
			{
				Offset: 12255584,
				Length: 32,
			},
			{
				Offset: 12582912,
				Length: 4194304,
			},
			{
				Offset: 15760208,
				Length: 67646,
			},
			{
				Offset: 1114112,
				Length: 11141120,
			},
			{
				Offset: 16777152,
				Length: 16,
			},
			{
				Offset: 12255232,
				Length: 432,
			},
		}
		entries.SortAndMerge()
		assertEqualRanges(t, Ranges{
			{
				Offset: 0,
				Length: 0,
			},
			{
				Offset: 1114112,
				Length: 11141552,
			},
			{
				Offset: 12320788,
				Length: 4,
			},
			{
				Offset: 12582912,
				Length: 4194304,
			},
		}, entries)
	})
}

func TestRangeExclude(t *testing.T) {
	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 0,
				Length: 1,
			},
			Range{
				Offset: 2,
				Length: 3,
			},
			Range{
				Offset: 6,
				Length: 4,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 1,
				Length: 1,
			},
			Range{
				Offset: 5,
				Length: 1,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 1,
				Length: 9,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 0,
				Length: 1,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 0,
				Length: 9,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 9,
				Length: 1,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 11,
				Length: 9,
			},
		},
		Range{
			Offset: 10,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 9,
				Length: 2,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 0,
				Length: 9,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 9,
				Length: 2,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 0,
				Length: 10,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 10,
				Length: 10,
			},
		},
		Range{
			Offset: 10,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 0,
				Length: 10,
			},
		),
	)

	assertEqualRanges(t,
		Ranges{
			Range{
				Offset: 0,
				Length: 10,
			},
		},
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 10,
				Length: 10,
			},
		),
	)

	assertEqualRanges(t,
		Ranges(nil),
		Range{
			Offset: 0,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 0,
				Length: 10,
			},
		),
	)

	assertEqualRanges(t,
		Ranges(nil),
		Range{
			Offset: 10,
			Length: 10,
		}.Exclude(
			Range{
				Offset: 0,
				Length: 30,
			},
		),
	)
}

func assertEqualRanges(t *testing.T, expected, actual Ranges) {
	if len(expected) != len(actual) {
		t.Errorf("Expected number of ranges: %d, got: %d", len(expected), len(actual))
	}
	if len(expected) == 0 {
		return
	}

	for i := 0; i < len(expected); i++ {
		expectedRange := expected[i]
		actualRange := actual[i]

		if expectedRange.Offset != actualRange.Offset || expectedRange.Length != actualRange.Length {
			t.Errorf("Range element %d is different, expected: [%d:%d], got: [%d:%d]",
				i,
				expectedRange.Offset,
				actualRange.Offset,
				expectedRange.Length,
				actualRange.Length,
			)
		}
	}
}

```

`pkg/cbfs/bootblock.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeBootBlock, Name: "CBFSBootBlock", New: NewBootBlock}); err != nil {
		log.Fatal(err)
	}
}

func NewBootBlock(f *File) (ReadWriter, error) {
	r := &BootBlockRecord{File: *f}
	Debug("Got header %s", r.String())
	return r, nil
}

func (r *BootBlockRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *BootBlockRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *BootBlockRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *BootBlockRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/bootsplash.go`:

```go
// Copyright 2022 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeBootSplash, Name: "bootsplash", New: NewBootSplash}); err != nil {
		log.Fatal(err)
	}
}

// NewBootSplash returns a ReadWriter interface for the CBFS type TypeBootSplash
func NewBootSplash(f *File) (ReadWriter, error) {
	rec := &BootSplashRecord{File: *f}
	return rec, nil
}

func (r *BootSplashRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *BootSplashRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *BootSplashRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

// File returns a pointer to the corresponding File
func (r *BootSplashRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/cbfs.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import "os"

func Open(n string) (*Image, error) {
	f, err := os.Open(n)
	if err != nil {
		return nil, err
	}

	return NewImage(f)
}

```

`pkg/cbfs/cmos.go`:

```go
// Copyright 2022 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeCMOS, Name: "cmos", New: NewCMOS}); err != nil {
		log.Fatal(err)
	}
}

func NewCMOS(f *File) (ReadWriter, error) {
	rec := &CMOSRecord{File: *f}
	return rec, nil
}

func (r *CMOSRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *CMOSRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *CMOSRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *CMOSRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/cmoslayout.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeCMOSLayout, Name: "CBFSCMOSLayout", New: NewCMOSLayout}); err != nil {
		log.Fatal(err)
	}
}

func NewCMOSLayout(f *File) (ReadWriter, error) {
	rec := &CMOSLayoutRecord{File: *f}
	return rec, nil
}

func (r *CMOSLayoutRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *CMOSLayoutRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *CMOSLayoutRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *CMOSLayoutRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/data.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

var (
	Master = []byte{
		/*0000*/ 0x5f, 0x5f, 0x46, 0x4d, 0x41, 0x50, 0x5f, 0x5f, 0x01, 0x01, 0x00, 0x00, 0xfc, 0xff, 0x00, 0x00, //|__FMAP__........|
		/*0010*/ 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x46, 0x4c, 0x41, 0x53, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, //|......FLASH.....|
		/*0020*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|................|
		/*0030*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, //|................|
		/*0040*/ 0x42, 0x49, 0x4f, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|BIOS............|
		/*0050*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|................|
		/*0060*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x46, 0x4d, 0x41, 0x50, 0x00, 0x00, //|..........FMAP..|
		/*0070*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|................|
		/*0080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, //|................|
		/*0090*/ 0x00, 0xfe, 0x03, 0x00, 0x43, 0x4f, 0x52, 0x45, 0x42, 0x4f, 0x4f, 0x54, 0x00, 0x00, 0x00, 0x00, //|....COREBOOT....|
		/*00a0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|................|
		/*00b0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*00c0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*00d0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*00e0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*00f0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0100*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0110*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0120*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0130*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0140*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0150*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0160*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0170*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0180*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0190*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01a0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01b0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01c0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01d0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01e0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*01f0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0200*/ 0x4c, 0x41, 0x52, 0x43, 0x48, 0x49, 0x56, 0x45, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, //|LARCHIVE... ....|
		/*0210*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x63, 0x62, 0x66, 0x73, 0x20, 0x6d, 0x61, 0x73, //|.......8cbfs mas|
		/*0220*/ 0x74, 0x65, 0x72, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|ter header......|
		/*0230*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x52, 0x42, 0x43, 0x31, 0x31, 0x31, 0x32, //|........ORBC1112|
		/*0240*/ 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x02, 0x00, //|...........@....|
		/*0250*/ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0260*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*0270*/ 0x4c, 0x41, 0x52, 0x43, 0x48, 0x49, 0x56, 0x45, 0x00, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0xff, //|LARCHIVE..w.....|
		/*0280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //|.......(........|
		/*0290*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*02a0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|
		/*02b0*/ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, //|................|

	}
	ListOutput = `FMAP REGIOName: COREBOOT
Name                           Offset     Type           Size   Comp
cbfs master header             0x0        cbfs header        32 none
fallback/romstage              0x80       stage           15812 none
fallback/ramstage              0x3ec0     stage           52417 none
config                         0x10bc0    raw               355 none
revision                       0x10d80    raw               576 none
cmos_layout.bin                0x11000    cmos_layout       548 none
fallback/dsdt.aml              0x11280    raw              6952 none
fallback/payload               0x12e00    simple elf         28 none
(empty)                        0x12e80    null           183192 none
bootblock                      0x3fa40    bootblock         880 none
`
)

```

`pkg/cbfs/empty.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeDeleted, Name: "CBFSEmpty", New: NewEmptyRecord}); err != nil {
		log.Fatal(err)
	}
	if err := RegisterFileReader(&SegReader{Type: TypeDeleted2, Name: "CBFSEmpty", New: NewEmptyRecord}); err != nil {
		log.Fatal(err)
	}
}

func NewEmptyRecord(f *File) (ReadWriter, error) {
	r := &EmptyRecord{File: *f}
	Debug("Got header %v", r.String())
	r.Type = TypeDeleted2
	r.Attr = make([]byte, 16)
	r.FData = ffbyte(f.Size)
	return r, nil
}

func (r *EmptyRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *EmptyRecord) String() string {
	return recString("(empty)", r.RecordStart, r.Type.String(), r.Size, "none")
}

func (r *EmptyRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *EmptyRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/file.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"io"

	"github.com/linuxboot/fiano/pkg/compression"
)

var ErrCBFSHeaderMagicNotFound = errors.New("CBFS header magic doesn't match")

func (f *File) MarshalJSON() ([]byte, error) {
	return json.Marshal(mFile{
		Name:        f.Name,
		Start:       f.RecordStart,
		Size:        f.FileHeader.Size,
		Type:        f.FileHeader.Type.String(),
		Compression: f.Compression().String(),
	})
}

// NewFile reads in the CBFS file at current offset
// On success it seeks to the end of the file.
// On error the current offset withing the ReadSeeker is undefined.
func NewFile(r io.ReadSeeker) (*File, error) {
	var f File
	off, err := r.Seek(0, io.SeekCurrent)
	if err != nil {
		return nil, err
	}
	f.RecordStart = uint32(off)

	err = Read(r, &f.FileHeader)
	if err != nil {
		return nil, err
	}
	if string(f.Magic[:]) != FileMagic {
		return nil, ErrCBFSHeaderMagicNotFound
	}
	Debug("Found CBFS file at %#02x is %v type %v", f.RecordStart, f, f.Type)

	var nameSize uint32
	if f.AttrOffset == 0 {
		nameSize = f.SubHeaderOffset - uint32(binary.Size(FileHeader{}))
	} else {
		nameSize = f.AttrOffset - uint32(binary.Size(FileHeader{}))
	}
	if err := ReadName(r, &f, nameSize); err != nil {
		return nil, err
	}
	if err := ReadAttributes(r, &f); err != nil {
		return nil, err
	}
	if err := ReadData(r, &f); err != nil {
		return nil, err
	}

	return &f, nil
}

// ReadName reads the variable length CBFS name.
func ReadName(r io.Reader, f *File, size uint32) error {
	b := make([]byte, size)
	n, err := r.Read(b)
	if err != nil {
		Debug("ReadName failed:%v", err)
		return err
	}
	fname := cleanString(string(b))
	Debug("ReadName gets '%s' (%#02x)", fname, b)
	if n != len(b) {
		err = fmt.Errorf("ReadName: got %d, want %d for name", n, len(b))
		Debug("ReadName short: %v", err)
		return err
	}
	// discard trailing NULLs
	z := bytes.Split(b, []byte{0})
	Debug("ReadName stripped: '%s'", z)
	f.Name = string(z[0])
	return nil
}

// ReadAttributes reads the variable length CBFS attribute list.
func ReadAttributes(r io.Reader, f *File) error {
	if f.AttrOffset == 0 {
		return nil
	}

	b := make([]byte, f.SubHeaderOffset-f.AttrOffset)
	n, err := r.Read(b)
	if err != nil {
		Debug("ReadAttributes failed:%v", err)
		return err
	}
	Debug("ReadAttributes gets %#02x", b)
	if n != len(b) {
		err = fmt.Errorf("ReadAttributes: got %d, want %d for name", n, len(b))
		Debug("ReadAttributes short: %v", err)
		return err
	}
	f.Attr = b
	return nil
}

// ReadData reads the variable length CBFS file data.
func ReadData(r io.ReadSeeker, f *File) error {
	Debug("ReadData: Seek to %#x", int64(f.RecordStart+f.SubHeaderOffset))
	if _, err := r.Seek(int64(f.RecordStart+f.SubHeaderOffset), io.SeekStart); err != nil {
		return err
	}
	Debug("ReadData: read %#x", f.Size)
	b := make([]byte, f.Size)
	n, err := r.Read(b)
	if err != nil {
		Debug("ReadData failed:%v", err)
		return err
	}
	f.FData = b
	Debug("ReadData gets %#02x", n)
	return nil
}

// FindAttribute returns the attribute with given tag as
// []byte. It has the size as specified by the tag.
// Returns an error if not found or could not read in total.
func (f *File) FindAttribute(t Tag) ([]byte, error) {
	buf := bytes.NewReader(f.Attr)
	generic := FileAttr{}

	for {
		if err := binary.Read(buf, Endian, &generic); err != nil {
			return nil, err
		}
		if generic.Tag == uint32(Unused) || generic.Tag == uint32(Unused2) {
			return nil, fmt.Errorf("end tag found")
		}
		// Validate input
		if generic.Size < uint32(binary.Size(generic)) || generic.Size == 0xffffffff {
			return nil, fmt.Errorf("tag is malformed, aborting")
		}
		Debug("FindAttribute: Found attribute with tag %x", generic.Tag)

		if Tag(generic.Tag) == t {
			_, _ = buf.Seek(-int64(binary.Size(generic)), io.SeekCurrent)

			ret := make([]byte, generic.Size)
			err := binary.Read(buf, Endian, &ret)
			return ret, err
		} else {
			_, err := buf.Seek(int64(generic.Size)-int64(binary.Size(generic)), io.SeekCurrent)
			if err != nil {
				return nil, err
			}
		}
	}
}

// Compression returns the algorithm used to compress FData.
// If no compression attribute is found or on error it returns 'None'
func (f *File) Compression() Compression {
	cattr, err := f.FindAttribute(Compressed)
	if err != nil {
		Debug("Compression: No compression tag found: %v", err)
		return None
	}

	comp := FileAttrCompression{}
	if err := binary.Read(bytes.NewBuffer(cattr), Endian, &comp); err != nil {
		Debug("Compression: failed to read compression tag: %v", err)
		return None
	}
	return comp.Compression
}

// Decompress returns the decompressed FData
// If FData is not compressed it returns FData
func (f *File) Decompress() ([]byte, error) {
	c := f.Compression()
	if c == None {
		return f.FData, nil
	} else if c == LZMA {
		compressor := compression.LZMA{}
		return compressor.Decode(f.FData)
	} else if c == LZ4 {
		compressor := compression.LZ4{}
		return compressor.Decode(f.FData)
	}
	return nil, fmt.Errorf("unknown compression")
}

```

`pkg/cbfs/fns.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"
	"unicode"
)

var Debug = func(format string, v ...interface{}) {}

// Read reads things in in BE format, which they are supposed to be in.
func Read(r io.Reader, f interface{}) error {
	// NOTE: THIS is the `Read` you are looking for!
	if err := binary.Read(r, Endian, f); err != nil {
		if err == io.EOF {
			Debug("Read %v: reached EOF", f)
		}
		return err
	}
	return nil
}

// ReadLE reads things in LE format, which the spec says it is not in.
func ReadLE(r io.Reader, f interface{}) error {
	if err := binary.Read(r, binary.LittleEndian, f); err != nil {
		return err
	}
	return nil
}

// Write reads things in in BE format, which they are supposed to be in.
func Write(w io.Writer, f interface{}) error {
	if err := binary.Write(w, Endian, f); err != nil {
		return err
	}
	return nil
}

// WriteLE reads things in LE format, which the spec says it is not in.
func WriteLE(r io.Writer, f interface{}) error {
	if err := binary.Write(r, binary.LittleEndian, f); err != nil {
		return err
	}
	return nil
}

func (c Compression) String() string {
	switch c {
	case None:
		return "none"
	case LZMA:
		return "lzma"
	case LZ4:
		return "lz4"
	}
	return "unknown"
}

func (f FileType) String() string {
	switch f {
	case TypeDeleted2:
		return "Deleted2"
	case TypeDeleted:
		return "Deleted"
	case TypeMaster:
		return "cbfs header"
	case TypeBootBlock:
		return "BootBlock"
	case TypeLegacyStage:
		return "LegacyStage"
	case TypeStage:
		return "Stage"
	case TypeSELF:
		return "SELF"
	case TypeFIT:
		return "FIT"
	case TypeOptionRom:
		return "OptionRom"
	case TypeBootSplash:
		return "BootSplash"
	case TypeRaw:
		return "Raw"
	case TypeVSA:
		return "VSA"
	case TypeMBI:
		return "MBI"
	case TypeMicroCode:
		return "MicroCode"
	case TypeFSP:
		return "FSP"
	case TypeMRC:
		return "MRC"
	case TypeMMA:
		return "MMA"
	case TypeEFI:
		return "EFI"
	case TypeStruct:
		return "Struct"
	case TypeCMOS:
		return "CMOS"
	case TypeSPD:
		return "SPD"
	case TypeMRCCache:
		return "MRCCache"
	case TypeCMOSLayout:
		return "CMOSLayout"
	}
	return fmt.Sprintf("%#x", uint32(f))
}

func recString(n string, off uint32, typ string, sz uint32, compress string) string {
	return fmt.Sprintf("%-32s 0x%-8x %-24s 0x%-8x %-4s", n, off, typ, sz, compress)
}

// Clean up non-printable and other characters. 0xfffd is the Unicode tofu char,
// aka 'REPLACEMENT CHARACTER': https://unicodemap.org/details/0xFFFD/index.html
// Would occur e.g. from `0x66616c6c6261636b2f726f6d737461676500...00ff...ff`.
func cleanString(n string) string {
	return strings.Map(func(r rune) rune {
		if r != 0xfffd && (unicode.IsPrint(r) || unicode.IsGraphic(r)) {
			return r
		}
		return -1
	}, n)
}

func ffbyte(s uint32) []byte {
	b := make([]byte, s)
	for i := range b {
		b[i] = 0xff
	}
	return b
}

```

`pkg/cbfs/fsp.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeFSP, Name: "fsp", New: NewFSP}); err != nil {
		log.Fatal(err)
	}
}

// NewFSP returns a ReadWriter interface for the CBFS type TypeFSP
func NewFSP(f *File) (ReadWriter, error) {
	rec := &FSPRecord{File: *f}
	return rec, nil
}

func (r *FSPRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *FSPRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *FSPRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

// File returns a pointer to the corresponding File
func (r *FSPRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/image.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/fmap"
)

type SegReader struct {
	Type FileType
	New  func(f *File) (ReadWriter, error)
	Name string
}

var SegReaders = make(map[FileType]*SegReader)

func RegisterFileReader(f *SegReader) error {
	if r, ok := SegReaders[f.Type]; ok {
		return fmt.Errorf("RegisterFileType: Slot of %v is owned by %s, can't add %s", r.Type, r.Name, f.Name)
	}
	SegReaders[f.Type] = f
	Debug("Registered %v", f)
	return nil
}

func NewImage(rs io.ReadSeeker) (*Image, error) {
	// Suck the image in. Todo: write a thing that implements
	// ReadSeeker on a []byte.
	b, err := io.ReadAll(rs)
	if err != nil {
		return nil, fmt.Errorf("failed to read: %w", err)
	}
	in := bytes.NewReader(b)
	f, m, err := fmap.Read(in)
	if err != nil {
		return nil, err
	}
	Debug("Fmap %v", f)
	var i = &Image{FMAP: f, FMAPMetadata: m, Data: b}
	for _, a := range f.Areas {
		Debug("Check %v", a.Name.String())
		if a.Name.String() == "COREBOOT" {
			i.Area = &a
			break
		}
	}
	if i.Area == nil {
		return nil, fmt.Errorf("no CBFS in fmap")
	}
	r := io.NewSectionReader(in, int64(i.Area.Offset), int64(i.Area.Size))

	for off := int64(0); off < int64(i.Area.Size); {
		var f *File

		if _, err := r.Seek(off, io.SeekStart); err != nil {
			return nil, err
		}
		f, err := NewFile(r)
		if err == ErrCBFSHeaderMagicNotFound {
			off = off + 16
			continue
		}
		if err == io.EOF {
			return i, nil
		}
		if err != nil {
			return nil, err
		}

		Debug("It is %v type %v", f, f.Type)
		Debug("Starting at %#02x + %#02x", i.Area.Offset, f.RecordStart)

		sr, ok := SegReaders[f.Type]
		if !ok {
			Debug("No match found for type %v, %v", f.Type, ok)
			sr = &SegReader{Type: f.Type, Name: "Unknown", New: NewUnknownRecord}
		}
		s, err := sr.New(f)
		if err != nil {
			return nil, err
		}
		Debug("Segment: %v", s)
		if err := s.Read(bytes.NewReader(f.FData)); err != nil {
			return nil, fmt.Errorf("reading %#x byte subheader, type %v: %w", len(f.FData), f.Type, err)
		}
		Debug("Segment was readable")
		i.Segs = append(i.Segs, s)
		off, err = r.Seek(0, io.SeekCurrent)
		if err != nil {
			return nil, err
		}
		// Force alignment.
		off = (off + 15) & (^15)
	}
	return i, nil
}

func (i *Image) WriteFile(name string, perm os.FileMode) error {
	if err := os.WriteFile(name, i.Data, 0666); err != nil {
		return err
	}
	return nil
}

// Update creates a new []byte for the cbfs. It is complicated a lot
// by the fact that endianness is not consistent in cbfs images.
func (i *Image) Update() error {
	//FIXME: Support additional regions
	for _, s := range i.Segs {
		var b bytes.Buffer
		if err := Write(&b, s.GetFile().FileHeader); err != nil {
			return err
		}
		if _, err := b.Write(s.GetFile().Attr); err != nil {
			return fmt.Errorf("writing attr to cbfs record for %v: %w", s, err)
		}
		if err := s.Write(&b); err != nil {
			return err
		}
		// This error should not happen but we need to check just in case.
		end := uint32(len(b.Bytes())) + s.GetFile().RecordStart
		if end > i.Area.Size {
			return fmt.Errorf("region [%#x, %#x] outside of CBFS [%#x, %#x]", s.GetFile().RecordStart, end, s.GetFile().RecordStart, i.Area.Size)
		}

		Debug("Copy %s %d bytes to i.Data[%d]", s.GetFile().Type.String(), len(b.Bytes()), i.Area.Offset+s.GetFile().RecordStart)
		copy(i.Data[i.Area.Offset+s.GetFile().RecordStart:], b.Bytes())
	}
	return nil
}

type mImage struct {
	Offset   uint32
	Segments []ReadWriter
}

func (i *Image) MarshalJSON() ([]byte, error) {
	return json.Marshal(mImage{Segments: i.Segs, Offset: i.Area.Offset})
}

func (i *Image) String() string {
	var s = "FMAP REGIOName: COREBOOT\n"

	s += fmt.Sprintf("%-32s %-8s   %-24s %-8s   %-4s\n", "Name", "Offset", "Type", "Size", "Comp")
	for _, seg := range i.Segs {
		s = s + seg.String() + "\n"
	}
	return s
}

func (h *FileHeader) Deleted() bool {
	t := h.Type
	return t == TypeDeleted || t == TypeDeleted2
}

func (i *Image) Remove(n string) error {
	found := -1
	for x, s := range i.Segs {
		if s.GetFile().Name == n {
			found = x
		}
	}
	if found == -1 {
		return os.ErrExist
	}
	// You can not remove the master header
	// Just remake the cbfs if you're doing that kind of surgery.
	if found == 0 {
		return os.ErrPermission
	}
	// Bootblock on x86 is at the end of CBFS and shall stay untouched.
	if found == len(i.Segs)-1 && i.Segs[found].GetFile().Type == TypeBootBlock {
		return os.ErrPermission
	}
	start, end := found, found+1
	if i.Segs[start-1].GetFile().Deleted() {
		start = start - 1
	}
	if i.Segs[end].GetFile().Deleted() {
		end = end + 1
	}
	Debug("Remove: empty range [%d:%d]", start, end)
	base := i.Segs[start].GetFile().RecordStart
	top := i.Segs[end].GetFile().RecordStart
	Debug("Remove: base %#x top %#x", base, top)
	// 0x28: header size + 16-byte-aligned-size name
	s := top - base - 0x28
	i.Segs[found].GetFile().SubHeaderOffset = 0x28
	i.Segs[found].GetFile().Size = s
	del, _ := NewEmptyRecord(i.Segs[found].GetFile())
	Debug("Offset is 0x28, Size is %#x", s)
	Debug("Remove: Replace %d..%d with %s", start, end, del.String())
	// At most, there will be an Empty record before us since
	// things come pre-merged
	i.Segs = append(append(i.Segs[:start], del), i.Segs[end:]...)
	return nil
}

```

`pkg/cbfs/image_test.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"reflect"
	"strings"
	"testing"
)

func TestReadFile(t *testing.T) {
	Debug = t.Logf
	f, err := os.Open("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	i, err := NewImage(f)
	if err != nil {
		t.Fatal(err)
	}
	t.Logf("%s", i)
}

func TestCompression(t *testing.T) {
	Debug = t.Logf
	f, err := os.Open("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	i, err := NewImage(f)
	if err != nil {
		t.Fatal(err)
	}
	for s := range i.Segs {
		f := i.Segs[s].GetFile()
		if f.Name == "compression_test1" {
			if f.Compression() != LZ4 {
				t.Errorf("CBFS file '%s' has wrong compression '%s'", f.Name, f.Compression().String())
			}
			d, err := f.Decompress()
			if err != nil {
				t.Fatal(err)
			}
			data := []byte(strings.Repeat("FIANO ROCKS!\n", 1024))
			if !bytes.Equal(data, d) {
				t.Errorf("Decompressed file '%s' has unexpected contents: %s", f.Name, string(d)[0:12])
			}
		} else if f.Name == "compression_test2" {
			if f.Compression() != LZMA {
				t.Errorf("CBFS file '%s' has wrong compression '%s'", f.Name, f.Compression().String())
			}
			d, err := f.Decompress()
			if err != nil {
				t.Fatal(err)
			}

			data := []byte(strings.Repeat("FIANO ROCKS!\n", 1024))
			if !bytes.Equal(data, d) {
				t.Errorf("Decompressed file '%s' has unexpected contents: %s", f.Name, string(d)[0:12])
			}
		} else if f.Name == "fallback/bootblock" {
			if f.Compression() != None {
				t.Errorf("CBFS file '%s' has wrong compression '%s'", f.Name, f.Compression().String())
			}
		}
	}
	t.Logf("%s", i)
}

func TestBogusArchives(t *testing.T) {
	var tests = []struct {
		n    string
		r    io.ReadSeeker
		want string
	}{
		{"Short", bytes.NewReader([]byte("INUXARCHIV")), "cannot find FMAP signature"},
		{"Misaligned", bytes.NewReader([]byte("INUXARCHIVL")), "cannot find FMAP signature"},
	}

	for _, tc := range tests {
		t.Run(tc.n, func(t *testing.T) {
			_, err := NewImage(tc.r)
			if err == nil {
				t.Errorf("got nil, want %v", tc.want)
				return
			}
			e := fmt.Sprintf("%v", err)
			if e != tc.want {
				t.Errorf("got %v, want %v", e, tc.want)
			}
		})
	}
}

func TestReadSimple(t *testing.T) {
	var tests = []struct {
		n    string
		b    []byte
		want string
	}{
		{"Master Only", Master, ""},
	}
	Debug = t.Logf
	for _, tc := range tests {
		t.Run(tc.n, func(t *testing.T) {
			r := bytes.NewReader(tc.b)
			_, err := NewImage(r)
			if err != nil {
				t.Errorf("got %v, want nil", err)
				return
			}
		})
	}
}

func TestConflict(t *testing.T) {
	if err := RegisterFileReader(&SegReader{Type: 2, Name: "CBFSRaw", New: nil}); err == nil {
		t.Fatalf("Registering conflicting entry to type 2, want error, got nil")
	}

}

func TestStringer(t *testing.T) {
	f, err := os.Open("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	i, err := NewImage(f)
	if err != nil {
		t.Fatal(err)
	}
	s := i.String()

	t.Logf("Image string: %v", s)
}

func TestSimpleWrite(t *testing.T) {
	Debug = t.Logf
	f, err := os.Open("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	i, err := NewImage(f)
	if err != nil {
		t.Fatal(err)
	}
	f.Close()
	out, err := os.CreateTemp("", "cbfs")
	if err != nil {
		t.Fatal(err)
	}
	defer os.Remove(out.Name())
	if err := i.WriteFile(out.Name(), 0666); err != nil {
		t.Fatal(err)
	}
	out.Close()

	fi, err := os.Stat(out.Name())
	if err != nil {
		t.Fatal(err)
	}
	t.Logf("output file %v", fi)
	old, err := os.ReadFile("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	new, err := os.ReadFile(out.Name())
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(old, new) {
		t.Fatalf("testdata/coreboot.rom and %s differ", out.Name())
	}

}

func TestRemovePayload(t *testing.T) {
	Debug = t.Logf
	f, err := os.Open("testdata/coreboot.rom")
	if err != nil {
		t.Fatal(err)
	}
	i, err := NewImage(f)
	if err != nil {
		t.Fatal(err)
	}
	f.Close()
	out, err := os.CreateTemp("", "cbfs")
	if err != nil {
		t.Fatal(err)
	}
	//	defer os.Remove(out.Name())
	if err := i.Remove("fallback/payload"); err != nil {
		t.Fatal(err)
	}
	if err := i.Update(); err != nil {
		t.Fatal(err)
	}
	if err := i.WriteFile(out.Name(), 0666); err != nil {
		t.Fatal(err)
	}
	out.Close()

	fi, err := os.Stat(out.Name())
	if err != nil {
		t.Fatal(err)
	}
	t.Logf("output file %v", fi)
	// FIXME: What is this supposed to do? `removepayload.rom` does not exist
	/*
		f, err = os.Open("testdata/removepayload.rom")
		if err != nil {
			t.Fatal(err)
		}
		old, err := NewImage(f)
		if err != nil {
			t.Fatal(err)
		}
		f.Close()
		f, err = os.Open(out.Name())
		if err != nil {
			t.Fatalf("%s: %v", out.Name(), err)
		}
		new, err := NewImage(f)
		if err != nil {
			t.Fatalf("%s: %v", out.Name(), err)
		}
		f.Close()
		if !reflect.DeepEqual(old, new) {
			t.Errorf("testdata/coreboot.rom and %s differ", out.Name())
		}
		t.Logf("new image is %s", new.String())
	*/

}

```

`pkg/cbfs/master.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"bytes"
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: 2, Name: "CBFSMaster", New: NewMaster}); err != nil {
		log.Fatal(err)
	}
}

func NewMaster(f *File) (ReadWriter, error) {
	Debug("NewMaster: %+v, %x", f, f)
	r := &MasterRecord{File: *f}
	return r, nil
}

func (r *MasterRecord) Read(in io.ReadSeeker) error {
	dump := &bytes.Buffer{}
	n, err := io.Copy(dump, in)
	if err != nil {
		return err
	}
	Debug("MasterRecord (%d bytes)\n   %+v\n   %x", n, r, dump)
	Debug("MasterRecord Header %v at %v", r.MasterHeader, r.Offset)
	if err := Read(in, &r.MasterHeader); err != nil {
		Debug("MasterRecord read from %v: %v", r.Offset, err)
		if err != io.EOF {
			return err
		}
	}
	Debug("Got header %s offset %#x", r.String(), r.Offset)
	return nil
}

func (r *MasterRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, "none")
}

func (r *MasterRecord) Write(w io.Writer) error {
	return Write(w, r.MasterHeader)
}

func (r *MasterRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/microcode.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeMicroCode, Name: "microcode", New: NewMicrocode}); err != nil {
		log.Fatal(err)
	}
}

// NewMicrocode returns a ReadWriter interface for the CBFS type TypeMicroCode
func NewMicrocode(f *File) (ReadWriter, error) {
	rec := &MicrocodeRecord{File: *f}
	return rec, nil
}

func (r *MicrocodeRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *MicrocodeRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *MicrocodeRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

// Header returns a pointer to the corresponding File
func (r *MicrocodeRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/optionrom.go`:

```go
// Copyright 2022 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeOptionRom, Name: "option rom", New: NewOptionROM}); err != nil {
		log.Fatal(err)
	}
}

func NewOptionROM(f *File) (ReadWriter, error) {
	rec := &OptionROMRecord{File: *f}
	return rec, nil
}

func (r *OptionROMRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *OptionROMRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *OptionROMRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *OptionROMRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/payload.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeSELF, Name: "Payload", New: NewPayloadRecord}); err != nil {
		log.Fatal(err)
	}
}

func NewPayloadRecord(f *File) (ReadWriter, error) {
	p := &PayloadRecord{File: *f}
	return p, nil
}

func (r *PayloadRecord) Read(in io.ReadSeeker) error {
	for {
		var h PayloadHeader
		if err := Read(in, &h); err != nil {
			Debug("PayloadHeader read: %v", err)
			return err
		}
		Debug("Got PayloadHeader %s", h.String())
		r.Segs = append(r.Segs, h)
		if h.Type == SegEntry {
			break
		}
	}
	// Seek to offset (after the header); the remainder is the actual payload.
	offset, err := in.Seek(0, io.SeekCurrent)
	if err != nil {
		return fmt.Errorf("finding location in stream: %w", err)
	}
	bodySize := int64(r.Size) - offset
	Debug("Payload size: %v, body size: %v, offset: %v", r.Size, bodySize, offset)
	if bodySize < 0 {
		// This should not happen. Tolerate a potential error.
		return nil
	}
	// This _may_ happen. E.g. with the test payload here. Silently ignore.
	if bodySize == 0 {
		Debug("Payload empty, nothing to read")
		return nil
	}
	r.FData = make([]byte, bodySize)
	n, err := in.Read(r.FData)
	if err != nil {
		return err
	}
	Debug("Payload read %d bytes", n)
	return nil
}

// struct for PayloadRecord marshalling
type mPayloadRecord struct {
	Name        string
	Start       uint32
	Size        uint32
	Type        string
	Segments    []PayloadHeader
	Compression string
}

func (r *PayloadRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(mPayloadRecord{
		Name:        r.Name,
		Start:       r.RecordStart,
		Size:        r.FileHeader.Size,
		Type:        r.FileHeader.Type.String(),
		Segments:    r.Segs,
		Compression: r.File.Compression().String(),
	})
}

func (r *PayloadRecord) String() string {
	s := recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, "none")
	for i, seg := range r.Segs {
		s += "\n"
		s += recString(fmt.Sprintf(" Seg #%d", i), seg.Offset, seg.Type.String(), seg.Size, seg.Compression.String())
	}
	return s
}

// struct for PayloadHeader marshalling
type mPayloadHeader struct {
	Type        string
	Compression string
	Offset      uint32
	LoadAddress uint64
	Size        uint32
	MemSize     uint32
}

func (h *PayloadHeader) MarshalJSON() ([]byte, error) {
	return json.Marshal(mPayloadHeader{
		Type:        h.Type.String(),
		Compression: h.Compression.String(),
		Offset:      h.Offset,
		LoadAddress: h.LoadAddress,
		Size:        h.Size,
		MemSize:     h.MemSize,
	})
}

func (h *PayloadHeader) String() string {
	return fmt.Sprintf("Type %#x Compression %#x Offset %#x LoadAddress %#x Size %#x MemSize %#x",
		h.Type,
		h.Compression,
		h.Offset,
		h.LoadAddress,
		h.Size,
		h.MemSize)
}

func (r *PayloadRecord) Write(w io.Writer) error {
	if err := Write(w, r.Segs); err != nil {
		return err
	}
	return Write(w, r.FData)
}

func (r *PayloadRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/raw.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeRaw, Name: "CBFSRaw", New: NewRaw}); err != nil {
		log.Fatal(err)
	}
}

func NewRaw(f *File) (ReadWriter, error) {
	rec := &RawRecord{File: *f}
	return rec, nil
}

func (r *RawRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *RawRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *RawRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *RawRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/spd.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeSPD, Name: "spd", New: NewSPD}); err != nil {
		log.Fatal(err)
	}
}

// NewSPD returns a ReadWriter for the CBFS type TypeSPD
func NewSPD(f *File) (ReadWriter, error) {
	rec := &SPDRecord{File: *f}
	return rec, nil
}

func (r *SPDRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *SPDRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *SPDRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

// Header returns a pointer to the corresponding File
func (r *SPDRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/stage.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"fmt"
	"io"
	"log"
)

func init() {
	if err := RegisterFileReader(&SegReader{Type: TypeLegacyStage, Name: "LegacyStage", New: NewLegacyStageRecord}); err != nil {
		log.Fatal(err)
	}
	if err := RegisterFileReader(&SegReader{Type: TypeStage, Name: "Stage", New: NewStageRecord}); err != nil {
		log.Fatal(err)
	}
}

func NewLegacyStageRecord(f *File) (ReadWriter, error) {
	r := &LegacyStageRecord{File: *f}
	return r, nil
}

func (r *LegacyStageRecord) Read(in io.ReadSeeker) error {
	if err := ReadLE(in, &r.StageHeader); err != nil {
		Debug("StageHeader read: %v", err)
		return err
	}
	Debug("Got StageHeader %s, data is %d bytes", r.String(), r.StageHeader.Size)
	r.Data = make([]byte, r.StageHeader.Size)
	n, err := in.Read(r.Data)
	if err != nil {
		return err
	}
	Debug("Stage read %d bytes", n)
	return nil
}

func (h *StageHeader) String() string {
	return fmt.Sprintf("Compression %#x Entry %#x LoadAddress %#x Size %#x MemSize %#x",
		h.Compression,
		h.Entry,
		h.LoadAddress,
		h.Size,
		h.MemSize)
}

func (r *LegacyStageRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.Size, r.File.Compression().String())
}

func (r *LegacyStageRecord) Write(w io.Writer) error {
	if err := WriteLE(w, r.StageHeader); err != nil {
		return err
	}

	return Write(w, r.Data)
}

func (r *LegacyStageRecord) GetFile() *File {
	return &r.File
}

func NewStageRecord(f *File) (ReadWriter, error) {
	r := &StageRecord{File: *f}
	return r, nil
}

func (r *StageRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (h *FileAttrStageHeader) String() string {
	return fmt.Sprintf("Size %#x LoadAddress %#x EntryOffset %#x MemSize %#x",
		h.Size,
		h.LoadAddress,
		h.EntryOffset,
		h.MemSize)
}

func (r *StageRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.Type.String(), r.File.Size, r.File.Compression().String())
}

func (r *StageRecord) Write(w io.Writer) error {
	return Write(w, r.Data)
}

func (r *StageRecord) GetFile() *File {
	return &r.File
}

```

`pkg/cbfs/types.go`:

```go
// Copyright 2018-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"encoding/binary"
	"io"

	"github.com/linuxboot/fiano/pkg/fmap"
)

type Props struct {
	Offset uint32
	Size   uint32
}

type Compression uint32

const (
	None Compression = iota
	LZMA
	LZ4
)

var Endian = binary.BigEndian

// These are standard component types for well known
//
//	components (i.e - those that coreboot needs to consume.
//	Users are welcome to use any other value for their
//	components.
type FileType uint32

const (
	// FOV
	TypeDeleted2    FileType = 0xffffffff
	TypeDeleted     FileType = 0
	TypeBootBlock   FileType = 0x1
	TypeMaster      FileType = 0x2
	TypeLegacyStage FileType = 0x10
	TypeStage       FileType = 0x11
	TypeSELF        FileType = 0x20
	TypeFIT         FileType = 0x21
	TypeOptionRom   FileType = 0x30
	TypeBootSplash  FileType = 0x40
	TypeRaw         FileType = 0x50
	TypeVSA         FileType = 0x51 // very, very obsolete Geode thing
	TypeMBI         FileType = 0x52
	TypeMicroCode   FileType = 0x53
	TypeFSP         FileType = 0x60
	TypeMRC         FileType = 0x61
	TypeMMA         FileType = 0x62
	TypeEFI         FileType = 0x63
	TypeStruct      FileType = 0x70
	TypeCMOS        FileType = 0xaa
	TypeSPD         FileType = 0xab
	TypeMRCCache    FileType = 0xac
	TypeCMOSLayout  FileType = 0x1aa
)

const (
	HeaderMagic   = 0x4F524243
	HeaderV1      = 0x31313131
	HeaderV2      = 0x31313132
	HeaderVersion = HeaderV2
	Alignment     = 64
)

/** This is a component header - every entry in the CBFS
  will have this header.

  This is how the component is arranged in the ROM:

  --------------   <- 0
  component header
  --------------   <- sizeof(struct component)
  component name
  --------------   <- offset
  data
  ...
  --------------   <- offset + len
*/

const FileMagic = "LARCHIVE"

const FileSize = 24

type FileHeader struct {
	Magic           [8]byte
	Size            uint32
	Type            FileType
	AttrOffset      uint32
	SubHeaderOffset uint32
}

type File struct {
	FileHeader
	RecordStart uint32
	Name        string
	Attr        []byte
	FData       []byte
}

type mFile struct {
	Name        string
	Start       uint32
	Size        uint32
	Type        string
	Compression string
}

// The common fields of extended cbfs file attributes.
// Attributes are expected to start with tag/len, then append their
// specific fields.
type FileAttr struct {
	Tag  uint32
	Size uint32 // inclusize of Tag and Size
}

type Tag uint32

const (
	Unused     Tag = 0
	Unused2    Tag = 0xffffffff
	Compressed Tag = 0x42435a4c
	Hash       Tag = 0x68736148
	PSCB       Tag = 0x42435350
	ALCB       Tag = 0x42434c41
	SHCB       Tag = 0x53746748
)

type FileAttrCompression struct {
	Tag              Tag
	Size             uint32
	Compression      Compression
	DecompressedSize uint32
}

type FileAttrHash struct {
	Tag      Tag
	Size     uint32 // includes everything including data.
	HashType uint32
	Data     []byte
}

type FileAttrPos struct {
	Tag  Tag
	Size uint32 // includes everything including data.
	Pos  uint32
}

type FileAttrAlign struct {
	Tag   Tag
	Size  uint32 // includes everything including data.
	Align uint32
}

type FileAttrStageHeader struct {
	Tag         Tag
	Size        uint32
	LoadAddress uint64
	EntryOffset uint32
	MemSize     uint32
}

// Component sub-headers

// Following are component sub-headers for the "standard"
// component types

// this is the master cbfs header - it must be located somewhere available
// to bootblock (to load romstage). The last 4 bytes in the image contain its
// relative offset from the end of the image (as a 32-bit signed integer).
const MasterHeaderLen = 32

type MasterHeader struct {
	Magic         uint32
	Version       uint32
	RomSize       uint32
	BootBlockSize uint32
	Align         uint32 // always 64 bytes -- FOV
	Offset        uint32
	Architecture  Architecture // integer, not name -- FOV
	_             uint32
}

type MasterRecord struct {
	File
	MasterHeader
}

type Architecture uint32

const (
	X86 Architecture = 1
	ARM Architecture = 0x10
)

type StageHeader struct {
	Compression Compression
	Entry       uint64
	LoadAddress uint64
	Size        uint32
	MemSize     uint32
}

type LegacyStageRecord struct {
	File
	StageHeader
	Data []byte
}

type StageRecord struct {
	File
	FileAttrStageHeader
	Data []byte
}

type UnknownRecord struct {
	File
}

type RawRecord struct {
	File
}

type EmptyRecord struct {
	File
}

type CMOSRecord struct {
	File
}

type CMOSLayoutRecord struct {
	File
}

type MicrocodeRecord struct {
	File
}

type OptionROMRecord struct {
	File
}

type BootBlockRecord struct {
	File
}

type BootSplashRecord struct {
	File
}

type SPDRecord struct {
	File
}

type FSPRecord struct {
	File
}

type PayloadHeader struct {
	Type        SegmentType
	Compression Compression
	Offset      uint32
	LoadAddress uint64
	Size        uint32
	MemSize     uint32
}

type PayloadRecord struct {
	File
	Segs []PayloadHeader
	Data []byte
}

// fix this mess later to use characters, not constants.
// I had done this once and it never made it into coreboot
// and I still don't know why.
type SegmentType uint32

const (
	SegCode   SegmentType = 0x434F4445
	SegData   SegmentType = 0x44415441
	SegBSS    SegmentType = 0x42535320
	SegParams SegmentType = 0x50415241
	SegEntry  SegmentType = 0x454E5452
)

func (s SegmentType) String() string {
	switch s {
	case SegCode:
		return "code"
	case SegData:
		return "data"
	case SegBSS:
		return "bss"
	case SegParams:
		return "params"
	case SegEntry:
		return "entry"
	}
	return "unknown"
}

type OptionRom struct {
	File
	Compression Compression
	Size        uint32
}

// Each CBFS file type must implement at least this interface.
type ReadWriter interface {
	GetFile() *File
	String() string
	Read(r io.ReadSeeker) error
	Write(f io.Writer) error
}

type Image struct {
	Segs []ReadWriter
	// Scarf away the fmap info.
	FMAP         *fmap.FMap
	FMAPMetadata *fmap.Metadata
	Area         *fmap.Area
	// And all the data.
	Data []byte
}

```

`pkg/cbfs/unknown.go`:

```go
// Copyright 2018-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbfs

import (
	"io"
)

func NewUnknownRecord(f *File) (ReadWriter, error) {
	r := &UnknownRecord{File: *f}
	Debug("Got header %v", r.String())
	r.Attr = make([]byte, 16)
	r.FData = ffbyte(f.Size)
	return r, nil
}

func (r *UnknownRecord) Read(in io.ReadSeeker) error {
	return nil
}

func (r *UnknownRecord) String() string {
	return recString(r.File.Name, r.RecordStart, r.File.Type.String(), r.Size, r.File.Compression().String())
}

func (r *UnknownRecord) Write(w io.Writer) error {
	return Write(w, r.FData)
}

func (r *UnknownRecord) GetFile() *File {
	return &r.File
}

```

`pkg/compression/compression.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package compression implements reading and writing of compressed files.
//
// This package is specifically designed for the LZMA formats used by popular UEFI
// implementations.
package compression

import (
	"flag"
	"os/exec"

	"github.com/linuxboot/fiano/pkg/guid"
)

var brotliPath = flag.String("brotliPath", "brotli", "Path to system brotli command used for brotli encoding.")
var xzPath = flag.String("xzPath", "xz", "Path to system xz command used for lzma encoding. If unset, an internal lzma implementation is used.")

// Compressor defines a single compression scheme (such as LZMA).
type Compressor interface {
	// Name is typically the name of a class.
	Name() string

	// Decode and Encode obey "x == Decode(Encode(x))".
	Decode(encodedData []byte) ([]byte, error)
	Encode(decodedData []byte) ([]byte, error)
}

// Well-known GUIDs for GUIDed sections containing compressed data.
var (
	BROTLIGUID  = *guid.MustParse("3D532050-5CDA-4FD0-879E-0F7F630D5AFB")
	LZMAGUID    = *guid.MustParse("EE4E5898-3914-4259-9D6E-DC7BD79403CF")
	LZMAX86GUID = *guid.MustParse("D42AE6BD-1352-4BFB-909A-CA72A6EAE889")
	ZLIBGUID    = *guid.MustParse("CE3233F5-2CD6-4D87-9152-4A238BB6D1C4")
)

// CompressorFromGUID returns a Compressor for the corresponding GUIDed Section.
func CompressorFromGUID(guid *guid.GUID) Compressor {
	// Default to system xz command for lzma encoding; if not found, use an
	// internal lzma implementation.
	var lzma Compressor
	if _, err := exec.LookPath(*xzPath); err == nil {
		lzma = &SystemLZMA{*xzPath}
	} else {
		lzma = &LZMA{}
	}
	switch *guid {
	case BROTLIGUID:
		return &SystemBROTLI{*brotliPath}
	case LZMAGUID:
		return lzma
	case LZMAX86GUID:
		// Alternatively, the -f86 argument could be passed
		// into xz. It does not make much difference because
		// the x86 filter is not the bottleneck.
		return &LZMAX86{lzma}
	case ZLIBGUID:
		return &ZLIB{}
	}
	return nil
}

```

`pkg/compression/compression_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"os"
	"reflect"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
)

var tests = []struct {
	name            string
	encodedFilename string
	decodedFilename string
	compressor      Compressor
}{
	{
		name:            "random data LZMA",
		encodedFilename: "testdata/random.bin.lzma",
		decodedFilename: "testdata/random.bin",
		compressor:      &LZMA{},
	},
	{
		name:            "random data LZ4",
		encodedFilename: "testdata/random.bin.lz4",
		decodedFilename: "testdata/random.bin",
		compressor:      &LZ4{},
	},
	{
		name:            "random data SystemLZMA",
		encodedFilename: "testdata/random.bin.lzma",
		decodedFilename: "testdata/random.bin",
		compressor:      &SystemLZMA{"xz"},
	},
	{
		name:            "random data LZMAX86",
		encodedFilename: "testdata/random.bin.lzma86",
		decodedFilename: "testdata/random.bin",
		compressor:      &LZMAX86{&LZMA{}},
	},
	{
		name:            "random data SystemLZMAX86",
		encodedFilename: "testdata/random.bin.lzma86",
		decodedFilename: "testdata/random.bin",
		compressor:      &LZMAX86{&SystemLZMA{"xz"}},
	},
	{
		name:            "random data ZLIB",
		encodedFilename: "testdata/random.bin.zlib",
		decodedFilename: "testdata/random.bin",
		compressor:      &ZLIB{},
	},
}

func TestEncodeDecode(t *testing.T) {
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Read test data.
			want, err := os.ReadFile(tt.decodedFilename)
			if err != nil {
				t.Fatal(err)
			}

			// Encoded and decode
			encoded, err := tt.compressor.Encode(want)
			if err != nil {
				t.Fatal(err)
			}
			got, err := tt.compressor.Decode(encoded)
			if err != nil {
				t.Fatal(err)
			}
			if !reflect.DeepEqual(got, want) {
				t.Fatalf("decompressed image did not match, (got: %d bytes, want: %d bytes)", len(got), len(want))
			}
		})
	}
}

func TestDecode(t *testing.T) {
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Read test data.
			want, err := os.ReadFile(tt.decodedFilename)
			if err != nil {
				t.Fatal(err)
			}
			encoded, err := os.ReadFile(tt.encodedFilename)
			if err != nil {
				t.Fatal(err)
			}

			// Decode
			got, err := tt.compressor.Decode(encoded)
			if err != nil {
				t.Fatal(err)
			}
			if !reflect.DeepEqual(got, want) {
				t.Fatalf("decompressed image did not match, (got: %d bytes, want: %d bytes)", len(got), len(want))
			}
		})
	}
}

func TestCompressorFromGUID(t *testing.T) {
	var compressors = []struct {
		name            string
		guid            *guid.GUID
		expected        Compressor
		encodedFilename string
		decodedFilename string
	}{
		{
			name:            "system xz",
			guid:            &LZMAGUID,
			expected:        &SystemLZMA{"xz"},
			encodedFilename: "testdata/random.bin.lzma",
			decodedFilename: "testdata/random.bin",
		},
		{
			name:            "lzma",
			guid:            &LZMAX86GUID,
			expected:        &LZMAX86{&SystemLZMA{"xz"}},
			encodedFilename: "testdata/random.bin.lzma86",
			decodedFilename: "testdata/random.bin",
		},
		{
			name:            "zlib",
			guid:            &ZLIBGUID,
			expected:        &ZLIB{},
			encodedFilename: "testdata/random.bin.zlib",
			decodedFilename: "testdata/random.bin",
		},
	}
	for _, tt := range compressors {
		t.Run(tt.name, func(t *testing.T) {
			compressor := CompressorFromGUID(tt.guid)
			if compressor.Name() != tt.expected.Name() {
				t.Fatalf("compressor from guid %v did not match (got: %s, want: %s)", tt.guid, compressor.Name(), tt.expected.Name())
			}
			// Read test data.
			want, err := os.ReadFile(tt.decodedFilename)
			if err != nil {
				t.Fatal(err)
			}
			// Compare encodings
			encoded, err := compressor.Encode(want)
			if err != nil {
				t.Fatal(err)
			}
			expectedEncoded, terr := tt.expected.Encode(want)
			if terr != nil {
				t.Fatal(terr)
			}
			if !reflect.DeepEqual(encoded, expectedEncoded) {
				t.Fatalf("compressor from guid %v encoding did not match (got: %s, want: %s)", tt.guid, encoded, expectedEncoded)
			}
			// Compare decodings
			got, err := compressor.Decode(encoded)
			if err != nil {
				t.Fatal(err)
			}
			expectedGot, terr := tt.expected.Decode(encoded)
			if terr != nil {
				t.Fatal(terr)
			}
			if !reflect.DeepEqual(got, expectedGot) {
				t.Fatalf("compressor from guid %v decoding did not match (got: %s, want: %s)", tt.guid, got, expectedGot)
			}
			if !reflect.DeepEqual(got, want) {
				t.Fatalf("decompressed image did not match, (got: %d bytes, want: %d bytes)", len(got), len(want))
			}
		})

	}
}

```

`pkg/compression/lz4.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"bytes"
	"io"

	"github.com/pierrec/lz4"
)

// LZ4 implements Compressor and uses a Go-based implementation.
type LZ4 struct{}

// Name returns the type of compression employed.
func (c *LZ4) Name() string {
	return "LZ4"
}

// Decode decodes a byte slice of LZ4 data.
func (c *LZ4) Decode(encodedData []byte) ([]byte, error) {
	return io.ReadAll(lz4.NewReader(bytes.NewBuffer(encodedData)))
}

// Encode encodes a byte slice with LZ4.
func (c *LZ4) Encode(decodedData []byte) ([]byte, error) {

	buf := bytes.Buffer{}
	w := lz4.NewWriter(&buf)
	_, err := w.Write(decodedData)
	if err != nil {
		return nil, err
	}
	w.Flush()

	return buf.Bytes(), nil
}

```

`pkg/compression/lzma.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"bytes"
	"io"

	"github.com/ulikunitz/xz/lzma"
)

// Mapping from compression level to dictionary size.
var lzmaDictCapExps = []uint{18, 20, 21, 22, 22, 23, 23, 24, 25, 26}
var compressionLevel = 7

// LZMA implements Compressor and uses a Go-based implementation.
type LZMA struct{}

// Name returns the type of compression employed.
func (c *LZMA) Name() string {
	return "LZMA"
}

// Decode decodes a byte slice of LZMA data.
func (c *LZMA) Decode(encodedData []byte) ([]byte, error) {
	r, err := lzma.NewReader(bytes.NewBuffer(encodedData))
	if err != nil {
		return nil, err
	}
	return io.ReadAll(r)
}

// Encode encodes a byte slice with LZMA.
func (c *LZMA) Encode(decodedData []byte) ([]byte, error) {
	// These options are supported by the xz's LZMA command and EDK2's LZMA.
	wc := lzma.WriterConfig{
		SizeInHeader: true,
		Size:         int64(len(decodedData)),
		EOSMarker:    false,
		Properties:   &lzma.Properties{LC: 3, LP: 0, PB: 2},
		DictCap:      1 << lzmaDictCapExps[compressionLevel],
	}
	if err := wc.Verify(); err != nil {
		return nil, err
	}
	buf := &bytes.Buffer{}
	w, err := wc.NewWriter(buf)
	if err != nil {
		return nil, err
	}
	if _, err := io.Copy(w, bytes.NewBuffer(decodedData)); err != nil {
		return nil, err
	}
	if err := w.Close(); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

```

`pkg/compression/systembrotli.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"bytes"
	"encoding/binary"
	"os/exec"
)

// SystemBROTLI implements Compression and calls out to the system's compressor
type SystemBROTLI struct {
	brotliPath string
}

// Name returns the type of compression employed.
func (c *SystemBROTLI) Name() string {
	return "BROTLI"
}

// Decode decodes a byte slice of BROTLI data.
func (c *SystemBROTLI) Decode(encodedData []byte) ([]byte, error) {
	// The start of the brotli section contains an 8 byte header describing
	// the final uncompressed size. The real data starts at 0x10

	cmd := exec.Command(c.brotliPath, "--stdout", "-d")
	cmd.Stdin = bytes.NewBuffer(encodedData[0x10:])

	decodedData, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	return decodedData, nil
}

// Encode encodes a byte slice with BROTLI.
func (c *SystemBROTLI) Encode(decodedData []byte) ([]byte, error) {
	cmd := exec.Command(c.brotliPath, "--stdout", "-q", "9")
	cmd.Stdin = bytes.NewBuffer(decodedData)

	encodedData, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	// Generate the size of the decoded data for the header
	decodedSize := &bytes.Buffer{}
	if err := binary.Write(decodedSize, binary.LittleEndian, uint64(len(decodedData))); err != nil {
		return nil, err
	}

	// This seems to be the buffer size needed by the UEFI decompressor
	// 0x03000000 should suffice. The EDK2 base tools generates this header
	// using Brotli internals. This needs to be tuned somehow
	scratchBufferSize := []byte{0x00, 0x00, 0x00, 0x03, 0, 0, 0, 0}
	header := append(decodedSize.Bytes(), scratchBufferSize...)

	encodedData = append(header, encodedData...)

	return encodedData, nil
}

```

`pkg/compression/systemlzma.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"bytes"
	"encoding/binary"
	"os/exec"
)

// SystemLZMA implements Compression and calls out to the system's compressor
// (except for Decode which uses the Go-based decompressor). The sytem's
// compressor is typically faster and generates smaller files than the Go-based
// implementation.
type SystemLZMA struct {
	xzPath string
}

// Name returns the type of compression employed.
func (c *SystemLZMA) Name() string {
	return "LZMA"
}

// Decode decodes a byte slice of LZMA data.
func (c *SystemLZMA) Decode(encodedData []byte) ([]byte, error) {
	// When the xz command compresses, it stores an End-Of-Stream (EOS)
	// marker at the end and 0xFFFFFFFFFFFFFFFF in the header. EDK2's
	// decompressor is primitive and will try to allocate
	// 0xFFFFFFFFFFFFFFFF bytes and fail. So, the Encode function writes
	// the size in the header which works for EDK2's tool. Unfortunately,
	// xz considers an lzma file which has both a valid size and EOS corrupt,
	// but will still decompress it and return exit status 1 (false
	// positive). We simply use the Go decompressor despite being slow.
	return (&LZMA{}).Decode(encodedData)
}

// Encode encodes a byte slice with LZMA.
func (c *SystemLZMA) Encode(decodedData []byte) ([]byte, error) {
	cmd := exec.Command(c.xzPath, "--format=lzma", "-7", "--stdout")
	cmd.Stdin = bytes.NewBuffer(decodedData)
	encodedData, err := cmd.Output()
	if err != nil {
		return nil, err
	}

	// Quoting the XZ Utils manpage:
	//
	//     xz supports decompressing .lzma files with or without
	//     end-of-payload marker, but all .lzma files created by xz will
	//     use end-of-payload marker and have uncompressed size marked as
	//     unknown in the .lzma header. This may be a problem in some
	//     uncommon situations. For example, a .lzma decompressor in an
	//     embedded device might work only with files that have known
	//     uncompressed size.
	//
	// This also affects some UEFI implementations, so the size must be
	// written to the header.
	buf := &bytes.Buffer{}
	if err := binary.Write(buf, binary.LittleEndian, uint64(len(decodedData))); err != nil {
		return nil, err
	}
	copy(encodedData[5:5+8], buf.Bytes())
	return encodedData, nil
}

```

`pkg/compression/x86.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

// LZMAX86 implements Compressor and includes the X86 filter which is popular
// in some UEFI implementations.
type LZMAX86 struct {
	// The X86 filter is layered on top of an existing LZMA implementation.
	lzma Compressor
}

// Name returns the type of compression employed.
func (c *LZMAX86) Name() string {
	return "LZMAX86"
}

// Decode decodes LZMA data with the x86 extension.
func (c *LZMAX86) Decode(encodedData []byte) ([]byte, error) {
	decodedData, err := c.lzma.Decode(encodedData)
	if err != nil {
		return nil, err
	}
	var x86State uint32
	x86Convert(decodedData, uint(len(decodedData)), 0, &x86State, false)
	return decodedData, nil
}

// Encode encodes LZMA data with the x86 extension.
func (c *LZMAX86) Encode(decodedData []byte) ([]byte, error) {
	// x86Convert modifies the input, so a copy is recommened.
	decodedDataCpy := make([]byte, len(decodedData))
	copy(decodedDataCpy, decodedData)

	var x86State uint32
	x86Convert(decodedDataCpy, uint(len(decodedDataCpy)), 0, &x86State, true)
	return c.lzma.Encode(decodedDataCpy)
}

// Adapted from: https://github.com/tianocore/edk2/blob/00f5e11913a8706a1733da2b591502d59f848a99/BaseTools/Source/C/LzmaCompress/Sdk/C/Bra86.c
func x86Convert(data []byte, size uint, ip uint32, state *uint32, encoding bool) uint {
	var pos uint
	mask := *state & 7
	if size < 5 {
		return 0
	}
	size -= 4
	ip += 5

	for {
		p := pos
		for ; p < size; p++ {
			if data[p]&0xFE == 0xE8 {
				break
			}
		}

		{
			d := p - pos
			pos = p
			if p >= size {
				if d > 2 {
					*state = 0
				} else {
					*state = mask >> d
				}
				return pos
			}
			if d > 2 {
				mask = 0
			} else {
				mask >>= d
				if mask != 0 && (mask > 4 || mask == 3 || test86MSByte(data[p+uint(mask>>1)+1])) {
					mask = (mask >> 1) | 4
					pos++
					continue
				}
			}
		}

		if test86MSByte(data[p+4]) {
			v := (uint32(data[p+4]) << 24) + (uint32(data[p+3]) << 16) + (uint32(data[p+2]) << 8) + uint32(data[p+1])
			cur := ip + uint32(pos)
			pos += 5
			if encoding {
				v += cur
			} else {
				v -= cur
			}
			if mask != 0 {
				sh := uint((mask & 6) << 2)
				if test86MSByte(uint8(v >> sh)) {
					v ^= (uint32(0x100) << sh) - 1
					if encoding {
						v += cur
					} else {
						v -= cur
					}
				}
				mask = 0
			}
			data[p+1] = uint8(v)
			data[p+2] = uint8(v >> 8)
			data[p+3] = uint8(v >> 16)
			data[p+4] = uint8(0 - ((v >> 24) & 1))
		} else {
			mask = (mask >> 1) | 4
			pos++
		}
	}
}

func test86MSByte(b byte) bool {
	return (b+1)&0xFE == 0
}

```

`pkg/compression/zlib.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package compression

import (
	"bytes"
	"compress/zlib"
	"encoding/binary"
	"errors"
	"io"
)

const (
	zlibCompressionLevel  = 9
	zlibSectionHeaderSize = 256
	zlibSizeOffset        = 20
)

// ZLIB implements Compressor and uses the zlib package from the standard
// library
type ZLIB struct{}

// Name returns the type of compression employed.
func (c *ZLIB) Name() string {
	return "ZLIB"
}

// Decode decodes a byte slice of ZLIB data.
func (c *ZLIB) Decode(encodedData []byte) ([]byte, error) {
	if len(encodedData) < 256 {
		return nil, errors.New("Zlib.Decode: missing section header")
	}

	// Check size in ZLIB section header
	size := binary.LittleEndian.Uint32(
		encodedData[zlibSizeOffset : zlibSizeOffset+4],
	)
	if size != uint32(len(encodedData)-zlibSectionHeaderSize) {
		return nil, errors.New("ZLIB.Decode: size mismatch")
	}

	// Remove section header
	r, err := zlib.NewReader(
		bytes.NewBuffer(encodedData[zlibSectionHeaderSize:]),
	)
	if err != nil {
		return nil, err
	}

	decodedData, err := io.ReadAll(r)
	r.Close()
	if err != nil {
		return nil, err
	}

	return decodedData, nil
}

// Encode encodes a byte slice with ZLIB.
func (c *ZLIB) Encode(decodedData []byte) ([]byte, error) {
	var encodedData bytes.Buffer

	w, err := zlib.NewWriterLevel(&encodedData, zlibCompressionLevel)
	if err != nil {
		return nil, err
	}

	_, err = w.Write(decodedData)
	w.Close()
	if err != nil {
		return nil, err
	}

	// Add ZLIB section header containing the compressed size and zero padding.
	zlib_header := make([]byte, zlibSectionHeaderSize)
	binary.LittleEndian.PutUint32(
		zlib_header[zlibSizeOffset:],
		uint32(len(encodedData.Bytes())),
	)
	return append(zlib_header, encodedData.Bytes()[:]...), nil
}

```

`pkg/fmap/fmap.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package fmap parses flash maps.
package fmap

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"hash"
	"io"
	"strconv"
	"strings"
)

// Signature of the fmap structure.
var Signature = []byte("__FMAP__")

// Flags which can be applied to Area.Flags.
const (
	FmapAreaStatic = 1 << iota
	FmapAreaCompressed
	FmapAreaReadOnly
)

// String wraps around byte array to give us more control over how strings are
// serialized.
type String struct {
	Value [32]uint8
}

func (s *String) String() string {
	return strings.TrimRight(string(s.Value[:]), "\x00")
}

// MarshalJSON implements json.Marshaler.
func (s *String) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.String())
}

// UnmarshalJSON implements json.Unmarshaler.
func (s *String) UnmarshalJSON(b []byte) error {
	str, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	if len(str) > len(s.Value) {
		return fmt.Errorf("String %#v is longer than 32 bytes", str)
	}
	copy(s.Value[:], []byte(str))
	return nil
}

// FMap structure serializable using encoding.Binary.
type FMap struct {
	Header
	Areas []Area
}

// Header describes the flash part.
type Header struct {
	Signature [8]uint8
	VerMajor  uint8
	VerMinor  uint8
	Base      uint64
	Size      uint32
	Name      String
	NAreas    uint16
}

// Area describes each area.
type Area struct {
	Offset uint32
	Size   uint32
	Name   String
	Flags  uint16
}

// Metadata contains additional data not part of the FMap.
type Metadata struct {
	Start uint64
}

func headerValid(h *Header) bool {
	if h.VerMajor != 1 {
		return false
	}
	// Check if some sensible value is used for the full flash size
	if h.Size == 0 {
		return false
	}

	// Name is specified to be null terminated single-word string without spaces
	return bytes.Contains(h.Name.Value[:], []byte("\x00"))
}

// FlagNames returns human readable representation of the flags.
func FlagNames(flags uint16) string {
	names := []string{}
	m := []struct {
		val  uint16
		name string
	}{
		{FmapAreaStatic, "STATIC"},
		{FmapAreaCompressed, "COMPRESSED"},
		{FmapAreaReadOnly, "READ_ONLY"},
	}
	for _, v := range m {
		if v.val&flags != 0 {
			names = append(names, v.name)
			flags -= v.val
		}
	}
	// Write a hex value for unknown flags.
	if flags != 0 || len(names) == 0 {
		names = append(names, fmt.Sprintf("%#x", flags))
	}
	return strings.Join(names, "|")
}

var errEOF = errors.New("unexpected EOF while parsing fmap")

func readField(r io.Reader, data interface{}) error {
	// The endianness might depend on your machine or it might not.
	if err := binary.Read(r, binary.LittleEndian, data); err != nil {
		return errEOF
	}
	return nil
}

var errSigNotFound = errors.New("cannot find FMAP signature")
var errMultipleFound = errors.New("found multiple fmap")

// Read an FMap into the data structure.
func Read(f io.Reader) (*FMap, *Metadata, error) {
	// Read flash into memory.
	// TODO: it is possible to parse fmap without reading entire file into memory
	data, err := io.ReadAll(f)
	if err != nil {
		return nil, nil, err
	}

	// Loop over __FMAP__ occurrences until a valid header is found
	start := 0
	validFmaps := 0
	var fmap FMap
	var fmapMetadata Metadata
	for {
		if start >= len(data) {
			break
		}

		next := bytes.Index(data[start:], Signature)
		if next == -1 {
			break
		}
		start += next

		// Reader anchored to the start of the fmap
		r := bytes.NewReader(data[start:])

		// Read fields.
		var testFmap FMap
		if err := readField(r, &testFmap.Header); err != nil {
			return nil, nil, err
		}
		if !headerValid(&testFmap.Header) {
			start += len(Signature)
			continue
		}
		fmap = testFmap
		validFmaps++

		fmap.Areas = make([]Area, fmap.NAreas)
		err := readField(r, &fmap.Areas)
		if err != nil {
			return nil, nil, err
		}
		// Return useful metadata
		fmapMetadata = Metadata{
			Start: uint64(start),
		}
		start += len(Signature)
	}
	if validFmaps >= 2 {
		return nil, nil, errMultipleFound
	} else if validFmaps == 1 {
		return &fmap, &fmapMetadata, nil
	}
	return nil, nil, errSigNotFound
}

// Write overwrites the fmap in the flash file.
func Write(f io.WriteSeeker, fmap *FMap, m *Metadata) error {
	if _, err := f.Seek(int64(m.Start), io.SeekStart); err != nil {
		return err
	}
	if err := binary.Write(f, binary.LittleEndian, fmap.Header); err != nil {
		return err
	}
	return binary.Write(f, binary.LittleEndian, fmap.Areas)
}

// IndexOfArea returns the index of an area in the fmap given its name. If no
// names match, -1 is returned.
func (f *FMap) IndexOfArea(name string) int {
	for i := 0; i < len(f.Areas); i++ {
		if f.Areas[i].Name.String() == name {
			return i
		}
	}
	return -1
}

// ReadArea reads an area from the flash image as a byte array given its index.
func (f *FMap) ReadArea(r io.ReaderAt, i int) ([]byte, error) {
	if i < 0 || int(f.NAreas) <= i {
		return nil, fmt.Errorf("area index %d out of range", i)
	}
	buf := make([]byte, f.Areas[i].Size)
	_, err := r.ReadAt(buf, int64(f.Areas[i].Offset))
	return buf, err
}

// ReadAreaByName is the same as ReadArea but uses the area's name.
func (f *FMap) ReadAreaByName(r io.ReaderAt, name string) ([]byte, error) {
	i := f.IndexOfArea(name)
	if i == -1 {
		return nil, fmt.Errorf("FMAP area %q not found", name)
	}
	return f.ReadArea(r, i)
}

// WriteArea writes a byte array to an area on the flash image given its index.
// If the data is too large for the fmap area, the write is not performed and
// an error returned. If the data is too small, the remainder is left untouched.
func (f *FMap) WriteArea(r io.WriterAt, i int, data []byte) error {
	if i < 0 || int(f.NAreas) <= i {
		return fmt.Errorf("Area index %d out of range", i)
	}
	if uint32(len(data)) > f.Areas[i].Size {
		return fmt.Errorf("data too large for fmap area: %#x > %#x",
			len(data), f.Areas[i].Size)
	}
	_, err := r.WriteAt(data, int64(f.Areas[i].Offset))
	return err
}

// WriteAreaByName is the same as WriteArea but uses the area's name.
func (f *FMap) WriteAreaByName(r io.WriterAt, name string, data []byte) error {
	i := f.IndexOfArea(name)
	if i == -1 {
		return fmt.Errorf("FMAP area %q not found", name)
	}
	return f.WriteArea(r, i, data)
}

// Checksum performs a hash of the static areas.
func (f *FMap) Checksum(r io.ReaderAt, h hash.Hash) ([]byte, error) {
	for i, v := range f.Areas {
		if v.Flags&FmapAreaStatic == 0 {
			continue
		}
		areaReader, err := f.ReadArea(r, i)
		if err != nil {
			return nil, err
		}
		_, err = bytes.NewReader(areaReader).WriteTo(h)
		if err != nil {
			return nil, err
		}
	}
	return h.Sum([]byte{}), nil
}

```

`pkg/fmap/fmap_test.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmap

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"reflect"
	"strings"
	"testing"
)

// Flash map is stored in little-endian.
var fmapName = []byte("Fake flash" + strings.Repeat("\x00", 32-10))
var area0Name = []byte("Area Number 1\x00\x00\x00Hello" + strings.Repeat("\x00", 32-21))
var area1Name = []byte("Area Number 2xxxxxxxxxxxxxxxxxxx")
var fakeFlash = bytes.Join([][]byte{
	// Arbitrary data
	bytes.Repeat([]byte{0x53, 0x11, 0x34, 0x22}, 94387),

	// Signature
	Signature,
	// VerMajor, VerMinor
	{1, 0},
	// Base
	{0xef, 0xbe, 0xad, 0xde, 0xbe, 0xba, 0xfe, 0xca},
	// Size
	{0x11, 0x22, 0x33, 0x44},
	// Name (32 bytes)
	fmapName,
	// NAreas
	{0x02, 0x00},

	// Areas[0].Offset
	{0xef, 0xbe, 0xad, 0xde},
	// Areas[0].Size
	{0x11, 0x11, 0x11, 0x11},
	// Areas[0].Name (32 bytes)
	area0Name,
	// Areas[0].Flags
	{0x13, 0x10},

	// Areas[1].Offset
	{0xbe, 0xba, 0xfe, 0xca},
	// Areas[1].Size
	{0x22, 0x22, 0x22, 0x22},
	// Areas[1].Name (32 bytes)
	area1Name,
	// Areas[1].Flags
	{0x00, 0x00},
}, []byte{})

func TestReadFMap(t *testing.T) {
	r := bytes.NewReader(fakeFlash)
	fmap, _, err := Read(r)
	if err != nil {
		t.Fatal(err)
	}
	expected := FMap{
		Header: Header{
			VerMajor: 1,
			VerMinor: 0,
			Base:     0xcafebabedeadbeef,
			Size:     0x44332211,
			NAreas:   2,
		},
		Areas: []Area{
			{
				Offset: 0xdeadbeef,
				Size:   0x11111111,
				Flags:  0x1013,
			}, {
				Offset: 0xcafebabe,
				Size:   0x22222222,
				Flags:  0x0000,
			},
		},
	}
	copy(expected.Signature[:], []byte("__FMAP__"))
	copy(expected.Name.Value[:], fmapName)
	copy(expected.Areas[0].Name.Value[:], area0Name)
	copy(expected.Areas[1].Name.Value[:], area1Name)
	if !reflect.DeepEqual(*fmap, expected) {
		t.Errorf("expected:\n%+v\ngot:\n%+v", expected, *fmap)
	}
}

func TestReadMetadata(t *testing.T) {
	r := bytes.NewReader(fakeFlash)
	_, metadata, err := Read(r)
	if err != nil {
		t.Fatal(err)
	}
	expected := Metadata{
		Start: 4 * 94387,
	}
	if !reflect.DeepEqual(*metadata, expected) {
		t.Errorf("expected:\n%+v\ngot:\n%+v", expected, *metadata)
	}
}

func TestFieldNames(t *testing.T) {
	r := bytes.NewReader(fakeFlash)
	fmap, _, err := Read(r)
	if err != nil {
		t.Fatal(err)
	}
	for i, expected := range []string{"STATIC|COMPRESSED|0x1010", "0x0"} {
		got := FlagNames(fmap.Areas[i].Flags)
		if got != expected {
			t.Errorf("expected:\n%s\ngot:\n%s", expected, got)
		}
	}
}

func TestNoSignature(t *testing.T) {
	fakeFlash := bytes.Repeat([]byte{0x53, 0x11, 0x34, 0x22}, 94387)
	r := bytes.NewReader(fakeFlash)
	_, _, got := Read(r)
	if want := errSigNotFound; got != want {
		t.Errorf("Read(%v) = %v, want %v", r, got, want)
	}
}

func TestTwoSignatures(t *testing.T) {
	fakeFlash := bytes.Repeat(fakeFlash, 2)
	r := bytes.NewReader(fakeFlash)
	_, _, got := Read(r)
	if want := errMultipleFound; got != want {
		t.Errorf("Read(%v) = %v, want %v", r, got, want)
	}
}

func TestTruncatedFmap(t *testing.T) {
	r := bytes.NewReader(fakeFlash[:len(fakeFlash)-2])
	_, _, got := Read(r)
	if want := errEOF; got != want {
		t.Errorf("Read(%v) = %v, want %v", r, got, want)
	}

}

func TestIndexOfArea(t *testing.T) {
	r := bytes.NewReader(fakeFlash)
	fmap, _, err := Read(r)
	if err != nil {
		t.Fatal(err)
	}
	tests := []struct {
		name  string
		index int
	}{
		{strings.TrimRight(string(area0Name), "\x00"), 0},
		{strings.TrimRight(string(area1Name), "\x00"), 1},
		{"not an area name", -1},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			index := fmap.IndexOfArea(tt.name)
			if index != tt.index {
				t.Errorf("expected index: %d, got index: %d", tt.index, index)
			}
		})
	}
}

func TestReadArea(t *testing.T) {
	fmap := FMap{
		Header: Header{
			NAreas: 3,
		},
		Areas: []Area{
			{
				Offset: 0x0,
				Size:   0x10,
			}, {
				Offset: 0x10,
				Size:   0x20,
			}, {
				Offset: 0x30,
				Size:   0x40,
			},
		},
	}
	fakeFlash := bytes.Repeat([]byte{0x53, 0x11, 0x34, 0x22}, 0x70)
	r := bytes.NewReader(fakeFlash)
	got, err := fmap.ReadArea(r, 1)
	if err != nil {
		t.Fatal(err)
	}
	expected := fakeFlash[0x10:0x30]
	if !bytes.Equal(expected, got) {
		t.Errorf("expected: %v; got: %v", expected, got)
	}
}

func TestReadAreaByName(t *testing.T) {
	fmap := FMap{
		Header: Header{
			NAreas: 3,
		},
		Areas: []Area{
			{
				Offset: 0x0,
				Size:   0x10,
			}, {
				Offset: 0x10,
				Size:   0x20,
			}, {
				Offset: 0x30,
				Size:   0x40,
			},
		},
	}
	copy(fmap.Areas[0].Name.Value[:], []byte("Area 1\x00"))
	copy(fmap.Areas[1].Name.Value[:], []byte("Area 2\x00"))
	copy(fmap.Areas[2].Name.Value[:], []byte("Area 3\x00"))
	fakeFlash := bytes.Repeat([]byte{0x53, 0x11, 0x34, 0x22}, 0x70)
	r := bytes.NewReader(fakeFlash)
	got, err := fmap.ReadAreaByName(r, "Area 3")
	if err != nil {
		t.Fatal(err)
	}
	expected := fakeFlash[0x30:0x70]
	if !bytes.Equal(expected, got) {
		t.Errorf("expected: %v; got: %v", expected, got)
	}
}

type testBuffer struct {
	buf []byte
}

func (b *testBuffer) WriteAt(p []byte, off int64) (n int, err error) {
	if off+int64(len(p)) > int64(len(b.buf)) {
		return 0, fmt.Errorf("out of bounds: %d > %d",
			off+int64(len(p)), int64(len(b.buf)))
	}
	copy(b.buf[off:], p)
	return len(p), nil
}

func TestWriteAreaByName(t *testing.T) {
	fmap := FMap{
		Header: Header{
			NAreas: 3,
		},
		Areas: []Area{
			{
				Offset: 0x0,
				Size:   0x10,
			}, {
				Offset: 0x10,
				Size:   0x20,
			}, {
				Offset: 0x30,
				Size:   0x40,
			},
		},
	}
	copy(fmap.Areas[0].Name.Value[:], []byte("Area 1\x00"))
	copy(fmap.Areas[1].Name.Value[:], []byte("Area 2\x00"))
	copy(fmap.Areas[2].Name.Value[:], []byte("Area 3\x00"))
	fakeFlash := bytes.Repeat([]byte{0x53, 0x11, 0x34, 0x22}, 0x70)
	w := &testBuffer{fakeFlash}
	data := []byte("AHHHHH!!!!!!!")
	if err := fmap.WriteAreaByName(w, "Area 2", data); err != nil {
		t.Fatal(err)
	}
	got := fakeFlash[fmap.Areas[1].Offset : fmap.Areas[1].Offset+uint32(len(data))]
	if !bytes.Equal(data, got) {
		t.Errorf("expected: %v; got: %v", data, got)
	}
}

func TestChecksum(t *testing.T) {
	fmap := FMap{
		Header: Header{
			NAreas: 3,
		},
		Areas: []Area{
			{
				Offset: 0x00,
				Size:   0x03,
				Flags:  FmapAreaStatic,
			}, {
				Offset: 0x03,
				Size:   0x20,
				Flags:  0x00,
			}, {
				Offset: 0x23,
				Size:   0x04,
				Flags:  FmapAreaStatic | FmapAreaCompressed,
			},
		},
	}
	fakeFlash := bytes.Repeat([]byte("abcd"), 0x70)
	r := bytes.NewReader(fakeFlash)
	checksum, err := fmap.Checksum(r, sha256.New())
	if err != nil {
		t.Fatal(err)
	}
	// $ echo -n abcdabc | sha256sum
	want := "8a50a4422d673f463f8e4141d8c4b68c4f001ba16f83ad77b8a31bde53ee7273"
	got := fmt.Sprintf("%x", checksum)
	if want != got {
		t.Errorf("want: %v; got: %v", want, got)
	}
}

```

`pkg/fsp/header.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package fsp implements FSP info header parsing
package fsp

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/linuxboot/fiano/pkg/log"
)

// TODO support FSP versions < 2.0
// TODO implement FSP_INFO_EXTENDED_HEADER

// FSP 2.0 specification
// https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/fsp-architecture-spec-v2.pdf

// values from the FSP 2.0 spec
var (
	Signature = [4]byte{'F', 'S', 'P', 'H'}
)

// constants from the FSP 2.0 spec
const (
	// size of the shared part of the header across FSP spec revisions
	FixedInfoHeaderLength = 12
	HeaderV3Length        = 72
	HeaderV4Length        = 72
	HeaderV5Length        = 76
	HeaderV6Length        = 80
	// FSP 2.0
	CurrentSpecVersion = SpecVersion(0x20)
	HeaderMinRevision  = 3
	HeaderMaxRevision  = 6
	// FSP 3.0
	UnsupportedSpecVersion = SpecVersion(0x30)
)

// FixedInfoHeader is the common header among the various revisions of the FSP
// info header.
type FixedInfoHeader struct {
	Signature      [4]byte
	HeaderLength   uint32
	Reserved1      [2]uint8
	SpecVersion    SpecVersion
	HeaderRevision uint8
}

// InfoHeaderRev3 represents the FSP_INFO_HEADER structure revision 3 + 4 (FSP
// 2.0) as defined by Intel.
type InfoHeaderRev3 struct {
	FixedInfoHeader
	ImageRevisionLowBytes     uint32
	ImageID                   [8]byte
	ImageSize                 uint32
	ImageBase                 uint32
	ImageAttribute            ImageAttribute
	ComponentAttribute        ComponentAttribute
	CfgRegionOffset           uint32
	CfgRegionSize             uint32
	Reserved2                 [4]byte
	TempRAMInitEntryOffset    uint32
	Reserved3                 [4]byte
	NotifyPhaseEntryOffset    uint32
	FSPMemoryInitEntryOffset  uint32
	TempRAMExitEntryOffset    uint32
	FSPSiliconInitEntryOffset uint32
}

// InfoHeaderRev5 represents the FSP_INFO_HEADER structure revision 5 (FSP
// 2.0) as defined by Intel.
type InfoHeaderRev5 struct {
	InfoHeaderRev3
	FspMultiPhaseSiInitEntryOffset uint32
}

// InfoHeaderRev6 represents the FSP_INFO_HEADER structure revision 6 (FSP
// 2.0) as defined by Intel.
type InfoHeaderRev6 struct {
	InfoHeaderRev5
	ExtendedImageRevision uint16
	Reserved4             uint16
}

// CommonInfoHeader represents the FSP_INFO_HEADER structure
// revision independent
type CommonInfoHeader struct {
	Signature                      [4]byte
	HeaderLength                   uint32
	SpecVersion                    SpecVersion
	HeaderRevision                 uint8
	ImageRevision                  ImageRevision
	ImageID                        [8]byte
	ImageSize                      uint32
	ImageBase                      uint32
	ImageAttribute                 ImageAttribute
	ComponentAttribute             ComponentAttribute
	CfgRegionOffset                uint32
	CfgRegionSize                  uint32
	TempRAMInitEntryOffset         uint32
	NotifyPhaseEntryOffset         uint32
	FSPMemoryInitEntryOffset       uint32
	TempRAMExitEntryOffset         uint32
	FSPSiliconInitEntryOffset      uint32
	FspMultiPhaseSiInitEntryOffset uint32
	ExtendedImageRevision          uint16
}

// Summary prints a multi-line summary of the header's content.
func (ih CommonInfoHeader) Summary() string {
	s := fmt.Sprintf("Signature                        : %s\n", ih.Signature)
	s += fmt.Sprintf("Header Length                    : %d\n", ih.HeaderLength)
	s += fmt.Sprintf("Spec Version                     : %s\n", ih.SpecVersion)
	s += fmt.Sprintf("Header Revision                  : %d\n", ih.HeaderRevision)
	s += fmt.Sprintf("Image Revision                   : %s\n", ih.ImageRevision)
	s += fmt.Sprintf("Image ID                         : %s\n", ih.ImageID)
	s += fmt.Sprintf("Image Size                       : %#08x %d\n", ih.ImageSize, ih.ImageSize)
	s += fmt.Sprintf("Image Base                       : %#08x %d\n", ih.ImageBase, ih.ImageBase)
	s += fmt.Sprintf("Image Attribute                  : %s\n", ih.ImageAttribute)
	s += fmt.Sprintf("Component Attribute              : %s\n", ih.ComponentAttribute)
	s += fmt.Sprintf("Cfg Region Offset                : %#08x %d\n", ih.CfgRegionOffset, ih.CfgRegionOffset)
	s += fmt.Sprintf("Cfg Region Size                  : %#08x %d\n", ih.CfgRegionSize, ih.CfgRegionSize)
	s += fmt.Sprintf("TempRAMInit Entry Offset         : %#08x %d\n", ih.TempRAMInitEntryOffset, ih.TempRAMInitEntryOffset)
	s += fmt.Sprintf("NotifyPhase Entry Offset         : %#08x %d\n", ih.NotifyPhaseEntryOffset, ih.NotifyPhaseEntryOffset)
	s += fmt.Sprintf("FSPMemoryInit Entry Offset       : %#08x %d\n", ih.FSPMemoryInitEntryOffset, ih.FSPMemoryInitEntryOffset)
	s += fmt.Sprintf("TempRAMExit Entry Offset         : %#08x %d\n", ih.TempRAMExitEntryOffset, ih.TempRAMExitEntryOffset)
	s += fmt.Sprintf("FSPSiliconInit Entry Offset      : %#08x %d\n", ih.FSPSiliconInitEntryOffset, ih.FSPSiliconInitEntryOffset)
	s += fmt.Sprintf("FspMultiPhaseSiInit Entry Offset : %#08x %d\n", ih.FspMultiPhaseSiInitEntryOffset, ih.FspMultiPhaseSiInitEntryOffset)
	s += fmt.Sprintf("ExtendedImageRevision            : %#08x %d\n", ih.ExtendedImageRevision, ih.ExtendedImageRevision)

	return s
}

// ImageRevision is the image revision field of the FSP info header.
type ImageRevision uint64

func (ir ImageRevision) String() string {
	return fmt.Sprintf("%d.%d.%d.%d",
		(ir>>48)&0xffff,
		(ir>>32)&0xffff,
		(ir>>16)&0xffff,
		ir&0xffff,
	)
}

func DecodeImageRevision(HeaderRevision uint8, Revision uint32, ExtendedRevision uint16) ImageRevision {
	///            Major.Minor.Revision.Build
	///            If FSP HeaderRevision is <= 5, the ImageRevision can be decoded as follows:
	///               7 : 0  - Build Number
	///              15 : 8  - Revision
	///              23 : 16 - Minor Version
	///              31 : 24 - Major Version
	///            If FSP HeaderRevision is >= 6, ImageRevision specifies the low-order bytes of the build number and revision
	///            while ExtendedImageRevision specifies the high-order bytes of the build number and revision.
	///               7 : 0  - Low Byte of Build Number
	///              15 : 8  - Low Byte of Revision
	///              23 : 16 - Minor Version
	///              31 : 24 - Major Version
	///            This value is only valid if FSP HeaderRevision is >= 6.
	///
	///            ExtendedImageRevision specifies the high-order byte of the revision and build number in the FSP binary revision.
	///               7 : 0 - High Byte of Build Number
	///              15 : 8 - High Byte of Revision
	///            The FSP binary build number can be decoded as follows:
	///            Build Number = (ExtendedImageRevision[7:0] << 8) | ImageRevision[7:0]
	///            Revision = (ExtendedImageRevision[15:8] << 8) | ImageRevision[15:8]
	///            Minor Version = ImageRevision[23:16]
	///            Major Version = ImageRevision[31:24]

	if HeaderRevision < 6 {
		ExtendedRevision = 0
	}
	return ImageRevision((uint64(Revision)&0xff)<<0 |
		(uint64(Revision)&0xff00)<<8 |
		(uint64(Revision)&0xff0000)<<16 |
		(uint64(Revision)&0xff000000)<<24 |
		(uint64(ExtendedRevision)&0xff)<<8 |
		(uint64(ExtendedRevision)&0xff00)<<16)
}

// SpecVersion represents the spec version as a packed BCD two-digit,
// dot-separated unsigned integer.
type SpecVersion uint8

func (sv SpecVersion) String() string {
	return fmt.Sprintf("%d.%d", (sv>>4)&0x0f, sv&0x0f)
}

// ImageAttribute represents the image attributes.
type ImageAttribute uint16

func (ia ImageAttribute) String() string {
	ret := fmt.Sprintf("%#04x ", uint16(ia))
	if ia.IsGraphicsDisplaySupported() {
		ret += "GraphicsDisplaySupported"
	} else {
		ret += "GraphicsDisplayNotSupported"
	}
	if ia.IsDispatchModeSupported() {
		ret += " DispatchModeSupported"
	} else {
		ret += " DispatchModeNotSupported"
	}
	if uint16(ia) & ^(uint16(1)) != 0 {
		ret += " (reserved bits are not zeroed)"
	}
	return ret
}

// IsGraphicsDisplaySupported returns true if FSP supports enabling graphics display.
func (ia ImageAttribute) IsGraphicsDisplaySupported() bool {
	return uint16(ia)&0x1 == 1
}

// IsDispatchModeSupported returns true if FSP supports Dispatch mode.
func (ia ImageAttribute) IsDispatchModeSupported() bool {
	return uint16(ia)&0x2 == 2
}

// Type identifies the FSP type.
type Type uint8

// FSP types. All the other values are reserved.
var (
	TypeT Type = 1
	TypeM Type = 2
	TypeS Type = 3
	TypeO Type = 8
	// TypeReserved is a fake type that represents a reserved FSP type.
	TypeReserved Type
)

var fspTypeNames = map[Type]string{
	TypeT:        "FSP-T",
	TypeM:        "FSP-M",
	TypeS:        "FSP-S",
	TypeO:        "FSP-O",
	TypeReserved: "FSP-ReservedType",
}

// ComponentAttribute represents the component attribute.
type ComponentAttribute uint16

// IsDebugBuild returns true if the FSP build is a debug build, and false
// if it's a release build.
func (ca ComponentAttribute) IsDebugBuild() bool {
	return uint16(ca)&0x01 == 0
}

// IsTestRelease returns true if the release is a test release, and false if
// it's an official release.
func (ca ComponentAttribute) IsTestRelease() bool {
	return uint16(ca)&0x03 == 0
}

// Type returns the FSP type.
func (ca ComponentAttribute) Type() Type {
	typ := Type(uint16(ca) >> 12)
	if _, ok := fspTypeNames[typ]; ok {
		return typ
	}
	return TypeReserved
}

func (ca ComponentAttribute) String() string {
	var attrs []string
	if ca.IsDebugBuild() {
		attrs = append(attrs, "DebugBuild")
	} else {
		attrs = append(attrs, "ReleaseBuild")
	}
	if ca.IsTestRelease() {
		attrs = append(attrs, "TestRelease")
	} else {
		attrs = append(attrs, "OfficialRelease")
	}
	if typeName, ok := fspTypeNames[ca.Type()]; ok {
		attrs = append(attrs, typeName)
	} else {
		attrs = append(attrs, fmt.Sprintf("TypeUnknown(%v)", ca.Type()))
	}
	ret := fmt.Sprintf("%#04x %s", uint16(ca), strings.Join(attrs, "|"))
	// bits 11:2 are reserved
	if uint16(ca)&0x0ffe != 0 {
		ret += " (reserved bits are not zeroed)"
	}
	return ret
}

// NewInfoHeader creates an CommonInfoHeader from a byte buffer.
func NewInfoHeader(b []byte) (*CommonInfoHeader, error) {
	if len(b) < FixedInfoHeaderLength {
		return nil, fmt.Errorf("short FSP Info Header length %d; want at least %d", len(b), FixedInfoHeaderLength)
	}
	var hdr FixedInfoHeader

	reader := bytes.NewReader(b)
	if err := binary.Read(reader, binary.LittleEndian, &hdr); err != nil {
		return nil, err
	}

	// check signature
	if !bytes.Equal(hdr.Signature[:], Signature[:]) {
		return nil, fmt.Errorf("invalid signature %v; want %v", hdr.Signature, Signature)
	}
	// reserved bytes must be zero'ed
	if !bytes.Equal(hdr.Reserved1[:], []byte{0, 0}) {
		log.Warnf("reserved bytes must be zero, got %v", hdr.Reserved1)
	}
	// check spec version
	// TODO currently, only FSP 2.x is supported
	if hdr.SpecVersion < CurrentSpecVersion || hdr.SpecVersion >= UnsupportedSpecVersion {
		return nil, fmt.Errorf("cannot handle spec version %s; want %s", hdr.SpecVersion, CurrentSpecVersion)
	}

	// check header revision
	if hdr.HeaderRevision < HeaderMinRevision {
		return nil, fmt.Errorf("cannot handle header revision %d; want min %d", hdr.HeaderRevision, HeaderMinRevision)
	}

	l := uint32(0)
	switch hdr.HeaderRevision {
	case 3:
		l = HeaderV3Length
	case 4:
		l = HeaderV4Length
	case 5:
		l = HeaderV5Length
	case 6:
		l = HeaderV6Length
	default:
		l = HeaderV6Length
	}
	if hdr.HeaderRevision <= HeaderMaxRevision {
		// Intel violates their own spec! Warn here and don't care about additional fields.
		if l != hdr.HeaderLength {
			log.Warnf("Spec violation. header length is %d; expected %d", hdr.HeaderLength, l)
		}
	}
	if hdr.HeaderLength < l {
		return nil, fmt.Errorf("invalid header length %d; want at least %d", hdr.HeaderLength, l)
	}

	// now that we know it's an info header spec 2.0, re-read the
	// buffer to fill the whole header.
	reader = bytes.NewReader(b)
	var InfoHeader InfoHeaderRev6

	if hdr.HeaderRevision >= 6 {
		if err := binary.Read(reader, binary.LittleEndian, &InfoHeader); err != nil {
			return nil, err
		}
	} else if hdr.HeaderRevision >= 5 {
		if err := binary.Read(reader, binary.LittleEndian, &InfoHeader.InfoHeaderRev5); err != nil {
			return nil, err
		}
	} else {
		if err := binary.Read(reader, binary.LittleEndian, &InfoHeader.InfoHeaderRev3); err != nil {
			return nil, err
		}
	}

	// Fill common info header
	j, _ := json.Marshal(InfoHeader)
	var c CommonInfoHeader
	if err := json.Unmarshal(j, &c); err != nil {
		return nil, err
	}

	// Update custom types
	c.ImageRevision = DecodeImageRevision(hdr.HeaderRevision,
		InfoHeader.ImageRevisionLowBytes,
		InfoHeader.ExtendedImageRevision)

	return &c, nil
}

```

`pkg/fsp/header_test.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fsp

import (
	"bytes"
	"testing"
)

var (
	FSPTestHeaderRev3 = []byte("FSPHH\x00\x00\x00\x00\x00 \x03\x01\x03\x04\x01$APLFSP$\x00\xa0\x02\x00\x00\x00 \x00\x01\x00\x030$\x01\x00\x00\xb0\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x8a\x05\x00\x00")
	FSPTestHeaderRev4 = []byte("\x46\x53\x50\x48\x4c\x00\x00\x00\x00\x00\x21\x04\x3a\x00\x02\x02\x24\x43\x50\x58\x2d\x53\x50\x24\x00\x00\x04\x00\x00\x00\xcc\xff\x02\x00\x03\x30\x7c\x01\x00\x00\x58\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x98\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa2\x02\x00\x00\x00\x00\x00\x00")
	FSPTestHeaderRev5 = []byte("\x46\x53\x50\x48\x4c\x00\x00\x00\x00\x00\x22\x05\x71\x7d\x00\x0a\x54\x47\x4c\x49\x2d\x46\x53\x50\x00\xa0\x05\x00\x00\x00\xe3\xff\x03\x00\x03\x30\xb4\x06\x00\x00\xe0\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xd8\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe2\x01\x00\x00\xec\x01\x00\x00")
	FSPTestHeaderRev6 = []byte("\x46\x53\x50\x48\x50\x00\x00\x00\x00\x00\x23\x06\x0f\x01\x01\x01\x24\x53\x50\x52\x2d\x53\x50\x24\x00\x80\x00\x00\x00\x00\xfe\xff\x02\x00\x00\x10\x4c\x02\x00\x00\x68\x00\x00\x00\x00\x00\x00\x00\x11\x24\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00")
)

func TestNewInfoHeaderRev3(t *testing.T) {
	hdr, err := NewInfoHeader(FSPTestHeaderRev3)
	if err != nil {
		t.Errorf("NewInfoHeader failed to parse FSP header: %v", err)
	}
	if hdr.Signature != Signature {
		t.Errorf("Invalid signature %v; want %v", hdr.Signature, Signature)
	}
	if hdr.HeaderLength != HeaderV3Length {
		t.Errorf("Invalid header length %d; want %d", hdr.HeaderLength, HeaderV3Length)
	}
	if hdr.SpecVersion != SpecVersion(0x20) {
		t.Errorf("Invalid spec version %s; want %s", hdr.SpecVersion, SpecVersion(0x20))
	}
	if hdr.HeaderRevision != 3 {
		t.Errorf("Invalid header revision %d; want %d", hdr.HeaderRevision, 3)
	}
	if hdr.ImageRevision != ImageRevision(0x1000400030001) {
		t.Errorf("Invalid image revision %s; want %s", hdr.ImageRevision, ImageRevision(0x1000400030001))
	}
	if !bytes.Equal(hdr.ImageID[:], []byte("$APLFSP$")) {
		t.Errorf("Invalid image ID %s; want %s", hdr.ImageID, "$APLFSP$")
	}
	if hdr.ImageSize != 0x2a000 {
		t.Errorf("Invalid image size %#x; want %#x", hdr.ImageSize, 0x2a000)
	}
	if hdr.ImageBase != 0x200000 {
		t.Errorf("Invalid image base %#x; want %#x", hdr.ImageBase, 0x200000)
	}
	if hdr.ImageAttribute != 0x1 {
		t.Errorf("Invalid image attribute %#x; want %#x", hdr.ImageAttribute, 0x1)
	}
	if hdr.ComponentAttribute != 0x3003 {
		t.Errorf("Invalid component attribute %#x; want %#x", hdr.ComponentAttribute, 0x3003)
	}
	if hdr.CfgRegionOffset != 0x124 {
		t.Errorf("Invalid cfg region offset %#x; want %#x", hdr.CfgRegionOffset, 0x124)
	}
	if hdr.CfgRegionSize != 0x3b0 {
		t.Errorf("Invalid cfg region size %#x; want %#x", hdr.CfgRegionSize, 0x3b0)
	}
	if hdr.TempRAMInitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0x0)
	}
	if hdr.NotifyPhaseEntryOffset != 0x580 {
		t.Errorf("Invalid notify phase entry offset %#x; want %#x", hdr.NotifyPhaseEntryOffset, 0x580)
	}
	if hdr.FSPMemoryInitEntryOffset != 0x0 {
		t.Errorf("Invalid FSP memory init entry offset %#x; want %#x", hdr.FSPMemoryInitEntryOffset, 0x0)
	}
	if hdr.TempRAMExitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM exit entry offset %#x; want %#x", hdr.TempRAMExitEntryOffset, 0x0)
	}
	if hdr.FSPSiliconInitEntryOffset != 0x58a {
		t.Errorf("Invalid FSP silicon init entry offset %#x; want %#x", hdr.FSPSiliconInitEntryOffset, 0x58a)
	}
	if hdr.FspMultiPhaseSiInitEntryOffset != 0 {
		t.Errorf("Invalid FSP silicon init entry offset %#x; want %#x", hdr.FspMultiPhaseSiInitEntryOffset, 0)
	}
}

func TestNewInfoHeaderRev4(t *testing.T) {
	hdr, err := NewInfoHeader(FSPTestHeaderRev4)
	if err != nil {
		t.Errorf("NewInfoHeader failed to parse FSP header: %v", err)
	}
	if hdr.Signature != Signature {
		t.Errorf("Invalid signature %v; want %v", hdr.Signature, Signature)
	}
	// This FSP violates the spec! Should be HeaderV4Length.
	if hdr.HeaderLength != HeaderV5Length {
		t.Errorf("Invalid header length %d; want %d", hdr.HeaderLength, HeaderV5Length)
	}
	if hdr.SpecVersion != SpecVersion(0x21) {
		t.Errorf("Invalid spec version %s; want %s", hdr.SpecVersion, SpecVersion(0x21))
	}
	if hdr.HeaderRevision != 4 {
		t.Errorf("Invalid header revision %d; want %d", hdr.HeaderRevision, 4)
	}
	if hdr.ImageRevision != ImageRevision(0x200020000003a) {
		t.Errorf("Invalid image revision %s; want %s", hdr.ImageRevision, ImageRevision(0x200020000003a))
	}
	if !bytes.Equal(hdr.ImageID[:], []byte("$CPX-SP$")) {
		t.Errorf("Invalid image ID %s; want %s", hdr.ImageID, "$CPX-SP$")
	}
	if hdr.ImageSize != 0x40000 {
		t.Errorf("Invalid image size %#x; want %#x", hdr.ImageSize, 0x40000)
	}
	if hdr.ImageBase != 0xffcc0000 {
		t.Errorf("Invalid image base %#x; want %#x", hdr.ImageBase, 0xffcc0000)
	}
	if hdr.ImageAttribute != 0x2 {
		t.Errorf("Invalid image attribute %#x; want %#x", int(hdr.ImageAttribute), 0x2)
	}
	if hdr.ComponentAttribute != 0x3003 {
		t.Errorf("Invalid component attribute %#x; want %#x", int(hdr.ComponentAttribute), 0x3003)
	}
	if hdr.CfgRegionOffset != 0x17c {
		t.Errorf("Invalid cfg region offset %#x; want %#x", hdr.CfgRegionOffset, 0x17c)
	}
	if hdr.CfgRegionSize != 0x58 {
		t.Errorf("Invalid cfg region size %#x; want %#x", hdr.CfgRegionSize, 0x58)
	}
	if hdr.TempRAMInitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0x0)
	}
	if hdr.NotifyPhaseEntryOffset != 0x298 {
		t.Errorf("Invalid notify phase entry offset %#x; want %#x", hdr.NotifyPhaseEntryOffset, 0x298)
	}
	if hdr.FSPMemoryInitEntryOffset != 0x0 {
		t.Errorf("Invalid FSP memory init entry offset %#x; want %#x", hdr.FSPMemoryInitEntryOffset, 0x0)
	}
	if hdr.TempRAMExitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM exit entry offset %#x; want %#x", hdr.TempRAMExitEntryOffset, 0x0)
	}
	if hdr.FSPSiliconInitEntryOffset != 0x2a2 {
		t.Errorf("Invalid FSP silicon init entry offset %#x; want %#x", hdr.FSPSiliconInitEntryOffset, 0x2a2)
	}
	if hdr.FspMultiPhaseSiInitEntryOffset != 0 {
		t.Errorf("Invalid FSP silicon init entry offset %#x; want %#x", hdr.FspMultiPhaseSiInitEntryOffset, 0)
	}
}

func TestNewInfoHeaderRev5(t *testing.T) {
	hdr, err := NewInfoHeader(FSPTestHeaderRev5)
	if err != nil {
		t.Errorf("NewInfoHeader failed to parse FSP header: %v", err)
	}
	if hdr.Signature != Signature {
		t.Errorf("Invalid signature %v; want %v", hdr.Signature, Signature)
	}
	if hdr.HeaderLength != HeaderV5Length {
		t.Errorf("Invalid header length %d; want %d", hdr.HeaderLength, HeaderV5Length)
	}
	if hdr.SpecVersion != SpecVersion(0x22) {
		t.Errorf("Invalid spec version %s; want %s", hdr.SpecVersion, SpecVersion(0x22))
	}
	if hdr.HeaderRevision != 5 {
		t.Errorf("Invalid header revision %d; want %d", hdr.HeaderRevision, 5)
	}
	if hdr.ImageRevision != ImageRevision(0xA0000007d0071) {
		t.Errorf("Invalid image revision %s; want %s", hdr.ImageRevision, ImageRevision(0xA0000007d0071))
	}
	if !bytes.Equal(hdr.ImageID[:], []byte("TGLI-FSP")) {
		t.Errorf("Invalid image ID %s; want %s", hdr.ImageID, "TGLI-FSP")
	}
	if hdr.ImageSize != 0x5a000 {
		t.Errorf("Invalid image size %#x; want %#x", hdr.ImageSize, 0x5a000)
	}
	if hdr.ImageBase != 0xffe30000 {
		t.Errorf("Invalid image base %#x; want %#x", hdr.ImageBase, 0xffe30000)
	}
	if hdr.ImageAttribute != 0x3 {
		t.Errorf("Invalid image attribute %#x; want %#x", int(hdr.ImageAttribute), 0x3)
	}
	if hdr.ComponentAttribute != 0x3003 {
		t.Errorf("Invalid component attribute %#x; want %#x", int(hdr.ComponentAttribute), 0x3003)
	}
	if hdr.CfgRegionOffset != 0x6b4 {
		t.Errorf("Invalid cfg region offset %#x; want %#x", hdr.CfgRegionOffset, 0x6b4)
	}
	if hdr.CfgRegionSize != 0xee0 {
		t.Errorf("Invalid cfg region size %#x; want %#x", hdr.CfgRegionSize, 0xee0)
	}
	if hdr.TempRAMInitEntryOffset != 0 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0)
	}
	if hdr.NotifyPhaseEntryOffset != 0x1d8 {
		t.Errorf("Invalid notify phase entry offset %#x; want %#x", hdr.NotifyPhaseEntryOffset, 0x1d8)
	}
	if hdr.FSPMemoryInitEntryOffset != 0x0 {
		t.Errorf("Invalid FSP memory init entry offset %#x; want %#x", hdr.FSPMemoryInitEntryOffset, 0x0)
	}
	if hdr.TempRAMExitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM exit entry offset %#x; want %#x", hdr.TempRAMExitEntryOffset, 0x0)
	}
	if hdr.FSPSiliconInitEntryOffset != 0x1e2 {
		t.Errorf("Invalid silicon init entry offset %#x; want %#x", hdr.FSPSiliconInitEntryOffset, 0x1e2)
	}
	if hdr.FspMultiPhaseSiInitEntryOffset != 0x1ec {
		t.Errorf("Invalid Multi Phase Si entry offset %#x; want %#x", hdr.FspMultiPhaseSiInitEntryOffset, 0x1ec)
	}
}

func TestNewInfoHeaderRev6(t *testing.T) {
	hdr, err := NewInfoHeader(FSPTestHeaderRev6)
	if err != nil {
		t.Errorf("NewInfoHeader failed to parse FSP header: %v", err)
	}
	if hdr.Signature != Signature {
		t.Errorf("Invalid signature %v; want %v", hdr.Signature, Signature)
	}
	if hdr.HeaderLength != HeaderV6Length {
		t.Errorf("Invalid header length %d; want %d", hdr.HeaderLength, HeaderV6Length)
	}
	if hdr.SpecVersion != SpecVersion(0x23) {
		t.Errorf("Invalid spec version %s; want %s", hdr.SpecVersion, SpecVersion(0x23))
	}
	if hdr.HeaderRevision != 6 {
		t.Errorf("Invalid header revision %d; want %d", hdr.HeaderRevision, 6)
	}
	if hdr.ImageRevision != ImageRevision(0x100010001020F) {
		t.Errorf("Invalid image revision %s; want %s", hdr.ImageRevision, ImageRevision(0x100010001020F))
	}
	if !bytes.Equal(hdr.ImageID[:], []byte("$SPR-SP$")) {
		t.Errorf("Invalid image ID %s; want %s", hdr.ImageID, "$SPR-SP$")
	}
	if hdr.ImageSize != 0x8000 {
		t.Errorf("Invalid image size %#x; want %#x", hdr.ImageSize, 0x8000)
	}
	if hdr.ImageBase != 0xfffe0000 {
		t.Errorf("Invalid image base %#x; want %#x", hdr.ImageBase, 0xfffe0000)
	}
	if hdr.ImageAttribute != 0x2 {
		t.Errorf("Invalid image attribute %#x; want %#x", int(hdr.ImageAttribute), 0x2)
	}
	if hdr.ComponentAttribute != 0x1000 {
		t.Errorf("Invalid component attribute %#x; want %#x", int(hdr.ComponentAttribute), 0x1000)
	}
	if hdr.CfgRegionOffset != 0x24c {
		t.Errorf("Invalid cfg region offset %#x; want %#x", hdr.CfgRegionOffset, 0x24c)
	}
	if hdr.CfgRegionSize != 0x68 {
		t.Errorf("Invalid cfg region size %#x; want %#x", hdr.CfgRegionSize, 0x68)
	}
	if hdr.TempRAMInitEntryOffset != 0x2411 {
		t.Errorf("Invalid temp RAM init entry offset %#x; want %#x", hdr.TempRAMInitEntryOffset, 0x2411)
	}
	if hdr.NotifyPhaseEntryOffset != 0 {
		t.Errorf("Invalid notify phase entry offset %#x; want %#x", hdr.NotifyPhaseEntryOffset, 0)
	}
	if hdr.FSPMemoryInitEntryOffset != 0x0 {
		t.Errorf("Invalid FSP memory init entry offset %#x; want %#x", hdr.FSPMemoryInitEntryOffset, 0x0)
	}
	if hdr.TempRAMExitEntryOffset != 0x0 {
		t.Errorf("Invalid temp RAM exit entry offset %#x; want %#x", hdr.TempRAMExitEntryOffset, 0x0)
	}
	if hdr.FSPSiliconInitEntryOffset != 0x0 {
		t.Errorf("Invalid silicon init entry offset %#x; want %#x", hdr.FSPSiliconInitEntryOffset, 0x0)
	}
	if hdr.FspMultiPhaseSiInitEntryOffset != 0 {
		t.Errorf("Invalid Multi Phase Si entry offset %#x; want %#x", hdr.FspMultiPhaseSiInitEntryOffset, 0)
	}
}

func TestErrorPath(t *testing.T) {
	// Header too small
	tmp := make([]byte, len(FSPTestHeaderRev3))
	copy(tmp, FSPTestHeaderRev3)
	_, err := NewInfoHeader(tmp[:len(tmp)-1])
	if err == nil {
		t.Errorf("Expected an error")
	}

	copy(tmp, FSPTestHeaderRev3)
	_, err = NewInfoHeader(tmp[:11])
	if err == nil {
		t.Errorf("Expected an error")
	}

	// Signature corrupted
	copy(tmp, FSPTestHeaderRev3)
	tmp[0] = 0
	_, err = NewInfoHeader(tmp)
	if err == nil {
		t.Errorf("Expected an error")
	}

	// Spec version too small
	copy(tmp, FSPTestHeaderRev3)
	tmp[10] = 0x10
	_, err = NewInfoHeader(tmp)
	if err == nil {
		t.Errorf("Expected an error")
	}

	// Spec version too big
	copy(tmp, FSPTestHeaderRev3)
	tmp[10] = 0x30
	_, err = NewInfoHeader(tmp)
	if err == nil {
		t.Errorf("Expected an error")
	}

	// Header too small
	copy(tmp, FSPTestHeaderRev3)
	tmp[4] = byte(len(tmp) - 1)
	tmp[5] = 0
	tmp[6] = 0
	tmp[7] = 0
	_, err = NewInfoHeader(tmp)
	if err == nil {
		t.Errorf("Expected an error")
	}

	// Header Revision too small
	copy(tmp, FSPTestHeaderRev3)
	tmp[11] = 2
	_, err = NewInfoHeader(tmp)
	if err == nil {
		t.Errorf("Expected an error")
	}
}

func TestComponentAttribute(t *testing.T) {
	ca := ComponentAttribute(0x3003)
	if ca.IsDebugBuild() {
		t.Errorf("Invalid component attribute: got debug build; want release build")
	}
	if ca.IsTestRelease() {
		t.Errorf("Invalid component attribute: got test release; want official release")
	}
	if ca.Type() != TypeS {
		t.Errorf("Invalid FSP type: got %v; want %v", ca.Type(), TypeS)
	}
	// test FSP type reserved
	ca = ComponentAttribute(0xffff)
	if ca.Type() != TypeReserved {
		t.Errorf("Invalid FSP type: got %v; want %v", ca.Type(), TypeReserved)
	}
}

func TestImageAttribute(t *testing.T) {
	// graphics display not supported, dispatch mode not supported
	ia := ImageAttribute(0)
	if ia.IsGraphicsDisplaySupported() {
		t.Errorf("Expected false, got true")
	}
	// graphics display supported
	ia = ImageAttribute(1)
	if !ia.IsGraphicsDisplaySupported() {
		t.Errorf("Expected true, got false")
	}
	// dispatch mode supported
	ia = ImageAttribute(2)
	if !ia.IsDispatchModeSupported() {
		t.Errorf("Expected true, got false")
	}
	if ia.IsGraphicsDisplaySupported() {
		t.Errorf("Expected false, got true")
	}
	// graphics display supported, dispatch mode supported
	ia = ImageAttribute(3)
	if !ia.IsDispatchModeSupported() || !ia.IsGraphicsDisplaySupported() {
		t.Errorf("Expected true, got false")
	}
}

func TestNewInfoHeaderShortHeader(t *testing.T) {
	_, err := NewInfoHeader([]byte{})
	if err == nil {
		t.Errorf("Expected error, got nil")
	}
}

func TestNewInfoHeaderInvalidSignature(t *testing.T) {
	_, err := NewInfoHeader(bytes.Repeat([]byte{0xaa}, FixedInfoHeaderLength))
	if err == nil {
		t.Errorf("Expected error, got nil")
	}
}

func TestNewInfoHeaderNonZeroReserved1(t *testing.T) {
	_, err := NewInfoHeader(append(Signature[:], bytes.Repeat([]byte{0xaa}, FixedInfoHeaderLength)...))
	if err == nil {
		t.Errorf("Expected error, got nil")
	}
}

```

`pkg/guid/guid.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package guid implements the mixed-endian GUID as implemented by Microsoft.
package guid

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/linuxboot/fiano/pkg/log"
)

const (
	// Size represents number of bytes in a GUID
	Size = 16
	// UExample is a example of a string GUID
	UExample  = "01234567-89AB-CDEF-0123-456789ABCDEF"
	strFormat = "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X"
)

var (
	fields = [...]int{4, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1}
)

// GUID represents a unique identifier.
type GUID [Size]byte

func reverse(b []byte) {
	for i := 0; i < len(b)/2; i++ {
		other := len(b) - i - 1
		b[other], b[i] = b[i], b[other]
	}
}

// Parse parses a guid string.
func Parse(s string) (*GUID, error) {
	// remove all hyphens to make it easier to parse.
	stripped := strings.Replace(s, "-", "", -1)
	decoded, err := hex.DecodeString(stripped)
	if err != nil {
		return nil, fmt.Errorf("guid string not correct, need string of the format \n%v\n, got \n%v",
			UExample, s)
	}

	if len(decoded) != Size {
		return nil, fmt.Errorf("guid string has incorrect length, need string of the format \n%v\n, got \n%v",
			UExample, s)
	}

	u := GUID{}
	i := 0
	copy(u[:], decoded[:])
	// Correct for endianness.
	for _, fieldlen := range fields {
		reverse(u[i : i+fieldlen])
		i += fieldlen
	}
	return &u, nil
}

// MustParse parses a guid string or panics.
func MustParse(s string) *GUID {
	guid, err := Parse(s)
	if err != nil {
		log.Fatalf("%v", err)
	}
	return guid
}

func (u GUID) String() string {
	// Not a pointer receiver so we don't have to manually copy.
	i := 0
	// reverse endianness.
	for _, fieldlen := range fields {
		reverse(u[i : i+fieldlen])
		i += fieldlen
	}
	// Convert to []interface{} for easy printing.
	b := make([]interface{}, Size)
	for i := range u[:] {
		b[i] = u[i]
	}
	return fmt.Sprintf(strFormat, b...)
}

// MarshalJSON implements the marshaller interface.
// This allows us to actually read and edit the json file
func (u *GUID) MarshalJSON() ([]byte, error) {
	return []byte(`{"GUID" : "` + u.String() + `"}`), nil
}

// UnmarshalJSON implements the unmarshaller interface.
// This allows us to actually read and edit the json file
func (u *GUID) UnmarshalJSON(b []byte) error {
	j := make(map[string]string)

	if err := json.Unmarshal(b, &j); err != nil {
		return err
	}
	g, err := Parse(j["GUID"])
	if err != nil {
		return err
	}
	copy(u[:], g[:])
	return nil
}

```

`pkg/guid/guid_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package guid

import (
	"fmt"
	"testing"
)

var (
	// GUID examples
	exampleGUID GUID = [16]byte{0x67, 0x45, 0x23, 0x01, 0xAB, 0x89, 0xEF, 0xCD,
		0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF}
	// GUID string examples
	exampleGUIDString   = "01234567-89AB-CDEF-0123-456789ABCDEF"
	shortGUIDString     = "0123456789ABCDEF0123456789ABCDEF"
	badGUIDStringLength = "01234567"
	badHex              = "GHGHGHGHGHGHGH"

	// GUID JSON examples
	exampleJSON       = `{"GUID" : "` + exampleGUIDString + `"}`
	exampleJSONBadHex = `{"GUID" : "` + badHex + `"}`
	exampleJSONBadKey = `{"UU" : "` + exampleGUIDString + `"}`
)

func TestParse(t *testing.T) {
	var tests = []struct {
		s   string
		u   *GUID
		msg string
	}{
		{exampleGUIDString, &exampleGUID, ""},
		{shortGUIDString, &exampleGUID, ""},
		{badGUIDStringLength, nil, fmt.Sprintf("guid string has incorrect length, need string of the format \n%v\n, got \n%v",
			UExample, badGUIDStringLength)},
		{badHex, nil, fmt.Sprintf("guid string not correct, need string of the format \n%v\n, got \n%v",
			UExample, badHex)},
	}
	for _, test := range tests {
		u, err := Parse(test.s)
		if u == nil {
			if test.u != nil {
				t.Errorf("GUID was expected: %v, got nil", test.u)
			}
			if err == nil {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
		} else if *u != *test.u {
			t.Errorf("GUID was parsed incorrectly, expected %v\n, got %v\n, string was %v", test.u, u, test.s)
		}
	}
}

func TestMarshal(t *testing.T) {
	var tests = []struct {
		j string
		u *GUID
	}{
		{exampleJSON, &exampleGUID},
	}
	for _, test := range tests {
		j, err := test.u.MarshalJSON()
		if err != nil {
			t.Errorf("No error was expected, got %v", err)
		}
		if test.j != string(j) {
			t.Errorf("JSON strings are not equal. Expected:\n%v\ngot:\n%v", test.j, string(j))
		}
	}
}

func TestUnmarshal(t *testing.T) {
	var tests = []struct {
		j   string
		u   *GUID
		msg string
	}{
		{exampleJSON, &exampleGUID, ""},
		{exampleJSONBadHex, nil, fmt.Sprintf("guid string not correct, need string of the format \n%v\n, got \n%v",
			UExample, badHex)},
		{exampleJSONBadKey, nil, fmt.Sprintf("guid string has incorrect length, need string of the format \n%v\n, got \n%v",
			UExample, "")},
	}
	for _, test := range tests {
		var g GUID
		err := g.UnmarshalJSON([]byte(test.j))
		if test.msg == "" && err != nil {
			t.Errorf("No error was expected, got %v", err)
		}
		if test.msg != "" && err == nil {
			t.Errorf("Error was expected: %v, got nil", test.msg)
		}
		if err != nil && err.Error() != test.msg {
			t.Errorf("Got Error msg %v, was expecting %v", err.Error(), test.msg)
		}
		if test.u != nil && *test.u != g {
			t.Errorf("GUIDs are not equal. Expected:\n%v\ngot:\n%v", test.u, g)
		}
	}
}

```

`pkg/guid2english/transformer.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package guid2english provides a transform.Transformer which replaces all
// GUIDs in the input with their known English representation.
package guid2english

import (
	"bytes"
	"regexp"
	"text/template"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/knownguids"
	"github.com/linuxboot/fiano/pkg/log"
	"golang.org/x/text/transform"
)

var guidRegex = regexp.MustCompile(
	"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
)

var partialguidRegex = regexp.MustCompile(
	"[-a-fA-F0-9]{1,36}$",
)

// Mapper converts a GUID to a string.
type Mapper interface {
	Map(guid.GUID) []byte
}

// TemplateMapper implements mapper using Go's text/template package. The
// template can refer to the following variables:
//   - {{.Guid}}: The GUID being mapped
//   - {{.Name}}: The English name of the GUID or "UNKNOWN"
//   - {{.IsKnown}}: Set to true when the English name is not known
type TemplateMapper struct {
	tmpl *template.Template
}

// NewTemplateMapper creates a new TemplateMapper given a Template.
func NewTemplateMapper(tmpl *template.Template) *TemplateMapper {
	return &TemplateMapper{
		tmpl: tmpl,
	}
}

// Map implements the Mapper.Map() function.
func (f *TemplateMapper) Map(g guid.GUID) []byte {
	name, isKnown := knownguids.GUIDs[g]
	if !isKnown {
		name = "UNKNOWN"
	}

	b := &bytes.Buffer{}
	err := f.tmpl.Execute(b, struct {
		GUID    guid.GUID
		Name    string
		IsKnown bool
	}{
		GUID:    g,
		Name:    name,
		IsKnown: isKnown,
	})
	if err != nil {
		// There is likely a bug in the template. We do not want to
		// interrupt the byte stream, so just log the error.
		log.Errorf("Error in template: %v", err)
	}
	return b.Bytes()
}

// Transformer replaces all the GUIDs using the Mapper interface. For example,
// this can replace all the GUIDs with their's English representation.
type Transformer struct {
	mapper Mapper
}

// New creates a new Transformer with the given Mapper.
func New(m Mapper) *Transformer {
	return &Transformer{
		mapper: m,
	}
}

func (t *Transformer) bufferMap(match []byte) []byte {
	// The regex only matches valid GUIDs, so this must parse.
	g, err := guid.Parse(string(match))
	if err != nil {
		return match
	}
	return t.mapper.Map(*g)
}

// Transform implements transform.Transformer.Transform().
func (t *Transformer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
	if atEOF {
		// we have the end of file, try to process all at once
		transformed := guidRegex.ReplaceAllFunc(src, t.bufferMap)
		if len(transformed) > len(dst) {
			// we were too optimistic, dst is too short
			d, s, e := t.Transform(dst, src, false)
			if e != transform.ErrShortSrc {
				return d, s, e
			}
			return d, s, transform.ErrShortDst
		}
		copy(dst, transformed)
		return len(transformed), len(src), nil
	}
	loc := guidRegex.FindIndex(src)
	if loc == nil {
		// check if the end potentially contain the beginning of a GUID
		loc := partialguidRegex.FindIndex(src)
		if loc == nil {
			copy(dst, src)
			return len(src), len(src), nil
		}
		copy(dst, src[0:loc[0]])
		return loc[0], loc[0], transform.ErrShortSrc
	}
	copy(dst, src[0:loc[0]])
	mappedGUID := t.bufferMap(src[loc[0]:loc[1]])
	if loc[0]+len(mappedGUID) > len(dst) {
		// mapped buffer does not fit, only send the plain part
		return loc[0], loc[0], transform.ErrShortDst
	}

	copy(dst[loc[0]:], mappedGUID)
	return loc[0] + len(mappedGUID), loc[1], transform.ErrShortSrc
}

// Reset implements transform.Transformer.Reset().
func (t *Transformer) Reset() {
}

```

`pkg/guid2english/transformer_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package guid2english

import (
	"bytes"
	"io"
	"strings"
	"testing"
	"text/template"

	"golang.org/x/text/transform"
)

func TestTransformer(t *testing.T) {
	// transform.NewReader internally build 4096 long buffers so
	// prepare a string almost that long to trigger boundary checks
	long4080String := strings.Repeat("ghijklmnopqrstuvwxyz", 204)

	tests := []struct {
		name   string
		input  string
		tmpl   string
		output string
	}{
		{
			name:   "empty",
			input:  "",
			tmpl:   "",
			output: "",
		},
		{
			name:   "single GUID",
			input:  "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}}",
			output: "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
		},
		{
			name:   "replace with name",
			input:  "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.Name}}",
			output: "Shell",
		},
		{
			name:   "name and GUID",
			input:  "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)",
		},
		{
			name:   "unknown name and GUID",
			input:  "fff4A583-9E3E-4F1C-BD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: "FFF4A583-9E3E-4F1C-BD65-E05268D0B4D1 (UNKNOWN)",
		},
		{
			name:   "advanced formatting",
			input:  "fff4A583-9E3E-4F1C-BD65-E05268D0B4D1",
			tmpl:   "{{if .IsKnown}}KNOWN{{else}}UNKNOWN{{end}}",
			output: "UNKNOWN",
		},
		{
			name: "multiple GUIDs",
			input: `
Running 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1...
Cannot find fff4A583-9E3E-4F1C-BD65-E05268D0B4D1...
Waiting for D5125E0F-1226-444F-A218-0085996ED5DA?
			`,
			tmpl: "{{.GUID}} ({{.Name}})",
			output: `
Running 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)...
Cannot find FFF4A583-9E3E-4F1C-BD65-E05268D0B4D1 (UNKNOWN)...
Waiting for D5125E0F-1226-444F-A218-0085996ED5DA (Smbus)?
			`,
		},
		{
			name:   "handle ErrShortDst",
			input:  strings.Repeat("7C04A583-9E3E-4F1C-AD65-E05268D0B4D1", 112),
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: strings.Repeat("7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)", 112),
		},
		{
			name:   "long buffer with GUID cut by 4096 boundary",
			input:  long4080String + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: long4080String + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)",
		},
		{
			name:   "very long buffer",
			input:  long4080String + long4080String + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: long4080String + long4080String + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)",
		},
		{
			name:   "4096 buffer with GUID at end",
			input:  long4080String[:4096-36] + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} ({{.Name}})",
			output: long4080String[:4096-36] + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)",
		},
		{
			name:   "4096 buffer with GUID at start and end, long template",
			input:  "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1" + long4080String[:4096-36-36] + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1",
			tmpl:   "{{.GUID}} {{.GUID}} ({{.Name}})",
			output: "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)" + long4080String[:4096-36-36] + "7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 7C04A583-9E3E-4F1C-AD65-E05268D0B4D1 (Shell)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			input := bytes.NewBufferString(tt.input)
			tmpl, err := template.New("guid2english").Parse(tt.tmpl)
			if err != nil {
				t.Fatalf("template not valid: %v", err)
			}

			trans := New(NewTemplateMapper(tmpl))

			output := &bytes.Buffer{}
			_, err = io.Copy(output, transform.NewReader(input, trans))
			if err != nil {
				t.Errorf("error copying buffer: %v", err)
			}

			if output.String() != tt.output {
				t.Errorf("got %q, want %q", output.Bytes(), tt.output)
			}
		})
	}
}

```

`pkg/intel/me/me.go`:

```go
// Copyright 2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package me

import (
	"bytes"
	"encoding/binary"
	"io"
)

var (
	Signature = [4]byte{0x24, 0x46, 0x50, 0x54}
)

func parseLegacyFlashPartitionTableHeader(r io.Reader) (*LegacyFlashPartitionTableHeader, error) {
	var header LegacyFlashPartitionTableHeader
	var scrap [12]byte
	if err := binary.Read(r, binary.LittleEndian, &scrap); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.Marker); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.NumFptEntries); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderVersion); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.EntryVersion); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderLength); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderChecksum); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.TicksToAdd); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.TokensToAdd); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.UMASize); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.Flags); err != nil {
		return nil, err
	}
	return &header, nil

}

func parseFlashPartitionTableHeader(r io.Reader) (*FlashPartitionTableHeader, error) {
	var header FlashPartitionTableHeader
	// Set Signature
	header.Marker = Signature

	if err := binary.Read(r, binary.LittleEndian, &header.NumFptEntries); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderVersion); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.EntryVersion); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderLength); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.HeaderChecksum); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.TicksToAdd); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.TokensToAdd); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.UMASizeOrReserved); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.FlashLayoutOrFlags); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.FitcMajor); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.FitcMinor); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.FitcHotfix); err != nil {
		return nil, err
	}
	if err := binary.Read(r, binary.LittleEndian, &header.FitcBuild); err != nil {
		return nil, err
	}

	return &header, nil
}

func parseEntry(r io.Reader) (*FlashPartitionTableEntry, error) {
	var entry FlashPartitionTableEntry
	if err := binary.Read(r, binary.LittleEndian, &entry); err != nil {
		return nil, err
	}
	return &entry, nil
}

// ParseIntelFirmware parses the Intel firmware image by uefi.Firmware interface`
func ParseIntelME(r io.Reader) (*IntelME, error) {
	var me IntelME
	me.legacy = false
	var numEntries uint32

	// Read first 4 byte, we catch the marker as prefix or suffix
	var markerarea [4]byte
	if err := binary.Read(r, binary.LittleEndian, &markerarea); err != nil {
		return nil, err
	}

	// Check on new header
	if bytes.HasPrefix(markerarea[:], Signature[:]) {
		hdr, err := parseFlashPartitionTableHeader(r)
		if err != nil {
			return nil, err
		}
		me.hdr = hdr
		numEntries = hdr.NumFptEntries
	} else {
		me.legacy = true
		hdr, err := parseLegacyFlashPartitionTableHeader(r)
		if err != nil {
			return nil, err
		}
		me.legacyhdr = hdr
		numEntries = hdr.NumFptEntries
	}

	partitions := make([]FlashPartitionTableEntry, 0)
	for i := uint32(0); i < numEntries; i++ {
		entry, err := parseEntry(r)
		if err != nil {
			return nil, err
		}
		partitions = append(partitions, *entry)
	}
	me.partitions = partitions
	return &me, nil
}

```

`pkg/intel/me/me_test.go`:

```go
// Copyright 2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package me

import (
	"bytes"
	"errors"
	"fmt"
	"testing"
)

var (
	validLegacyHeaderPadding = []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	validME = []byte{
		0x24, 0x46, 0x50, 0x54, 0x02, 0x00, 0x00, 0x00,
		0x20, 0x01, 0x20, 0x30, 0x00, 0x01, 0x01, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// first entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// second entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
	invalidMEEntryNumber = []byte{
		0x24, 0x46, 0x50, 0x54, 0x07, 0x00, 0x00, 0x00,
		0x20, 0x01, 0x20, 0x30, 0x00, 0x01, 0x01, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// first entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// second entry
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}
)

func TestParseIntelME(t *testing.T) {
	for _, tt := range []struct {
		name    string
		data    []byte
		wantErr error
	}{
		{
			name: "Test Lagacy ME",
			data: append(validLegacyHeaderPadding, validME...),
		},
		{
			name: "Test ME",
			data: validME,
		},
		{
			name:    "Invalid Entry number",
			data:    invalidMEEntryNumber,
			wantErr: errors.New("EOF"),
		},
	} {
		t.Run(tt.name, func(t *testing.T) {
			_, gotErr := ParseIntelME(bytes.NewReader(tt.data))
			if gotErrorString, wantErrorString := fmt.Sprint(gotErr), fmt.Sprint(tt.wantErr); gotErrorString != wantErrorString {
				t.Errorf("ParseIntelME() got err %q; want err %q",
					gotErrorString,
					wantErrorString)
			}
		})
	}
}

```

`pkg/intel/me/structures.go`:

```go
// Copyright 2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package me

import (
	"fmt"
	"strings"
)

// LegacyFlashPartitionTableHeader describes the old flash partition table header
// in Intel ME binaries.
type LegacyFlashPartitionTableHeader struct {
	Padding        [16]byte // 16 zeros
	Marker         [4]byte  // Always $FPT
	NumFptEntries  uint32
	HeaderVersion  uint8
	EntryVersion   uint8
	HeaderLength   uint8 // Usually 0x30
	HeaderChecksum uint8
	TicksToAdd     uint16
	TokensToAdd    uint16
	UMASize        uint32
	Flags          uint32
}

func (h LegacyFlashPartitionTableHeader) String() string {
	var b strings.Builder
	b.WriteString("Flash partition table:\n")
	fmt.Fprintf(&b, " Entries       : %d\n", h.NumFptEntries)
	fmt.Fprintf(&b, " HeaderVersion : 0x%x\n", h.HeaderVersion)
	fmt.Fprintf(&b, " EntryVersion  : 0x%x\n", h.EntryVersion)
	fmt.Fprintf(&b, " HeaderLength  : 0x%x\n", h.HeaderLength)
	fmt.Fprintf(&b, " HeaderChecksum: 0x%x\n", h.HeaderChecksum)
	fmt.Fprintf(&b, " TicksToAdd    : 0x%x\n", h.TicksToAdd)
	fmt.Fprintf(&b, " TokensToAdd   : 0x%x\n", h.TokensToAdd)
	fmt.Fprintf(&b, " UMASize       : 0x%x\n", h.UMASize)
	fmt.Fprintf(&b, " Flags         : 0x%x\n", h.Flags)

	return b.String()
}

// FlashPartitionTableHeader describes the new flash partition table header
// in Intel ME binaries.
type FlashPartitionTableHeader struct {
	Marker             [4]byte // Always $FPT
	NumFptEntries      uint32
	HeaderVersion      uint8 // Only support 2.0
	EntryVersion       uint8
	HeaderLength       uint8 // Usually 0x20
	HeaderChecksum     uint8
	TicksToAdd         uint16
	TokensToAdd        uint16
	UMASizeOrReserved  uint32
	FlashLayoutOrFlags uint32
	// Not Present in ME version 7
	FitcMajor  uint16
	FitcMinor  uint16
	FitcHotfix uint16
	FitcBuild  uint16
}

func (h FlashPartitionTableHeader) String() string {
	var b strings.Builder

	b.WriteString("Flash partition table:\n")
	fmt.Fprintf(&b, " Entries            : %d\n", h.NumFptEntries)
	fmt.Fprintf(&b, " HeaderVersion      : 0x%x\n", h.HeaderVersion)
	fmt.Fprintf(&b, " EntryVersion       : 0x%x\n", h.EntryVersion)
	fmt.Fprintf(&b, " HeaderLength       : 0x%x\n", h.HeaderLength)
	fmt.Fprintf(&b, " HeaderChecksum     : 0x%x\n", h.HeaderChecksum)
	fmt.Fprintf(&b, " TicksToAdd         : 0x%x\n", h.TicksToAdd)
	fmt.Fprintf(&b, " TokensToAdd        : 0x%x\n", h.TokensToAdd)
	fmt.Fprintf(&b, " UMASizeOrReserved  : 0x%x\n", h.UMASizeOrReserved)
	fmt.Fprintf(&b, " FlashLayoutOrFlags : 0x%x\n", h.FlashLayoutOrFlags)
	fmt.Fprintf(&b, " Fitc Version       : %d.%d.%d.%d\n", h.FitcMajor, h.FitcMinor, h.FitcHotfix, h.FitcBuild)

	return b.String()
}

type name [4]byte

func (n *name) String() string {
	return string(n[:])
}

// FlashPartitionTableEntry describes information of a flash partition table entry.
type FlashPartitionTableEntry struct {
	Name           name
	Owner          name
	Offset         uint32
	Length         uint32
	StartTokens    uint32
	MaxTokens      uint32
	ScratchSectors uint32
	Flags          uint32
}

func (e FlashPartitionTableEntry) String() string {
	var b strings.Builder
	b.WriteString("Flash partition entry:\n")
	fmt.Fprintf(&b, " Name          : %s\n", e.Name.String())
	fmt.Fprintf(&b, " Owner         : %s\n", e.Owner.String())
	fmt.Fprintf(&b, " Offset        : 0x%x\n", e.Offset)
	fmt.Fprintf(&b, " Length        : 0x%x\n", e.Length)
	fmt.Fprintf(&b, " StartTokens   : 0x%x\n", e.StartTokens)
	fmt.Fprintf(&b, " MaxTokens     : 0x%x\n", e.MaxTokens)
	fmt.Fprintf(&b, " ScratchSectors: 0x%x\n", e.ScratchSectors)
	fmt.Fprintf(&b, " Flags         : 0x%x\n", e.Flags)

	if e.Flags>>24 == 0xff {
		b.WriteString(" Valid         : No\n")
	} else {
		b.WriteString(" Valid         : yes\n")
	}
	if e.Flags&1 > 0 {
		b.WriteString(" Partition     : Data\n")
	} else {
		b.WriteString(" Partition     : Code\n")
	}

	return b.String()
}

// IntelME abstracts the ME/CSME/SPS firmware found on intel platforms
type IntelME struct {
	hdr        *FlashPartitionTableHeader
	legacyhdr  *LegacyFlashPartitionTableHeader
	legacy     bool
	partitions []FlashPartitionTableEntry
}

```

`pkg/intel/metadata/README.md`:

```md
Prequesites:
Open another terminal and go get the sm2/sm3 crypto library into your gopath.
The code generator disables go modules.
```
GOPATH=your/go/path go get github.com/tjfoc/gmsm/sm2
```

To generalize all the logic related to Boot Policy Manifest and Key Manifest
we use code generation. Therefore it is enough to create structure declarations
and run command from this directory:
```
go run ./../common/manifestcodegen/cmd/manifestcodegen/ . ./bootpolicy ./key
```

It will performe the code autogeneration in directories:
* Current directory (`.`), which contains common structures for different manifests;
* Boot Policy Manifest directory (`./bootpolicy`);
* and Key Manifest directory (`./key`).

To check if the files are in the up-to-date state, one may add option `-check`:
```
go run ./../common/manifestcodegen/cmd/manifestcodegen/ -check . ./bootpolicy ./key
```

Or if it is required to debug/trace the behavior of autogenerated code, one
may add option `-trace`:
```
go run ./../common/manifestcodegen/cmd/manifestcodegen/ -trace . ./bootpolicy ./key
```

In this case the code will write a verbose log into stdout.

If you need to edit the template, please edit file: `./common/manifestcodegen/cmd/manifestcodegen/template_methods.tpl.go`.

# Field tags

There are few special struct field tags which are recognized by the code
generator:
* `id` -- defines the element Structure ID string (for example `__TXTS__`).
* `version` -- defines the value of `StructVersion` (see document #575623).
* `countType` -- used only for slices and it defines which variable type is
  used to store amount of items of the slice. Arrays in a structure in a Manifest
  is almost always prepended with a count variable, and we automatically map
  it to the real amount of elements of our slice. And to do that we need to know
  the bitsize of the counter, therefore this tag exists.
* `countValue` -- (see also `countType`) sometimes a counter requires special
  transformations before it could be maped into the real amount of elements
  of a slice. `countValue` allows to define a function to calculate the
  real count value.
* `require` -- defines the value required by the document #575623.
* `default` -- defines the default value.
* `prettyValue` -- defines the function which prints the value in a pretty format.
* `rehashValue` -- is used to receive an auto-updated value, for example it could
  be handy to automatically update size-fields.

See also:
```
grep -RIn field.TagGet ./
```
```

`pkg/intel/metadata/bg/bgbootpolicy/bpmh.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgbootpolicy

import "github.com/linuxboot/fiano/pkg/intel/metadata/bg"

type BPMH struct {
	StructInfo `id:"__ACBP__" version:"0x10"`

	HdrStructVersion uint8 `json:"HdrStructVersion"`

	PMBPMVersion uint8 `json:"bpmhRevision"`

	// PrettyString: BPM SVN
	BPMSVN bg.SVN `json:"bpmhSNV"`
	// PrettyString: ACM SVN Auth
	ACMSVNAuth bg.SVN `json:"bpmhACMSVN"`

	Reserved0 [1]byte `require:"0" json:"bpmhReserved0,omitempty"`

	NEMDataStack Size4K `json:"bpmhNEMStackSize"`
}

// Size4K is a size in units of 4096 bytes.
type Size4K uint16

// InBytes returns the size in bytes.
func (s Size4K) InBytes() uint32 {
	return uint32(s) * 4096
}

// NewSize4K returns the given size as multiple of 4K
func NewSize4K(size uint32) Size4K {
	return Size4K(size / 4096)
}

```

`pkg/intel/metadata/bg/bgbootpolicy/bpmh_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy

package bgbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewBPMH returns a new instance of BPMH with
// all default values set.
func NewBPMH() *BPMH {
	s := &BPMH{}
	copy(s.StructInfo.ID[:], []byte(StructureIDBPMH))
	s.StructInfo.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *BPMH) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}

	return nil
}

// StructureIDBPMH is the StructureID (in terms of
// the document #575623) of element 'BPMH'.
const StructureIDBPMH = "__ACBP__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *BPMH) GetStructInfo() bg.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *BPMH) SetStructInfo(newStructInfo bg.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the BPMH from 'r' in format defined in the document #575623.
func (s *BPMH) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the BPMH from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *BPMH) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// HdrStructVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.HdrStructVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HdrStructVersion': %w", err)
		}
		totalN += int64(n)
	}

	// PMBPMVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.PMBPMVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PMBPMVersion': %w", err)
		}
		totalN += int64(n)
	}

	// BPMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.BPMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'BPMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// ACMSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.ACMSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ACMSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// NEMDataStack (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.NEMDataStack)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'NEMDataStack': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *BPMH) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *BPMH) Rehash() {
}

// WriteTo writes the BPMH into 'w' in format defined in
// the document #575623.
func (s *BPMH) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// HdrStructVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.HdrStructVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HdrStructVersion': %w", err)
		}
		totalN += int64(n)
	}

	// PMBPMVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.PMBPMVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PMBPMVersion': %w", err)
		}
		totalN += int64(n)
	}

	// BPMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.BPMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// ACMSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.ACMSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ACMSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// NEMDataStack (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.NEMDataStack)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'NEMDataStack': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *BPMH) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// HdrStructVersionSize returns the size in bytes of the value of field HdrStructVersion
func (s *BPMH) HdrStructVersionTotalSize() uint64 {
	return 1
}

// PMBPMVersionSize returns the size in bytes of the value of field PMBPMVersion
func (s *BPMH) PMBPMVersionTotalSize() uint64 {
	return 1
}

// BPMSVNSize returns the size in bytes of the value of field BPMSVN
func (s *BPMH) BPMSVNTotalSize() uint64 {
	return 1
}

// ACMSVNAuthSize returns the size in bytes of the value of field ACMSVNAuth
func (s *BPMH) ACMSVNAuthTotalSize() uint64 {
	return 1
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *BPMH) Reserved0TotalSize() uint64 {
	return 1
}

// NEMDataStackSize returns the size in bytes of the value of field NEMDataStack
func (s *BPMH) NEMDataStackTotalSize() uint64 {
	return 2
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *BPMH) StructInfoOffset() uint64 {
	return 0
}

// HdrStructVersionOffset returns the offset in bytes of field HdrStructVersion
func (s *BPMH) HdrStructVersionOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// PMBPMVersionOffset returns the offset in bytes of field PMBPMVersion
func (s *BPMH) PMBPMVersionOffset() uint64 {
	return s.HdrStructVersionOffset() + s.HdrStructVersionTotalSize()
}

// BPMSVNOffset returns the offset in bytes of field BPMSVN
func (s *BPMH) BPMSVNOffset() uint64 {
	return s.PMBPMVersionOffset() + s.PMBPMVersionTotalSize()
}

// ACMSVNAuthOffset returns the offset in bytes of field ACMSVNAuth
func (s *BPMH) ACMSVNAuthOffset() uint64 {
	return s.BPMSVNOffset() + s.BPMSVNTotalSize()
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *BPMH) Reserved0Offset() uint64 {
	return s.ACMSVNAuthOffset() + s.ACMSVNAuthTotalSize()
}

// NEMDataStackOffset returns the offset in bytes of field NEMDataStack
func (s *BPMH) NEMDataStackOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// Size returns the total size of the BPMH.
func (s *BPMH) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.HdrStructVersionTotalSize()
	size += s.PMBPMVersionTotalSize()
	size += s.BPMSVNTotalSize()
	size += s.ACMSVNAuthTotalSize()
	size += s.Reserved0TotalSize()
	size += s.NEMDataStackTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *BPMH) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "BPMH", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hdr Struct Version", "", &s.HdrStructVersion, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "PMBPM Version", "", &s.PMBPMVersion, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "BPM SVN", "", &s.BPMSVN, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "ACM SVN Auth", "", &s.ACMSVNAuth, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "NEM Data Stack", "", &s.NEMDataStack, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Size4K) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Size 4 K", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "In Bytes", "", v.InBytes(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v Size4K) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Size4K into 'w' in binary format.
func (v Size4K) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Size4K from 'r' in binary format.
func (v Size4K) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/bg/bgbootpolicy/manifest.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgbootpolicy

import (
	"bytes"
	"fmt"

	pkgbytes "github.com/linuxboot/fiano/pkg/bytes"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// StructInfo is the common header of any element.
type StructInfo = bg.StructInfo

// PrettyString: Boot Policy Manifest
type Manifest struct {
	// PrettyString: BPMH: Header
	BPMH `rehashValue:"rehashedBPMH()" json:"bpmHeader"`
	// PrettyString: SE: Header
	SE []SE `json:"bpmSE"`
	// PrettyString: PME: Platform Manufacturer
	PME *PM `json:"bpmPME,omitempty"`
	// PrettyString: PMSE: Signature
	PMSE Signature `json:"bpmSignature"`
}

// StructInfo is the information about how to parse the structure.
func (bpm Manifest) StructInfo() StructInfo {
	return bpm.BPMH.StructInfo
}

// ValidateIBB returns an error if IBB segments does not match the signature
func (bpm *Manifest) ValidateIBB(firmware uefi.Firmware) error {
	if bpm.SE[0].Digest.TotalSize() == 0 {
		return fmt.Errorf("no IBB hashes")
	}

	digest := bpm.SE[0].Digest

	h, err := digest.HashAlg.Hash()
	if err != nil {
		return fmt.Errorf("invalid hash function: %v", digest.HashAlg)
	}

	for _, _range := range bpm.IBBDataRanges(uint64(len(firmware.Buf()))) {
		if _, err := h.Write(firmware.Buf()[_range.Offset:_range.End()]); err != nil {
			return fmt.Errorf("unable to hash: %w", err)
		}
	}
	hashValue := h.Sum(nil)

	if !bytes.Equal(hashValue, digest.HashBuffer) {
		return fmt.Errorf("IBB %s hash mismatch: %X != %X", digest.HashAlg, hashValue, digest.HashBuffer)
	}

	return nil
}

// IBBDataRanges returns data ranges of IBB.
func (bpm *Manifest) IBBDataRanges(firmwareSize uint64) pkgbytes.Ranges {
	var result pkgbytes.Ranges

	for _, seg := range bpm.SE[0].IBBSegments {
		if seg.Flags&1 == 1 {
			continue
		}
		startIdx := calculateOffsetFromPhysAddr(uint64(seg.Base), firmwareSize)
		result = append(result, pkgbytes.Range{Offset: startIdx, Length: uint64(seg.Size)})
	}

	return result
}

// calculateOffsetFromPhysAddr calculates the offset within an image
// of the physical address (address to a region mapped from
// the SPI chip).
//
// Examples:
//
//	calculateOffsetFromPhysAddr(0xffffffff, 0x1000) == 0xfff
//	calculateOffsetFromPhysAddr(0xffffffc0, 0x1000) == 0xfc0
func calculateOffsetFromPhysAddr(physAddr uint64, imageSize uint64) uint64 {
	const basePhysAddr = 1 << 32 // "4GiB"
	startAddr := basePhysAddr - imageSize
	return physAddr - startAddr
}

```

`pkg/intel/metadata/bg/bgbootpolicy/manifest_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy

package bgbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewManifest returns a new instance of Manifest with
// all default values set.
func NewManifest() *Manifest {
	s := &Manifest{}
	// Recursively initializing a child structure:
	s.BPMH = *NewBPMH()
	// Recursively initializing a child structure:
	s.PMSE = *NewSignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Manifest) Validate() error {
	// Recursively validating a child structure:
	if err := s.BPMH.Validate(); err != nil {
		return fmt.Errorf("error on field 'BPMH': %w", err)
	}
	// See tag "rehashValue"
	{
		expectedValue := BPMH(s.rehashedBPMH())
		if s.BPMH != expectedValue {
			return fmt.Errorf("field 'BPMH' expects write-value '%v', but has %v", expectedValue, s.BPMH)
		}
	}
	// Recursively validating a child structure:
	if err := s.PMSE.Validate(); err != nil {
		return fmt.Errorf("error on field 'PMSE': %w", err)
	}

	return nil
}

// fieldIndexByStructID returns the position index within
// structure Manifest of the field by its StructureID
// (see document #575623, an example of StructureID value is "__KEYM__").
func (_ Manifest) fieldIndexByStructID(structID string) int {
	switch structID {
	case StructureIDBPMH:
		return 0
	case StructureIDSE:
		return 1
	case StructureIDPM:
		return 2
	case StructureIDSignature:
		return 3
	}

	return -1
}

// fieldNameByIndex returns the name of the field by its position number
// within structure Manifest.
func (_ Manifest) fieldNameByIndex(fieldIndex int) string {
	switch fieldIndex {
	case 0:
		return "BPMH"
	case 1:
		return "SE"
	case 2:
		return "PME"
	case 3:
		return "PMSE"
	}

	return fmt.Sprintf("invalidFieldIndex_%d", fieldIndex)
}

// ReadFrom reads the Manifest from 'r' in format defined in the document #575623.
func (s *Manifest) ReadFrom(r io.Reader) (returnN int64, returnErr error) {
	var missingFieldsByIndices = [4]bool{
		0: true,
		3: true,
	}
	defer func() {
		if returnErr != nil {
			return
		}
		for fieldIndex, v := range missingFieldsByIndices {
			if v {
				returnErr = fmt.Errorf("field '%s' is missing", s.fieldNameByIndex(fieldIndex))
				break
			}
		}
	}()
	var totalN int64
	previousFieldIndex := int(-1)
	for {
		var structInfo bg.StructInfo
		err := binary.Read(r, binary.LittleEndian, &structInfo)
		if err == io.EOF || err == io.ErrUnexpectedEOF {
			return totalN, nil
		}
		if err != nil {
			return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
		}
		totalN += int64(binary.Size(structInfo))

		structID := structInfo.ID.String()
		fieldIndex := s.fieldIndexByStructID(structID)
		if fieldIndex < 0 {
			// TODO: report error "unknown structure ID: '"+structID+"'"
			continue
		}
		if bg.StrictOrderCheck && fieldIndex < previousFieldIndex {
			return totalN, fmt.Errorf("invalid order of fields (%d < %d): structure '%s' is out of order", fieldIndex, previousFieldIndex, structID)
		}
		missingFieldsByIndices[fieldIndex] = false

		var n int64
		switch structID {
		case StructureIDBPMH:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'BPMH' is not a slice, but multiple elements found")
			}
			s.BPMH.SetStructInfo(structInfo)
			n, err = s.BPMH.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field BPMH at %d: %w", totalN, err)
			}
		case StructureIDSE:
			var el SE
			el.SetStructInfo(structInfo)
			n, err = el.ReadDataFrom(r)
			s.SE = append(s.SE, el)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field SE at %d: %w", totalN, err)
			}
		case StructureIDPM:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'PME' is not a slice, but multiple elements found")
			}
			s.PME = &PM{}
			s.PME.SetStructInfo(structInfo)
			n, err = s.PME.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field PME at %d: %w", totalN, err)
			}
		case StructureIDSignature:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'PMSE' is not a slice, but multiple elements found")
			}
			s.PMSE.SetStructInfo(structInfo)
			n, err = s.PMSE.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field PMSE at %d: %w", totalN, err)
			}
		default:
			return totalN, fmt.Errorf("there is no field with structure ID '%s' in Manifest", structInfo.ID)
		}
		totalN += n
		previousFieldIndex = fieldIndex
	}
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Manifest) RehashRecursive() {
	s.BPMH.Rehash()
	if s.PME != nil {
		s.PME.Rehash()
	}
	s.PMSE.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Manifest) Rehash() {
	s.BPMH = BPMH(s.rehashedBPMH())
}

// WriteTo writes the Manifest into 'w' in format defined in
// the document #575623.
func (s *Manifest) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// BPMH (ManifestFieldType: element)
	{
		n, err := s.BPMH.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPMH': %w", err)
		}
		totalN += int64(n)
	}

	// SE (ManifestFieldType: elementList)
	{
		for idx := range s.SE {
			n, err := s.SE[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'SE[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	// PME (ManifestFieldType: element)
	if s.PME != nil {
		n, err := s.PME.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PME': %w", err)
		}
		totalN += int64(n)
	}

	// PMSE (ManifestFieldType: element)
	{
		n, err := s.PMSE.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PMSE': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// BPMHSize returns the size in bytes of the value of field BPMH
func (s *Manifest) BPMHTotalSize() uint64 {
	return s.BPMH.TotalSize()
}

// SESize returns the size in bytes of the value of field SE
func (s *Manifest) SETotalSize() uint64 {
	var size uint64
	for idx := range s.SE {
		size += s.SE[idx].TotalSize()
	}
	return size
}

// PMESize returns the size in bytes of the value of field PME
func (s *Manifest) PMETotalSize() uint64 {
	return s.PME.TotalSize()
}

// PMSESize returns the size in bytes of the value of field PMSE
func (s *Manifest) PMSETotalSize() uint64 {
	return s.PMSE.TotalSize()
}

// BPMHOffset returns the offset in bytes of field BPMH
func (s *Manifest) BPMHOffset() uint64 {
	return 0
}

// SEOffset returns the offset in bytes of field SE
func (s *Manifest) SEOffset() uint64 {
	return s.BPMHOffset() + s.BPMHTotalSize()
}

// PMEOffset returns the offset in bytes of field PME
func (s *Manifest) PMEOffset() uint64 {
	return s.SEOffset() + s.SETotalSize()
}

// PMSEOffset returns the offset in bytes of field PMSE
func (s *Manifest) PMSEOffset() uint64 {
	return s.PMEOffset() + s.PMETotalSize()
}

// Size returns the total size of the Manifest.
func (s *Manifest) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.BPMHTotalSize()
	size += s.SETotalSize()
	size += s.PMETotalSize()
	size += s.PMSETotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Manifest) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Boot Policy Manifest", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "BPMH: Header", "", &s.BPMH, opts...)...)
	// ManifestFieldType is elementList
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("SE: Array of \"Boot Policy Manifest\" of length %d", len(s.SE)), s.SE))
	for i := 0; i < len(s.SE); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.SE[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "PME: Platform Manufacturer", "", s.PME, opts...)...)
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "PMSE: Signature", "", &s.PMSE, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/bgbootpolicy/manifest_nocodegen.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

//
// To avoid errors "bpm.KeySignatureOffsetTotalSize undefined" and
// "bpm.BPMH.PrettyString undefined" we place these functions to a file
// with a build tag "!manifestcodegen"

package bgbootpolicy

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

func (bpm *Manifest) rehashedBPMH() BPMH {
	return bpm.BPMH
}

// Print prints the Manifest
func (bpm Manifest) Print() {
	fmt.Printf("%v", bpm.BPMH.PrettyString(1, true))
	for _, item := range bpm.SE {
		fmt.Printf("%v", item.PrettyString(1, true))
	}

	if bpm.PME != nil {
		fmt.Printf("%v\n", bpm.PME.PrettyString(1, true))
	} else {
		fmt.Println("  --PME--\n\tnot set!(optional)")
	}

	if bpm.PMSE.Signature.DataTotalSize() < 1 {
		fmt.Printf("%v\n", bpm.PMSE.PrettyString(1, true, pretty.OptionOmitKeySignature(true)))
		fmt.Printf("  --PMSE--\n\tBoot Policy Manifest not signed!\n\n")
	} else {
		fmt.Printf("%v\n", bpm.PMSE.PrettyString(1, true, pretty.OptionOmitKeySignature(false)))
	}
}

```

`pkg/intel/metadata/bg/bgbootpolicy/manifest_test.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bgbootpolicy

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/unittest"
)

func TestReadWrite(t *testing.T) {
	unittest.BGManifestReadWrite(t, &Manifest{}, "testdata/bpm.bin")
	unittest.BGManifestReadWrite(t, &Manifest{}, "testdata/bpm2.bin")
	unittest.BGManifestReadWrite(t, &Manifest{}, "testdata/bpm3.bin")
}

```

`pkg/intel/metadata/bg/bgbootpolicy/pm.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgbootpolicy

type PM struct {
	StructInfo `id:"__PMDA__" version:"0x10"`
	DataSize   uint16 `json:"pcDataSize"`
	Data       []byte `json:"pcData"`
}

```

`pkg/intel/metadata/bg/bgbootpolicy/pm_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy

package bgbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewPM returns a new instance of PM with
// all default values set.
func NewPM() *PM {
	s := &PM{}
	copy(s.StructInfo.ID[:], []byte(StructureIDPM))
	s.StructInfo.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *PM) Validate() error {

	return nil
}

// StructureIDPM is the StructureID (in terms of
// the document #575623) of element 'PM'.
const StructureIDPM = "__PMDA__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PM) GetStructInfo() bg.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PM) SetStructInfo(newStructInfo bg.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the PM from 'r' in format defined in the document #575623.
func (s *PM) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the PM from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *PM) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// DataSize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.DataSize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DataSize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		var size uint16
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *PM) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *PM) Rehash() {
}

// WriteTo writes the PM into 'w' in format defined in
// the document #575623.
func (s *PM) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// DataSize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.DataSize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DataSize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(len(s.Data))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *PM) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// DataSizeSize returns the size in bytes of the value of field DataSize
func (s *PM) DataSizeTotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *PM) DataTotalSize() uint64 {
	size := uint64(binary.Size(uint16(0)))
	size += uint64(len(s.Data))
	return size
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *PM) StructInfoOffset() uint64 {
	return 0
}

// DataSizeOffset returns the offset in bytes of field DataSize
func (s *PM) DataSizeOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *PM) DataOffset() uint64 {
	return s.DataSizeOffset() + s.DataSizeTotalSize()
}

// Size returns the total size of the PM.
func (s *PM) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.DataSizeTotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *PM) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "PM", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Data Size", "", &s.DataSize, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", &s.Data, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/bgbootpolicy/se.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgbootpolicy

import (
	"fmt"
	"math"
	"time"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
)

// PrettyString: IBB Segments Element
type SE struct {
	StructInfo `id:"__IBBS__" version:"0x10"`
	Reserved0  [1]byte   `require:"0" json:"seReserved0,omitempty"`
	Reserved1  [1]byte   `require:"0" json:"seReserved1,omitempty"`
	PBETValue  PBETValue `json:"sePBETValue"`
	Flags      SEFlags   `json:"seFlags"`
	// PrettyString: IBB MCHBAR
	IBBMCHBAR uint64 `json:"seIBBMCHBAR"`
	// PrettyString: VT-d BAR
	VTdBAR uint64 `json:"seVTdBAR"`
	// PrettyString: DMA Protection 0 Base Address
	PMRLBase uint32 `json:"seDMAProtBase0"`
	// PrettyString: DMA Protection 0 Limit Address
	PMRLLimit uint32 `json:"seDMAProtLimit0"`
	// PrettyString: DMA Protection 1 Base Address
	Reserved2 [8]byte `json:"seDMAProtBase1"`
	// PrettyString: DMA Protection 2 Limit Address
	Reserved3 [8]byte `json:"seDMAProtLimit1"`

	PostIBBHash bg.HashStructureFill `json:"sePostIBBHash"`

	IBBEntryPoint uint32 `json:"seIBBEntry"`

	Digest bg.HashStructure `json:"seDigestList"`

	IBBSegments []IBBSegment `countType:"uint8" json:"seIBBSegments,omitempty"`
}

type PBETValue uint8

// PBETValue returns the raw value of the timer setting.
func (pbet PBETValue) PBETValue() uint8 {
	return uint8(pbet) & 0x0f
}

// Duration returns the value as time.Duration.
func (pbet PBETValue) Duration() time.Duration {
	v := pbet.PBETValue()
	if v == 0 {
		return math.MaxInt64
	}
	return time.Second * time.Duration(5+v)
}

func (pbet *PBETValue) SetDuration(duration time.Duration) time.Duration {
	v := duration.Nanoseconds()/time.Second.Nanoseconds() - 5
	if v <= 0 {
		v = 1
	}
	if v >= 16 {
		v = 0
	}
	*pbet = PBETValue(v)

	return pbet.Duration()
}

type SEFlags uint32

func (flags SEFlags) Reserved0() uint32 {
	return uint32(flags & 0xffffffe0)
}

// PrettyString-true:  BIOS supports Top Swap remediation action
// PrettyString-false: BIOS does not support Top Swap remediation action
func (flags SEFlags) SupportsTopSwapRemediation() bool {
	return flags&0x10 != 0
}

// PrettyString-true:  Leave Hierarchies enabled. Cap all PCRs on failure.
// PrettyString-false: Do not leave enabled. Disable all Hierarchies or deactivate on failure.
func (flags SEFlags) TPMFailureLeavesHierarchiesEnabled() bool {
	return flags&0x08 != 0
}

// PrettyString-true:  Extend Authority Measurements into the Authority PCR 7
// PrettyString-false: Do not extend into the Authority PCR 7
func (flags SEFlags) AuthorityMeasure() bool {
	return flags&0x04 != 0
}

// PrettyString-true:  Issue TPM Start-up from Locality 3
// PrettyString-false: Disabled
func (flags SEFlags) Locality3Startup() bool {
	return flags&0x02 != 0
}

// PrettyString-true:  Enable DMA Protection
// PrettyString-false: Disable DMA Protection
func (flags SEFlags) DMAProtection() bool {
	return flags&0x01 != 0
}

type IBBSegment struct {
	Reserved [2]byte `require:"0" json:"ibbSegReserved"`
	Flags    uint16  `json:"ibbSegFlags"`
	Base     uint32  `json:"ibbSegBase"`
	Size     uint32  `json:"ibbSegSize"`
}

type CachingType uint8

const (
	CachingTypeWriteProtect = CachingType(iota)
	CachingTypeWriteBack
	CachingTypeReserved0
	CachingTypeReserved1
)

// String implements fmt.Stringer.
func (c CachingType) String() string {
	switch c {
	case CachingTypeWriteProtect:
		return "write_protect"
	case CachingTypeWriteBack:
		return "write_back"
	case CachingTypeReserved0:
		return "value_0x02"
	case CachingTypeReserved1:
		return "value_0x03"
	}
	return fmt.Sprintf("unexpected_value_0x%02X", uint8(c))
}

```

`pkg/intel/metadata/bg/bgbootpolicy/se_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy

package bgbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewIBBSegment returns a new instance of IBBSegment with
// all default values set.
func NewIBBSegment() *IBBSegment {
	s := &IBBSegment{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *IBBSegment) Validate() error {
	// See tag "require"
	for idx := range s.Reserved {
		if s.Reserved[idx] != 0 {
			return fmt.Errorf("'Reserved[%d]' is expected to be 0, but it is %v", idx, s.Reserved[idx])
		}
	}

	return nil
}

// ReadFrom reads the IBBSegment from 'r' in format defined in the document #575623.
func (s *IBBSegment) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Reserved (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, s.Reserved[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// Base (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Base)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// Size (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *IBBSegment) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *IBBSegment) Rehash() {
}

// WriteTo writes the IBBSegment into 'w' in format defined in
// the document #575623.
func (s *IBBSegment) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Reserved (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, s.Reserved[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// Base (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Base)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// Size (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// ReservedSize returns the size in bytes of the value of field Reserved
func (s *IBBSegment) ReservedTotalSize() uint64 {
	return 2
}

// FlagsSize returns the size in bytes of the value of field Flags
func (s *IBBSegment) FlagsTotalSize() uint64 {
	return 2
}

// BaseSize returns the size in bytes of the value of field Base
func (s *IBBSegment) BaseTotalSize() uint64 {
	return 4
}

// SizeSize returns the size in bytes of the value of field Size
func (s *IBBSegment) SizeTotalSize() uint64 {
	return 4
}

// ReservedOffset returns the offset in bytes of field Reserved
func (s *IBBSegment) ReservedOffset() uint64 {
	return 0
}

// FlagsOffset returns the offset in bytes of field Flags
func (s *IBBSegment) FlagsOffset() uint64 {
	return s.ReservedOffset() + s.ReservedTotalSize()
}

// BaseOffset returns the offset in bytes of field Base
func (s *IBBSegment) BaseOffset() uint64 {
	return s.FlagsOffset() + s.FlagsTotalSize()
}

// SizeOffset returns the offset in bytes of field Size
func (s *IBBSegment) SizeOffset() uint64 {
	return s.BaseOffset() + s.BaseTotalSize()
}

// Size returns the total size of the IBBSegment.
func (s *IBBSegment) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.ReservedTotalSize()
	size += s.FlagsTotalSize()
	size += s.BaseTotalSize()
	size += s.SizeTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *IBBSegment) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "IBB Segment", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved", "", &s.Reserved, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Flags", "", &s.Flags, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Base", "", &s.Base, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Size", "", &s.Size, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// NewSE returns a new instance of SE with
// all default values set.
func NewSE() *SE {
	s := &SE{}
	copy(s.StructInfo.ID[:], []byte(StructureIDSE))
	s.StructInfo.Version = 0x10
	// Recursively initializing a child structure:
	s.PostIBBHash = *bg.NewHashStructureFill()
	// Recursively initializing a child structure:
	s.Digest = *bg.NewHashStructure()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *SE) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}
	// See tag "require"
	for idx := range s.Reserved1 {
		if s.Reserved1[idx] != 0 {
			return fmt.Errorf("'Reserved1[%d]' is expected to be 0, but it is %v", idx, s.Reserved1[idx])
		}
	}
	// Recursively validating a child structure:
	if err := s.PostIBBHash.Validate(); err != nil {
		return fmt.Errorf("error on field 'PostIBBHash': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.Digest.Validate(); err != nil {
		return fmt.Errorf("error on field 'Digest': %w", err)
	}

	return nil
}

// StructureIDSE is the StructureID (in terms of
// the document #575623) of element 'SE'.
const StructureIDSE = "__IBBS__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *SE) GetStructInfo() bg.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *SE) SetStructInfo(newStructInfo bg.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the SE from 'r' in format defined in the document #575623.
func (s *SE) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the SE from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *SE) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// PBETValue (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.PBETValue)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PBETValue': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// IBBMCHBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.IBBMCHBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'IBBMCHBAR': %w", err)
		}
		totalN += int64(n)
	}

	// VTdBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.VTdBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'VTdBAR': %w", err)
		}
		totalN += int64(n)
	}

	// PMRLBase (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.PMRLBase)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PMRLBase': %w", err)
		}
		totalN += int64(n)
	}

	// PMRLLimit (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.PMRLLimit)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PMRLLimit': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved3 (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, s.Reserved3[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved3': %w", err)
		}
		totalN += int64(n)
	}

	// PostIBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.PostIBBHash.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PostIBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// IBBEntryPoint (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.IBBEntryPoint)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'IBBEntryPoint': %w", err)
		}
		totalN += int64(n)
	}

	// Digest (ManifestFieldType: subStruct)
	{
		n, err := s.Digest.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Digest': %w", err)
		}
		totalN += int64(n)
	}

	// IBBSegments (ManifestFieldType: list)
	{
		var count uint8
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field 'IBBSegments': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.IBBSegments = make([]IBBSegment, count)

		for idx := range s.IBBSegments {
			n, err := s.IBBSegments[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field 'IBBSegments[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *SE) RehashRecursive() {
	s.StructInfo.Rehash()
	s.PostIBBHash.Rehash()
	s.Digest.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *SE) Rehash() {
}

// WriteTo writes the SE into 'w' in format defined in
// the document #575623.
func (s *SE) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// PBETValue (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.PBETValue)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PBETValue': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// IBBMCHBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.IBBMCHBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'IBBMCHBAR': %w", err)
		}
		totalN += int64(n)
	}

	// VTdBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.VTdBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'VTdBAR': %w", err)
		}
		totalN += int64(n)
	}

	// PMRLBase (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.PMRLBase)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PMRLBase': %w", err)
		}
		totalN += int64(n)
	}

	// PMRLLimit (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.PMRLLimit)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PMRLLimit': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved3 (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, s.Reserved3[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved3': %w", err)
		}
		totalN += int64(n)
	}

	// PostIBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.PostIBBHash.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PostIBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// IBBEntryPoint (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.IBBEntryPoint)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'IBBEntryPoint': %w", err)
		}
		totalN += int64(n)
	}

	// Digest (ManifestFieldType: subStruct)
	{
		n, err := s.Digest.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Digest': %w", err)
		}
		totalN += int64(n)
	}

	// IBBSegments (ManifestFieldType: list)
	{
		count := uint8(len(s.IBBSegments))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field 'IBBSegments': %w", err)
		}
		totalN += int64(binary.Size(count))
		for idx := range s.IBBSegments {
			n, err := s.IBBSegments[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'IBBSegments[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *SE) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *SE) Reserved0TotalSize() uint64 {
	return 1
}

// Reserved1Size returns the size in bytes of the value of field Reserved1
func (s *SE) Reserved1TotalSize() uint64 {
	return 1
}

// PBETValueSize returns the size in bytes of the value of field PBETValue
func (s *SE) PBETValueTotalSize() uint64 {
	return 1
}

// FlagsSize returns the size in bytes of the value of field Flags
func (s *SE) FlagsTotalSize() uint64 {
	return 4
}

// IBBMCHBARSize returns the size in bytes of the value of field IBBMCHBAR
func (s *SE) IBBMCHBARTotalSize() uint64 {
	return 8
}

// VTdBARSize returns the size in bytes of the value of field VTdBAR
func (s *SE) VTdBARTotalSize() uint64 {
	return 8
}

// PMRLBaseSize returns the size in bytes of the value of field PMRLBase
func (s *SE) PMRLBaseTotalSize() uint64 {
	return 4
}

// PMRLLimitSize returns the size in bytes of the value of field PMRLLimit
func (s *SE) PMRLLimitTotalSize() uint64 {
	return 4
}

// Reserved2Size returns the size in bytes of the value of field Reserved2
func (s *SE) Reserved2TotalSize() uint64 {
	return 8
}

// Reserved3Size returns the size in bytes of the value of field Reserved3
func (s *SE) Reserved3TotalSize() uint64 {
	return 8
}

// PostIBBHashSize returns the size in bytes of the value of field PostIBBHash
func (s *SE) PostIBBHashTotalSize() uint64 {
	return s.PostIBBHash.TotalSize()
}

// IBBEntryPointSize returns the size in bytes of the value of field IBBEntryPoint
func (s *SE) IBBEntryPointTotalSize() uint64 {
	return 4
}

// DigestSize returns the size in bytes of the value of field Digest
func (s *SE) DigestTotalSize() uint64 {
	return s.Digest.TotalSize()
}

// IBBSegmentsSize returns the size in bytes of the value of field IBBSegments
func (s *SE) IBBSegmentsTotalSize() uint64 {
	var size uint64
	size += uint64(binary.Size(uint8(0)))
	for idx := range s.IBBSegments {
		size += s.IBBSegments[idx].TotalSize()
	}
	return size
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *SE) StructInfoOffset() uint64 {
	return 0
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *SE) Reserved0Offset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// Reserved1Offset returns the offset in bytes of field Reserved1
func (s *SE) Reserved1Offset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// PBETValueOffset returns the offset in bytes of field PBETValue
func (s *SE) PBETValueOffset() uint64 {
	return s.Reserved1Offset() + s.Reserved1TotalSize()
}

// FlagsOffset returns the offset in bytes of field Flags
func (s *SE) FlagsOffset() uint64 {
	return s.PBETValueOffset() + s.PBETValueTotalSize()
}

// IBBMCHBAROffset returns the offset in bytes of field IBBMCHBAR
func (s *SE) IBBMCHBAROffset() uint64 {
	return s.FlagsOffset() + s.FlagsTotalSize()
}

// VTdBAROffset returns the offset in bytes of field VTdBAR
func (s *SE) VTdBAROffset() uint64 {
	return s.IBBMCHBAROffset() + s.IBBMCHBARTotalSize()
}

// PMRLBaseOffset returns the offset in bytes of field PMRLBase
func (s *SE) PMRLBaseOffset() uint64 {
	return s.VTdBAROffset() + s.VTdBARTotalSize()
}

// PMRLLimitOffset returns the offset in bytes of field PMRLLimit
func (s *SE) PMRLLimitOffset() uint64 {
	return s.PMRLBaseOffset() + s.PMRLBaseTotalSize()
}

// Reserved2Offset returns the offset in bytes of field Reserved2
func (s *SE) Reserved2Offset() uint64 {
	return s.PMRLLimitOffset() + s.PMRLLimitTotalSize()
}

// Reserved3Offset returns the offset in bytes of field Reserved3
func (s *SE) Reserved3Offset() uint64 {
	return s.Reserved2Offset() + s.Reserved2TotalSize()
}

// PostIBBHashOffset returns the offset in bytes of field PostIBBHash
func (s *SE) PostIBBHashOffset() uint64 {
	return s.Reserved3Offset() + s.Reserved3TotalSize()
}

// IBBEntryPointOffset returns the offset in bytes of field IBBEntryPoint
func (s *SE) IBBEntryPointOffset() uint64 {
	return s.PostIBBHashOffset() + s.PostIBBHashTotalSize()
}

// DigestOffset returns the offset in bytes of field Digest
func (s *SE) DigestOffset() uint64 {
	return s.IBBEntryPointOffset() + s.IBBEntryPointTotalSize()
}

// IBBSegmentsOffset returns the offset in bytes of field IBBSegments
func (s *SE) IBBSegmentsOffset() uint64 {
	return s.DigestOffset() + s.DigestTotalSize()
}

// Size returns the total size of the SE.
func (s *SE) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.Reserved0TotalSize()
	size += s.Reserved1TotalSize()
	size += s.PBETValueTotalSize()
	size += s.FlagsTotalSize()
	size += s.IBBMCHBARTotalSize()
	size += s.VTdBARTotalSize()
	size += s.PMRLBaseTotalSize()
	size += s.PMRLLimitTotalSize()
	size += s.Reserved2TotalSize()
	size += s.Reserved3TotalSize()
	size += s.PostIBBHashTotalSize()
	size += s.IBBEntryPointTotalSize()
	size += s.DigestTotalSize()
	size += s.IBBSegmentsTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *SE) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "IBB Segments Element", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 1", "", &s.Reserved1, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "PBET Value", "", &s.PBETValue, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Flags", "", &s.Flags, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "IBB MCHBAR", "", &s.IBBMCHBAR, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "VT-d BAR", "", &s.VTdBAR, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 0 Base Address", "", &s.PMRLBase, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 0 Limit Address", "", &s.PMRLLimit, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 1 Base Address", "", &s.Reserved2, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 2 Limit Address", "", &s.Reserved3, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Post IBB Hash", "", &s.PostIBBHash, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "IBB Entry Point", "", &s.IBBEntryPoint, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Digest", "", &s.Digest, opts...)...)
	// ManifestFieldType is list
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("IBBSegments: Array of \"IBB Segments Element\" of length %d", len(s.IBBSegments)), s.IBBSegments))
	for i := 0; i < len(s.IBBSegments); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.IBBSegments[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v CachingType) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v CachingType) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the CachingType into 'w' in binary format.
func (v CachingType) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the CachingType from 'r' in binary format.
func (v CachingType) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v PBETValue) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "PBET Value", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "PBET Value", "", v.PBETValue(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v PBETValue) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the PBETValue into 'w' in binary format.
func (v PBETValue) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the PBETValue from 'r' in binary format.
func (v PBETValue) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v SEFlags) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "SE Flags", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", v.Reserved0(), opts...)...)
	if v.SupportsTopSwapRemediation() {
		lines = append(lines, pretty.SubValue(depth+1, "Supports Top Swap Remediation", "BIOS supports Top Swap remediation action", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Supports Top Swap Remediation", "BIOS does not support Top Swap remediation action", false, opts...)...)
	}
	if v.TPMFailureLeavesHierarchiesEnabled() {
		lines = append(lines, pretty.SubValue(depth+1, "TPM Failure Leaves Hierarchies Enabled", "Leave Hierarchies enabled. Cap all PCRs on failure.", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "TPM Failure Leaves Hierarchies Enabled", "Do not leave enabled. Disable all Hierarchies or deactivate on failure.", false, opts...)...)
	}
	if v.AuthorityMeasure() {
		lines = append(lines, pretty.SubValue(depth+1, "Authority Measure", "Extend Authority Measurements into the Authority PCR 7", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Authority Measure", "Do not extend into the Authority PCR 7", false, opts...)...)
	}
	if v.Locality3Startup() {
		lines = append(lines, pretty.SubValue(depth+1, "Locality 3 Startup", "Issue TPM Start-up from Locality 3", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Locality 3 Startup", "Disabled", false, opts...)...)
	}
	if v.DMAProtection() {
		lines = append(lines, pretty.SubValue(depth+1, "DMA Protection", "Enable DMA Protection", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "DMA Protection", "Disable DMA Protection", false, opts...)...)
	}
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v SEFlags) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the SEFlags into 'w' in binary format.
func (v SEFlags) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the SEFlags from 'r' in binary format.
func (v SEFlags) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/bg/bgbootpolicy/signature.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgbootpolicy

import "github.com/linuxboot/fiano/pkg/intel/metadata/bg"

// Signature contains the signature of the BPM.
type Signature struct {
	StructInfo      `id:"__PMSG__" version:"0x10"`
	bg.KeySignature `json:"sigKeySignature"`
}

```

`pkg/intel/metadata/bg/bgbootpolicy/signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy

package bgbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewSignature returns a new instance of Signature with
// all default values set.
func NewSignature() *Signature {
	s := &Signature{}
	copy(s.StructInfo.ID[:], []byte(StructureIDSignature))
	s.StructInfo.Version = 0x10
	// Recursively initializing a child structure:
	s.KeySignature = *bg.NewKeySignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Signature) Validate() error {
	// Recursively validating a child structure:
	if err := s.KeySignature.Validate(); err != nil {
		return fmt.Errorf("error on field 'KeySignature': %w", err)
	}

	return nil
}

// StructureIDSignature is the StructureID (in terms of
// the document #575623) of element 'Signature'.
const StructureIDSignature = "__PMSG__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Signature) GetStructInfo() bg.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Signature) SetStructInfo(newStructInfo bg.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the Signature from 'r' in format defined in the document #575623.
func (s *Signature) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the Signature from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *Signature) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// KeySignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeySignature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Signature) RehashRecursive() {
	s.StructInfo.Rehash()
	s.KeySignature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Signature) Rehash() {
}

// WriteTo writes the Signature into 'w' in format defined in
// the document #575623.
func (s *Signature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// KeySignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeySignature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *Signature) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// KeySignatureSize returns the size in bytes of the value of field KeySignature
func (s *Signature) KeySignatureTotalSize() uint64 {
	return s.KeySignature.TotalSize()
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *Signature) StructInfoOffset() uint64 {
	return 0
}

// KeySignatureOffset returns the offset in bytes of field KeySignature
func (s *Signature) KeySignatureOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// Size returns the total size of the Signature.
func (s *Signature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.KeySignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Signature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key Signature", "", &s.KeySignature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/bgkey/manifest.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bgkey

import (
	"bytes"
	"crypto"
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
)

// PrettyString: BG Key Manifest
type Manifest struct {
	bg.StructInfo   `id:"__KEYM__" version:"0x10"`
	KMVersion       uint8            `json:"kmVersion"`
	KMSVN           bg.SVN           `json:"kmSVN"`
	KMID            uint8            `json:"kmID"`
	BPKey           bg.HashStructure `json:"kmBPKey"`
	KeyAndSignature bg.KeySignature  `json:"kmKeySignature"`
}

func (m *Manifest) SetSignature(
	algo bg.Algorithm,
	privKey crypto.Signer,
	signedData []byte,
) error {
	err := m.KeyAndSignature.SetSignature(algo, privKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}

	return nil
}

func (m *Manifest) ValidateBPMKey(bpmKS bg.KeySignature) error {
	h, err := m.BPKey.HashAlg.Hash()
	if err != nil {
		return fmt.Errorf("invalid hash algo %v: %w", m.BPKey.HashAlg, err)
	}

	if len(m.BPKey.HashBuffer) != h.Size() {
		return fmt.Errorf("invalid hash lenght: actual:%d expected:%d", len(m.BPKey.HashBuffer), h.Size())
	}

	switch bpmKS.Key.KeyAlg {
	case bg.AlgRSA:
		if _, err := h.Write(bpmKS.Key.Data[4:]); err != nil {
			return fmt.Errorf("unable to hash: %w", err)
		}
	default:
		return fmt.Errorf("unsupported key algorithm: %v", bpmKS.Key.KeyAlg)
	}
	digest := h.Sum(nil)

	if !bytes.Equal(m.BPKey.HashBuffer, digest) {
		return fmt.Errorf("BPM key hash does not match the one in KM: actual:%X != in-KM:%X (hash algo: %v)", digest, m.BPKey.HashBuffer, m.BPKey.HashAlg)
	}

	return nil
}

```

`pkg/intel/metadata/bg/bgkey/manifest_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgkey

package bgkey

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = bg.StructInfo{}
)

// NewManifest returns a new instance of Manifest with
// all default values set.
func NewManifest() *Manifest {
	s := &Manifest{}
	copy(s.StructInfo.ID[:], []byte(StructureIDManifest))
	s.StructInfo.Version = 0x10
	// Recursively initializing a child structure:
	s.BPKey = *bg.NewHashStructure()
	// Recursively initializing a child structure:
	s.KeyAndSignature = *bg.NewKeySignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Manifest) Validate() error {
	// Recursively validating a child structure:
	if err := s.BPKey.Validate(); err != nil {
		return fmt.Errorf("error on field 'BPKey': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.KeyAndSignature.Validate(); err != nil {
		return fmt.Errorf("error on field 'KeyAndSignature': %w", err)
	}

	return nil
}

// StructureIDManifest is the StructureID (in terms of
// the document #575623) of element 'Manifest'.
const StructureIDManifest = "__KEYM__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Manifest) GetStructInfo() bg.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Manifest) SetStructInfo(newStructInfo bg.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the Manifest from 'r' in format defined in the document #575623.
func (s *Manifest) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the Manifest from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *Manifest) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// KMVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.KMVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KMVersion': %w", err)
		}
		totalN += int64(n)
	}

	// KMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.KMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// KMID (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.KMID)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KMID': %w", err)
		}
		totalN += int64(n)
	}

	// BPKey (ManifestFieldType: subStruct)
	{
		n, err := s.BPKey.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'BPKey': %w", err)
		}
		totalN += int64(n)
	}

	// KeyAndSignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeyAndSignature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeyAndSignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Manifest) RehashRecursive() {
	s.StructInfo.Rehash()
	s.BPKey.Rehash()
	s.KeyAndSignature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Manifest) Rehash() {
}

// WriteTo writes the Manifest into 'w' in format defined in
// the document #575623.
func (s *Manifest) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// KMVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.KMVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KMVersion': %w", err)
		}
		totalN += int64(n)
	}

	// KMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.KMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// KMID (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.KMID)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KMID': %w", err)
		}
		totalN += int64(n)
	}

	// BPKey (ManifestFieldType: subStruct)
	{
		n, err := s.BPKey.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPKey': %w", err)
		}
		totalN += int64(n)
	}

	// KeyAndSignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeyAndSignature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeyAndSignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *Manifest) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// KMVersionSize returns the size in bytes of the value of field KMVersion
func (s *Manifest) KMVersionTotalSize() uint64 {
	return 1
}

// KMSVNSize returns the size in bytes of the value of field KMSVN
func (s *Manifest) KMSVNTotalSize() uint64 {
	return 1
}

// KMIDSize returns the size in bytes of the value of field KMID
func (s *Manifest) KMIDTotalSize() uint64 {
	return 1
}

// BPKeySize returns the size in bytes of the value of field BPKey
func (s *Manifest) BPKeyTotalSize() uint64 {
	return s.BPKey.TotalSize()
}

// KeyAndSignatureSize returns the size in bytes of the value of field KeyAndSignature
func (s *Manifest) KeyAndSignatureTotalSize() uint64 {
	return s.KeyAndSignature.TotalSize()
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *Manifest) StructInfoOffset() uint64 {
	return 0
}

// KMVersionOffset returns the offset in bytes of field KMVersion
func (s *Manifest) KMVersionOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// KMSVNOffset returns the offset in bytes of field KMSVN
func (s *Manifest) KMSVNOffset() uint64 {
	return s.KMVersionOffset() + s.KMVersionTotalSize()
}

// KMIDOffset returns the offset in bytes of field KMID
func (s *Manifest) KMIDOffset() uint64 {
	return s.KMSVNOffset() + s.KMSVNTotalSize()
}

// BPKeyOffset returns the offset in bytes of field BPKey
func (s *Manifest) BPKeyOffset() uint64 {
	return s.KMIDOffset() + s.KMIDTotalSize()
}

// KeyAndSignatureOffset returns the offset in bytes of field KeyAndSignature
func (s *Manifest) KeyAndSignatureOffset() uint64 {
	return s.BPKeyOffset() + s.BPKeyTotalSize()
}

// Size returns the total size of the Manifest.
func (s *Manifest) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.KMVersionTotalSize()
	size += s.KMSVNTotalSize()
	size += s.KMIDTotalSize()
	size += s.BPKeyTotalSize()
	size += s.KeyAndSignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Manifest) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "BG Key Manifest", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "KM Version", "", &s.KMVersion, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "KMSVN", "", &s.KMSVN, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "KMID", "", &s.KMID, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "BP Key", "", &s.BPKey, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key And Signature", "", &s.KeyAndSignature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/bgkey/manifest_nocodegen.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bgkey

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

// Print prints the Key Manifest.
func (m *Manifest) Print() {
	if m.KeyAndSignature.Signature.DataTotalSize() < 1 {
		fmt.Printf("%v\n", m.PrettyString(1, true, pretty.OptionOmitKeySignature(true)))
		fmt.Printf("  --KeyAndSignature--\n\tKey Manifest not signed!\n\n")
	} else {
		fmt.Printf("%v\n", m.PrettyString(1, true, pretty.OptionOmitKeySignature(false)))
	}
}

```

`pkg/intel/metadata/bg/bgkey/manifest_test.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bgkey

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/unittest"
)

func TestReadWrite(t *testing.T) {
	unittest.BGManifestReadWrite(t, &Manifest{}, "testdata/km.bin")
}

```

`pkg/intel/metadata/bg/config.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bg

var (
	// StrictOrderCheck defines if elements order checks should be performed.
	// For example in the Boot Policy Manifest elements could be in a wrong
	// order. And we still can parse it, but in this way `*Offset` methods
	// could be confusing, since they will show the offset as they will
	// be written (not as they were parsed).
	//
	// We require a strict order because it is explicitly required
	// in the documentation #575623:
	//
	// > The order of the elements and the order of the fields within each
	// > element are architectural and must be followed.
	StrictOrderCheck = true
)

```

`pkg/intel/metadata/bg/crypto_routines.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"crypto"
	"fmt"
	"hash"
	"strings"

	// Required for hash.Hash return in hashInfo struct
	_ "crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
)

// Algorithm represents a crypto algorithm value.
type Algorithm uint16

const (
	AlgUnknown Algorithm = 0x0000
	AlgRSA     Algorithm = 0x0001
	AlgSHA1    Algorithm = 0x0004
	AlgSHA256  Algorithm = 0x000B
	AlgNull    Algorithm = 0x0010
	AlgRSASSA  Algorithm = 0x0014
)

var hashInfo = []struct {
	alg         Algorithm
	hashFactory func() hash.Hash
}{
	{AlgSHA1, crypto.SHA1.New},
	{AlgSHA256, crypto.SHA256.New},
}

// IsNull returns true if a is AlgNull or zero (unset).
func (a Algorithm) IsNull() bool {
	return a == AlgNull || a == AlgUnknown
}

// Hash returns a crypto.Hash based on the given id.
// An error is returned if the given algorithm is not a hash algorithm or is not available.
func (a Algorithm) Hash() (hash.Hash, error) {
	for _, info := range hashInfo {
		if info.alg == a {
			if info.hashFactory == nil {
				return nil, fmt.Errorf("go hash algorithm #%snot available", info.alg.String())
			}
			return info.hashFactory(), nil
		}
	}
	return nil, fmt.Errorf("hash algorithm not supported: %s", a.String())
}

func (a Algorithm) String() string {
	var s strings.Builder
	var err error
	switch a {
	case AlgUnknown:
		_, err = s.WriteString("AlgUnknown")
	case AlgRSA:
		_, err = s.WriteString("RSA")
	case AlgSHA1:
		_, err = s.WriteString("SHA1")
	case AlgSHA256:
		_, err = s.WriteString("SHA256")
	case AlgNull:
		_, err = s.WriteString("AlgNull")
	case AlgRSASSA:
		_, err = s.WriteString("RSASSA")
	default:
		return fmt.Sprintf("Alg?<%d>", int(a))
	}
	if err != nil {
		return fmt.Sprintf("Writing to string builder failed: %v", err)
	}
	return s.String()
}

func GetAlgFromString(name string) (Algorithm, error) {
	n := strings.ToUpper(name)
	switch n {
	case "ALGUNKNOWN":
		return AlgUnknown, nil
	case "RSA":
		return AlgRSA, nil
	case "SHA1":
		return AlgSHA1, nil
	case "SHA256":
		return AlgSHA256, nil
	case "ALGNULL":
		return AlgNull, nil
	case "RSASSA":
		return AlgRSASSA, nil
	default:
		return AlgNull, fmt.Errorf("algorithm name provided unknown")
	}
}

```

`pkg/intel/metadata/bg/crypto_routines_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Algorithm) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v Algorithm) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Algorithm into 'w' in binary format.
func (v Algorithm) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Algorithm from 'r' in binary format.
func (v Algorithm) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/bg/hash.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

// HashStructure describes a digest.
type HashStructure struct {
	HashAlg    Algorithm `default:"0x10" json:"hsAlg"`
	HashBuffer []byte    `json:"hsBuffer"`
}

type HashStructureFill struct {
	HashAlg    Algorithm `default:"0x0b" json:"hsAlg"`
	HashBuffer []byte    `countValue:"hashSize()" prettyValue:"hashSizePrint()" json:"hsBuffer"`
}

func (a Algorithm) size() uint16 {
	switch a {
	case AlgUnknown:
		return 0
	case AlgNull:
		return 0
	case AlgSHA1:
		return 20
	case AlgSHA256:
		return 32
	default:
		return 0
	}
}

func (h HashStructureFill) hashSize() uint16 {
	const hashSizeFieldLen = 2
	if h.HashAlg.IsNull() {
		// Evil hack, more investigation needed
		return AlgSHA256.size() + hashSizeFieldLen
	} else {
		return h.HashAlg.size() + hashSizeFieldLen
	}
}

func (h HashStructureFill) hashSizePrint() interface{} {
	if h.HashAlg.IsNull() {
		// Evil hack, more investigation needed
		return make([]byte, AlgSHA256.size())
	} else {
		return h.HashBuffer
	}
}

```

`pkg/intel/metadata/bg/hash_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewHashStructure returns a new instance of HashStructure with
// all default values set.
func NewHashStructure() *HashStructure {
	s := &HashStructure{}
	// Set through tag "default":
	s.HashAlg = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *HashStructure) Validate() error {

	return nil
}

// ReadFrom reads the HashStructure from 'r' in format defined in the document #575623.
func (s *HashStructure) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		var size uint16
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field 'HashBuffer': %w", err)
		}
		totalN += int64(binary.Size(size))
		s.HashBuffer = make([]byte, size)
		n, err := len(s.HashBuffer), binary.Read(r, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *HashStructure) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *HashStructure) Rehash() {
}

// WriteTo writes the HashStructure into 'w' in format defined in
// the document #575623.
func (s *HashStructure) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		size := uint16(len(s.HashBuffer))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field 'HashBuffer': %w", err)
		}
		totalN += int64(binary.Size(size))
		n, err := len(s.HashBuffer), binary.Write(w, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// HashAlgSize returns the size in bytes of the value of field HashAlg
func (s *HashStructure) HashAlgTotalSize() uint64 {
	return 2
}

// HashBufferSize returns the size in bytes of the value of field HashBuffer
func (s *HashStructure) HashBufferTotalSize() uint64 {
	size := uint64(binary.Size(uint16(0)))
	size += uint64(len(s.HashBuffer))
	return size
}

// HashAlgOffset returns the offset in bytes of field HashAlg
func (s *HashStructure) HashAlgOffset() uint64 {
	return 0
}

// HashBufferOffset returns the offset in bytes of field HashBuffer
func (s *HashStructure) HashBufferOffset() uint64 {
	return s.HashAlgOffset() + s.HashAlgTotalSize()
}

// Size returns the total size of the HashStructure.
func (s *HashStructure) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.HashAlgTotalSize()
	size += s.HashBufferTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *HashStructure) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Hash Structure", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hash Alg", "", &s.HashAlg, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Hash Buffer", "", &s.HashBuffer, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// NewHashStructureFill returns a new instance of HashStructureFill with
// all default values set.
func NewHashStructureFill() *HashStructureFill {
	s := &HashStructureFill{}
	// Set through tag "default":
	s.HashAlg = 0x0b
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *HashStructureFill) Validate() error {

	return nil
}

// ReadFrom reads the HashStructureFill from 'r' in format defined in the document #575623.
func (s *HashStructureFill) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		size := uint16(s.hashSize())
		s.HashBuffer = make([]byte, size)
		n, err := len(s.HashBuffer), binary.Read(r, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *HashStructureFill) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *HashStructureFill) Rehash() {
}

// WriteTo writes the HashStructureFill into 'w' in format defined in
// the document #575623.
func (s *HashStructureFill) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		n, err := len(s.HashBuffer), binary.Write(w, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// HashAlgSize returns the size in bytes of the value of field HashAlg
func (s *HashStructureFill) HashAlgTotalSize() uint64 {
	return 2
}

// HashBufferSize returns the size in bytes of the value of field HashBuffer
func (s *HashStructureFill) HashBufferTotalSize() uint64 {
	return uint64(len(s.HashBuffer))
}

// HashAlgOffset returns the offset in bytes of field HashAlg
func (s *HashStructureFill) HashAlgOffset() uint64 {
	return 0
}

// HashBufferOffset returns the offset in bytes of field HashBuffer
func (s *HashStructureFill) HashBufferOffset() uint64 {
	return s.HashAlgOffset() + s.HashAlgTotalSize()
}

// Size returns the total size of the HashStructureFill.
func (s *HashStructureFill) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.HashAlgTotalSize()
	size += s.HashBufferTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *HashStructureFill) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Hash Structure Fill", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hash Alg", "", &s.HashAlg, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Hash Buffer", "", s.hashSizePrint(), opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/key.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"encoding/binary"
	"fmt"
	"math/big"
)

// Key is a public key of an asymmetric crypto keypair.
type Key struct {
	KeyAlg  Algorithm `json:"keyAlg"`
	Version uint8     `require:"0x10"  json:"keyVersion"`
	KeySize BitSize   `json:"keyBitsize"`
	Data    []byte    `countValue:"keyDataSize()" json:"keyData"`
}

// BitSize is a size in bits.
type BitSize uint16

// InBits returns the size in bits.
func (ks BitSize) InBits() uint16 {
	return uint16(ks)
}

// InBytes returns the size in bytes.
func (ks BitSize) InBytes() uint16 {
	return uint16(ks >> 3)
}

// SetInBits sets the size in bits.
func (ks *BitSize) SetInBits(amountOfBits uint16) {
	*ks = BitSize(amountOfBits)
}

// SetInBytes sets the size in bytes.
func (ks *BitSize) SetInBytes(amountOfBytes uint16) {
	*ks = BitSize(amountOfBytes << 3)
}

// keyDataSize returns the expected length of Data for specified
// KeyAlg and KeySize.
func (k Key) keyDataSize() int64 {
	switch k.KeyAlg {
	case AlgRSA:
		return int64(k.KeySize.InBytes()) + 4
	}
	return -1
}

// PubKey parses Data into crypto.PublicKey.
func (k Key) PubKey() (crypto.PublicKey, error) {
	expectedSize := int(k.keyDataSize())
	if expectedSize < 0 {
		return nil, fmt.Errorf("unexpected algorithm: %s", k.KeyAlg)
	}
	if len(k.Data) != expectedSize {
		return nil, fmt.Errorf("unexpected size: expected:%d, received %d", expectedSize, len(k.Data))
	}

	switch k.KeyAlg {
	case AlgRSA:
		result := &rsa.PublicKey{
			N: new(big.Int).SetBytes(reverseBytes(k.Data[4:])),
			E: int(binaryOrder.Uint32(k.Data)),
		}
		return result, nil
	}

	return nil, fmt.Errorf("unexpected TPM algorithm: %s", k.KeyAlg)
}

func reverseBytes(b []byte) []byte {
	r := make([]byte, len(b))
	for idx := range b {
		r[idx] = b[len(b)-idx-1]
	}
	return r
}

// SetPubKey sets Data the value corresponding to passed `key`.
func (k *Key) SetPubKey(key crypto.PublicKey) error {
	k.Version = 0x10

	switch key := key.(type) {
	case *rsa.PublicKey:
		k.KeyAlg = AlgRSA
		n := key.N.Bytes()
		k.KeySize.SetInBytes(uint16(len(n)))
		k.Data = make([]byte, 4+len(n))
		binaryOrder.PutUint32(k.Data, uint32(key.E))
		copy(k.Data[4:], reverseBytes(n))
		return nil
	}

	return fmt.Errorf("unexpected key type: %T", key)
}

// PrintBPMPubKey prints the BPM public signing key hash to fuse into the Intel ME
func (k *Key) PrintBPMPubKey(bpmAlg Algorithm) error {
	buf := new(bytes.Buffer)
	if len(k.Data) > 1 {
		hash, err := bpmAlg.Hash()
		if err != nil {
			return err
		}
		if k.KeyAlg == AlgRSA {
			if err := binary.Write(buf, binary.LittleEndian, k.Data[4:]); err != nil {
				return err
			}
			hash.Write(buf.Bytes())
			fmt.Printf("   Boot Policy Manifest Pubkey Hash: 0x%x\n", hash.Sum(nil))
		} else {
			fmt.Printf("   Boot Policy Manifest Pubkey Hash: Unknown Algorithm\n")
		}
	} else {
		fmt.Printf("   Boot Policy Pubkey Hash: No km public key set in KM\n")
	}

	return nil
}

// PrintKMPubKey prints the KM public signing key hash to fuse into the Intel ME
func (k *Key) PrintKMPubKey(kmAlg Algorithm) error {
	buf := new(bytes.Buffer)
	if len(k.Data) > 1 {
		if k.KeyAlg == AlgRSA {
			if err := binary.Write(buf, binary.LittleEndian, k.Data[4:]); err != nil {
				return err
			}
			if err := binary.Write(buf, binary.LittleEndian, k.Data[:4]); err != nil {
				return err
			}
			if kmAlg != AlgSHA256 {
				return fmt.Errorf("KM public key hash algorithm must be SHA256")
			}
			hash, err := kmAlg.Hash()
			if err != nil {
				return err
			}
			hash.Write(buf.Bytes())
			fmt.Printf("   Key Manifest Pubkey Hash: 0x%x\n", hash.Sum(nil))
			// On SKL and KBL the exponent is not included in the KM hash
			buf.Truncate(len(k.Data[4:]))
			hash.Reset()
			hash.Write(buf.Bytes())
			fmt.Printf("   Key Manifest Pubkey Hash (Skylake and Kabylake only): 0x%x\n", hash.Sum(nil))
		} else {
			fmt.Printf("   Key Manifest Pubkey Hash: Unsupported Algorithm\n")
		}
	} else {
		fmt.Printf("   Key Manifest Pubkey Hash: No km public key set in KM\n")
	}

	return nil
}

```

`pkg/intel/metadata/bg/key_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewKey returns a new instance of Key with
// all default values set.
func NewKey() *Key {
	s := &Key{}
	// Set through tag "required":
	s.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Key) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}

	return nil
}

// ReadFrom reads the Key from 'r' in format defined in the document #575623.
func (s *Key) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// KeyAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeyAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeyAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(s.keyDataSize())
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Key) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Key) Rehash() {
}

// WriteTo writes the Key into 'w' in format defined in
// the document #575623.
func (s *Key) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// KeyAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeyAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeyAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// KeyAlgSize returns the size in bytes of the value of field KeyAlg
func (s *Key) KeyAlgTotalSize() uint64 {
	return 2
}

// VersionSize returns the size in bytes of the value of field Version
func (s *Key) VersionTotalSize() uint64 {
	return 1
}

// KeySizeSize returns the size in bytes of the value of field KeySize
func (s *Key) KeySizeTotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *Key) DataTotalSize() uint64 {
	return uint64(len(s.Data))
}

// KeyAlgOffset returns the offset in bytes of field KeyAlg
func (s *Key) KeyAlgOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *Key) VersionOffset() uint64 {
	return s.KeyAlgOffset() + s.KeyAlgTotalSize()
}

// KeySizeOffset returns the offset in bytes of field KeySize
func (s *Key) KeySizeOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *Key) DataOffset() uint64 {
	return s.KeySizeOffset() + s.KeySizeTotalSize()
}

// Size returns the total size of the Key.
func (s *Key) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.KeyAlgTotalSize()
	size += s.VersionTotalSize()
	size += s.KeySizeTotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Key) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Key", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Alg", "", &s.KeyAlg, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Size", "", &s.KeySize, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", &s.Data, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v BitSize) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Bit Size", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "In Bits", "", v.InBits(), opts...)...)
	lines = append(lines, pretty.SubValue(depth+1, "In Bytes", "", v.InBytes(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v BitSize) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the BitSize into 'w' in binary format.
func (v BitSize) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the BitSize from 'r' in binary format.
func (v BitSize) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/bg/key_signature.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"crypto"
	"fmt"
)

// KeySignature
type KeySignature struct {
	Version   uint8     `require:"0x10" json:"ksVersion,omitempty"`
	Key       Key       `json:"ksKey"`
	Signature Signature `json:"ksSignature"`
}

// Verify verifies the builtin signature with the builtin public key.
func (ks *KeySignature) Verify(signedData []byte) error {
	sig, err := ks.Signature.SignatureData()
	if err != nil {
		return fmt.Errorf("invalid signature: %w", err)
	}
	pk, err := ks.Key.PubKey()
	if err != nil {
		return fmt.Errorf("invalid public key: %w", err)
	}
	err = sig.Verify(pk, signedData)
	if err != nil {
		return fmt.Errorf("verification failed: %w", err)
	}
	return nil
}

// SetSignature generates a signature and sets all the values of KeyManifest,
// accordingly to arguments signAlgo, privKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (ks *KeySignature) SetSignature(signAlgo Algorithm, privKey crypto.Signer, signedData []byte) error {
	ks.Version = 0x10
	err := ks.Key.SetPubKey(privKey.Public())
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return ks.Signature.SetSignature(signAlgo, privKey, signedData)
}

// SetSignatureAuto generates a signature and sets all the values of KeyManifest,
// accordingly to arguments privKey and signedData.
//
// Signing algorithm will be detected automatically based on the type of the
// provided private key.
func (ks *KeySignature) SetSignatureAuto(privKey crypto.Signer, signedData []byte) error {
	ks.Version = 0x10
	err := ks.Key.SetPubKey(privKey.Public())
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return ks.SetSignature(0, privKey, signedData)
}

// FillSignature sets a signature and all the values of KeyManifest,
// accordingly to arguments signAlgo, pubKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (ks *KeySignature) FillSignature(signAlgo Algorithm, pubKey crypto.PublicKey, signedData []byte, hashAlgo Algorithm) error {
	ks.Version = 0x10
	err := ks.Key.SetPubKey(pubKey)
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return ks.Signature.FillSignature(signAlgo, pubKey, signedData, hashAlgo)
}

```

`pkg/intel/metadata/bg/key_signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewKeySignature returns a new instance of KeySignature with
// all default values set.
func NewKeySignature() *KeySignature {
	s := &KeySignature{}
	// Set through tag "required":
	s.Version = 0x10
	// Recursively initializing a child structure:
	s.Key = *NewKey()
	// Recursively initializing a child structure:
	s.Signature = *NewSignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *KeySignature) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}
	// Recursively validating a child structure:
	if err := s.Key.Validate(); err != nil {
		return fmt.Errorf("error on field 'Key': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.Signature.Validate(); err != nil {
		return fmt.Errorf("error on field 'Signature': %w", err)
	}

	return nil
}

// ReadFrom reads the KeySignature from 'r' in format defined in the document #575623.
func (s *KeySignature) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Key (ManifestFieldType: subStruct)
	{
		n, err := s.Key.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Key': %w", err)
		}
		totalN += int64(n)
	}

	// Signature (ManifestFieldType: subStruct)
	{
		n, err := s.Signature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Signature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *KeySignature) RehashRecursive() {
	s.Key.Rehash()
	s.Signature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *KeySignature) Rehash() {
}

// WriteTo writes the KeySignature into 'w' in format defined in
// the document #575623.
func (s *KeySignature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Key (ManifestFieldType: subStruct)
	{
		n, err := s.Key.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Key': %w", err)
		}
		totalN += int64(n)
	}

	// Signature (ManifestFieldType: subStruct)
	{
		n, err := s.Signature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Signature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// VersionSize returns the size in bytes of the value of field Version
func (s *KeySignature) VersionTotalSize() uint64 {
	return 1
}

// KeySize returns the size in bytes of the value of field Key
func (s *KeySignature) KeyTotalSize() uint64 {
	return s.Key.TotalSize()
}

// SignatureSize returns the size in bytes of the value of field Signature
func (s *KeySignature) SignatureTotalSize() uint64 {
	return s.Signature.TotalSize()
}

// VersionOffset returns the offset in bytes of field Version
func (s *KeySignature) VersionOffset() uint64 {
	return 0
}

// KeyOffset returns the offset in bytes of field Key
func (s *KeySignature) KeyOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// SignatureOffset returns the offset in bytes of field Signature
func (s *KeySignature) SignatureOffset() uint64 {
	return s.KeyOffset() + s.KeyTotalSize()
}

// Size returns the total size of the KeySignature.
func (s *KeySignature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.VersionTotalSize()
	size += s.KeyTotalSize()
	size += s.SignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *KeySignature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Key Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key", "", &s.Key, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Signature", "", &s.Signature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/signature.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"crypto"
	"crypto/rand"
	"fmt"
)

var (
	// RandReader exports the rand.Reader
	RandReader = rand.Reader
)

// Signature exports the Signature structure
type Signature struct {
	SigScheme Algorithm `json:"sigScheme"`
	Version   uint8     `require:"0x10" json:"sigVersion,omitempty"`
	KeySize   BitSize   `json:"sigKeysize,omitempty"`
	HashAlg   Algorithm `json:"sigHashAlg"`
	Data      []byte    `countValue:"KeySize.InBytes()" prettyValue:"dataPrettyValue()" json:"sigData"`
}

func (m Signature) dataPrettyValue() interface{} {
	r, _ := m.SignatureData()
	return r
}

// SignatureData parses field Data and returns the signature as one of these types:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m Signature) SignatureData() (SignatureDataInterface, error) {
	switch m.SigScheme {
	case AlgRSASSA:
		return SignatureRSAASA(m.Data), nil
	}

	return nil, fmt.Errorf("unexpected signature scheme: %s", m.SigScheme)
}

// SetSignatureByData sets all the fields of the structure Signature by
// accepting one of these types as the input argument `sig`:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m *Signature) SetSignatureByData(sig SignatureDataInterface, hashAlgo Algorithm) error {
	err := m.SetSignatureData(sig)
	if err != nil {
		return err
	}

	switch sig := sig.(type) {
	case SignatureRSAASA:
		m.SigScheme = AlgRSASSA
		if hashAlgo.IsNull() {
			m.HashAlg = AlgSHA256
		} else {
			m.HashAlg = hashAlgo
		}
		m.KeySize.SetInBytes(uint16(len(m.Data)))
	default:
		return fmt.Errorf("unexpected signature type: %T", sig)
	}
	return nil
}

// SetSignatureData sets the value of the field Data by accepting one of these
// types as the input argument `sig`:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m *Signature) SetSignatureData(sig SignatureDataInterface) error {
	switch sig := sig.(type) {
	case SignatureRSAASA:
		m.Data = sig
	default:
		return fmt.Errorf("unexpected signature type: %T", sig)
	}
	return nil
}

// SetSignature calculates the signature accordingly to arguments signAlgo,
// privKey and signedData; and sets all the fields of the structure Signature.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (m *Signature) SetSignature(signAlgo Algorithm, privKey crypto.Signer, signedData []byte) error {
	m.Version = 0x10
	signData, err := NewSignatureData(signAlgo, privKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to construct the signature data: %w", err)
	}

	err = m.SetSignatureByData(signData, AlgNull)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}

	return nil
}

// FillSignature sets the signature accordingly to arguments signAlgo,
// pubKey and signedData; and sets all the fields of the structure Signature.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (m *Signature) FillSignature(signAlgo Algorithm, pubKey crypto.PublicKey, signedData []byte, hashAlgo Algorithm) error {
	m.Version = 0x10
	signData, err := NewSignatureByData(signAlgo, pubKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to construct the signature data: %w", err)
	}

	err = m.SetSignatureByData(signData, hashAlgo)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}

	return nil
}

```

`pkg/intel/metadata/bg/signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewSignature returns a new instance of Signature with
// all default values set.
func NewSignature() *Signature {
	s := &Signature{}
	// Set through tag "required":
	s.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Signature) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}

	return nil
}

// ReadFrom reads the Signature from 'r' in format defined in the document #575623.
func (s *Signature) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// SigScheme (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.SigScheme)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SigScheme': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(s.KeySize.InBytes())
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Signature) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Signature) Rehash() {
}

// WriteTo writes the Signature into 'w' in format defined in
// the document #575623.
func (s *Signature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// SigScheme (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.SigScheme)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SigScheme': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// SigSchemeSize returns the size in bytes of the value of field SigScheme
func (s *Signature) SigSchemeTotalSize() uint64 {
	return 2
}

// VersionSize returns the size in bytes of the value of field Version
func (s *Signature) VersionTotalSize() uint64 {
	return 1
}

// KeySizeSize returns the size in bytes of the value of field KeySize
func (s *Signature) KeySizeTotalSize() uint64 {
	return 2
}

// HashAlgSize returns the size in bytes of the value of field HashAlg
func (s *Signature) HashAlgTotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *Signature) DataTotalSize() uint64 {
	return uint64(len(s.Data))
}

// SigSchemeOffset returns the offset in bytes of field SigScheme
func (s *Signature) SigSchemeOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *Signature) VersionOffset() uint64 {
	return s.SigSchemeOffset() + s.SigSchemeTotalSize()
}

// KeySizeOffset returns the offset in bytes of field KeySize
func (s *Signature) KeySizeOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// HashAlgOffset returns the offset in bytes of field HashAlg
func (s *Signature) HashAlgOffset() uint64 {
	return s.KeySizeOffset() + s.KeySizeTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *Signature) DataOffset() uint64 {
	return s.HashAlgOffset() + s.HashAlgTotalSize()
}

// Size returns the total size of the Signature.
func (s *Signature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.SigSchemeTotalSize()
	size += s.VersionTotalSize()
	size += s.KeySizeTotalSize()
	size += s.HashAlgTotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Signature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Sig Scheme", "", &s.SigScheme, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Size", "", &s.KeySize, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hash Alg", "", &s.HashAlg, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", s.dataPrettyValue(), opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/signature_types.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"fmt"
)

var SM2UID = []byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}

// NewSignatureData returns an implementation of SignatureDataInterface,
// accordingly to signAlgo, privKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func NewSignatureData(
	signAlgo Algorithm,
	privKey crypto.Signer,
	signedData []byte,
) (SignatureDataInterface, error) {
	if signAlgo == 0 {
		// auto-detect the sign algorithm, based on the provided signing key
		switch privKey.(type) {
		case *rsa.PrivateKey:
			signAlgo = AlgRSASSA
		}
	}
	switch signAlgo {
	case AlgRSASSA:
		rsaPrivateKey, ok := privKey.(*rsa.PrivateKey)
		if !ok {
			return nil, fmt.Errorf("expected private RSA key (type %T), but received %T", rsaPrivateKey, privKey)
		}
		h := sha256.New()
		_, _ = h.Write(signedData)
		bpmHash := h.Sum(nil)
		data, err := rsa.SignPKCS1v15(RandReader, rsaPrivateKey, crypto.SHA256, bpmHash)
		if err != nil {
			return nil, fmt.Errorf("unable to sign with RSASSA the data: %w", err)
		}
		return SignatureRSAASA(data), nil
	}

	return nil, fmt.Errorf("signing algorithm '%s' is not implemented in this library", signAlgo)
}

// NewSignatureByData returns an implementation of SignatureDataInterface,
// accordingly to signAlgo, publicKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func NewSignatureByData(
	signAlgo Algorithm,
	pubKey crypto.PublicKey,
	signedData []byte,
) (SignatureDataInterface, error) {
	if signAlgo == 0 {
		// auto-detect the sign algorithm, based on the provided signing key
		switch pubKey.(type) {
		case *rsa.PublicKey:
			signAlgo = AlgRSASSA
		}
	}
	switch signAlgo {
	case AlgRSASSA:
		return SignatureRSAASA(signedData), nil
	}
	return nil, fmt.Errorf("signing algorithm '%s' is not implemented in this library", signAlgo)
}

// SignatureDataInterface is the interface which abstracts all the signature data types.
type SignatureDataInterface interface {
	fmt.Stringer

	// Verify returns nil if signedData was indeed signed by key pk, and
	// returns an appropriate error otherwise.
	Verify(pk crypto.PublicKey, signedData []byte) error
}

// SignatureRSAASA is RSAASA signature bytes.
type SignatureRSAASA []byte

// String implements fmt.Stringer
func (s SignatureRSAASA) String() string {
	return fmt.Sprintf("0x%X", []byte(s))
}

// Verify implements SignatureDataInterface.
func (s SignatureRSAASA) Verify(pkIface crypto.PublicKey, signedData []byte) error {
	pk, ok := pkIface.(*rsa.PublicKey)
	if !ok {
		return fmt.Errorf("expected public key of type %T, but received %T", pk, pkIface)
	}

	h := sha256.New()
	h.Write(signedData)
	hash := h.Sum(nil)

	err := rsa.VerifyPKCS1v15(pk, crypto.SHA256, hash, s)
	if err != nil {
		return fmt.Errorf("data was not signed by the key: %w", err)
	}

	return nil
}

```

`pkg/intel/metadata/bg/structure.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

import (
	"encoding/binary"
	"io"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	binaryOrder = binary.LittleEndian
)

type StructInfo struct {
	ID      StructureID `json:"StructInfoID"`
	Version uint8       `json:"StructInfoVersion"`
}

func (s StructInfo) StructInfo() StructInfo {
	return s
}

type StructureID [8]byte

func (s StructureID) String() string {
	return string(s[:])
}

type Structure interface {
	io.ReaderFrom
	io.WriterTo
	TotalSize() uint64
	PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string
}

type Element interface {
	Structure
	ReadDataFrom(r io.Reader) (int64, error)
	GetStructInfo() StructInfo
	SetStructInfo(StructInfo)
}

type ElementsContainer interface {
	Structure
	GetFieldByStructID(structID string) interface{}
}

type Manifest interface {
	Structure
}

```

`pkg/intel/metadata/bg/structure_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewStructInfo returns a new instance of StructInfo with
// all default values set.
func NewStructInfo() *StructInfo {
	s := &StructInfo{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *StructInfo) Validate() error {

	return nil
}

// ReadFrom reads the StructInfo from 'r' in format defined in the document #575623.
func (s *StructInfo) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// ID (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, s.ID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ID': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *StructInfo) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *StructInfo) Rehash() {
}

// WriteTo writes the StructInfo into 'w' in format defined in
// the document #575623.
func (s *StructInfo) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// ID (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, s.ID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ID': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// IDSize returns the size in bytes of the value of field ID
func (s *StructInfo) IDTotalSize() uint64 {
	return 8
}

// VersionSize returns the size in bytes of the value of field Version
func (s *StructInfo) VersionTotalSize() uint64 {
	return 1
}

// IDOffset returns the offset in bytes of field ID
func (s *StructInfo) IDOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *StructInfo) VersionOffset() uint64 {
	return s.IDOffset() + s.IDTotalSize()
}

// Size returns the total size of the StructInfo.
func (s *StructInfo) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.IDTotalSize()
	size += s.VersionTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *StructInfo) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Struct Info", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "ID", "", &s.ID, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/bg/svn.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package bg

// SVN represents Security Version Number.
type SVN uint8

// SVN returns the Security Version Number of an SVN field
func (svn SVN) SVN() uint8 {
	return uint8(svn) & 0x0f
}

```

`pkg/intel/metadata/bg/svn_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package bg github.com/linuxboot/fiano/pkg/intel/metadata/bg

package bg

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v SVN) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "SVN", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "SVN", "", v.SVN(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v SVN) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the SVN into 'w' in binary format.
func (v SVN) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the SVN from 'r' in binary format.
func (v SVN) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/Reserved.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

// Reserved is reducted
type Reserved struct {
	StructInfo   `id:"__PFRS__" version:"0x21" var0:"0" var1:"uint16(s.TotalSize())"`
	ReservedData [32]byte `json:"ReservedData"`
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/Reserved_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewReserved returns a new instance of Reserved with
// all default values set.
func NewReserved() *Reserved {
	s := &Reserved{}
	copy(s.StructInfo.ID[:], []byte(StructureIDReserved))
	s.StructInfo.Version = 0x21
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Reserved) Validate() error {

	return nil
}

// StructureIDReserved is the StructureID (in terms of
// the document #575623) of element 'Reserved'.
const StructureIDReserved = "__PFRS__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Reserved) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Reserved) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the Reserved from 'r' in format defined in the document #575623.
func (s *Reserved) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the Reserved from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *Reserved) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// ReservedData (ManifestFieldType: arrayStatic)
	{
		n, err := 32, binary.Read(r, binary.LittleEndian, s.ReservedData[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ReservedData': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Reserved) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Reserved) Rehash() {
	s.Variable0 = 0
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the Reserved into 'w' in format defined in
// the document #575623.
func (s *Reserved) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// ReservedData (ManifestFieldType: arrayStatic)
	{
		n, err := 32, binary.Write(w, binary.LittleEndian, s.ReservedData[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ReservedData': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *Reserved) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// ReservedDataSize returns the size in bytes of the value of field ReservedData
func (s *Reserved) ReservedDataTotalSize() uint64 {
	return 32
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *Reserved) StructInfoOffset() uint64 {
	return 0
}

// ReservedDataOffset returns the offset in bytes of field ReservedData
func (s *Reserved) ReservedDataOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// Size returns the total size of the Reserved.
func (s *Reserved) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.ReservedDataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Reserved) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Reserved", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved Data", "", &s.ReservedData, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/bpmh.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// BPMH is the header of boot policy manifest
type BPMH struct {
	StructInfo `id:"__ACBP__" version:"0x23" var0:"0x20" var1:"uint16(s.TotalSize())"`

	KeySignatureOffset uint16 `json:"bpmhKeySignatureOffset"`

	BPMRevision uint8 `json:"bpmhRevision"`

	// BPMSVN is BPM security version number
	//
	// PrettyString: BPM SVN
	BPMSVN cbnt.SVN `json:"bpmhSNV"`

	// ACMSVNAuth is authorized ACM security version number
	//
	// PrettyString: ACM SVN Auth
	ACMSVNAuth cbnt.SVN `json:"bpmhACMSVN"`

	Reserved0 [1]byte `require:"0" json:"bpmhReserved0,omitempty"`

	NEMDataStack Size4K `json:"bpmhNEMStackSize"`
}

// Size4K is a size in units of 4096 bytes.
type Size4K uint16

// InBytes returns the size in bytes.
func (s Size4K) InBytes() uint32 {
	return uint32(s) * 4096
}

// NewSize4K returns the given size as multiple of 4K
func NewSize4K(size uint32) Size4K {
	return Size4K(size / 4096)
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/bpmh_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewBPMH returns a new instance of BPMH with
// all default values set.
func NewBPMH() *BPMH {
	s := &BPMH{}
	copy(s.StructInfo.ID[:], []byte(StructureIDBPMH))
	s.StructInfo.Version = 0x23
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *BPMH) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}

	return nil
}

// StructureIDBPMH is the StructureID (in terms of
// the document #575623) of element 'BPMH'.
const StructureIDBPMH = "__ACBP__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *BPMH) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *BPMH) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the BPMH from 'r' in format defined in the document #575623.
func (s *BPMH) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the BPMH from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *BPMH) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// KeySignatureOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeySignatureOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySignatureOffset': %w", err)
		}
		totalN += int64(n)
	}

	// BPMRevision (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.BPMRevision)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'BPMRevision': %w", err)
		}
		totalN += int64(n)
	}

	// BPMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.BPMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'BPMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// ACMSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.ACMSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ACMSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// NEMDataStack (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.NEMDataStack)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'NEMDataStack': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *BPMH) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *BPMH) Rehash() {
	s.Variable0 = 0x20
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the BPMH into 'w' in format defined in
// the document #575623.
func (s *BPMH) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// KeySignatureOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeySignatureOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySignatureOffset': %w", err)
		}
		totalN += int64(n)
	}

	// BPMRevision (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.BPMRevision)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPMRevision': %w", err)
		}
		totalN += int64(n)
	}

	// BPMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.BPMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// ACMSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.ACMSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ACMSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// NEMDataStack (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.NEMDataStack)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'NEMDataStack': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *BPMH) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// KeySignatureOffsetSize returns the size in bytes of the value of field KeySignatureOffset
func (s *BPMH) KeySignatureOffsetTotalSize() uint64 {
	return 2
}

// BPMRevisionSize returns the size in bytes of the value of field BPMRevision
func (s *BPMH) BPMRevisionTotalSize() uint64 {
	return 1
}

// BPMSVNSize returns the size in bytes of the value of field BPMSVN
func (s *BPMH) BPMSVNTotalSize() uint64 {
	return 1
}

// ACMSVNAuthSize returns the size in bytes of the value of field ACMSVNAuth
func (s *BPMH) ACMSVNAuthTotalSize() uint64 {
	return 1
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *BPMH) Reserved0TotalSize() uint64 {
	return 1
}

// NEMDataStackSize returns the size in bytes of the value of field NEMDataStack
func (s *BPMH) NEMDataStackTotalSize() uint64 {
	return 2
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *BPMH) StructInfoOffset() uint64 {
	return 0
}

// KeySignatureOffsetOffset returns the offset in bytes of field KeySignatureOffset
func (s *BPMH) KeySignatureOffsetOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// BPMRevisionOffset returns the offset in bytes of field BPMRevision
func (s *BPMH) BPMRevisionOffset() uint64 {
	return s.KeySignatureOffsetOffset() + s.KeySignatureOffsetTotalSize()
}

// BPMSVNOffset returns the offset in bytes of field BPMSVN
func (s *BPMH) BPMSVNOffset() uint64 {
	return s.BPMRevisionOffset() + s.BPMRevisionTotalSize()
}

// ACMSVNAuthOffset returns the offset in bytes of field ACMSVNAuth
func (s *BPMH) ACMSVNAuthOffset() uint64 {
	return s.BPMSVNOffset() + s.BPMSVNTotalSize()
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *BPMH) Reserved0Offset() uint64 {
	return s.ACMSVNAuthOffset() + s.ACMSVNAuthTotalSize()
}

// NEMDataStackOffset returns the offset in bytes of field NEMDataStack
func (s *BPMH) NEMDataStackOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// Size returns the total size of the BPMH.
func (s *BPMH) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.KeySignatureOffsetTotalSize()
	size += s.BPMRevisionTotalSize()
	size += s.BPMSVNTotalSize()
	size += s.ACMSVNAuthTotalSize()
	size += s.Reserved0TotalSize()
	size += s.NEMDataStackTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *BPMH) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "BPMH", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Signature Offset", "", &s.KeySignatureOffset, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "BPM Revision", "", &s.BPMRevision, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "BPM SVN", "", &s.BPMSVN, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "ACM SVN Auth", "", &s.ACMSVNAuth, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "NEM Data Stack", "", &s.NEMDataStack, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Size4K) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Size 4 K", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "In Bytes", "", v.InBytes(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v Size4K) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Size4K into 'w' in binary format.
func (v Size4K) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Size4K from 'r' in binary format.
func (v Size4K) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/manifest.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"bytes"
	"fmt"

	pkgbytes "github.com/linuxboot/fiano/pkg/bytes"
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// StructInfo is the common header of any element.
type StructInfo = cbnt.StructInfo

// Manifest is a boot policy manifest
//
// PrettyString: Boot Policy Manifest
type Manifest struct {
	// BPMH is the header of the boot policy manifest
	//
	// PrettyString: BPMH: Header
	BPMH `rehashValue:"rehashedBPMH()" json:"bpmHeader"`

	SE   []SE      `json:"bpmSE"`
	TXTE *TXT      `json:"bpmTXTE,omitempty"`
	Res  *Reserved `json:"bpmReserved,omitempty"`

	// PCDE is the platform configuration data element
	//
	// PrettyString: PCDE: Platform Config Data
	PCDE *PCD `json:"bpmPCDE,omitempty"`

	// PME is the platform manufacturer element
	//
	// PrettyString: PME: Platform Manufacturer
	PME *PM `json:"bpmPME,omitempty"`

	// PMSE is the signature element
	//
	// PrettyString: PMSE: Signature
	PMSE Signature `json:"bpmSignature"`
}

// StructInfo is the information about how to parse the structure.
func (bpm Manifest) StructInfo() StructInfo {
	return bpm.BPMH.StructInfo
}

// ValidateIBB returns an error if IBB segments does not match the signature
func (bpm *Manifest) ValidateIBB(firmware uefi.Firmware) error {
	if len(bpm.SE[0].DigestList.List) == 0 {
		return fmt.Errorf("no IBB hashes")
	}

	digest := bpm.SE[0].DigestList.List[0] // [0] instead of range -- is intentionally

	h, err := digest.HashAlg.Hash()
	if err != nil {
		return fmt.Errorf("invalid hash function: %v", digest.HashAlg)
	}

	for _, _range := range bpm.IBBDataRanges(uint64(len(firmware.Buf()))) {
		if _, err := h.Write(firmware.Buf()[_range.Offset:_range.End()]); err != nil {
			return fmt.Errorf("unable to hash: %w", err)
		}
	}
	hashValue := h.Sum(nil)

	if !bytes.Equal(hashValue, digest.HashBuffer) {
		return fmt.Errorf("IBB %s hash mismatch: %X != %X", digest.HashAlg, hashValue, digest.HashBuffer)
	}

	return nil
}

// IBBDataRanges returns data ranges of IBB.
func (bpm *Manifest) IBBDataRanges(firmwareSize uint64) pkgbytes.Ranges {
	var result pkgbytes.Ranges

	for _, seg := range bpm.SE[0].IBBSegments {
		if seg.Flags&1 == 1 {
			continue
		}
		startIdx := calculateOffsetFromPhysAddr(uint64(seg.Base), firmwareSize)
		result = append(result, pkgbytes.Range{Offset: startIdx, Length: uint64(seg.Size)})
	}

	return result
}

// calculateOffsetFromPhysAddr calculates the offset within an image
// of the physical address (address to a region mapped from
// the SPI chip).
//
// Examples:
//
//	calculateOffsetFromPhysAddr(0xffffffff, 0x1000) == 0xfff
//	calculateOffsetFromPhysAddr(0xffffffc0, 0x1000) == 0xfc0
func calculateOffsetFromPhysAddr(physAddr uint64, imageSize uint64) uint64 {
	const basePhysAddr = 1 << 32 // "4GiB"
	startAddr := basePhysAddr - imageSize
	return physAddr - startAddr
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/manifest_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewManifest returns a new instance of Manifest with
// all default values set.
func NewManifest() *Manifest {
	s := &Manifest{}
	// Recursively initializing a child structure:
	s.BPMH = *NewBPMH()
	// Recursively initializing a child structure:
	s.PMSE = *NewSignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Manifest) Validate() error {
	// Recursively validating a child structure:
	if err := s.BPMH.Validate(); err != nil {
		return fmt.Errorf("error on field 'BPMH': %w", err)
	}
	// See tag "rehashValue"
	{
		expectedValue := BPMH(s.rehashedBPMH())
		if s.BPMH != expectedValue {
			return fmt.Errorf("field 'BPMH' expects write-value '%v', but has %v", expectedValue, s.BPMH)
		}
	}
	// Recursively validating a child structure:
	if err := s.PMSE.Validate(); err != nil {
		return fmt.Errorf("error on field 'PMSE': %w", err)
	}

	return nil
}

// fieldIndexByStructID returns the position index within
// structure Manifest of the field by its StructureID
// (see document #575623, an example of StructureID value is "__KEYM__").
func (_ Manifest) fieldIndexByStructID(structID string) int {
	switch structID {
	case StructureIDBPMH:
		return 0
	case StructureIDSE:
		return 1
	case StructureIDTXT:
		return 2
	case StructureIDReserved:
		return 3
	case StructureIDPCD:
		return 4
	case StructureIDPM:
		return 5
	case StructureIDSignature:
		return 6
	}

	return -1
}

// fieldNameByIndex returns the name of the field by its position number
// within structure Manifest.
func (_ Manifest) fieldNameByIndex(fieldIndex int) string {
	switch fieldIndex {
	case 0:
		return "BPMH"
	case 1:
		return "SE"
	case 2:
		return "TXTE"
	case 3:
		return "Res"
	case 4:
		return "PCDE"
	case 5:
		return "PME"
	case 6:
		return "PMSE"
	}

	return fmt.Sprintf("invalidFieldIndex_%d", fieldIndex)
}

// ReadFrom reads the Manifest from 'r' in format defined in the document #575623.
func (s *Manifest) ReadFrom(r io.Reader) (returnN int64, returnErr error) {
	var missingFieldsByIndices = [7]bool{
		0: true,
		6: true,
	}
	defer func() {
		if returnErr != nil {
			return
		}
		for fieldIndex, v := range missingFieldsByIndices {
			if v {
				returnErr = fmt.Errorf("field '%s' is missing", s.fieldNameByIndex(fieldIndex))
				break
			}
		}
	}()
	var totalN int64
	previousFieldIndex := int(-1)
	for {
		var structInfo cbnt.StructInfo
		err := binary.Read(r, binary.LittleEndian, &structInfo)
		if err == io.EOF || err == io.ErrUnexpectedEOF {
			return totalN, nil
		}
		if err != nil {
			return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
		}
		totalN += int64(binary.Size(structInfo))

		structID := structInfo.ID.String()
		fieldIndex := s.fieldIndexByStructID(structID)
		if fieldIndex < 0 {
			// TODO: report error "unknown structure ID: '"+structID+"'"
			continue
		}
		if cbnt.StrictOrderCheck && fieldIndex < previousFieldIndex {
			return totalN, fmt.Errorf("invalid order of fields (%d < %d): structure '%s' is out of order", fieldIndex, previousFieldIndex, structID)
		}
		missingFieldsByIndices[fieldIndex] = false

		var n int64
		switch structID {
		case StructureIDBPMH:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'BPMH' is not a slice, but multiple elements found")
			}
			s.BPMH.SetStructInfo(structInfo)
			n, err = s.BPMH.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field BPMH at %d: %w", totalN, err)
			}
		case StructureIDSE:
			var el SE
			el.SetStructInfo(structInfo)
			n, err = el.ReadDataFrom(r)
			s.SE = append(s.SE, el)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field SE at %d: %w", totalN, err)
			}
		case StructureIDTXT:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'TXTE' is not a slice, but multiple elements found")
			}
			s.TXTE = &TXT{}
			s.TXTE.SetStructInfo(structInfo)
			n, err = s.TXTE.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field TXTE at %d: %w", totalN, err)
			}
		case StructureIDReserved:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'Res' is not a slice, but multiple elements found")
			}
			s.Res = &Reserved{}
			s.Res.SetStructInfo(structInfo)
			n, err = s.Res.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field Res at %d: %w", totalN, err)
			}
		case StructureIDPCD:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'PCDE' is not a slice, but multiple elements found")
			}
			s.PCDE = &PCD{}
			s.PCDE.SetStructInfo(structInfo)
			n, err = s.PCDE.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field PCDE at %d: %w", totalN, err)
			}
		case StructureIDPM:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'PME' is not a slice, but multiple elements found")
			}
			s.PME = &PM{}
			s.PME.SetStructInfo(structInfo)
			n, err = s.PME.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field PME at %d: %w", totalN, err)
			}
		case StructureIDSignature:
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field 'PMSE' is not a slice, but multiple elements found")
			}
			s.PMSE.SetStructInfo(structInfo)
			n, err = s.PMSE.ReadDataFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field PMSE at %d: %w", totalN, err)
			}
		default:
			return totalN, fmt.Errorf("there is no field with structure ID '%s' in Manifest", structInfo.ID)
		}
		totalN += n
		previousFieldIndex = fieldIndex
	}
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Manifest) RehashRecursive() {
	s.BPMH.Rehash()
	if s.TXTE != nil {
		s.TXTE.Rehash()
	}
	if s.Res != nil {
		s.Res.Rehash()
	}
	if s.PCDE != nil {
		s.PCDE.Rehash()
	}
	if s.PME != nil {
		s.PME.Rehash()
	}
	s.PMSE.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Manifest) Rehash() {
	s.BPMH = BPMH(s.rehashedBPMH())
}

// WriteTo writes the Manifest into 'w' in format defined in
// the document #575623.
func (s *Manifest) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// BPMH (ManifestFieldType: element)
	{
		n, err := s.BPMH.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'BPMH': %w", err)
		}
		totalN += int64(n)
	}

	// SE (ManifestFieldType: elementList)
	{
		for idx := range s.SE {
			n, err := s.SE[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'SE[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	// TXTE (ManifestFieldType: element)
	if s.TXTE != nil {
		n, err := s.TXTE.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'TXTE': %w", err)
		}
		totalN += int64(n)
	}

	// Res (ManifestFieldType: element)
	if s.Res != nil {
		n, err := s.Res.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Res': %w", err)
		}
		totalN += int64(n)
	}

	// PCDE (ManifestFieldType: element)
	if s.PCDE != nil {
		n, err := s.PCDE.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PCDE': %w", err)
		}
		totalN += int64(n)
	}

	// PME (ManifestFieldType: element)
	if s.PME != nil {
		n, err := s.PME.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PME': %w", err)
		}
		totalN += int64(n)
	}

	// PMSE (ManifestFieldType: element)
	{
		n, err := s.PMSE.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PMSE': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// BPMHSize returns the size in bytes of the value of field BPMH
func (s *Manifest) BPMHTotalSize() uint64 {
	return s.BPMH.TotalSize()
}

// SESize returns the size in bytes of the value of field SE
func (s *Manifest) SETotalSize() uint64 {
	var size uint64
	for idx := range s.SE {
		size += s.SE[idx].TotalSize()
	}
	return size
}

// TXTESize returns the size in bytes of the value of field TXTE
func (s *Manifest) TXTETotalSize() uint64 {
	return s.TXTE.TotalSize()
}

// ResSize returns the size in bytes of the value of field Res
func (s *Manifest) ResTotalSize() uint64 {
	return s.Res.TotalSize()
}

// PCDESize returns the size in bytes of the value of field PCDE
func (s *Manifest) PCDETotalSize() uint64 {
	return s.PCDE.TotalSize()
}

// PMESize returns the size in bytes of the value of field PME
func (s *Manifest) PMETotalSize() uint64 {
	return s.PME.TotalSize()
}

// PMSESize returns the size in bytes of the value of field PMSE
func (s *Manifest) PMSETotalSize() uint64 {
	return s.PMSE.TotalSize()
}

// BPMHOffset returns the offset in bytes of field BPMH
func (s *Manifest) BPMHOffset() uint64 {
	return 0
}

// SEOffset returns the offset in bytes of field SE
func (s *Manifest) SEOffset() uint64 {
	return s.BPMHOffset() + s.BPMHTotalSize()
}

// TXTEOffset returns the offset in bytes of field TXTE
func (s *Manifest) TXTEOffset() uint64 {
	return s.SEOffset() + s.SETotalSize()
}

// ResOffset returns the offset in bytes of field Res
func (s *Manifest) ResOffset() uint64 {
	return s.TXTEOffset() + s.TXTETotalSize()
}

// PCDEOffset returns the offset in bytes of field PCDE
func (s *Manifest) PCDEOffset() uint64 {
	return s.ResOffset() + s.ResTotalSize()
}

// PMEOffset returns the offset in bytes of field PME
func (s *Manifest) PMEOffset() uint64 {
	return s.PCDEOffset() + s.PCDETotalSize()
}

// PMSEOffset returns the offset in bytes of field PMSE
func (s *Manifest) PMSEOffset() uint64 {
	return s.PMEOffset() + s.PMETotalSize()
}

// Size returns the total size of the Manifest.
func (s *Manifest) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.BPMHTotalSize()
	size += s.SETotalSize()
	size += s.TXTETotalSize()
	size += s.ResTotalSize()
	size += s.PCDETotalSize()
	size += s.PMETotalSize()
	size += s.PMSETotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Manifest) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Boot Policy Manifest", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "BPMH: Header", "", &s.BPMH, opts...)...)
	// ManifestFieldType is elementList
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("SE: Array of \"Boot Policy Manifest\" of length %d", len(s.SE)), s.SE))
	for i := 0; i < len(s.SE); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.SE[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "TXTE", "", s.TXTE, opts...)...)
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "Res", "", s.Res, opts...)...)
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "PCDE: Platform Config Data", "", s.PCDE, opts...)...)
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "PME: Platform Manufacturer", "", s.PME, opts...)...)
	// ManifestFieldType is element
	lines = append(lines, pretty.SubValue(depth+1, "PMSE: Signature", "", &s.PMSE, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/manifest_nocodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

//
// To avoid errors "bpm.KeySignatureOffsetTotalSize undefined" and
// "bpm.BPMH.PrettyString undefined" we place these functions to a file
// with a build tag "!manifestcodegen"

package cbntbootpolicy

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

func (bpm *Manifest) rehashedBPMH() BPMH {
	bpmh := bpm.BPMH
	bpmh.KeySignatureOffset = uint16(bpm.PMSEOffset() + bpm.PMSE.KeySignatureOffset())
	return bpmh
}

// Print prints the Manifest
func (bpm Manifest) Print() {
	fmt.Printf("%v", bpm.BPMH.PrettyString(1, true))
	for _, item := range bpm.SE {
		fmt.Printf("%v", item.PrettyString(1, true))
	}
	if bpm.TXTE != nil {
		fmt.Printf("%v\n", bpm.TXTE.PrettyString(1, true))
	} else {
		fmt.Printf("  --TXTE--\n\t not set!(optional)\n")
	}

	if bpm.PCDE != nil {
		fmt.Printf("%v\n", bpm.PCDE.PrettyString(1, true))
	} else {
		fmt.Println("  --PCDE-- \n\tnot set!(optional)")
	}

	if bpm.PME != nil {
		fmt.Printf("%v\n", bpm.PME.PrettyString(1, true))
	} else {
		fmt.Println("  --PME--\n\tnot set!(optional)")
	}

	if bpm.PMSE.Signature.DataTotalSize() < 1 {
		fmt.Printf("%v\n", bpm.PMSE.PrettyString(1, true, pretty.OptionOmitKeySignature(true)))
		fmt.Printf("  --PMSE--\n\tBoot Policy Manifest not signed!\n\n")
	} else {
		fmt.Printf("%v\n", bpm.PMSE.PrettyString(1, true, pretty.OptionOmitKeySignature(false)))
	}
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/manifest_test.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbntbootpolicy

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/unittest"
)

func TestReadWrite(t *testing.T) {
	unittest.CBNTManifestReadWrite(t, &Manifest{}, "testdata/bpm.bin")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/pcd.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

// PCD holds various Platform Config Data.
type PCD struct {
	StructInfo `id:"__PCDS__" version:"0x20" var0:"0" var1:"uint16(s.TotalSize())"`
	Reserved0  [2]byte `json:"pcdReserved0,omitempty"`
	Data       []byte  `json:"pcdData"`
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/pcd_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewPCD returns a new instance of PCD with
// all default values set.
func NewPCD() *PCD {
	s := &PCD{}
	copy(s.StructInfo.ID[:], []byte(StructureIDPCD))
	s.StructInfo.Version = 0x20
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *PCD) Validate() error {

	return nil
}

// StructureIDPCD is the StructureID (in terms of
// the document #575623) of element 'PCD'.
const StructureIDPCD = "__PCDS__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PCD) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PCD) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the PCD from 'r' in format defined in the document #575623.
func (s *PCD) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the PCD from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *PCD) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		var size uint16
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *PCD) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *PCD) Rehash() {
	s.Variable0 = 0
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the PCD into 'w' in format defined in
// the document #575623.
func (s *PCD) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(len(s.Data))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *PCD) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *PCD) Reserved0TotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *PCD) DataTotalSize() uint64 {
	size := uint64(binary.Size(uint16(0)))
	size += uint64(len(s.Data))
	return size
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *PCD) StructInfoOffset() uint64 {
	return 0
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *PCD) Reserved0Offset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *PCD) DataOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// Size returns the total size of the PCD.
func (s *PCD) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.Reserved0TotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *PCD) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "PCD", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", &s.Data, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/pm.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

// PM is the platform manufacturer data element
type PM struct {
	StructInfo `id:"__PMDA__" version:"0x20" var0:"0" var1:"uint16(s.TotalSize())"`
	Reserved0  [2]byte `require:"0" json:"pcReserved0,omitempty"`
	Data       []byte  `json:"pcData"`
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/pm_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewPM returns a new instance of PM with
// all default values set.
func NewPM() *PM {
	s := &PM{}
	copy(s.StructInfo.ID[:], []byte(StructureIDPM))
	s.StructInfo.Version = 0x20
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *PM) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}

	return nil
}

// StructureIDPM is the StructureID (in terms of
// the document #575623) of element 'PM'.
const StructureIDPM = "__PMDA__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PM) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *PM) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the PM from 'r' in format defined in the document #575623.
func (s *PM) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the PM from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *PM) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		var size uint16
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *PM) RehashRecursive() {
	s.StructInfo.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *PM) Rehash() {
	s.Variable0 = 0
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the PM into 'w' in format defined in
// the document #575623.
func (s *PM) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(len(s.Data))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field 'Data': %w", err)
		}
		totalN += int64(binary.Size(size))
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *PM) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *PM) Reserved0TotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *PM) DataTotalSize() uint64 {
	size := uint64(binary.Size(uint16(0)))
	size += uint64(len(s.Data))
	return size
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *PM) StructInfoOffset() uint64 {
	return 0
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *PM) Reserved0Offset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *PM) DataOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// Size returns the total size of the PM.
func (s *PM) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.Reserved0TotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *PM) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "PM", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", &s.Data, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/se.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"fmt"
	"math"
	"time"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// SE is an IBB segments element
//
// PrettyString: IBB Segments Element
type SE struct {
	StructInfo `id:"__IBBS__" version:"0x20" var0:"0" var1:"uint16(s.TotalSize())"`
	Reserved0  [1]byte   `require:"0" json:"seReserved0,omitempty"`
	SetNumber  uint8     `require:"0" json:"seSetNumber,omitempty"`
	Reserved1  [1]byte   `require:"0" json:"seReserved1,omitempty"`
	PBETValue  PBETValue `json:"sePBETValue"`
	Flags      SEFlags   `json:"seFlags"`

	// IBBMCHBAR <TO BE DOCUMENTED>
	// PrettyString: IBB MCHBAR
	IBBMCHBAR uint64 `json:"seIBBMCHBAR"`

	// VTdBAR <TO BE DOCUMENTED>
	// PrettyString: VT-d BAR
	VTdBAR uint64 `json:"seVTdBAR"`

	// DMAProtBase0 <TO BE DOCUMENTED>
	// PrettyString: DMA Protection 0 Base Address
	DMAProtBase0 uint32 `json:"seDMAProtBase0"`

	// DMAProtLimit0 <TO BE DOCUMENTED>
	// PrettyString: DMA Protection 0 Limit Address
	DMAProtLimit0 uint32 `json:"seDMAProtLimit0"`

	// DMAProtBase1 <TO BE DOCUMENTED>
	// PrettyString: DMA Protection 1 Base Address
	DMAProtBase1 uint64 `json:"seDMAProtBase1"`

	// DMAProtLimit1 <TO BE DOCUMENTED>
	// PrettyString: DMA Protection 2 Limit Address
	DMAProtLimit1 uint64 `json:"seDMAProtLimit1"`

	PostIBBHash cbnt.HashStructure `json:"sePostIBBHash"`

	IBBEntryPoint uint32 `json:"seIBBEntry"`

	DigestList cbnt.HashList `json:"seDigestList"`

	OBBHash cbnt.HashStructure `json:"seOBBHash"`

	Reserved2 [3]byte `require:"0" json:"seReserved2,omitempty"`

	IBBSegments []IBBSegment `countType:"uint8" json:"seIBBSegments,omitempty"`
}

// PBETValue <TO BE DOCUMENTED>
type PBETValue uint8

// PBETValue returns the raw value of the timer setting.
func (pbet PBETValue) PBETValue() uint8 {
	return uint8(pbet) & 0x0f
}

// Duration returns the value as time.Duration.
func (pbet PBETValue) Duration() time.Duration {
	v := pbet.PBETValue()
	if v == 0 {
		return math.MaxInt64
	}
	return time.Second * time.Duration(5+v)
}

// SetDuration sets the value using standard time.Duration as the input.
func (pbet *PBETValue) SetDuration(duration time.Duration) time.Duration {
	v := duration.Nanoseconds()/time.Second.Nanoseconds() - 5
	if v <= 0 {
		v = 1
	}
	if v >= 16 {
		v = 0
	}
	*pbet = PBETValue(v)

	return pbet.Duration()
}

// SEFlags <TO BE DOCUMENTED>
type SEFlags uint32

// Reserved0 <TO BE DOCUMENTED>
func (flags SEFlags) Reserved0() uint32 {
	return uint32(flags & 0xffffffe0)
}

// SupportsTopSwapRemediation <TO BE DOCUMENTED>
//
// PrettyString-true:  BIOS supports Top Swap remediation action
// PrettyString-false: BIOS does not support Top Swap remediation action
func (flags SEFlags) SupportsTopSwapRemediation() bool {
	return flags&0x10 != 0
}

// TPMFailureLeavesHierarchiesEnabled <TO BE DOCUMENTED>
//
// PrettyString-true:  Leave Hierarchies enabled. Cap all PCRs on failure.
// PrettyString-false: Do not leave enabled. Disable all Hierarchies or deactivate on failure.
func (flags SEFlags) TPMFailureLeavesHierarchiesEnabled() bool {
	return flags&0x08 != 0
}

// AuthorityMeasure <TO BE DOCUMENTED>
//
// PrettyString-true:  Extend Authority Measurements into the Authority PCR 7
// PrettyString-false: Do not extend into the Authority PCR 7
func (flags SEFlags) AuthorityMeasure() bool {
	return flags&0x04 != 0
}

// Locality3Startup <TO BE DOCUMENTED>
//
// PrettyString-true:  Issue TPM Start-up from Locality 3
// PrettyString-false: Disabled
func (flags SEFlags) Locality3Startup() bool {
	return flags&0x02 != 0
}

// DMAProtection <TO BE DOCUMENTED>
//
// PrettyString-true:  Enable DMA Protection
// PrettyString-false: Disable DMA Protection
func (flags SEFlags) DMAProtection() bool {
	return flags&0x01 != 0
}

// IBBSegment defines a single IBB segment
type IBBSegment struct {
	Reserved [2]byte `require:"0" json:"ibbSegReserved"`
	Flags    uint16  `json:"ibbSegFlags"`
	Base     uint32  `json:"ibbSegBase"`
	Size     uint32  `json:"ibbSegSize"`
}

// CachingType <TO BE DOCUMENTED>
type CachingType uint8

// <TO BE DOCUMENTED>
const (
	CachingTypeWriteProtect = CachingType(iota)
	CachingTypeWriteBack
	CachingTypeReserved0
	CachingTypeReserved1
)

// String implements fmt.Stringer.
func (c CachingType) String() string {
	switch c {
	case CachingTypeWriteProtect:
		return "write_protect"
	case CachingTypeWriteBack:
		return "write_back"
	case CachingTypeReserved0:
		return "value_0x02"
	case CachingTypeReserved1:
		return "value_0x03"
	}
	return fmt.Sprintf("unexpected_value_0x%02X", uint8(c))
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/se_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewIBBSegment returns a new instance of IBBSegment with
// all default values set.
func NewIBBSegment() *IBBSegment {
	s := &IBBSegment{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *IBBSegment) Validate() error {
	// See tag "require"
	for idx := range s.Reserved {
		if s.Reserved[idx] != 0 {
			return fmt.Errorf("'Reserved[%d]' is expected to be 0, but it is %v", idx, s.Reserved[idx])
		}
	}

	return nil
}

// ReadFrom reads the IBBSegment from 'r' in format defined in the document #575623.
func (s *IBBSegment) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Reserved (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, s.Reserved[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// Base (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Base)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// Size (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *IBBSegment) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *IBBSegment) Rehash() {
}

// WriteTo writes the IBBSegment into 'w' in format defined in
// the document #575623.
func (s *IBBSegment) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Reserved (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, s.Reserved[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// Base (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Base)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// Size (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// ReservedSize returns the size in bytes of the value of field Reserved
func (s *IBBSegment) ReservedTotalSize() uint64 {
	return 2
}

// FlagsSize returns the size in bytes of the value of field Flags
func (s *IBBSegment) FlagsTotalSize() uint64 {
	return 2
}

// BaseSize returns the size in bytes of the value of field Base
func (s *IBBSegment) BaseTotalSize() uint64 {
	return 4
}

// SizeSize returns the size in bytes of the value of field Size
func (s *IBBSegment) SizeTotalSize() uint64 {
	return 4
}

// ReservedOffset returns the offset in bytes of field Reserved
func (s *IBBSegment) ReservedOffset() uint64 {
	return 0
}

// FlagsOffset returns the offset in bytes of field Flags
func (s *IBBSegment) FlagsOffset() uint64 {
	return s.ReservedOffset() + s.ReservedTotalSize()
}

// BaseOffset returns the offset in bytes of field Base
func (s *IBBSegment) BaseOffset() uint64 {
	return s.FlagsOffset() + s.FlagsTotalSize()
}

// SizeOffset returns the offset in bytes of field Size
func (s *IBBSegment) SizeOffset() uint64 {
	return s.BaseOffset() + s.BaseTotalSize()
}

// Size returns the total size of the IBBSegment.
func (s *IBBSegment) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.ReservedTotalSize()
	size += s.FlagsTotalSize()
	size += s.BaseTotalSize()
	size += s.SizeTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *IBBSegment) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "IBB Segment", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved", "", &s.Reserved, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Flags", "", &s.Flags, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Base", "", &s.Base, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Size", "", &s.Size, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// NewSE returns a new instance of SE with
// all default values set.
func NewSE() *SE {
	s := &SE{}
	copy(s.StructInfo.ID[:], []byte(StructureIDSE))
	s.StructInfo.Version = 0x20
	// Set through tag "required":
	s.SetNumber = 0
	// Recursively initializing a child structure:
	s.PostIBBHash = *cbnt.NewHashStructure()
	// Recursively initializing a child structure:
	s.DigestList = *cbnt.NewHashList()
	// Recursively initializing a child structure:
	s.OBBHash = *cbnt.NewHashStructure()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *SE) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}
	// See tag "require"
	if s.SetNumber != 0 {
		return fmt.Errorf("field 'SetNumber' expects value '0', but has %v", s.SetNumber)
	}
	// See tag "require"
	for idx := range s.Reserved1 {
		if s.Reserved1[idx] != 0 {
			return fmt.Errorf("'Reserved1[%d]' is expected to be 0, but it is %v", idx, s.Reserved1[idx])
		}
	}
	// Recursively validating a child structure:
	if err := s.PostIBBHash.Validate(); err != nil {
		return fmt.Errorf("error on field 'PostIBBHash': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.DigestList.Validate(); err != nil {
		return fmt.Errorf("error on field 'DigestList': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.OBBHash.Validate(); err != nil {
		return fmt.Errorf("error on field 'OBBHash': %w", err)
	}
	// See tag "require"
	for idx := range s.Reserved2 {
		if s.Reserved2[idx] != 0 {
			return fmt.Errorf("'Reserved2[%d]' is expected to be 0, but it is %v", idx, s.Reserved2[idx])
		}
	}

	return nil
}

// StructureIDSE is the StructureID (in terms of
// the document #575623) of element 'SE'.
const StructureIDSE = "__IBBS__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *SE) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *SE) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the SE from 'r' in format defined in the document #575623.
func (s *SE) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the SE from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *SE) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// SetNumber (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.SetNumber)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SetNumber': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// PBETValue (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.PBETValue)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PBETValue': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// IBBMCHBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.IBBMCHBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'IBBMCHBAR': %w", err)
		}
		totalN += int64(n)
	}

	// VTdBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.VTdBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'VTdBAR': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtBase0 (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.DMAProtBase0)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DMAProtBase0': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtLimit0 (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.DMAProtLimit0)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DMAProtLimit0': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtBase1 (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.DMAProtBase1)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DMAProtBase1': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtLimit1 (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.DMAProtLimit1)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DMAProtLimit1': %w", err)
		}
		totalN += int64(n)
	}

	// PostIBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.PostIBBHash.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PostIBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// IBBEntryPoint (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.IBBEntryPoint)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'IBBEntryPoint': %w", err)
		}
		totalN += int64(n)
	}

	// DigestList (ManifestFieldType: subStruct)
	{
		n, err := s.DigestList.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DigestList': %w", err)
		}
		totalN += int64(n)
	}

	// OBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.OBBHash.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'OBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Read(r, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// IBBSegments (ManifestFieldType: list)
	{
		var count uint8
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field 'IBBSegments': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.IBBSegments = make([]IBBSegment, count)

		for idx := range s.IBBSegments {
			n, err := s.IBBSegments[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field 'IBBSegments[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *SE) RehashRecursive() {
	s.StructInfo.Rehash()
	s.PostIBBHash.Rehash()
	s.DigestList.Rehash()
	s.OBBHash.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *SE) Rehash() {
	s.Variable0 = 0
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the SE into 'w' in format defined in
// the document #575623.
func (s *SE) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// SetNumber (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.SetNumber)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SetNumber': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// PBETValue (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.PBETValue)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PBETValue': %w", err)
		}
		totalN += int64(n)
	}

	// Flags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Flags)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Flags': %w", err)
		}
		totalN += int64(n)
	}

	// IBBMCHBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.IBBMCHBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'IBBMCHBAR': %w", err)
		}
		totalN += int64(n)
	}

	// VTdBAR (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.VTdBAR)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'VTdBAR': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtBase0 (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.DMAProtBase0)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DMAProtBase0': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtLimit0 (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.DMAProtLimit0)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DMAProtLimit0': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtBase1 (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.DMAProtBase1)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DMAProtBase1': %w", err)
		}
		totalN += int64(n)
	}

	// DMAProtLimit1 (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.DMAProtLimit1)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DMAProtLimit1': %w", err)
		}
		totalN += int64(n)
	}

	// PostIBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.PostIBBHash.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PostIBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// IBBEntryPoint (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.IBBEntryPoint)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'IBBEntryPoint': %w", err)
		}
		totalN += int64(n)
	}

	// DigestList (ManifestFieldType: subStruct)
	{
		n, err := s.DigestList.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DigestList': %w", err)
		}
		totalN += int64(n)
	}

	// OBBHash (ManifestFieldType: subStruct)
	{
		n, err := s.OBBHash.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'OBBHash': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Write(w, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// IBBSegments (ManifestFieldType: list)
	{
		count := uint8(len(s.IBBSegments))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field 'IBBSegments': %w", err)
		}
		totalN += int64(binary.Size(count))
		for idx := range s.IBBSegments {
			n, err := s.IBBSegments[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'IBBSegments[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *SE) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *SE) Reserved0TotalSize() uint64 {
	return 1
}

// SetNumberSize returns the size in bytes of the value of field SetNumber
func (s *SE) SetNumberTotalSize() uint64 {
	return 1
}

// Reserved1Size returns the size in bytes of the value of field Reserved1
func (s *SE) Reserved1TotalSize() uint64 {
	return 1
}

// PBETValueSize returns the size in bytes of the value of field PBETValue
func (s *SE) PBETValueTotalSize() uint64 {
	return 1
}

// FlagsSize returns the size in bytes of the value of field Flags
func (s *SE) FlagsTotalSize() uint64 {
	return 4
}

// IBBMCHBARSize returns the size in bytes of the value of field IBBMCHBAR
func (s *SE) IBBMCHBARTotalSize() uint64 {
	return 8
}

// VTdBARSize returns the size in bytes of the value of field VTdBAR
func (s *SE) VTdBARTotalSize() uint64 {
	return 8
}

// DMAProtBase0Size returns the size in bytes of the value of field DMAProtBase0
func (s *SE) DMAProtBase0TotalSize() uint64 {
	return 4
}

// DMAProtLimit0Size returns the size in bytes of the value of field DMAProtLimit0
func (s *SE) DMAProtLimit0TotalSize() uint64 {
	return 4
}

// DMAProtBase1Size returns the size in bytes of the value of field DMAProtBase1
func (s *SE) DMAProtBase1TotalSize() uint64 {
	return 8
}

// DMAProtLimit1Size returns the size in bytes of the value of field DMAProtLimit1
func (s *SE) DMAProtLimit1TotalSize() uint64 {
	return 8
}

// PostIBBHashSize returns the size in bytes of the value of field PostIBBHash
func (s *SE) PostIBBHashTotalSize() uint64 {
	return s.PostIBBHash.TotalSize()
}

// IBBEntryPointSize returns the size in bytes of the value of field IBBEntryPoint
func (s *SE) IBBEntryPointTotalSize() uint64 {
	return 4
}

// DigestListSize returns the size in bytes of the value of field DigestList
func (s *SE) DigestListTotalSize() uint64 {
	return s.DigestList.TotalSize()
}

// OBBHashSize returns the size in bytes of the value of field OBBHash
func (s *SE) OBBHashTotalSize() uint64 {
	return s.OBBHash.TotalSize()
}

// Reserved2Size returns the size in bytes of the value of field Reserved2
func (s *SE) Reserved2TotalSize() uint64 {
	return 3
}

// IBBSegmentsSize returns the size in bytes of the value of field IBBSegments
func (s *SE) IBBSegmentsTotalSize() uint64 {
	var size uint64
	size += uint64(binary.Size(uint8(0)))
	for idx := range s.IBBSegments {
		size += s.IBBSegments[idx].TotalSize()
	}
	return size
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *SE) StructInfoOffset() uint64 {
	return 0
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *SE) Reserved0Offset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// SetNumberOffset returns the offset in bytes of field SetNumber
func (s *SE) SetNumberOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// Reserved1Offset returns the offset in bytes of field Reserved1
func (s *SE) Reserved1Offset() uint64 {
	return s.SetNumberOffset() + s.SetNumberTotalSize()
}

// PBETValueOffset returns the offset in bytes of field PBETValue
func (s *SE) PBETValueOffset() uint64 {
	return s.Reserved1Offset() + s.Reserved1TotalSize()
}

// FlagsOffset returns the offset in bytes of field Flags
func (s *SE) FlagsOffset() uint64 {
	return s.PBETValueOffset() + s.PBETValueTotalSize()
}

// IBBMCHBAROffset returns the offset in bytes of field IBBMCHBAR
func (s *SE) IBBMCHBAROffset() uint64 {
	return s.FlagsOffset() + s.FlagsTotalSize()
}

// VTdBAROffset returns the offset in bytes of field VTdBAR
func (s *SE) VTdBAROffset() uint64 {
	return s.IBBMCHBAROffset() + s.IBBMCHBARTotalSize()
}

// DMAProtBase0Offset returns the offset in bytes of field DMAProtBase0
func (s *SE) DMAProtBase0Offset() uint64 {
	return s.VTdBAROffset() + s.VTdBARTotalSize()
}

// DMAProtLimit0Offset returns the offset in bytes of field DMAProtLimit0
func (s *SE) DMAProtLimit0Offset() uint64 {
	return s.DMAProtBase0Offset() + s.DMAProtBase0TotalSize()
}

// DMAProtBase1Offset returns the offset in bytes of field DMAProtBase1
func (s *SE) DMAProtBase1Offset() uint64 {
	return s.DMAProtLimit0Offset() + s.DMAProtLimit0TotalSize()
}

// DMAProtLimit1Offset returns the offset in bytes of field DMAProtLimit1
func (s *SE) DMAProtLimit1Offset() uint64 {
	return s.DMAProtBase1Offset() + s.DMAProtBase1TotalSize()
}

// PostIBBHashOffset returns the offset in bytes of field PostIBBHash
func (s *SE) PostIBBHashOffset() uint64 {
	return s.DMAProtLimit1Offset() + s.DMAProtLimit1TotalSize()
}

// IBBEntryPointOffset returns the offset in bytes of field IBBEntryPoint
func (s *SE) IBBEntryPointOffset() uint64 {
	return s.PostIBBHashOffset() + s.PostIBBHashTotalSize()
}

// DigestListOffset returns the offset in bytes of field DigestList
func (s *SE) DigestListOffset() uint64 {
	return s.IBBEntryPointOffset() + s.IBBEntryPointTotalSize()
}

// OBBHashOffset returns the offset in bytes of field OBBHash
func (s *SE) OBBHashOffset() uint64 {
	return s.DigestListOffset() + s.DigestListTotalSize()
}

// Reserved2Offset returns the offset in bytes of field Reserved2
func (s *SE) Reserved2Offset() uint64 {
	return s.OBBHashOffset() + s.OBBHashTotalSize()
}

// IBBSegmentsOffset returns the offset in bytes of field IBBSegments
func (s *SE) IBBSegmentsOffset() uint64 {
	return s.Reserved2Offset() + s.Reserved2TotalSize()
}

// Size returns the total size of the SE.
func (s *SE) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.Reserved0TotalSize()
	size += s.SetNumberTotalSize()
	size += s.Reserved1TotalSize()
	size += s.PBETValueTotalSize()
	size += s.FlagsTotalSize()
	size += s.IBBMCHBARTotalSize()
	size += s.VTdBARTotalSize()
	size += s.DMAProtBase0TotalSize()
	size += s.DMAProtLimit0TotalSize()
	size += s.DMAProtBase1TotalSize()
	size += s.DMAProtLimit1TotalSize()
	size += s.PostIBBHashTotalSize()
	size += s.IBBEntryPointTotalSize()
	size += s.DigestListTotalSize()
	size += s.OBBHashTotalSize()
	size += s.Reserved2TotalSize()
	size += s.IBBSegmentsTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *SE) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "IBB Segments Element", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Set Number", "", &s.SetNumber, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 1", "", &s.Reserved1, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "PBET Value", "", &s.PBETValue, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Flags", "", &s.Flags, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "IBB MCHBAR", "", &s.IBBMCHBAR, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "VT-d BAR", "", &s.VTdBAR, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 0 Base Address", "", &s.DMAProtBase0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 0 Limit Address", "", &s.DMAProtLimit0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 1 Base Address", "", &s.DMAProtBase1, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "DMA Protection 2 Limit Address", "", &s.DMAProtLimit1, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Post IBB Hash", "", &s.PostIBBHash, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "IBB Entry Point", "", &s.IBBEntryPoint, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Digest List", "", &s.DigestList, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "OBB Hash", "", &s.OBBHash, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 2", "", &s.Reserved2, opts...)...)
	// ManifestFieldType is list
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("IBBSegments: Array of \"IBB Segments Element\" of length %d", len(s.IBBSegments)), s.IBBSegments))
	for i := 0; i < len(s.IBBSegments); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.IBBSegments[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v CachingType) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v CachingType) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the CachingType into 'w' in binary format.
func (v CachingType) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the CachingType from 'r' in binary format.
func (v CachingType) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v PBETValue) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "PBET Value", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "PBET Value", "", v.PBETValue(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v PBETValue) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the PBETValue into 'w' in binary format.
func (v PBETValue) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the PBETValue from 'r' in binary format.
func (v PBETValue) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v SEFlags) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "SE Flags", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", v.Reserved0(), opts...)...)
	if v.SupportsTopSwapRemediation() {
		lines = append(lines, pretty.SubValue(depth+1, "Supports Top Swap Remediation", "BIOS supports Top Swap remediation action", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Supports Top Swap Remediation", "BIOS does not support Top Swap remediation action", false, opts...)...)
	}
	if v.TPMFailureLeavesHierarchiesEnabled() {
		lines = append(lines, pretty.SubValue(depth+1, "TPM Failure Leaves Hierarchies Enabled", "Leave Hierarchies enabled. Cap all PCRs on failure.", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "TPM Failure Leaves Hierarchies Enabled", "Do not leave enabled. Disable all Hierarchies or deactivate on failure.", false, opts...)...)
	}
	if v.AuthorityMeasure() {
		lines = append(lines, pretty.SubValue(depth+1, "Authority Measure", "Extend Authority Measurements into the Authority PCR 7", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Authority Measure", "Do not extend into the Authority PCR 7", false, opts...)...)
	}
	if v.Locality3Startup() {
		lines = append(lines, pretty.SubValue(depth+1, "Locality 3 Startup", "Issue TPM Start-up from Locality 3", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Locality 3 Startup", "Disabled", false, opts...)...)
	}
	if v.DMAProtection() {
		lines = append(lines, pretty.SubValue(depth+1, "DMA Protection", "Enable DMA Protection", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "DMA Protection", "Disable DMA Protection", false, opts...)...)
	}
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v SEFlags) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the SEFlags into 'w' in binary format.
func (v SEFlags) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the SEFlags from 'r' in binary format.
func (v SEFlags) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/signature.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// Signature contains the signature of the BPM.
type Signature struct {
	StructInfo        `id:"__PMSG__" version:"0x20" var0:"0" var1:"0"`
	cbnt.KeySignature `json:"sigKeySignature"`
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewSignature returns a new instance of Signature with
// all default values set.
func NewSignature() *Signature {
	s := &Signature{}
	copy(s.StructInfo.ID[:], []byte(StructureIDSignature))
	s.StructInfo.Version = 0x20
	// Recursively initializing a child structure:
	s.KeySignature = *cbnt.NewKeySignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Signature) Validate() error {
	// Recursively validating a child structure:
	if err := s.KeySignature.Validate(); err != nil {
		return fmt.Errorf("error on field 'KeySignature': %w", err)
	}

	return nil
}

// StructureIDSignature is the StructureID (in terms of
// the document #575623) of element 'Signature'.
const StructureIDSignature = "__PMSG__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Signature) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Signature) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the Signature from 'r' in format defined in the document #575623.
func (s *Signature) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the Signature from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *Signature) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// KeySignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeySignature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Signature) RehashRecursive() {
	s.StructInfo.Rehash()
	s.KeySignature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Signature) Rehash() {
	s.Variable0 = 0
	s.ElementSize = 0
}

// WriteTo writes the Signature into 'w' in format defined in
// the document #575623.
func (s *Signature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// KeySignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeySignature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *Signature) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// KeySignatureSize returns the size in bytes of the value of field KeySignature
func (s *Signature) KeySignatureTotalSize() uint64 {
	return s.KeySignature.TotalSize()
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *Signature) StructInfoOffset() uint64 {
	return 0
}

// KeySignatureOffset returns the offset in bytes of field KeySignature
func (s *Signature) KeySignatureOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// Size returns the total size of the Signature.
func (s *Signature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.KeySignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Signature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key Signature", "", &s.KeySignature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/txt.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"fmt"
	"time"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// TXT is the TXT element
type TXT struct {
	StructInfo      `id:"__TXTS__" version:"0x21" var0:"0" var1:"uint16(s.TotalSize())"`
	Reserved0       [1]byte          `require:"0" json:"txtReserved0,omitempty"`
	SetNumber       [1]byte          `require:"0" json:"txtSetNumer,omitempty"`
	SInitMinSVNAuth uint8            `default:"0" json:"txtSVN"`
	Reserved1       [1]byte          `require:"0" json:"txtReserved1,omitempty"`
	ControlFlags    TXTControlFlags  `json:"txtFlags"`
	PwrDownInterval Duration16In5Sec `json:"txtPwrDownInterval"`
	// PrettyString: PTT CMOS Offset 0
	PTTCMOSOffset0 uint8 `default:"126" json:"txtPTTCMOSOffset0"`
	// PrettyString: PTT CMOS Offset 1
	PTTCMOSOffset1 uint8   `default:"127" json:"txtPTTCMOSOffset1"`
	ACPIBaseOffset uint16  `default:"0x400" json:"txtACPIBaseOffset,omitempty"`
	Reserved2      [2]byte `json:"txtReserved2,omitempty"`
	// PrettyString: ACPI MMIO Offset
	PwrMBaseOffset uint32        `default:"0xFE000000" json:"txtPwrMBaseOffset,omitempty"`
	DigestList     cbnt.HashList `json:"txtDigestList"`
	Reserved3      [3]byte       `require:"0" json:"txtReserved3,omitempty"`

	SegmentCount uint8 `require:"0" json:"txtSegmentCount,omitempty"`
}

// Duration16In5Sec exports the custom type Duration16In5Sec
type Duration16In5Sec uint16

// Duration calculates a given time in multiple of 5 seconds.
func (d Duration16In5Sec) Duration() time.Duration {
	return time.Second * 5 * time.Duration(d)
}

func (d Duration16In5Sec) String() string {
	if d == 0 {
		return "0 (infinite)"
	}
	return fmt.Sprintf("%d (%s)", d, d.Duration().String())
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/txt_control_flags.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntbootpolicy

import (
	"fmt"
)

type TXTControlFlags uint32

func (flags TXTControlFlags) ExecutionProfile() ExecutionProfile {
	return ExecutionProfile(flags & 0x1f)
}

type ExecutionProfile uint8

const (
	ExecutionProfileA = ExecutionProfile(iota)
	ExecutionProfileB
	ExecutionProfileC
)

// String just implements fmt.Stringer.
func (p ExecutionProfile) String() string {
	switch p {
	case ExecutionProfileA:
		return `A (use default selection based on differentation between clients, UP, and MP servers)`
	case ExecutionProfileB:
		return `B (use "Server model": rely on BIOS to configure topoligy; do not use ACHECK)`
	case ExecutionProfileC:
		return `C (use "Client model": do not measure BIOS into D-PCRs; use ACHECK-based alias check)`
	}
	return fmt.Sprintf("unexpected_execution_profile_value_0x%02X", uint8(p))
}

func (flags TXTControlFlags) MemoryScrubbingPolicy() MemoryScrubbingPolicy {
	return MemoryScrubbingPolicy((flags >> 5) & 0x3)
}

type MemoryScrubbingPolicy uint8

const (
	MemoryScrubbingPolicyDefault = MemoryScrubbingPolicy(iota)
	MemoryScrubbingPolicyBIOS
	MemoryScrubbingPolicySACM
)

// String implements fmt.Stringer.
func (policy MemoryScrubbingPolicy) String() string {
	switch policy {
	case MemoryScrubbingPolicyDefault:
		return "BIOS if verified or backup action othersize"
	case MemoryScrubbingPolicyBIOS:
		return "BIOS"
	case MemoryScrubbingPolicySACM:
		return "S-ACM"
	}
	return fmt.Sprintf("unexpected_value_0x%02X", uint8(policy))
}

func (flags TXTControlFlags) BackupActionPolicy() BackupActionPolicy {
	return BackupActionPolicy((flags >> 7) & 0x3)
}

type BackupActionPolicy uint8

const (
	BackupActionPolicyDefault = BackupActionPolicy(iota)
	BackupActionPolicyForceMemoryPowerDown
	BackupActionPolicyForceBtGUnbreakableShutdown
)

// String implements fmt.Stringer.
func (policy BackupActionPolicy) String() string {
	switch policy {
	case BackupActionPolicyDefault:
		return "memory power down if profile D or BtG unbreakable shutdown otherwise"
	case BackupActionPolicyForceMemoryPowerDown:
		return "memory power down"
	case BackupActionPolicyForceBtGUnbreakableShutdown:
		return "BtG unbreakable shutdown"
	}
	return fmt.Sprintf("unexpected_value_0x%02X", uint8(policy))
}

// PrettyString-true:  Default setting. S-ACM is requested to extend static PCRs
// PrettyString-false: S-ACM is not requested to extend static PCRs
func (flags TXTControlFlags) IsSACMRequestedToExtendStaticPCRs() bool {
	return (flags>>9)&0x01 == 0
}

func (flags TXTControlFlags) ResetAUXControl() ResetAUXControl {
	return ResetAUXControl((flags >> 31) & 0x01)
}

type ResetAUXControl uint8

const (
	ResetAUXControlResetAUXIndex = ResetAUXControl(iota)
	ResetAUXControlDeleteAUXIndex
)

// String implements fmt.Stringer.
func (c ResetAUXControl) String() string {
	switch c {
	case ResetAUXControlResetAUXIndex:
		return "AUX reset leaf will reset AUX index"
	case ResetAUXControlDeleteAUXIndex:
		return "AUX reset leaf will delete AUX index"
	}
	return fmt.Sprintf("unexpected_value_0x%02X", uint8(c))
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/txt_control_flags_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v BackupActionPolicy) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v BackupActionPolicy) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the BackupActionPolicy into 'w' in binary format.
func (v BackupActionPolicy) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the BackupActionPolicy from 'r' in binary format.
func (v BackupActionPolicy) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v ExecutionProfile) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v ExecutionProfile) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the ExecutionProfile into 'w' in binary format.
func (v ExecutionProfile) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the ExecutionProfile from 'r' in binary format.
func (v ExecutionProfile) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v MemoryScrubbingPolicy) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v MemoryScrubbingPolicy) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the MemoryScrubbingPolicy into 'w' in binary format.
func (v MemoryScrubbingPolicy) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the MemoryScrubbingPolicy from 'r' in binary format.
func (v MemoryScrubbingPolicy) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v ResetAUXControl) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v ResetAUXControl) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the ResetAUXControl into 'w' in binary format.
func (v ResetAUXControl) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the ResetAUXControl from 'r' in binary format.
func (v ResetAUXControl) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v TXTControlFlags) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TXT Control Flags", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "Execution Profile", "", v.ExecutionProfile(), opts...)...)
	lines = append(lines, pretty.SubValue(depth+1, "Memory Scrubbing Policy", "", v.MemoryScrubbingPolicy(), opts...)...)
	lines = append(lines, pretty.SubValue(depth+1, "Backup Action Policy", "", v.BackupActionPolicy(), opts...)...)
	if v.IsSACMRequestedToExtendStaticPCRs() {
		lines = append(lines, pretty.SubValue(depth+1, "Is SACM Requested To Extend Static PC Rs", "Default setting. S-ACM is requested to extend static PCRs", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Is SACM Requested To Extend Static PC Rs", "S-ACM is not requested to extend static PCRs", false, opts...)...)
	}
	lines = append(lines, pretty.SubValue(depth+1, "Reset AUX Control", "", v.ResetAUXControl(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v TXTControlFlags) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the TXTControlFlags into 'w' in binary format.
func (v TXTControlFlags) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the TXTControlFlags from 'r' in binary format.
func (v TXTControlFlags) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntbootpolicy/txt_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy

package cbntbootpolicy

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewTXT returns a new instance of TXT with
// all default values set.
func NewTXT() *TXT {
	s := &TXT{}
	copy(s.StructInfo.ID[:], []byte(StructureIDTXT))
	s.StructInfo.Version = 0x21
	// Set through tag "default":
	s.SInitMinSVNAuth = 0
	// Set through tag "default":
	s.PTTCMOSOffset0 = 126
	// Set through tag "default":
	s.PTTCMOSOffset1 = 127
	// Set through tag "default":
	s.ACPIBaseOffset = 0x400
	// Set through tag "default":
	s.PwrMBaseOffset = 0xFE000000
	// Recursively initializing a child structure:
	s.DigestList = *cbnt.NewHashList()
	// Set through tag "required":
	s.SegmentCount = 0
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *TXT) Validate() error {
	// See tag "require"
	for idx := range s.Reserved0 {
		if s.Reserved0[idx] != 0 {
			return fmt.Errorf("'Reserved0[%d]' is expected to be 0, but it is %v", idx, s.Reserved0[idx])
		}
	}
	// See tag "require"
	for idx := range s.SetNumber {
		if s.SetNumber[idx] != 0 {
			return fmt.Errorf("'SetNumber[%d]' is expected to be 0, but it is %v", idx, s.SetNumber[idx])
		}
	}
	// See tag "require"
	for idx := range s.Reserved1 {
		if s.Reserved1[idx] != 0 {
			return fmt.Errorf("'Reserved1[%d]' is expected to be 0, but it is %v", idx, s.Reserved1[idx])
		}
	}
	// Recursively validating a child structure:
	if err := s.DigestList.Validate(); err != nil {
		return fmt.Errorf("error on field 'DigestList': %w", err)
	}
	// See tag "require"
	for idx := range s.Reserved3 {
		if s.Reserved3[idx] != 0 {
			return fmt.Errorf("'Reserved3[%d]' is expected to be 0, but it is %v", idx, s.Reserved3[idx])
		}
	}
	// See tag "require"
	if s.SegmentCount != 0 {
		return fmt.Errorf("field 'SegmentCount' expects value '0', but has %v", s.SegmentCount)
	}

	return nil
}

// StructureIDTXT is the StructureID (in terms of
// the document #575623) of element 'TXT'.
const StructureIDTXT = "__TXTS__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *TXT) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *TXT) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the TXT from 'r' in format defined in the document #575623.
func (s *TXT) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the TXT from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *TXT) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// SetNumber (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.SetNumber[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SetNumber': %w", err)
		}
		totalN += int64(n)
	}

	// SInitMinSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.SInitMinSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SInitMinSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// ControlFlags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.ControlFlags)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ControlFlags': %w", err)
		}
		totalN += int64(n)
	}

	// PwrDownInterval (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.PwrDownInterval)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PwrDownInterval': %w", err)
		}
		totalN += int64(n)
	}

	// PTTCMOSOffset0 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.PTTCMOSOffset0)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PTTCMOSOffset0': %w", err)
		}
		totalN += int64(n)
	}

	// PTTCMOSOffset1 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.PTTCMOSOffset1)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PTTCMOSOffset1': %w", err)
		}
		totalN += int64(n)
	}

	// ACPIBaseOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.ACPIBaseOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ACPIBaseOffset': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// PwrMBaseOffset (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.PwrMBaseOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PwrMBaseOffset': %w", err)
		}
		totalN += int64(n)
	}

	// DigestList (ManifestFieldType: subStruct)
	{
		n, err := s.DigestList.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'DigestList': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved3 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Read(r, binary.LittleEndian, s.Reserved3[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved3': %w", err)
		}
		totalN += int64(n)
	}

	// SegmentCount (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.SegmentCount)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SegmentCount': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *TXT) RehashRecursive() {
	s.StructInfo.Rehash()
	s.DigestList.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *TXT) Rehash() {
	s.Variable0 = 0
	s.ElementSize = uint16(s.TotalSize())
}

// WriteTo writes the TXT into 'w' in format defined in
// the document #575623.
func (s *TXT) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved0 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved0[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved0': %w", err)
		}
		totalN += int64(n)
	}

	// SetNumber (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.SetNumber[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SetNumber': %w", err)
		}
		totalN += int64(n)
	}

	// SInitMinSVNAuth (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.SInitMinSVNAuth)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SInitMinSVNAuth': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved1 (ManifestFieldType: arrayStatic)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, s.Reserved1[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved1': %w", err)
		}
		totalN += int64(n)
	}

	// ControlFlags (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.ControlFlags)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ControlFlags': %w", err)
		}
		totalN += int64(n)
	}

	// PwrDownInterval (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.PwrDownInterval)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PwrDownInterval': %w", err)
		}
		totalN += int64(n)
	}

	// PTTCMOSOffset0 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.PTTCMOSOffset0)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PTTCMOSOffset0': %w", err)
		}
		totalN += int64(n)
	}

	// PTTCMOSOffset1 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.PTTCMOSOffset1)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PTTCMOSOffset1': %w", err)
		}
		totalN += int64(n)
	}

	// ACPIBaseOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.ACPIBaseOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ACPIBaseOffset': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// PwrMBaseOffset (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.PwrMBaseOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PwrMBaseOffset': %w", err)
		}
		totalN += int64(n)
	}

	// DigestList (ManifestFieldType: subStruct)
	{
		n, err := s.DigestList.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'DigestList': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved3 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Write(w, binary.LittleEndian, s.Reserved3[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved3': %w", err)
		}
		totalN += int64(n)
	}

	// SegmentCount (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.SegmentCount)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SegmentCount': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *TXT) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// Reserved0Size returns the size in bytes of the value of field Reserved0
func (s *TXT) Reserved0TotalSize() uint64 {
	return 1
}

// SetNumberSize returns the size in bytes of the value of field SetNumber
func (s *TXT) SetNumberTotalSize() uint64 {
	return 1
}

// SInitMinSVNAuthSize returns the size in bytes of the value of field SInitMinSVNAuth
func (s *TXT) SInitMinSVNAuthTotalSize() uint64 {
	return 1
}

// Reserved1Size returns the size in bytes of the value of field Reserved1
func (s *TXT) Reserved1TotalSize() uint64 {
	return 1
}

// ControlFlagsSize returns the size in bytes of the value of field ControlFlags
func (s *TXT) ControlFlagsTotalSize() uint64 {
	return 4
}

// PwrDownIntervalSize returns the size in bytes of the value of field PwrDownInterval
func (s *TXT) PwrDownIntervalTotalSize() uint64 {
	return 2
}

// PTTCMOSOffset0Size returns the size in bytes of the value of field PTTCMOSOffset0
func (s *TXT) PTTCMOSOffset0TotalSize() uint64 {
	return 1
}

// PTTCMOSOffset1Size returns the size in bytes of the value of field PTTCMOSOffset1
func (s *TXT) PTTCMOSOffset1TotalSize() uint64 {
	return 1
}

// ACPIBaseOffsetSize returns the size in bytes of the value of field ACPIBaseOffset
func (s *TXT) ACPIBaseOffsetTotalSize() uint64 {
	return 2
}

// Reserved2Size returns the size in bytes of the value of field Reserved2
func (s *TXT) Reserved2TotalSize() uint64 {
	return 2
}

// PwrMBaseOffsetSize returns the size in bytes of the value of field PwrMBaseOffset
func (s *TXT) PwrMBaseOffsetTotalSize() uint64 {
	return 4
}

// DigestListSize returns the size in bytes of the value of field DigestList
func (s *TXT) DigestListTotalSize() uint64 {
	return s.DigestList.TotalSize()
}

// Reserved3Size returns the size in bytes of the value of field Reserved3
func (s *TXT) Reserved3TotalSize() uint64 {
	return 3
}

// SegmentCountSize returns the size in bytes of the value of field SegmentCount
func (s *TXT) SegmentCountTotalSize() uint64 {
	return 1
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *TXT) StructInfoOffset() uint64 {
	return 0
}

// Reserved0Offset returns the offset in bytes of field Reserved0
func (s *TXT) Reserved0Offset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// SetNumberOffset returns the offset in bytes of field SetNumber
func (s *TXT) SetNumberOffset() uint64 {
	return s.Reserved0Offset() + s.Reserved0TotalSize()
}

// SInitMinSVNAuthOffset returns the offset in bytes of field SInitMinSVNAuth
func (s *TXT) SInitMinSVNAuthOffset() uint64 {
	return s.SetNumberOffset() + s.SetNumberTotalSize()
}

// Reserved1Offset returns the offset in bytes of field Reserved1
func (s *TXT) Reserved1Offset() uint64 {
	return s.SInitMinSVNAuthOffset() + s.SInitMinSVNAuthTotalSize()
}

// ControlFlagsOffset returns the offset in bytes of field ControlFlags
func (s *TXT) ControlFlagsOffset() uint64 {
	return s.Reserved1Offset() + s.Reserved1TotalSize()
}

// PwrDownIntervalOffset returns the offset in bytes of field PwrDownInterval
func (s *TXT) PwrDownIntervalOffset() uint64 {
	return s.ControlFlagsOffset() + s.ControlFlagsTotalSize()
}

// PTTCMOSOffset0Offset returns the offset in bytes of field PTTCMOSOffset0
func (s *TXT) PTTCMOSOffset0Offset() uint64 {
	return s.PwrDownIntervalOffset() + s.PwrDownIntervalTotalSize()
}

// PTTCMOSOffset1Offset returns the offset in bytes of field PTTCMOSOffset1
func (s *TXT) PTTCMOSOffset1Offset() uint64 {
	return s.PTTCMOSOffset0Offset() + s.PTTCMOSOffset0TotalSize()
}

// ACPIBaseOffsetOffset returns the offset in bytes of field ACPIBaseOffset
func (s *TXT) ACPIBaseOffsetOffset() uint64 {
	return s.PTTCMOSOffset1Offset() + s.PTTCMOSOffset1TotalSize()
}

// Reserved2Offset returns the offset in bytes of field Reserved2
func (s *TXT) Reserved2Offset() uint64 {
	return s.ACPIBaseOffsetOffset() + s.ACPIBaseOffsetTotalSize()
}

// PwrMBaseOffsetOffset returns the offset in bytes of field PwrMBaseOffset
func (s *TXT) PwrMBaseOffsetOffset() uint64 {
	return s.Reserved2Offset() + s.Reserved2TotalSize()
}

// DigestListOffset returns the offset in bytes of field DigestList
func (s *TXT) DigestListOffset() uint64 {
	return s.PwrMBaseOffsetOffset() + s.PwrMBaseOffsetTotalSize()
}

// Reserved3Offset returns the offset in bytes of field Reserved3
func (s *TXT) Reserved3Offset() uint64 {
	return s.DigestListOffset() + s.DigestListTotalSize()
}

// SegmentCountOffset returns the offset in bytes of field SegmentCount
func (s *TXT) SegmentCountOffset() uint64 {
	return s.Reserved3Offset() + s.Reserved3TotalSize()
}

// Size returns the total size of the TXT.
func (s *TXT) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.Reserved0TotalSize()
	size += s.SetNumberTotalSize()
	size += s.SInitMinSVNAuthTotalSize()
	size += s.Reserved1TotalSize()
	size += s.ControlFlagsTotalSize()
	size += s.PwrDownIntervalTotalSize()
	size += s.PTTCMOSOffset0TotalSize()
	size += s.PTTCMOSOffset1TotalSize()
	size += s.ACPIBaseOffsetTotalSize()
	size += s.Reserved2TotalSize()
	size += s.PwrMBaseOffsetTotalSize()
	size += s.DigestListTotalSize()
	size += s.Reserved3TotalSize()
	size += s.SegmentCountTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *TXT) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TXT", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 0", "", &s.Reserved0, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Set Number", "", &s.SetNumber, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "S Init Min SVN Auth", "", &s.SInitMinSVNAuth, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 1", "", &s.Reserved1, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Control Flags", "", &s.ControlFlags, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Pwr Down Interval", "", &s.PwrDownInterval, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "PTT CMOS Offset 0", "", &s.PTTCMOSOffset0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "PTT CMOS Offset 1", "", &s.PTTCMOSOffset1, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "ACPI Base Offset", "", &s.ACPIBaseOffset, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 2", "", &s.Reserved2, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "ACPI MMIO Offset", "", &s.PwrMBaseOffset, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Digest List", "", &s.DigestList, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 3", "", &s.Reserved3, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Segment Count", "", &s.SegmentCount, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Duration16In5Sec) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v Duration16In5Sec) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Duration16In5Sec into 'w' in binary format.
func (v Duration16In5Sec) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Duration16In5Sec from 'r' in binary format.
func (v Duration16In5Sec) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntkey/hash.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntkey

import (
	"fmt"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// Hash is "KM hash Structure" defined in document #575623.
type Hash struct {
	// Usage is the digest usage bitmask.
	//
	// More than one bit can be set to indicate shared digest usage.
	// Usage of bit 0 is normative; other usages are informative.
	Usage Usage `json:"hashUsage"`

	// Digest is the actual digest.
	Digest cbnt.HashStructure `json:"hashStruct"`
}

// Usage is the digest usage bitmask.
//
// More than one bit can be set to indicate shared digest usage.
// Usage of bit 0 is normative; other usages are informative.
type Usage uint64

const (
	// UsageBPMSigningPKD is the bit meaning the digest could be used as
	// Boot Policy Manifest signing pubkey digest.
	UsageBPMSigningPKD = Usage(1 << iota)

	// UsageFITPatchManifestSigningPKD is the bit meaning the digest could be used as
	// FIT Patch Manifest signing pubkey digest.
	UsageFITPatchManifestSigningPKD

	// UsageACMManifestSigningPKD is the bit meaning the digest could be used as
	// ACM Manifest signing pubkey digest.
	UsageACMManifestSigningPKD

	// UsageSDEVSigningPKD is the bit meaning the digest could be used as
	// SDEV signing pubkey digest.
	UsageSDEVSigningPKD

	// UsageReserved is a reserved bit
	UsageReserved
)

// String implements fmt.Stringer.
func (u Usage) String() string {
	var result []string
	for i := uint(0); i < 64; i++ {
		f := Usage(1 << i)
		if !u.IsSet(f) {
			continue
		}
		var descr string
		switch f {
		case UsageBPMSigningPKD:
			descr = "BPM_signing_pubkey_digest"
		case UsageFITPatchManifestSigningPKD:
			descr = "FIT_patch_manifest_signing_pubkey_digest"
		case UsageACMManifestSigningPKD:
			descr = "ACM_manifest_signing_pubkey_digest"
		case UsageSDEVSigningPKD:
			descr = "SDEV_signing_pubkey_digest"
		case UsageReserved:
			descr = "Reserved"
		default:
			descr = fmt.Sprintf("unexpected_bit_%d", i)
		}
		result = append(result, descr)
	}

	return strings.Join(result, ",")
}

// IsSet returns true if bits `f` are set in bitmask `u`.
func (u Usage) IsSet(f Usage) bool {
	return u&f != 0
}

// Set sets/unsets the bits of `f` in bitmask `u`.
//
// To set the bits `v` should be true, to unset -- false.
func (u *Usage) Set(f Usage, v bool) {
	if v {
		*u |= f
	} else {
		*u &= ^f
	}
}

```

`pkg/intel/metadata/cbnt/cbntkey/hash_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntkey

package cbntkey

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewHash returns a new instance of Hash with
// all default values set.
func NewHash() *Hash {
	s := &Hash{}
	// Recursively initializing a child structure:
	s.Digest = *cbnt.NewHashStructure()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Hash) Validate() error {
	// Recursively validating a child structure:
	if err := s.Digest.Validate(); err != nil {
		return fmt.Errorf("error on field 'Digest': %w", err)
	}

	return nil
}

// ReadFrom reads the Hash from 'r' in format defined in the document #575623.
func (s *Hash) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Usage (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, &s.Usage)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Usage': %w", err)
		}
		totalN += int64(n)
	}

	// Digest (ManifestFieldType: subStruct)
	{
		n, err := s.Digest.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Digest': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Hash) RehashRecursive() {
	s.Digest.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Hash) Rehash() {
}

// WriteTo writes the Hash into 'w' in format defined in
// the document #575623.
func (s *Hash) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Usage (ManifestFieldType: endValue)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, &s.Usage)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Usage': %w", err)
		}
		totalN += int64(n)
	}

	// Digest (ManifestFieldType: subStruct)
	{
		n, err := s.Digest.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Digest': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// UsageSize returns the size in bytes of the value of field Usage
func (s *Hash) UsageTotalSize() uint64 {
	return 8
}

// DigestSize returns the size in bytes of the value of field Digest
func (s *Hash) DigestTotalSize() uint64 {
	return s.Digest.TotalSize()
}

// UsageOffset returns the offset in bytes of field Usage
func (s *Hash) UsageOffset() uint64 {
	return 0
}

// DigestOffset returns the offset in bytes of field Digest
func (s *Hash) DigestOffset() uint64 {
	return s.UsageOffset() + s.UsageTotalSize()
}

// Size returns the total size of the Hash.
func (s *Hash) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.UsageTotalSize()
	size += s.DigestTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Hash) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Hash", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Usage", "", &s.Usage, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Digest", "", &s.Digest, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Usage) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v Usage) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Usage into 'w' in binary format.
func (v Usage) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Usage from 'r' in binary format.
func (v Usage) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/cbntkey/manifest.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbntkey

import (
	"bytes"
	"crypto"
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
)

// PrettyString: CBnT Key Manifest
type Manifest struct {
	cbnt.StructInfo `id:"__KEYM__" version:"0x21" var0:"0" var1:"0"`

	// KeyManifestSignatureOffset is Key Manifest KeySignature offset.
	//
	// The original name is "KeySignatureOffset" (in #575623).
	KeyManifestSignatureOffset uint16 `rehashValue:"KeyAndSignatureOffset()" json:"kmSigOffset,omitempty"`

	// Reserved2 is an alignment.
	Reserved2 [3]byte `json:"kmReserved2,omitempty"`

	// Revision is the revision of the Key Manifest defined by the Platform
	// Manufacturer.
	Revision uint8 `json:"kmRevision"`

	// KMSVN is the Key Manifest Security Version Number.
	KMSVN cbnt.SVN `json:"kmSVN"`

	// KMID is the Key Manifest Identifier.
	KMID uint8 `json:"kmID"`

	// PubKeyHashAlg is the hash algorithm of OEM public key digest programmed
	// into the FPF.
	PubKeyHashAlg cbnt.Algorithm `json:"kmPubKeyHashAlg"`

	// Hash is the slice of KMHASH_STRUCT (KHS) structures (see table 5-3
	// of the document #575623). Describes BPM pubkey digest (among other).
	Hash []Hash `json:"kmHash"`

	// KeyAndSignature is the Key Manifest signature.
	KeyAndSignature cbnt.KeySignature `json:"kmKeySignature"`
}

func (m *Manifest) SetSignature(
	algo cbnt.Algorithm,
	hashAlgo cbnt.Algorithm,
	privKey crypto.Signer,
	signedData []byte,
) error {
	err := m.KeyAndSignature.SetSignature(algo, hashAlgo, privKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}
	m.PubKeyHashAlg = m.KeyAndSignature.Signature.HashAlg

	return nil
}

func (m *Manifest) ValidateBPMKey(bpmKS cbnt.KeySignature) error {
	hashCount := 0
	for _, hashEntry := range m.Hash {
		if !hashEntry.Usage.IsSet(UsageBPMSigningPKD) {
			continue
		}

		h, err := hashEntry.Digest.HashAlg.Hash()
		if err != nil {
			return fmt.Errorf("invalid hash algo %v: %w", hashEntry.Digest.HashAlg, err)
		}

		if len(hashEntry.Digest.HashBuffer) != h.Size() {
			return fmt.Errorf("invalid hash lenght: actual:%d expected:%d", len(hashEntry.Digest.HashBuffer), h.Size())
		}

		switch bpmKS.Key.KeyAlg {
		case cbnt.AlgRSA:
			if _, err := h.Write(bpmKS.Key.Data[4:]); err != nil {
				return fmt.Errorf("unable to hash: %w", err)
			}
		default:
			return fmt.Errorf("unsupported key algorithm: %v", bpmKS.Key.KeyAlg)
		}
		digest := h.Sum(nil)

		if !bytes.Equal(hashEntry.Digest.HashBuffer, digest) {
			return fmt.Errorf("BPM key hash does not match the one in KM: actual:%X != in-KM:%X (hash algo: %v)", digest, hashEntry.Digest.HashBuffer, hashEntry.Digest.HashAlg)
		}
		hashCount++
	}

	if hashCount == 0 {
		return fmt.Errorf("no hash of BPM's key was found in KM")
	}

	return nil
}

```

`pkg/intel/metadata/cbnt/cbntkey/manifest_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntkey

package cbntkey

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
	_ = cbnt.StructInfo{}
)

// NewManifest returns a new instance of Manifest with
// all default values set.
func NewManifest() *Manifest {
	s := &Manifest{}
	copy(s.StructInfo.ID[:], []byte(StructureIDManifest))
	s.StructInfo.Version = 0x21
	// Recursively initializing a child structure:
	s.KeyAndSignature = *cbnt.NewKeySignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Manifest) Validate() error {
	// See tag "rehashValue"
	{
		expectedValue := uint16(s.KeyAndSignatureOffset())
		if s.KeyManifestSignatureOffset != expectedValue {
			return fmt.Errorf("field 'KeyManifestSignatureOffset' expects write-value '%v', but has %v", expectedValue, s.KeyManifestSignatureOffset)
		}
	}
	// Recursively validating a child structure:
	if err := s.KeyAndSignature.Validate(); err != nil {
		return fmt.Errorf("error on field 'KeyAndSignature': %w", err)
	}

	return nil
}

// StructureIDManifest is the StructureID (in terms of
// the document #575623) of element 'Manifest'.
const StructureIDManifest = "__KEYM__"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Manifest) GetStructInfo() cbnt.StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *Manifest) SetStructInfo(newStructInfo cbnt.StructInfo) {
	s.StructInfo = newStructInfo
}

// ReadFrom reads the Manifest from 'r' in format defined in the document #575623.
func (s *Manifest) ReadFrom(r io.Reader) (int64, error) {
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the Manifest from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *Manifest) ReadDataFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// StructInfo (ManifestFieldType: structInfo)
	{
		// ReadDataFrom does not read Struct, use ReadFrom for that.
	}

	// KeyManifestSignatureOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeyManifestSignatureOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeyManifestSignatureOffset': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Read(r, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// Revision (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Revision)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Revision': %w", err)
		}
		totalN += int64(n)
	}

	// KMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.KMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// KMID (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.KMID)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KMID': %w", err)
		}
		totalN += int64(n)
	}

	// PubKeyHashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.PubKeyHashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'PubKeyHashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Hash (ManifestFieldType: list)
	{
		var count uint16
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field 'Hash': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.Hash = make([]Hash, count)

		for idx := range s.Hash {
			n, err := s.Hash[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field 'Hash[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	// KeyAndSignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeyAndSignature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeyAndSignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Manifest) RehashRecursive() {
	s.StructInfo.Rehash()
	s.KeyAndSignature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Manifest) Rehash() {
	s.Variable0 = 0
	s.ElementSize = 0
	s.KeyManifestSignatureOffset = uint16(s.KeyAndSignatureOffset())
}

// WriteTo writes the Manifest into 'w' in format defined in
// the document #575623.
func (s *Manifest) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// StructInfo (ManifestFieldType: structInfo)
	{
		n, err := s.StructInfo.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'StructInfo': %w", err)
		}
		totalN += int64(n)
	}

	// KeyManifestSignatureOffset (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeyManifestSignatureOffset)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeyManifestSignatureOffset': %w", err)
		}
		totalN += int64(n)
	}

	// Reserved2 (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Write(w, binary.LittleEndian, s.Reserved2[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Reserved2': %w", err)
		}
		totalN += int64(n)
	}

	// Revision (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Revision)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Revision': %w", err)
		}
		totalN += int64(n)
	}

	// KMSVN (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.KMSVN)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KMSVN': %w", err)
		}
		totalN += int64(n)
	}

	// KMID (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.KMID)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KMID': %w", err)
		}
		totalN += int64(n)
	}

	// PubKeyHashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.PubKeyHashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'PubKeyHashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Hash (ManifestFieldType: list)
	{
		count := uint16(len(s.Hash))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field 'Hash': %w", err)
		}
		totalN += int64(binary.Size(count))
		for idx := range s.Hash {
			n, err := s.Hash[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'Hash[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	// KeyAndSignature (ManifestFieldType: subStruct)
	{
		n, err := s.KeyAndSignature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeyAndSignature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// StructInfoSize returns the size in bytes of the value of field StructInfo
func (s *Manifest) StructInfoTotalSize() uint64 {
	return s.StructInfo.TotalSize()
}

// KeyManifestSignatureOffsetSize returns the size in bytes of the value of field KeyManifestSignatureOffset
func (s *Manifest) KeyManifestSignatureOffsetTotalSize() uint64 {
	return 2
}

// Reserved2Size returns the size in bytes of the value of field Reserved2
func (s *Manifest) Reserved2TotalSize() uint64 {
	return 3
}

// RevisionSize returns the size in bytes of the value of field Revision
func (s *Manifest) RevisionTotalSize() uint64 {
	return 1
}

// KMSVNSize returns the size in bytes of the value of field KMSVN
func (s *Manifest) KMSVNTotalSize() uint64 {
	return 1
}

// KMIDSize returns the size in bytes of the value of field KMID
func (s *Manifest) KMIDTotalSize() uint64 {
	return 1
}

// PubKeyHashAlgSize returns the size in bytes of the value of field PubKeyHashAlg
func (s *Manifest) PubKeyHashAlgTotalSize() uint64 {
	return 2
}

// HashSize returns the size in bytes of the value of field Hash
func (s *Manifest) HashTotalSize() uint64 {
	var size uint64
	size += uint64(binary.Size(uint16(0)))
	for idx := range s.Hash {
		size += s.Hash[idx].TotalSize()
	}
	return size
}

// KeyAndSignatureSize returns the size in bytes of the value of field KeyAndSignature
func (s *Manifest) KeyAndSignatureTotalSize() uint64 {
	return s.KeyAndSignature.TotalSize()
}

// StructInfoOffset returns the offset in bytes of field StructInfo
func (s *Manifest) StructInfoOffset() uint64 {
	return 0
}

// KeyManifestSignatureOffsetOffset returns the offset in bytes of field KeyManifestSignatureOffset
func (s *Manifest) KeyManifestSignatureOffsetOffset() uint64 {
	return s.StructInfoOffset() + s.StructInfoTotalSize()
}

// Reserved2Offset returns the offset in bytes of field Reserved2
func (s *Manifest) Reserved2Offset() uint64 {
	return s.KeyManifestSignatureOffsetOffset() + s.KeyManifestSignatureOffsetTotalSize()
}

// RevisionOffset returns the offset in bytes of field Revision
func (s *Manifest) RevisionOffset() uint64 {
	return s.Reserved2Offset() + s.Reserved2TotalSize()
}

// KMSVNOffset returns the offset in bytes of field KMSVN
func (s *Manifest) KMSVNOffset() uint64 {
	return s.RevisionOffset() + s.RevisionTotalSize()
}

// KMIDOffset returns the offset in bytes of field KMID
func (s *Manifest) KMIDOffset() uint64 {
	return s.KMSVNOffset() + s.KMSVNTotalSize()
}

// PubKeyHashAlgOffset returns the offset in bytes of field PubKeyHashAlg
func (s *Manifest) PubKeyHashAlgOffset() uint64 {
	return s.KMIDOffset() + s.KMIDTotalSize()
}

// HashOffset returns the offset in bytes of field Hash
func (s *Manifest) HashOffset() uint64 {
	return s.PubKeyHashAlgOffset() + s.PubKeyHashAlgTotalSize()
}

// KeyAndSignatureOffset returns the offset in bytes of field KeyAndSignature
func (s *Manifest) KeyAndSignatureOffset() uint64 {
	return s.HashOffset() + s.HashTotalSize()
}

// Size returns the total size of the Manifest.
func (s *Manifest) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.StructInfoTotalSize()
	size += s.KeyManifestSignatureOffsetTotalSize()
	size += s.Reserved2TotalSize()
	size += s.RevisionTotalSize()
	size += s.KMSVNTotalSize()
	size += s.KMIDTotalSize()
	size += s.PubKeyHashAlgTotalSize()
	size += s.HashTotalSize()
	size += s.KeyAndSignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Manifest) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "CBnT Key Manifest", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is structInfo
	lines = append(lines, pretty.SubValue(depth+1, "Struct Info", "", &s.StructInfo, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Manifest Signature Offset", "", &s.KeyManifestSignatureOffset, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Reserved 2", "", &s.Reserved2, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Revision", "", &s.Revision, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "KMSVN", "", &s.KMSVN, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "KMID", "", &s.KMID, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Pub Key Hash Alg", "", &s.PubKeyHashAlg, opts...)...)
	// ManifestFieldType is list
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("Hash: Array of \"Key Manifest\" of length %d", len(s.Hash)), s.Hash))
	for i := 0; i < len(s.Hash); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.Hash[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key And Signature", "", &s.KeyAndSignature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/cbntkey/manifest_nocodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

//
// To avoid error "m.StructInfo.PrettyString undefined" we place this
// function to a file with a build tag "!manifestcodegen"

package cbntkey

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

// Print prints the Key Manifest.
func (m *Manifest) Print() {
	if m.KeyAndSignature.Signature.DataTotalSize() < 1 {
		fmt.Printf("%v\n", m.PrettyString(1, true, pretty.OptionOmitKeySignature(true)))
		fmt.Printf("  --KeyAndSignature--\n\tKey Manifest not signed!\n\n")
	} else {
		fmt.Printf("%v\n", m.PrettyString(1, true, pretty.OptionOmitKeySignature(false)))
	}
}

```

`pkg/intel/metadata/cbnt/cbntkey/manifest_test.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbntkey

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/unittest"
)

func TestReadWrite(t *testing.T) {
	unittest.CBNTManifestReadWrite(t, &Manifest{}, "testdata/km.bin")
}

```

`pkg/intel/metadata/cbnt/chipset_ac_module_information.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

var chipsetACModuleInformationSignature = []byte{
	0xAA, 0x3A, 0xC0, 0x7F, 0xA7, 0x46, 0xDB, 0x18,
	0x2E, 0xAC, 0x69, 0x8F, 0x8D, 0x41, 0x7F, 0x5A,
}

// ChipsetACModuleInformation represents Chipset AC Module Information Table parts for all versions
type ChipsetACModuleInformation struct {
	UUID            [16]byte
	ChipsetACMType  uint8
	Version         uint8
	Length          uint16
	ChipsetIDList   uint32
	OsSinitDataVer  uint32
	MinMleHeaderVer uint32
	Capabilities    uint32
	AcmVersion      uint8
	AcmRevision     [3]uint8
	ProcessorIDList uint32
}

// ChipsetACModuleInformationV5 represents Chipset AC Module Information Table for version >= 5
type ChipsetACModuleInformationV5 struct {
	Base        ChipsetACModuleInformation
	TPMInfoList uint32
}

```

`pkg/intel/metadata/cbnt/chipset_ac_module_information_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewChipsetACModuleInformation returns a new instance of ChipsetACModuleInformation with
// all default values set.
func NewChipsetACModuleInformation() *ChipsetACModuleInformation {
	s := &ChipsetACModuleInformation{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *ChipsetACModuleInformation) Validate() error {

	return nil
}

// ReadFrom reads the ChipsetACModuleInformation from 'r' in format defined in the document #575623.
func (s *ChipsetACModuleInformation) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// UUID (ManifestFieldType: arrayStatic)
	{
		n, err := 16, binary.Read(r, binary.LittleEndian, s.UUID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'UUID': %w", err)
		}
		totalN += int64(n)
	}

	// ChipsetACMType (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.ChipsetACMType)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ChipsetACMType': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Length (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.Length)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Length': %w", err)
		}
		totalN += int64(n)
	}

	// ChipsetIDList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.ChipsetIDList)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ChipsetIDList': %w", err)
		}
		totalN += int64(n)
	}

	// OsSinitDataVer (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.OsSinitDataVer)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'OsSinitDataVer': %w", err)
		}
		totalN += int64(n)
	}

	// MinMleHeaderVer (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.MinMleHeaderVer)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'MinMleHeaderVer': %w", err)
		}
		totalN += int64(n)
	}

	// Capabilities (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Capabilities)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Capabilities': %w", err)
		}
		totalN += int64(n)
	}

	// AcmVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.AcmVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'AcmVersion': %w", err)
		}
		totalN += int64(n)
	}

	// AcmRevision (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Read(r, binary.LittleEndian, s.AcmRevision[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'AcmRevision': %w", err)
		}
		totalN += int64(n)
	}

	// ProcessorIDList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.ProcessorIDList)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ProcessorIDList': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *ChipsetACModuleInformation) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *ChipsetACModuleInformation) Rehash() {
}

// WriteTo writes the ChipsetACModuleInformation into 'w' in format defined in
// the document #575623.
func (s *ChipsetACModuleInformation) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// UUID (ManifestFieldType: arrayStatic)
	{
		n, err := 16, binary.Write(w, binary.LittleEndian, s.UUID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'UUID': %w", err)
		}
		totalN += int64(n)
	}

	// ChipsetACMType (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.ChipsetACMType)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ChipsetACMType': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Length (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.Length)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Length': %w", err)
		}
		totalN += int64(n)
	}

	// ChipsetIDList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.ChipsetIDList)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ChipsetIDList': %w", err)
		}
		totalN += int64(n)
	}

	// OsSinitDataVer (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.OsSinitDataVer)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'OsSinitDataVer': %w", err)
		}
		totalN += int64(n)
	}

	// MinMleHeaderVer (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.MinMleHeaderVer)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'MinMleHeaderVer': %w", err)
		}
		totalN += int64(n)
	}

	// Capabilities (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Capabilities)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Capabilities': %w", err)
		}
		totalN += int64(n)
	}

	// AcmVersion (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.AcmVersion)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'AcmVersion': %w", err)
		}
		totalN += int64(n)
	}

	// AcmRevision (ManifestFieldType: arrayStatic)
	{
		n, err := 3, binary.Write(w, binary.LittleEndian, s.AcmRevision[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'AcmRevision': %w", err)
		}
		totalN += int64(n)
	}

	// ProcessorIDList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.ProcessorIDList)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ProcessorIDList': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// UUIDSize returns the size in bytes of the value of field UUID
func (s *ChipsetACModuleInformation) UUIDTotalSize() uint64 {
	return 16
}

// ChipsetACMTypeSize returns the size in bytes of the value of field ChipsetACMType
func (s *ChipsetACModuleInformation) ChipsetACMTypeTotalSize() uint64 {
	return 1
}

// VersionSize returns the size in bytes of the value of field Version
func (s *ChipsetACModuleInformation) VersionTotalSize() uint64 {
	return 1
}

// LengthSize returns the size in bytes of the value of field Length
func (s *ChipsetACModuleInformation) LengthTotalSize() uint64 {
	return 2
}

// ChipsetIDListSize returns the size in bytes of the value of field ChipsetIDList
func (s *ChipsetACModuleInformation) ChipsetIDListTotalSize() uint64 {
	return 4
}

// OsSinitDataVerSize returns the size in bytes of the value of field OsSinitDataVer
func (s *ChipsetACModuleInformation) OsSinitDataVerTotalSize() uint64 {
	return 4
}

// MinMleHeaderVerSize returns the size in bytes of the value of field MinMleHeaderVer
func (s *ChipsetACModuleInformation) MinMleHeaderVerTotalSize() uint64 {
	return 4
}

// CapabilitiesSize returns the size in bytes of the value of field Capabilities
func (s *ChipsetACModuleInformation) CapabilitiesTotalSize() uint64 {
	return 4
}

// AcmVersionSize returns the size in bytes of the value of field AcmVersion
func (s *ChipsetACModuleInformation) AcmVersionTotalSize() uint64 {
	return 1
}

// AcmRevisionSize returns the size in bytes of the value of field AcmRevision
func (s *ChipsetACModuleInformation) AcmRevisionTotalSize() uint64 {
	return 3
}

// ProcessorIDListSize returns the size in bytes of the value of field ProcessorIDList
func (s *ChipsetACModuleInformation) ProcessorIDListTotalSize() uint64 {
	return 4
}

// UUIDOffset returns the offset in bytes of field UUID
func (s *ChipsetACModuleInformation) UUIDOffset() uint64 {
	return 0
}

// ChipsetACMTypeOffset returns the offset in bytes of field ChipsetACMType
func (s *ChipsetACModuleInformation) ChipsetACMTypeOffset() uint64 {
	return s.UUIDOffset() + s.UUIDTotalSize()
}

// VersionOffset returns the offset in bytes of field Version
func (s *ChipsetACModuleInformation) VersionOffset() uint64 {
	return s.ChipsetACMTypeOffset() + s.ChipsetACMTypeTotalSize()
}

// LengthOffset returns the offset in bytes of field Length
func (s *ChipsetACModuleInformation) LengthOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// ChipsetIDListOffset returns the offset in bytes of field ChipsetIDList
func (s *ChipsetACModuleInformation) ChipsetIDListOffset() uint64 {
	return s.LengthOffset() + s.LengthTotalSize()
}

// OsSinitDataVerOffset returns the offset in bytes of field OsSinitDataVer
func (s *ChipsetACModuleInformation) OsSinitDataVerOffset() uint64 {
	return s.ChipsetIDListOffset() + s.ChipsetIDListTotalSize()
}

// MinMleHeaderVerOffset returns the offset in bytes of field MinMleHeaderVer
func (s *ChipsetACModuleInformation) MinMleHeaderVerOffset() uint64 {
	return s.OsSinitDataVerOffset() + s.OsSinitDataVerTotalSize()
}

// CapabilitiesOffset returns the offset in bytes of field Capabilities
func (s *ChipsetACModuleInformation) CapabilitiesOffset() uint64 {
	return s.MinMleHeaderVerOffset() + s.MinMleHeaderVerTotalSize()
}

// AcmVersionOffset returns the offset in bytes of field AcmVersion
func (s *ChipsetACModuleInformation) AcmVersionOffset() uint64 {
	return s.CapabilitiesOffset() + s.CapabilitiesTotalSize()
}

// AcmRevisionOffset returns the offset in bytes of field AcmRevision
func (s *ChipsetACModuleInformation) AcmRevisionOffset() uint64 {
	return s.AcmVersionOffset() + s.AcmVersionTotalSize()
}

// ProcessorIDListOffset returns the offset in bytes of field ProcessorIDList
func (s *ChipsetACModuleInformation) ProcessorIDListOffset() uint64 {
	return s.AcmRevisionOffset() + s.AcmRevisionTotalSize()
}

// Size returns the total size of the ChipsetACModuleInformation.
func (s *ChipsetACModuleInformation) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.UUIDTotalSize()
	size += s.ChipsetACMTypeTotalSize()
	size += s.VersionTotalSize()
	size += s.LengthTotalSize()
	size += s.ChipsetIDListTotalSize()
	size += s.OsSinitDataVerTotalSize()
	size += s.MinMleHeaderVerTotalSize()
	size += s.CapabilitiesTotalSize()
	size += s.AcmVersionTotalSize()
	size += s.AcmRevisionTotalSize()
	size += s.ProcessorIDListTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *ChipsetACModuleInformation) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Chipset AC Module Information", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "UUID", "", &s.UUID, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Chipset ACM Type", "", &s.ChipsetACMType, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Length", "", &s.Length, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Chipset ID List", "", &s.ChipsetIDList, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Os Sinit Data Ver", "", &s.OsSinitDataVer, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Min Mle Header Ver", "", &s.MinMleHeaderVer, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Capabilities", "", &s.Capabilities, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Acm Version", "", &s.AcmVersion, opts...)...)
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "Acm Revision", "", &s.AcmRevision, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Processor ID List", "", &s.ProcessorIDList, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// NewChipsetACModuleInformationV5 returns a new instance of ChipsetACModuleInformationV5 with
// all default values set.
func NewChipsetACModuleInformationV5() *ChipsetACModuleInformationV5 {
	s := &ChipsetACModuleInformationV5{}
	// Recursively initializing a child structure:
	s.Base = *NewChipsetACModuleInformation()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *ChipsetACModuleInformationV5) Validate() error {
	// Recursively validating a child structure:
	if err := s.Base.Validate(); err != nil {
		return fmt.Errorf("error on field 'Base': %w", err)
	}

	return nil
}

// ReadFrom reads the ChipsetACModuleInformationV5 from 'r' in format defined in the document #575623.
func (s *ChipsetACModuleInformationV5) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Base (ManifestFieldType: subStruct)
	{
		n, err := s.Base.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// TPMInfoList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.TPMInfoList)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'TPMInfoList': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *ChipsetACModuleInformationV5) RehashRecursive() {
	s.Base.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *ChipsetACModuleInformationV5) Rehash() {
}

// WriteTo writes the ChipsetACModuleInformationV5 into 'w' in format defined in
// the document #575623.
func (s *ChipsetACModuleInformationV5) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Base (ManifestFieldType: subStruct)
	{
		n, err := s.Base.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Base': %w", err)
		}
		totalN += int64(n)
	}

	// TPMInfoList (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.TPMInfoList)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'TPMInfoList': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// BaseSize returns the size in bytes of the value of field Base
func (s *ChipsetACModuleInformationV5) BaseTotalSize() uint64 {
	return s.Base.TotalSize()
}

// TPMInfoListSize returns the size in bytes of the value of field TPMInfoList
func (s *ChipsetACModuleInformationV5) TPMInfoListTotalSize() uint64 {
	return 4
}

// BaseOffset returns the offset in bytes of field Base
func (s *ChipsetACModuleInformationV5) BaseOffset() uint64 {
	return 0
}

// TPMInfoListOffset returns the offset in bytes of field TPMInfoList
func (s *ChipsetACModuleInformationV5) TPMInfoListOffset() uint64 {
	return s.BaseOffset() + s.BaseTotalSize()
}

// Size returns the total size of the ChipsetACModuleInformationV5.
func (s *ChipsetACModuleInformationV5) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.BaseTotalSize()
	size += s.TPMInfoListTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *ChipsetACModuleInformationV5) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Chipset AC Module Information V 5", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Base", "", &s.Base, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "TPM Info List", "", &s.TPMInfoList, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/chipset_ac_module_information_nocodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

//
// To avoid errors "type ChipsetACModuleInformation has no field or method ReadFrom"
// with a build tag "!manifestcodegen"

package cbnt

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
)

// ParseChipsetACModuleInformation parses Chipset AC Module Information Table according to the version
func ParseChipsetACModuleInformation(r io.Reader) (int64, ChipsetACModuleInformationV5, error) {
	var result ChipsetACModuleInformationV5
	total, err := result.Base.ReadFrom(r)
	if !bytes.Equal(result.Base.UUID[:], chipsetACModuleInformationSignature) {
		return 0, ChipsetACModuleInformationV5{}, fmt.Errorf(
			"incorrect UUID [%x], expected: [%x]", result.Base.UUID, chipsetACModuleInformationSignature)
	}
	if err != nil {
		return total, result, err
	}
	if result.Base.Version < 5 {
		return total, result, nil
	}
	err = binary.Read(r, binary.LittleEndian, &result.TPMInfoList)
	total += int64(binary.Size(result.TPMInfoList))
	return total, result, err
}

```

`pkg/intel/metadata/cbnt/config.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbnt

var (
	// StrictOrderCheck defines if elements order checks should be performed.
	// For example in the Boot Policy Manifest elements could be in a wrong
	// order. And we still can parse it, but in this way `*Offset` methods
	// could be confusing, since they will show the offset as they will
	// be written (not as they were parsed).
	//
	// We require a strict order because it is explicitly required
	// in the documentation #575623:
	//
	// > The order of the elements and the order of the fields within each
	// > element are architectural and must be followed.
	StrictOrderCheck = true
)

```

`pkg/intel/metadata/cbnt/crypto_routines.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

import (
	"crypto"
	// Required for hash.Hash return in hashInfo struct
	_ "crypto/sha1"
	_ "crypto/sha256"
	_ "crypto/sha512"
	"fmt"
	"hash"
	"strings"

	"github.com/tjfoc/gmsm/sm3"
)

// Algorithm represents a crypto algorithm value.
type Algorithm uint16

// Supported algorithms
const (
	AlgUnknown Algorithm = 0x0000
	AlgRSA     Algorithm = 0x0001
	AlgSHA1    Algorithm = 0x0004
	AlgSHA256  Algorithm = 0x000B
	AlgSHA384  Algorithm = 0x000C
	AlgSHA512  Algorithm = 0x000D
	AlgNull    Algorithm = 0x0010
	AlgSM3     Algorithm = 0x0012
	AlgRSASSA  Algorithm = 0x0014
	AlgRSAPSS  Algorithm = 0x0016
	AlgECDSA   Algorithm = 0x0018
	AlgSM2     Algorithm = 0x001b
	AlgECC     Algorithm = 0x0023
)

var hashInfo = []struct {
	alg         Algorithm
	hashFactory func() hash.Hash
}{
	{AlgSHA1, crypto.SHA1.New},
	{AlgSHA256, crypto.SHA256.New},
	{AlgSHA384, crypto.SHA384.New},
	{AlgSHA512, crypto.SHA512.New},
	{AlgSM3, sm3.New},
}

// IsNull returns true if a is AlgNull or zero (unset).
func (a Algorithm) IsNull() bool {
	return a == AlgNull || a == AlgUnknown
}

// Hash returns a crypto.Hash based on the given id.
// An error is returned if the given algorithm is not a hash algorithm or is not available.
func (a Algorithm) Hash() (hash.Hash, error) {
	for _, info := range hashInfo {
		if info.alg == a {
			if info.hashFactory == nil {
				return nil, fmt.Errorf("go hash algorithm #%snot available", info.alg.String())
			}
			return info.hashFactory(), nil
		}
	}
	return nil, fmt.Errorf("hash algorithm not supported: %s", a.String())
}

func (a Algorithm) String() string {
	var s strings.Builder
	var err error
	switch a {
	case AlgUnknown:
		_, err = s.WriteString("AlgUnknown")
	case AlgRSA:
		_, err = s.WriteString("RSA")
	case AlgSHA1:
		_, err = s.WriteString("SHA1")
	case AlgSHA256:
		_, err = s.WriteString("SHA256")
	case AlgSHA384:
		_, err = s.WriteString("SHA384")
	case AlgSHA512:
		_, err = s.WriteString("SHA512")
	case AlgSM3:
		_, err = s.WriteString("SM3_256")
	case AlgNull:
		_, err = s.WriteString("AlgNull")
	case AlgRSASSA:
		_, err = s.WriteString("RSASSA")
	case AlgRSAPSS:
		_, err = s.WriteString("RSAPSS")
	case AlgECDSA:
		_, err = s.WriteString("ECDSA")
	case AlgECC:
		_, err = s.WriteString("ECC")
	case AlgSM2:
		_, err = s.WriteString("SM2")
	default:
		return fmt.Sprintf("Alg?<%d>", int(a))
	}
	if err != nil {
		return fmt.Sprintf("Writing to string builder failed: %v", err)
	}
	return s.String()
}

func GetAlgFromString(name string) (Algorithm, error) {
	n := strings.ToUpper(name)
	switch n {
	case "ALGUNKNOWN":
		return AlgUnknown, nil
	case "RSA":
		return AlgRSA, nil
	case "SHA1":
		return AlgSHA1, nil
	case "SHA256":
		return AlgSHA256, nil
	case "SHA384":
		return AlgSHA384, nil
	case "SM3":
		return AlgSM3, nil
	case "ALGNULL":
		return AlgNull, nil
	case "RSASSA":
		return AlgRSASSA, nil
	case "RSAPSS":
		return AlgRSAPSS, nil
	case "ECDSA":
		return AlgECDSA, nil
	case "ECC":
		return AlgECC, nil
	case "SM2":
		return AlgSM2, nil
	default:
		return AlgNull, fmt.Errorf("algorithm name provided unknown")
	}
}

```

`pkg/intel/metadata/cbnt/crypto_routines_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v Algorithm) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	return v.String()
}

// TotalSize returns the total size measured through binary.Size.
func (v Algorithm) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the Algorithm into 'w' in binary format.
func (v Algorithm) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the Algorithm from 'r' in binary format.
func (v Algorithm) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/hash.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

// HashStructure describes a digest.
type HashStructure struct {
	HashAlg    Algorithm `default:"0x10" json:"hsAlg"`
	HashBuffer []byte    `json:"hsBuffer"`
}

// HashList describes multiple digests
type HashList struct {
	Size uint16          `rehashValue:"TotalSize()" json:"hlSize"`
	List []HashStructure `json:"hlList"`
}

```

`pkg/intel/metadata/cbnt/hash_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewHashList returns a new instance of HashList with
// all default values set.
func NewHashList() *HashList {
	s := &HashList{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *HashList) Validate() error {
	// See tag "rehashValue"
	{
		expectedValue := uint16(s.TotalSize())
		if s.Size != expectedValue {
			return fmt.Errorf("field 'Size' expects write-value '%v', but has %v", expectedValue, s.Size)
		}
	}

	return nil
}

// ReadFrom reads the HashList from 'r' in format defined in the document #575623.
func (s *HashList) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Size (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	// List (ManifestFieldType: list)
	{
		var count uint16
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field 'List': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.List = make([]HashStructure, count)

		for idx := range s.List {
			n, err := s.List[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field 'List[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *HashList) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *HashList) Rehash() {
	s.Size = uint16(s.TotalSize())
}

// WriteTo writes the HashList into 'w' in format defined in
// the document #575623.
func (s *HashList) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Size (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.Size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Size': %w", err)
		}
		totalN += int64(n)
	}

	// List (ManifestFieldType: list)
	{
		count := uint16(len(s.List))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field 'List': %w", err)
		}
		totalN += int64(binary.Size(count))
		for idx := range s.List {
			n, err := s.List[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'List[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// SizeSize returns the size in bytes of the value of field Size
func (s *HashList) SizeTotalSize() uint64 {
	return 2
}

// ListSize returns the size in bytes of the value of field List
func (s *HashList) ListTotalSize() uint64 {
	var size uint64
	size += uint64(binary.Size(uint16(0)))
	for idx := range s.List {
		size += s.List[idx].TotalSize()
	}
	return size
}

// SizeOffset returns the offset in bytes of field Size
func (s *HashList) SizeOffset() uint64 {
	return 0
}

// ListOffset returns the offset in bytes of field List
func (s *HashList) ListOffset() uint64 {
	return s.SizeOffset() + s.SizeTotalSize()
}

// Size returns the total size of the HashList.
func (s *HashList) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.SizeTotalSize()
	size += s.ListTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *HashList) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Hash List", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Size", "", &s.Size, opts...)...)
	// ManifestFieldType is list
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("List: Array of \"Hash List\" of length %d", len(s.List)), s.List))
	for i := 0; i < len(s.List); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.List[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// NewHashStructure returns a new instance of HashStructure with
// all default values set.
func NewHashStructure() *HashStructure {
	s := &HashStructure{}
	// Set through tag "default":
	s.HashAlg = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *HashStructure) Validate() error {

	return nil
}

// ReadFrom reads the HashStructure from 'r' in format defined in the document #575623.
func (s *HashStructure) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		var size uint16
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field 'HashBuffer': %w", err)
		}
		totalN += int64(binary.Size(size))
		s.HashBuffer = make([]byte, size)
		n, err := len(s.HashBuffer), binary.Read(r, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *HashStructure) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *HashStructure) Rehash() {
}

// WriteTo writes the HashStructure into 'w' in format defined in
// the document #575623.
func (s *HashStructure) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// HashBuffer (ManifestFieldType: arrayDynamic)
	{
		size := uint16(len(s.HashBuffer))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field 'HashBuffer': %w", err)
		}
		totalN += int64(binary.Size(size))
		n, err := len(s.HashBuffer), binary.Write(w, binary.LittleEndian, s.HashBuffer)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashBuffer': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// HashAlgSize returns the size in bytes of the value of field HashAlg
func (s *HashStructure) HashAlgTotalSize() uint64 {
	return 2
}

// HashBufferSize returns the size in bytes of the value of field HashBuffer
func (s *HashStructure) HashBufferTotalSize() uint64 {
	size := uint64(binary.Size(uint16(0)))
	size += uint64(len(s.HashBuffer))
	return size
}

// HashAlgOffset returns the offset in bytes of field HashAlg
func (s *HashStructure) HashAlgOffset() uint64 {
	return 0
}

// HashBufferOffset returns the offset in bytes of field HashBuffer
func (s *HashStructure) HashBufferOffset() uint64 {
	return s.HashAlgOffset() + s.HashAlgTotalSize()
}

// Size returns the total size of the HashStructure.
func (s *HashStructure) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.HashAlgTotalSize()
	size += s.HashBufferTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *HashStructure) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Hash Structure", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hash Alg", "", &s.HashAlg, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Hash Buffer", "", &s.HashBuffer, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/key.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

import (
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rsa"
	"encoding/binary"
	"fmt"
	"math/big"

	"github.com/tjfoc/gmsm/sm2"
)

// Key is a public key of an asymmetric crypto keypair.
type Key struct {
	KeyAlg  Algorithm `json:"keyAlg"`
	Version uint8     `require:"0x10"  json:"keyVersion"`
	KeySize BitSize   `json:"keyBitsize"`
	Data    []byte    `countValue:"keyDataSize()" json:"keyData"`
}

// BitSize is a size in bits.
type BitSize uint16

// InBits returns the size in bits.
func (ks BitSize) InBits() uint16 {
	return uint16(ks)
}

// InBytes returns the size in bytes.
func (ks BitSize) InBytes() uint16 {
	return uint16(ks >> 3)
}

// SetInBits sets the size in bits.
func (ks *BitSize) SetInBits(amountOfBits uint16) {
	*ks = BitSize(amountOfBits)
}

// SetInBytes sets the size in bytes.
func (ks *BitSize) SetInBytes(amountOfBytes uint16) {
	*ks = BitSize(amountOfBytes << 3)
}

// keyDataSize returns the expected length of Data for specified
// KeyAlg and KeySize.
func (k Key) keyDataSize() int64 {
	switch k.KeyAlg {
	case AlgRSA:
		return int64(k.KeySize.InBytes()) + 4
	case AlgECC, AlgSM2:
		return int64(k.KeySize.InBytes()) * 2
	}
	return -1
}

// PubKey parses Data into crypto.PublicKey.
func (k Key) PubKey() (crypto.PublicKey, error) {
	expectedSize := int(k.keyDataSize())
	if expectedSize < 0 {
		return nil, fmt.Errorf("unexpected algorithm: %s", k.KeyAlg)
	}
	if len(k.Data) != expectedSize {
		return nil, fmt.Errorf("unexpected size: expected:%d, received %d", expectedSize, len(k.Data))
	}

	switch k.KeyAlg {
	case AlgRSA:
		result := &rsa.PublicKey{
			N: new(big.Int).SetBytes(reverseBytes(k.Data[4:])),
			E: int(binaryOrder.Uint32(k.Data)),
		}
		return result, nil
	case AlgECC:
		keySize := k.KeySize.InBytes()
		x := new(big.Int).SetBytes(reverseBytes(k.Data[:keySize]))
		y := new(big.Int).SetBytes(reverseBytes(k.Data[keySize:]))
		return ecdsa.PublicKey{Curve: elliptic.P256(), X: x, Y: y}, nil
	case AlgSM2:
		keySize := k.KeySize.InBytes()
		x := new(big.Int).SetBytes(reverseBytes(k.Data[:keySize]))
		y := new(big.Int).SetBytes(reverseBytes(k.Data[keySize:]))
		return sm2.PublicKey{Curve: elliptic.P256(), X: x, Y: y}, nil
	}

	return nil, fmt.Errorf("unexpected TPM algorithm: %s", k.KeyAlg)
}

func reverseBytes(b []byte) []byte {
	r := make([]byte, len(b))
	for idx := range b {
		r[idx] = b[len(b)-idx-1]
	}
	return r
}

// SetPubKey sets Data the value corresponding to passed `key`.
func (k *Key) SetPubKey(key crypto.PublicKey) error {
	k.Version = 0x10

	switch key := key.(type) {
	case *rsa.PublicKey:
		k.KeyAlg = AlgRSA
		n := key.N.Bytes()
		k.KeySize.SetInBytes(uint16(len(n)))
		k.Data = make([]byte, 4+len(n))
		binaryOrder.PutUint32(k.Data, uint32(key.E))
		copy(k.Data[4:], reverseBytes(n))
		return nil

	case *ecdsa.PublicKey:
		var x, y *big.Int
		k.KeyAlg = AlgECC
		x, y = key.X, key.Y
		if x == nil || y == nil {
			return fmt.Errorf("the pubkey '%#+v' is invalid: x == nil || y == nil", key)
		}
		k.KeySize.SetInBits(256)
		xB, yB := x.Bytes(), y.Bytes()
		if len(xB) != int(k.KeySize.InBytes()) || len(yB) != int(k.KeySize.InBytes()) {
			return fmt.Errorf("the pubkey '%#+v' is invalid: len(x)<%d> != %d || len(y)<%d> == %d",
				key, len(xB), int(k.KeySize.InBytes()), len(yB), int(k.KeySize.InBytes()))
		}
		k.Data = make([]byte, 2*k.KeySize.InBytes())
		copy(k.Data[:], reverseBytes(xB))
		copy(k.Data[len(xB):], reverseBytes(yB))
		return nil

	case *sm2.PublicKey:
		var x, y *big.Int
		k.KeyAlg = AlgSM2
		x, y = key.X, key.Y
		if x == nil || y == nil {
			return fmt.Errorf("the pubkey '%#+v' is invalid: x == nil || y == nil", key)
		}
		k.KeySize.SetInBits(256)
		xB, yB := x.Bytes(), y.Bytes()
		if len(xB) != int(k.KeySize.InBytes()) || len(yB) != int(k.KeySize.InBytes()) {
			return fmt.Errorf("the pubkey '%#+v' is invalid: len(x)<%d> != %d || len(y)<%d> == %d",
				key, len(xB), int(k.KeySize.InBytes()), len(yB), int(k.KeySize.InBytes()))
		}
		k.Data = make([]byte, 2*k.KeySize.InBytes())
		copy(k.Data[:], reverseBytes(xB))
		copy(k.Data[len(xB):], reverseBytes(yB))
		return nil
	}

	return fmt.Errorf("unexpected key type: %T", key)
}

// PrintBPMPubKey prints the BPM public signing key hash to fuse into the Intel ME
func (k *Key) PrintBPMPubKey(bpmAlg Algorithm) error {
	buf := new(bytes.Buffer)
	if len(k.Data) > 1 {
		hash, err := bpmAlg.Hash()
		if err != nil {
			return err
		}
		if k.KeyAlg == AlgRSA {
			if err := binary.Write(buf, binary.LittleEndian, k.Data[4:]); err != nil {
				return err
			}
			if _, err := hash.Write(buf.Bytes()); err != nil {
				return fmt.Errorf("unable to hash: %w", err)
			}
			fmt.Printf("   Boot Policy Manifest Pubkey Hash: 0x%x\n", hash.Sum(nil))
		} else if k.KeyAlg == AlgSM2 || k.KeyAlg == AlgECC {
			if err := binary.Write(buf, binary.LittleEndian, k.Data); err != nil {
				return err
			}
			if _, err := hash.Write(buf.Bytes()); err != nil {
				return fmt.Errorf("unable to hash: %w", err)
			}
			fmt.Printf("   Boot Policy Manifest Pubkey Hash: 0x%x\n", hash.Sum(nil))
		} else {
			fmt.Printf("   Boot Policy Manifest Pubkey Hash: Unknown Algorithm\n")
		}
	} else {
		fmt.Printf("   Boot Policy Pubkey Hash: No km public key set in KM\n")
	}

	return nil
}

// PrintKMPubKey prints the KM public signing key hash to fuse into the Intel ME
func (k *Key) PrintKMPubKey(kmAlg Algorithm) error {
	buf := new(bytes.Buffer)
	if len(k.Data) > 1 {
		if k.KeyAlg == AlgRSA {
			if err := binary.Write(buf, binary.LittleEndian, k.Data[4:]); err != nil {
				return err
			}
			if err := binary.Write(buf, binary.LittleEndian, k.Data[:4]); err != nil {
				return err
			}
			if kmAlg != AlgSHA256 && kmAlg != AlgSHA384 {
				return fmt.Errorf("KM public key hash algorithm must be SHA256 or SHA384")
			}
			hash, err := kmAlg.Hash()
			if err != nil {
				return err
			}
			if _, err := hash.Write(buf.Bytes()); err != nil {
				return fmt.Errorf("unable to hash: %w", err)
			}
			fmt.Printf("   Key Manifest Pubkey Hash: 0x%x\n", hash.Sum(nil))
			// On SKL and KBL the exponent is not included in the KM hash
			buf.Truncate(len(k.Data[4:]))
			hash.Reset()
			if _, err := hash.Write(buf.Bytes()); err != nil {
				return fmt.Errorf("unable to hash: %w", err)
			}
			fmt.Printf("   Key Manifest Pubkey Hash (Skylake and Kabylake only): 0x%x\n", hash.Sum(nil))
		} else {
			fmt.Printf("   Key Manifest Pubkey Hash: Unsupported Algorithm\n")
		}
	} else {
		fmt.Printf("   Key Manifest Pubkey Hash: No km public key set in KM\n")
	}

	return nil
}

```

`pkg/intel/metadata/cbnt/key_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewKey returns a new instance of Key with
// all default values set.
func NewKey() *Key {
	s := &Key{}
	// Set through tag "required":
	s.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Key) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}

	return nil
}

// ReadFrom reads the Key from 'r' in format defined in the document #575623.
func (s *Key) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// KeyAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeyAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeyAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(s.keyDataSize())
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Key) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Key) Rehash() {
}

// WriteTo writes the Key into 'w' in format defined in
// the document #575623.
func (s *Key) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// KeyAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeyAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeyAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// KeyAlgSize returns the size in bytes of the value of field KeyAlg
func (s *Key) KeyAlgTotalSize() uint64 {
	return 2
}

// VersionSize returns the size in bytes of the value of field Version
func (s *Key) VersionTotalSize() uint64 {
	return 1
}

// KeySizeSize returns the size in bytes of the value of field KeySize
func (s *Key) KeySizeTotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *Key) DataTotalSize() uint64 {
	return uint64(len(s.Data))
}

// KeyAlgOffset returns the offset in bytes of field KeyAlg
func (s *Key) KeyAlgOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *Key) VersionOffset() uint64 {
	return s.KeyAlgOffset() + s.KeyAlgTotalSize()
}

// KeySizeOffset returns the offset in bytes of field KeySize
func (s *Key) KeySizeOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *Key) DataOffset() uint64 {
	return s.KeySizeOffset() + s.KeySizeTotalSize()
}

// Size returns the total size of the Key.
func (s *Key) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.KeyAlgTotalSize()
	size += s.VersionTotalSize()
	size += s.KeySizeTotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Key) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Key", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Alg", "", &s.KeyAlg, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Size", "", &s.KeySize, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", &s.Data, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v BitSize) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Bit Size", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "In Bits", "", v.InBits(), opts...)...)
	lines = append(lines, pretty.SubValue(depth+1, "In Bytes", "", v.InBytes(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v BitSize) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the BitSize into 'w' in binary format.
func (v BitSize) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the BitSize from 'r' in binary format.
func (v BitSize) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/cbnt/key_signature.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

import (
	"crypto"
	"fmt"
)

// KeySignature combines a public key and a signature in a single structure.
type KeySignature struct {
	Version   uint8     `require:"0x10" json:"ksVersion,omitempty"`
	Key       Key       `json:"ksKey"`
	Signature Signature `json:"ksSignature"`
}

// Verify verifies the builtin signature with the builtin public key.
func (s *KeySignature) Verify(signedData []byte) error {
	sig, err := s.Signature.SignatureData()
	if err != nil {
		return fmt.Errorf("invalid signature: %w", err)
	}
	pk, err := s.Key.PubKey()
	if err != nil {
		return fmt.Errorf("invalid public key: %w", err)
	}
	err = sig.Verify(pk, s.Signature.HashAlg, signedData)
	if err != nil {
		return fmt.Errorf("verification failed: %w", err)
	}
	return nil
}

// SetSignature generates a signature and sets all the values of KeyManifest,
// accordingly to arguments signAlgo, privKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (s *KeySignature) SetSignature(signAlgo Algorithm, hashAlgo Algorithm, privKey crypto.Signer, signedData []byte) error {
	s.Version = 0x10
	err := s.Key.SetPubKey(privKey.Public())
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return s.Signature.SetSignature(signAlgo, hashAlgo, privKey, signedData)
}

// SetSignatureAuto generates a signature and sets all the values of KeyManifest,
// accordingly to arguments privKey and signedData.
//
// Signing algorithm will be detected automatically based on the type of the
// provided private key.
func (s *KeySignature) SetSignatureAuto(privKey crypto.Signer, signedData []byte) error {
	s.Version = 0x10
	err := s.Key.SetPubKey(privKey.Public())
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return s.SetSignature(0, 0, privKey, signedData)
}

// FillSignature sets a signature and all the values of KeyManifest,
// accordingly to arguments signAlgo, pubKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (s *KeySignature) FillSignature(signAlgo Algorithm, pubKey crypto.PublicKey, signedData []byte, hashAlgo Algorithm) error {
	s.Version = 0x10
	err := s.Key.SetPubKey(pubKey)
	if err != nil {
		return fmt.Errorf("unable to set public key: %w", err)
	}

	return s.Signature.FillSignature(signAlgo, pubKey, signedData, hashAlgo)
}

```

`pkg/intel/metadata/cbnt/key_signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewKeySignature returns a new instance of KeySignature with
// all default values set.
func NewKeySignature() *KeySignature {
	s := &KeySignature{}
	// Set through tag "required":
	s.Version = 0x10
	// Recursively initializing a child structure:
	s.Key = *NewKey()
	// Recursively initializing a child structure:
	s.Signature = *NewSignature()
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *KeySignature) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}
	// Recursively validating a child structure:
	if err := s.Key.Validate(); err != nil {
		return fmt.Errorf("error on field 'Key': %w", err)
	}
	// Recursively validating a child structure:
	if err := s.Signature.Validate(); err != nil {
		return fmt.Errorf("error on field 'Signature': %w", err)
	}

	return nil
}

// ReadFrom reads the KeySignature from 'r' in format defined in the document #575623.
func (s *KeySignature) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Key (ManifestFieldType: subStruct)
	{
		n, err := s.Key.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Key': %w", err)
		}
		totalN += int64(n)
	}

	// Signature (ManifestFieldType: subStruct)
	{
		n, err := s.Signature.ReadFrom(r)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Signature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *KeySignature) RehashRecursive() {
	s.Key.Rehash()
	s.Signature.Rehash()
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *KeySignature) Rehash() {
}

// WriteTo writes the KeySignature into 'w' in format defined in
// the document #575623.
func (s *KeySignature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Key (ManifestFieldType: subStruct)
	{
		n, err := s.Key.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Key': %w", err)
		}
		totalN += int64(n)
	}

	// Signature (ManifestFieldType: subStruct)
	{
		n, err := s.Signature.WriteTo(w)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Signature': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// VersionSize returns the size in bytes of the value of field Version
func (s *KeySignature) VersionTotalSize() uint64 {
	return 1
}

// KeySize returns the size in bytes of the value of field Key
func (s *KeySignature) KeyTotalSize() uint64 {
	return s.Key.TotalSize()
}

// SignatureSize returns the size in bytes of the value of field Signature
func (s *KeySignature) SignatureTotalSize() uint64 {
	return s.Signature.TotalSize()
}

// VersionOffset returns the offset in bytes of field Version
func (s *KeySignature) VersionOffset() uint64 {
	return 0
}

// KeyOffset returns the offset in bytes of field Key
func (s *KeySignature) KeyOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// SignatureOffset returns the offset in bytes of field Signature
func (s *KeySignature) SignatureOffset() uint64 {
	return s.KeyOffset() + s.KeyTotalSize()
}

// Size returns the total size of the KeySignature.
func (s *KeySignature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.VersionTotalSize()
	size += s.KeyTotalSize()
	size += s.SignatureTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *KeySignature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Key Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Key", "", &s.Key, opts...)...)
	// ManifestFieldType is subStruct
	lines = append(lines, pretty.SubValue(depth+1, "Signature", "", &s.Signature, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/signature.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

import (
	"crypto"
	"crypto/rand"
	"fmt"
	"math/big"
)

var (
	// RandReader exports the rand.Reader
	RandReader = rand.Reader
)

// Signature exports the Signature structure
type Signature struct {
	SigScheme Algorithm `json:"sigScheme"`
	Version   uint8     `require:"0x10" json:"sigVersion,omitempty"`
	KeySize   BitSize   `json:"sigKeysize,omitempty"`
	HashAlg   Algorithm `json:"sigHashAlg"`
	Data      []byte    `countValue:"KeySize.InBytes()" prettyValue:"dataPrettyValue()" json:"sigData"`
}

func (m Signature) dataPrettyValue() interface{} {
	r, _ := m.SignatureData()
	return r
}

// SignatureData parses field Data and returns the signature as one of these types:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m Signature) SignatureData() (SignatureDataInterface, error) {
	switch m.SigScheme {
	case AlgRSAPSS:
		return SignatureRSAPSS(m.Data), nil
	case AlgRSASSA:
		return SignatureRSAASA(m.Data), nil
	case AlgECDSA:
		if len(m.Data) != 64 && len(m.Data) != 96 {
			return nil, fmt.Errorf("invalid length of the signature data: %d (expected 64 or 96)", len(m.Data))
		}
		return SignatureECDSA{
			R: new(big.Int).SetBytes(reverseBytes(m.Data[:len(m.Data)/2])),
			S: new(big.Int).SetBytes(reverseBytes(m.Data[len(m.Data)/2:])),
		}, nil
	case AlgSM2:
		if len(m.Data) != 64 && len(m.Data) != 96 {
			return nil, fmt.Errorf("invalid length of the signature data: %d (expected 64 or 96)", len(m.Data))
		}
		return SignatureSM2{
			R: new(big.Int).SetBytes(reverseBytes(m.Data[:len(m.Data)/2])),
			S: new(big.Int).SetBytes(reverseBytes(m.Data[len(m.Data)/2:])),
		}, nil
	}

	return nil, fmt.Errorf("unexpected signature scheme: %s", m.SigScheme)
}

// SetSignatureByData sets all the fields of the structure Signature by
// accepting one of these types as the input argument `sig`:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m *Signature) SetSignatureByData(sig SignatureDataInterface, hashAlgo Algorithm) error {
	err := m.SetSignatureData(sig)
	if err != nil {
		return err
	}

	switch sig := sig.(type) {
	case SignatureRSAPSS:
		m.SigScheme = AlgRSAPSS
		if hashAlgo.IsNull() {
			m.HashAlg = AlgSHA384
		} else {
			m.HashAlg = hashAlgo
		}
		m.KeySize.SetInBytes(uint16(len(m.Data)))
	case SignatureRSAASA:
		m.SigScheme = AlgRSASSA
		if hashAlgo.IsNull() {
			m.HashAlg = AlgSHA256
		} else {
			m.HashAlg = hashAlgo
		}
		m.KeySize.SetInBytes(uint16(len(m.Data)))
	case SignatureECDSA:
		m.SigScheme = AlgECDSA
		if hashAlgo.IsNull() {
			m.HashAlg = AlgSHA512
		} else {
			m.HashAlg = hashAlgo
		}
		m.KeySize.SetInBits(uint16(sig.R.BitLen()))
	case SignatureSM2:
		m.SigScheme = AlgSM2
		if hashAlgo.IsNull() {
			m.HashAlg = AlgSM3
		} else {
			m.HashAlg = hashAlgo
		}
		m.KeySize.SetInBits(uint16(sig.R.BitLen()))
	default:
		return fmt.Errorf("unexpected signature type: %T", sig)
	}
	return nil
}

// SetSignatureData sets the value of the field Data by accepting one of these
// types as the input argument `sig`:
// * SignatureRSAPSS
// * SignatureRSAASA
// * SignatureECDSA
// * SignatureSM2
func (m *Signature) SetSignatureData(sig SignatureDataInterface) error {
	switch sig := sig.(type) {
	case SignatureRSAPSS:
		m.Data = sig
	case SignatureRSAASA:
		m.Data = sig
	case SignatureECDSA, SignatureSM2:
		var r, s *big.Int
		switch sig := sig.(type) {
		case SignatureECDSA:
			r, s = sig.R, sig.S
		case SignatureSM2:
			r, s = sig.R, sig.S
		default:
			return fmt.Errorf("internal error")
		}
		if r.BitLen() != s.BitLen() {
			return fmt.Errorf("the length of component R (%d) is not equal to the length of component S (%d)", r.BitLen(), s.BitLen())
		}
		if r.BitLen() != 256 && r.BitLen() != 384 {
			return fmt.Errorf("component R (or S) size should be 256 or 384 bites (not %d)", r.BitLen())
		}
		m.Data = make([]byte, r.BitLen()/8+s.BitLen()/8)
		copy(m.Data[:], reverseBytes(r.Bytes()))
		copy(m.Data[r.BitLen()/8:], reverseBytes(s.Bytes()))
	default:
		return fmt.Errorf("unexpected signature type: %T", sig)
	}
	return nil
}

// SetSignature calculates the signature accordingly to arguments signAlgo,
// privKey and signedData; and sets all the fields of the structure Signature.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (m *Signature) SetSignature(signAlgo Algorithm, hashAlgo Algorithm, privKey crypto.Signer, signedData []byte) error {
	m.Version = 0x10
	m.HashAlg = hashAlgo
	signData, err := NewSignatureData(signAlgo, privKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to construct the signature data: %w", err)
	}
	err = m.SetSignatureByData(signData, m.HashAlg)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}

	return nil
}

// FillSignature sets the signature accordingly to arguments signAlgo,
// pubKey and signedData; and sets all the fields of the structure Signature.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func (m *Signature) FillSignature(signAlgo Algorithm, pubKey crypto.PublicKey, signedData []byte, hashAlgo Algorithm) error {
	m.Version = 0x10
	signData, err := NewSignatureByData(signAlgo, pubKey, signedData)
	if err != nil {
		return fmt.Errorf("unable to construct the signature data: %w", err)
	}

	err = m.SetSignatureByData(signData, hashAlgo)
	if err != nil {
		return fmt.Errorf("unable to set the signature: %w", err)
	}

	return nil
}

```

`pkg/intel/metadata/cbnt/signature_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewSignature returns a new instance of Signature with
// all default values set.
func NewSignature() *Signature {
	s := &Signature{}
	// Set through tag "required":
	s.Version = 0x10
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *Signature) Validate() error {
	// See tag "require"
	if s.Version != 0x10 {
		return fmt.Errorf("field 'Version' expects value '0x10', but has %v", s.Version)
	}

	return nil
}

// ReadFrom reads the Signature from 'r' in format defined in the document #575623.
func (s *Signature) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// SigScheme (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.SigScheme)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'SigScheme': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		size := uint16(s.KeySize.InBytes())
		s.Data = make([]byte, size)
		n, err := len(s.Data), binary.Read(r, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *Signature) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *Signature) Rehash() {
}

// WriteTo writes the Signature into 'w' in format defined in
// the document #575623.
func (s *Signature) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// SigScheme (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.SigScheme)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'SigScheme': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// KeySize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.KeySize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'KeySize': %w", err)
		}
		totalN += int64(n)
	}

	// HashAlg (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.HashAlg)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'HashAlg': %w", err)
		}
		totalN += int64(n)
	}

	// Data (ManifestFieldType: arrayDynamic)
	{
		n, err := len(s.Data), binary.Write(w, binary.LittleEndian, s.Data)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Data': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// SigSchemeSize returns the size in bytes of the value of field SigScheme
func (s *Signature) SigSchemeTotalSize() uint64 {
	return 2
}

// VersionSize returns the size in bytes of the value of field Version
func (s *Signature) VersionTotalSize() uint64 {
	return 1
}

// KeySizeSize returns the size in bytes of the value of field KeySize
func (s *Signature) KeySizeTotalSize() uint64 {
	return 2
}

// HashAlgSize returns the size in bytes of the value of field HashAlg
func (s *Signature) HashAlgTotalSize() uint64 {
	return 2
}

// DataSize returns the size in bytes of the value of field Data
func (s *Signature) DataTotalSize() uint64 {
	return uint64(len(s.Data))
}

// SigSchemeOffset returns the offset in bytes of field SigScheme
func (s *Signature) SigSchemeOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *Signature) VersionOffset() uint64 {
	return s.SigSchemeOffset() + s.SigSchemeTotalSize()
}

// KeySizeOffset returns the offset in bytes of field KeySize
func (s *Signature) KeySizeOffset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// HashAlgOffset returns the offset in bytes of field HashAlg
func (s *Signature) HashAlgOffset() uint64 {
	return s.KeySizeOffset() + s.KeySizeTotalSize()
}

// DataOffset returns the offset in bytes of field Data
func (s *Signature) DataOffset() uint64 {
	return s.HashAlgOffset() + s.HashAlgTotalSize()
}

// Size returns the total size of the Signature.
func (s *Signature) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.SigSchemeTotalSize()
	size += s.VersionTotalSize()
	size += s.KeySizeTotalSize()
	size += s.HashAlgTotalSize()
	size += s.DataTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *Signature) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Signature", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Sig Scheme", "", &s.SigScheme, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Key Size", "", &s.KeySize, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Hash Alg", "", &s.HashAlg, opts...)...)
	// ManifestFieldType is arrayDynamic
	lines = append(lines, pretty.SubValue(depth+1, "Data", "", s.dataPrettyValue(), opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/signature_types.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbnt

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/asn1"
	"fmt"
	"math/big"

	"github.com/tjfoc/gmsm/sm2"
)

var sm2UID = []byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}

// NewSignatureData returns an implementation of SignatureDataInterface,
// accordingly to signAlgo, privKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func NewSignatureData(
	signAlgo Algorithm,
	privKey crypto.Signer,
	signedData []byte,
) (SignatureDataInterface, error) {
	if signAlgo == 0 {
		// auto-detect the sign algorithm, based on the provided signing key
		pubKey := privKey.Public()
		switch k := pubKey.(type) {
		case *rsa.PublicKey:
			switch k.Size() {
			case 2048:
				signAlgo = AlgRSASSA
			case 3072:
				signAlgo = AlgRSAPSS
			}
		case *ecdsa.PublicKey:
			signAlgo = AlgECDSA
		case *sm2.PublicKey:
			signAlgo = AlgSM2
		}
	}
	switch signAlgo {
	case AlgRSAPSS:
		h := sha512.New384()
		_, _ = h.Write(signedData)
		bpmHash := h.Sum(nil)

		pss := rsa.PSSOptions{
			SaltLength: rsa.PSSSaltLengthAuto,
			Hash:       crypto.SHA384,
		}
		data, err := privKey.Sign(RandReader, bpmHash, &pss)
		if err != nil {
			return nil, fmt.Errorf("unable to sign with RSAPSS the data: %w", err)
		}
		return SignatureRSAPSS(data), nil
	case AlgRSASSA:
		h := sha256.New()
		_, _ = h.Write(signedData)
		bpmHash := h.Sum(nil)
		data, err := privKey.Sign(RandReader, bpmHash, crypto.SHA256)
		if err != nil {
			return nil, fmt.Errorf("unable to sign with RSASSA the data: %w", err)
		}
		return SignatureRSAASA(data), nil
	case AlgECDSA:
		eccPrivateKey, ok := privKey.(*ecdsa.PrivateKey)
		if !ok {
			return nil, fmt.Errorf("expected private ECDSA key (type %T), but received %T", eccPrivateKey, privKey)
		}
		var ecdsaSig SignatureECDSA
		data, err := privKey.Sign(RandReader, signedData, nil)
		if err != nil {
			return nil, fmt.Errorf("unable to sign with ECDSA the data: %w", err)
		}
		_, err = asn1.Unmarshal(data, &ecdsaSig)
		if err != nil {
			return nil, fmt.Errorf("unable to read ECDSA signature")
		}
		return ecdsaSig, nil
	case AlgSM2:
		eccPrivateKey, ok := privKey.(*sm2.PrivateKey)
		if !ok {
			return nil, fmt.Errorf("expected private SM2 key (type %T), but received %T", eccPrivateKey, privKey)
		}
		var data SignatureSM2
		var err error
		data.R, data.S, err = sm2.Sm2Sign(eccPrivateKey, signedData, sm2UID, RandReader)
		if err != nil {
			return nil, fmt.Errorf("unable to sign with SM2 the data: %w", err)
		}
		return data, nil
	}

	return nil, fmt.Errorf("signing algorithm '%s' is not implemented in this library", signAlgo)
}

// NewSignatureByData returns an implementation of SignatureDataInterface,
// accordingly to signAlgo, publicKey and signedData.
//
// if signAlgo is zero then it is detected automatically, based on the type
// of the provided private key.
func NewSignatureByData(
	signAlgo Algorithm,
	pubKey crypto.PublicKey,
	signedData []byte,
) (SignatureDataInterface, error) {
	if signAlgo == 0 {
		// auto-detect the sign algorithm, based on the provided signing key
		switch pubKey.(type) {
		case *rsa.PublicKey:
			signAlgo = AlgRSASSA
		case *ecdsa.PublicKey:
			signAlgo = AlgECDSA
		case *sm2.PublicKey:
			signAlgo = AlgSM2
		}
	}
	switch signAlgo {
	case AlgRSAPSS:
		return SignatureRSAPSS(signedData), nil
	case AlgRSASSA:
		return SignatureRSAASA(signedData), nil
	case AlgECDSA:
		return SignatureECDSA{
			R: new(big.Int).SetBytes(reverseBytes(signedData[:len(signedData)/2])),
			S: new(big.Int).SetBytes(reverseBytes(signedData[len(signedData)/2:])),
		}, nil
	case AlgSM2:
		return SignatureSM2{
			R: new(big.Int).SetBytes(reverseBytes(signedData[:len(signedData)/2])),
			S: new(big.Int).SetBytes(reverseBytes(signedData[len(signedData)/2:])),
		}, nil
	}
	return nil, fmt.Errorf("signing algorithm '%s' is not implemented in this library", signAlgo)
}

// SignatureDataInterface is the interface which abstracts all the signature data types.
type SignatureDataInterface interface {
	fmt.Stringer

	// Verify returns nil if signedData was indeed signed by key pk, and
	// returns an appropriate error otherwise.
	Verify(pk crypto.PublicKey, hashAlgo Algorithm, signedData []byte) error
}

// SignatureRSAPSS is RSAPSS signature bytes.
type SignatureRSAPSS []byte

// String implements fmt.Stringer
func (s SignatureRSAPSS) String() string {
	return fmt.Sprintf("0x%X", []byte(s))
}

// Verify implements SignatureDataInterface.
func (s SignatureRSAPSS) Verify(pkIface crypto.PublicKey, hashAlgo Algorithm, signedData []byte) error {
	pk, ok := pkIface.(*rsa.PublicKey)
	if !ok {
		return fmt.Errorf("expected public key of type %T, but received %T", pk, pkIface)
	}
	h, err := hashAlgo.Hash()
	if err != nil {
		return fmt.Errorf("invalid hash algorithm: %q", err)
	}
	if _, err := h.Write(signedData); err != nil {
		return fmt.Errorf("unable to hash the data: %w", err)
	}
	hash := h.Sum(nil)

	var hashfunc crypto.Hash
	switch hashAlgo {
	case AlgSHA256:
		hashfunc = crypto.SHA256
	case AlgSHA384:
		hashfunc = crypto.SHA384
	default:
		return fmt.Errorf("signature verification for RSAPSS only supports SHA256 and SHA384")
	}
	pss := rsa.PSSOptions{
		SaltLength: rsa.PSSSaltLengthAuto,
		Hash:       hashfunc,
	}
	err = rsa.VerifyPSS(pk, hashfunc, hash, s, &pss)
	if err != nil {
		return fmt.Errorf("signature does not correspond to the pub key: %w", err)
	}
	return nil
}

// SignatureRSAASA is RSAASA signature bytes.
type SignatureRSAASA []byte

// String implements fmt.Stringer
func (s SignatureRSAASA) String() string {
	return fmt.Sprintf("0x%X", []byte(s))
}

// Verify implements SignatureDataInterface.
func (s SignatureRSAASA) Verify(pkIface crypto.PublicKey, hashAlgo Algorithm, signedData []byte) error {
	pk, ok := pkIface.(*rsa.PublicKey)
	if !ok {
		return fmt.Errorf("expected public key of type %T, but received %T", pk, pkIface)
	}

	h, err := hashAlgo.Hash()
	if err != nil {
		return fmt.Errorf("invalid hash algorithm: %q", err)
	}
	if _, err := h.Write(signedData); err != nil {
		return fmt.Errorf("unable to hash the data: %w", err)
	}
	hash := h.Sum(nil)

	var hashfunc crypto.Hash
	switch hashAlgo {
	case AlgSHA256:
		hashfunc = crypto.SHA256
	case AlgSHA384:
		hashfunc = crypto.SHA384
	default:
		return fmt.Errorf("signature verification for RSAASA only supports SHA256 and SHA384")
	}

	err = rsa.VerifyPKCS1v15(pk, hashfunc, hash, s)
	if err != nil {
		return fmt.Errorf("signature does not correspond to the pub key: %w", err)
	}

	return nil
}

// SignatureECDSA is a structure with components of an ECDSA signature.
type SignatureECDSA struct {
	// R is the R component of the signature.
	R *big.Int
	// S is the S component of the signature.
	S *big.Int
}

// String implements fmt.Stringer
func (s SignatureECDSA) String() string {
	return fmt.Sprintf("{R: 0x%X, S: 0x%X}", s.R, s.S)
}

// Verify implements SignatureDataInterface.
func (s SignatureECDSA) Verify(pkIface crypto.PublicKey, hashAlgo Algorithm, signedData []byte) error {
	return fmt.Errorf("support of ECDSA signatures is not implemented, yet")
}

// SignatureSM2 is a structure with components of an SM2 signature.
type SignatureSM2 struct {
	// R is the R component of the signature.
	R *big.Int
	// S is the S component of the signature.
	S *big.Int
}

// String implements fmt.Stringer
func (s SignatureSM2) String() string {
	return fmt.Sprintf("{R: 0x%X, S: 0x%X}", s.R, s.S)
}

// Verify implements SignatureDataInterface.
func (s SignatureSM2) Verify(pkIface crypto.PublicKey, hashAlgo Algorithm, signedData []byte) error {
	return fmt.Errorf("support of SM2 signatures is not implemented, yet")
}

```

`pkg/intel/metadata/cbnt/structure.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

import (
	"encoding/binary"
	"io"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	binaryOrder = binary.LittleEndian
)

// StructInfo is the common part of any structure of a manifest
type StructInfo struct {
	ID          StructureID `json:"StructInfoID"`
	Version     uint8       `json:"StructInfoVersion"`
	Variable0   uint8       `json:"StructInfoVariable0"`
	ElementSize uint16      `json:"StructInfoElementSize"`
}

// StructInfo just returns StructInfo, it is a handy method if StructInfo
// is included anonymously to another type.
func (s StructInfo) StructInfo() StructInfo {
	return s
}

// StructureID is the magic ID string used to identify the structure type
// in the manifest
type StructureID [8]byte

// String returns the ID as a string.
func (s StructureID) String() string {
	return string(s[:])
}

// Structure is an abstraction of a structure of a manifest.
type Structure interface {
	io.ReaderFrom
	io.WriterTo
	TotalSize() uint64
	// PrettyString returns the whole object as a structured string.
	PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string
}

// Element is an abstraction of an element of a manifest.
type Element interface {
	Structure
	ReadDataFrom(r io.Reader) (int64, error)
	GetStructInfo() StructInfo
	SetStructInfo(StructInfo)
}

// ElementsContainer is an abstraction of set of elements of a manifest (for
// example: the root structure of BPM).
type ElementsContainer interface {
	Structure
	GetFieldByStructID(structID string) interface{}
}

// Manifest is an abstract manifest.
type Manifest interface {
	Structure
}

```

`pkg/intel/metadata/cbnt/structure_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewStructInfo returns a new instance of StructInfo with
// all default values set.
func NewStructInfo() *StructInfo {
	s := &StructInfo{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *StructInfo) Validate() error {

	return nil
}

// ReadFrom reads the StructInfo from 'r' in format defined in the document #575623.
func (s *StructInfo) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// ID (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Read(r, binary.LittleEndian, s.ID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ID': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Variable0 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Read(r, binary.LittleEndian, &s.Variable0)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Variable0': %w", err)
		}
		totalN += int64(n)
	}

	// ElementSize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Read(r, binary.LittleEndian, &s.ElementSize)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'ElementSize': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *StructInfo) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *StructInfo) Rehash() {
}

// WriteTo writes the StructInfo into 'w' in format defined in
// the document #575623.
func (s *StructInfo) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// ID (ManifestFieldType: arrayStatic)
	{
		n, err := 8, binary.Write(w, binary.LittleEndian, s.ID[:])
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ID': %w", err)
		}
		totalN += int64(n)
	}

	// Version (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Version)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Version': %w", err)
		}
		totalN += int64(n)
	}

	// Variable0 (ManifestFieldType: endValue)
	{
		n, err := 1, binary.Write(w, binary.LittleEndian, &s.Variable0)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Variable0': %w", err)
		}
		totalN += int64(n)
	}

	// ElementSize (ManifestFieldType: endValue)
	{
		n, err := 2, binary.Write(w, binary.LittleEndian, &s.ElementSize)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'ElementSize': %w", err)
		}
		totalN += int64(n)
	}

	return totalN, nil
}

// IDSize returns the size in bytes of the value of field ID
func (s *StructInfo) IDTotalSize() uint64 {
	return 8
}

// VersionSize returns the size in bytes of the value of field Version
func (s *StructInfo) VersionTotalSize() uint64 {
	return 1
}

// Variable0Size returns the size in bytes of the value of field Variable0
func (s *StructInfo) Variable0TotalSize() uint64 {
	return 1
}

// ElementSizeSize returns the size in bytes of the value of field ElementSize
func (s *StructInfo) ElementSizeTotalSize() uint64 {
	return 2
}

// IDOffset returns the offset in bytes of field ID
func (s *StructInfo) IDOffset() uint64 {
	return 0
}

// VersionOffset returns the offset in bytes of field Version
func (s *StructInfo) VersionOffset() uint64 {
	return s.IDOffset() + s.IDTotalSize()
}

// Variable0Offset returns the offset in bytes of field Variable0
func (s *StructInfo) Variable0Offset() uint64 {
	return s.VersionOffset() + s.VersionTotalSize()
}

// ElementSizeOffset returns the offset in bytes of field ElementSize
func (s *StructInfo) ElementSizeOffset() uint64 {
	return s.Variable0Offset() + s.Variable0TotalSize()
}

// Size returns the total size of the StructInfo.
func (s *StructInfo) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.IDTotalSize()
	size += s.VersionTotalSize()
	size += s.Variable0TotalSize()
	size += s.ElementSizeTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *StructInfo) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "Struct Info", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is arrayStatic
	lines = append(lines, pretty.SubValue(depth+1, "ID", "", &s.ID, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Version", "", &s.Version, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Variable 0", "", &s.Variable0, opts...)...)
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Element Size", "", &s.ElementSize, opts...)...)
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

```

`pkg/intel/metadata/cbnt/svn.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cbnt

// SVN represents Security Version Number.
type SVN uint8

// SVN returns the Security Version Number of an SVN field
func (svn SVN) SVN() uint8 {
	return uint8(svn) & 0x0f
}

```

`pkg/intel/metadata/cbnt/tpm_info_list.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate manifestcodegen

package cbnt

// TPM2PCRExtendPolicySupport defined TPM2 PCR Extend policy support.
type TPM2PCRExtendPolicySupport uint8

// Possible values of TPM2PCRExtendPolicySupport
const (
	TPM2PCRExtendIllegal                  TPM2PCRExtendPolicySupport = 0
	TPM2PCRExtendMaximumAgilityPolicy     TPM2PCRExtendPolicySupport = 1
	TPM2PCRExtendMaximumPerformancePolicy TPM2PCRExtendPolicySupport = 2
	TPM2PCRExtendBothPolicies             TPM2PCRExtendPolicySupport = 3
)

// TPMFamilySupport defines TPM family support
type TPMFamilySupport uint8

// IsDiscreteTPM12Supported returns true if discrete TPM1.2 is supported.
// PrettyString-true:  Discrete TPM1.2 is supported
// PrettyString-false: Discrete TPM1.2 is not supported
func (familySupport TPMFamilySupport) IsDiscreteTPM12Supported() bool {
	return familySupport&1 != 0
}

// IsDiscreteTPM20Supported returns true if discrete TPM2.0 is supported.
// PrettyString-true:  Discrete TPM2.0 is supported
// PrettyString-false: Discrete TPM2.0 is not supported
func (familySupport TPMFamilySupport) IsDiscreteTPM20Supported() bool {
	return familySupport&2 != 0
}

// IsFirmwareTPM20Supported returns true if firmware TPM2.0 is supported.
// PrettyString-true:  Firmware TPM2.0 is supported
// PrettyString-false: Firmware TPM2.0 is not supported
func (familySupport TPMFamilySupport) IsFirmwareTPM20Supported() bool {
	return familySupport&(1<<3) != 0
}

// TPMCapabilities defines TPM capabilities
type TPMCapabilities uint32

// TPM2PCRExtendPolicySupport returns TPM2PCRExtendPolicySupport
func (cap TPMCapabilities) TPM2PCRExtendPolicySupport() TPM2PCRExtendPolicySupport {
	return TPM2PCRExtendPolicySupport(cap & 3)
}

// TPMFamilySupport returns TPMFamilySupport
func (cap TPMCapabilities) TPMFamilySupport() TPMFamilySupport {
	return TPMFamilySupport((cap >> 2) & 15)
}

// TPMInfoList represents TPM capabilities supported by ACM
type TPMInfoList struct {
	Capabilities TPMCapabilities
	Algorithms   []Algorithm
}

```

`pkg/intel/metadata/cbnt/tpm_info_list_manifestcodegen.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen github.com/linuxboot/fiano/pkg/intel/metadata/cbnt

package cbnt

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
)

// NewTPMInfoList returns a new instance of TPMInfoList with
// all default values set.
func NewTPMInfoList() *TPMInfoList {
	s := &TPMInfoList{}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *TPMInfoList) Validate() error {

	return nil
}

// ReadFrom reads the TPMInfoList from 'r' in format defined in the document #575623.
func (s *TPMInfoList) ReadFrom(r io.Reader) (int64, error) {
	totalN := int64(0)

	// Capabilities (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Read(r, binary.LittleEndian, &s.Capabilities)
		if err != nil {
			return totalN, fmt.Errorf("unable to read field 'Capabilities': %w", err)
		}
		totalN += int64(n)
	}

	// Algorithms (ManifestFieldType: list)
	{
		var count uint16
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field 'Algorithms': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.Algorithms = make([]Algorithm, count)

		for idx := range s.Algorithms {
			n, err := s.Algorithms[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field 'Algorithms[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// RehashRecursive calls Rehash (see below) recursively.
func (s *TPMInfoList) RehashRecursive() {
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *TPMInfoList) Rehash() {
}

// WriteTo writes the TPMInfoList into 'w' in format defined in
// the document #575623.
func (s *TPMInfoList) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

	// Capabilities (ManifestFieldType: endValue)
	{
		n, err := 4, binary.Write(w, binary.LittleEndian, &s.Capabilities)
		if err != nil {
			return totalN, fmt.Errorf("unable to write field 'Capabilities': %w", err)
		}
		totalN += int64(n)
	}

	// Algorithms (ManifestFieldType: list)
	{
		count := uint16(len(s.Algorithms))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field 'Algorithms': %w", err)
		}
		totalN += int64(binary.Size(count))
		for idx := range s.Algorithms {
			n, err := s.Algorithms[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field 'Algorithms[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
	}

	return totalN, nil
}

// CapabilitiesSize returns the size in bytes of the value of field Capabilities
func (s *TPMInfoList) CapabilitiesTotalSize() uint64 {
	return 4
}

// AlgorithmsSize returns the size in bytes of the value of field Algorithms
func (s *TPMInfoList) AlgorithmsTotalSize() uint64 {
	var size uint64
	size += uint64(binary.Size(uint16(0)))
	for idx := range s.Algorithms {
		size += s.Algorithms[idx].TotalSize()
	}
	return size
}

// CapabilitiesOffset returns the offset in bytes of field Capabilities
func (s *TPMInfoList) CapabilitiesOffset() uint64 {
	return 0
}

// AlgorithmsOffset returns the offset in bytes of field Algorithms
func (s *TPMInfoList) AlgorithmsOffset() uint64 {
	return s.CapabilitiesOffset() + s.CapabilitiesTotalSize()
}

// Size returns the total size of the TPMInfoList.
func (s *TPMInfoList) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
	size += s.CapabilitiesTotalSize()
	size += s.AlgorithmsTotalSize()
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *TPMInfoList) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TPM Info List", s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
	// ManifestFieldType is endValue
	lines = append(lines, pretty.SubValue(depth+1, "Capabilities", "", &s.Capabilities, opts...)...)
	// ManifestFieldType is list
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf("Algorithms: Array of \"TPM Info List\" of length %d", len(s.Algorithms)), s.Algorithms))
	for i := 0; i < len(s.Algorithms); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i)+strings.TrimSpace(s.Algorithms[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v TPM2PCRExtendPolicySupport) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TPM 2 PCR Extend Policy Support", v))
	}
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v TPM2PCRExtendPolicySupport) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the TPM2PCRExtendPolicySupport into 'w' in binary format.
func (v TPM2PCRExtendPolicySupport) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the TPM2PCRExtendPolicySupport from 'r' in binary format.
func (v TPM2PCRExtendPolicySupport) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v TPMCapabilities) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TPM Capabilities", v))
	}
	lines = append(lines, pretty.SubValue(depth+1, "TPM 2 PCR Extend Policy Support", "", v.TPM2PCRExtendPolicySupport(), opts...)...)
	lines = append(lines, pretty.SubValue(depth+1, "TPM Family Support", "", v.TPMFamilySupport(), opts...)...)
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v TPMCapabilities) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the TPMCapabilities into 'w' in binary format.
func (v TPMCapabilities) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the TPMCapabilities from 'r' in binary format.
func (v TPMCapabilities) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

// PrettyString returns the bits of the flags in an easy-to-read format.
func (v TPMFamilySupport) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, "TPM Family Support", v))
	}
	if v.IsDiscreteTPM12Supported() {
		lines = append(lines, pretty.SubValue(depth+1, "Is Discrete TPM 12 Supported", "Discrete TPM1.2 is supported", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Is Discrete TPM 12 Supported", "Discrete TPM1.2 is not supported", false, opts...)...)
	}
	if v.IsDiscreteTPM20Supported() {
		lines = append(lines, pretty.SubValue(depth+1, "Is Discrete TPM 20 Supported", "Discrete TPM2.0 is supported", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Is Discrete TPM 20 Supported", "Discrete TPM2.0 is not supported", false, opts...)...)
	}
	if v.IsFirmwareTPM20Supported() {
		lines = append(lines, pretty.SubValue(depth+1, "Is Firmware TPM 20 Supported", "Firmware TPM2.0 is supported", true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "Is Firmware TPM 20 Supported", "Firmware TPM2.0 is not supported", false, opts...)...)
	}
	return strings.Join(lines, "\n")
}

// TotalSize returns the total size measured through binary.Size.
func (v TPMFamilySupport) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the TPMFamilySupport into 'w' in binary format.
func (v TPMFamilySupport) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the TPMFamilySupport from 'r' in binary format.
func (v TPMFamilySupport) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

```

`pkg/intel/metadata/common/bgheader/bgheader.go`:

```go
// Copyright 2017-2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bgheader

import (
	"encoding/binary"
	"fmt"
	"io"
)

var (
	binaryOrder = binary.LittleEndian
)

type structInfo struct {
	ID      structureID `json:"StructInfoID"`
	Version uint8       `json:"StructInfoVersion"`
}

type structureID [8]byte

type BootGuardVersion uint8

const (
	Version10 BootGuardVersion = 1
	Version20 BootGuardVersion = 2
)

func (bgv BootGuardVersion) String() string {
	switch bgv {
	case Version10:
		return "1.0"
	case Version20:
		return "2.0"
	}
	return "unknown"
}

func DetectBGV(r io.ReadSeeker) (BootGuardVersion, error) {
	var s structInfo
	err := binary.Read(r, binaryOrder, &s)
	if err != nil {
		return 0, fmt.Errorf("unable to read field 'ID': %w", err)
	}
	_, err = r.Seek(0, 0)
	if err != nil {
		return 0, err
	}
	if s.Version >= 0x20 {
		return Version20, nil
	} else if (s.Version < 0x20) && (s.Version >= 0x10) {
		return Version10, nil
	} else {
		return 0, fmt.Errorf("couldn't detect version")
	}
}

```

`pkg/intel/metadata/common/examples/cmd/bpmdump/main.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"log"
	"os"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy"
)

func assertNoError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {
	f, err := os.Open(os.Args[1])
	assertNoError(err)

	m := &cbntbootpolicy.Manifest{}
	_, err = m.ReadFrom(f)
	assertNoError(err)

	fmt.Printf("%s", m.PrettyString(0, true))
}

```

`pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen/main.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/pkg/analyze"
)

func deleteBackupFiles(dirPath string) error {
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return fmt.Errorf("unable to open '%s' as dir: %w", dirPath, err)
	}

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), "_manifestcodegen.go~") {
			continue
		}

		path := filepath.Join(dirPath, file.Name())
		err := os.Remove(path)
		if err != nil {
			return fmt.Errorf("unable to delete file '%s': %w", path, err)
		}
	}

	return nil
}

func backupGeneratedFiles(dirPath string, isReverse bool) error {
	files, err := os.ReadDir(dirPath)
	if err != nil {
		return fmt.Errorf("unable to open '%s' as dir: %w", dirPath, err)
	}

	suffix := "_manifestcodegen.go"
	if isReverse {
		suffix += "~"
	}

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), suffix) {
			continue
		}

		var err error
		path := filepath.Join(dirPath, file.Name())
		if isReverse {
			err = os.Rename(path, path[:len(path)-1])
		} else {
			err = os.Rename(path, path+"~")
		}
		if err != nil {
			return fmt.Errorf("unable to delete file '%s': %w", path, err)
		}
	}

	return nil
}

func processPath(path string, isCheck, enableTracing bool, packageName string) error {
	if stat, err := os.Stat(path); err == nil && stat.IsDir() {
		err := backupGeneratedFiles(path, false)
		if err != nil {
			return fmt.Errorf("unable to rename old generated files: %w", err)
		}
	}

	var goPaths []string
	if gopathEnv := os.Getenv("GOPATH"); gopathEnv != "" {
		goPaths = filepath.SplitList(gopathEnv)
	} else {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("unable to determine the homedir: %w", err)
		}

		goPaths = append(goPaths, filepath.Join(homeDir, "go"))
	}

	dirInfo, err := analyze.Scan(path, goPaths)
	if err != nil {
		return fmt.Errorf("unable to analyze path '%s': %w", path, err)
	}

	for _, fileInfo := range dirInfo.Files {
		err := generateMethodsFile(*fileInfo, isCheck, enableTracing, packageName)
		if err != nil {
			_ = backupGeneratedFiles(path, true)
			return err
		}
	}

	if isCheck {
		err := backupGeneratedFiles(path, true)
		if err != nil {
			return fmt.Errorf("unable to rename back old generated files: %w", err)
		}
	} else {
		err := deleteBackupFiles(path)
		if err != nil {
			return fmt.Errorf("unable to rename back old generated files: %w", err)
		}
	}

	return nil
}

func processPaths(paths []string, checkFlag, traceFlag bool, packageName string) int {
	errorCount := 0
	for _, path := range paths {
		err := processPath(path, checkFlag, traceFlag, packageName)
		if err != nil {
			log.Printf("an error: %v", err)
			errorCount++
		}
	}

	return errorCount
}

func main() {
	checkFlag := flag.Bool("check", false, "generate with tracing code")
	traceFlag := flag.Bool("trace", false, "generate with tracing code")
	packageName := flag.String("package", "TODO_PACKAGE", "target package name")
	flag.Parse()

	var paths []string

	switch {
	case flag.NArg() > 0:
		paths = append(paths, flag.Args()...)
	case os.Getenv("GOFILE") != "":
		paths = append(paths, os.Getenv("GOFILE"))
	default:
		paths = append(paths, ".")
	}

	errorCount := processPaths(paths, *checkFlag, *traceFlag, *packageName)
	if errorCount != 0 {
		os.Exit(1)
	}
}

```

`pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen/template_methods.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path"
	"reflect"
	"strings"
	"text/template"

	"github.com/fatih/camelcase"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/pkg/analyze"
)

type methodsData struct {
	analyze.File
	EnableTracing bool
	PackageName   string
}

// generateMethodsFile generates a file using the template above.
//
// The file name is constructed from the original file name, but with
// adding suffix '_manifestcodegen' before the file extension.
func generateMethodsFile(file analyze.File, isCheck, enableTracing bool, packageName string) error {
	funcsMap := map[string]interface{}{
		"add": func(a, b int) int { return a + b },
		"ternary": func(cond bool, a, b interface{}) interface{} {
			if cond {
				return a
			}
			return b
		},
		"isNil": func(v interface{}) bool {
			return reflect.ValueOf(v).IsNil()
		},
		"camelcaseToSentence": func(in string) string {
			return strings.Join(camelcase.Split(in), " ")
		},
		"join": func(a, b interface{}) interface{} {
			return fmt.Sprintf("%s%s", a, b)
		},
	}

	if len(file.Structs) == 0 && len(file.BasicNamedTypes) == 0 {
		return nil
	}

	templateMethods, err := template.New("methods").Funcs(funcsMap).Parse(templateMethods)
	if err != nil {
		return fmt.Errorf("unable to parse the template: %w", err)
	}
	if ext := path.Ext(file.Path); ext != ".go" {
		return fmt.Errorf("invalid extension: '%s'", ext)
	}
	generatedFile := fmt.Sprintf("%s_manifestcodegen.go",
		file.Path[:len(file.Path)-3],
	)

	var outFile string
	if isCheck {
		outFile = generatedFile + "-check.go"
	} else {
		outFile = generatedFile
	}

	f, err := os.OpenFile(outFile, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("unable to open file '%s' for writing: %w", outFile, err)
	}
	defer func() {
		if isCheck {
			err := os.Remove(outFile)
			if err != nil {
				log.Printf("unable to remove file '%s': %v\n", outFile, err)
			}
		}
		err := f.Close()
		if err != nil {
			log.Printf("unable to close file '%s': %v\n", outFile, err)
		}
	}()

	err = templateMethods.Execute(f, methodsData{
		File:          file,
		EnableTracing: enableTracing,
		PackageName:   packageName,
	})
	if err != nil {
		return fmt.Errorf("unable to write: %w", err)
	}
	err = exec.Command("go", "fmt", outFile).Run()
	if err != nil {
		return fmt.Errorf("unable to format file '%s': %w", outFile, err)
	}

	if isCheck {
		b0, err := os.ReadFile(outFile)
		if err != nil {
			return fmt.Errorf("unable to read a temp file '%s'", outFile)
		}
		b1, err := os.ReadFile(generatedFile + "~")
		if err != nil {
			return fmt.Errorf("unable to read file '%s'", generatedFile)
		}
		if !bytes.Equal(b0, b1) {
			return fmt.Errorf("file '%s' is not up-to-date; please run command: "+
				"go run github.com/linuxboot/fiano/pkg/intel/metadata/manifest/common/manifestcodegen/cmd/manifestcodegen %s",
				generatedFile, file.Package.Path())
		}
	}
	return nil
}

```

`pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen/template_methods.tpl.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main // TODO: replace this file with "embed", when it will be released: https://github.com/golang/go/issues/41191
const templateMethods = `// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !manifestcodegen
// +build !manifestcodegen

// Code generated by "menifestcodegen". DO NOT EDIT.
// To reproduce: go run github.com/linuxboot/fiano/pkg/intel/metadata/common/manifestcodegen/cmd/manifestcodegen -package {{ .PackageName }} {{ .Package.Path }}

package {{ .Package.Name }}

import (
{{- if not .EnableTracing }}
	"encoding/binary"
{{- else }}
	binary "github.com/linuxboot/fiano/pkg/intel/metadata/common/tracedbinary"
{{- end }}
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/common/pretty"
{{- if and (ne .Package.Name "cbnt") (ne .Package.Name "bg") }}
	"github.com/linuxboot/fiano/pkg/intel/metadata/{{.PackageName}}"
{{- end }}
)

var (
	// Just to avoid errors in "import" above in case if it wasn't used below
	_ = binary.LittleEndian
	_ = (fmt.Stringer)(nil)
	_ = (io.Reader)(nil)
	_ = pretty.Header
	_ = strings.Join
{{- if and (ne .Package.Name "cbnt") (ne .Package.Name "bg") }}
	_ = {{.PackageName}}.StructInfo{}
{{- end }}
)

{{- $manifestRootPath := join .PackageName "." }}
{{- $enableTracing := .EnableTracing }}

{{- range $index, $struct := .Structs }}

// New{{ $struct.Name }} returns a new instance of {{ $struct.Name }} with
// all default values set.
func New{{ $struct.Name }}() *{{ $struct.Name }} {
	s := &{{ $struct.Name }}{}
 {{- if ne $struct.ElementStructID "" }}
	copy(s.StructInfo.ID[:], []byte(StructureID{{ $struct.Name }}))
	s.StructInfo.Version = {{ $struct.ElementStructVersion }}
 {{- end }}
 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}
  {{- if and (not $field.IsSlice) (not $field.IsPointer) (or (eq $fieldType "element") (eq $fieldType "subStruct")) }}
	// Recursively initializing a child structure:
	s.{{ $field.Name }} = *{{ $field.AccessPrefix }}New{{ $field.ItemTypeName }}()
  {{- end }}
  {{- $defaultValue := ternary (ne $field.RequiredValue "") $field.RequiredValue $field.DefaultValue }}
  {{- $defaultValueSource := ternary (ne $field.RequiredValue "") "required" "default" }}
  {{- if ne $defaultValue "" }}
   {{- if eq $fieldType "arrayStatic" }}
    {{- if ne $defaultValue "0" }}
	// Set through tag "{{ $defaultValueSource }}":
	for idx := range s.{{ $field.Name }} {
		s.{{ $field.Name }}[idx] = {{ $defaultValue }}
	}
    {{- end }}
   {{- else }}
	// Set through tag "{{ $defaultValueSource }}":
	s.{{ $field.Name }} = {{ $defaultValue }}
   {{- end }}
  {{- end }}
 {{- end }}
	s.Rehash()
	return s
}

// Validate (recursively) checks the structure if there are any unexpected
// values. It returns an error if so.
func (s *{{ $struct.Name }}) Validate() error {
 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}
  {{- if and (not $field.IsSlice) (not $field.IsPointer) (or (eq $fieldType "element") (eq $fieldType "subStruct")) }}
	// Recursively validating a child structure:
	if err := s.{{ $field.Name }}.Validate(); err != nil {
		return fmt.Errorf("error on field '{{ $field.Name }}': %w", err)
	}
  {{- end }}
  {{- if ne $field.RequiredValue "" }}
	// See tag "require"
   {{- if eq $fieldType "arrayStatic" }}
	for idx := range s.{{ $field.Name }} {
		if s.{{ $field.Name }}[idx] != {{ $field.RequiredValue }} {
			return fmt.Errorf("'{{ $field.Name }}[%d]' is expected to be {{ $field.RequiredValue }}, but it is %v", idx, s.{{ $field.Name }}[idx])
		}
	}
   {{- else }}
	if s.{{ $field.Name }} != {{ $field.RequiredValue }} {
		return fmt.Errorf("field '{{ $field.Name }}' expects value '{{ $field.RequiredValue }}', but has %v", s.{{ $field.Name }})
	}
   {{- end }}
  {{- end }}
  {{- if ne $field.RehashValue "" }}
	// See tag "rehashValue"
	{
		expectedValue := {{ $field.Type }}(s.{{ $field.RehashValue }})
		if s.{{ $field.Name }} != expectedValue {
			return fmt.Errorf("field '{{ $field.Name }}' expects write-value '%v', but has %v", expectedValue, s.{{ $field.Name }})
		}
	}
  {{- end }}
 {{- end }}

	return nil
}

{{- if ne $struct.ElementStructID "" }}
// StructureID{{ $struct.Name }} is the StructureID (in terms of
// the document #575623) of element '{{ $struct.Name }}'.
const StructureID{{ $struct.Name }} = "{{ $struct.ElementStructID }}"

// GetStructInfo returns current value of StructInfo of the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *{{ $struct.Name }}) GetStructInfo() {{ $manifestRootPath }}StructInfo {
	return s.StructInfo
}

// SetStructInfo sets new value of StructInfo to the structure.
//
// StructInfo is a set of standard fields with presented in any element
// ("element" in terms of document #575623).
func (s *{{ $struct.Name }}) SetStructInfo(newStructInfo {{ $manifestRootPath }}StructInfo) {
	s.StructInfo = newStructInfo
}

{{- end }}

{{- if $struct.IsElementsContainer }}

// fieldIndexByStructID returns the position index within
// structure {{ $struct.Name }} of the field by its StructureID
// (see document #575623, an example of StructureID value is "__KEYM__").
func (_ {{ $struct.Name }}) fieldIndexByStructID(structID string) int {
	switch structID {
 {{- range $index, $field := $struct.Fields }}
	case StructureID{{ $field.Struct.Name }}:
		return {{ $index }}
 {{- end }}
	}

	return -1
}

// fieldNameByIndex returns the name of the field by its position number
// within structure {{ $struct.Name }}.
func (_ {{ $struct.Name }}) fieldNameByIndex(fieldIndex int) string {
	switch fieldIndex {
 {{- range $index, $field := $struct.Fields }}
	case {{ $index }}:
		return "{{ $field.Name }}"
 {{- end }}
	}

	return fmt.Sprintf("invalidFieldIndex_%d", fieldIndex)
}

// ReadFrom reads the {{ $struct.Name }} from 'r' in format defined in the document #575623.
func (s *{{ $struct.Name }}) ReadFrom(r io.Reader) (returnN int64, returnErr error) {
	var missingFieldsByIndices = [{{ len $struct.Fields }}]bool{
 {{- range $index, $field := $struct.Fields }}
  {{- if and (not $field.IsSlice) (not $field.IsPointer) }}
		{{ $index }}: true,
  {{- end }}
 {{- end }}
	}
	defer func() {
		if returnErr != nil {
			return
		}
		for fieldIndex, v := range missingFieldsByIndices {
			if v {
				returnErr = fmt.Errorf("field '%s' is missing", s.fieldNameByIndex(fieldIndex))
				break
			}
		}
	}()
	var totalN int64
	previousFieldIndex := int(-1)
	for {
		var structInfo {{ $manifestRootPath }}StructInfo
		err := binary.Read(r, binary.LittleEndian, &structInfo)
		if err == io.EOF || err == io.ErrUnexpectedEOF {
			return totalN, nil
		}
		if err != nil {
			return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
		}
    	{{- if $enableTracing }}
		fmt.Printf("%s header parsed, TotalN is %d -> %d\n", structInfo.ID.String(), totalN, totalN + int64(binary.Size(structInfo))){{- end}}
		totalN += int64(binary.Size(structInfo))

		structID := structInfo.ID.String()
		fieldIndex := s.fieldIndexByStructID(structID)
		if fieldIndex < 0 {
			// TODO: report error "unknown structure ID: '"+structID+"'"
			continue
		}
		if {{ $manifestRootPath }}StrictOrderCheck && fieldIndex < previousFieldIndex {
			return totalN, fmt.Errorf("invalid order of fields (%d < %d): structure '%s' is out of order", fieldIndex, previousFieldIndex, structID)
		}
		missingFieldsByIndices[fieldIndex] = false

		var n int64
		switch structID {
 {{- range $index, $field := $struct.Fields }}
		case StructureID{{ $field.Struct.Name }}:
  {{- if $field.IsSlice }}
			var el {{ $field.Struct.TypeSpec.Name.String }}
			el.SetStructInfo(structInfo)
			n, err = el.ReadDataFrom(r)
			s.{{ $field.Name }} = append(s.{{ $field.Name }}, el)
  {{- else }}
			if fieldIndex == previousFieldIndex {
				return totalN, fmt.Errorf("field '{{ $field.Name }}' is not a slice, but multiple elements found")
			}
   {{- if $field.IsPointer }}
			s.{{ $field.Name }} = &{{ $field.Struct.TypeSpec.Name.String }}{}
   {{- end }}
			s.{{ $field.Name }}.SetStructInfo(structInfo)
			n, err = s.{{ $field.Name }}.ReadDataFrom(r)
  {{- end }}
			if err != nil {
				return totalN, fmt.Errorf("unable to read field {{ $field.Name }} at %d: %w", totalN, err)
			}
 {{- end }}
		default:
			return totalN, fmt.Errorf("there is no field with structure ID '%s' in {{ $struct.Name }}", structInfo.ID)
		}
    	{{- if $enableTracing }}
		fmt.Printf("%s parsed, TotalN is %d -> %d\n", structID, totalN, totalN + n){{- end}}
		totalN += n
		previousFieldIndex = fieldIndex
	}
}

{{- else }}

// ReadFrom reads the {{ $struct.Name }} from 'r' in format defined in the document #575623.
func (s *{{ $struct.Name }}) ReadFrom(r io.Reader) (int64, error) {
{{- if ne $struct.ElementStructID "" }}
	var totalN int64

	err := binary.Read(r, binary.LittleEndian, &s.StructInfo)
	if err != nil {
		return totalN, fmt.Errorf("unable to read structure info at %d: %w", totalN, err)
	}
	totalN += int64(binary.Size(s.StructInfo))

	n, err := s.ReadDataFrom(r)
	if err != nil {
		return totalN, fmt.Errorf("unable to read data: %w", err)
	}
	totalN += n

	return totalN, nil
}

// ReadDataFrom reads the {{ $struct.Name }} from 'r' excluding StructInfo,
// in format defined in the document #575623.
func (s *{{ $struct.Name }}) ReadDataFrom(r io.Reader) (int64, error) {
{{- end }}
	totalN := int64(0)
 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}

	// {{ $field.Name }} (ManifestFieldType: {{ $field.ManifestFieldType.String }})
    {{- if and ($enableTracing) (ne $fieldType "structInfo") }}
	fmt.Printf("{{ $struct.Name }}.{{ $field.Name }} (old TotalN is %d)\n", totalN){{- end}}
	{
  {{- if eq $fieldType "endValue" }}
		n, err := {{ $field.TypeStdSize}}, binary.Read(r, binary.LittleEndian, &s.{{ $field.Name }})
  {{- end }}
  {{- if eq $fieldType "structInfo" }}
		// ReadDataFrom does not read Struct, use ReadFrom for that.
  {{- end }}
  {{- if eq $fieldType "subStruct" }}
   {{- if $field.IsPointer }}
		s.{{ $field.Name }} = &{{ $field.ItemTypeName }}{}
   {{- end }}
		n, err := s.{{ $field.Name }}.ReadFrom(r)
  {{- end }}
  {{- if eq $fieldType "arrayStatic" }}
		n, err := {{ $field.TypeStdSize }}, binary.Read(r, binary.LittleEndian, s.{{ $field.Name }}[:])
  {{- end }}
  {{- if eq $fieldType "arrayDynamic" }}
   {{- if eq $field.CountValue "" }}
    	var size {{ $field.CountType }}
		err := binary.Read(r, binary.LittleEndian, &size)
		if err != nil {
			return totalN, fmt.Errorf("unable to the read size of field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(binary.Size(size))
   {{- else }}
		size := {{ $field.CountType }}(s.{{ $field.CountValue }})
   {{- end }}
		s.{{ $field.Name }} = make([]byte, size)
		n, err := len(s.{{ $field.Name }}), binary.Read(r, binary.LittleEndian, s.{{ $field.Name }})
  {{- end }}
  {{- if eq $fieldType "list" }}
    	var count {{ $field.CountType }}
		err := binary.Read(r, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to read the count for field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(binary.Size(count))
		s.{{ $field.Name }} = make([]{{ $field.ItemTypeName }}, count)

		for idx := range s.{{ $field.Name }} {
			n, err := s.{{ $field.Name }}[idx].ReadFrom(r)
			if err != nil {
				return totalN, fmt.Errorf("unable to read field '{{ $field.Name }}[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
  {{- end }}
  {{- if and (ne $fieldType "list") (ne $fieldType "structInfo") }}
		if err != nil {
			return totalN, fmt.Errorf("unable to read field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(n)
  {{- end }}
	}
    {{- if and ($enableTracing) (ne $fieldType "structInfo") }}
	fmt.Printf("{{ $struct.Name }}.{{ $field.Name }} parsed, TotalN is %d)\n", totalN){{- end}}
 {{- end }}

	return totalN, nil
}

{{- end }}

// RehashRecursive calls Rehash (see below) recursively.
func (s *{{ $struct.Name }}) RehashRecursive() {
 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}
  {{- if or (eq $fieldType "subStruct") (eq $fieldType "structInfo") (eq $fieldType "element") }}
    {{- if $field.IsPointer }}
      	if s.{{ $field.Name }} != nil {
      		s.{{ $field.Name }}.Rehash()
        }
    {{- else }}
	s.{{ $field.Name }}.Rehash()
	{{- end }}
  {{- end }}
 {{- end }}
	s.Rehash()
}

// Rehash sets values which are calculated automatically depending on the rest
// data. It is usually about the total size field of an element.
func (s *{{ $struct.Name }}) Rehash() {
 {{- if ne $struct.ElementStructInfoVar0 "" }}
	s.Variable0 = {{ $struct.ElementStructInfoVar0 }}
 {{- end }}
 {{- if ne $struct.ElementStructInfoVar1 "" }}
	s.ElementSize = {{ $struct.ElementStructInfoVar1 }}
 {{- end }}
 {{- range $index, $field := $struct.Fields }}
  {{- if ne $field.RehashValue "" }}
	s.{{ $field.Name }} = {{ $field.Type.Name }}(s.{{ $field.RehashValue }})
  {{- end }}
 {{- end }}
}

// WriteTo writes the {{ $struct.Name }} into 'w' in format defined in
// the document #575623.
func (s *{{ $struct.Name }}) WriteTo(w io.Writer) (int64, error) {
	totalN := int64(0)
	s.Rehash()

 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}

	// {{ $field.Name }} (ManifestFieldType: {{ $field.ManifestFieldType.String }})
	{{ if $field.IsPointer }}if s.{{ $field.Name }} != nil {{ end }}{
  {{- if eq $fieldType "endValue" }}
		n, err := {{ $field.TypeStdSize }}, binary.Write(w, binary.LittleEndian, &s.{{ $field.Name }})
  {{- end }}
  {{- if or (eq $fieldType "subStruct") (eq $fieldType "structInfo") (eq $fieldType "element") }}
		n, err := s.{{ $field.Name }}.WriteTo(w)
  {{- end }}
  {{- if eq $fieldType "arrayStatic" }}
		n, err := {{ $field.TypeStdSize }}, binary.Write(w, binary.LittleEndian, s.{{ $field.Name }}[:])
  {{- end }}
  {{- if eq $fieldType "arrayDynamic" }}
   {{- if eq $field.CountValue "" }}
		size := {{ $field.CountType }}(len(s.{{ $field.Name }}))
		err := binary.Write(w, binary.LittleEndian, size)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the size of field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(binary.Size(size))
   {{- end }}
		n, err := len(s.{{ $field.Name }}), binary.Write(w, binary.LittleEndian, s.{{ $field.Name }})
  {{- end }}
  {{- if eq $fieldType "list" }}
    	count := {{ $field.CountType }}(len(s.{{ $field.Name }}))
		err := binary.Write(w, binary.LittleEndian, &count)
		if err != nil {
			return totalN, fmt.Errorf("unable to write the count for field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(binary.Size(count))
  {{- end }}
  {{- if or (eq $fieldType "list") (eq $fieldType "elementList") }}
		for idx := range s.{{ $field.Name }} {
			n, err := s.{{ $field.Name }}[idx].WriteTo(w)
			if err != nil {
				return totalN, fmt.Errorf("unable to write field '{{ $field.Name }}[%d]': %w", idx, err)
			}
			totalN += int64(n)
		}
  {{- end }}
  {{- if and (ne $fieldType "list") (ne $fieldType "elementList") }}
		if err != nil {
			return totalN, fmt.Errorf("unable to write field '{{ $field.Name }}': %w", err)
		}
		totalN += int64(n)
  {{- end }}
	}
 {{- end }}

	return totalN, nil
}

{{- range $index, $field := $struct.Fields }}
// {{ $field.Name }}Size returns the size in bytes of the value of field {{ $field.Name }}
func (s *{{ $struct.Name }}) {{ $field.Name }}TotalSize() uint64 {
 {{- $fieldType := $field.ManifestFieldType.String }}
 {{- if or (eq $fieldType "endValue") (eq $fieldType "arrayStatic") }}
	return {{ $field.TypeStdSize }}
 {{- end }}
 {{- if or (eq $fieldType "subStruct") (eq $fieldType "structInfo") (eq $fieldType "element") }}
	return s.{{ $field.Name }}.TotalSize()
 {{- end }}
 {{- if or (eq $fieldType "list") (eq $fieldType "elementList") }}
	var size uint64
  {{- if and (eq $fieldType "list") (eq $field.CountValue "") }}
	size += uint64(binary.Size({{ $field.CountType }}(0)))
  {{- end }}
	for idx := range s.{{ $field.Name }} {
		size += s.{{ $field.Name }}[idx].TotalSize()
	}
	return size
 {{- end }}
 {{- if eq $fieldType "arrayDynamic" }}
  {{- if ne $field.CountValue "" }}
	return uint64(len(s.{{ $field.Name }}))
  {{- else }}
	size := uint64(binary.Size({{ $field.CountType }}(0)))
	size += uint64(len(s.{{ $field.Name }}))
	return size
  {{- end }}
 {{- end }}
}
{{- end }}

{{- range $index, $field := $struct.Fields }}
// {{ $field.Name }}Offset returns the offset in bytes of field {{ $field.Name }}
func (s *{{ $struct.Name }}) {{ $field.Name }}Offset() uint64 {
 {{- if eq $index 0 }}
	return 0
 {{- else }}
  {{- $beforeField := index $struct.Fields (add $index -1) }}
	return s.{{ $beforeField.Name }}Offset() + s.{{ $beforeField.Name }}TotalSize()
 {{- end }}
}
{{- end }}

// Size returns the total size of the {{ $struct.Name }}.
func (s *{{ $struct.Name }}) TotalSize() uint64 {
	if s == nil {
		return 0
	}

	var size uint64
 {{- range $index, $field := $struct.Fields }}
	size += s.{{ $field.Name }}TotalSize()
 {{- end }}
	return size
}

// PrettyString returns the content of the structure in an easy-to-read format.
func (s *{{ $struct.Name }}) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, {{ $struct.PrettyString | printf "%q" }}, s))
	}
	if s == nil {
		return strings.Join(lines, "\n")
	}
 {{- range $index, $field := $struct.Fields }}
  {{- $fieldType := $field.ManifestFieldType.String }}
	// ManifestFieldType is {{ $fieldType }}
  {{- if or (eq $fieldType "list") (eq $fieldType "elementList") }}
	lines = append(lines, pretty.Header(depth+1, fmt.Sprintf({{ printf "%s: Array of \"%s\" of length %%d" $field.Name $field.Parent.PrettyString | printf "%q"}}, len(s.{{ $field.Name }})), s.{{ $field.Name }}))
	for i := 0; i<len(s.{{ $field.Name }}); i++ {
		lines = append(lines, fmt.Sprintf("%sitem #%d: ", strings.Repeat("  ", int(depth+2)), i) + strings.TrimSpace(s.{{ $field.Name }}[i].PrettyString(depth+2, true)))
	}
	if depth < 1 {
		lines = append(lines, "")
	}
  {{- else }}
   {{- $fieldValue := ternary $field.IsPointer (printf "s.%s" $field.Name) (printf "&s.%s" $field.Name) }}
   {{- $prettyValue := ternary (ne $field.PrettyValue "") (printf "s.%s" $field.PrettyValue) $fieldValue }}
	lines = append(lines, pretty.SubValue(depth+1, {{ $field.PrettyString | printf "%q" }}, "", {{ $prettyValue }}, opts...)...)
  {{- end }}
 {{- end }}
	if depth < 2 {
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}

{{- end }}

{{- range $index,$type := .BasicNamedTypes }}
// PrettyString returns the bits of the flags in an easy-to-read format.
func (v {{ $type.Name }}) PrettyString(depth uint, withHeader bool, opts ...pretty.Option) string {
 {{- if not (isNil ($type.MethodByName "String")) }}
	return v.String()
 {{- else }}
	var lines []string
	if withHeader {
		lines = append(lines, pretty.Header(depth, {{ $type.PrettyString | printf "%q" }}, v))
	}
  {{- range $index, $method := $type.Methods }}
   {{- if $method.ReturnsFlagValue }}
    {{- if eq $method.ReturnsTypeName "bool" }}
	if v.{{ $method.Name }}() {
		lines = append(lines, pretty.SubValue(depth+1, "{{ $method.Name.Name | camelcaseToSentence }}", {{ $method.PrettyStringForResult true | printf "%q" }}, true, opts...)...)
	} else {
		lines = append(lines, pretty.SubValue(depth+1, "{{ $method.Name.Name | camelcaseToSentence }}", {{ $method.PrettyStringForResult false | printf "%q" }}, false, opts...)...)
	}
    {{- else }}
	lines = append(lines, pretty.SubValue(depth+1, "{{ $method.Name.Name | camelcaseToSentence }}", "", v.{{ $method.Name }}(), opts...)...)
    {{- end }}
   {{- end }}
  {{- end }}
	return strings.Join(lines, "\n")
 {{- end }}
}

// TotalSize returns the total size measured through binary.Size.
func (v {{ $type.Name }}) TotalSize() uint64 {
	return uint64(binary.Size(v))
}

// WriteTo writes the {{ $type.Name }} into 'w' in binary format.
func (v {{ $type.Name }}) WriteTo(w io.Writer) (int64, error) {
	return int64(v.TotalSize()), binary.Write(w, binary.LittleEndian, v)
}

// ReadFrom reads the {{ $type.Name }} from 'r' in binary format.
func (v {{ $type.Name }}) ReadFrom(r io.Reader) (int64, error) {
	return int64(v.TotalSize()), binary.Read(r, binary.LittleEndian, v)
}

{{- end }}
`

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/basic_named_type.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"

	"github.com/xaionaro-go/gosrc"
)

// BasicNamedType exports the structure BasiNamedType.
type BasicNamedType struct {
	gosrc.AstTypeSpec
	Parent *File
}

// PrettyString returns the instance of BasicNamedType as formatted string.
func (t BasicNamedType) PrettyString() (string, error) {
	result, err := getPrettyString(t.TypeSpec.Name, t.TypeSpec.Doc, t.TypeSpec.Comment, "PrettyString:")
	if err != nil {
		err = fmt.Errorf("unable to get PrettyString for '%s'", t.TypeSpec.Name.Name)
	}
	return result, err
}

// Methods returns the functions of the BasicNamedType instance
func (t BasicNamedType) Methods() Funcs {
	var result Funcs
	for _, method := range t.AstTypeSpec.Methods() {
		result = append(result, &Func{
			Parent: t.Parent,
			Func:   *method,
		})
	}
	return result
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/field.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"
	"go/ast"
	"go/types"
	"math"
	"path/filepath"
	"strings"

	"github.com/xaionaro-go/gosrc"
)

// Field is just a wrapper around gosrc.Field to provide necessary information
// for code generation.
type Field struct {
	gosrc.Field

	Parent *Struct
}

// ItemTypeName returns the type of the given field.
func (field Field) ItemTypeName() string {
	return field.Field.ItemTypeName().Name
}

// AccessPrefix returns a prefix of a given field.
func (field Field) AccessPrefix() string {
	itemTypeName := field.Field.ItemTypeName()
	if itemTypeName.Path == filepath.Dir(field.Parent.Parent.Path) {
		// Not imported, the same package, so no prefix is required
		return ""
	}

	// Imported. As temporary solution we use directory name
	// as the package name.
	return filepath.Base(itemTypeName.Path) + "."
}

// TypeStdSize returns the size (in bytes) of the field's value, if it has
// a static size.
//
// For example if the field has type `uint32` or `[4]byte`, then the returned
// value will be `4`.
//
// Basically this is something like `binary.Size(struct.Field)`.
func (field Field) TypeStdSize() int64 {
	// We set MaxInt64 as wordSize, because we expect wordSize to be
	// never used, so MaxInt64 will help us to reveal any errors.
	//
	// maxAlign is 1 since the data is packed.
	return field.Field.TypeStdSize(math.MaxInt64, 1)
}

// CountType returns the name of the type used to store the count of items
// of the slice. According to document #575623 it is usually uint16, but
// sometimes it is something else (for example uint8).
//
// This method is used only for types ManifestFieldTypeByteArrayDynamic and
// ManifestFieldTypeList.
//
// For example in table 5-11 (of document #575623) there are in particular
// fields `Count and `Digest`, where `Digest` is a list of HASH_STRUCTURE items
// and `Count` is the amount of these items. CountType defines the type of
// the field `Count` in this case (which is `uint16`).
func (field Field) CountType() string {
	if countType, ok := field.TagGet("countType"); ok {
		return countType
	}
	return "uint16"
}

// CountValue returns the value of Tag countValue
func (field Field) CountValue() string {
	result, _ := field.TagGet("countValue")
	return result
}

// RequiredValue returns value of the Tag required
func (field Field) RequiredValue() string {
	result, _ := field.TagGet("require")
	return result
}

// DefaultValue returns the value of the Tag default
func (field Field) DefaultValue() string {
	result, _ := field.TagGet("default")
	return result
}

// PrettyValue returns the value of the Tag prettyValue
func (field Field) PrettyValue() string {
	result, _ := field.TagGet("prettyValue")
	return result
}

// RehashValue returns the value of the tag rehashValue
func (field Field) RehashValue() string {
	result, _ := field.TagGet("rehashValue")
	return result
}

// IsElement returns bool true if a Struct is elements of a field.
func (field Field) IsElement() bool {
	_struct := field.Struct()
	if _struct == nil {
		return false
	}
	info := _struct.ElementStructInfoField()
	return info != nil
}

// IsFlags returns bool true if a field is of type Flags
func (field Field) IsFlags() bool {
	namedType, ok := field.TypeValue.Type.(*types.Named)
	if !ok {
		return false
	}

	return strings.HasSuffix(namedType.Obj().Name(), "Flags")
}

func (field Field) isElementStructInfo() bool {
	return field.Field.ItemTypeName().Name == "StructInfo"
}

// ElementStructID returns the ElementStructID of a Field
func (field Field) ElementStructID() string {
	_struct := field.Struct()
	if _struct == nil {
		return ""
	}
	return _struct.ElementStructID()
}

// Struct returns a pointer to the most upper field structure instance
func (field Field) Struct() *Struct {
	return field.Parent.Parent.Parent.StructByName(field.Field.ItemTypeName().Name)
}

// ManifestFieldType returns the ManifestFieldType of the field instance
func (field Field) ManifestFieldType() (ManifestFieldType, error) {
	_struct := field.Parent
	if _struct == nil {
		return ManifestFieldTypeUndefined, fmt.Errorf("internal error: parent is not defined")
	}

	typ := gosrc.TypeDeepest(field.TypeValue.Type)
	if typCasted, ok := typ.(*types.Pointer); ok {
		typ = typCasted.Elem()
	}
	if typCasted, ok := typ.(*types.Named); ok {
		typ = typCasted.Underlying()
	}

	switch typ := typ.(type) {
	case *types.Array:
		switch typ := typ.Elem().(type) {
		case *types.Basic:
			if typ.Kind() != types.Uint8 {
				return ManifestFieldTypeUndefined, fmt.Errorf("static array, but not of bytes in %s.%s: %s", _struct.Name(), field.Name(), typ.String())
			}
			return ManifestFieldTypeByteArrayStatic, nil
		default:
			return ManifestFieldTypeUndefined, fmt.Errorf("static array, but not of bytes in %s.%s: %s", _struct.Name(), field.Name(), typ.String())
		}
	case *types.Slice:
		switch elemType := typ.Elem().(type) {
		case *types.Basic:
			if elemType.Kind() != types.Uint8 {
				return ManifestFieldTypeUndefined, fmt.Errorf("dynamic array, but not of bytes in %s.%s: %s", _struct.Name(), field.Name(), typ.String())
			}
			return ManifestFieldTypeByteArrayDynamic, nil
		default:
			if field.IsElement() {
				return ManifestFieldTypeElementList, nil
			}
			return ManifestFieldTypeList, nil

		}
	case *types.Struct:
		if field.isElementStructInfo() {
			return ManifestFieldTypeStructInfo, nil
		}
		if field.IsElement() {
			return ManifestFieldTypeElement, nil
		}
		return ManifestFieldTypeSubStruct, nil

	case *types.Basic:
		return ManifestFieldTypeEndValue, nil
	case *types.Interface:
		return ManifestFieldTypeUndefined, fmt.Errorf("do not know how to handle an interface of '%s.%s'", _struct.Name(), field.Name())
	}

	return ManifestFieldTypeUndefined, fmt.Errorf("unknown case: %s:%T: %v", field.Name(), typ, typ.String())
}

// PrettyString returns a formatted string of the field structure instance
func (field Field) PrettyString() (string, error) {
	result, err := getPrettyString(&ast.Ident{Name: field.Name()}, field.Doc, field.Comment, "PrettyString:")
	if err != nil {
		err = fmt.Errorf("unable to get PrettyString for '%s.%s'", field.Parent.TypeSpec.Name.Name, field.Name())
	}
	return result, err
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/func.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"
	"go/ast"

	"github.com/xaionaro-go/gosrc"
)

// Func exports the Func struct
type Func struct {
	Parent *File
	gosrc.Func
}

// Funcs exports the custom type []*Funs
type Funcs []*Func

// ReturnsFlagValue returns bool true if Function has a Flag value
func (fn Func) ReturnsFlagValue() bool {
	if fn.Type.Params != nil && len(fn.Type.Params.List) != 0 {
		return false
	}
	if fn.Type.Results == nil || len(fn.Type.Results.List) != 1 {
		return false
	}
	ident, ok := fn.Type.Results.List[0].Type.(*ast.Ident)
	if !ok {
		return false
	}
	if ident.Name == "string" {
		return false
	}
	return true
}

// ReturnsTypeName a string of the TypeName of the function
func (fn Func) ReturnsTypeName() string {
	if fn.Type.Results == nil || len(fn.Type.Results.List) != 1 {
		return ""
	}
	ident, ok := fn.Type.Results.List[0].Type.(*ast.Ident)
	if !ok {
		return ""
	}
	return ident.Name
}

// PrettyStringForResult returns a string corresponding with the documentation of the implemented function
func (fn Func) PrettyStringForResult(r interface{}) (string, error) {
	result, err := getPrettyString(fn.Type, fn.FuncDecl.Doc, nil, fmt.Sprintf("PrettyString-%v:", r))
	if err != nil {
		err = fmt.Errorf("unable to get PrettyString for '%s'", fn.FuncDecl.Name.Name)
	}
	return result, err
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/manifest_field_type.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"
)

// ManifestFieldType represents the custom type
type ManifestFieldType uint

const (
	// ManifestFieldTypeUndefined indicates that the field is undefined
	ManifestFieldTypeUndefined = ManifestFieldType(iota)
	// ManifestFieldTypeElement indicates that the field is an element
	ManifestFieldTypeElement
	// ManifestFieldTypeElementList indicates that the field is a list of elements
	ManifestFieldTypeElementList
	// ManifestFieldTypeStructInfo indicates that the field is a StructInfo
	ManifestFieldTypeStructInfo
	// ManifestFieldTypeSubStruct indicates that the field is a underlaying struct
	ManifestFieldTypeSubStruct
	// ManifestFieldTypeEndValue indicates that the field is an EndValue
	ManifestFieldTypeEndValue
	// ManifestFieldTypeByteArrayDynamic indicates that the field is a´ dynamic byte array
	ManifestFieldTypeByteArrayDynamic
	// ManifestFieldTypeByteArrayStatic indicates that the field is a static byte array
	ManifestFieldTypeByteArrayStatic
	// ManifestFieldTypeList indicates that the field is a type list
	ManifestFieldTypeList
)

func (ft ManifestFieldType) String() string {
	switch ft {
	case ManifestFieldTypeUndefined:
		return "undefined"
	case ManifestFieldTypeElement:
		return "element"
	case ManifestFieldTypeElementList:
		return "elementList"
	case ManifestFieldTypeStructInfo:
		return "structInfo"
	case ManifestFieldTypeSubStruct:
		return "subStruct"
	case ManifestFieldTypeEndValue:
		return "endValue"
	case ManifestFieldTypeByteArrayDynamic:
		return "arrayDynamic"
	case ManifestFieldTypeByteArrayStatic:
		return "arrayStatic"
	case ManifestFieldTypeList:
		return "list"
	}
	return fmt.Sprintf("unexpected_%d", uint(ft))
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/package.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"github.com/xaionaro-go/gosrc"
)

// File struct has four fields. gosrc.File holds the associated file.
// Parent represents the package as element containing the file.
// Structs holds a map of all structures of a file matching to their name in string representation.
// BasicNamedTypes holds
type File struct {
	gosrc.File

	Parent          *Package
	Structs         map[string]*Struct
	BasicNamedTypes map[string]*BasicNamedType
}

// Package contains zwo fields. gosrc.Package and an slice of file pointers.
type Package struct {
	gosrc.Package

	Files []*File
}

// StructByName returns Struct with the given name.
func (pkg *Package) StructByName(structName string) *Struct {
	for _, file := range pkg.Files {
		if _struct, ok := file.Structs[structName]; ok {
			return _struct
		}
	}

	return nil
}

// Structs returns a map matching StructNames to pointers of their struct instance.
func (pkg *Package) Structs() map[string]*Struct {
	result := map[string]*Struct{}
	for _, file := range pkg.Files {
		for structName, _struct := range file.Structs {
			result[structName] = _struct
		}
	}
	return result
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/pretty_string.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"
	"go/ast"
	"strings"

	"github.com/fatih/camelcase"
)

func getPrettyString(typ ast.Expr, doc, comment *ast.CommentGroup, docPrefix string) (string, error) {
	if doc == nil {
		doc = comment
	}

	if doc != nil {
		for _, docItem := range doc.List {
			text := strings.TrimSpace(strings.TrimLeft(docItem.Text, "/"))
			if !strings.HasPrefix(text, docPrefix) {
				continue
			}

			return strings.TrimSpace(text[len(docPrefix):]), nil
		}
	}

	if ident, ok := typ.(*ast.Ident); ok {
		return strings.Join(camelcase.Split(ident.Name), " "), nil
	}

	if doc != nil {
		if len(doc.List) > 0 {
			return strings.TrimSpace(strings.TrimLeft(doc.List[0].Text, "/")), nil
		}
	}

	return "", fmt.Errorf("comment with prefix '%s' is not found", docPrefix)
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/scan.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"
	"go/ast"
	"go/build"
	"path/filepath"
	"strings"

	"github.com/xaionaro-go/gosrc"
)

// Scan holds information about a scan process used to scan a path.
func Scan(
	path string,
	goPaths []string,
) (*Package, error) {

	// Scan the path "path".
	pkgRaw, err := getRawPkg(path, goPaths)
	if err != nil {
		return nil, fmt.Errorf("unable to get the package from directory '%s': %w", path, err)
	}

	// Basically just converting received structures to our-own types,
	// which we will used then in cmd/manifestcodegen/template_methods.go.
	pkg, err := convertRawPkg(pkgRaw)
	if err != nil {
		return nil, fmt.Errorf("unable to get convert the package: %w", err)
	}

	return pkg, nil
}

func getRawPkg(
	path string,
	goPaths []string,
) (*gosrc.Package, error) {
	buildCtx := build.Default
	buildCtx.GOPATH = strings.Join(goPaths, string(filepath.ListSeparator))
	buildCtx.BuildTags = append(buildCtx.BuildTags, `manifestcodegen`)
	dirRaw, err := gosrc.OpenDirectoryByPkgPath(&buildCtx, path, false, false, false, nil)
	if err != nil {
		return nil, fmt.Errorf("unable to open go directory: %w", err)
	}

	if len(dirRaw.Packages) != 1 {
		return nil, fmt.Errorf("expected one package in the directory, but received %d", len(dirRaw.Packages))
	}

	return dirRaw.Packages[0], nil
}

func convertRawPkg(
	pkgRaw *gosrc.Package,
) (*Package, error) {
	pkg := &Package{
		Package: *pkgRaw,
	}
	for _, fileRaw := range pkgRaw.Files.FilterByGoGenerateTag("manifestcodegen") {
		file := &File{
			File:            *fileRaw,
			Parent:          pkg,
			Structs:         map[string]*Struct{},
			BasicNamedTypes: map[string]*BasicNamedType{},
		}

		for _, astTypeSpec := range fileRaw.AstTypeSpecs() {
			switch astTypeSpec.TypeSpec.Type.(type) {
			case *ast.StructType:
				structRaw := &gosrc.Struct{AstTypeSpec: *astTypeSpec}
				fieldsRaw, err := structRaw.Fields()
				if err != nil {
					return nil, fmt.Errorf("unable to get fields of struct '%s': %w", structRaw, err)
				}

				_struct := &Struct{
					Struct: *structRaw,
					Parent: file,
				}
				for _, fieldRaw := range fieldsRaw {
					_struct.Fields = append(_struct.Fields, &Field{
						Field:  *fieldRaw,
						Parent: _struct,
					})
				}

				if _struct := pkg.StructByName(_struct.Name()); _struct != nil {
					return nil, fmt.Errorf("structure %s is defined twice (files: '%s' and '%s')", _struct.Name(), _struct.Parent.File, file.Path)
				}
				file.Structs[_struct.Name()] = _struct

			case *ast.Ident:
				file.BasicNamedTypes[astTypeSpec.TypeSpec.Name.Name] = &BasicNamedType{
					Parent:      file,
					AstTypeSpec: *astTypeSpec,
				}
			}
		}

		pkg.Files = append(pkg.Files, file)
	}

	return pkg, nil
}

```

`pkg/intel/metadata/common/manifestcodegen/pkg/analyze/struct.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package analyze

import (
	"fmt"

	"github.com/xaionaro-go/gosrc"
)

type Struct struct {
	gosrc.Struct

	Parent *File
	Fields []*Field
}

func (_struct Struct) ElementStructInfoField() *Field {
	for _, field := range _struct.Fields {
		if field.isElementStructInfo() {
			return field
		}
	}

	return nil
}

func (_struct Struct) ElementStructVersion() string {
	field := _struct.ElementStructInfoField()
	if field == nil {
		return ""
	}

	id, _ := field.TagGet("version")
	return id
}

func (_struct Struct) ElementStructID() string {
	field := _struct.ElementStructInfoField()
	if field == nil {
		return ""
	}

	id, _ := field.TagGet("id")
	return id
}

func (_struct Struct) IsElementsContainer() bool {
	for _, field := range _struct.Fields {
		if field.IsElement() {
			return true
		}
	}

	return false
}

func (_struct Struct) PrettyString() (string, error) {
	result, err := getPrettyString(_struct.TypeSpec.Name, _struct.TypeSpec.Doc, _struct.TypeSpec.Comment, "PrettyString:")
	if err != nil {
		err = fmt.Errorf("unable to get PrettyString for '%s'", _struct.TypeSpec.Name.Name)
	}
	return result, err
}

func (_struct Struct) Methods() Funcs {
	var result Funcs
	for _, method := range _struct.AstTypeSpec.Methods() {
		result = append(result, &Func{Func: *method})
	}
	return result
}

func (_struct Struct) HasOnRehash() bool {
	return _struct.MethodByName("onRehash") != nil
}

func (_struct Struct) ElementStructInfoVar0() string {
	f := _struct.ElementStructInfoField()
	if f == nil {
		return ""
	}
	r, _ := f.TagGet("var0")
	return r
}

func (_struct Struct) ElementStructInfoVar1() string {
	f := _struct.ElementStructInfoField()
	if f == nil {
		return ""
	}
	r, _ := f.TagGet("var1")
	return r
}

```

`pkg/intel/metadata/common/pretty/options.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pretty

type Option interface {
	apply(*config)
}

type OptionOmitKeySignature bool

func (opt OptionOmitKeySignature) apply(cfg *config) {
	cfg.OmitKeySignature = bool(opt)
}

type config struct {
	OmitKeySignature bool
}

func getConfig(opts []Option) config {
	var cfg config
	for _, opt := range opts {
		opt.apply(&cfg)
	}
	return cfg
}

```

`pkg/intel/metadata/common/pretty/pretty.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package pretty

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/dustin/go-humanize"
)

func Header(depth uint, description string, obj interface{}) string {
	if description == "" {
		description = fmt.Sprintf("%T", obj)
	}
	switch depth {
	case 0:
		description = `----` + description + "----\n"
	case 1:
		description = `--` + description + `--`
	default:
		description += `:`
	}
	description = strings.Repeat("  ", int(depth)) + description
	return description
}

func SubValue(depth uint, fieldName, valueDescription string, value interface{}, opts ...Option) []string {
	cfg := getConfig(opts)
	if cfg.OmitKeySignature {
		switch fieldName {
		case "PMSE: Signature", "Key And Signature":
			return nil
		}
	}

	if valueDescription == "" {
		valueDescription = getDescriptionForValue(depth, value, opts...)
	}
	return []string{fmt.Sprintf("%s %s", Header(depth, fieldName, nil), valueDescription)}
}

func getDescriptionForValue(depth uint, value interface{}, opts ...Option) string {
	v := reflect.ValueOf(value)
	if v.Kind() == reflect.Ptr && v.IsNil() {
		return "is not set (nil)"
	}

	switch value := value.(type) {
	case interface {
		PrettyString(depth uint, withHeader bool, opts ...Option) string
	}:
		description := value.PrettyString(depth, false, opts...)
		if len(strings.Split(description, "\n")) > 1 {
			return "\n" + description
		} else {
			return strings.TrimSpace(description)
		}
	case fmt.GoStringer:
		return value.GoString()
	case fmt.Stringer:
		return value.String()
	}

	v = reflect.Indirect(v)
	switch v.Kind() {
	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		i := v.Uint()
		var hexFmt string
		switch v.Type().Size() {
		case 1:
			hexFmt = "0x%02X"
		case 2:
			hexFmt = "0x%04X"
		case 4:
			hexFmt = "0x%08X"
		case 8:
			hexFmt = "0x%16X"
		}
		switch {
		case i < 10:
			return fmt.Sprintf(hexFmt, i)
		case i < 65536:
			return fmt.Sprintf(hexFmt+" (%d)", i, i)
		default:
			return fmt.Sprintf(hexFmt+" (%d: %s)", i, i, humanize.IBytes(i))
		}

	case reflect.Array:
		return fmt.Sprintf("0x%X", v.Interface())

	case reflect.Slice:
		if v.Len() == 0 {
			return "empty (len: 0)"
		}
		return fmt.Sprintf("0x%X (len: %d)", v.Interface(), v.Len())
	}

	return fmt.Sprintf("%#+v (%T)", value, value)
}

```

`pkg/intel/metadata/common/tracedbinary/binary.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package tracedbinary

import (
	"encoding/binary"
	"fmt"
	"io"
	"path/filepath"
	"reflect"
	"runtime"
)

type ByteOrder = binary.ByteOrder

var (
	LittleEndian = binary.LittleEndian
)

func Read(r io.Reader, order ByteOrder, data interface{}) error {
	err := binary.Read(r, order, data)
	v := reflect.Indirect(reflect.ValueOf(data))
	switch {
	case v.Kind() != reflect.Slice || v.Len() < 16:
		fmt.Printf("%s: binary.Read(%T, %s, %T) -> %v; data == %v\n", caller(), r, order, data, err, v.Interface())
	case v.Kind() == reflect.Slice:
		fmt.Printf("%s: binary.Read(%T, %s, %T) -> %v; len(data) == %v\n", caller(), r, order, data, err, v.Len())
	default:
		fmt.Printf("%s: binary.Read(%T, %s, %T) -> %v\n", caller(), r, order, data, err)
	}
	return err
}

func Write(w io.Writer, order ByteOrder, data interface{}) error {
	err := binary.Write(w, order, data)
	fmt.Printf("%s: binary.Read(%T, %s, %T) -> %v\n", caller(), w, order, data, err)
	return err
}

func Size(v interface{}) int {
	r := binary.Size(v)
	fmt.Printf("%s: binary.Size(%T) -> %v\n", caller(), v, r)
	return r
}

func caller() string {
	_, file, line, _ := runtime.Caller(2)
	return fmt.Sprintf("%s:%d", filepath.Base(file), line)
}

```

`pkg/intel/metadata/common/unittest/read_write.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package unittest

import (
	"bytes"
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg"
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt"
	"github.com/stretchr/testify/require"
)

func CBNTManifestReadWrite(t *testing.T, m cbnt.Manifest, testDataFilePath string) {
	testData, err := os.ReadFile(testDataFilePath)
	require.NoError(t, err)

	nR, err := m.ReadFrom(bytes.NewReader(append(testData, []byte(`extra bytes`)...)))
	require.NoError(t, err)
	require.Equal(t, int64(len(testData)), nR)
	require.Equal(t, nR, int64(m.TotalSize()))

	prettyString := m.PrettyString(0, true)

	var out bytes.Buffer
	nW, err := m.WriteTo(&out)
	require.NoError(t, err)

	newPrettyString := m.PrettyString(0, true)
	require.Equal(t, prettyString, newPrettyString, newPrettyString)
	require.Equal(t, string(testData), out.String())
	require.Equal(t, nW, nR)
	require.Equal(t, nW, int64(out.Len()))
}

func BGManifestReadWrite(t *testing.T, m bg.Manifest, testDataFilePath string) {
	testData, err := os.ReadFile(testDataFilePath)
	require.NoError(t, err)

	nR, err := m.ReadFrom(bytes.NewReader(testData))
	require.NoError(t, err)
	require.Equal(t, int64(len(testData)), nR)
	require.Equal(t, nR, int64(m.TotalSize()))

	prettyString := m.PrettyString(0, true)

	var out bytes.Buffer
	nW, err := m.WriteTo(&out)
	require.NoError(t, err)

	newPrettyString := m.PrettyString(0, true)
	require.Equal(t, prettyString, newPrettyString, newPrettyString)
	require.Equal(t, string(testData), out.String())
	require.Equal(t, nW, nR)
	require.Equal(t, nW, int64(out.Len()))
}

```

`pkg/intel/metadata/fit/calc_offset.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import "github.com/linuxboot/fiano/pkg/intel/metadata/fit/consts"

// CalculatePhysAddrFromOffset calculates the physical address (address to a
// region mapped from the SPI chip) using an offset withtin an image, relatively
// to BasePhysAddr.
//
// Examples:
//
//	CalculatePhysAddrFromOffset(0x01, 0x2000) ==  0xffffe001
//	CalculatePhysAddrFromOffset(0x40, 0x2000) ==  0xffffe040
func CalculatePhysAddrFromOffset(offset uint64, imageSize uint64) uint64 {
	startAddr := consts.BasePhysAddr - imageSize
	return startAddr + offset
}

// CalculateOffsetFromPhysAddr calculates the offset within an image
// of the physical address (address to a region mapped from
// the SPI chip).
//
// Examples:
//
//	CalculateOffsetFromPhysAddr(0xffffffff, 0x1000) == 0xfff
//	CalculateOffsetFromPhysAddr(0xffffffc0, 0x1000) == 0xfc0
func CalculateOffsetFromPhysAddr(physAddr uint64, imageSize uint64) uint64 {
	startAddr := consts.BasePhysAddr - imageSize
	return physAddr - startAddr
}

// CalculateTailOffsetFromPhysAddr calculates the offset (towards down, relatively
// to BasePhysAddr) of the physical address (address to a region mapped from
// the SPI chip).
//
// Examples:
//
//	CalculateTailOffsetFromPhysAddr(0xffffffff) == 0x01
//	CalculateTailOffsetFromPhysAddr(0xffffffc0) == 0x40
func CalculateTailOffsetFromPhysAddr(physAddr uint64) uint64 {
	return consts.BasePhysAddr - physAddr
}

```

`pkg/intel/metadata/fit/check/bounds.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package check

import (
	"github.com/hashicorp/go-multierror"
)

func bounds(length uint, startIdx, endIdx int) error {
	var result *multierror.Error
	if startIdx < 0 {
		result = multierror.Append(result, &ErrStartLessThanZero{StartIdx: startIdx})
	}
	if endIdx < startIdx {
		result = multierror.Append(result, &ErrEndLessThanStart{StartIdx: startIdx, EndIdx: endIdx})
	}
	if endIdx >= 0 && uint(endIdx) > length {
		result = multierror.Append(result, &ErrEndGreaterThanLength{Length: length, EndIdx: endIdx})
	}

	return result.ErrorOrNil()
}

// BytesRange checks if starting index `startIdx`, ending index `endIdx` and
// len(b) passes sanity checks:
// * 0 <= startIdx
// * startIdx <= endIdx
// * endIdx < len(b)
func BytesRange(length uint, startIdx, endIdx int) error {
	return bounds(length, startIdx, endIdx)
}

```

`pkg/intel/metadata/fit/check/errors.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package check

import (
	"fmt"
)

// ErrStartLessThanZero means `startIdx` has negative value
type ErrStartLessThanZero struct {
	StartIdx int
}

func (err *ErrStartLessThanZero) Error() string {
	return fmt.Sprintf("start index is less than zero: %d", err.StartIdx)
}

// ErrEndLessThanStart means `endIdx` value is less than `startIdx` value
type ErrEndLessThanStart struct {
	StartIdx int
	EndIdx   int
}

func (err *ErrEndLessThanStart) Error() string {
	return fmt.Sprintf("end index is less than start index: %d < %d",
		err.EndIdx, err.StartIdx)
}

// ErrEndGreaterThanLength means `endIdx` is greater or equal to the length.
type ErrEndGreaterThanLength struct {
	Length uint
	EndIdx int
}

func (err *ErrEndGreaterThanLength) Error() string {
	return fmt.Sprintf("end index is outside of the bounds: %d >= %d",
		err.EndIdx, err.Length)
}

```

`pkg/intel/metadata/fit/consts/consts.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package consts

const (
	// BasePhysAddr is the absolute physical address where the firmware image ends.
	//
	// See Figure 2.1 in https://www.intel.com/content/dam/www/public/us/en/documents/guides/fit-bios-specification.pdf
	//
	// Note: A firmware image grows towards lower addresses. So an image will be mapped to addresses:
	//       [ BasePhysAddr-length .. BasePhysAddr )
	//
	// Note: SPI chip is mapped into this region. So we actually work directly with data of the SPI chip
	//
	// See also CalculatePhysAddrOfOffset().
	BasePhysAddr = 1 << 32 // "4GB"

	// FITPointerOffset is the offset of the physical address of the FIT pointer.
	// See "1 Firmware Interface Table" in "Firmware Interface Table" specification:
	//  * https://www.intel.com/content/dam/www/public/us/en/documents/guides/fit-bios-specification.pdf
	FITPointerOffset = 0x40

	// FITPointerPhysAddr is the physical address of the FIT pointer.
	// See "1 Firmware Interface Table" in "Firmware Interface Table" specification:
	//  * https://www.intel.com/content/dam/www/public/us/en/documents/guides/fit-bios-specification.pdf
	FITPointerPhysAddr = BasePhysAddr - FITPointerOffset

	// FITPointerSize is the size of the FIT pointer.
	// It is suggested to be 0x10 bytes because of "Figure 1-1" of the specification.
	FITPointerSize = 0x10
)

```

`pkg/intel/metadata/fit/consts/fit.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package consts

const (
	// FITHeadersMagic is the magic string, expected in the beginning of the
	// first FIT entry
	FITHeadersMagic = "_FIT_   "
)

```

`pkg/intel/metadata/fit/ent_bios_policy_record.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"io"
)

// EntryBIOSPolicyRecord represents a FIT entry of type "BIOS Policy Record" (0x09)
type EntryBIOSPolicyRecord struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryBIOSPolicyRecord)(nil)

func (entry *EntryBIOSPolicyRecord) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	return uint64(entry.Headers.Size.Uint32()), nil
}

var _ EntryCustomRecalculateHeaderser = (*EntryBIOSPolicyRecord)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryBIOSPolicyRecord) CustomRecalculateHeaders() error {
	mostCommonRecalculateHeadersOfEntry(entry)

	entry.Headers.Size.SetUint32(uint32(len(entry.DataSegmentBytes)))
	return nil
}

```

`pkg/intel/metadata/fit/ent_bios_startup_module_entry.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryBIOSStartupModuleEntry represents a FIT entry of type "BIOS Startup Module Entry" (0x07)
type EntryBIOSStartupModuleEntry struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_boot_policy_manifest.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgbootpolicy"
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntbootpolicy"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/bgheader"
)

// EntryBootPolicyManifestRecord represents a FIT entry of type "Boot Policy Manifest" (0x0C)
type EntryBootPolicyManifestRecord struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryBootPolicyManifestRecord)(nil)

func (entry *EntryBootPolicyManifestRecord) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	return uint64(entry.Headers.Size.Uint32()), nil
}

var _ EntryCustomRecalculateHeaderser = (*EntryBootPolicyManifestRecord)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryBootPolicyManifestRecord) CustomRecalculateHeaders() error {
	mostCommonRecalculateHeadersOfEntry(entry)

	entry.Headers.Size.SetUint32(uint32(len(entry.DataSegmentBytes)))
	return nil
}

// Reader creates io.ReadSeeker from EntryBootPolicyManifestRecord
func (entry *EntryBootPolicyManifestRecord) Reader() *bytes.Reader {
	return bytes.NewReader(entry.DataSegmentBytes)
}

// ParseData creates EntryBootPolicyManifestRecord from EntryBootPolicyManifest
func (entry *EntryBootPolicyManifestRecord) ParseData() (*bgbootpolicy.Manifest, *cbntbootpolicy.Manifest, error) {
	r := bytes.NewReader(entry.DataSegmentBytes)
	version, err := bgheader.DetectBGV(r)
	if err != nil {
		return nil, nil, err
	}
	switch version {
	case bgheader.Version10:
		manifest := bgbootpolicy.NewManifest()
		_, err = manifest.ReadFrom(r)
		if err != nil && !errors.Is(err, io.EOF) {
			return nil, nil, err
		}
		return manifest, nil, nil
	case bgheader.Version20:
		manifest := cbntbootpolicy.NewManifest()
		_, err = manifest.ReadFrom(r)
		if err != nil && !errors.Is(err, io.EOF) {
			return nil, nil, err
		}
		return nil, manifest, nil
	default:
		return nil, nil, fmt.Errorf("failed to parse BootPolicyManifest, err: %v", err)
	}
}

// ParseBootPolicyManifest returns a boot policy manifest if it was able to
// parse one.
func (table Table) ParseBootPolicyManifest(firmware []byte) (*bgbootpolicy.Manifest, *cbntbootpolicy.Manifest, error) {
	hdr := table.First(EntryTypeBootPolicyManifest)
	if hdr == nil {
		return nil, nil, ErrNotFound{}
	}

	return hdr.GetEntry(firmware).(*EntryBootPolicyManifestRecord).ParseData()
}

```

`pkg/intel/metadata/fit/ent_cse_secure_boot.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryCSESecureBoot represents a FIT entry of type "CSE Secure Boot" (0x10)
type EntryCSESecureBoot struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_diagnostic_acm.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"
	"io"
)

// EntryDiagnosticACM represents a FIT entry of type "Diagnostic ACM" (0x03)
type EntryDiagnosticACM struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryDiagnosticACM)(nil)

// Init initializes the entry using EntryHeaders and firmware image.
func (entry *EntryDiagnosticACM) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	return 0, fmt.Errorf("EntryDiagnosticACM is not supported, yet")
}

var _ EntryCustomRecalculateHeaderser = (*EntryDiagnosticACM)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryDiagnosticACM) CustomRecalculateHeaders() error {
	return fmt.Errorf("EntryDiagnosticACM is not supported, yet")
}

```

`pkg/intel/metadata/fit/ent_feature_policy_delivery_record.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryFeaturePolicyDeliveryRecord represents a FIT entry of type "Feature Policy Delivery Record" (0x2D)
type EntryFeaturePolicyDeliveryRecord struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_fit_header_entry.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"encoding/binary"
	"io"
)

// EntryFITHeaderEntry represents a FIT entry of type "FIT Header Entry" (0x00)
type EntryFITHeaderEntry struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryFITHeaderEntry)(nil)

func (entry *EntryFITHeaderEntry) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	// See "1.2.2" of the specification.
	// FITHeaderEntry contains "_FIT_   " string instead of an address.
	// And we shouldn't do anything in this case.
	return 0, nil
}

var _ EntryCustomRecalculateHeaderser = (*EntryFITHeaderEntry)(nil)

func (entry *EntryFITHeaderEntry) CustomRecalculateHeaders() error {
	mostCommonRecalculateHeadersOfEntry(entry)

	// See 4.2 of the FIT specification.
	entry.Headers.Address = Address64(binary.LittleEndian.Uint64([]byte("_FIT_   ")))
	return nil
}

```

`pkg/intel/metadata/fit/ent_jmp_debug_policy.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryJMPDebugPolicy represents a FIT entry of type "JMP $ Debug Policy" (0x2F)
type EntryJMPDebugPolicy struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_key_manifest_record.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/linuxboot/fiano/pkg/intel/metadata/bg/bgkey"
	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntkey"
	"github.com/linuxboot/fiano/pkg/intel/metadata/common/bgheader"
)

// EntryKeyManifestRecord represents a FIT entry of type "Key Manifest Record" (0x0B)
type EntryKeyManifestRecord struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryKeyManifestRecord)(nil)

func (entry *EntryKeyManifestRecord) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	return uint64(entry.Headers.Size.Uint32()), nil
}

var _ EntryCustomRecalculateHeaderser = (*EntryKeyManifestRecord)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryKeyManifestRecord) CustomRecalculateHeaders() error {
	mostCommonRecalculateHeadersOfEntry(entry)

	entry.Headers.Size.SetUint32(uint32(len(entry.DataSegmentBytes)))
	return nil
}

// Reader creates io.ReadSeeker from EntryKeyManifestRecord
func (entry *EntryKeyManifestRecord) Reader() *bytes.Reader {
	return bytes.NewReader(entry.DataSegmentBytes)
}

// ParseData creates EntryKeyManifestRecord from EntryKeyManifest
func (entry *EntryKeyManifestRecord) ParseData() (*bgkey.Manifest, *cbntkey.Manifest, error) {
	r := bytes.NewReader(entry.DataSegmentBytes)
	version, err := bgheader.DetectBGV(r)
	if err != nil {
		return nil, nil, err
	}
	switch version {
	case bgheader.Version10:
		manifest := bgkey.NewManifest()
		_, err = manifest.ReadFrom(r)
		if err != nil && !errors.Is(err, io.EOF) {
			return nil, nil, err
		}
		return manifest, nil, nil
	case bgheader.Version20:
		manifest := cbntkey.NewManifest()
		_, err = manifest.ReadFrom(r)
		if err != nil && !errors.Is(err, io.EOF) {
			return nil, nil, err
		}
		return nil, manifest, nil
	default:
		return nil, nil, fmt.Errorf("failed to parse KeyManifest, err: %v", err)
	}
}

// ParseKeyManifest returns a key manifest if it was able to
// parse one.
func (table Table) ParseKeyManifest(firmware []byte) (*bgkey.Manifest, *cbntkey.Manifest, error) {
	hdr := table.First(EntryTypeKeyManifestRecord)
	if hdr == nil {
		return nil, nil, ErrNotFound{}
	}

	return hdr.GetEntry(firmware).(*EntryKeyManifestRecord).ParseData()
}

```

`pkg/intel/metadata/fit/ent_microcode_update_entry.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryMicrocodeUpdateEntry represents a FIT entry of type "Microcode Update Entry" (0x01)
type EntryMicrocodeUpdateEntry struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_skip.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntrySkip represents a FIT entry of type "Unused Entry (skip)" (0x7F)
type EntrySkip struct{ EntryBase }

```

`pkg/intel/metadata/fit/ent_startup_ac_module_entry.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"crypto/rsa"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"reflect"

	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/check"
	"github.com/xaionaro-go/bytesextra"
)

// EntrySACM represents a FIT entry of type "Startup AC Module Entry" (0x02)
type EntrySACM struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntrySACM)(nil)

func (entry *EntrySACM) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	offset, err := entry.Headers.getDataSegmentOffset(firmware)
	if err != nil {
		return 0, fmt.Errorf("unable to detect data segment offset: %w", err)
	}

	// See point "7" of "2.7" of the specification: the size field is
	// always zero. So we parsing the size from it's data right now:
	var size uint32
	size, err = EntrySACMParseSizeFrom(firmware, offset)
	if err != nil {
		return 0, fmt.Errorf("unable to detect data segment size: %w", err)
	}
	return uint64(size), nil
}

var _ EntryCustomRecalculateHeaderser = (*EntrySACM)(nil)

func (entry *EntrySACM) CustomRecalculateHeaders() error {
	// See 4.4.7 of the FIT specification.
	entry.Headers.Size.SetUint32(0)
	return nil
}

// See the section "A.1" of the specification
// "Intel ® Trusted Execution Technology (Intel ® TXT)"
// https://www.intel.com/content/www/us/en/software-developers/txt-software-development-guide.html

// EntrySACMDataInterface is the interface of a startup AC module
// data (of any version)
type EntrySACMDataInterface interface {
	io.ReadWriter
	io.ReaderFrom
	io.WriterTo

	// Field getters:

	GetModuleType() ACModuleType
	GetModuleSubType() ACModuleSubType
	GetHeaderLen() SizeM4
	GetHeaderVersion() ACModuleHeaderVersion
	GetChipsetID() ACChipsetID
	GetFlags() ACFlags
	GetModuleVendor() ACModuleVendor
	GetDate() BCDDate
	GetSize() SizeM4
	GetTXTSVN() TXTSVN
	GetSESVN() SESVN
	GetCodeControl() CodeControl
	GetErrorEntryPoint() ErrorEntryPoint
	GetGDTLimit() GDTLimit
	GetGDTBasePtr() GDTBasePtr
	GetSegSel() SegSel
	GetEntryPoint() EntryPoint
	GetReserved2() [64]byte
	GetKeySize() SizeM4
	GetScratchSize() SizeM4
	GetRSAPubKey() rsa.PublicKey
	GetRSAPubExp() uint32
	GetRSASig() []byte
	GetScratch() []byte

	// Auxiliary methods:
	RSASigBinaryOffset() uint64

	// DateBinaryOffset returns the offset of the field 'Date'
	// relatively to the beginning of the structure in the binary
	// format (see 'encoding/binary').
	DateBinaryOffset() uint
}

// ACModuleType defines the type of AC module
type ACModuleType uint16

// ACModuleSubType defines the subtype of AC module (0 - TXT ACM; 1 - S-ACM)
type ACModuleSubType uint16

// ACModuleHeaderVersion defines module format version:
// * 0.0 – for SINIT ACM before 2017
// * 3.0 – for SINIT ACM of converge of BtG and TXT
type ACModuleHeaderVersion uint32

const (
	// ACHeaderVersion0 is version "0.0 – for SINIT ACM before 2017"
	ACHeaderVersion0 = ACModuleHeaderVersion(0x00000000)

	// ACHeaderVersion3 is version "3.0 – for SINIT ACM of converge of BtG and TXT"
	ACHeaderVersion3 = ACModuleHeaderVersion(0x00030000)

	// ACHeaderVersion4 is version "4.0 for SINIT ACM of BtG"
	ACHeaderVersion4 = ACModuleHeaderVersion(0x00040000)
)

func (ver ACModuleHeaderVersion) GoString() string {
	return fmt.Sprintf("0x%08X", ver)
}

// ACChipsetID defines the module release identifier
type ACChipsetID uint16

// ACFlags defines the module-specific flags
type ACFlags uint16

// ACModuleVendor defines the module vendor identifier
type ACModuleVendor uint32

// BCDDate is a date in format ("year.month.day")
type BCDDate uint32

// SizeM4 is a size in multiples of four bytes
type SizeM4 uint32

// Size return the size in bytes
func (size SizeM4) Size() uint64      { return uint64(size) << 2 }
func (size SizeM4) String() string    { return fmt.Sprintf("%d*4", uint32(size)) }
func (size *SizeM4) SetSize(v uint64) { *size = SizeM4(v >> 2) }

// TXTSVN is the TXT Security Version Number
type TXTSVN uint16

// SESVN is the Software Guard Extensions (Secure Enclaves) Security Version Number
type SESVN uint16

// CodeControl is the authenticated code control flags
type CodeControl uint32

// ErrorEntryPoint is the error response entry point offset (bytes)
type ErrorEntryPoint uint32

// Pointer returns the value of ErrorEntryPoint as a pointer which
// could be used for pointer arithmetics.
func (ptr ErrorEntryPoint) Pointer() uint64 { return uint64(ptr) }

// GDTLimit is the GDT limit (defines last byte of GDT)
type GDTLimit uint32

// GDTBasePtr is the GDT base pointer offset (bytes)
type GDTBasePtr uint32

// Offset returns the GDTBasePtr value as a pointer which
// could be used for pointer arithmetics.
func (ptr GDTBasePtr) Offset() uint64 { return uint64(ptr) }

// SegSel is the segment selector initializer
type SegSel uint32

// EntryPoint is the authenticated code entry point offset (bytes)
type EntryPoint uint32

// EntrySACMDataCommon is the common part from the beginning of a startup AC module
// entry of any version.
type EntrySACMDataCommon struct {
	ModuleType      ACModuleType
	ModuleSubType   ACModuleSubType
	HeaderLen       SizeM4
	HeaderVersion   ACModuleHeaderVersion
	ChipsetID       ACChipsetID
	Flags           ACFlags
	ModuleVendor    ACModuleVendor
	Date            BCDDate
	Size            SizeM4
	TXTSVN          TXTSVN
	SESVN           SESVN
	CodeControl     CodeControl
	ErrorEntryPoint ErrorEntryPoint
	GDTLimit        GDTLimit
	GDTBasePtr      GDTBasePtr
	SegSel          SegSel
	EntryPoint      EntryPoint
	Reserved2       [64]byte
	KeySize         SizeM4
	ScratchSize     SizeM4
}

var entrySACMDataCommonSize = uint(binary.Size(EntrySACMDataCommon{}))

// Read parses the ACM common headers
func (entryData *EntrySACMDataCommon) Read(b []byte) (int, error) {
	n, err := entryData.ReadFrom(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// ReadFrom parses the ACM common headers
func (entryData *EntrySACMDataCommon) ReadFrom(r io.Reader) (int64, error) {
	err := binary.Read(r, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMDataCommonSize), nil
}

// Write compiles the SACM common headers into a binary representation
func (entryData *EntrySACMDataCommon) Write(b []byte) (int, error) {
	n, err := entryData.WriteTo(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// WriteTo compiles the SACM common headers into a binary representation
func (entryData *EntrySACMDataCommon) WriteTo(w io.Writer) (int64, error) {
	err := binary.Write(w, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMDataCommonSize), nil
}

// GetModuleType returns the type of AC module
func (entryData *EntrySACMDataCommon) GetModuleType() ACModuleType { return entryData.ModuleType }

// GetModuleSubType returns the subtype of AC module (0 - TXT ACM; 1 - S-ACM)
func (entryData *EntrySACMDataCommon) GetModuleSubType() ACModuleSubType {
	return entryData.ModuleSubType
}

// GetHeaderLen returns HeaderLen field value
func (entryData *EntrySACMDataCommon) GetHeaderLen() SizeM4 { return entryData.HeaderLen }

// GetHeaderVersion returns module format version:
// * 0.0 – for SINIT ACM before 2017
// * 3.0 – for SINIT ACM of converge of BtG and TXT
func (entryData *EntrySACMDataCommon) GetHeaderVersion() ACModuleHeaderVersion {
	return entryData.HeaderVersion
}

// GetChipsetID returns ChipsetID field value
func (entryData *EntrySACMDataCommon) GetChipsetID() ACChipsetID { return entryData.ChipsetID }

// GetFlags returns Flags field value (the module-specific flags)
func (entryData *EntrySACMDataCommon) GetFlags() ACFlags { return entryData.Flags }

// GetModuleVendor returns ModuleVendor field value
func (entryData *EntrySACMDataCommon) GetModuleVendor() ACModuleVendor { return entryData.ModuleVendor }

// GetDate returns Date field value ("year.month.day")
func (entryData *EntrySACMDataCommon) GetDate() BCDDate { return entryData.Date }

// GetSize returns Size field value (the size in multiples of four bytes)
func (entryData *EntrySACMDataCommon) GetSize() SizeM4 { return entryData.Size }

// GetTXTSVN returns TXT security version number
func (entryData *EntrySACMDataCommon) GetTXTSVN() TXTSVN { return entryData.TXTSVN }

// GetSESVN returns Software Guard Extensions (Secure Enclaves) Security Version Number
func (entryData *EntrySACMDataCommon) GetSESVN() SESVN { return entryData.SESVN }

// GetCodeControl returns the authenticated code control flags
func (entryData *EntrySACMDataCommon) GetCodeControl() CodeControl { return entryData.CodeControl }

// GetErrorEntryPoint returns error entry point field value
func (entryData *EntrySACMDataCommon) GetErrorEntryPoint() ErrorEntryPoint {
	return entryData.ErrorEntryPoint
}

// GetGDTLimit returns GDTLimit field value
func (entryData *EntrySACMDataCommon) GetGDTLimit() GDTLimit { return entryData.GDTLimit }

// GetGDTBasePtr returns the GDT base pointer offset (bytes)
func (entryData *EntrySACMDataCommon) GetGDTBasePtr() GDTBasePtr { return entryData.GDTBasePtr }

// GetSegSel the segment selector initializer
func (entryData *EntrySACMDataCommon) GetSegSel() SegSel { return entryData.SegSel }

// GetEntryPoint returns the authenticated code entry point offset (bytes)
func (entryData *EntrySACMDataCommon) GetEntryPoint() EntryPoint { return entryData.EntryPoint }

// GetReserved2 returns the Reserved2 field value
func (entryData *EntrySACMDataCommon) GetReserved2() [64]byte { return entryData.Reserved2 }

// GetKeySize returns the KeySize field value (the size in multiples of four bytes)
func (entryData *EntrySACMDataCommon) GetKeySize() SizeM4 { return entryData.KeySize }

// GetScratchSize returns the ScratchSize field value (the size in multiples of four bytes)
func (entryData *EntrySACMDataCommon) GetScratchSize() SizeM4 { return entryData.ScratchSize }

// GetRSAPubKey returns the RSA public key
func (entryData *EntrySACMDataCommon) GetRSAPubKey() rsa.PublicKey { return rsa.PublicKey{} }

// GetRSAPubExp returns the RSA exponent
func (entryData *EntrySACMDataCommon) GetRSAPubExp() uint32 { return 0 }

// GetRSASig returns the RSA signature.
func (entryData *EntrySACMDataCommon) GetRSASig() []byte { return nil }

// RSASigBinaryOffset returns the RSA signature offset
func (entryData *EntrySACMDataCommon) RSASigBinaryOffset() uint64 { return 0 }

// GetScratch returns the Scratch field value
func (entryData *EntrySACMDataCommon) GetScratch() []byte { return nil }

// HeaderVersionBinaryOffset returns the offset of the field 'HeaderVersion'
// relatively to the beginning of the structure in the binary
// format (see 'encoding/binary').
func (entryData EntrySACMDataCommon) HeaderVersionBinaryOffset() uint {
	return 8
}

// DateBinaryOffset returns the offset of the field 'Date'
// relatively to the beginning of the structure in the binary
// format (see 'encoding/binary').
func (entryData EntrySACMDataCommon) DateBinaryOffset() uint {
	return 20
}

// SizeBinaryOffset returns the offset of the field 'Size'
// relatively to the beginning of the structure in the binary
// format (see 'encoding/binary').
func (entryData EntrySACMDataCommon) SizeBinaryOffset() uint {
	return 24
}

// TXTSVNBinaryOffset returns the offset of the field 'TXTSVN'
// relatively to the beginning of the structure in the binary
// format (see 'encoding/binary').
func (entryData *EntrySACMDataCommon) TXTSVNBinaryOffset() uint64 {
	return 28
}

// KeySizeBinaryOffset returns the offset of the field 'KeySize'
// relatively to the beginning of the structure in the binary
// format (see 'encoding/binary').
func (entryData EntrySACMDataCommon) KeySizeBinaryOffset() uint {
	return 120
}

// EntrySACMData0 is the structure for ACM of version 0.0.
type EntrySACMData0 struct {
	EntrySACMDataCommon

	RSAPubKey [256]byte
	RSAPubExp [4]byte
	RSASig    [256]byte
	Scratch   [572]byte
}

var entrySACMData0Size = uint(binary.Size(EntrySACMData0{}))

// Read parses the ACM v0 headers
func (entryData *EntrySACMData0) Read(b []byte) (int, error) {
	n, err := entryData.ReadFrom(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// ReadFrom parses the ACM v0 headers
func (entryData *EntrySACMData0) ReadFrom(r io.Reader) (int64, error) {
	err := binary.Read(r, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData0Size), nil
}

// Write compiles the SACM v0 headers into a binary representation
func (entryData *EntrySACMData0) Write(b []byte) (int, error) {
	n, err := entryData.WriteTo(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// WriteTo compiles the SACM v0 headers into a binary representation
func (entryData *EntrySACMData0) WriteTo(w io.Writer) (int64, error) {
	err := binary.Write(w, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData0Size), nil
}

// GetRSAPubKey returns the RSA public key
func (entryData *EntrySACMData0) GetRSAPubKey() rsa.PublicKey {
	pubKey := rsa.PublicKey{
		N: big.NewInt(0),
		E: int(entryData.GetRSAPubExp()),
	}
	pubKey.N.SetBytes(entryData.RSAPubKey[:])
	return pubKey
}

// GetRSAPubExp returns the RSA exponent
func (entryData *EntrySACMData0) GetRSAPubExp() uint32 {
	return binary.LittleEndian.Uint32(entryData.RSAPubExp[:])
}

// GetRSASig returns the RSA signature.
func (entryData *EntrySACMData0) GetRSASig() []byte { return entryData.RSASig[:] }

// RSASigBinaryOffset returns the RSA signature offset
func (entryData *EntrySACMData0) RSASigBinaryOffset() uint64 {
	return uint64(binary.Size(entryData.EntrySACMDataCommon)) +
		uint64(binary.Size(entryData.RSAPubKey)) +
		uint64(binary.Size(entryData.RSAPubExp))
}

// GetScratch returns the Scratch field value
func (entryData *EntrySACMData0) GetScratch() []byte { return entryData.Scratch[:] }

// EntrySACMData3 is the structure for ACM of version 3.0
type EntrySACMData3 struct {
	EntrySACMDataCommon

	RSAPubKey [384]byte
	RSASig    [384]byte
	Scratch   [832]byte
}

var entrySACMData3Size = uint(binary.Size(EntrySACMData3{}))

// Read parses the ACM v3 headers
func (entryData *EntrySACMData3) Read(b []byte) (int, error) {
	n, err := entryData.ReadFrom(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// ReadFrom parses the ACM v3 headers
func (entryData *EntrySACMData3) ReadFrom(r io.Reader) (int64, error) {
	err := binary.Read(r, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData3Size), nil
}

// Write compiles the SACM v3 headers into a binary representation
func (entryData *EntrySACMData3) Write(b []byte) (int, error) {
	n, err := entryData.WriteTo(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// WriteTo compiles the SACM v3 headers into a binary representation
func (entryData *EntrySACMData3) WriteTo(w io.Writer) (int64, error) {
	err := binary.Write(w, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData3Size), nil
}

// GetRSAPubKey returns the RSA public key
func (entryData *EntrySACMData3) GetRSAPubKey() rsa.PublicKey {
	pubKey := rsa.PublicKey{
		N: big.NewInt(0),
		E: 0x10001, // see Table 9. "RSAPubExp" of https://www.intel.com/content/www/us/en/software-developers/txt-software-development-guide.html
	}
	pubKey.N.SetBytes(entryData.RSAPubKey[:])
	return pubKey
}

// GetRSASig returns the RSA signature.
func (entryData *EntrySACMData3) GetRSASig() []byte { return entryData.RSASig[:] }

// RSASigBinaryOffset returns the RSA signature offset
func (entryData *EntrySACMData3) RSASigBinaryOffset() uint64 {
	return uint64(binary.Size(entryData.EntrySACMDataCommon)) +
		uint64(binary.Size(entryData.RSAPubKey))
}

// GetScratch returns the Scratch field value
func (entryData *EntrySACMData3) GetScratch() []byte { return entryData.Scratch[:] }

// EntrySACMData combines the structure for ACM and the user area.
type EntrySACMData struct {
	EntrySACMDataInterface

	UserArea []byte
}

type EntrySACMData4 struct {
	EntrySACMDataCommon

	RSAPubKey  [384]byte
	RSASig     [384]byte
	XMSSPubKey [64]byte
	XMSSSig    [2692]byte
	Reserved   [60]byte
	Scratch    [3584]byte
}

var entrySACMData4Size = uint(binary.Size(EntrySACMData4{}))

// Read parses the ACM v3 headers
func (entryData *EntrySACMData4) Read(b []byte) (int, error) {
	n, err := entryData.ReadFrom(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// ReadFrom parses the ACM v3 headers
func (entryData *EntrySACMData4) ReadFrom(r io.Reader) (int64, error) {
	err := binary.Read(r, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData3Size), nil
}

// Write compiles the SACM v3 headers into a binary representation
func (entryData *EntrySACMData4) Write(b []byte) (int, error) {
	n, err := entryData.WriteTo(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// WriteTo compiles the SACM v3 headers into a binary representation
func (entryData *EntrySACMData4) WriteTo(w io.Writer) (int64, error) {
	err := binary.Write(w, binary.LittleEndian, entryData)
	if err != nil {
		return -1, err
	}
	return int64(entrySACMData4Size), nil
}

// GetRSAPubKey returns the RSA public key
func (entryData *EntrySACMData4) GetRSAPubKey() rsa.PublicKey {
	pubKey := rsa.PublicKey{
		N: big.NewInt(0),
		E: 0x10001, // see Table 9. "RSAPubExp" of https://www.intel.com/content/www/us/en/software-developers/txt-software-development-guide.html
	}
	pubKey.N.SetBytes(entryData.RSAPubKey[:])
	return pubKey
}

// GetRSASig returns the RSA signature.
func (entryData *EntrySACMData4) GetRSASig() []byte { return entryData.RSASig[:] }

// RSASigBinaryOffset returns the RSA signature offset
func (entryData *EntrySACMData4) RSASigBinaryOffset() uint64 {
	return uint64(binary.Size(entryData.EntrySACMDataCommon)) +
		uint64(binary.Size(entryData.RSAPubKey))
}

// GetXMSSPubKey returns the XMSS public key
func (entryData *EntrySACMData4) GetXMSSPubKey() []byte { return entryData.XMSSPubKey[:] }

// GetXMSSSig returns the XMSS signature.
func (entryData *EntrySACMData4) GetXMSSSig() []byte { return entryData.XMSSSig[:] }

// GetScratch returns the Scratch field value
func (entryData *EntrySACMData4) GetScratch() []byte { return entryData.Scratch[:] }

// Read parses the ACM
func (entryData *EntrySACMData) Read(b []byte) (int, error) {
	n, err := entryData.ReadFrom(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// ReadFrom parses the ACM
func (entryData *EntrySACMData) ReadFrom(r io.Reader) (int64, error) {
	parsedEntryData, err := ParseSACMData(r)
	if err != nil {
		return -1, err
	}
	*entryData = *parsedEntryData
	return int64(binary.Size(entryData.EntrySACMDataInterface) + len(entryData.UserArea)), nil
}

// Write compiles the SACM into a binary representation
func (entryData *EntrySACMData) Write(b []byte) (int, error) {
	n, err := entryData.WriteTo(bytesextra.NewReadWriteSeeker(b))
	return int(n), err
}

// WriteTo compiles the SACM into a binary representation
func (entryData *EntrySACMData) WriteTo(w io.Writer) (int64, error) {
	totalN, err := entryData.EntrySACMDataInterface.WriteTo(w)
	if err != nil {
		return -1, err
	}
	n, err := w.Write(entryData.UserArea)
	if n >= 0 {
		totalN += int64(n)
	}
	if err != nil {
		return totalN, fmt.Errorf("unable to write UserArea: %w", err)
	}
	if n != len(entryData.UserArea) {
		return totalN, fmt.Errorf("unable to complete writing UserArea: %d != %d: %w", n, len(entryData.UserArea), err)
	}
	return totalN, nil
}

// GetCommon returns the common part of the structures for different ACM versions.
func (entryData *EntrySACMData) GetCommon() *EntrySACMDataCommon {
	if entryData == nil {
		return nil
	}
	switch data := entryData.EntrySACMDataInterface.(type) {
	case *EntrySACMDataCommon:
		return data
	case *EntrySACMData0:
		return &data.EntrySACMDataCommon
	case *EntrySACMData3:
		return &data.EntrySACMDataCommon
	case *EntrySACMData4:
		return &data.EntrySACMDataCommon
	}
	return nil
}

// EntrySACMParseSizeFrom parses SACM structure size
func EntrySACMParseSizeFrom(r io.ReadSeeker, offset uint64) (uint32, error) {
	sizeFieldLocalOffset := EntrySACMDataCommon{}.SizeBinaryOffset()
	sizeFieldOffset := int64(offset) + int64(sizeFieldLocalOffset)
	_, err := r.Seek(sizeFieldOffset, io.SeekStart)
	if err != nil {
		return 0, fmt.Errorf("unable to seek(%d, start): %w", sizeFieldOffset, err)
	}
	var result uint32
	err = binary.Read(r, binary.LittleEndian, &result)
	if err != nil {
		return 0, fmt.Errorf("unable to read: %w", err)
	}
	return result << 2, nil
}

// EntrySACMParseSize parses SACM structure size
func EntrySACMParseSize(b []byte) (uint32, error) {
	sizeFieldOffset := EntrySACMDataCommon{}.SizeBinaryOffset()
	if int(sizeFieldOffset) >= len(b)-4 {
		return 0, &check.ErrEndLessThanStart{StartIdx: int(sizeFieldOffset), EndIdx: len(b) - 4}
	}
	return binary.LittleEndian.Uint32(b[sizeFieldOffset:]) << 2, nil
}

// ParseData parses SACM entry and returns EntrySACMData.
func (entry *EntrySACM) ParseData() (*EntrySACMData, error) {
	entryData := EntrySACMData{}
	_, err := entryData.Read(entry.DataSegmentBytes)
	if err != nil {
		return nil, err
	}
	return &entryData, nil
}

// ParseSACMData parses SACM entry and returns EntrySACMData.
func ParseSACMData(r io.Reader) (*EntrySACMData, error) {

	// Read common headers

	common := EntrySACMDataCommon{}
	if _, err := common.ReadFrom(r); err != nil {
		return nil, fmt.Errorf("unable to parse startup AC module entry: %w", err)
	}
	result := &EntrySACMData{EntrySACMDataInterface: &common, UserArea: nil}

	var requiredKeySize uint64
	switch common.HeaderVersion {
	case ACHeaderVersion0:
		result.EntrySACMDataInterface = &EntrySACMData0{EntrySACMDataCommon: common}
		requiredKeySize = uint64(len(EntrySACMData0{}.RSAPubKey))
	case ACHeaderVersion3:
		result.EntrySACMDataInterface = &EntrySACMData3{EntrySACMDataCommon: common}
		requiredKeySize = uint64(len(EntrySACMData3{}.RSAPubKey))
	case ACHeaderVersion4:
		result.EntrySACMDataInterface = &EntrySACMData4{EntrySACMDataCommon: common}
		requiredKeySize = uint64(len(EntrySACMData4{}.RSAPubKey))
	default:
		return result, &ErrUnknownACMHeaderVersion{ACHeaderVersion: common.HeaderVersion}
	}

	if common.KeySize.Size() != requiredKeySize {
		return result, &ErrACMInvalidKeySize{ExpectedKeySize: requiredKeySize, RealKeySize: common.KeySize.Size()}
	}

	// Read version-specific headers
	//
	// Here we need to continue reading from the reader,
	// but in the resulting struct we need to skip the first field (because it contains
	// already read common headers).

	// Creating a substruct without the first field (which is already read)
	t := reflect.TypeOf(result.EntrySACMDataInterface).Elem()
	var fieldsToBeFilled []reflect.StructField
	for fieldNum := 1; fieldNum < t.NumField(); fieldNum++ {
		fieldsToBeFilled = append(fieldsToBeFilled, t.Field(fieldNum))
	}
	subStructToBeFilled := reflect.New(reflect.StructOf(fieldsToBeFilled))
	// Reading the substruct
	if err := binary.Read(r, binary.LittleEndian, subStructToBeFilled.Interface()); err != nil {
		return result, fmt.Errorf("cannot parse version-specific headers (version 0x%04X): %w", common.HeaderVersion, err)
	}
	// Copying values from the substruct to the headers struct
	subStructToBeFilled = subStructToBeFilled.Elem()
	v := reflect.ValueOf(result.EntrySACMDataInterface).Elem()
	for fieldNum := 1; fieldNum < v.NumField(); fieldNum++ {
		v.Field(fieldNum).Set(subStructToBeFilled.Field(fieldNum - 1))
	}

	// Read UserArea

	// `UserArea` has variable length and therefore was not included into
	// `EntrySACMData0` and `EntrySACMData3/4`, but it is in the tail,
	// so we just calculate the startIndex as the end of
	// EntrySACMData0/EntrySACMData3/4.
	userAreaStartIdx := uint64(binary.Size(result.EntrySACMDataInterface))
	userAreaEndIdx := result.EntrySACMDataInterface.GetSize().Size()
	if userAreaEndIdx > userAreaStartIdx {
		var err error
		result.UserArea, err = readBytesFromReader(r, userAreaEndIdx-userAreaStartIdx)
		if err != nil {
			return result, fmt.Errorf("unable to read user area: %w", err)
		}
	}

	return result, nil
}

type entrySACMJSON struct {
	Headers        *EntryHeaders
	DataParsed     *EntrySACMData `json:",omitempty"`
	DataNotParsed  []byte         `json:"DataNotParsedBase64,omitempty"`
	HeadersErrors  []error
	DataParseError error
}

// MarshalJSON implements json.Marshaler
func (entry *EntrySACM) MarshalJSON() ([]byte, error) {
	result := entrySACMJSON{}
	result.DataParsed, result.DataParseError = entry.ParseData()
	result.Headers = &entry.Headers
	result.HeadersErrors = make([]error, len(entry.HeadersErrors))
	copy(result.HeadersErrors, entry.HeadersErrors)
	result.DataNotParsed = entry.DataSegmentBytes
	return json.Marshal(&result)
}

// UnmarshalJSON implements json.Unmarshaller
func (entry *EntrySACM) UnmarshalJSON(b []byte) error {
	result := entrySACMJSON{}
	err := json.Unmarshal(b, &result)
	if err != nil {
		return err
	}
	entry.Headers = *result.Headers
	entry.HeadersErrors = result.HeadersErrors
	entry.DataSegmentBytes = result.DataNotParsed
	return nil
}

```

`pkg/intel/metadata/fit/ent_startup_ac_module_entry_test.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"crypto/rand"
	"encoding/binary"
	"testing"

	"github.com/stretchr/testify/require"
)

func randBytes(size uint) []byte {
	b := make([]byte, int(size))
	_, _ = rand.Read(b)
	return b
}

func TestEntrySACM_ParseData(t *testing.T) {
	sizeOffset := EntrySACMDataCommon{}.SizeBinaryOffset()
	sizeEndOffset := sizeOffset + uint(binary.Size(EntrySACMDataCommon{}.Size))

	versionOffset := EntrySACMDataCommon{}.HeaderVersionBinaryOffset()
	versionEndOffset := versionOffset + uint(binary.Size(EntrySACMDataCommon{}.HeaderVersion))

	keySizeOffset := EntrySACMDataCommon{}.KeySizeBinaryOffset()
	keySizeEndOffset := keySizeOffset + uint(binary.Size(EntrySACMDataCommon{}.KeySize))

	entry := EntrySACM{
		EntryBase: EntryBase{
			DataSegmentBytes: randBytes(65536),
			HeadersErrors:    nil,
		},
	}

	testPositive := func(t *testing.T, headersSize int) {
		data, err := entry.ParseData()
		require.NoError(t, err)

		_ = data.GetRSAPubKey()
		require.Zero(t, len(data.UserArea))
		require.Zero(t, len(entry.DataSegmentBytes)-headersSize)
		require.NotZero(t, data.GetKeySize())

		var buf bytes.Buffer
		_, err = data.WriteTo(&buf)
		require.NoError(t, err)

		dataCopy, err := ParseSACMData(&buf)
		require.NoError(t, err)

		require.Equal(t, data, dataCopy)
	}

	t.Run("SACMv0", func(t *testing.T) {
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[versionOffset:versionEndOffset], uint32(ACHeaderVersion0))
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[sizeOffset:sizeEndOffset], uint32(entrySACMData0Size)>>2)
		dataSize, err := EntrySACMParseSize(entry.DataSegmentBytes[:65536])
		require.NoError(t, err)
		entry.DataSegmentBytes = entry.DataSegmentBytes[:dataSize]
		t.Run("positive", func(t *testing.T) {
			binary.LittleEndian.PutUint32(entry.DataSegmentBytes[keySizeOffset:keySizeEndOffset], 256>>2)
			testPositive(t, int(entrySACMData0Size))
		})
	})

	t.Run("SACMv3", func(t *testing.T) {
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[versionOffset:versionEndOffset], uint32(ACHeaderVersion3))
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[sizeOffset:sizeEndOffset], uint32(entrySACMData3Size)>>2)
		dataSize, err := EntrySACMParseSize(entry.DataSegmentBytes[:65536])
		require.NoError(t, err)
		entry.DataSegmentBytes = entry.DataSegmentBytes[:dataSize]
		t.Run("positive", func(t *testing.T) {
			binary.LittleEndian.PutUint32(entry.DataSegmentBytes[keySizeOffset:keySizeEndOffset], 384>>2)
			testPositive(t, int(entrySACMData3Size))
		})
		t.Run("negative_keySize", func(t *testing.T) {
			binary.LittleEndian.PutUint32(entry.DataSegmentBytes[keySizeOffset:keySizeEndOffset], 256>>2)

			_, err := entry.ParseData()
			require.Error(t, err)
		})
	})

	t.Run("SACM_invalidVersion", func(t *testing.T) {
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[versionOffset:versionEndOffset], 0x12345678)
		binary.LittleEndian.PutUint32(entry.DataSegmentBytes[sizeOffset:sizeEndOffset], uint32(entrySACMData0Size)>>2)
		dataSize, err := EntrySACMParseSize(entry.DataSegmentBytes[:65536])
		require.NoError(t, err)
		entry.DataSegmentBytes = entry.DataSegmentBytes[:dataSize]

		_, err = entry.ParseData()
		require.Error(t, err)
	})
}

```

`pkg/intel/metadata/fit/ent_tpm_policy_record.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"
	"io"
)

// EntryTPMPolicyRecord represents a FIT entry of type "TPM Policy Record" (0x08)
type EntryTPMPolicyRecord struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryTPMPolicyRecord)(nil)

// Init initializes the entry using EntryHeaders and firmware image.
func (entry *EntryTPMPolicyRecord) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	return 0, fmt.Errorf("EntryTPMPolicyRecord is not supported, yet")
}

var _ EntryCustomRecalculateHeaderser = (*EntryTPMPolicyRecord)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryTPMPolicyRecord) CustomRecalculateHeaders() error {
	return fmt.Errorf("EntryTPMPolicyRecord is not supported, yet")
}

```

`pkg/intel/metadata/fit/ent_txt_policy_record.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
)

// EntryTXTPolicyRecord represents a FIT entry of type "TXT Policy Record" (0x0A)
type EntryTXTPolicyRecord struct{ EntryBase }

var _ EntryCustomGetDataSegmentSizer = (*EntryTXTPolicyRecord)(nil)

// Init initializes the entry using EntryHeaders and firmware image.
func (entry *EntryTXTPolicyRecord) CustomGetDataSegmentSize(firmware io.ReadSeeker) (uint64, error) {
	// TXT policy record has no data section and the Address field is used to store the data.
	return 0, nil
}

var _ EntryCustomRecalculateHeaderser = (*EntryTXTPolicyRecord)(nil)

// CustomRecalculateHeaders recalculates metadata to be consistent with data.
// For example, it fixes checksum, data size, entry type and so on.
func (entry *EntryTXTPolicyRecord) CustomRecalculateHeaders() error {
	entryBase := entry.GetEntryBase()
	entryBase.DataSegmentBytes = nil
	hdr := &entryBase.Headers
	hdr.TypeAndIsChecksumValid.SetType(EntryTypeTXTPolicyRecord)

	// See 4.9.10 of the FIT specification.
	hdr.TypeAndIsChecksumValid.SetIsChecksumValid(false)
	// See 4.9.11 of the FIT specification.
	hdr.Size.SetUint32(0)
	return nil
}

// EntryTXTPolicyRecordDataInterface is a parsed TXT Policy Record entry
type EntryTXTPolicyRecordDataInterface interface {
	IsTXTEnabled() bool
}

// EntryTXTPolicyRecordDataIndexedIO is a parsed TXT Policy Record entry of
// version 1.
type EntryTXTPolicyRecordDataIndexedIO struct {
	IndexRegisterIOAddress uint16
	DataRegisterIOAddress  uint16
	AccessWidth            uint8
	BitPosition            uint8
	Index                  uint16
}

// IsTXTEnabled returns true if TXT is enabled.
func (entryData *EntryTXTPolicyRecordDataIndexedIO) IsTXTEnabled() bool {
	panic("not implemented")
}

// EntryTXTPolicyRecordDataFlatPointer is a parsed TXT Policy Record entry
// of version 0
type EntryTXTPolicyRecordDataFlatPointer uint64

// TPMPolicyPointer returns the TPM Policy pointer.
func (entryData EntryTXTPolicyRecordDataFlatPointer) TPMPolicyPointer() uint64 {
	return uint64(entryData & 0x7fffffffffffffff)
}

// IsTXTEnabled returns true if TXT is enabled.
func (entryData EntryTXTPolicyRecordDataFlatPointer) IsTXTEnabled() bool {
	return entryData&0x8000000000000000 != 0
}

// Parse parses TXT Policy Record entry
func (entry *EntryTXTPolicyRecord) Parse() (EntryTXTPolicyRecordDataInterface, error) {
	switch entry.Headers.Version {
	case 0:
		result := EntryTXTPolicyRecordDataFlatPointer(entry.Headers.Address.Pointer())
		return result, nil
	case 1:
		var b [8]byte
		binary.LittleEndian.PutUint64(b[:], entry.Headers.Address.Pointer())
		var dataParsed EntryTXTPolicyRecordDataIndexedIO
		err := binary.Read(bytes.NewReader(b[:]), binary.LittleEndian, &dataParsed)
		if err != nil {
			return nil, fmt.Errorf("unable to parse EntryTXTPolicyRecordDataIndexedIO: %w", err)
		}
		return &dataParsed, nil
	}

	return nil, &ErrInvalidTXTPolicyRecordVersion{entry.Headers.Version}
}

```

`pkg/intel/metadata/fit/ent_unknown.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// EntryUnknown represents an unknown FIT entry type.
type EntryUnknown struct{ EntryBase }

```

`pkg/intel/metadata/fit/entry.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/hashicorp/go-multierror"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/check"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/consts"
	"github.com/xaionaro-go/bytesextra"
)

// Entry is the interface common to any FIT entry
type Entry interface {
	// GetEntryBase returns EntryBase (which contains metadata of the Entry).
	GetEntryBase() *EntryBase
}

// EntryCustomGetDataSegmentSizer is an extension of Entry which overrides the default
// procedure of calculating the data segment size.
type EntryCustomGetDataSegmentSizer interface {
	// CustomGetDataSegmentSize returns the size of the data segment associates with the entry.
	CustomGetDataSegmentSize(firmwareImage io.ReadSeeker) (uint64, error)
}

// CustomRecalculateHeaderser is an extension of Entry which overrides the default
// procedure of recalculating EntryHeaders.
type EntryCustomRecalculateHeaderser interface {
	// CustomRecalculateHeaders recalculates metadata to be consistent with data.
	// For example, it fixes checksum, data size, entry type and so on.
	CustomRecalculateHeaders() error
}

// EntriesByType is a helper to sort a slice of `Entry`-ies by their type/class.
type EntriesByType []Entry

func (entries EntriesByType) Less(i, j int) bool {
	return entries[i].GetEntryBase().Headers.Type() < entries[j].GetEntryBase().Headers.Type()
}
func (entries EntriesByType) Swap(i, j int) { entries[i], entries[j] = entries[j], entries[i] }
func (entries EntriesByType) Len() int      { return len(entries) }

// mostCommonRecalculateHeadersOfEntry recalculates entry headers using headers data using the most common rules:
// * Set "Version" to 0x0100.
// * Set "IsChecksumValid" to true.
// * Set "Type" to the type of the entry.
// * Set "Checksum" to the calculated checksum value of the headers
// * Set "Size" to a multiple of 16 of the data size (in other words: len(data) >> 4).
//
// This is considered the most common set of rules for the most FIT entry types. But different types may break
// different rules.
func mostCommonRecalculateHeadersOfEntry(entry Entry) {
	entryType, foundEntryType := entryTypeOf(entry)
	if !foundEntryType {
		panic(fmt.Errorf("type %T is not known", entry))
	}

	entryBase := entry.GetEntryBase()
	hdr := &entryBase.Headers
	hdr.TypeAndIsChecksumValid.SetType(entryType)
	hdr.TypeAndIsChecksumValid.SetIsChecksumValid(true)
	hdr.Checksum = hdr.CalculateChecksum()
	hdr.Version = EntryVersion(0x0100)
	hdr.Size.SetUint32(uint32(len(entryBase.DataSegmentBytes) >> 4))
}

// EntryRecalculateHeaders recalculates headers of the entry based on its data.
func EntryRecalculateHeaders(entry Entry) error {
	if recalcer, ok := entry.(EntryCustomRecalculateHeaderser); ok {
		return recalcer.CustomRecalculateHeaders()
	}

	mostCommonRecalculateHeadersOfEntry(entry)
	return nil
}

// Entries are a slice of multiple parsed FIT entries (headers + data)
type Entries []Entry

// RecalculateHeaders recalculates metadata to be consistent with data. For example, it fixes checksum, data size,
// entry type and so on.
//
// Supposed to be used before Inject or/and InjectTo. Since it is possible to prepare data in entries, then
// call Rehash (to prepare headers consistent with data).
func (entries Entries) RecalculateHeaders() error {
	if len(entries) == 0 {
		return nil
	}

	for idx, entry := range entries {
		err := EntryRecalculateHeaders(entry)
		if err != nil {
			return fmt.Errorf("unable to recalculate headers of FIT entry #%d (%#+v): %w", idx, entry, err)
		}
	}

	beginEntry, ok := entries[0].(*EntryFITHeaderEntry)
	if !ok {
		return fmt.Errorf("the first entry is not a EntryFITHeaderEntry, but %T", entries[0])
	}

	// See point 4.2.5 of the FIT specification
	beginEntry.GetEntryBase().Headers.Size.SetUint32(uint32(len(entries)))

	return nil
}

// Table returns a table of headers of all entries of the slice.
func (entries Entries) Table() Table {
	result := make(Table, 0, len(entries))
	for _, entry := range entries {
		if entry.GetEntryBase() == nil {
			panic(fmt.Sprintf("%T", entry))
		}
		result = append(result, entry.GetEntryBase().Headers)
	}
	return result
}

// String implements fmt.Stringer
func (entries Entries) String() string {
	var result strings.Builder
	for idx, entry := range entries {
		hdr := entry.GetEntryBase().Headers
		result.WriteString(fmt.Sprintf("Entry #%d\n\tType: %s (0x%X)\n\tVersion: 0x%04X\n\tAddr: 0x%X\n\tSize: 0x%06X\n\tChecksum: 0x%X\n\tChecksum is valid: %v\n",
			idx,
			hdr.Type(), uint(hdr.Type()),
			uint16(hdr.Version),
			hdr.Address.Pointer(),
			hdr.Size.Uint32(),
			hdr.Checksum,
			hdr.IsChecksumValid(),
		))
		if data := entry.GetEntryBase().DataSegmentBytes; len(data) > 0 {
			result.WriteString(fmt.Sprintf("\tData: 0x%X\n", data))
		}
	}
	return result.String()
}

// Inject writes complete FIT (headers + data + pointer) to a firmware image.
//
// What will happen:
// 1. The FIT headers will be written by offset headersOffset.
// 2. The FIT pointer will be written at consts.FITPointerOffset offset from the end of the image.
// 3. Data referenced by FIT headers will be written at offsets accordingly to Address fields (in the headers).
//
// Consider calling Rehash() before Inject()/InjectTo()
func (entries Entries) Inject(b []byte, headersOffset uint64) error {
	return entries.InjectTo(bytesextra.NewReadWriteSeeker(b), headersOffset)
}

// InjectTo does the same as Inject, but for io.WriteSeeker.
func (entries Entries) InjectTo(w io.WriteSeeker, headersOffset uint64) error {

	// Detect image size

	imageSize, err := w.Seek(0, io.SeekEnd)
	if err != nil {
		return fmt.Errorf("unable to detect the end of the image: %w", err)
	}
	if imageSize < 0 {
		panic(fmt.Errorf("negative image size: %d", imageSize))
	}

	// Write FIT pointer

	if _, err := w.Seek(-consts.FITPointerOffset, io.SeekEnd); err != nil {
		return fmt.Errorf("unable to Seek(%d, %d) to write FIT pointer: %w", headersOffset, io.SeekStart, err)
	}
	pointerValue := CalculatePhysAddrFromOffset(headersOffset, uint64(imageSize))
	if err := binary.Write(w, binary.LittleEndian, pointerValue); err != nil {
		return fmt.Errorf("unable to write FIT pointer: %w", err)
	}

	// Write headers

	if _, err := w.Seek(int64(headersOffset), io.SeekStart); err != nil {
		return fmt.Errorf("unable to Seek(%d, %d) to write headers: %w", headersOffset, io.SeekStart, err)
	}

	table := entries.Table()
	if _, err := table.WriteTo(w); err != nil {
		return fmt.Errorf("unable to write %d headers to offset %d: %w", len(table), headersOffset, err)
	}

	// Write data sections

	for idx, entry := range entries {
		if err := entry.GetEntryBase().injectDataSectionTo(w); err != nil {
			return fmt.Errorf("unable to inject data section of entry %d: %w", idx, err)
		}
	}

	return nil
}

func copyBytesFrom(r io.ReadSeeker, startIdx, endIdx uint64) ([]byte, error) {
	_, err := r.Seek(int64(startIdx), io.SeekStart)
	if err != nil {
		return nil, fmt.Errorf("unable to Seek(%d, io.SeekStart): %w", int64(startIdx), err)
	}

	if endIdx < startIdx {
		return nil, fmt.Errorf("endIdx < startIdx: %d < %d", endIdx, startIdx)
	}

	return readBytesFromReader(r, endIdx-startIdx)
}

func readBytesFromReader(r io.Reader, size uint64) ([]byte, error) {
	result := make([]byte, size)
	written, err := io.CopyN(bytesextra.NewReadWriteSeeker(result), r, int64(size))
	if err != nil {
		return nil, fmt.Errorf("unable to copy %d bytes: %w", int64(size), err)
	}
	if written != int64(size) {
		return nil, fmt.Errorf("invalid amount of bytes copied: %d != %d", written, int64(size))
	}

	return result, nil
}

// EntryDataSegmentSize returns the coordinates of the data segment size associates with the entry.
func EntryDataSegmentSize(entry Entry, firmware io.ReadSeeker) (uint64, error) {
	if sizeGetter, ok := entry.(EntryCustomGetDataSegmentSizer); ok {
		return sizeGetter.CustomGetDataSegmentSize(firmware)
	} else {
		return entry.GetEntryBase().Headers.mostCommonGetDataSegmentSize(), nil
	}
}

// EntryDataSegmentCoordinates returns the coordinates of the data segment coordinates associates with the entry.
func EntryDataSegmentCoordinates(entry Entry, firmware io.ReadSeeker) (uint64, uint64, error) {
	var err error

	offset, addErr := entry.GetEntryBase().Headers.getDataSegmentOffset(firmware)
	if addErr != nil {
		err = multierror.Append(err, fmt.Errorf("unable to get data segment offset: %w", err))
	}

	size, addErr := EntryDataSegmentSize(entry, firmware)
	if addErr != nil {
		err = multierror.Append(err, fmt.Errorf("unable to get data segment size: %w", err))
	}

	return offset, size, err
}

// If possible then make a slice of existing data; if not then copy.
func sliceOrCopyBytesFrom(r io.ReadSeeker, startIdx, endIdx uint64) ([]byte, error) {
	switch r := r.(type) {
	case *bytesextra.ReadWriteSeeker:
		if err := check.BytesRange(uint(len(r.Storage)), int(startIdx), int(endIdx)); err != nil {
			return nil, err
		}
		return r.Storage[startIdx:endIdx], nil
	default:
		return copyBytesFrom(r, startIdx, endIdx)
	}
}

func entryInitDataSegmentBytes(entry Entry, firmware io.ReadSeeker) error {
	dataSegmentOffset, dataSegmentSize, err := EntryDataSegmentCoordinates(entry, firmware)
	if err != nil {
		return fmt.Errorf("unable to get data segment coordinates of entry %T: %w", entry, err)
	}

	if dataSegmentSize == 0 {
		return nil
	}

	base := entry.GetEntryBase()

	base.DataSegmentBytes, err = sliceOrCopyBytesFrom(firmware, dataSegmentOffset, dataSegmentOffset+dataSegmentSize)
	if err != nil {
		return fmt.Errorf("unable to copy data segment bytes from the firmware image (offset:%d, size:%d): %w", dataSegmentOffset, dataSegmentSize, err)
	}

	return nil
}

// NewEntry returns a new entry using headers and firmware image
func NewEntry(hdr *EntryHeaders, firmware io.ReadSeeker) Entry {
	entry := hdr.Type().newEntry()
	if entry == nil {
		entry = &EntryUnknown{}
	}
	base := entry.GetEntryBase()
	base.Headers = *hdr

	err := entryInitDataSegmentBytes(entry, firmware)
	if err != nil {
		base.HeadersErrors = append(base.HeadersErrors, err)
	}

	return entry
}

```

`pkg/intel/metadata/fit/entry_base.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"
	"io"
)

// EntryBase is the common information for any FIT entry
type EntryBase struct {
	// Headers is FIT entry headers.
	//
	// See "Table 1-1" in "1.2 Firmware Interface Table" in "Firmware Interface Table" specification:
	//  * https://www.intel.com/content/dam/www/public/us/en/documents/guides/fit-bios-specification.pdf
	Headers EntryHeaders

	// DataSegmentBytes is the raw bytes of the special data segment referenced by the headers.
	//
	// Is not nil only if FIT entry really references to a data segment. If FIT entry
	// stores data directly in headers then DataSegmentBytes is nil.
	DataSegmentBytes []byte `json:",omitempty"`

	// HeadersErrors is the list of errors occurred while parsing and interpreting FIT entry headers.
	HeadersErrors []error `json:",omitempty"`
}

// GetEntryBase returns EntryBase (which contains metadata of the Entry).
func (entry *EntryBase) GetEntryBase() *EntryBase {
	return entry
}

// GoString implements fmt.GoStringer
func (entry *EntryBase) GoString() string {
	return entry.Headers.GoString()
}

// injectDataSectionTo does the same as InjectData, but for io.WriteSeeker.
func (entry EntryBase) injectDataSectionTo(w io.WriteSeeker) error {
	base := entry.GetEntryBase()

	if len(base.DataSegmentBytes) == 0 {
		return nil
	}

	firmwareSize, err := w.Seek(0, io.SeekEnd)
	if err != nil {
		return fmt.Errorf("unable to detect firmware size: %w", err)
	}

	dataSectionOffset := base.Headers.Address.Offset(uint64(firmwareSize))
	if _, err := w.Seek(int64(dataSectionOffset), io.SeekStart); err != nil {
		return fmt.Errorf("unable to Seek(%d, %d) to write the data section: %w", int64(dataSectionOffset), io.SeekStart, err)
	}

	if _, err := w.Write(entry.DataSegmentBytes); err != nil {
		return fmt.Errorf("unable to write the data section: %w", err)
	}

	return nil
}

```

`pkg/intel/metadata/fit/entry_headers.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/xaionaro-go/bytesextra"
)

var (
	entryHeadersSize = uint(binary.Size(EntryHeaders{}))
)

// EntryHeaders implements a "FIT Entry Format".
//
// See "Table 1-1" in "1.2 Firmware Interface Table" in "Firmware Interface Table" specification:
//   - https://www.intel.com/content/dam/www/public/us/en/documents/guides/fit-bios-specification.pdf
//
// Descriptions of the fields are adapted descriptions from the document by the link above.
type EntryHeaders struct {
	// Address is the base address of the firmware component.
	// Must be aligned on 16 byte boundary.
	Address Address64

	Size Uint24

	// Reserved should always be equal to zero.
	Reserved uint8

	Version EntryVersion

	TypeAndIsChecksumValid TypeAndIsChecksumValid

	Checksum uint8
}

func (hdr EntryHeaders) copy() *EntryHeaders {
	return &hdr
}

// GoString implements fmt.GoStringer.
func (hdr *EntryHeaders) GoString() string {
	var result strings.Builder
	result.WriteString(fmt.Sprintf("   Address: 0x%x\n", hdr.Address.Pointer()))
	result.WriteString(fmt.Sprintf("   size: 0x%x\n", hdr.Size.Uint32()))
	result.WriteString(fmt.Sprintf("   Version: 0x%x\n", uint16(hdr.Version)))
	result.WriteString(fmt.Sprintf("   Type: 0x%x\n", uint8(hdr.TypeAndIsChecksumValid)))
	result.WriteString(fmt.Sprintf("   Checksum: 0x%x\n", hdr.Checksum))
	return result.String()
}

type entryHeadersForJSON struct {
	Address         uint64
	Size            uint32
	Reserved        uint8 `json:",omitempty"`
	Version         EntryVersion
	Type            EntryType
	IsChecksumValid bool
	Checksum        uint8
}

// MarshalJSON just implements encoding/json.Marshaler
func (hdr EntryHeaders) MarshalJSON() ([]byte, error) {
	return json.Marshal(&entryHeadersForJSON{
		Address:         hdr.Address.Pointer(),
		Size:            hdr.Size.Uint32(),
		Reserved:        hdr.Reserved,
		Version:         hdr.Version,
		Type:            hdr.Type(),
		IsChecksumValid: hdr.IsChecksumValid(),
		Checksum:        hdr.Checksum,
	})
}

// UnmarshalJSON just implements encoding/json.Unmarshaler
func (hdr *EntryHeaders) UnmarshalJSON(b []byte) error {
	var parsed entryHeadersForJSON
	err := json.Unmarshal(b, &parsed)
	if err != nil {
		return err
	}
	*hdr = EntryHeaders{
		Address:  Address64(parsed.Address),
		Reserved: parsed.Reserved,
		Version:  parsed.Version,
		Checksum: parsed.Checksum,
	}
	hdr.Size.SetUint32(parsed.Size)
	hdr.TypeAndIsChecksumValid.SetType(parsed.Type)
	hdr.TypeAndIsChecksumValid.SetIsChecksumValid(parsed.IsChecksumValid)
	return nil
}

// Uint24 is a 24 bit unsigned little-endian integer value.
type Uint24 struct {
	Value [3]byte
}

// Uint32 returns the value as parsed uint32.
//
// If the value is used in "Size" then in the most cases the value should be
// shifted with "<< 4" to get the real size value.
//
// See also the code of EntryHeaders.getDataCoordinates()
func (size Uint24) Uint32() uint32 {
	b := make([]byte, 4)
	copy(b[:], size.Value[:])
	return binary.LittleEndian.Uint32(b)
}

// SetUint32 sets the value. See also Uint32.
func (size *Uint24) SetUint32(newValue uint32) {
	if newValue >= 1<<24 {
		panic(fmt.Errorf("too big integer: %d >= %d", newValue, 1<<24))
	}
	b := make([]byte, 4)
	binary.LittleEndian.PutUint32(b, newValue)
	copy(size.Value[:], b[:])
}

// MarshalJSON just implements encoding/json.Marshaler
func (size Uint24) MarshalJSON() ([]byte, error) {
	return json.Marshal(size.Uint32())
}

// UnmarshalJSON just implements encoding/json.Unmarshaler
func (size *Uint24) UnmarshalJSON(b []byte) error {
	var parsed uint32
	err := json.Unmarshal(b, &parsed)
	if err != nil {
		return err
	}
	if parsed >= 1<<24 {
		return fmt.Errorf("too big integer: %d >= %d", parsed, 1<<24)
	}
	size.SetUint32(parsed)
	return nil
}

// Address64 is a 64bit address type
type Address64 uint64

// Pointer returns the pointer which could be used for pointer arithmetics.
func (addr Address64) Pointer() uint64 { return uint64(addr) }

// Offset returns an offset from the beginning of a firmware of a defined size.
func (addr Address64) Offset(firmwareSize uint64) uint64 {
	return CalculateOffsetFromPhysAddr(addr.Pointer(), firmwareSize)
}

// SetOffset sets the value to a physical address corresponding to
// an offset from the beginning of the firmware.
//
// See also the description of calculatePhysAddrFromOffset.
func (addr *Address64) SetOffset(offset, firmwareSize uint64) {
	physAddr := CalculatePhysAddrFromOffset(offset, firmwareSize)
	*addr = Address64(physAddr)
}

// String implements fmt.Stringer
func (addr Address64) String() string { return fmt.Sprintf("0x%x", addr.Pointer()) }

// EntryVersion contains the component's version number in binary
// coded decimal (BCD) format. For the FIT header entry, the value in this
// field will indicate the revision number of the FIT data structure.
// The upper byte of the revision field indicates the major revision and
// the lower byte indicates the minor revision. The format 0x1234 conveys
// the major number encoded in the first two digits and the minor number
// in the last two with a fixed point assumed in between
type EntryVersion uint16

// Major returns the major part of the entry version
func (ver EntryVersion) Major() uint8 { return uint8(ver & 0xff00 >> 8) }

// Minor returns the minor part of the entry version
func (ver EntryVersion) Minor() uint8 { return uint8(ver & 0xff) }

func (ver EntryVersion) String() string {
	b, _ := ver.MarshalJSON()
	return string(b)
}

type entryVersionStruct struct {
	Major uint8 `json:"maj"`
	Minor uint8 `json:"min,omitempty"`
}

// MarshalJSON just implements encoding/json.Marshaler
func (ver EntryVersion) MarshalJSON() ([]byte, error) {
	return json.Marshal(&entryVersionStruct{
		Major: ver.Major(),
		Minor: ver.Minor(),
	})
}

// UnmarshalJSON just implements encoding/json.Unmarshaler
func (ver *EntryVersion) UnmarshalJSON(b []byte) error {
	parsed := entryVersionStruct{}
	err := json.Unmarshal(b, &parsed)
	if err != nil {
		return err
	}
	*ver = EntryVersion(parsed.Major)<<8 | EntryVersion(parsed.Minor)
	return nil
}

// SizeM16 is a size in multiple of 16 bytes (M16).
type SizeM16 uint16

// Size returns the size in bytes
func (size SizeM16) Size() uint     { return uint(size) << 4 }
func (size SizeM16) String() string { return fmt.Sprintf("0x%x*0x10", uint16(size)) }

// TypeAndIsChecksumValid combines two fields:
//   - "C_V" -- Checksum Valid bit. This is a one bit field that indicates,
//     whether component has a valid checksum. CPU must ignore
//     "Checksum" field, if C_V bit is not set.
//   - EntryType (see "entry_type.go").
type TypeAndIsChecksumValid uint8

// IsChecksumValid returns bit "C_V" of the FIT entry.
//
// A quote from the specification:
// Checksum Valid bit. This is a one bit field that indicates, whether
// component has a valid checksum. CPU must ignore CHKSUM field, if C_V bit is not set.
func (f TypeAndIsChecksumValid) IsChecksumValid() bool {
	return f&0x80 != 0
}

// Type returns field EntryType ("TYPE" of the FIT entry in terms of
// the specification).
func (f TypeAndIsChecksumValid) Type() EntryType {
	return EntryType(f & 0x7f)
}

func (f TypeAndIsChecksumValid) String() string {
	b, _ := f.MarshalJSON()
	return string(b)
}

// SetType sets the value of field EntryType ("TYPE" of the FIT entry in terms of
// the specification).
func (f *TypeAndIsChecksumValid) SetType(newType EntryType) {
	if uint(newType) & ^uint(0x7f) != 0 {
		panic(fmt.Errorf("invalid type: 0x%X", newType))
	}
	otherBits := TypeAndIsChecksumValid(uint(*f) & ^uint(0x7f))
	*f = TypeAndIsChecksumValid(newType) | otherBits
}

// SetIsChecksumValid sets the value of field IsChecksumValid ("C_V" of the FIT entry in terms of
// the specification).
func (f *TypeAndIsChecksumValid) SetIsChecksumValid(newValue bool) {
	valueBits := TypeAndIsChecksumValid(0)
	if newValue {
		valueBits = TypeAndIsChecksumValid(0x80)
	}

	otherBits := TypeAndIsChecksumValid(uint(*f) & uint(0x7f))
	*f = valueBits | otherBits
}

type typeAndIsChecksumValidStruct struct {
	Type            EntryType `json:"type"`
	IsChecksumValid bool      `json:"isChecksumValid,omitempty"`
}

// MarshalJSON just implements encoding/json.Marshaler
func (f TypeAndIsChecksumValid) MarshalJSON() ([]byte, error) {
	return json.Marshal(&typeAndIsChecksumValidStruct{
		IsChecksumValid: f.IsChecksumValid(),
		Type:            f.Type(),
	})
}

// UnmarshalJSON just implements encoding/json.Unmarshaler
func (f *TypeAndIsChecksumValid) UnmarshalJSON(b []byte) error {
	parsed := typeAndIsChecksumValidStruct{}
	err := json.Unmarshal(b, &parsed)
	if err != nil {
		return err
	}
	if parsed.Type >= 0x80 {
		return fmt.Errorf(`"type" value is too high`)
	}
	*f = TypeAndIsChecksumValid(parsed.Type & 0x7f)
	if parsed.IsChecksumValid {
		*f |= 0x80
	}
	return nil
}

// GetEntry returns a full entry (headers + data)
func (hdr EntryHeaders) GetEntry(firmware []byte) Entry {
	return hdr.GetEntryFrom(bytesextra.NewReadWriteSeeker(firmware))
}

// GetEntryFrom returns a full entry (headers + data)
func (hdr EntryHeaders) GetEntryFrom(firmware io.ReadSeeker) Entry {
	return NewEntry(hdr.copy(), firmware)
}

// Type returns the type of the FIT entry
func (hdr *EntryHeaders) Type() EntryType {
	return hdr.TypeAndIsChecksumValid.Type()
}

// IsChecksumValid returns if bit "C_V" has value "1".
func (hdr *EntryHeaders) IsChecksumValid() bool {
	return hdr.TypeAndIsChecksumValid.IsChecksumValid()
}

func (hdr *EntryHeaders) String() string {
	return fmt.Sprintf("&%+v", *hdr)
}

var _ io.Writer = (*EntryHeaders)(nil)

// Write implements io.Writer. It writes the headers in a binary format to `b`.
func (hdr *EntryHeaders) Write(b []byte) (int, error) {
	n, err := hdr.WriteTo(bytes.NewBuffer(b))
	return int(n), err
}

var _ io.WriterTo = (*EntryHeaders)(nil)

// WriteTo implements io.WriterTo. It writes the headers in a binary format to `w`.
func (hdr *EntryHeaders) WriteTo(w io.Writer) (int64, error) {
	if hdr == nil {
		return 0, nil
	}

	err := binary.Write(w, binary.LittleEndian, hdr)
	if err != nil {
		return -1, fmt.Errorf("unable to write headers %#+v: %w", *hdr, err)
	}

	return int64(binary.Size(*hdr)), nil
}

// CalculateChecksum calculates the checksum ("CHKSUM")
// according to point 4.0 of the FIT specification.
func (hdr *EntryHeaders) CalculateChecksum() uint8 {
	_copy := *hdr
	_copy.Checksum = 0

	var buf bytes.Buffer
	if err := binary.Write(&buf, binary.LittleEndian, _copy); err != nil {
		panic(err)
	}

	result := uint8(0)
	for _, _byte := range buf.Bytes() {
		result += _byte
	}

	return result
}

// getDataSegmentCoordinates returns the offset of the data segment
// associated with the entry.
func (hdr *EntryHeaders) getDataSegmentOffset(firmware io.Seeker) (uint64, error) {
	firmwareSize, err := firmware.Seek(0, io.SeekEnd)
	if err != nil {
		return 0, fmt.Errorf("unable to get the size of the firmware: %w", err)
	}

	return hdr.Address.Offset(uint64(firmwareSize)), nil
}

// mostCommonGetDataSegmentCoordinates returns the length of the data segment
// associated with the entry using the most common rule:
// * The size equals to "Size" multiplied by 16.
//
// This is considered the most common rule for the most FIT entry types. But different types may break it.
func (hdr *EntryHeaders) mostCommonGetDataSegmentSize() uint64 {
	return uint64(hdr.Size.Uint32()) << 4
}

```

`pkg/intel/metadata/fit/entry_test.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"github.com/linuxboot/fiano/pkg/intel/metadata/cbnt/cbntkey"
	"github.com/stretchr/testify/require"
	"github.com/xaionaro-go/bytesextra"
)

func TestRehashEntry(t *testing.T) {
	for _, entryType := range AllEntryTypes() {
		switch entryType {
		case EntryTypeDiagnosticACModuleEntry,
			EntryTypeTPMPolicyRecord:
			// not supported yet
			continue
		}

		entry := entryType.newEntry()
		*entry.GetEntryBase() = EntryBase{
			DataSegmentBytes: make([]byte, 0x20),
			HeadersErrors:    nil,
		}
		func() {
			defer func() {
				_r := recover()
				if strings.Contains(fmt.Sprint(_r), "should not be used for an entry type") {
					// It does not make sense to call method GetHeaders().DataSize() on
					// some EntryType-s, see (*EntryHeaders).DataSize()
					//
					// This is because data size for some entries is not stored in the headers.
					return
				}
				require.Nil(t, _r)
			}()

			// Validating there is no errors
			err := EntryRecalculateHeaders(entry)
			if err != nil {
				// Not all entry types are fully implemented, see RehashEntry()
				t.Errorf("%v", err)
			}

			// Validating that DataSize() calculates sizes consistently with RehashEntry()
			if entryType != EntryTypeStartupACModuleEntry {
				dataSize, err := EntryDataSegmentSize(entry, nil)
				require.NoError(t, err)
				if dataSize != 0 && dataSize != uint64(len(entry.GetEntryBase().DataSegmentBytes)) {
					t.Errorf("wrong DataSize 0x%X for type %s", dataSize, entryType)
				}
			}
		}()
	}
}

func getSampleEntries(t *testing.T) Entries {
	var entries Entries
	headerEntry := &EntryFITHeaderEntry{}
	skipEntry := &EntrySkip{}

	kmEntry := &EntryKeyManifestRecord{}
	{
		km := cbntkey.NewManifest()
		var buf bytes.Buffer
		_, err := km.WriteTo(&buf)
		require.NoError(t, err)
		kmEntry.DataSegmentBytes = buf.Bytes()
	}
	kmEntry.Headers.Address.SetOffset(256, 1024)

	entries = append(entries, headerEntry)
	entries = append(entries, skipEntry)
	entries = append(entries, kmEntry)
	err := entries.RecalculateHeaders()
	require.NoError(t, err)
	return entries
}

func TestEntriesInject(t *testing.T) {
	testResult := func(t *testing.T, b []byte) {
		entries := getSampleEntries(t)

		parsedEntries, err := GetEntries(b)
		require.NoError(t, err)
		require.Equal(t, len(entries), len(parsedEntries))
		for idx, parsedEntry := range parsedEntries {
			require.Equal(t, entries[idx].GetEntryBase().DataSegmentBytes, parsedEntry.GetEntryBase().DataSegmentBytes)
		}
	}

	t.Run("Inject", func(t *testing.T) {
		entries := getSampleEntries(t)
		b := make([]byte, 1024)
		err := entries.Inject(b, 512)
		require.NoError(t, err)

		testResult(t, b)
	})

	t.Run("InjectTo", func(t *testing.T) {
		entries := getSampleEntries(t)
		b := make([]byte, 1024)
		err := entries.InjectTo(bytesextra.NewReadWriteSeeker(b), 512)
		require.NoError(t, err)

		testResult(t, b)
	})
}

```

`pkg/intel/metadata/fit/entry_type.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"
	"reflect"
	"sort"
	"strings"
)

// EntryType is a 7 bit field containing the type code for the component
// registered in the FIT table.
type EntryType uint8

// noinspection GoSnakeCaseUsage
const (
	EntryTypeFITHeaderEntry              = EntryType(0x00)
	EntryTypeMicrocodeUpdateEntry        = EntryType(0x01)
	EntryTypeStartupACModuleEntry        = EntryType(0x02)
	EntryTypeDiagnosticACModuleEntry     = EntryType(0x03)
	EntryTypeBIOSStartupModuleEntry      = EntryType(0x07)
	EntryTypeTPMPolicyRecord             = EntryType(0x08)
	EntryTypeBIOSPolicyRecord            = EntryType(0x09)
	EntryTypeTXTPolicyRecord             = EntryType(0x0A)
	EntryTypeKeyManifestRecord           = EntryType(0x0B)
	EntryTypeBootPolicyManifest          = EntryType(0x0C)
	EntryTypeCSESecureBoot               = EntryType(0x10)
	EntryTypeFeaturePolicyDeliveryRecord = EntryType(0x2D)
	EntryTypeJMPDebugPolicy              = EntryType(0x2F)
	EntryTypeSkip                        = EntryType(0x7F)
)

// String implements fmt.Stringer
func (_type EntryType) String() string {
	if goType, ok := entryTypeIDToGo[_type]; ok {
		name := goType.Name()
		if strings.HasPrefix(name, "Entry") {
			return name[len("Entry"):]
		}
		return name
	}

	return fmt.Sprintf("unknown_entry_0x%X", uint8(_type))
}

var (
	entryTypeIDToGo = map[EntryType]reflect.Type{}
	entryTypeGoToID = map[reflect.Type]EntryType{}
)

func goTypeOfEntry(entry Entry) reflect.Type {
	return reflect.Indirect(reflect.ValueOf(entry)).Type()
}

// RegisterEntryType adds a new FIT entry type to the registry of known entry types.
func RegisterEntryType(entryTypeID EntryType, entryGoType Entry) {
	if goType, ok := entryTypeIDToGo[entryTypeID]; ok {
		delete(entryTypeIDToGo, entryTypeID)
		delete(entryTypeGoToID, goType)
	}

	goType := goTypeOfEntry(entryGoType)
	entryTypeIDToGo[entryTypeID] = goType
	entryTypeGoToID[goType] = entryTypeID
}

func init() {
	RegisterEntryType(EntryTypeFITHeaderEntry, &EntryFITHeaderEntry{})
	RegisterEntryType(EntryTypeMicrocodeUpdateEntry, &EntryMicrocodeUpdateEntry{})
	RegisterEntryType(EntryTypeStartupACModuleEntry, &EntrySACM{})
	RegisterEntryType(EntryTypeDiagnosticACModuleEntry, &EntryDiagnosticACM{})
	RegisterEntryType(EntryTypeBIOSStartupModuleEntry, &EntryBIOSStartupModuleEntry{})
	RegisterEntryType(EntryTypeTPMPolicyRecord, &EntryTPMPolicyRecord{})
	RegisterEntryType(EntryTypeBIOSPolicyRecord, &EntryBIOSPolicyRecord{})
	RegisterEntryType(EntryTypeTXTPolicyRecord, &EntryTXTPolicyRecord{})
	RegisterEntryType(EntryTypeKeyManifestRecord, &EntryKeyManifestRecord{})
	RegisterEntryType(EntryTypeBootPolicyManifest, &EntryBootPolicyManifestRecord{})
	RegisterEntryType(EntryTypeCSESecureBoot, &EntryCSESecureBoot{})
	RegisterEntryType(EntryTypeFeaturePolicyDeliveryRecord, &EntryFeaturePolicyDeliveryRecord{})
	RegisterEntryType(EntryTypeJMPDebugPolicy, &EntryJMPDebugPolicy{})
	RegisterEntryType(EntryTypeSkip, &EntrySkip{})
}

// newEntry returns a new empty entry instance of a registered type.
func (_type EntryType) newEntry() Entry {
	goType, ok := entryTypeIDToGo[_type]
	if !ok {
		return nil
	}

	entry := reflect.New(goType).Interface().(Entry)
	return entry
}

// entryTypeOf returns EntryType based on variable type (in contrast to
// reading it from the headers).
func entryTypeOf(entry Entry) (EntryType, bool) {
	entryTypeID, ok := entryTypeGoToID[goTypeOfEntry(entry)]
	return entryTypeID, ok
}

func AllEntryTypes() []EntryType {
	result := make([]EntryType, 0, len(entryTypeIDToGo))
	for entryType := range entryTypeIDToGo {
		result = append(result, entryType)
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i] < result[j]
	})
	return result
}

```

`pkg/intel/metadata/fit/errors.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/consts"
)

// ErrACMInvalidKeySize means ACM entry has invalid key size
type ErrACMInvalidKeySize struct {
	ExpectedKeySize uint64
	RealKeySize     uint64
}

func (err *ErrACMInvalidKeySize) Error() string {
	return fmt.Sprintf("invalid key size, expected:%d, real:%d",
		err.ExpectedKeySize, err.RealKeySize)
}

// ErrUnknownACMHeaderVersion means ACM entry has invalid header version
type ErrUnknownACMHeaderVersion struct {
	ACHeaderVersion ACModuleHeaderVersion
}

func (err *ErrUnknownACMHeaderVersion) Error() string {
	return fmt.Sprintf("unknown ACM header version: %#v", err.ACHeaderVersion)
}

// ErrInvalidTXTPolicyRecordVersion means TXT Policy entry has invalid version.
type ErrInvalidTXTPolicyRecordVersion struct {
	EntryVersion EntryVersion
}

func (err *ErrInvalidTXTPolicyRecordVersion) Error() string {
	return fmt.Sprintf("invalid TXT policy record version: %v", err.EntryVersion)
}

// ErrExpectedFITHeadersMagic means FIT magic string was not found where
// it was expected.
type ErrExpectedFITHeadersMagic struct {
	Received []byte
}

func (err *ErrExpectedFITHeadersMagic) Error() string {
	return fmt.Sprintf("string '%s' was expected as the Address value of the FIT header entry, but received: '%s'",
		consts.FITHeadersMagic, err.Received)
}

// ErrNotFound literally means "not found".
type ErrNotFound struct{}

func (ErrNotFound) Error() string {
	return "not found"
}

```

`pkg/intel/metadata/fit/firmware.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

// Firmware is an abstraction from (*uefi.UEFI).
type Firmware interface {
	ImageBytes() []byte
	PhysAddrToOffset(physAddr uint64) uint64
}

```

`pkg/intel/metadata/fit/get_entries.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"fmt"
	"io"

	"github.com/xaionaro-go/bytesextra"
)

// GetEntries returns parsed FIT-entries
func GetEntries(firmware []byte) (Entries, error) {
	return GetEntriesFrom(bytesextra.NewReadWriteSeeker(firmware))
}

// GetEntriesFrom returns parsed FIT-entries
func GetEntriesFrom(firmware io.ReadSeeker) (Entries, error) {
	table, err := GetTableFrom(firmware)
	if err != nil {
		return nil, fmt.Errorf("unable to get FIT table: %w", err)
	}

	return table.GetEntriesFrom(firmware), nil
}

```

`pkg/intel/metadata/fit/get_entries_test.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"compress/bzip2"
	"encoding/base64"
	"fmt"
	"io"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

var (
	fitHeadersSampleBZ2, _ = base64.StdEncoding.DecodeString(
		"QlpoOTFBWSZTWeqFfFEBARl/z/6cAAhAEAJAISIUAMAAYADAABBMUgACAI4AAAiwANiQkhUepkNBk0A0Gj0nqGMmmQMmhkGRpgRgVJRHqBPUGmBPQQB6mu/KQvlYVFwVWSqIERBhUJJEkSR53rKJMcLkAQB4VEmzyuIBAGNSSaLY2elZ4gEAapJc7BvQ6GAOz3zzwaWQh1wYvXevCRHSI64eYVYAyTeHJJpz9TxxkkkkkgAA+ewChlSjX5WsDQH+LuSKcKEh1Qr4og==")
)

func panicIfError(err error) {
	if err != nil {
		panic(err)
	}
}

func TestGetEntries(t *testing.T) {
	firmwareBytes, err := io.ReadAll(bzip2.NewReader(bytes.NewReader(fitHeadersSampleBZ2)))
	panicIfError(err)

	entries, err := GetEntries(firmwareBytes)
	assert.NoError(t, err)

	assert.Equal(t, 27, len(entries))
}

func TestGetEntriesInvalidAddr(t *testing.T) {
	sampleEntries := getSampleEntries(t)
	for _, entry := range sampleEntries[1:] {
		entry.GetEntryBase().Headers.Address = 2<<32 + 1 // overflow
		entry.GetEntryBase().DataSegmentBytes = nil
	}

	dummyImage := make([]byte, 1024)
	err := sampleEntries.Inject(dummyImage, 512)
	require.NoError(t, err)

	// There should be no panic, and the errors should be inside entry headers.
	entries, err := GetEntries(dummyImage)
	require.NoError(t, err)
	for _, entry := range entries[1:] {
		switch entry := entry.(type) {
		case *EntrySkip:
			continue
		default:
			require.Contains(t, fmt.Sprintf("%v", entry.GetEntryBase().HeadersErrors), "index")
		}
	}
}

// BenchmarkGetEntries-8             520621              2357 ns/op            2944 B/op         59 allocs/op
func BenchmarkGetEntries(b *testing.B) {
	firmwareBytes, err := io.ReadAll(bzip2.NewReader(bytes.NewReader(fitHeadersSampleBZ2)))
	panicIfError(err)

	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = GetEntries(firmwareBytes)
	}
}

```

`pkg/intel/metadata/fit/table.go`:

```go
// Copyright 2017-2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fit

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"

	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/check"
	"github.com/linuxboot/fiano/pkg/intel/metadata/fit/consts"
	"github.com/xaionaro-go/bytesextra"
)

// Table is the FIT entry headers table (located by the "FIT Pointer"), without
// data this headers reference to.
type Table []EntryHeaders

// GetEntries returns parsed FIT-entries
func (table Table) GetEntries(firmware []byte) (result Entries) {
	return table.GetEntriesFrom(bytesextra.NewReadWriteSeeker(firmware))
}

// GetEntriesFrom returns parsed FIT-entries
func (table Table) GetEntriesFrom(firmware io.ReadSeeker) (result Entries) {
	for _, headers := range table {
		result = append(result, headers.GetEntryFrom(firmware))
	}
	return
}

// String prints the fit table in a tabular form
func (table Table) String() string {
	var s strings.Builder
	// PrintFit prints the Firmware Interface Table in a tabular human readable form.
	fmt.Fprintf(&s, "%-3s | %-32s | %-20s | %-8s | %-6s | %-15s | %-10s\n", "#", "Type", "Address", "Size", "Version", "Checksum valid", "Checksum")
	s.WriteString("---------------------------------------------------------------------------------------------------------------\n")
	for idx, entry := range table {
		fmt.Fprintf(&s, "%-3d | %-25s (0x%02X) | %-20s | %-8d | 0x%04x  | %-15v | %-10d\n",
			idx,
			entry.Type(), uint8(entry.Type()),
			entry.Address.String(),
			entry.Size.Uint32(),
			uint16(entry.Version),
			entry.IsChecksumValid(),
			entry.Checksum)
	}
	return s.String()
}

// First returns the first entry headers with selected entry type
func (table Table) First(entryType EntryType) *EntryHeaders {
	for idx, headers := range table {
		if headers.Type() == entryType {
			return &table[idx]
		}
	}
	return nil
}

// Write compiles FIT headers into a binary representation and writes to "b". If len(b)
// is less than required, then io.ErrUnexpectedEOF is returned.
func (table Table) Write(b []byte) (n int, err error) {
	for idx, entryHeaders := range table {
		addN, err := entryHeaders.Write(b)
		if err != nil {
			return n, fmt.Errorf("unable to write headers #%d (%#+v): %w", idx, entryHeaders, err)
		}
		n += addN
	}

	return n, nil
}

// WriteTo does the same as Write, but for io.Writer
func (table Table) WriteTo(w io.Writer) (n int64, err error) {
	for idx, entryHeaders := range table {
		addN, err := entryHeaders.WriteTo(w)
		if err != nil {
			return n, fmt.Errorf("unable to write headers #%d (%#+v): %w", idx, entryHeaders, err)
		}
		n += addN
	}

	return n, nil
}

// WriteToFirmwareImage finds the position of FIT in a firmware image and writes the table there.
func (table Table) WriteToFirmwareImage(w io.ReadWriteSeeker) (n int64, err error) {
	startIdx, _, err := GetHeadersTableRangeFrom(w)
	if err != nil {
		return 0, fmt.Errorf("unable to find the beginning of the FIT: %w", err)
	}

	if _, err := w.Seek(int64(startIdx), io.SeekStart); err != nil {
		return 0, fmt.Errorf("unable to Seek(%d, io.SeekStart): %w", int64(startIdx), err)
	}

	return table.WriteTo(w)
}

// ParseEntryHeadersFrom parses a single entry headers entry.
func ParseEntryHeadersFrom(r io.Reader) (*EntryHeaders, error) {
	entryHeaders := EntryHeaders{}
	err := binary.Read(r, binary.LittleEndian, &entryHeaders)
	if err != nil {
		return nil, fmt.Errorf("unable to parse FIT entry headers: %w", err)
	}

	return &entryHeaders, nil
}

// ParseTable parses a FIT table from `b`.
func ParseTable(b []byte) (Table, error) {
	var result Table
	r := bytes.NewReader(b)
	for r.Len() > 0 {
		entryHeaders, err := ParseEntryHeadersFrom(r)
		if err != nil {
			return nil, fmt.Errorf("unable to parse FIT headers table: %w", err)
		}
		result = append(result, *entryHeaders)
	}
	return result, nil
}

// GetPointerCoordinates returns the position of the FIT pointer within
// the firmware.
func GetPointerCoordinates(firmwareSize uint64) (startIdx, endIdx int64) {
	startIdx = int64(firmwareSize) - consts.FITPointerOffset
	endIdx = startIdx + consts.FITPointerSize
	return
}

// GetHeadersTableRangeFrom returns the starting and ending indexes of the FIT
// headers table within the firmware image.
func GetHeadersTableRangeFrom(firmware io.ReadSeeker) (startIdx, endIdx uint64, err error) {

	/*
		An example:
		<image start>
		...
		01bb0000: 5f46 4954 5f20 2020 1b00 0000 0001 0000  _FIT_   ........ <--+
		01bb0010: 80d5 e3ff 0000 0000 0000 0000 0001 0100  ................    |
		01bb0020: 804d e4ff 0000 0000 0000 0000 0001 0100  .M..............    |
		01bb0030: 80c5 e4ff 0000 0000 0000 0000 0001 0100  ................    |
		01bb0040: 8035 e5ff 0000 0000 0000 0000 0001 0100  .5..............    |
		01bb0050: ffff ffff 0000 0000 0000 0000 0001 7f00  ................    |
		...                                                                    |
		01bb0180: 7000 7100 0105 2a00 0000 0000 0000 0a00  p.q...*.........    |
		01bb0190: 80c2 e5ff 0000 0000 4102 0000 0001 0b00  ........A.......    |
		01bb01a0: 00b2 e5ff 0000 0000 df02 0000 0001 0c00  ................    |
		01bb01b0: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  xxxxxxxxxxxxxxxx    |
		...                                                                    |
		01ffffb0: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  xxxxxxxxxxxxxxxx    |
		01ffffc0: 0000 bbff 0000 0000 0000 0000 0000 0000  ................ >--+
		01ffffd0: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  xxxxxxxxxxxxxxxx
		01ffffe0: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  xxxxxxxxxxxxxxxx
		01fffff0: xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  xxxxxxxxxxxxxxxx
		<image end>

		So "0000 bbff" (LE: 0xffbb0000) is seems to be the fitPointer
		(according to the specification).

		Re-check:
		 * fitPointerOffset <- 0x100000000 - 0xffbb0000 == 0x450000
		 * headersStartIdx <- 0x2000000 - 0x450000 == 0x1bb0000
		It's the correct value, yey!

		The full procedure in more formal terms was:
		 * fitPointerPointer <- 0x2000000 (firmwareLength) - 0x40 == 0x01ffffc0
		 * fitPointer <- *fitPointerPointer == 0xffbb0000
		 * fitPointerOffset <- 0x100000000 (const) - 0xffbb0000 == 0x450000
		 * headersStartIdx <- 0x2000000 - 0x450000 == 0x1bb0000
	*/

	firmwareSize, err := firmware.Seek(0, io.SeekEnd)
	if err != nil || firmwareSize < 0 {
		return 0, 0, fmt.Errorf("unable to determine firmware size; result: %d; err: %w", firmwareSize, err)
	}

	fitPointerStartIdx, fitPointerEndIdx := GetPointerCoordinates(uint64(firmwareSize))

	if err := check.BytesRange(uint(firmwareSize), int(fitPointerStartIdx), int(fitPointerEndIdx)); err != nil {
		return 0, 0, fmt.Errorf("invalid fit pointer bytes range: %w", err)
	}

	fitPointerBytes, err := sliceOrCopyBytesFrom(firmware, uint64(fitPointerStartIdx), uint64(fitPointerEndIdx))
	if err != nil {
		return 0, 0, fmt.Errorf("unable to get FIT pointer value: %w", err)
	}
	fitPointerValue := binary.LittleEndian.Uint64(fitPointerBytes)
	fitPointerOffset := CalculateTailOffsetFromPhysAddr(fitPointerValue)
	startIdx = uint64(firmwareSize) - fitPointerOffset

	// OK, now we need to calculate the end of the headers...
	//
	// It's pretty easy. The first entry describes the table itself, and it's
	// size is the size of the table. So let's just use it.

	firstHeaderEndIdx := startIdx + uint64(entryHeadersSize)
	if err = check.BytesRange(uint(firmwareSize), int(startIdx), int(firstHeaderEndIdx)); err != nil {
		err = fmt.Errorf("invalid the first entry bytes range: %w", err)
		return
	}

	tableMeta := EntryHeaders{}

	if _, err = firmware.Seek(int64(startIdx), io.SeekStart); err != nil {
		err = fmt.Errorf("unable to Seek(%d, io.SeekStart) in the firmware: %w", int64(startIdx), err)
		return
	}
	err = binary.Read(firmware, binary.LittleEndian, &tableMeta)
	if err != nil {
		err = fmt.Errorf("unable to parse the first entry: %w", err)
		return
	}

	// Verify if the first entry contains "_FIT_  " as the address (as it is
	// described by the point 1.2.2 of the specification).

	var buf bytes.Buffer
	err = binary.Write(&buf, binary.LittleEndian, tableMeta.Address)
	if err != nil {
		err = fmt.Errorf("unable to read the Address value of the FIT header entry: %w", err)
		return
	}
	if !bytes.Equal([]byte(consts.FITHeadersMagic), buf.Bytes()) {
		err = &ErrExpectedFITHeadersMagic{Received: buf.Bytes()}
		return
	}

	// OK, it's correct. Now we know the size of the table and we can
	// parseHeaders it.

	endIdx = startIdx + uint64(tableMeta.Size.Uint32()<<4) // See 4.2.5
	if err = check.BytesRange(uint(firmwareSize), int(startIdx), int(endIdx)); err != nil {
		err = fmt.Errorf("invalid entries bytes range: %w", err)
		return
	}

	return
}

// GetTable returns the table of FIT entries of the firmware image.
func GetTable(firmware []byte) (Table, error) {
	return GetTableFrom(bytesextra.NewReadWriteSeeker(firmware))
}

// GetTableFrom returns the table of FIT entries of the firmware image.
func GetTableFrom(firmware io.ReadSeeker) (Table, error) {
	startIdx, endIdx, err := GetHeadersTableRangeFrom(firmware)
	if err != nil {
		return nil, fmt.Errorf("unable to locate the table coordinates (does the image contain FIT?): %w", err)
	}

	tableBytes, err := sliceOrCopyBytesFrom(firmware, startIdx, endIdx)
	if err != nil {
		return nil, fmt.Errorf("unable to copy bytes from the firmware: %w", err)
	}

	result, err := ParseTable(tableBytes)
	if err != nil {
		return nil, fmt.Errorf("unable to parse the table: %w", err)
	}

	return result, nil
}

```

`pkg/intel/microcode/microcode.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package microcode

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
)

const (
	DefaultDatasize  = 2000
	DefaultTotalSize = 2048
)

type Microcode struct {
	Header
	Data               []byte
	ExtSigTable        ExtendedSigTable
	ExtendedSignatures []ExtendedSignature
}

func (m *Microcode) String() string {
	s := fmt.Sprintf("sig=0x%x, pf=0x%x, rev=0x%x, total size=0x%x, date = %04x-%02x-%02x",
		m.HeaderProcessorSignature, m.HeaderProcessorFlags, m.HeaderRevision,
		getTotalSize(m.Header), m.HeaderDate&0xffff, m.HeaderDate>>24, (m.HeaderDate>>16)&0xff)
	if len(m.ExtendedSignatures) > 0 {
		s += "\n"
	}
	for i := range m.ExtendedSignatures {
		s += fmt.Sprintf("Extended signature[%d]: %s\n", i, m.ExtendedSignatures[i].String())
	}
	return s
}

type Header struct {
	HeaderVersion            uint32 // must be 0x1
	HeaderRevision           uint32
	HeaderDate               uint32 // packed BCD, MMDDYYYY
	HeaderProcessorSignature uint32
	HeaderChecksum           uint32
	HeaderLoaderRevision     uint32
	HeaderProcessorFlags     uint32
	HeaderDataSize           uint32 // 0 means 2000
	HeaderTotalSize          uint32 // 0 means 2048
	Reserved1                [3]uint32
}

type ExtendedSignature struct {
	Signature      uint32
	ProcessorFlags uint32
	Checksum       uint32
}

func (e *ExtendedSignature) String() string {
	return fmt.Sprintf("sig=0x%x, pf=0x%x", e.Signature, e.ProcessorFlags)
}

type ExtendedSigTable struct {
	Count    uint32
	Checksum uint32
	Reserved [3]uint32
}

func getTotalSize(h Header) uint32 {
	if h.HeaderDataSize > 0 {
		return h.HeaderTotalSize
	} else {
		return DefaultTotalSize
	}
}

func getDataSize(h Header) uint32 {
	if h.HeaderDataSize > 0 {
		return h.HeaderDataSize
	} else {
		return DefaultDatasize
	}
}

// ParseIntelMicrocode parses the Intel microcode update
func ParseIntelMicrocode(r io.Reader) (*Microcode, error) {
	var m Microcode

	if err := binary.Read(r, binary.LittleEndian, &m.Header); err != nil {
		return nil, fmt.Errorf("failed to read header: %w", err)
	}

	// Sanitychecks
	if getTotalSize(m.Header) < getDataSize(m.Header)+uint32(binary.Size(Header{})) {
		return nil, fmt.Errorf("bad data file size")
	}
	if m.HeaderLoaderRevision != 1 || m.HeaderVersion != 1 {
		return nil, fmt.Errorf("invalid version or revision")
	}
	if getDataSize(m.Header)%4 > 0 {
		return nil, fmt.Errorf("data size not 32bit aligned")
	}
	if getTotalSize(m.Header)%4 > 0 {
		return nil, fmt.Errorf("total size not 32bit aligned")
	}
	// Read data
	m.Data = make([]byte, getDataSize(m.Header))
	if err := binary.Read(r, binary.LittleEndian, &m.Data); err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}

	// Calculcate checksum
	buf := bytes.NewBuffer([]byte{})
	buf.Grow(int(getDataSize(m.Header)) + binary.Size(Header{}))
	_ = binary.Write(buf, binary.LittleEndian, &m.Header)
	_ = binary.Write(buf, binary.LittleEndian, &m.Data)

	var checksum uint32
	for {
		var data uint32
		if err := binary.Read(buf, binary.LittleEndian, &data); err != nil {
			break
		}
		checksum += data
	}
	if checksum != 0 {
		return nil, fmt.Errorf("checksum is not null: %#x", checksum)
	}

	if getTotalSize(m.Header) <= getDataSize(m.Header)+uint32(binary.Size(Header{})) {
		return &m, nil
	}

	// Read extended header
	if err := binary.Read(r, binary.LittleEndian, &m.ExtSigTable); err != nil {
		return nil, fmt.Errorf("failed to read extended sig table: %w", err)
	}
	for i := uint32(0); i < m.ExtSigTable.Count; i++ {
		var signature ExtendedSignature
		if err := binary.Read(r, binary.LittleEndian, &signature); err != nil {
			return nil, fmt.Errorf("failed to read extended signature: %w", err)
		}
		m.ExtendedSignatures = append(m.ExtendedSignatures, signature)
	}

	// Calculcate checksum
	buf = bytes.NewBuffer([]byte{})
	buf.Grow(binary.Size(ExtendedSigTable{}) +
		int(m.ExtSigTable.Count)*binary.Size(ExtendedSignature{}))
	_ = binary.Write(buf, binary.LittleEndian, &m.ExtSigTable)
	for i := uint32(0); i < m.ExtSigTable.Count; i++ {
		_ = binary.Write(buf, binary.LittleEndian, &m.ExtendedSignatures[i])
	}

	checksum = 0
	for {
		var data uint32
		if err := binary.Read(buf, binary.LittleEndian, &data); err != nil {
			break
		}
		checksum += data
	}
	if checksum != 0 {
		return nil, fmt.Errorf("extended header checksum is not null: %#x", checksum)
	}

	return &m, nil
}

```

`pkg/intel/microcode/microcode_test.go`:

```go
// Copyright 2023 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package microcode

import (
	"bytes"
	"testing"
)

var (
	testMicrocode         = []byte("\x01\x00\x00\x00\x24\x04\x00\x00\x22\x20\x19\x09\xa3\x06\x09\x00\x5d\xd4\xdd\xf6\x01\x00\x00\x00\x80\x00\x00\x00\x04\x00\x00\x00\x34\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")
	testMicrocodeExtTable = []byte("\x01\x00\x00\x00\x24\x04\x00\x00\x22\x20\x19\x09\xa3\x06\x09\x00\x31\xd4\xdd\xf6\x01\x00\x00\x00\x80\x00\x00\x00\x04\x00\x00\x00\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x06\x5a\x21\x95\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa3\x06\x09\x00\x80\x00\x00\x00\xd9\x4b\x66\xb5\xa4\x06\x09\x00\x80\x00\x00\x00\xd8\x4b\x66\xb5")
)

func TestParseMicrocodeExtTable(t *testing.T) {
	var m *Microcode
	var err error

	if m, err = ParseIntelMicrocode(bytes.NewBuffer(testMicrocodeExtTable)); err != nil {
		t.Errorf("Failed to parse microcode %v", err)
		return
	}
	if m.HeaderProcessorFlags != 0x80 {
		t.Errorf("Got microcode processor flags %#x, expected %#x", m.HeaderProcessorFlags, 0x80)
	}
	if m.HeaderDataSize != 4 {
		t.Errorf("Got microcode data size %#x, expected %#x", m.HeaderDataSize, 4)
	}
	if m.HeaderTotalSize != 0x60 {
		t.Errorf("Got microcode total size %#x, expected %#x", m.HeaderTotalSize, 0x60)
	}
	if m.HeaderProcessorSignature != 0x906a3 {
		t.Errorf("Got microcode processor signature %#x, expected %#x", m.HeaderProcessorSignature, 0x906a3)
	}
	if m.HeaderDate != 0x9192022 {
		t.Errorf("Got microcode date %#x, expected %#x", m.HeaderDate, 0x9192022)
	}
	if len(m.Data) != 4 {
		t.Errorf("Got microcode data length %d, expected %d", len(m.Data), 4)
	}
	if len(m.ExtendedSignatures) != 2 {
		t.Errorf("Got extended signatures %d, expected %d", len(m.ExtendedSignatures), 2)
	}
	if m.ExtendedSignatures[0].ProcessorFlags != 0x80 {
		t.Errorf("Got extended #0 microcode processor flags %#x, expected %#x",
			m.ExtendedSignatures[0].ProcessorFlags, 0x80)
	}
	if m.ExtendedSignatures[0].Signature != 0x906a3 {
		t.Errorf("Got extended #0 processor signature %#x, expected %#x",
			m.ExtendedSignatures[0].Signature, 0x906a3)
	}
	if m.ExtendedSignatures[1].ProcessorFlags != 0x80 {
		t.Errorf("Got extended #1 microcode processor flags %#x, expected %#x",
			m.ExtendedSignatures[1].ProcessorFlags, 0x80)
	}
	if m.ExtendedSignatures[1].Signature != 0x906a4 {
		t.Errorf("Got extended #1 processor signature %#x, expected %#x",
			m.ExtendedSignatures[1].Signature, 0x906a4)
	}
}

func TestParseMicrocode(t *testing.T) {
	var m *Microcode
	var err error

	if m, err = ParseIntelMicrocode(bytes.NewBuffer(testMicrocode)); err != nil {
		t.Errorf("Failed to parse microcode %v", err)
		return
	}
	if m.HeaderProcessorFlags != 0x80 {
		t.Errorf("Got microcode processor flags %#x, expected %#x", m.HeaderProcessorFlags, 0x80)
	}
	if m.HeaderDataSize != 4 {
		t.Errorf("Got microcode data size %#x, expected %#x", m.HeaderDataSize, 4)
	}
	if m.HeaderTotalSize != 0x34 {
		t.Errorf("Got microcode total size %#x, expected %#x", m.HeaderTotalSize, 0x34)
	}
	if m.HeaderProcessorSignature != 0x906a3 {
		t.Errorf("Got microcode processor signature %#x, expected %#x", m.HeaderProcessorSignature, 0x906a3)
	}
	if m.HeaderDate != 0x9192022 {
		t.Errorf("Got microcode date %#x, expected %#x", m.HeaderDate, 0x9192022)
	}
	if len(m.Data) != 4 {
		t.Errorf("Got microcode data length %d, expected %d", len(m.Data), 4)
	}
	if len(m.ExtendedSignatures) != 0 {
		t.Errorf("Got extended signatures %d, expected %d", len(m.ExtendedSignatures), 0)
	}
}

func TestParseMicrocodeErrors(t *testing.T) {
	// Invalid checksum
	testData := make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[16] += 1

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// Header version invlaid
	testData = make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[0] = 2

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// Datasize not multiple of 4
	testData = make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[28] += 1

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// Datasize invalid
	testData = make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[28] = 8

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// TotalSize invalid
	testData = make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[32] = 0

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// TotalSize invalid
	testData = make([]byte, len(testMicrocode))
	copy(testData, testMicrocode)
	testData[32] += 1

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// ExtTable invalid checksum
	testData = make([]byte, len(testMicrocodeExtTable))
	copy(testData, testMicrocodeExtTable)
	testData[len(testData)-1] += 1

	if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
		t.Errorf("Exptected error but didn't get one")
	}

	// Input to short
	for i := 0; i < len(testMicrocodeExtTable)-1; i++ {
		testData = make([]byte, i)
		copy(testData, testMicrocodeExtTable[:i])

		if _, err := ParseIntelMicrocode(bytes.NewBuffer(testData)); err == nil {
			t.Errorf("Exptected error but didn't get one")
		}
	}
}

```

`pkg/knownguids/guids.go`:

```go
// Copyright 2020 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package knownguids contains a list of guids and their names.
// THIS FILE IS GENERATED! DO NOT MODIFY!
// To regenerate, run: go run scripts/namecollect/namecollect.go
package knownguids

import "github.com/linuxboot/fiano/pkg/guid"

// GUIDs is a mapping from a GUID to its name.
var GUIDs = map[guid.GUID]string{
	*guid.MustParse("A17BA4F0-3DEB-4FE5-BD27-EC008E541B22"): "AcpiDbg2LibArm",
	*guid.MustParse("686FE5FE-B944-485F-8B1C-7D60E0056487"): "AcpiFadtLibArm",
	*guid.MustParse("26490F7A-7FA2-423C-8939-C6206329BC37"): "AcpiGtdtLibArm",
	*guid.MustParse("25682BA8-B41D-4403-B034-253769E0DAD5"): "AcpiIortLibArm",
	*guid.MustParse("24B9D62C-5A36-417B-94B6-38DBAEA90DCF"): "AcpiLib",
	*guid.MustParse("AF76C93B-41B5-454D-83CD-D2A80A1C1E38"): "AcpiMadtLibArm",
	*guid.MustParse("8C9BDCB2-72D4-4F30-A12D-1145C3807FF7"): "AcpiMcfgLibArm",
	*guid.MustParse("F0F6F006-DAB4-44B2-A7A1-0F72EEDCA716"): "AcpiPlatform",
	*guid.MustParse("368B3649-F204-4CD0-89A8-091077C070FA"): "AcpiPlatform",
	*guid.MustParse("CB933912-DF8F-4305-B1F9-7B44FA11395C"): "AcpiPlatform",
	*guid.MustParse("49970331-E3FA-4637-9ABC-3B7868676970"): "AcpiPlatform",
	*guid.MustParse("D5F92408-BAB5-44CA-8A60-C212F01D7E9D"): "AcpiPlatform",
	*guid.MustParse("FA102D52-5A92-4F95-A097-1D53F9CF5959"): "AcpiPpttLibArm",
	*guid.MustParse("20F31568-D687-49BA-B326-CCD9D38EDE16"): "AcpiRawLibArm",
	*guid.MustParse("2BDED685-F733-455F-A840-43A22B791FB3"): "AcpiS3SaveDxe",
	*guid.MustParse("F5AC7057-5650-466E-B692-76A47223EFB0"): "AcpiSmmPlatform",
	*guid.MustParse("55088136-7B78-4974-B1EE-F630150D0DE7"): "AcpiSpcrLibArm",
	*guid.MustParse("2CE21E0A-A39C-4B26-BC0E-526178036ACD"): "AcpiSratLibArm",
	*guid.MustParse("506533A6-E626-4500-B14F-17939C0E5B60"): "AcpiSupportDxe",
	*guid.MustParse("9622E42C-8E38-4A08-9E8F-54F784652F6B"): "AcpiTableDxe",
	*guid.MustParse("A41BF616-EF77-4658-9992-D813071C34CF"): "AcpiTimerLib",
	*guid.MustParse("46361B5B-AF17-41FF-95F9-E1BCE08435B9"): "AcpiViewApp",
	*guid.MustParse("79E5CA15-7A2D-4F37-A63B-D1C7BBCA47AD"): "AhciPei",
	*guid.MustParse("2EC9DA37-EE35-4DE9-86C5-6D9A81DC38A7"): "AmdSevDxe",
	*guid.MustParse("3A738B36-B9C5-4763-ABBD-6CBD4B25F9FF"): "AndroidBootApp",
	*guid.MustParse("ED3B8739-6FA7-4CB1-8AEB-2496F8FCAEFA"): "AndroidBootImgLib",
	*guid.MustParse("9588502A-5370-11E3-8631-D7C5951364C8"): "AndroidFastbootApp",
	*guid.MustParse("B6C0DCB6-434E-4BEC-BDAC-8EE7ED8A4EC8"): "ArithChk",
	*guid.MustParse("82DA1B44-D2D6-4A7D-BBF0-A0CB67964034"): "ArmArchTimerLib",
	*guid.MustParse("F1D943B6-99C5-46D5-AF5A-66EC67662700"): "ArmBaseLib",
	*guid.MustParse("1A20BE1F-33AD-450C-B49A-7123FCA8B7F9"): "ArmCacheMaintenanceLib",
	*guid.MustParse("B8D9777E-D72A-451F-9BDB-BAFB52A68415"): "ArmCpuDxe",
	*guid.MustParse("0BDA00B0-05D6-4BB8-BFC7-058AD13615CF"): "ArmCrashDumpDxe",
	*guid.MustParse("7ACEC173-F15D-426C-8F2F-BD86B4183EF1"): "ArmDisassemblerLib",
	*guid.MustParse("A9796991-4E88-47F0-87C5-D96A1D270539"): "ArmExceptionLib",
	*guid.MustParse("7A07E61D-9967-407F-AE85-2EB0B50BEF2C"): "ArmGenericTimerPhyCounterLib",
	*guid.MustParse("3C0D77CC-4F27-49C8-B25C-2D01D81ED4D8"): "ArmGenericTimerVirtCounterLib",
	*guid.MustParse("CD67F41A-26E9-4482-90C9-A9AFF803382A"): "ArmGicArchLib",
	*guid.MustParse("C1DD9745-9459-4E9A-9F5B-99CBD233C27D"): "ArmGicArchSecLib",
	*guid.MustParse("DE371F7C-DEC4-4D21-ADF1-593ABCC15882"): "ArmGicDxe",
	*guid.MustParse("03D05EE4-CDEB-458C-9DFC-993F09BDF405"): "ArmGicLib",
	*guid.MustParse("E594959A-D150-44D3-963B-BA90329D3D9A"): "ArmHvcLib",
	*guid.MustParse("E724AAF7-19E2-40A3-BAE1-D82A7C8B7A76"): "ArmMaliDp",
	*guid.MustParse("55DDB6E0-70B5-11E0-B33E-0002A5D5C51B"): "ArmMemoryInitPeiLib",
	*guid.MustParse("09EE81D3-F15E-43F4-85B4-CB9873DA5D6B"): "ArmMmCommunication",
	*guid.MustParse("DA8F0232-FB14-42F0-922C-63104D2C70BD"): "ArmMmuBaseLib/ArmMmuBaseLib/ArmMmuStandaloneMmCoreLib/ArmMmuBaseLib/ArmMmuStandaloneMmCoreLib",
	*guid.MustParse("B50D8D53-1AD1-44EA-9E69-8C89D4A6D08B"): "ArmMmuPeiLib",
	*guid.MustParse("05810525-FDEC-4006-9F1F-37609B3675FA"): "ArmMtlNullLib",
	*guid.MustParse("168D1A6E-F4A5-448A-9E95-795661BB3067"): "ArmPciCpuIo2Dxe",
	*guid.MustParse("CB494BAD-23FF-427E-8608-D7E138D3363B"): "ArmPlatformLibNull",
	*guid.MustParse("49D37060-70B5-11E0-AA2D-0002A5D5C51B"): "ArmPlatformPeiLib",
	*guid.MustParse("469FC080-AEC1-11DF-927C-0002A5D5C51B"): "ArmPlatformPrePeiCore",
	*guid.MustParse("D959E387-7B91-452C-90E0-A1DBAC90DDB8"): "ArmPlatformPrePiMPCore/ArmPlatformPrePiMPCore/ArmPlatformPrePiUniCore/ArmPlatformPrePiMPCore/ArmPlatformPrePiUniCore",
	*guid.MustParse("5E2E44AF-53C1-44C2-A801-9C149F3D6BA0"): "ArmPlatformStackLib",
	*guid.MustParse("A8F59B69-A105-41C7-8F5A-2C60DD7FD7AA"): "ArmPsciResetSystemLib",
	*guid.MustParse("62AA447A-1FBA-429E-9E0D-CE0D2D8DCF58"): "ArmRelocateExceptionLib",
	*guid.MustParse("9585984C-F027-45E9-AFDF-ADAA6DFAAAC7"): "ArmScmiDxe",
	*guid.MustParse("EB3F17D5-A3CC-4EAC-8912-84162D0F79DA"): "ArmSmcLib",
	*guid.MustParse("140E8004-16E1-4DE1-A352-C6EF51110ECF"): "ArmSmcLibNull",
	*guid.MustParse("18B12C83-7718-4D83-ADA4-87F2FE698DD4"): "ArmSmcPsciResetSystemLib",
	*guid.MustParse("A485F921-749E-41A0-9F91-62F09A38721C"): "ArmSoftFloatLib",
	*guid.MustParse("8E3618D7-F01D-4D65-B32B-4C70AACC8E49"): "ArmSvcLib",
	*guid.MustParse("49EA041E-6752-42CA-B0B1-7344FE2546B7"): "ArmTimerDxe",
	*guid.MustParse("93E34C7E-B50E-11DF-9223-2443DFD72085"): "ArmVeNorFlashDxe",
	*guid.MustParse("3CD90EEC-EBF3-425D-AAE8-B16215AC4F50"): "ArmVirtDxeHobLib",
	*guid.MustParse("87B0DC84-4661-4DEB-A789-97977FF636ED"): "ArmVirtGicArchLib",
	*guid.MustParse("021B6156-3CC8-4E99-85EE-13D8A871EDF2"): "ArmVirtMemoryInitPeiLib",
	*guid.MustParse("13173319-B270-4669-8592-3BB2B31E9E29"): "ArmVirtPL031FdtClientLib",
	*guid.MustParse("F7D9FD14-9335-4389-80C5-334D6ABFCCED"): "ArmVirtPrePiUniCoreRelocatable",
	*guid.MustParse("C81D76ED-66FA-44A3-AC4A-F163120187A9"): "ArmVirtPsciResetSystemLib",
	*guid.MustParse("551CFB98-C185-41A3-86BF-8CDB7E2A530C"): "ArmVirtPsciResetSystemPeiLib",
	*guid.MustParse("77EA80CA-2EFB-4AB4-8567-230D968F6B37"): "ArmVirtTimerFdtClientLib",
	*guid.MustParse("529D3F93-E8E9-4E73-B1E1-BDF6A9D50113"): "ArpDxe",
	*guid.MustParse("5E523CB4-D397-4986-87BD-A6DD8B22F455"): "AtaAtapiPassThruDxe",
	*guid.MustParse("19DF145A-B1D4-453F-8507-38816676D7F6"): "AtaBusDxe",
	*guid.MustParse("E49061CE-99A7-41D3-AB3A-36E5CFBAD63E"): "AtapiPassThruDxe",
	*guid.MustParse("B23CF5FB-6FCC-4422-B145-D855DBC05457"): "AuthVariableLib",
	*guid.MustParse("435CB0E4-7C9A-4BB7-9907-8FD4643E978A"): "AuthVariableLibNull",
	*guid.MustParse("2D6F6BCC-9681-8E42-8579-B57DCD0060F0"): "AutoScanPei",
	*guid.MustParse("B15239D6-6A01-4808-A0F7-B7F20F073555"): "Ax88772",
	*guid.MustParse("95C8D770-E1A4-4422-B263-E32F14FD8186"): "Ax88772b",
	*guid.MustParse("FB648CF5-91BE-4737-9023-FD807AC6D96D"): "BaseAcpiTimerLib",
	*guid.MustParse("564DE85F-049E-4481-BF7A-CA04D2788CF9"): "BaseAcpiTimerLib",
	*guid.MustParse("A5E3B247-7302-11EA-9C04-3CECEF0C1C08"): "BaseAcpiTimerLibBhyve",
	*guid.MustParse("CF5F650B-C208-409A-B889-0755172E2B0C"): "BaseBmpSupportLib",
	*guid.MustParse("FBB4A01B-947E-4D82-B27D-1E207C070053"): "BaseCacheAsRamLibNull",
	*guid.MustParse("630AEB10-2106-4234-9DB3-836A3663F50D"): "BaseCacheAsRamLibNull",
	*guid.MustParse("01359D99-9446-456D-ADA4-50A711C03ADB"): "BaseCacheLib",
	*guid.MustParse("8EF3A653-DA8B-4FFA-BB85-FF47406DB9F0"): "BaseCacheLib",
	*guid.MustParse("123DD843-57C9-4158-8418-CE68B3944CE7"): "BaseCacheMaintenanceLib",
	*guid.MustParse("13F13249-AC31-4373-8B2B-AFC5755A6FCD"): "BaseCacheMaintenanceLibNull",
	*guid.MustParse("3F3FFD80-04DC-4A2B-9D25-ECCA55C2E520"): "BaseCachingPciExpressLib",
	*guid.MustParse("4FBD2538-249C-4B50-8F4A-A9E66609CBF6"): "BaseCpuLib",
	*guid.MustParse("8A29AAA5-0FB7-44CC-8709-1344FE89B878"): "BaseCpuLibNull",
	*guid.MustParse("F10B5B91-D15A-496C-B044-B5235721AA08"): "BaseCpuTimerLib",
	*guid.MustParse("BE3BB803-91B6-4DA0-BD91-A8B21C18CA5D"): "BaseCryptLib",
	*guid.MustParse("BA4B5BA1-0EA1-415A-896C-6CAAF32146F3"): "BaseCryptLibNull",
	*guid.MustParse("455D16DC-E3AF-4B5F-A9AD-A4BC198085BD"): "BaseDebugDeviceLibNull",
	*guid.MustParse("5E975522-176F-4E2D-BB25-64ADCC7792A4"): "BaseDebugDeviceLibNull",
	*guid.MustParse("9BA1D976-0624-41A3-8650-28165E8D9AE8"): "BaseDebugLibNull",
	*guid.MustParse("BB83F95F-EDBC-4884-A520-CD42AF388FAE"): "BaseDebugLibSerialPort",
	*guid.MustParse("A2C09E18-E4D2-407E-AFCC-628B79113F72"): "BaseDebugPrintErrorLevelLib",
	*guid.MustParse("4E3236E9-D1C8-4C04-A89F-26F1C44B2592"): "BaseExtractGuidedSectionLib",
	*guid.MustParse("6E4CB8C5-6144-4AE3-BA52-B6AFBCB2B2F5"): "BaseFspApiLib",
	*guid.MustParse("54607F66-D728-448E-A282-49E0404A557F"): "BaseFspCommonLib",
	*guid.MustParse("38BE57E8-902C-485A-AB5E-D5AEC613194D"): "BaseFspCommonLib",
	*guid.MustParse("CEA4FF9C-D7BC-4F07-96F1-03F41F2B17AE"): "BaseFspDebugLibSerialPort",
	*guid.MustParse("9D52E46E-F07E-44E8-9A90-F8576C91C211"): "BaseFspDebugLibSerialPort",
	*guid.MustParse("24C6F3E2-6ACD-436B-A604-56A5CF742A55"): "BaseFspPlatformInfoLibSample",
	*guid.MustParse("B6380BFB-7140-4C52-AC42-8C966C9A3F34"): "BaseFspPlatformLib",
	*guid.MustParse("7DECCDAF-361F-4EC1-9714-260BAAF6F384"): "BaseFspPlatformLib",
	*guid.MustParse("C128CADC-623E-4E41-97CB-A7138E627460"): "BaseFspSecPlatformLibNull",
	*guid.MustParse("03DA99B3-DDF4-4C7E-8CCA-216FC3F1F311"): "BaseFspSecPlatformLibNull",
	*guid.MustParse("8A5EA987-27F9-4AD0-B07C-D61882BFF4FF"): "BaseFspSwitchStackLib",
	*guid.MustParse("68E79161-F7CE-4A61-8C72-F4DF6FF35CAA"): "BaseFspSwitchStackLib",
	*guid.MustParse("F42C789F-4D66-49AF-8C73-1AADC00437AC"): "BaseFspWrapperApiLib",
	*guid.MustParse("E7E96F88-017B-417C-8DC8-B84C2B877020"): "BaseFspWrapperApiTestLibNull",
	*guid.MustParse("12F38E73-B34D-4559-99E5-AE2DCD002156"): "BaseFspWrapperPlatformLibSample",
	*guid.MustParse("B1E566DD-DE7C-4F04-BDA0-B1295D3BE927"): "BaseHashApiLib",
	*guid.MustParse("A89DEA6F-C9A0-40BE-903C-7CAC2EF8A0E7"): "BaseHobLibNull",
	*guid.MustParse("63850097-3E97-4C4F-A52D-C811A0106105"): "BaseIntrinsicLib",
	*guid.MustParse("58ED6E5A-E36A-462A-9ED6-6E62C9A26DF8"): "BaseIoApicLib",
	*guid.MustParse("926C9CD0-4BB8-479B-9AC4-8A2A23F85307"): "BaseIoLibIntrinsic",
	*guid.MustParse("217102B4-B465-4A1D-A2DE-93DD385EC480"): "BaseIoLibIntrinsicArmVirt",
	*guid.MustParse("93742F95-6E71-4581-B600-8E1DA443F95A"): "BaseIoLibIntrinsicSev",
	*guid.MustParse("46805D61-0BB8-4680-A9BE-C96C751AB5A4"): "BaseIpmiLibNull",
	*guid.MustParse("27D67720-EA68-48AE-93DA-A3A074C90E30"): "BaseLib",
	*guid.MustParse("1D005F4C-4DFA-41B5-AB0C-BE91FE121459"): "BaseLibUnitTestsHost",
	*guid.MustParse("DF5A6FED-8786-4A9D-9D02-EAB39497B4A1"): "BaseLibUnitTestsUefi",
	*guid.MustParse("FD56F5D6-F194-448F-BE69-C0CBB0C281AF"): "BaseMemoryAllocationLibNull",
	*guid.MustParse("FD44E603-002A-4B29-9F5F-529E815B6165"): "BaseMemoryLib",
	*guid.MustParse("D458A654-F64C-49DB-B8D1-3821306BF1F6"): "BaseMemoryLibMmx",
	*guid.MustParse("02BD55C2-AB1D-4B75-B0FD-9A63AE09B31D"): "BaseMemoryLibOptDxe",
	*guid.MustParse("D6F43B1B-0F21-462B-B8B7-A033C3EB4261"): "BaseMemoryLibOptPei",
	*guid.MustParse("E7884BF4-51A1-485B-982A-FF89129983BC"): "BaseMemoryLibRepStr",
	*guid.MustParse("65A18235-5096-4032-8C63-214F0249CE8D"): "BaseMemoryLibSse2",
	*guid.MustParse("699F73C3-0058-484C-A9E5-61189276A985"): "BaseOrderedCollectionRedBlackTreeLib",
	*guid.MustParse("AF8FEF24-AFBB-472A-B8B7-13101A79703C"): "BasePL011UartClockLib",
	*guid.MustParse("40096A3A-5C2A-4FBC-AEF7-5475DD7AB334"): "BasePcdLibNull",
	*guid.MustParse("6957540D-F7B5-4D5B-BEE4-FC14114DCD3C"): "BasePciCapLib",
	*guid.MustParse("ED011855-AA31-43B9-ACC0-BF45A05C5985"): "BasePciCapPciSegmentLib",
	*guid.MustParse("472AB06D-9810-4C00-BB7F-DAD1828FC1AB"): "BasePciCf8Lib",
	*guid.MustParse("287E50F4-A188-4699-B907-3E4080CA5688"): "BasePciExpressLib",
	*guid.MustParse("28BDE99C-E8A7-4E3E-9A8A-E66CD64F31C6"): "BasePciLibCf8",
	*guid.MustParse("8987081E-DAEB-44A9-8BEF-A195B22D9417"): "BasePciLibPciExpress",
	*guid.MustParse("36B28584-C6AE-4B1B-A473-A51618EE525A"): "BasePciSegmentInfoLibNull",
	*guid.MustParse("AABF95D6-F40C-405F-8360-6A59794B8040"): "BasePciSegmentLibPci",
	*guid.MustParse("3427D883-E093-4CC9-BE85-6BD4058E96E2"): "BasePciSegmentLibSegmentInfo",
	*guid.MustParse("BE490364-73D2-420D-950E-F6450CA75DFB"): "BasePeCoffGetEntryPointLib",
	*guid.MustParse("556F5D10-7309-4AF4-B80A-8196BD60946F"): "BasePeCoffLib",
	*guid.MustParse("FC120ED3-40E1-46DC-8C9C-AAE3CA139ACF"): "BasePerformanceLibNull",
	*guid.MustParse("EBC3AEAD-CC13-49B0-A678-5BED93956955"): "BasePlatformHookLibNull",
	*guid.MustParse("19E3BBBA-BEB1-43E8-B32D-9ACBB22C7639"): "BasePostCodeLibDebug",
	*guid.MustParse("B6E9A733-EB75-41B6-B30C-009BCF3801C8"): "BasePostCodeLibPort80",
	*guid.MustParse("A86FBFCA-0183-4EEB-AA8A-762E3B7DA1F3"): "BasePrintLib",
	*guid.MustParse("EA7D2B69-D221-4950-9C2C-C38A65BCC96E"): "BaseQemuFwCfgS3LibNull",
	*guid.MustParse("1DE0B8C2-FFB6-4BDF-97F5-0FFB33979038"): "BaseReportStatusCodeLibNull",
	*guid.MustParse("5C71B08F-0ADE-4607-8B9D-946C2757FEE8"): "BaseResetSystemLibBhyve",
	*guid.MustParse("667A8B1C-9C97-4B2A-AE7E-568772FE45F3"): "BaseResetSystemLibNull",
	*guid.MustParse("626440D8-1971-41D9-9AB2-FB25F4AE79BC"): "BaseRngLib",
	*guid.MustParse("CD8991F8-2061-4084-8C9E-9C6F352DC58D"): "BaseRngLibNull",
	*guid.MustParse("74950C45-10FC-4AB5-B114-49C87C17409B"): "BaseRngLibTimerLib",
	*guid.MustParse("CDD9D74F-213E-4C28-98F7-8B4A167DB936"): "BaseRomAcpiTimerLib",
	*guid.MustParse("9A6DC1AC-94C0-43B1-8714-4C70FD58A815"): "BaseS3BootScriptLibNull",
	*guid.MustParse("B13F938E-47DF-4516-A397-8927A4E42B61"): "BaseS3IoLib",
	*guid.MustParse("F66B6BD2-513F-441D-B367-2D5BD4998A50"): "BaseS3PciLib",
	*guid.MustParse("17E2C90E-AD1F-443A-8C94-6E50C0E98607"): "BaseS3PciSegmentLib",
	*guid.MustParse("01190654-FED0-40D3-BA7F-2925539E5830"): "BaseS3SmbusLib",
	*guid.MustParse("498C6AC3-CC29-4821-BE6F-7C6F4ECF2C14"): "BaseS3StallLib",
	*guid.MustParse("4EA91BFA-3482-4930-B136-70679C6CE489"): "BaseSafeIntLib",
	*guid.MustParse("9E7C00CF-355A-4D4E-BF60-0428CFF95540"): "BaseSerialPortLib16550",
	*guid.MustParse("E2ECA273-A1C0-407E-9A5C-F10C55142196"): "BaseSmbusLibNull",
	*guid.MustParse("03F3331B-F12D-494F-BF37-E55A657F2497"): "BaseSortLib",
	*guid.MustParse("5F6579F7-B648-4FDB-9F19-4C17E27E8EFF"): "BaseStackCheckLib",
	*guid.MustParse("FC9990DF-C5FF-44CF-8799-CBB45B577F87"): "BaseSynchronizationLib",
	*guid.MustParse("F4731D79-537E-4505-BD52-C03F9B1F6B89"): "BaseTimerLibNullTemplate",
	*guid.MustParse("34C24FD7-7A90-45C2-89FD-946473D9CE98"): "BaseUefiCpuLib",
	*guid.MustParse("9AE5147D-B240-467F-A484-B024FDC42EE0"): "BaseUefiDecompressLib",
	*guid.MustParse("D774C4D9-C121-4DA3-A5E2-0F317E3C630C"): "BaseUefiTianoDecompressLib/BaseUefiTianoCustomDecompressLib/BaseUefiTianoCustomDecompressLib",
	*guid.MustParse("D87CA0A8-1AC2-439B-90F8-EF4A2AC88DAF"): "BaseXApicLib",
	*guid.MustParse("967B6E05-F10D-4C10-8BF7-365291CA143F"): "BaseXApicX2ApicLib",
	*guid.MustParse("FC5C7020-1A48-4198-9BE2-EAD5ABC8CF2F"): "BdsDxe",
	*guid.MustParse("6D33944A-EC75-4855-A54D-809C75241F6C"): "BdsDxe",
	*guid.MustParse("736343A0-1D96-11E0-AAAA-0002A5D5C51B"): "BeagleBoardLib",
	*guid.MustParse("E489DB0A-D847-4D67-910B-48A833F6FEF5"): "BeagleBoardMemoryInitPeiLib",
	*guid.MustParse("FEAA2E2B-53AC-4D5E-AE10-1EFD5DA4A2BA"): "BeagleBoardPciEmulation",
	*guid.MustParse("8A5DC3DE-FE31-4AD9-9C93-DD73626932E7"): "BeagleBoardPrePiUniCore",
	*guid.MustParse("781371A2-3FDD-41D4-96A1-7B34CBC9E895"): "BeagleBoardResetSystemLib",
	*guid.MustParse("97546CBD-C0FF-4C48-AB0B-E4F58862ACD3"): "BeagleBoardSerialPortLib",
	*guid.MustParse("6DDBF08B-CFC9-43CC-9E81-0784BA312CA0"): "BeagleBoardTimerDxe",
	*guid.MustParse("FE1D7183-9ABB-42CE-9A3B-36D7C6A8959F"): "BeagleBoardTimerLib",
	*guid.MustParse("FD982666-67F9-11E5-A42A-0025908602F6"): "BhyveFwCtlLib",
	*guid.MustParse("98546145-64F1-4D2E-814F-6BF963DB7930"): "BiosIdLib",
	*guid.MustParse("D0CAA91E-2DE4-4B0D-B3DC-09C67E854E34"): "BiosSnp16",
	*guid.MustParse("8669E6C9-842B-4B49-BCC3-32C96D244750"): "BiosVideoDxe",
	*guid.MustParse("4495E47E-42A9-4007-8C17-B6664F909D04"): "BlockIoDxe",
	*guid.MustParse("F7763316-8C04-41D8-A87D-45B73C13C43C"): "BltLibSample",
	*guid.MustParse("B8E62775-BB0A-43F0-A843-5BE8B14F8CCD"): "BootGraphicsResourceTableDxe",
	*guid.MustParse("85CDAFAD-13BE-422A-A8E5-55A249600DC3"): "BootLogoLib",
	*guid.MustParse("CA9E4824-4198-4715-AA22-E2935E703A07"): "BootMaintenanceManagerUiLib",
	*guid.MustParse("EEC25BDC-67F2-4D95-B1D5-F81B2039D11D"): "BootManagerMenuApp",
	*guid.MustParse("E622443C-284E-4B47-A984-FD66B482DAC0"): "BootManagerPolicyDxe",
	*guid.MustParse("CCB2DCE1-4FC8-41CB-88C5-D349E134C9FC"): "BootManagerUiLib",
	*guid.MustParse("B7611005-1F26-45BA-A3DB-01F39DDB2785"): "BootMode",
	*guid.MustParse("64196C76-58E3-0B4D-9484-B54F7C4349CA"): "BootModePei",
	*guid.MustParse("2B1D0832-2184-4C8F-A90D-8E4AF9DE5BCD"): "BootModePeim",
	*guid.MustParse("FA20568B-548B-4B2B-81EF-1BA08D4A3CEC"): "BootScriptExecutorDxe",
	*guid.MustParse("42BB673D-09F3-4E2E-9FEE-D081131DED5B"): "BootScriptSaveDxe",
	*guid.MustParse("69EC7DB2-B0DD-493A-963A-C5F330131BAA"): "BrotliDecompressLib",
	*guid.MustParse("E7A79769-DD6E-48F7-B90B-D4C510AC1741"): "BsdSocketLib",
	*guid.MustParse("4CEF31DA-8682-4274-9CC4-AEE7516A5E7B"): "CapsuleApp",
	*guid.MustParse("8ADEDF9E-2EC8-40FB-AE56-B76D90225D2D"): "CapsuleOnDiskLoadPei",
	*guid.MustParse("C779F6D8-7113-4AA1-9648-EB1633C7D53B"): "CapsulePei",
	*guid.MustParse("42857F0A-13F2-4B21-8A23-53D3F714B840"): "CapsuleRuntimeDxe",
	*guid.MustParse("86F67A12-2E32-44FC-8D6C-7901E2B5649A"): "CapsuleUpdatePolicyDxe",
	*guid.MustParse("8E36EC87-440D-44F9-AB2F-AA806C61A1A6"): "CapsuleUpdatePolicyLibNull",
	*guid.MustParse("0EA4C03F-D91B-4929-AAA5-B2FC8D69E2F4"): "CapsuleUpdatePolicyLibOnProtocol",
	*guid.MustParse("F7FDE4A6-294C-493C-B50F-9734553BB757"): "CapsuleX64",
	*guid.MustParse("49EDFC9E-5945-4386-9C0B-C9B60CD45BB1"): "CbParseLib",
	*guid.MustParse("B42AA265-00CA-4D4B-AC14-DBD5268E1BC7"): "CbPlatformSupportLib/PlatformSupportLib/PlatformSupportLib",
	*guid.MustParse("C68DAA4E-7AB5-41E8-A91D-5954421053F3"): "CbSupportDxe/BlSupportDxe/BlSupportDxe",
	*guid.MustParse("352C6AF8-315B-4BD6-B04F-31D4ED1EBE57"): "CbSupportPeim/BlSupportPeim/BlSupportPeim",
	*guid.MustParse("31E147A6-D39A-4147-9DA3-BEFD4D523243"): "CdExpressPei",
	*guid.MustParse("555F76EA-785F-40D7-9174-153C43636C68"): "CirrusLogic5430Dxe",
	*guid.MustParse("F1662152-3399-49AC-BE44-CAA97575FACE"): "CmockaLib",
	*guid.MustParse("0F2A0816-D319-4EE7-A6B8-D58524E4428F"): "CoherentDmaLib",
	*guid.MustParse("1019F54A-2560-41B2-87B0-6750B98F3EFF"): "CompatImageLoaderDxe",
	*guid.MustParse("855274FA-3575-4C20-9709-C031DC5589FA"): "CompilerIntrinsicsLib",
	*guid.MustParse("51CCF399-4FDF-4E55-A45B-E123F84D456A"): "ConPlatformDxe",
	*guid.MustParse("408EDCEC-CF6D-477C-A5A8-B4844E3DE281"): "ConSplitterDxe",
	*guid.MustParse("BBE2668C-0EFC-46FB-9137-4F2DA8F419F3"): "ConsolePrefDxe",
	*guid.MustParse("F3794B60-8985-11DB-8E53-0040D02B1835"): "Cpu",
	*guid.MustParse("EE993080-5197-4D4E-B63C-F1F7413E33CE"): "Cpu",
	*guid.MustParse("6D69F79F-9535-4893-9DD7-93929898252C"): "CpuCommonFeaturesLib",
	*guid.MustParse("1A1E4886-9517-440E-9FDE-3BE44CEE2136"): "CpuDxe",
	*guid.MustParse("3175E6B9-4B01-496A-9A2B-64AF02D87E34"): "CpuExceptionHandlerLibNull",
	*guid.MustParse("63EB1B62-10C9-4693-88AC-AE0999EA87F8"): "CpuFeaturesDxe",
	*guid.MustParse("183BB3E1-A1E5-4445-8AC9-0E83B6547E0E"): "CpuFeaturesPei",
	*guid.MustParse("84EEA114-C6BE-4445-8F90-51D97863E363"): "CpuHotplugSmm",
	*guid.MustParse("98546178-64F1-4D2E-814F-6BF963DB7930"): "CpuIA32Lib",
	*guid.MustParse("A19B1FE7-C1BC-49F8-875F-54A5D542443F"): "CpuIo2Dxe",
	*guid.MustParse("A47EE2D8-F60E-42FD-8E58-7BD65EE4C29B"): "CpuIo2Smm",
	*guid.MustParse("BAE7599F-3C6B-43B7-BDF0-9CE07AA91AA6"): "CpuIoDxe",
	*guid.MustParse("AE265864-CF5D-41A8-913D-71C155E76442"): "CpuIoPei",
	*guid.MustParse("EDADEB9D-DDBA-48BD-9D22-C1C169C8C5C6"): "CpuMpPei",
	*guid.MustParse("2FD8B7AD-F8FA-4021-9FC0-0AA572147CDC"): "CpuPei",
	*guid.MustParse("229B7EFD-DA02-46B9-93F4-E20C009F94E9"): "CpuS3DataDxe",
	*guid.MustParse("4D2E57EE-0E3F-44DD-93C4-D3B57E96945D"): "CpuS3DataDxe",
	*guid.MustParse("4AE7E1E8-9DFE-4E3E-85B4-A5F6ABD470FB"): "Cpuid",
	*guid.MustParse("FEA01457-E381-4135-9475-C6AFD0076C61"): "CryptoDxe",
	*guid.MustParse("0D1CE46B-72D9-4BA7-95DA-23511865E661"): "CryptoPei",
	*guid.MustParse("391B853F-F488-479B-A3D6-870766C7A38F"): "CryptoSmm",
	*guid.MustParse("1547B4F3-3E8A-4FEF-81C8-328ED647AB1A"): "Csm16",
	*guid.MustParse("04E03541-4663-417D-93F6-976378247D61"): "CsmSupportLib",
	*guid.MustParse("80B92017-EC64-4923-938D-94FAEE85832E"): "CustomizedDisplayLib",
	*guid.MustParse("53BCC14F-C24F-434C-B294-8ED2D4CC1860"): "DataHubDxe",
	*guid.MustParse("CA515306-00CE-4032-874E-11B755FF6866"): "DataHubStdErrDxe",
	*guid.MustParse("A85DCA1B-198F-4E14-A673-874264687E85"): "DataSink",
	*guid.MustParse("30EB0F26-FC0A-4FD2-B9C9-751EA2BB1980"): "DataSource",
	*guid.MustParse("863D214F-0920-437B-8CAD-88EA83A24E97"): "DatahubStatusCodeHandlerDxe",
	*guid.MustParse("9727502C-034E-472B-8E1B-67BB28C6CFDB"): "DebugAgentDxe",
	*guid.MustParse("4904B42F-9FC0-4C2E-BB3F-A2AB35123530"): "DebugAgentLibNull",
	*guid.MustParse("D9D114EF-F40B-4D48-AAA0-A3DC99C9F5BD"): "DebugAgentPei",
	*guid.MustParse("9055E2E0-9B33-11E0-A7D7-0002A5D5C51B"): "DebugAgentSymbolsBaseLib",
	*guid.MustParse("E82F99DE-74ED-4E56-BBA1-B143FCA3F69A"): "DebugAgentTimerLibNull",
	*guid.MustParse("02F04694-2C0A-4F1E-B0CE-64BE25890B03"): "DebugAgentTimerLibNull",
	*guid.MustParse("8CC435C5-6330-4269-B0C3-E3BD05C86FB8"): "DebugCommunicationLibSerialPort",
	*guid.MustParse("87438836-AD8D-4E3E-9249-895120A67240"): "DebugCommunicationLibUsb",
	*guid.MustParse("C41F8C82-B3E6-47E0-A61D-0F9E429E6996"): "DebugCommunicationLibUsb3Dxe",
	*guid.MustParse("106C877F-C2BA-4C46-876C-BDFE6171CD7E"): "DebugCommunicationLibUsb3Pei",
	*guid.MustParse("6A77CE89-C1B6-4A6B-9561-07D7127514A7"): "DebugLibPosix",
	*guid.MustParse("73E9457A-CEA1-4917-9A9C-9F1F0F0FD322"): "DebugPortDxe",
	*guid.MustParse("B73F81B9-1DFC-487C-824C-0509EE2B0128"): "DebugServicePei",
	*guid.MustParse("911D584C-35F7-4955-BEF9-B452769DDC3A"): "DebugSupportDxe",
	*guid.MustParse("C3E9448E-1726-42FB-9368-41F75B038C0C"): "DebugUnixPeCoffExtraActionLib",
	*guid.MustParse("EACDB354-DF1A-4AF9-A171-499737ED818F"): "DefaultExceptionHandlerLib",
	*guid.MustParse("6C633BB2-AE33-49AE-9F89-B5AA999FE3AE"): "DetectSmbiosVersionLib",
	*guid.MustParse("F6937495-1F44-4A8A-8A1B-5A669F9396F6"): "DevConsole",
	*guid.MustParse("0A1D4FD8-4704-4501-85EB-93399492CBED"): "DevShell",
	*guid.MustParse("D6A9928C-3397-4DD1-818F-C664BA6DCAAF"): "DevUtility",
	*guid.MustParse("75EBDC2E-5323-4F31-A41D-FD1A7A9FC65E"): "DeviceManagerUiLib",
	*guid.MustParse("9B680FCE-AD6B-4F3A-B60B-F59899003443"): "DevicePathDxe",
	*guid.MustParse("DCD1F939-1732-CA4D-81B7-C757AEC84DBC"): "DevicePathTextLib",
	*guid.MustParse("94734718-0BBC-47FB-96A5-EE7A5AE6A2AD"): "Dhcp4Dxe",
	*guid.MustParse("95E3669D-34BE-4775-A651-7EA41B69D89E"): "Dhcp6Dxe",
	*guid.MustParse("6B38F7B4-AD98-40E9-9093-ACA2B5A253C4"): "DiskIoDxe",
	*guid.MustParse("E660EA85-058E-4B55-A54B-F02F83A24707"): "DisplayEngine",
	*guid.MustParse("319E9E37-B2D6-4699-90F3-B8B72B6D4CBD"): "DisplayUpdateProgressLibGraphics",
	*guid.MustParse("CDEF83AE-1900-4B41-BF47-AAE9BD729CA5"): "DisplayUpdateProgressLibText",
	*guid.MustParse("B219E140-DFFC-11E3-B956-0022681E6906"): "DnsDxe",
	*guid.MustParse("A210F973-229D-4F4D-AA37-9895E6C9EABA"): "DpcDxe",
	*guid.MustParse("EBF8ED7C-0DD1-4787-84F1-F48D537DCACF"): "DriverHealthManagerDxe",
	*guid.MustParse("FE3542FE-C1D3-4EF8-657C-8048606FF671"): "DriverSample",
	*guid.MustParse("FC097B3C-2EBD-4A75-A3DA-121DCAB365CC"): "DtPlatformDxe",
	*guid.MustParse("31ADA2B2-62EA-4866-9B87-03FEA8425974"): "DumpDynPcd",
	*guid.MustParse("B549F005-4BD4-4020-A0CB-06F42BDA68C3"): "DwEmmcDxe",
	*guid.MustParse("52DECA02-2EE8-4EAA-8EAD-1AB83F8A5955"): "DxeAcpiTimerLib",
	*guid.MustParse("E624B98C-845A-4B94-9B50-B20475D552B9"): "DxeAcpiTimerLib",
	*guid.MustParse("534E35DE-8EB3-47B3-A4E0-72A571E50733"): "DxeCapsuleLib",
	*guid.MustParse("654950DF-1EDE-4B04-B144-6B77845736AD"): "DxeCapsuleLib",
	*guid.MustParse("4004DE5A-09A5-4F0C-94D7-82322E096AA7"): "DxeCapsuleLibNull",
	*guid.MustParse("D6A2CB7F-6A18-4E2F-B43B-9920A733700A"): "DxeCore",
	*guid.MustParse("D258D6AF-2FC0-4019-9C1F-1101C3DD19B5"): "DxeCoreEntryPoint",
	*guid.MustParse("882EE1A3-35B2-412C-B8A2-7A8D34A7C390"): "DxeCoreHobLib",
	*guid.MustParse("632F3FAC-1CA4-4725-BAA2-BDECCF9A111C"): "DxeCoreMemoryAllocationLib",
	*guid.MustParse("7ADD7147-74E8-4583-BE34-B6BC45353BB5"): "DxeCoreMemoryAllocationProfileLib",
	*guid.MustParse("D0F78BBF-0A30-4C63-8A48-0F618A4AFACD"): "DxeCorePerformanceLib",
	*guid.MustParse("B6E9835A-EDCF-4748-98A8-27D3C722E02D"): "DxeCpuExceptionHandlerLib",
	*guid.MustParse("F22CC0DA-E7DB-4E4D-ABE2-A608188233A2"): "DxeCpuTimerLib",
	*guid.MustParse("387A2490-81FC-4E7C-8E0A-3E58C30FCD0B"): "DxeCrc32GuidedSectionExtractLib",
	*guid.MustParse("B38CBDA6-8017-4111-8232-9E8328DE82F6"): "DxeCryptLib",
	*guid.MustParse("BA6BAD25-B814-4747-B0B0-0FBB61D40B90"): "DxeDebugAgentLib",
	*guid.MustParse("1D564EC9-9373-49A4-9E3F-E4D7B9974C84"): "DxeDebugPrintErrorLevelLib",
	*guid.MustParse("5E2FAE1F-41DA-4FBD-BC81-603CE5CD8497"): "DxeDeferImageLoadLib",
	*guid.MustParse("38897D86-FF36-4472-AE64-1DB9AE715C81"): "DxeDpcLib",
	*guid.MustParse("419A1910-70DA-4C99-8696-BA81A57BE508"): "DxeDtPlatformDtbLoaderLibDefault",
	*guid.MustParse("31479AFD-B06F-4E4A-863B-A8F7E7710778"): "DxeEmuLib",
	*guid.MustParse("68FCD487-D230-6846-95B1-5E1F2EF942C4"): "DxeEmuPeCoffExtraActionLib",
	*guid.MustParse("DF08A29A-F60B-E649-AA79-A1490E863A5D"): "DxeEmuSerialPortLib",
	*guid.MustParse("4EED5138-C512-9E4F-AB13-149B87D40453"): "DxeEmuStdErrSerialPortLib",
	*guid.MustParse("F773469B-E265-4B0C-B0A6-2F971FBFE72B"): "DxeExtractGuidedSectionLib",
	*guid.MustParse("6806C45F-13C4-4274-B8A3-055EF641A060"): "DxeFileExplorerProtocol",
	*guid.MustParse("F12B59C9-76D0-4661-AD7C-F04D1BEF0558"): "DxeHobLib",
	*guid.MustParse("671C6FD7-99FB-4EE3-B640-4B1D463BC3B5"): "DxeHobPeCoffLib",
	*guid.MustParse("7DE1C620-F587-4116-A36D-40F3467B9A0C"): "DxeHstiLib",
	*guid.MustParse("ABBAB4CD-EA88-45B9-8234-C8A7450531FC"): "DxeHttpLib",
	*guid.MustParse("EB92D1DE-7C36-4680-BB88-A67E96049F72"): "DxeImageAuthenticationStatusLib",
	*guid.MustParse("0CA970E1-43FA-4402-BC0A-81AF336BFFD6"): "DxeImageVerificationLib",
	*guid.MustParse("E94CD42A-3AAD-4EA0-9B09-945891C60CCD"): "DxeIoLibCpuIo",
	*guid.MustParse("33D33BF3-349E-4768-9459-836A9F7558FB"): "DxeIoLibCpuIo2",
	*guid.MustParse("A302F877-8625-425C-B1EC-7487B62C4FDA"): "DxeIpIoLib",
	*guid.MustParse("86D70125-BAA3-4296-A62F-602BEBBB9081"): "DxeIpl",
	*guid.MustParse("62408AD5-4EAC-432B-AB9B-C4B85BFAED02"): "DxeIpmiLibIpmiProtocol",
	*guid.MustParse("B88F7146-9834-4C55-BFAC-481CC0C33736"): "DxeMpInitLib",
	*guid.MustParse("DB6DCEF3-9F4E-4340-9351-FC35AA8A5888"): "DxeNetLib",
	*guid.MustParse("EF172A23-C7C5-47B7-B24E-D10DFE15540F"): "DxeNt32OemHookStatusCodeLib",
	*guid.MustParse("23AF9A54-3D7C-444D-8318-E9CF752DA349"): "DxeNt32PeCoffExtraActionLib",
	*guid.MustParse("AF97EB89-4CC6-45F8-A514-CA025B346480"): "DxePcdLib",
	*guid.MustParse("5360BFF6-3911-4495-AE3C-B02FF004B585"): "DxePciLibI440FxQ35",
	*guid.MustParse("8B8B4CCC-65FC-41A5-8067-308B8E42CCF2"): "DxePerformanceLib",
	*guid.MustParse("DAA55048-BC3F-4DD9-999B-F58ABF2BBFCC"): "DxePlatform",
	*guid.MustParse("02805010-2591-4ED3-827B-A218F34AE0D7"): "DxePlatformHelperLib",
	*guid.MustParse("55D460DB-8FEA-415A-B95D-70145AE0675C"): "DxePrintLibPrint2Protocol",
	*guid.MustParse("C5DE76EB-E8DE-4057-A487-C5A09AB039AB"): "DxeQemuFwCfgS3LibFwCfg",
	*guid.MustParse("ADE8F745-AA2E-49F6-8ED4-746B34867E52"): "DxeRegisterCpuFeaturesLib",
	*guid.MustParse("3DDC3B12-99EA-4364-B315-6310A2050BE5"): "DxeReportStatusCodeLib",
	*guid.MustParse("EBF144C8-70F5-4E09-ADE2-F41F5C59AFDA"): "DxeReportStatusCodeLib",
	*guid.MustParse("C2BDE4F6-65EE-440B-87B5-83ABF10EF45B"): "DxeResetSystemLib",
	*guid.MustParse("BC7835EA-4094-41FE-B770-BAD9E6C479B2"): "DxeResetSystemLib",
	*guid.MustParse("83E35653-B943-4C5F-BA08-9B2996AE9273"): "DxeResetSystemLibUnitTestHost",
	*guid.MustParse("FF9F84C5-A33E-44E3-9BB5-0D654B2D4149"): "DxeRngLib",
	*guid.MustParse("0AD6C423-4732-4CF3-9CE3-0A5416D634A5"): "DxeRsa2048Sha256GuidedSectionExtractLib",
	*guid.MustParse("19BE1E4B-1A9A-44C1-8F12-32DD0470516A"): "DxeRuntimeCapsuleLib",
	*guid.MustParse("9D914E2F-7CCB-41DB-8E74-9AFF8F3BBFBF"): "DxeRuntimeDebugLibSerialPort",
	*guid.MustParse("54DCBCE5-92AD-41F5-AAAF-1170F16DA6A8"): "DxeRuntimePciExpressLib",
	*guid.MustParse("F73EB3DE-F4E3-47CB-9F18-97796AE06314"): "DxeRuntimePciSegmentLibSegmentInfo",
	*guid.MustParse("57F9967B-26CD-4262-837A-55B8AA158254"): "DxeS3BootScriptLib",
	*guid.MustParse("7F61122C-19DF-47C3-BA0D-6C1149E30FA1"): "DxeSecurityManagementLib",
	*guid.MustParse("9515F92A-83AE-45FD-9D2E-E3DC15DF52D0"): "DxeSerializeVariablesLib",
	*guid.MustParse("EE680C58-FFC0-4A5D-858F-66FF9C84BC9F"): "DxeServicesLib",
	*guid.MustParse("BAA1BAA3-0A8D-402C-8042-985115FAE953"): "DxeServicesTableLib",
	*guid.MustParse("AF55A9B6-2AE6-4B08-8CF7-750B7CBF49D7"): "DxeSmbiosDataHobLib",
	*guid.MustParse("4F369FB1-31A7-423C-960E-B3EFD337894F"): "DxeSmbusLib",
	*guid.MustParse("79C5C7B7-1083-42A6-AD15-2A4E7C4274D7"): "DxeSmmDriverEntryPoint",
	*guid.MustParse("7E507A86-DE8B-4AD3-BC4C-0498389098D3"): "DxeTcg2PhysicalPresenceLib",
	*guid.MustParse("2A6BA243-DC22-42D8-9C3D-AE3728DC7AFA"): "DxeTcg2PhysicalPresenceLibNull",
	*guid.MustParse("EBC43A46-34AC-4F07-A7F5-A5394619361C"): "DxeTcgPhysicalPresenceLib",
	*guid.MustParse("D4608509-1AB0-4CC7-827A-AB8E1E7BD3E6"): "DxeTcpIoLib",
	*guid.MustParse("778CE4F4-36BD-4AE7-B8F0-10B420B0D174"): "DxeTpm2MeasureBootLib",
	*guid.MustParse("6C60C7D0-922A-4B7C-87D7-E503EDD73BBF"): "DxeTpmMeasureBootLib",
	*guid.MustParse("30930D10-AF5B-4ABF-80E6-EB4FFC0AE9D1"): "DxeTpmMeasurementLib",
	*guid.MustParse("7E615AA1-41EE-49D4-B7E9-1D7A60AA5C8D"): "DxeUpdIoLib",
	*guid.MustParse("F6B5871D-5226-41B3-A569-3FF893FDC7BC"): "DxeWinNtLib",
	*guid.MustParse("23A6AFDA-F2A5-45EC-BEFF-420639D345B9"): "DynamicAmlLib",
	*guid.MustParse("AC5978CC-5B62-4466-AD04-23644C2C38C2"): "DynamicSsdtSerialPortFixupLib",
	*guid.MustParse("FE846898-7403-4932-B8AD-A0491F0C2CBA"): "DynamicTableFactoryDxe",
	*guid.MustParse("E315C738-3A39-4D0D-A0AF-8EDFA770AB39"): "DynamicTableHelperLib",
	*guid.MustParse("89122868-BCFD-49E8-88A3-06635CB7B3CF"): "DynamicTableManagerDxe",
	*guid.MustParse("0983616A-49BC-4732-B531-4AF98D2056F0"): "EarlyFdtPL011SerialPortLib",
	*guid.MustParse("8296AF37-D183-4416-B3B6-19D2A80AD4A8"): "EbcDebugger",
	*guid.MustParse("13AC6DD0-73D0-11D4-B06B-00AA00BD6DE7"): "EbcDxe",
	*guid.MustParse("8CFC5233-23C6-49E3-8A2D-7E581AB305BA"): "EdbCfg",
	*guid.MustParse("434B164E-5FA6-4A3D-BC04-02DA2A4EEB26"): "EdkNt32PeiPeCoffGetEntryPointLib",
	*guid.MustParse("109D5FC6-56E6-481A-88EF-0CB828FBE0F6"): "EdkiiSystemCapsuleLib",
	*guid.MustParse("C33E0B7C-9D0F-41DF-BDFD-08F5E4C39EE8"): "EfiSocketLib",
	*guid.MustParse("BDFE430E-8F2A-4DB0-9991-6F856594777E"): "EhciDxe",
	*guid.MustParse("BAB4F20F-0981-4B5F-A047-6EF83BEEAB3C"): "EhciPei",
	*guid.MustParse("FCABE6A7-7953-4A84-B7EC-D29E89B62E87"): "EmbeddedMonotonicCounter",
	*guid.MustParse("7F06A90F-AE0D-4887-82C0-FEC7F4F68B29"): "EmmcBlockIoPei",
	*guid.MustParse("2145F72F-E6F1-4440-A828-59DC9AAB5F89"): "EmmcDxe",
	*guid.MustParse("8F7D7B1D-0E1C-4C98-B12E-4EC99C4081AC"): "EmptyApplication",
	*guid.MustParse("C6760651-A38D-5F4F-AEAF-F6661549DF75"): "EmuBlockIo",
	*guid.MustParse("9842073D-95D9-9F49-BD3F-2E29525125DF"): "EmuBusDriver",
	*guid.MustParse("FB184AF4-A2F2-EE4E-8885-E81E5D8B0135"): "EmuDxeCodeTimerLib",
	*guid.MustParse("74B62391-AD0D-1B4D-8784-151404F9D538"): "EmuDxeTimerLib",
	*guid.MustParse("1B290126-5760-424E-8AA2-3FAF4D0D7978"): "EmuGopDxe",
	*guid.MustParse("BCC87E0D-86D6-4D4D-8040-2D983D368BD1"): "EmuGopDxe",
	*guid.MustParse("6ABE5FDC-AE4B-474E-8E52-9546C96AE536"): "EmuPeiTimerLib",
	*guid.MustParse("50A18017-37AD-8743-BCF2-DF1A8FF12FAB"): "EmuReset",
	*guid.MustParse("BCAF98C9-22B0-3B4F-9CBD-C8A6B4DBCEE9"): "EmuSec",
	*guid.MustParse("35B72237-3926-CF4A-A7F3-1449F9E0E4BD"): "EmuSimpleFileSystem",
	*guid.MustParse("22597239-6107-DF44-AD3F-5F053E92222E"): "EmuSnpDxe",
	*guid.MustParse("2F62A818-4A72-CD40-90B9-FF00DAABEE7B"): "EmuThunk",
	*guid.MustParse("87E1BB14-4D5C-7C4E-A90E-E1415687D062"): "EmuTimer",
	*guid.MustParse("8A6062ED-7140-4A74-B4EA-FE900E79E24B"): "EmuVariableFvbLib",
	*guid.MustParse("22DC2B60-FE40-42AC-B01F-3AB1FAD9AAD8"): "EmuVariableFvbRuntimeDxe",
	*guid.MustParse("E9A22529-44FA-3E4A-A66B-1E918E7AB26A"): "EmulatorPkgPeiCoreServicesTablePointerLib",
	*guid.MustParse("7488FC06-370A-1C41-B05C-7395559A535A"): "EmulatorPkgPeiServicesTablePointerLib",
	*guid.MustParse("5FD8B4ED-D66F-C144-9953-AC557C649925"): "EmulatorPkgPeiServicesTablePointerLib",
	*guid.MustParse("CD3BAFB6-50FB-4FE8-8E4E-AB74D2C1A600"): "EnglishDxe",
	*guid.MustParse("42F58B27-5DC3-4FA7-844D-5A7DBFF06432"): "Enquire",
	*guid.MustParse("A0BAA8A3-041D-48A8-BC87-C36D121B5E3D"): "EnrollDefaultKeys",
	*guid.MustParse("999BD818-7DF7-4A9A-A502-9B75033E6A0F"): "EsrtDxe",
	*guid.MustParse("FF626DA9-17EE-4949-A8B8-B10FA0044E9F"): "EsrtFmpDxe",
	*guid.MustParse("F6BEC3FE-88FB-11E3-AE84-E73B77561C35"): "FastbootTransportUsbDxe",
	*guid.MustParse("961578FE-B6B7-44C3-AF35-6BC705CD2B1F"): "Fat",
	*guid.MustParse("5B60CCFD-1011-4BCF-B7D1-BB99CA96A603"): "FatPei",
	*guid.MustParse("FE5CEA76-4F72-49E8-986F-2CD899DFFE5D"): "FaultTolerantWriteDxe",
	*guid.MustParse("AAC33064-9ED0-4B89-A5AD-3EA767960B22"): "FaultTolerantWritePei",
	*guid.MustParse("98948C4A-70F2-4035-8E9F-5927493CFC07"): "FaultTolerantWriteSmmDxe",
	*guid.MustParse("3AADE4EC-63CC-4A48-A928-5A374DD463EB"): "FaultTolerantWriteStandaloneMm",
	*guid.MustParse("0B04B2ED-861C-42CD-A22F-C3AAFACCB896"): "FbGop/GraphicsOutputDxe/GraphicsOutputDxe",
	*guid.MustParse("9A871B00-1C16-4F61-8D2C-93B6654B5AD6"): "FdtClientDxe",
	*guid.MustParse("6B2478C0-BE23-11E0-A28C-0002A5D5C51B"): "FdtLib",
	*guid.MustParse("CB768406-7DE6-49B6-BC2C-F324E110DE5A"): "FdtPL011SerialPortLib",
	*guid.MustParse("59FCB139-2558-4CF0-8D7C-EBAC499DA727"): "FdtPciHostBridgeLib",
	*guid.MustParse("D584275B-BF1E-4DF8-A53D-980F5645C5E7"): "FdtPciPcdProducerLib",
	*guid.MustParse("405DA936-3737-4C0C-8E3F-E6172A568592"): "FileExplorerDxe",
	*guid.MustParse("4FC9C630-0F90-4053-8F13-264CBD22FC58"): "FileExplorerLib",
	*guid.MustParse("00160F8D-2B35-4DF2-BBE0-B272A8D631F0"): "FirmwarePerformanceDxe",
	*guid.MustParse("ADF01BF6-47D6-495D-B95B-687777807214"): "FirmwarePerformancePei",
	*guid.MustParse("044310AB-77FD-402A-AF1A-87D4120E7329"): "FirmwarePerformanceSmm",
	*guid.MustParse("AEFAF26C-FB6D-4FEF-AF7A-9D78FF201FCA"): "FirmwareUpdate",
	*guid.MustParse("6DB075DE-449E-2644-96D0-CC5A1B4C3B2A"): "FirmwareVolumePei",
	*guid.MustParse("E38A1C3C-928C-4BF7-B6C1-7F0EF163FAA5"): "FlashDeviceLib",
	*guid.MustParse("F0D7222F-FD43-4A5D-B8BF-A259C87AE3B2"): "FlashDeviceLibDxe",
	*guid.MustParse("C9FAF091-57F8-A64C-A07A-445B124F0D93"): "FlashMapPei",
	*guid.MustParse("5011522C-7B0E-4ACB-8E30-9B1D133CF2E0"): "FmpAuthenticationLibNull",
	*guid.MustParse("F4EA205B-7345-452C-9D62-53BA6F3B8910"): "FmpAuthenticationLibPkcs7",
	*guid.MustParse("105FF0EA-A0C0-48A8-B8F7-E8B4D62A1019"): "FmpAuthenticationLibRsa2048Sha256",
	*guid.MustParse("8296D425-3095-4CFE-88D8-B0A44DB174A8"): "FmpDependencyCheckLib",
	*guid.MustParse("D63F3166-9CBC-4AC2-8F23-8818E42EA2BD"): "FmpDependencyCheckLibNull",
	*guid.MustParse("05BE67B1-0748-4022-97E6-7C0D2F992AA6"): "FmpDependencyDeviceLibNull",
	*guid.MustParse("67F55EA4-B4CF-4A08-931B-0BBCF1E0F7A3"): "FmpDependencyLib",
	*guid.MustParse("CE32C647-CAD7-4099-9463-653B932C1691"): "FmpDependencyLibUnitTestsHost",
	*guid.MustParse("8FF4C129-C2EF-445D-8658-9A342A1FCC4D"): "FmpDependencyLibUnitTestsUefi",
	*guid.MustParse("8507642B-AE92-4664-B713-807F7774A96D"): "FmpDeviceLibNull",
	*guid.MustParse("78EF0A56-1CF0-4535-B5DA-F6FD2F405A11"): "FmpDxe",
	*guid.MustParse("4B11717A-30B3-4122-8C69-8E0D5E141C32"): "FmpDxeLib",
	*guid.MustParse("98A79A6C-513C-4E72-8375-39C0A7244C4B"): "FmpPayloadHeaderLibV1",
	*guid.MustParse("3A61FD45-69A0-42AD-B261-24DA451BF442"): "ForceRecovery",
	*guid.MustParse("243D3E8C-2780-4A25-9693-A410475BFCEC"): "FrameBufferBltLib",
	*guid.MustParse("2A40F516-C852-4BAA-B7A8-0E9EA090D659"): "FrameBufferBltLib",
	*guid.MustParse("B2F0D71A-A39F-4094-854B-0C6BA6910CCE"): "FrameworkUefiLib",
	*guid.MustParse("DF0FCD70-264A-40BF-BBD4-06C76DB19CB1"): "Fsp22SecCoreS",
	*guid.MustParse("98C8588C-640A-4BB4-AEA0-3F81CDE17524"): "FspDxeIpl",
	*guid.MustParse("BC59E2E1-7492-4031-806E-C48DCCC3A026"): "FspInitPeim",
	*guid.MustParse("890B12B4-56CC-453E-B062-4597FC6D3D8C"): "FspMeasurementLib",
	*guid.MustParse("8714C537-6D4B-4247-AA6C-29E8495F9100"): "FspNotifyDxe",
	*guid.MustParse("29CBB005-C972-49F3-960F-292E2202CECD"): "FspNotifyPhasePeim",
	*guid.MustParse("1BA0062E-C779-4582-8566-336AE8F78F09"): "FspSecCore/ResetVector/XenResetVector/ResetVector/ResetVector/ResetVector/SecCore/ResetVector/XenResetVector/ResetVector/ResetVector/ResetVector/SecCore",
	*guid.MustParse("C2F9AE46-3437-4FEF-9CB1-9A568B282FEE"): "FspSecCoreM",
	*guid.MustParse("53AB1ACD-EDB1-4E3A-A2C7-978D721D179D"): "FspSecCoreS",
	*guid.MustParse("5B94E419-C795-414D-A0D4-B80A877BE5FE"): "FspSecCoreT",
	*guid.MustParse("AD61999A-507E-47E6-BA28-79CC609FA1A4"): "FspWrapperNotifyDxe",
	*guid.MustParse("9FAAD0FF-0E0C-4885-A738-BAB4E4FA1E66"): "FspmWrapperPeim",
	*guid.MustParse("0D244DF9-6CE3-4133-A1CF-53200AB663AC"): "FspsWrapperPeim",
	*guid.MustParse("A8154B55-2021-4D40-AE81-2E23A02DCC46"): "FtdiUsbSerialDxe",
	*guid.MustParse("64AAEAE0-92DF-4980-8668-6EB5EAAF4393"): "FvInfoPei",
	*guid.MustParse("C20085E9-E3AB-4938-A727-C10935FEEE2B"): "FvLib",
	*guid.MustParse("72405B40-38DA-4ABA-9283-CA8321C23E63"): "FvReportPei",
	*guid.MustParse("907125C0-A5F1-11E3-A3FE-A3198B49350C"): "FvSimpleFileSystem",
	*guid.MustParse("FD3B7E55-FA7B-4E07-AE1D-208B81FB0BAD"): "FvbRuntimeDxe",
	*guid.MustParse("BDFE5FAA-2A35-44BB-B17A-8084D4E2B9E9"): "FvbServicesRuntimeDxe",
	*guid.MustParse("733CBAC2-B23F-4B92-BC8E-FB01CE5907B7"): "FvbServicesRuntimeDxe",
	*guid.MustParse("2E7DB7A7-608E-4041-B45F-00359E0766C6"): "FvbServicesSmm",
	*guid.MustParse("A4EC8ADB-B7A8-47D1-8E52-EC820D0ACF6F"): "FvbSmm",
	*guid.MustParse("9E8AD3F4-383D-4EC3-816E-7A4749371290"): "FvbSmmDxe",
	*guid.MustParse("A01E498C-96E8-2A4C-95F4-85248F989753"): "FwBlockService",
	*guid.MustParse("4D35A5A7-622E-4955-A5D2-CDA812940D74"): "FwBlockService",
	*guid.MustParse("A469DDBD-16D0-4535-BAE3-77274BD70B4C"): "FwBlockServiceSmm",
	*guid.MustParse("233C2592-1CEC-494A-A097-15DC96379777"): "FwVolDxe",
	*guid.MustParse("42ABB10A-660A-4BEC-AEFA-CC94AB4D993D"): "GdbSerialDebugPortLib",
	*guid.MustParse("E2423349-EF5D-439B-95F5-8B8D8E3B443F"): "GdbSerialLib",
	*guid.MustParse("9999B4EE-081F-4501-AEDC-137A534BAF69"): "GdbSerialLib",
	*guid.MustParse("1F2CCB4F-D817-404E-98E7-80E4851FB33E"): "GdbStub",
	*guid.MustParse("E405EC31-CCAA-4DD4-83E8-0AEC01703F7E"): "GenericBdsLib",
	*guid.MustParse("9C1080EE-D02E-487F-9432-F3BF086EC180"): "GenericMemoryTestDxe",
	*guid.MustParse("9E3E28DA-C7B5-4F85-841A-84E6A9A1F1A0"): "GenericQemuLoadImageLib",
	*guid.MustParse("0619F5C2-4858-4CAA-A86A-73A21A18DF6B"): "GenericWatchdogDxe",
	*guid.MustParse("4C26DF71-EBE7-4DEA-B5E2-0B5980433908"): "GetAddrInfo",
	*guid.MustParse("C31A6189-639A-458B-B040-D7D506CA8F4F"): "GetHostByAddr",
	*guid.MustParse("3698D2B0-E727-4537-A636-A8770736ABFB"): "GetHostByDns",
	*guid.MustParse("70FB9CE0-2CB1-4FD7-80EE-AB4B6CF4B43F"): "GetHostByName",
	*guid.MustParse("553087F6-BAAC-4D7F-97B4-31D8179AAE15"): "GetNameInfo",
	*guid.MustParse("22198FD5-4835-4842-BF31-EB957C7DD70D"): "GetNetByAddr",
	*guid.MustParse("DAF7B0E6-32DE-4619-B63A-2B9173A75B14"): "GetNetByName",
	*guid.MustParse("5D1F3F9E-8CEE-4299-93C2-4C64EBB58977"): "GetServByName",
	*guid.MustParse("83381B06-2EEA-4CF3-9B5F-D75B9B5C93DE"): "GetServByPort",
	*guid.MustParse("B75B91F0-A0B4-42FE-BA62-849027999B39"): "GopBltLib",
	*guid.MustParse("E7D9CAE1-6930-46E3-BDF9-0027446E7DF2"): "Gpio",
	*guid.MustParse("CCCB0C28-4B24-11D5-9A5A-0090273FC14D"): "GraphicsConsoleDxe",
	*guid.MustParse("20830080-CC28-4169-9836-7F42B8D0C8C9"): "GraphicsOutputDxe",
	*guid.MustParse("DB290230-3EFA-064F-A317-E146925684FE"): "GuardUefiMemoryAllocationLib",
	*guid.MustParse("63E3BDCF-2AC7-4AC0-9B92-03A7541422FF"): "Hash2DxeCrypto",
	*guid.MustParse("9A7A6AB4-9DA6-4AA4-90CB-6D4B79EDA7B9"): "HashInstanceLibSha1",
	*guid.MustParse("5810798A-ED30-4080-8DD7-B9667A748C02"): "HashInstanceLibSha256",
	*guid.MustParse("74223710-17A9-478F-9B24-E354496B968B"): "HashInstanceLibSha384",
	*guid.MustParse("959C3685-AC3F-4F3E-AC5B-7E2A64BADD36"): "HashInstanceLibSha512",
	*guid.MustParse("C5865D5D-9ACE-39FB-DC7C-0511891D40F9"): "HashInstanceLibSm3",
	*guid.MustParse("158DC712-F15A-44DC-93BB-1675045BE066"): "HashLibBaseCryptoRouterDxe",
	*guid.MustParse("DDCBCFBA-8EEB-488A-96D6-097831A6E50B"): "HashLibBaseCryptoRouterPei",
	*guid.MustParse("1317F0D5-7842-475C-B1CA-6EDC20DCBE7D"): "HashLibTpm2",
	*guid.MustParse("CE660500-824D-11E0-AC72-0002A5D5C51B"): "HdLcd",
	*guid.MustParse("9BD549CD-86D1-4925-9F7D-3686DDD876FC"): "HddPasswordDxe",
	*guid.MustParse("91AD7375-8E8E-49D2-A343-68BC78273955"): "HddPasswordPei",
	*guid.MustParse("A912F198-7F0E-4803-B908-B757B806EC83"): "Hello",
	*guid.MustParse("6987936E-ED34-44DB-AE97-1FA5E4ED2116"): "HelloWorld",
	*guid.MustParse("63EA1463-FBFA-428A-B97F-E222755852D7"): "HighMemDxe",
	*guid.MustParse("348C4D62-BFBD-4882-9ECE-C80BB1C4783B"): "HiiDatabase",
	*guid.MustParse("D49D2EB0-44D5-4621-9FD6-1A92C9109B99"): "HiiResourcesSample",
	*guid.MustParse("CF56EF2C-68D8-4BD5-9A8B-8A7BFCFF751C"): "HobLib",
	*guid.MustParse("8262551B-AB2D-4E76-99FC-5EBB83F4988E"): "HobLib",
	*guid.MustParse("8863C0AD-7724-C84B-88E5-A33B116D1485"): "Host",
	*guid.MustParse("6CE6B0DE-781C-4F6C-B42D-98346C614BEC"): "HpetTimerDxe",
	*guid.MustParse("ECEBCB00-D9C8-11E4-AF3D-8CDCD426C973"): "HttpBootDxe",
	*guid.MustParse("2366C20F-E15A-11E3-8BF1-E4115B28BC50"): "HttpDxe",
	*guid.MustParse("22EA234F-E72A-11E4-91F9-28D2447C4829"): "HttpUtilitiesDxe",
	*guid.MustParse("7F62BF44-2BA7-4C2D-9D4A-91C8906FF053"): "I2CLib",
	*guid.MustParse("8EF61509-890B-4FF2-B352-1C0E9CDDEC8B"): "I2CLibPei",
	*guid.MustParse("0C34B372-2622-4A13-A46E-BFD0DEB48BFF"): "I2cBusDxe",
	*guid.MustParse("ECA2AE9E-7594-4901-871C-449DA1A11660"): "I2cDxe",
	*guid.MustParse("CDEC3671-816E-43DC-A002-DCD645229338"): "I2cHostDxe",
	*guid.MustParse("462D127A-C143-469E-8449-B6E36BEB04A8"): "I2cLib",
	*guid.MustParse("86CDDF93-4872-4597-8AF9-A35AE4D3725F"): "IScsiDxe",
	*guid.MustParse("69FD8E47-A161-4550-B01A-5594CEB2B2B2"): "IdeBusDxe",
	*guid.MustParse("B7A5041A-78BA-49E3-B73B-54C757811FB6"): "IdeBusPei",
	*guid.MustParse("99549F44-49BB-4820-B9D2-901329412D67"): "IdeController",
	*guid.MustParse("AD70855E-0CC5-4ABF-8979-BE762A949EA3"): "IncompatiblePciDeviceSupport",
	*guid.MustParse("F6697AC4-A776-4EE1-B643-1FEFF2B615BB"): "IncompatiblePciDeviceSupportDxe",
	*guid.MustParse("6E4CD200-43E5-43CE-89E9-D715CF9526C4"): "IniParsingLib",
	*guid.MustParse("0C0AC8C1-E368-4D20-85FE-23EFB3DB094E"): "IntelPchAcpiTimerLib",
	*guid.MustParse("F5B2EA6C-8148-4A4E-88EA-38A4A51F389F"): "IntelQNCLib",
	*guid.MustParse("987555D6-595D-4CFA-B895-59B89368BD4D"): "IntelVTdDxe",
	*guid.MustParse("F906769F-4AED-4A0D-8C7C-FF21B9D1051A"): "IntelVTdPmrPei",
	*guid.MustParse("8657015B-EA43-440D-949A-AF3BE365C0FC"): "IoMmuDxe",
	*guid.MustParse("3FE2A8A3-C400-48F8-832F-7881A394C250"): "IohInitDxe",
	*guid.MustParse("B4C12297-7B19-4523-B165-81374D96716B"): "IohLib",
	*guid.MustParse("9FB1A1F3-3B71-4324-B39A-745CBB015FFF"): "Ip4Dxe",
	*guid.MustParse("5BEDB5CC-D830-4EB2-8742-2D4CC9B54F2C"): "Ip6Dxe",
	*guid.MustParse("0922E604-F5EC-42EF-980D-A35E9A2B1844"): "IpSecConfig",
	*guid.MustParse("EE8367C0-A1D6-4565-8F89-EF628547B722"): "IpSecDxe",
	*guid.MustParse("38A0EC22-FBE7-4911-8BC1-176E0D6C1DBD"): "IsaAcpi",
	*guid.MustParse("DCBE6D66-D928-4138-8041-358F35CBCF80"): "IsaBusDxe",
	*guid.MustParse("240612B5-A063-11D4-9A3A-0090273FC14D"): "IsaBusDxe",
	*guid.MustParse("0ABD8284-6DA3-4616-971A-83A5148067BA"): "IsaFloppyDxe",
	*guid.MustParse("7F6E0A24-DBFD-43DF-9755-0292D7D3DD48"): "IsaFloppyPei",
	*guid.MustParse("61AD3083-DCAD-4850-A50C-73B23B3B14F9"): "IsaIoDxe",
	*guid.MustParse("93B80003-9FB3-11D4-9A3A-0090273FC14D"): "IsaSerialDxe",
	*guid.MustParse("72D78EA6-4DEE-11E3-8100-F3842A48D0A0"): "Isp1761PeriphDxe",
	*guid.MustParse("6B7067C7-A843-A34C-9530-48446963B740"): "KeyMapLibNull",
	*guid.MustParse("5479662B-6AE4-49E8-A6BD-6DE4B625811F"): "KeyboardDxe",
	*guid.MustParse("4356B162-D0B2-11E1-8952-4437E6A60EA5"): "Lan9118Dxe",
	*guid.MustParse("5C12EA2F-9897-48AF-8138-25F4CE6FF8D6"): "Lan91xDxe",
	*guid.MustParse("E68088EF-D1A4-4336-C1DB-4D3A204730A6"): "LcdGraphicsDxe",
	*guid.MustParse("89464DAE-8DAA-41FE-A4C8-40D2175AF1E9"): "LcdGraphicsOutputDxe",
	*guid.MustParse("BB1FDE98-1DE2-410E-8850-FDCB8E67EBC0"): "LcdHwNullLib",
	*guid.MustParse("B78D02BB-D0B5-4389-BC7F-B39EE846C784"): "LcdPlatformNullLib/LcdPlatformNullLib/ArmPlatformPrePeiCore/LcdPlatformNullLib/ArmPlatformPrePeiCore",
	*guid.MustParse("245CB4DA-8E15-4A1B-87E3-9878FFA07520"): "Legacy8259",
	*guid.MustParse("79CA4208-BBA1-4A9A-8456-E1E66A81484E"): "Legacy8259",
	*guid.MustParse("46482D14-7CA1-4977-9DDB-64D747E13DE6"): "LegacyBiosDxe",
	*guid.MustParse("F122A15C-C10B-4D54-8F48-60F4F06DD1AD"): "LegacyBiosDxe",
	*guid.MustParse("E6F7F038-3ED9-401A-AF1F-5EA7BF644D34"): "LegacyBootMaintUiLib",
	*guid.MustParse("259A90B1-C151-43E5-8A71-82B4E3201F4E"): "LegacyBootMaintUiLib",
	*guid.MustParse("D1BBB810-6A9E-40E0-87CB-65EAD2AA2A09"): "LegacyBootManagerLib",
	*guid.MustParse("F1B87BE4-0ACC-409A-A52B-7BFFABCC96A0"): "LegacyBootManagerLib",
	*guid.MustParse("07A9330A-F347-11D4-9A49-0090273FC14D"): "LegacyMetronome",
	*guid.MustParse("EC2BEECA-E84A-445B-869B-F7A73C96F58A"): "LegacyRegion2Dxe",
	*guid.MustParse("8C439043-85CA-467A-96F1-CB14F4D0DCDA"): "LegacyRegionDxe",
	*guid.MustParse("695BEC93-82AE-4C17-BDAD-7F184F4E651D"): "LibC",
	*guid.MustParse("92F7436E-7395-4DA1-A7BE-F352F0BCD79C"): "LibContainer",
	*guid.MustParse("DCC64575-FA7D-4B7B-B1AD-48427C97C74D"): "LibCtype",
	*guid.MustParse("FC1D4706-88FB-42B0-98B0-A4B2E607EBAA"): "LibErr",
	*guid.MustParse("5C98DE6E-CB69-465F-B6B9-F661E26E6F9D"): "LibGdtoa",
	*guid.MustParse("CA599759-90A7-4FE4-BC8B-4B71C350DCAC"): "LibGen",
	*guid.MustParse("1D57B5D5-BAB4-4D2B-B7EB-0EB41D7B189C"): "LibGlob",
	*guid.MustParse("C1E9FFFB-5557-4CB5-A5F5-1FBD902A74ED"): "LibIIO",
	*guid.MustParse("9205CDE5-5AE5-4A4B-BFBF-F6211967EEF9"): "LibLocale",
	*guid.MustParse("A9DC6F60-F861-47D1-8751-ECAAE7D27291"): "LibMath",
	*guid.MustParse("F3C9667B-C50C-4E9C-A1F1-78C3B1DDF2C2"): "LibNetUtil",
	*guid.MustParse("C516673C-6C71-4F0E-83B5-57FC662376EC"): "LibPosix",
	*guid.MustParse("00C86DB8-013B-4FF4-B8E9-208F4FCF1C00"): "LibSignal",
	*guid.MustParse("E9F4B929-EE33-4B70-8E90-17D283AF508C"): "LibSoftfloat",
	*guid.MustParse("F8A312F8-BCCC-479F-B49B-CE129568B06A"): "LibStdLib",
	*guid.MustParse("7D2BD134-500D-4F42-AEE2-26ACCFB6CB1D"): "LibStdio",
	*guid.MustParse("CAEE2F3B-3191-4DA0-AD10-A5C07E636CD1"): "LibString",
	*guid.MustParse("19D17940-BA8D-4FA7-A704-F33D9FAFAB9D"): "LibStringlist",
	*guid.MustParse("C5847038-FF75-4074-9E4C-C36A2EB398A5"): "LibTime",
	*guid.MustParse("1DCFF17C-AA53-4B78-B234-864027555035"): "LibUefi",
	*guid.MustParse("42C078EF-14A8-4E30-9329-6F12D796E54A"): "LibWchar",
	*guid.MustParse("2F30DA26-F51B-4B6F-85C4-31873C281BCA"): "LinuxInitrdDynamicShellCommand",
	*guid.MustParse("BD712601-082F-4C59-8677-2C8A3C297948"): "LoadFileOnFv2",
	*guid.MustParse("EAEC1915-65A0-43A9-BF0B-A76438DA61DB"): "LoadLinuxLib",
	*guid.MustParse("17CA9B37-5BAB-492C-A09C-7121FBE34CE6"): "LockBoxBaseLib",
	*guid.MustParse("F61C9A34-2E18-44CE-AF2F-21A998E64FDA"): "LockBoxDxeLib",
	*guid.MustParse("0BA38EBD-E190-4DF7-8EC4-0A6E2B43772D"): "LockBoxNullLib",
	*guid.MustParse("7BB28B99-61BB-11D5-9A5D-0090273FC14D"): "Logo",
	*guid.MustParse("F74D20EE-37E7-48FC-97F7-9B1047749C69"): "LogoDxe",
	*guid.MustParse("EB4EB21F-5A3D-40BE-8BD2-F1B0E38E5744"): "LsiScsiDxe",
	*guid.MustParse("D6A9A1B9-4BFD-D61E-F037-3FA4CA06E046"): "Lua",
	*guid.MustParse("4E38555C-4F92-20C5-A563-FE907585662D"): "LuaLib",
	*guid.MustParse("A853C1D2-E003-4CC4-9DD1-8824AD79FE48"): "LzmaArchDecompressLib",
	*guid.MustParse("35194660-7421-44AD-9636-E44885F092D1"): "LzmaDecompressLib",
	*guid.MustParse("100C2CFA-B586-4198-9B4C-1683D195B1DA"): "MMCHS",
	*guid.MustParse("4EA97C46-7491-4DFD-B442-747010F3CE5F"): "Main",
	*guid.MustParse("C1594631-3888-4BE4-949F-9C630DBC842B"): "MemEncryptSevLib",
	*guid.MustParse("EA355F14-6409-4716-829F-37B3BC7C7F26"): "MemLib",
	*guid.MustParse("DCDCBE1D-E760-4E1D-85B4-96E3F0439C41"): "MemoryAllocationLib",
	*guid.MustParse("54646378-A9DC-473F-9BE1-BD027C4C76DE"): "MemoryAllocationLib",
	*guid.MustParse("A1672454-A3D3-4AAC-A86B-8D63132BBB91"): "MemoryAllocationLibPosix",
	*guid.MustParse("C61EF796-B50D-4F98-9F78-4F6F79D800D5"): "MemoryInit",
	*guid.MustParse("D2C69B26-82E1-4A1B-AD35-ED0261B9F347"): "MemoryInitPei",
	*guid.MustParse("21429B90-5F67-4E93-AF55-1D314D646E12"): "MemoryProfileInfo",
	*guid.MustParse("EF17CEE7-267D-4BFD-A257-4A6AB3EE8591"): "MemorySubClass",
	*guid.MustParse("C8339973-A563-4561-B858-D8476F9DEFC4"): "Metronome",
	*guid.MustParse("154CAB4A-52B5-46CD-99C3-4368ABBACFFD"): "Metronome",
	*guid.MustParse("4C6E0267-C77D-410D-8100-1495911A989D"): "MetronomeDxe",
	*guid.MustParse("ABC36AAC-2031-4422-896E-0A3B899AD0B4"): "Microcode",
	*guid.MustParse("6F871ADD-9D86-4676-8BAD-68E2E451FC5B"): "MicrocodeFlashAccessLibNull",
	*guid.MustParse("0565365C-2FE1-4F88-B3BE-624C04623A20"): "MicrocodeUpdateDxe",
	*guid.MustParse("4A9B9DB8-EC62-4A92-818F-8AA0246D246E"): "MiscSubclass",
	*guid.MustParse("4EFFB560-B28B-4E57-9DAD-4344E32EA3BA"): "MiscSubclass",
	*guid.MustParse("F2FBD108-8985-11DB-B06A-0040D02B1835"): "MiscSubclass",
	*guid.MustParse("9508ECFD-66D1-4B4C-9415-F25F0FFF9E93"): "MmServicesTableLib",
	*guid.MustParse("B6F44CC0-9E45-11DF-BE21-0002A5D5C51B"): "MmcDxe",
	*guid.MustParse("025BBFC7-E6A9-4B8B-82AD-6815A1AEAF4A"): "MnpDxe",
	*guid.MustParse("4EA215EE-85C1-4A0A-847F-D2A8DE20805F"): "MockUefiRuntimeServicesTableLib",
	*guid.MustParse("4BB346D2-8076-4671-8BC9-7B95CBB9A6DF"): "MonoStatusCode",
	*guid.MustParse("AD608272-D07F-4964-801E-7BD3B7888652"): "MonotonicCounterRuntimeDxe",
	*guid.MustParse("70E9818C-A4F0-4061-9FA2-2DFFC7016D6E"): "MpInitLibUp",
	*guid.MustParse("2B3DB5DD-B315-4961-8454-0AFF3C811B19"): "MptScsiDxe",
	*guid.MustParse("DC3641B8-2FA8-4ED3-BC1F-F9962A03454B"): "Mtftp4Dxe",
	*guid.MustParse("99F03B99-98D8-49DD-A8D3-3219D0FFE41E"): "Mtftp6Dxe",
	*guid.MustParse("6826B408-F4F3-47EE-917F-AF7047F9D937"): "MtrrLib",
	*guid.MustParse("A1542D84-B64D-4847-885E-0509084376AB"): "MtrrLibUnitTestHost",
	*guid.MustParse("AB83A52B-B44A-462C-B099-444CC0ED274D"): "MultiPlatformLib",
	*guid.MustParse("4D00EF14-C4E0-426B-81B7-30A00A14AAD6"): "NandFlash",
	*guid.MustParse("43AD4920-DB15-4E24-9889-2DB568431FBD"): "NonCoherentDmaLib",
	*guid.MustParse("7ED510AA-9CDC-49D2-A306-6E11E359F9B3"): "NonCoherentIoMmuDxe",
	*guid.MustParse("8802AE41-8184-49CB-8AEC-62627CD7CEB4"): "NonDiscoverableDeviceRegistrationLib",
	*guid.MustParse("71FD84CD-353B-464D-B7A4-6EA7B96995CB"): "NonDiscoverablePciDeviceDxe",
	*guid.MustParse("6B639C7E-9B53-4E9F-89A3-2E711729709C"): "NorFlashInfoLib",
	*guid.MustParse("29B733AD-D066-4DF6-8A89-B9DF1BEB818A"): "NorFlashPlatformNullLib",
	*guid.MustParse("339B7829-4C5F-4EFC-B2DD-5050E530DECE"): "NorFlashQemuLib",
	*guid.MustParse("A7EBA1F6-5505-4FBA-8895-386EE02B2FAC"): "Nt32ResetSystemLib",
	*guid.MustParse("96B5C032-DF4C-4B6E-8232-438DCF448D0E"): "NullMemoryTestDxe",
	*guid.MustParse("78F76AE8-AE62-4455-8148-C3A7EBAAA3F3"): "NvVarStoreFormattedLib",
	*guid.MustParse("9172FE8B-9A36-40F8-BBA5-5E57A44390BD"): "NvVarsFileLib",
	*guid.MustParse("5BE3BDF4-53CF-46A3-A6A9-73C34A6E5EE3"): "NvmExpressDxe",
	*guid.MustParse("94813714-E10A-4798-9909-8C904F66B4D9"): "NvmExpressPei",
	*guid.MustParse("54D2878F-25CD-4A2B-8420-EBD18E609C76"): "OemHookStatusCodeLibNull",
	*guid.MustParse("4ACA697E-F883-446F-98F7-096416FFFFFF"): "OhciDxe",
	*guid.MustParse("332A0926-429B-4624-9211-A36B23DF0389"): "OhciPei",
	*guid.MustParse("23EED05D-1B93-4A1A-8E1B-931D69E37952"): "Omap35xxBoardInterruptDxe",
	*guid.MustParse("09B17D99-BB07-49A8-B0D2-06D6AFCBE3AB"): "OmapDmaLib",
	*guid.MustParse("D035F5C2-1B92-4746-9F6C-5FF6202970DF"): "OmapLib",
	*guid.MustParse("79DED328-7FCE-4909-9AFD-D66176AF97A6"): "OobRx",
	*guid.MustParse("EB740091-A494-44D7-8D96-C192F95A6394"): "OobTx",
	*guid.MustParse("E3E4048D-6C0C-43E4-AE1C-FFB579D8EF41"): "OpalPasswordDxe",
	*guid.MustParse("DED60489-979C-4B5A-8EE4-4068B0CC38DC"): "OpalPasswordPei",
	*guid.MustParse("C873A7D0-9824-409F-9B42-2C158B992E69"): "OpensslLib",
	*guid.MustParse("E29FC209-8B64-4500-BD20-AF4EAE47EA0E"): "OpensslLibCrypto",
	*guid.MustParse("BCD50D08-9568-45B2-84DF-30AE0279AD46"): "OpteeLib",
	*guid.MustParse("E6C7EBB7-1604-4FCB-8F87-B3A6F48730AE"): "OrderedCollectionTest",
	*guid.MustParse("8ECEFC8F-A2C4-4091-B80F-20F7AEB0567F"): "PL011SerialPortLib",
	*guid.MustParse("6A2C5714-8910-44F0-861F-804ABC18CE39"): "PL011UartLib",
	*guid.MustParse("470DFB96-E205-4515-A75E-2E60F853E79D"): "PL031RealTimeClockLib",
	*guid.MustParse("5C1997D7-8D45-4F21-AF3C-2206B8ED8BEC"): "PL061GpioDxe",
	*guid.MustParse("407B4008-BF5B-11DF-9547-CF16E0D72085"): "PL111Lcd",
	*guid.MustParse("09831032-6FA3-4484-AF4F-0A000A8D3A82"): "PL180MciDxe",
	*guid.MustParse("1FA1F39E-FEFF-4AAE-BD7B-38A070A3B609"): "PartitionDxe",
	*guid.MustParse("1B25AF84-1EA8-4B52-894E-BFA6880B97FF"): "PcAtSerialPortLib",
	*guid.MustParse("378D7B65-8DA9-4773-B6E4-A47826A833E1"): "PcRtc",
	*guid.MustParse("4F1F379F-2A62-48BB-AC34-D3F135C6E2B7"): "PcatSingleSegmentPciCfg2Pei",
	*guid.MustParse("80CF7257-87AB-47F9-A3FE-D50B76D89541"): "PcdDxe",
	*guid.MustParse("9B3ADA4F-AE56-4C24-8DEA-F03B7558AE50"): "PcdPeim",
	*guid.MustParse("32F89CBC-305D-4BDD-8B2C-9C65592E66AC"): "PchPlatformLib",
	*guid.MustParse("A6A16CCB-91B0-42F4-B4F3-D17D7A5662E6"): "PchSmmLib",
	*guid.MustParse("C194C6EA-B68C-4981-B64B-9BD271474B20"): "PchSpiRuntime",
	*guid.MustParse("27F4917B-A707-4AAD-9676-26DF168CBF0D"): "PchSpiSmm",
	*guid.MustParse("93B80004-9FB3-11D4-9A3A-0090273FC14D"): "PciBusDxe",
	*guid.MustParse("D58EBCE1-AF26-488D-BE66-C164417F8C13"): "PciHostBridge",
	*guid.MustParse("128FB770-5E79-4176-9E51-9BB268A17DD1"): "PciHostBridgeDxe",
	*guid.MustParse("62EE5269-CFFD-43A3-BE3F-622FC79F467E"): "PciHostBridgeLib",
	*guid.MustParse("9F2BC05E-51EA-4AED-9A3E-7699641734E8"): "PciHostBridgeLib",
	*guid.MustParse("A19A6C36-7053-4E2C-8BD0-E8286230E473"): "PciHostBridgeLibNull",
	*guid.MustParse("11A6EDF6-A9BE-426D-A6CC-B22FE51D9224"): "PciHotPlugInitDxe",
	*guid.MustParse("E2441B64-7EF4-41FE-B3A3-8CAA7F8D3017"): "PciPlatform",
	*guid.MustParse("2E8CD01A-BDB7-40B4-8376-E7C26EAC21FF"): "PciPlatform",
	*guid.MustParse("0EA82AA2-6C36-4FD5-BC90-FFA3ECB5E0CE"): "PciSegmentInfoLibAcpiBoardInfo",
	*guid.MustParse("E2775B47-D453-4EE3-ADA7-391A1B05AC17"): "PciSioSerialDxe",
	*guid.MustParse("8F01CBD5-E069-44D7-90C9-35F0318603AD"): "PeCoffExtraActionLib",
	*guid.MustParse("0EB84DA1-267A-40B4-8347-1F48694C8B47"): "PeCoffExtraActionLibNull",
	*guid.MustParse("3FCA54F6-E1A2-4B20-BE76-926B4B48BFAA"): "PeiAcpiTimerLib",
	*guid.MustParse("52C05B14-0B98-496C-BC3B-04B50211D680"): "PeiCore",
	*guid.MustParse("B3B0654A-969D-4096-86CB-27E262A02083"): "PeiCoreEntryPoint",
	*guid.MustParse("980DDA67-44A6-4897-99E6-275290B71F9E"): "PeiCpuExceptionHandlerLib",
	*guid.MustParse("2B13DE00-1A5F-4DD7-A298-01B08AF1015A"): "PeiCpuTimerLib",
	*guid.MustParse("1EBE57F5-BE42-45F0-A1F9-FA3DC633910B"): "PeiCrc32GuidedSectionExtractLib",
	*guid.MustParse("9A2A4375-194C-4E97-9F67-547EC98D96CA"): "PeiCryptLib",
	*guid.MustParse("3E8B50C6-F68C-4212-B903-94A10FE02399"): "PeiCryptLib",
	*guid.MustParse("2E08836C-4D1C-42F7-BBBE-EC5D25F1FDD4"): "PeiDebugLibDebugPpi",
	*guid.MustParse("EB0BDD73-DABB-E74B-BF51-62DC1DA521E1"): "PeiDebugPrintHobLib",
	*guid.MustParse("BDA39D3A-451B-4350-8266-81AB10FA0523"): "PeiDxeDebugLibReportStatusCode",
	*guid.MustParse("E062C52D-78DC-4CC5-B246-B13497A8123C"): "PeiDxePostCodeLibReportStatusCode",
	*guid.MustParse("79C4E72A-730B-F040-8129-95877B3A97A8"): "PeiEmuPeCoffExtraActionLib",
	*guid.MustParse("1CBED347-7DE6-BC48-AC68-3758598124D2"): "PeiEmuPeCoffGetEntryPointLib",
	*guid.MustParse("76003416-0373-4C3C-BC4C-87E367FD4BD1"): "PeiEmuSerialPortLibNull",
	*guid.MustParse("E4541241-8897-411A-91F8-7D7E45837146"): "PeiEmuSerialPortLibNull/BaseSerialPortLibNull/BaseSerialPortLibNull",
	*guid.MustParse("41DDF016-2A11-415F-8880-00D938E9541A"): "PeiExtractGuidedSectionLib",
	*guid.MustParse("C7B7070B-E5A8-4B86-9110-BDCA1095F496"): "PeiFspHobProcessLibSample",
	*guid.MustParse("87DC266A-C8F7-4A66-A0CB-018A6F5305B4"): "PeiFspWrapperApiTestLib",
	*guid.MustParse("864693E2-EDE8-4DF8-8871-38C0BAA157EB"): "PeiFspWrapperHobProcessLibSample",
	*guid.MustParse("B6684612-6F5D-425D-952C-F462792EC00B"): "PeiHobLib",
	*guid.MustParse("9643128F-AC24-4B3E-B6BE-D8849A306153"): "PeiHobLib",
	*guid.MustParse("B2585B69-FB63-4220-844A-8FBEA8BF01AF"): "PeiIoLibCpuIo",
	*guid.MustParse("43679142-87C4-44AD-AF02-B47F782D6CF3"): "PeiIpmiLibIpmiPpi",
	*guid.MustParse("B694E0DC-CD4E-4B30-885B-9C164ED3E74A"): "PeiMemoryAllocationLib",
	*guid.MustParse("3A9759D2-53BC-4EB2-ABCD-C93099419063"): "PeiMemoryLib",
	*guid.MustParse("B00F6090-7739-4830-B906-E0032D388987"): "PeiMpInitLib",
	*guid.MustParse("0C2070F9-02A7-4E8E-B584-84EA922363FB"): "PeiNt32OemHookStatusCodeLib",
	*guid.MustParse("057C712A-84F0-4F4A-94CB-713EEF002E2F"): "PeiNt32PeCoffExtraActionLib",
	*guid.MustParse("9DBF6F25-0DA2-4A1D-8E12-E78DE6AB4D0E"): "PeiPcdLib",
	*guid.MustParse("FA3AD693-D58A-4619-960B-8EE85C914870"): "PeiPciLibPciCfg2",
	*guid.MustParse("254901AD-7DB7-45F8-93C8-93D579398D9F"): "PeiPciSegmentLibPciCfg2",
	*guid.MustParse("F72DE735-B24F-4EF6-897F-70A85D01A047"): "PeiPerformanceLib",
	*guid.MustParse("024D3127-7B60-48F4-A6FE-726E19CD4CEB"): "PeiPlatformHelperLib",
	*guid.MustParse("DD8D28B4-C1DC-4CAF-BB93-074BE80DAE6D"): "PeiQemuFwCfgS3LibFwCfg",
	*guid.MustParse("C0227547-0811-4CBB-ABEA-DECD22829122"): "PeiRecoveryLib",
	*guid.MustParse("41789FB9-02AC-4484-BD40-A3147D7EDA25"): "PeiRecoveryLibNull",
	*guid.MustParse("D8855DB3-8348-41B5-BDA4-385351767D41"): "PeiRegisterCpuFeaturesLib",
	*guid.MustParse("8C690838-7A22-45C4-AA58-A33E3E515CD4"): "PeiReportStatusCodeLib",
	*guid.MustParse("3198FF36-FC72-42E7-B98A-A080D823AFBF"): "PeiResetSystemLib",
	*guid.MustParse("E8D6390D-E190-4957-9AB6-D47D51B01336"): "PeiResourcePublicationLib",
	*guid.MustParse("FD5F2C91-4878-4007-BBA1-1B91DD325438"): "PeiRsa2048Sha256GuidedSectionExtractLib",
	*guid.MustParse("EFB7D3A8-DEB9-4BED-B6D6-3B09BEEB835A"): "PeiS3Lib",
	*guid.MustParse("018E1925-D6A2-4A2A-8958-817610A15ADF"): "PeiS3LibNull",
	*guid.MustParse("A804239B-4155-446F-ACC8-F0825D74908C"): "PeiServicesLib",
	*guid.MustParse("1C747F6B-0A58-49AE-8EA3-0327A4FA10E3"): "PeiServicesTablePointerLib",
	*guid.MustParse("C3C9C4ED-EB8A-4548-BE1B-ABB0B6F35B1E"): "PeiServicesTablePointerLib",
	*guid.MustParse("DED3F743-CE2C-4BA6-92A2-FFCE2A6D72D9"): "PeiServicesTablePointerLibIdt",
	*guid.MustParse("2A1E1C92-AABA-4D62-AC40-F3A4C3387356"): "PeiSmbusLibSmbus2Ppi",
	*guid.MustParse("51C4C059-67F0-4E3C-9A55-FF42A8291C8C"): "PeiSmbusLibSmbusPpi",
	*guid.MustParse("AB82E7BE-0970-480B-93EB-3D332B89F99E"): "PeiTcg2PhysicalPresenceLib",
	*guid.MustParse("9A62C49D-C45A-4322-9F3C-45958DF0056B"): "PeiTpmMeasurementLib",
	*guid.MustParse("34C8C28F-B61C-45A2-8F2E-89E46BECC63B"): "PeiVariable",
	*guid.MustParse("FA177FF7-1FC7-458D-A358-D9D62AE61CEC"): "PeimEntryPoint",
	*guid.MustParse("4FE772E8-FE3E-4086-B638-8C493C490488"): "PhysicalPresencePei",
	*guid.MustParse("1C8B7F78-1699-40E6-AF33-9B995D16B043"): "PiSmmCommunicationPei",
	*guid.MustParse("E21F35A8-42FF-4050-82D6-93F7CDFA7073"): "PiSmmCommunicationSmm",
	*guid.MustParse("E94F54CD-81EB-47ED-AEC3-856F5DC157A9"): "PiSmmCore",
	*guid.MustParse("B618E089-9ABA-4D97-AE80-57B5BCCDA51D"): "PiSmmCoreMemoryAllocationLib",
	*guid.MustParse("D55E42AD-3E63-4536-8281-82C0F1098C5E"): "PiSmmCoreMemoryAllocationProfileLib",
	*guid.MustParse("C427146A-2EF2-4AF9-A85A-E09EA65EE47D"): "PiSmmCoreSmmServicesTableLib",
	*guid.MustParse("A3FF0EF5-0C28-42F5-B544-8C7DE1E80014"): "PiSmmCpuDxeSmm",
	*guid.MustParse("2FA2A6DA-11D5-4DC3-999A-749648B03C56"): "PiSmmIpl",
	*guid.MustParse("DC952D08-C62B-41C6-BAC7-70ED054F91E5"): "Pkcs7VerifyDxe",
	*guid.MustParse("35034CE2-A6E5-4FB4-BABE-A0156E9B2549"): "PlatDriOverrideDxe",
	*guid.MustParse("B4BA6241-936C-4485-A483-9FA832C758CA"): "PlatformAcpiTables",
	*guid.MustParse("7E374E25-8E01-4FEE-87F2-390C23C606CD"): "PlatformAcpiTables",
	*guid.MustParse("A6BC385D-59E5-4B77-87D7-200ABAA83C15"): "PlatformBdsLib",
	*guid.MustParse("143B5044-7C1B-4904-9778-EA16F1F3D554"): "PlatformBdsLib",
	*guid.MustParse("59569181-CBF8-2E44-9C3E-C2AB2F5608E1"): "PlatformBmLib",
	*guid.MustParse("3417C705-903E-41A7-9485-3FAFEBF60917"): "PlatformBmPrintScLib",
	*guid.MustParse("FB65006C-AC9F-4992-AD80-184B2BDBBD83"): "PlatformBootManagerLib",
	*guid.MustParse("F0D9063A-DADB-4185-85E2-D7ACDA93F7A6"): "PlatformBootManagerLib",
	*guid.MustParse("469184E8-FADA-41E4-8823-012CA19B40D4"): "PlatformBootManagerLib",
	*guid.MustParse("92FD2DE3-B9CB-4B35-8141-42AD34D73C9F"): "PlatformBootManagerLib",
	*guid.MustParse("95C097CC-8943-4038-BB8A-1C70CF2E9F3C"): "PlatformBootManagerLib",
	*guid.MustParse("EC67889B-9E62-4C81-8CA0-86E6A6EEE61A"): "PlatformBootManagerLib",
	*guid.MustParse("B0DE5F0D-F676-42DA-8D00-86997EE0DBB4"): "PlatformBootManagerLibBhyve",
	*guid.MustParse("ECA883EF-0CBE-40B6-84BC-FA4A709782F7"): "PlatformCmosLib",
	*guid.MustParse("55961E20-B0D9-4553-9948-E3ECF0BE0889"): "PlatformConfigPei",
	*guid.MustParse("025F738B-4EBD-4D55-B728-5F421B601F20"): "PlatformCpuInfoDxe",
	*guid.MustParse("DF934DA3-CD31-49FE-AF50-B3C87C79325F"): "PlatformDebugLibIoPort",
	*guid.MustParse("056E7324-A718-465B-9A84-228F06642B4F"): "PlatformDxe",
	*guid.MustParse("D9DCC5DF-4007-435E-9098-8970935504B2"): "PlatformDxe",
	*guid.MustParse("0A5EA2E1-BE0B-44A0-A775-F429C9A018A0"): "PlatformEarlyInit",
	*guid.MustParse("9618C0DC-50A4-496C-994F-7241F282ED01"): "PlatformEarlyInitPei",
	*guid.MustParse("31CF9CEC-DA4E-4505-AA20-33364A291A95"): "PlatformFlashAccessLib",
	*guid.MustParse("9168384A-5F66-4CF7-AEB6-845BDEBD3012"): "PlatformFlashAccessLibDxe",
	*guid.MustParse("A0534D92-9776-4E4E-9234-C9DC1849DBB5"): "PlatformFlashAccessLibNull",
	*guid.MustParse("1305A712-33A6-4FA7-BA59-AEAC3362931A"): "PlatformFspLib",
	*guid.MustParse("79263F9A-1701-4382-98C2-573F3558E6C8"): "PlatformFvbLibNull",
	*guid.MustParse("9737D7CA-D869-45E5-A5EF-75D9438688DE"): "PlatformGOPPolicy",
	*guid.MustParse("9D1DD27F-6D7F-427B-AEC4-B62F6279C2F1"): "PlatformHasAcpiDtDxe",
	*guid.MustParse("29BEB028-0958-447B-BE0A-12229235D77D"): "PlatformHasAcpiLib",
	*guid.MustParse("49B4B018-0558-448B-1E1A-12226342877D"): "PlatformHasIoMmuLib",
	*guid.MustParse("40A2CBC6-CFB8-447B-A90E-198E88FD345E"): "PlatformHookLib",
	*guid.MustParse("621734D8-8B5E-4C01-B330-9F89A1081710"): "PlatformHookLibSerialPortPpi",
	*guid.MustParse("025F738B-4EBD-4D55-B728-5F421B601F1F"): "PlatformInfoDxe",
	*guid.MustParse("2E6A521C-F697-402D-9774-98B2B7E140F3"): "PlatformInitDxe",
	*guid.MustParse("C153F460-5D8A-4D44-83BB-A8AF5CEF132C"): "PlatformPcieHelperLib",
	*guid.MustParse("AA89D903-345B-4AB2-9ABF-030B5EFB5D50"): "PlatformPei",
	*guid.MustParse("2AD0FC59-2314-4BF3-8633-13FA22A624A0"): "PlatformPei",
	*guid.MustParse("222C386D-5ABC-4FB4-B124-FBB82488ACF4"): "PlatformPei",
	*guid.MustParse("59C11815-F8DA-4F49-B4FB-EC1E41ED1F06"): "PlatformPeiLib",
	*guid.MustParse("CEB0D9D3-328F-4C24-8C02-28FA1986AE1B"): "PlatformRomDebugLibIoPort",
	*guid.MustParse("92AEB68E-C2CF-466E-9AB2-3F5E713F7DE6"): "PlatformRomDebugLibIoPortNocheck",
	*guid.MustParse("8DE4221F-A9CC-4C78-85B9-D863681F0C01"): "PlatformSecLib",
	*guid.MustParse("6695974D-968C-420B-80B9-7870CD20118F"): "PlatformSecLibNull",
	*guid.MustParse("4204D78D-EDBF-4CEE-BE80-3881457CF344"): "PlatformSecureLib",
	*guid.MustParse("38BB5221-F685-469F-846E-F1C508FC5F4A"): "PlatformSecureLib",
	*guid.MustParse("F263EC2A-F0DB-4640-8B12-4ED22A506FB1"): "PlatformSecureLib",
	*guid.MustParse("7FA68D82-10A4-4E71-9524-D3D9500D3CDF"): "PlatformSecureLibNull",
	*guid.MustParse("C1A69A12-8653-4FDE-A215-48FCD95288C3"): "PlatformSetupDxe",
	*guid.MustParse("67FA951E-4FA2-9F4E-A658-4DBD954AC22E"): "PlatformSmbiosDxe",
	*guid.MustParse("99C20A37-042A-46E2-80F4-E4027FDBC86F"): "PlatformSmm",
	*guid.MustParse("839EB770-5C64-4EED-A6D5-EC515B2B2B23"): "PlatformVTdInfoSamplePei",
	*guid.MustParse("5DFAE03E-9C19-4996-85BF-65297BD4137F"): "PlatformVTdSampleDxe",
	*guid.MustParse("9C9623EB-4EF3-44E0-A931-F3A340D1A0F9"): "PlatformVarCleanupLib",
	*guid.MustParse("161BE597-E9C5-49DB-AE50-C462AB54EEDA"): "PowerManagementAcpiTables2",
	*guid.MustParse("2EE72E7C-FB9E-4318-B888-33A315C7A91D"): "PpmPolicy",
	*guid.MustParse("36F6E94E-6E8E-488E-89A4-7AD911C5AFB1"): "PrePiExtractGuidedSectionLib",
	*guid.MustParse("1F3A3278-82EB-4C0D-86F1-5BCDA5846CB2"): "PrePiHobLib/PrePiHobLib/PrePiLib/PrePiHobLib/PrePiLib",
	*guid.MustParse("D751D880-5EE2-11E0-B93E-0002A5D5C51B"): "PrePiHobListPointerLib",
	*guid.MustParse("4F14C900-51A9-11E0-AFBF-0002A5D5C51B"): "PrePiMemoryAllocationLib",
	*guid.MustParse("79E4A61C-ED73-4312-94FE-E3E7563362A9"): "PrintDxe",
	*guid.MustParse("C4D1F932-821F-4744-BF06-6D30F7730F8D"): "Ps2KeyboardDxe",
	*guid.MustParse("3DC82376-637B-40A6-A8FC-A565417F2C38"): "Ps2KeyboardDxe",
	*guid.MustParse("2899C94A-1FB6-4B1A-B96B-8364975303E0"): "Ps2MouseAbsolutePointerDxe",
	*guid.MustParse("08464531-4C99-4C4C-A887-8D8BA4BBB063"): "Ps2MouseDxe",
	*guid.MustParse("202A2B0E-9A31-4812-B291-8747DF152439"): "Ps2MouseDxe",
	*guid.MustParse("30346B14-1580-4781-879D-BA0C55AE9BB2"): "PvScsiDxe",
	*guid.MustParse("1DA2723F-52DF-432A-8D03-6E8FA8ACC107"): "PxeBcPcdProducerLib",
	*guid.MustParse("CA5627C4-51BA-4DCB-AC62-C076EBD37DDB"): "Python",
	*guid.MustParse("F78285FD-121E-49F4-9716-44E307656586"): "Python2710",
	*guid.MustParse("CC13B9FB-DAF5-4B42-907F-122216787C05"): "QNCAccessLib",
	*guid.MustParse("74D3B506-EE9C-47ED-B749-41261401DA78"): "QNCInitDxe",
	*guid.MustParse("2480271C-09C6-4F36-AD75-5E1390BD9929"): "QNCSmmDispatcher",
	*guid.MustParse("8A9A62F5-758B-4965-A28B-0AAC292FBD89"): "QNCSmmLib",
	*guid.MustParse("1D677A58-C753-4AF1-B552-EFE142DF8F57"): "QemuBootOrderLib",
	*guid.MustParse("17985E6F-E778-4D94-AEFA-C5DD2B77E186"): "QemuFwCfgAcpiPlatform",
	*guid.MustParse("80474090-55E7-4C28-B25C-9F236BA41F28"): "QemuFwCfgDxeLib",
	*guid.MustParse("B271F41F-B841-48A9-BA8D-545B4BC2E2BF"): "QemuFwCfgLib",
	*guid.MustParse("B9D1A1F2-01E2-4732-982D-C7F9ED51AC6B"): "QemuFwCfgLibNull",
	*guid.MustParse("DDD4F5F0-5304-42A8-9EFA-D14BF11A3533"): "QemuFwCfgPeiLib",
	*guid.MustParse("60A910E5-7443-413D-9A30-97E57497CD1B"): "QemuFwCfgSecLib",
	*guid.MustParse("A9A1211D-061E-4B64-AF30-5DD0CAC9DC99"): "QemuFwCfgSimpleParserLib",
	*guid.MustParse("806040CA-DAD9-4978-A3B4-2D2AB0C8A48F"): "QemuKernelLoaderFsDxe",
	*guid.MustParse("DCE1B094-7DC6-45D0-9FDD-D7FC3CC3E4EF"): "QemuRamfbDxe",
	*guid.MustParse("E3752948-B9A1-4770-90C4-DF41C38986BE"): "QemuVideoDxe",
	*guid.MustParse("9B30CA82-6746-4A82-A3E6-11EA79DF3B46"): "QemuVirtMemInfoLib",
	*guid.MustParse("0C4D10CF-D949-49B4-BD13-47A4AE22EFCE"): "QemuVirtMemInfoPeiLib",
	*guid.MustParse("C7EA9787-CA0A-43B4-B1E5-25EF87391F8D"): "QncS3Support",
	*guid.MustParse("28A03FF4-12B3-4305-A417-BB1A4F94081E"): "RamDiskDxe",
	*guid.MustParse("8D7AE6A9-B490-45E1-8795-C2BEAADC3814"): "RawIp4Rx",
	*guid.MustParse("3DFE0FAB-70C7-4B53-9855-985F14DB2DDA"): "RawIp4Tx",
	*guid.MustParse("B336F62D-4135-4A55-AE4E-4971BBF0885D"): "RealTimeClock",
	*guid.MustParse("F3552032-8985-11DB-8429-0040D02B1835"): "RealTimeClock",
	*guid.MustParse("27F05AF5-1644-4EF4-8944-48C4F75675A0"): "RealTimeClock",
	*guid.MustParse("EC1713DB-7DB5-4C99-8FE2-6F52F95A1132"): "RealTimeClockLib",
	*guid.MustParse("4278A574-4769-4D60-B090-DD4916691590"): "RecoveryModuleLoadPei",
	*guid.MustParse("929189C9-0670-4C0B-AF7D-135D1550C8C0"): "RecvDgram",
	*guid.MustParse("3E197E9C-D8DC-42D3-89CE-B04FA9833756"): "RegularExpressionDxe",
	*guid.MustParse("A3610442-E69F-4DF3-82CA-2360C4031A23"): "ReportStatusCodeRouterPei",
	*guid.MustParse("D93CE3D8-A7EB-4730-8C8E-CC466A9ECC3C"): "ReportStatusCodeRouterRuntimeDxe",
	*guid.MustParse("A6885402-D022-4B0E-A509-4711B90F2A39"): "ReportStatusCodeRouterSmm",
	*guid.MustParse("16036A73-E8EF-46D0-953C-9B8E96527D13"): "Reset",
	*guid.MustParse("AD33A56E-3AAD-40AC-91B1-FA861E8D9D85"): "ResetSystemLib",
	*guid.MustParse("C5CD4EEE-527F-47DF-9C92-B41414AF7479"): "ResetSystemLib",
	*guid.MustParse("D4FF05AA-3C7D-4B8A-A1EE-AA5EFA0B1732"): "ResetSystemLib",
	*guid.MustParse("EC4F3E59-F879-418B-9E4C-7D6F434714A0"): "ResetSystemLib",
	*guid.MustParse("66564872-21D4-4D2A-A68B-1E844F980820"): "ResetSystemLib/BaseResetSystemLib",
	*guid.MustParse("6141E486-7543-4F1A-A579-FF532ED78E75"): "ResetSystemPei",
	*guid.MustParse("4B28E4C7-FF36-4E10-93CF-A82159E777C5"): "ResetSystemRuntimeDxe",
	*guid.MustParse("CAFC3CA1-3E32-449F-9B0E-40BA3CB73A12"): "ResetUtilityLib",
	*guid.MustParse("B981A835-6EE8-4F4C-AE0B-210AA0BFBF01"): "RngDxe",
	*guid.MustParse("FAE0BA22-92E2-4334-8F0F-96AFF9BAE360"): "RpmcLibNull",
	*guid.MustParse("78189CC0-727D-46A4-84EA-F7DD860DE64A"): "RuntimeCryptLib",
	*guid.MustParse("B601F8C4-43B7-4784-95B1-F4226CB40CEE"): "RuntimeDxe",
	*guid.MustParse("07D25BBB-F832-41BB-BBA0-612E9F033067"): "RuntimeDxeReportStatusCodeLib",
	*guid.MustParse("E6B51D93-E4C8-4425-9FA9-9DED814220F9"): "RuntimeQNCAccessLib",
	*guid.MustParse("DD5D0821-F343-4C85-9CD9-54B3C1A19CEA"): "RuntimeResetSystemLib",
	*guid.MustParse("5EDEB7E7-EA55-4E92-8216-335AC98A3B11"): "RvdUnixPeCoffExtraActionLib",
	*guid.MustParse("89E549B0-7CFE-449D-9BA3-10D8B2312D71"): "S3Resume2Pei",
	*guid.MustParse("BDCE85BB-FBAA-4F4E-9264-501A2C249581"): "S3SaveStateDxe",
	*guid.MustParse("90A330BD-6F89-4900-933A-C25EB4356348"): "SDController",
	*guid.MustParse("80897901-91F6-4EFE-9579-3353A0C02DAB"): "SDMediaDevice",
	*guid.MustParse("04A76C80-06B9-445E-B73E-CB8C61A6A964"): "SIO791",
	*guid.MustParse("EBD705FB-FA92-46A7-B32B-7F566D944614"): "SP805WatchdogDxe",
	*guid.MustParse("021722D8-522B-4079-852A-FE44C2C13F49"): "SataController",
	*guid.MustParse("8F4CD826-A5A0-4E93-9522-CFB0AB72926C"): "SataController",
	*guid.MustParse("96BB18BD-FF2B-4B51-B683-0DC9A4BF12CF"): "SampleUnitTestDxe",
	*guid.MustParse("CC0EA77E-BF2D-4134-B419-0C02E15CE08E"): "SampleUnitTestHost",
	*guid.MustParse("B9BD9451-3DC8-48EA-A6F0-55753BF186F1"): "SampleUnitTestPei",
	*guid.MustParse("389B16DB-F622-424C-9000-9E43C69CBF71"): "SampleUnitTestSmm",
	*guid.MustParse("9E8F461A-17E1-4312-B49C-E66F0A88EA8B"): "SampleUnitTestUefiShell",
	*guid.MustParse("820C59BB-274C-43B2-83EA-DAC673035A59"): "SataController",
	*guid.MustParse("1DF18DA0-A18B-11DF-8C3A-0002A5D5C51B"): "SataSiI3132",
	*guid.MustParse("0F99E33C-CA0C-4AA2-887D-B57EC9050278"): "SaveMemoryConfig",
	*guid.MustParse("E0ECBEC9-B193-4351-A488-36A655F22F9F"): "SaveMemoryConfig",
	*guid.MustParse("DE6FB32C-52CF-4A17-A84C-B323653CB5E0"): "SblParseLib",
	*guid.MustParse("0167CCC4-D0F7-4F21-A3EF-9E64B7CDCE8B"): "ScsiBus",
	*guid.MustParse("0A66E322-3740-4CCE-AD62-BD172CECCA35"): "ScsiDisk",
	*guid.MustParse("17851FBF-45C4-4FF7-A2A0-C3B12D63C27E"): "SdBlockIoPei",
	*guid.MustParse("430AC2F7-EEC6-4093-94F7-9F825A7C1C40"): "SdDxe",
	*guid.MustParse("8E325979-3FE1-4927-AAE2-8F5C4BD2AF0D"): "SdMmcPciHcDxe",
	*guid.MustParse("1BB737EF-427A-4144-8B3B-B76EF38515E6"): "SdMmcPciHcPei",
	*guid.MustParse("BA7BE337-6CFB-4DBB-B26C-21EC2FC16073"): "SecCore",
	*guid.MustParse("8F1AC44A-CE7E-4E29-95BB-92E321BB1573"): "SecFspWrapperPlatformSecLibSample",
	*guid.MustParse("DF1CCEF6-F301-4A63-9661-FC6030DCC880"): "SecMain",
	*guid.MustParse("4B837B03-6587-4D19-B82B-EDFAD836C0A0"): "SecMain",
	*guid.MustParse("58B35361-8922-41BC-B313-EF7ED9ADFDF7"): "SecMigrationPei",
	*guid.MustParse("CA4BBC99-DFC6-4234-B553-8B6586B7B113"): "SecPeiCpuExceptionHandlerLib",
	*guid.MustParse("508B7D59-CD4E-4A6B-A45B-6D3B2D90111E"): "SecPeiDebugAgentLib",
	*guid.MustParse("B5A05743-9B71-489B-A0ED-A0EB3950D23B"): "SecPeiDxeTimerLibCpu",
	*guid.MustParse("4FFF2014-2086-4EE6-9B58-886D1967861C"): "SecPeiDxeTimerLibUefiCpu",
	*guid.MustParse("4E1C4F95-90EA-47DE-9ACC-B8920189A1F5"): "SecPeiFspPlatformSecLibSample",
	*guid.MustParse("6653876C-F6A1-45BB-A027-20455093BC6D"): "SecPeiFspPlatformSecLibVlv2",
	*guid.MustParse("E3E4A441-8465-0F41-8AF4-F67EBE984099"): "SecPeiServicesLib",
	*guid.MustParse("F950E820-0457-8143-86AD-30E4A45FD4BF"): "SecPpiListLib",
	*guid.MustParse("801ADCA0-815E-46A4-84F7-657F53621A57"): "SectionExtractionDxe",
	*guid.MustParse("A0E8E04C-9B5A-43BE-8B7D-C98760492B68"): "SectionExtractionDxe",
	*guid.MustParse("EED5EA31-38E2-463D-B623-2C57702B8A1C"): "SectionExtractionPei",
	*guid.MustParse("F0E6A44F-7195-41C3-AC64-54F202CD0A21"): "SecureBootConfigDxe",
	*guid.MustParse("F80697E9-7FD6-4665-8646-88E33EF71DFC"): "SecurityStubDxe",
	*guid.MustParse("2A8D3FC4-8DB1-4D27-A3F3-780AF03CF848"): "SemiHostingDebugLib",
	*guid.MustParse("E9FB2D1E-05D9-421C-8C35-6100BB0093B7"): "SemiHostingSerialPortLib",
	*guid.MustParse("C5B9C74A-6D72-4719-99AB-C59F199091EB"): "SemihostFs",
	*guid.MustParse("C40D08BA-DB7B-4F07-905A-C5FE4B5AF987"): "SemihostLib",
	*guid.MustParse("9A5163E7-5C29-453F-825C-837A46A81E15"): "SerialDxe",
	*guid.MustParse("D3987D4B-971A-435F-8CAF-4967EB627241"): "SerialDxe",
	*guid.MustParse("15B26F43-A389-4BAE-BDE3-4BB0719B7D4F"): "SerialPortLib",
	*guid.MustParse("4BC80B15-255D-4858-8072-51D6D98CF90E"): "SetHostName",
	*guid.MustParse("6E851687-A7A9-4AA2-8DD0-673E03E51433"): "SetSockOpt",
	*guid.MustParse("EBF342FE-B1D3-4EF8-957C-8048606FF671"): "SetupBrowser",
	*guid.MustParse("7C04A583-9E3E-4F1C-AD65-E05268D0B4D1"): "Shell",
	*guid.MustParse("7A6CA3B8-EE1B-489C-B300-24544A7BD418"): "ShellCTestApp",
	*guid.MustParse("079E8E98-AE93-4B9A-8A71-1DC869F23E09"): "ShellSortTestApp",
	*guid.MustParse("6696936D-3637-467C-87CB-14EA8248948C"): "SimpleTextInOutSerial",
	*guid.MustParse("864E1CA8-85EB-4D63-9DCC-6E0FC90FFD55"): "SioBusDxe",
	*guid.MustParse("F9D88642-0737-49BC-81B5-6889CD57D9EA"): "SmbiosDxe",
	*guid.MustParse("881863A2-09FD-3E44-8D62-7AE038D03747"): "SmbiosLib",
	*guid.MustParse("D27FED59-ABB4-4FED-BEAD-2A878C7E4A7E"): "SmbiosMeasurementDxe",
	*guid.MustParse("EF0C99B6-B1D3-4025-9405-BF6A560FE0E0"): "SmbiosMisc",
	*guid.MustParse("E2D8A63C-C239-484F-BB21-2917843CC382"): "SmbiosPlatformDxe",
	*guid.MustParse("4110465D-5FF3-4F4B-B580-24ED0D06747A"): "SmbiosPlatformDxe",
	*guid.MustParse("D5125E0F-1226-444F-A218-0085996ED5DA"): "Smbus",
	*guid.MustParse("0558CAEA-FEF3-4B6D-915E-8742EFE6DEE1"): "SmbusLib",
	*guid.MustParse("6F2F36B3-936B-4EB2-83C7-2987B4F9D4EB"): "SmbusLib",
	*guid.MustParse("611EA796-8DF8-4BB6-91FE-6540ED70DC66"): "SmiHandlerProfileInfo",
	*guid.MustParse("B43D1B52-6251-4E6F-82EC-A599A5EE94C1"): "SmiHandlerProfileLibNull",
	*guid.MustParse("274F0C8F-9E57-41D8-9966-29CCD48D31C2"): "SmmAccess",
	*guid.MustParse("AC95AD3D-4366-44BF-9A62-E4B29D7A2206"): "SmmAccess2Dxe",
	*guid.MustParse("6C0E75B4-B0B9-44D1-8210-3377D7B4E066"): "SmmAccessPei",
	*guid.MustParse("B4E0CDFC-30CD-4B29-A445-B0AA95A532E4"): "SmmAccessPei",
	*guid.MustParse("8FAAD0A7-02B4-432F-8F5C-B880965D8B41"): "SmmCommunicationBufferDxe",
	*guid.MustParse("1206F7CA-A475-4624-A83E-E6FC9BB38E49"): "SmmControl2Dxe",
	*guid.MustParse("A03A9429-C570-4EF9-9E00-C7A673976E5F"): "SmmControlDxe",
	*guid.MustParse("60EC7720-512B-4490-9FD1-A336769AE01F"): "SmmControlPei",
	*guid.MustParse("36290D10-0F47-42C1-BBCE-E191C7928DCF"): "SmmCorePerformanceLib",
	*guid.MustParse("FED6583D-2418-4760-AC96-B5E18F0A6326"): "SmmCorePlatformHookLibNull",
	*guid.MustParse("8D2C439B-3981-42FF-9CE5-1B50ECA502D6"): "SmmCpuExceptionHandlerLib",
	*guid.MustParse("34001BF4-1E93-4E08-B90E-52F2418A5026"): "SmmCpuFeaturesLib",
	*guid.MustParse("FC3DC10D-D271-422A-AFF3-CBCF70344431"): "SmmCpuFeaturesLib",
	*guid.MustParse("AC9991BE-D77A-464C-A8DE-A873DB8A4836"): "SmmCpuFeaturesLib",
	*guid.MustParse("374DE830-81C5-4CC8-B2AB-28F0AB73710B"): "SmmCpuFeaturesLibStm",
	*guid.MustParse("D6494E1B-E06F-4AB5-B64D-48B25AA9EB33"): "SmmCpuPlatformHookLibNull",
	*guid.MustParse("154D6D26-54B8-45BC-BA3A-CBAA20C02A6A"): "SmmCpuPlatformHookLibQemu",
	*guid.MustParse("5CC6ECC9-E961-46A9-8D5C-6581A060DC0D"): "SmmCryptLib",
	*guid.MustParse("028080A3-8958-4A62-A1A8-0FA1DA162007"): "SmmCryptLib",
	*guid.MustParse("CB07D74C-598F-4268-A5D1-644FB4A481E8"): "SmmDebugAgentLib",
	*guid.MustParse("470CB248-E8AC-473C-BB4F-81069A1FE6FD"): "SmmFaultTolerantWriteDxe",
	*guid.MustParse("F0F5A845-E3ED-4C6E-82D6-4ECE85DAC00F"): "SmmIoLib",
	*guid.MustParse("DEEEA15E-4A77-4513-BA75-71D26FEF78A1"): "SmmIoLibSmmCpuIo2",
	*guid.MustParse("B422FB70-E835-448D-A921-EBA460E105B6"): "SmmIpmiLibSmmIpmiProtocol",
	*guid.MustParse("DDADFC93-FBC5-4389-B20F-EC99E4A6AE52"): "SmmLibNull",
	*guid.MustParse("33FB3535-F15E-4C17-B303-5EB94595ECB6"): "SmmLockBox",
	*guid.MustParse("4A0054B4-3CA8-4E1B-9339-9B58D5FBB7D2"): "SmmLockBoxDxeLib",
	*guid.MustParse("5F5E6140-E7BA-4BD6-B85F-236B5BCD8E1E"): "SmmLockBoxPeiLib",
	*guid.MustParse("E04894D6-290D-4171-A362-0ACFD939F3C8"): "SmmLockBoxSmmLib",
	*guid.MustParse("7F23F839-C81C-4B89-8132-69746FCBCE52"): "SmmMemLib",
	*guid.MustParse("4DF30A5D-D5B0-4F85-80ED-6B16CD343C8E"): "SmmMemoryAllocationLib",
	*guid.MustParse("DC50729F-8633-47AB-8FD3-6939688CEE4C"): "SmmMemoryAllocationProfileLib",
	*guid.MustParse("00D24382-8231-4B18-A4F0-2D94D8FE2E81"): "SmmPciExpressLib",
	*guid.MustParse("F6994CBA-2351-4EBC-A2DA-20BAC2FE2CF3"): "SmmPciLibPciRootBridgeIo",
	*guid.MustParse("1EDD13E6-D0CD-4432-A692-FF65C9B4F039"): "SmmPerformanceLib",
	*guid.MustParse("AED5F3FB-4CFF-4B60-9E43-1541B55C8267"): "SmmPeriodicSmiLib",
	*guid.MustParse("271F1343-20D6-4E14-9B62-3C0297F56F07"): "SmmPowerManagement",
	*guid.MustParse("67089D19-B3D6-4D9E-A0EB-FEDC1F83A1EE"): "SmmReportStatusCodeLib",
	*guid.MustParse("D65D9F72-7BCE-4F73-A673-47AF446A1A31"): "SmmRuntimeDxeReportStatusCodeLibFramework",
	*guid.MustParse("2D59F041-53A4-40D0-A6CD-844DC0DFEF17"): "SmmS3SaveState",
	*guid.MustParse("064B4C5B-C5EF-4EFF-85DF-65518EF1314D"): "SmmServicesTableLib",
	*guid.MustParse("FC38CEAE-FB74-4049-A51C-68F0BA69DA7D"): "SmmSmiHandlerProfileLib",
	*guid.MustParse("1410C6AC-9F4B-495B-9C23-8A5AEB0165E9"): "SmmSwDispatch2OnSmmSwDispatchThunk",
	*guid.MustParse("AAE02741-858B-4964-9887-CA870489D944"): "SmmTcg2PhysicalPresenceLib",
	*guid.MustParse("63296C52-01CF-4EEA-A47C-782A14DA6894"): "SmramSaveInfoHandlerSmm",
	*guid.MustParse("A2F436EA-A127-4EF8-957C-8048606FF670"): "SnpDxe",
	*guid.MustParse("D0893F05-B06D-4161-B947-9BE9B85AC3A1"): "SnpNt32Dxe",
	*guid.MustParse("2A43BA5F-AC29-4FDC-8A3B-0328D0256F8C"): "SocketDxe",
	*guid.MustParse("D1F92325-2DFB-435C-9B4C-A6B864F19230"): "SsdtSerialPortLibArm",
	*guid.MustParse("6807217E-E8DE-42D0-91D9-60AECED7420D"): "Stall",
	*guid.MustParse("A6A16CCB-91B0-42F4-B4F3-D16D7A8662E6"): "StallSmmLib",
	*guid.MustParse("6E14B6FD-3600-4DD6-A17A-206B3B6DCE16"): "StandaloneMmCore",
	*guid.MustParse("C97AC593-109A-4C63-905C-675FDE2689E8"): "StandaloneMmCoreEntryPoint",
	*guid.MustParse("58F7A62B-6280-42A7-BC38-10535A64A92C"): "StandaloneMmCpu",
	*guid.MustParse("5CA126C0-B598-4F4B-ABB9-B6E7D077AEA9"): "StandaloneMmDriverEntryPoint",
	*guid.MustParse("8B40543B-9588-48F8-840C-5A60E6DB1B03"): "StandaloneMmPeCoffExtraActionLib",
	*guid.MustParse("EAA4684F-FB4E-41F3-9967-307D5B409182"): "StandaloneMmServicesTableLib",
	*guid.MustParse("9D225237-FA01-464C-A949-BAABC02D31D0"): "StatusCodeHandlerPei",
	*guid.MustParse("6C2004EF-4E0E-4BE4-B14C-340EB4AA5891"): "StatusCodeHandlerRuntimeDxe",
	*guid.MustParse("79CD78D8-6EDC-4978-BD02-3299C387AB17"): "StatusCodeHandlerSmm",
	*guid.MustParse("1EC0F53A-FDE0-4576-8F25-7A1A410F58EB"): "StatusCodePei",
	*guid.MustParse("FEDE0A1B-BCA2-4A9F-BB2B-D9FD7DEC2E9F"): "StatusCodeRuntimeDxe",
	*guid.MustParse("90B2B846-CA6D-4D6E-A8D3-C140A8E110AC"): "SystemFirmwareDescriptor",
	*guid.MustParse("BC1A046C-7DBD-41F2-94E5-D7595554CAF4"): "SystemFirmwareReportDxe",
	*guid.MustParse("0A2FBD15-1C25-407E-8915-60C5652BC2AA"): "SystemFirmwareUpdateDxe",
	*guid.MustParse("71FE861A-5450-48B6-BFB0-B93522616F99"): "TPS65950",
	*guid.MustParse("4D9CBEF0-15A0-4D0C-83DB-5213E710C23F"): "Tcg2ConfigDxe",
	*guid.MustParse("BF7F2B0C-9F2F-4889-AB5C-12460022BE87"): "Tcg2ConfigPei",
	*guid.MustParse("EADD5061-93EF-4CCC-8450-F78A7F0820F0"): "Tcg2ConfigPei",
	*guid.MustParse("FDFF263D-5F68-4591-87BA-B768F445A9AF"): "Tcg2Dxe",
	*guid.MustParse("A0C98B77-CBA5-4BB8-993B-4AF6CE33ECE4"): "Tcg2Pei",
	*guid.MustParse("41D3E698-9EEC-41FF-9CBB-5FE79A0CF326"): "Tcg2PhysicalPresenceLibQemu",
	*guid.MustParse("51924AE9-BE81-4820-94BA-7C9546E702D0"): "Tcg2PpVendorLibNull",
	*guid.MustParse("44A20657-10B8-4049-A148-ACD8812AF257"): "Tcg2Smm",
	*guid.MustParse("1FA4DAFE-FA5D-4D75-BEA6-5863862C520A"): "TcgConfigDxe",
	*guid.MustParse("A5683620-7998-4BB2-A377-1C1E31E1E215"): "TcgDxe",
	*guid.MustParse("F8125B2A-3922-4A22-A6F8-3B6159A25A3B"): "TcgEventLogRecordLib",
	*guid.MustParse("AD416CE3-A483-45B1-94C2-4B4E4D575562"): "TcgMor",
	*guid.MustParse("E2EA6F47-E678-47FA-8C1B-02A03E825C6E"): "TcgMorLockSmm",
	*guid.MustParse("2BE1E4A6-6505-43B3-9FFC-A3C8330E0432"): "TcgPei",
	*guid.MustParse("8489334D-4219-4CA1-9B42-1D46B0B75861"): "TcgPpVendorLibNull",
	*guid.MustParse("42293093-76B9-4482-8C02-3BEFDEA9B35D"): "TcgSmm",
	*guid.MustParse("AD63B09B-1FC9-4789-AF0C-5AF8A3FB1F9C"): "TcgStorageCoreLib",
	*guid.MustParse("F8B56221-FD5D-4215-B578-C3574AD1E253"): "TcgStorageOpalLib",
	*guid.MustParse("1A7E4468-2F55-4A56-903C-01265EB7622B"): "TcpDxe",
	*guid.MustParse("86787704-8FED-11E3-B3FF-F33B73ACFEC2"): "TcpFastbootTransportDxe",
	*guid.MustParse("B661E02D-A90B-42AB-A5F9-CF841AAA43D9"): "TemplateRealTimeClockLib",
	*guid.MustParse("40BAFDE5-4CC8-4FBE-A8BA-071890076E50"): "TemplateResetSystemLib",
	*guid.MustParse("9E863906-A40F-4875-977F-5B93FF237FC6"): "TerminalDxe",
	*guid.MustParse("9729DB60-FB9D-4625-9EE1-93B21EC246B8"): "TestBaseSafeIntLibDxe",
	*guid.MustParse("95487689-9E30-41AD-B773-3650C94BCBE2"): "TestBaseSafeIntLibHost",
	*guid.MustParse("7D910602-ED53-45E6-826E-8266705B9734"): "TestBaseSafeIntLibPei",
	*guid.MustParse("2F2A1907-B1B4-4E33-8B83-62A60AB4F0D4"): "TestBaseSafeIntLibSmm",
	*guid.MustParse("1F91B73E-5B6A-4317-80E8-E7C36A3C7AF4"): "TestBaseSafeIntLibUefiShell",
	*guid.MustParse("94621F9E-B5CA-4CFD-82BE-0C542EB0D9BE"): "TftpServer",
	*guid.MustParse("465FDE84-E8B0-B04B-A843-A03F68F617A9"): "ThunkPpiList",
	*guid.MustParse("C32A66D5-D8B7-2640-B768-082C8F083C37"): "ThunkPpiToProtocolPei",
	*guid.MustParse("7833616E-AE0D-594F-870C-80E68682D587"): "ThunkProtocolList",
	*guid.MustParse("B1B07E01-6896-448C-8E75-F0E119ABDF49"): "TimeBaseLib",
	*guid.MustParse("C3811036-710B-4E39-8CF1-0AF9BE3A8198"): "Timer",
	*guid.MustParse("F2765DEC-6B41-11D5-8E71-00902707B35E"): "Timer",
	*guid.MustParse("C190FE35-44AA-41A1-8AEA-4947BC60E09D"): "Timer",
	*guid.MustParse("C10194E7-DEB2-4AF4-9EEE-BFFDE4D7D4C7"): "TimestampDxe",
	*guid.MustParse("7CA1024F-EB17-11E5-9DBA-28D2447C4829"): "TlsAuthConfigDxe",
	*guid.MustParse("660AB627-4C5F-4D42-A3B6-BD021E9028BD"): "TlsAuthConfigLib",
	*guid.MustParse("3ACEB0C0-3C72-11E4-9A56-74D435052646"): "TlsDxe",
	*guid.MustParse("CC729DC5-4E21-0B36-1A00-3A8E1B86A155"): "TlsLib",
	*guid.MustParse("705A5B3B-CFA5-42EA-87F0-F2B8D44EC521"): "TlsLibNull",
	*guid.MustParse("C595047C-70B3-4731-99CC-A014E956D7A7"): "Tpm12CommandLib",
	*guid.MustParse("A0C0B7EF-99FF-417F-8B9F-5AD4701D90D6"): "Tpm12DeviceLibAtmelI2c",
	*guid.MustParse("BC2B7672-A48B-4D58-B39E-AEE3707B5A23"): "Tpm12DeviceLibDTpm",
	*guid.MustParse("DBE37563-AFEF-4B41-BDCE-B01B6D1E8690"): "Tpm12DeviceLibInfineonI2c",
	*guid.MustParse("4D8B77D9-E923-48F8-B070-4053D78B7E56"): "Tpm12DeviceLibTcg",
	*guid.MustParse("2F572F32-8BE5-4868-BD1D-7438AD97DC27"): "Tpm2CommandLib",
	*guid.MustParse("E54A3327-A345-4068-8842-70AC0D519855"): "Tpm2DeviceLibDTpm",
	*guid.MustParse("C3D69D87-5200-4AAB-A6DB-2569BA1A92FC"): "Tpm2DeviceLibRouterDxe",
	*guid.MustParse("97CDCF04-4C8E-42FE-8015-11CC8A6E9D81"): "Tpm2DeviceLibRouterPei",
	*guid.MustParse("294B196A-A3CC-4A43-857F-EEC26147857B"): "Tpm2DeviceLibSeC",
	*guid.MustParse("1EEA2BFE-01CB-40CC-A34E-CB224C800AA2"): "Tpm2DeviceLibSeC",
	*guid.MustParse("A1B0B230-67DC-431E-A94A-A96AF1EBE637"): "Tpm2DeviceLibTcg2",
	*guid.MustParse("286BF25A-C2C3-408C-B3B4-25E6758B7317"): "Tpm2InstanceLibDTpm",
	*guid.MustParse("7D9FE32E-A6A9-4CDF-ABFF-10CC7F22E1C9"): "TpmCommLib",
	*guid.MustParse("6DFD6E9F-9278-48D8-8F45-B6CFF2C2B69C"): "TpmMeasurementLibNull",
	*guid.MustParse("905F13B0-8F91-4B0A-BD76-E1E78F9422E4"): "UdfDxe",
	*guid.MustParse("6D6963AB-906D-4A65-A7CA-BD40E5D6AF2B"): "Udp4Dxe",
	*guid.MustParse("D912C7BC-F098-4367-92BA-E911083C7B0E"): "Udp6Dxe",
	*guid.MustParse("DADE8301-CB29-4FD5-8148-56FD246C5B88"): "UefiApplicationEntryPoint",
	*guid.MustParse("8D4752BC-595E-49A2-B4AF-F3F57B601DE9"): "UefiBootManagerLib",
	*guid.MustParse("FF5C7A2C-AB7A-4366-8616-11C6E53247B6"): "UefiBootServicesTableLib",
	*guid.MustParse("5CDDFAF3-E9A7-4D16-BDCE-1E002DF475BB"): "UefiDebugLibConOut",
	*guid.MustParse("102287B4-6B12-4D41-91E1-EBEE1F3AA614"): "UefiDebugLibDebugPortProtocol",
	*guid.MustParse("B57A1DF6-FFDB-4247-A3DF-3A562176751A"): "UefiDebugLibStdErr",
	*guid.MustParse("91C1677A-E57F-4191-8B8E-EB7711A716E0"): "UefiDevicePathLib",
	*guid.MustParse("050EB8C6-C12E-4B86-892B-40985E8B3137"): "UefiDevicePathLibDevicePathProtocol",
	*guid.MustParse("3E1C696D-FCF0-45A7-85A7-E86C2A1C1080"): "UefiDevicePathLibOptionalDevicePathProtocol",
	*guid.MustParse("331DEB15-454B-48D8-9B74-70D01F3F3556"): "UefiDriverEntryPoint",
	*guid.MustParse("9495D344-9D8A-41F3-8D17-E2FD238C4E71"): "UefiFileHandleLib",
	*guid.MustParse("3CDC7177-CC2A-4678-BA8F-1A936A093FA4"): "UefiHandleParsingLib",
	*guid.MustParse("3143687A-7C80-404E-B5FE-2D88980E1B1C"): "UefiHiiLib",
	*guid.MustParse("894DC1B6-07A3-4A9D-8CDD-333580B3D4B1"): "UefiHiiServicesLib",
	*guid.MustParse("3A004BA5-EFE0-4A61-9F1A-267A46AE5BA9"): "UefiLib",
	*guid.MustParse("4674739D-3195-4FB2-8094-AC1D22D00194"): "UefiMemoryAllocationLib",
	*guid.MustParse("9E8A380A-231E-41E4-AD40-5E706196B853"): "UefiMemoryAllocationProfileLib",
	*guid.MustParse("F1BBE03D-2F28-4DEE-BEC7-D98D7A30C36A"): "UefiMemoryLib",
	*guid.MustParse("4102F4FE-DA10-4F0F-AC18-4982ED506154"): "UefiPciCapPciIoLib",
	*guid.MustParse("90EC42CB-B780-4EB8-8E99-C8E3E5F37530"): "UefiPciLibPciRootBridgeIo",
	*guid.MustParse("C6068612-B6E0-48A3-BB92-60E4A4F89EDF"): "UefiPciSegmentLibPciRootBridgeIo",
	*guid.MustParse("B95E9FDA-26DE-48D2-8807-1F9107AC5E3A"): "UefiPxeBcDxe",
	*guid.MustParse("B1EE6C28-54AA-4D17-B705-3E28CCB27B2E"): "UefiRuntimeLib",
	*guid.MustParse("19CBBB97-FF61-45FF-8C3F-DFA66DD118C8"): "UefiRuntimeServicesTableLib",
	*guid.MustParse("280E42C3-826E-4573-9772-B74EF1086D95"): "UefiScsiLib",
	*guid.MustParse("FB5B305E-84F5-461F-940D-82D345757AFA"): "UefiShellAcpiViewCommandLib",
	*guid.MustParse("F6A3BF5D-4095-4E4F-9670-408770C2DBDF"): "UefiShellBcfgCommandLib",
	*guid.MustParse("0E205C8A-8586-4DEC-9F5C-4F9E394AEFE8"): "UefiShellCEntryLib",
	*guid.MustParse("5C12F31F-EBAC-466E-A400-FCA8C9EA3A05"): "UefiShellCommandLib",
	*guid.MustParse("90330D51-A99B-4CC8-A2EB-AE22542A3F45"): "UefiShellDebug1CommandsLib",
	*guid.MustParse("313D3674-3ED4-48FD-BF97-7DB35D4190D1"): "UefiShellDriver1CommandsLib",
	*guid.MustParse("D250E364-51C6-49ED-AEBF-6D83F5130F74"): "UefiShellInstall1CommandsLib",
	*guid.MustParse("50CB6037-1102-47AF-B2DD-9944B6EB1ABE"): "UefiShellLevel1CommandsLib",
	*guid.MustParse("CBF3931C-A2DF-40E5-B77E-CCA9555E9755"): "UefiShellLevel2CommandsLib",
	*guid.MustParse("71374B42-85D7-4753-AD17-AA84C3A0EB93"): "UefiShellLevel3CommandsLib",
	*guid.MustParse("449D0F00-2148-4A43-9836-F10B3980ECF5"): "UefiShellLib",
	*guid.MustParse("9A929F7E-3861-45CE-87AB-7371219AE255"): "UefiShellNetwork1CommandsLib",
	*guid.MustParse("D94E3B82-908E-46BF-A7B9-C7B7F17B1B7D"): "UefiShellNetwork2CommandsLib",
	*guid.MustParse("4264A823-45A3-42DB-B92C-AA078555CBD3"): "UefiSortLib",
	*guid.MustParse("87EB5DF9-722A-4241-AD7F-370D0B3A56D7"): "UefiUsbLib",
	*guid.MustParse("BE189D38-C963-41CF-B695-D90E9E545A13"): "UfsBlockIoPei",
	*guid.MustParse("E7F1DFF9-DAB6-498A-9ADF-57F344EDDF57"): "UfsPassThruDxe",
	*guid.MustParse("AF43E178-C2E9-4712-A7CD-08BFDAC7482C"): "UfsPciHcDxe",
	*guid.MustParse("905DC1AD-C44D-4965-98AC-B6B4444BFD65"): "UfsPciHcPei",
	*guid.MustParse("2FB92EFA-2EE0-4BAE-9EB6-7464125E1EF7"): "UhciDxe",
	*guid.MustParse("C463CEAC-FC57-4F36-88B7-356C750C3BCA"): "UhciPei",
	*guid.MustParse("462CAA21-7614-4503-836E-8AB6F4662331"): "UiApp",
	*guid.MustParse("A1F436EA-A127-4EF8-957C-8048606FF670"): "UndiRuntimeDxe",
	*guid.MustParse("F143E75D-76E1-4040-B134-8F4F0BD5E3BD"): "UnitTestBootLibNull",
	*guid.MustParse("DFADE2A2-DB69-47DE-A37A-40FB6D52E844"): "UnitTestBootLibUsbClass",
	*guid.MustParse("9D53AD0D-5416-451F-A5BF-E5420051A99B"): "UnitTestDebugAssertLib",
	*guid.MustParse("9555A0D3-09BA-46C4-A51A-45198E3C765E"): "UnitTestHostBaseLib",
	*guid.MustParse("98CEF9CA-15CE-40A3-ADE8-C299953CD0F6"): "UnitTestLib",
	*guid.MustParse("C800595F-45A3-45A1-8B50-28F01C2A5A4F"): "UnitTestLibCmocka",
	*guid.MustParse("B8553C7A-0B0B-4BBD-9DF3-825804BF26AB"): "UnitTestPersistenceLibNull",
	*guid.MustParse("9200844A-CDFD-4368-B4BD-106354702605"): "UnitTestPersistenceLibSimpleFileSystem",
	*guid.MustParse("C659641D-BA1F-4B58-946E-B1E1103903F9"): "UnitTestResultReportLibConOut",
	*guid.MustParse("BED736D4-D197-475F-B7CE-0D828FF2C9A6"): "UnitTestResultReportLibDebugLib",
	*guid.MustParse("0E84FC69-29CC-4C6D-92AC-6D476921850F"): "UpdateDriverDxe",
	*guid.MustParse("8401A046-6F70-4505-8471-7015B40355E3"): "UsbBotPei",
	*guid.MustParse("240612B7-A063-11D4-9A3A-0090273FC14D"): "UsbBusDxe",
	*guid.MustParse("8401A045-6F70-4505-8471-7015B40355E3"): "UsbBusPei",
	*guid.MustParse("2D2E62CF-9ECF-43B7-8219-94E7FC713DFE"): "UsbKbDxe",
	*guid.MustParse("9FB4B4A7-42C0-4BCD-8540-9BCC6711F83E"): "UsbMassStorageDxe",
	*guid.MustParse("4EA43463-747C-46EB-97FB-B0E5C5F05306"): "UsbMouseAbsolutePointerDxe",
	*guid.MustParse("2D2E62AA-9ECF-43B7-8219-94E7FC713DFE"): "UsbMouseDxe",
	*guid.MustParse("73E6F6B4-D029-4E87-8405-6067C8BD02A6"): "UsbPei",
	*guid.MustParse("1A6853C8-F362-4F68-A77E-0B304A194C05"): "UseSocketDxe",
	*guid.MustParse("87E36301-0406-44DB-AAF3-9E0E591F3725"): "VConfig",
	*guid.MustParse("A34FBDD0-05D3-4AF7-A720-560E91AC8CDF"): "VarCheckHiiLib",
	*guid.MustParse("63E12D08-0C5D-47F8-95E4-09F89D7506C5"): "VarCheckLib",
	*guid.MustParse("D4FA5311-5F1F-4B1E-9AC3-90C4DFC029F1"): "VarCheckPcdLib",
	*guid.MustParse("AC24A4C7-F845-4665-90E5-6431D6E28DC0"): "VarCheckUefiLib",
	*guid.MustParse("202A2922-8C27-4943-9855-26180BF9F113"): "VariableInfo",
	*guid.MustParse("2B640ED8-1E6A-4516-9F1D-25910E59BC4A"): "VariableKeyLibNull",
	*guid.MustParse("64BC4129-778E-4867-BA07-13999A4DEC3F"): "VariableMmDependency",
	*guid.MustParse("CBD2E4D5-7068-4FF5-B462-9822B4AD8D60"): "VariableRuntimeDxe",
	*guid.MustParse("23A089B3-EED5-4AC5-B2AB-43E3298C2343"): "VariableSmm",
	*guid.MustParse("9F7DCADE-11EA-448A-A46F-76E003657DD1"): "VariableSmmRuntimeDxe",
	*guid.MustParse("7EE2C0C1-C21A-4113-A53A-66824A95696F"): "VariableStandaloneMm",
	*guid.MustParse("BF89F10D-B205-474F-96E3-7A7BB1B4A407"): "VgaClassDxe",
	*guid.MustParse("15C5E761-58D8-461A-9173-CAB020916264"): "VgaMiniPort",
	*guid.MustParse("0170F60C-1D40-4651-956D-F0BD9879D527"): "Virtio10",
	*guid.MustParse("11D92DFB-3CA9-4F93-BA2E-4780ED3E03B5"): "VirtioBlkDxe",
	*guid.MustParse("0049858F-8CA7-4CCD-918B-D952CBF32975"): "VirtioFdtDxe",
	*guid.MustParse("D6099B94-CD97-4CC5-8714-7F6312701A8A"): "VirtioGpuDxe",
	*guid.MustParse("90CED1D9-18F2-47CC-BF24-41EC29406637"): "VirtioLib",
	*guid.MustParse("3B6ED966-B5D1-46A8-965B-867FF22D9C89"): "VirtioMmioDeviceLib",
	*guid.MustParse("A92CDB4B-82F1-4E0B-A516-8A655D371524"): "VirtioNetDxe",
	*guid.MustParse("83DD3B39-7CAF-4FAC-A542-E050B767E3A7"): "VirtioPciDeviceDxe",
	*guid.MustParse("58E26F0D-CBAC-4BBA-B70F-18221415665A"): "VirtioRngDxe",
	*guid.MustParse("FAB5D4F4-83C0-4AAF-8480-442D11DF6CEA"): "VirtioScsiDxe",
	*guid.MustParse("88079B18-B42B-44AA-A6F2-B83911075E89"): "VirtualKeyboardDxe",
	*guid.MustParse("1E27D461-78F3-4F7D-B1C2-F72384F13A6E"): "VirtualRealTimeClockLib",
	*guid.MustParse("E4F61863-FE2C-4B56-A8F4-08519BC439DF"): "VlanConfigDxe",
	*guid.MustParse("83723F51-39B5-4D99-A974-90132AB55F83"): "Vlv2FmpDeviceLib",
	*guid.MustParse("582DF9AB-E626-42A8-A11C-3FEA098FF3FA"): "Vlv2FmpDeviceLibSample",
	*guid.MustParse("1EC0EFC9-C93A-4B62-9B27-C059ABD80E92"): "VlvPlatformInitDxe",
	*guid.MustParse("0E923C25-13CD-430B-8714-FFE85652A97B"): "VmgExitLib",
	*guid.MustParse("3CD7368F-EF9B-4A9B-9571-2ED93813677E"): "VmgExitLibNull",
	*guid.MustParse("F099D67F-71AE-4C36-B2A3-DCEB0EB2B7D8"): "WatchdogTimer",
	*guid.MustParse("99E87DCF-6162-40C5-9FA1-32111F5197F7"): "WebServer",
	*guid.MustParse("C6DF98F2-5EC0-4A94-8C11-9A9828EF03F2"): "WifiConnectionManagerDxe",
	*guid.MustParse("62E8F833-2B0A-4C19-A966-63C180588BE7"): "WinHost",
	*guid.MustParse("BE0FEABA-3443-4919-9F3A-2D4216329EA9"): "WinNtAutoScan",
	*guid.MustParse("F479E147-A125-11D4-BCFC-0080C73C8881"): "WinNtBlockIo",
	*guid.MustParse("BD7E9A27-D6C5-416A-B245-5F507D95B2BD"): "WinNtBusDriverDxe",
	*guid.MustParse("F0384FFD-8633-452F-9010-F6B7D2EAE2F1"): "WinNtFirmwareVolumePei",
	*guid.MustParse("681F3771-6F1D-42DE-9AA2-F82BBCDBC5F9"): "WinNtFlashMapPei",
	*guid.MustParse("29B3C4C6-E5AA-49E4-8CE0-2772F782DDC2"): "WinNtGopDxe",
	*guid.MustParse("CA4233AD-847E-4E5D-AD3F-21CABFE5E23C"): "WinNtOemHookStatusCodeHandlerDxe",
	*guid.MustParse("D233D6BD-F1B1-425A-BF45-5CAF2B88EDDC"): "WinNtOemHookStatusCodeHandlerPei",
	*guid.MustParse("6B41B553-A649-11D4-BD02-0080C73C8881"): "WinNtSerialIoDxe",
	*guid.MustParse("9C25E18B-76BA-43DA-A132-DBB0997CEFEF"): "WinNtSimpleFileSystemDxe",
	*guid.MustParse("0C95A916-A006-11D4-BCFA-0080C73C8881"): "WinNtThunkDxe",
	*guid.MustParse("D3AAD8DC-3A48-46AC-B1C7-28A9D3CF6755"): "WinNtThunkPPIToProtocolPei",
	*guid.MustParse("2304DF80-E21D-4170-9C3C-113C878F7AC0"): "X86QemuLoadImageLib",
	*guid.MustParse("49C481AF-1621-42F3-8FA1-27C64143E304"): "Xcode5SecPeiCpuExceptionHandlerLib",
	*guid.MustParse("0EFC6282-F1E5-469A-8A70-194A8761F9AA"): "XenAcpiPlatformDxe",
	*guid.MustParse("E3913319-96AC-4AC0-808B-8EDB8776A51C"): "XenArmGenericTimerVirtCounterLib",
	*guid.MustParse("565EC8BA-A484-11E3-802B-B8AC6F7D65E6"): "XenBusDxe",
	*guid.MustParse("401406DD-BCAC-4B91-9F4E-72A7FEBE4762"): "XenConsoleSerialPortLib",
	*guid.MustParse("B5EE9A32-CA5A-49A8-82E3-ADA4CCB77C7C"): "XenHypercallLib",
	*guid.MustParse("DE9BDC19-8434-47BB-BE3C-7F28F2101FD0"): "XenIoMmioLib",
	*guid.MustParse("CF569F50-DE44-4F54-B4D7-F4AE25CDA599"): "XenIoPciDxe",
	*guid.MustParse("7A567CC4-0E75-4D7A-A305-C3DB109B53AD"): "XenIoPvhDxe",
	*guid.MustParse("6914C46F-D46E-48DC-9998-8A5F64F02553"): "XenPlatformHasAcpiDtDxe",
	*guid.MustParse("DB54DBB7-8142-4EE5-9364-78C824B582EB"): "XenPlatformLib",
	*guid.MustParse("F112A6EE-993A-4F0B-8295-E52029D9B4BA"): "XenPlatformPei",
	*guid.MustParse("8C2487EA-9AF3-11E3-B966-B8AC6F7D65E6"): "XenPvBlkDxe",
	*guid.MustParse("EC2557E8-7005-430B-9F6F-9BA109698248"): "XenRealTimeClockLib",
	*guid.MustParse("52FE8196-F9DE-4D07-B22F-51F77A0E7C41"): "XenTimerDxe",
	*guid.MustParse("40D1F8F5-4DFE-4E0F-9A15-B1DE9DC9F4ED"): "XenVirtMemInfoLib",
	*guid.MustParse("338695EA-CA84-4FA2-9DA8-5C4BB87905C6"): "XenioFdtDxe",
	*guid.MustParse("B7F50E91-A759-412C-ADE4-DCD03E7F7C28"): "XhciDxe",
	*guid.MustParse("65E5746E-9C14-467D-B5B3-932A66D59F79"): "XhciPei",
	*guid.MustParse("1831A379-2D48-45BD-9744-D4059D93815D"): "dp",
	*guid.MustParse("0253F9FA-129A-4A8D-B12E-7DC2B6376302"): "dpDynamicCommand",
	*guid.MustParse("8DC58D0D-67F5-4B97-9DFC-E442BB9A5648"): "tftp",
	*guid.MustParse("A487A478-51EF-48AA-8794-7BEE2A0562F1"): "tftpDynamicCommand",
}

```

`pkg/log/logger.go`:

```go
// Copyright 2021 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package log

import (
	"log"
	"os"
)

// Logger describes a logger to be used in fiano.
type Logger interface {
	// Warnf logs an warning message.
	Warnf(format string, args ...interface{})

	// Errorf logs an error message.
	Errorf(format string, args ...interface{})

	// Fatalf logs a fatal message and immediately exits the application
	// with os.Exit.
	Fatalf(format string, args ...interface{})
}

// DefaultLogger is the logger used by default everywhere within fiano.
var DefaultLogger Logger

func init() {
	DefaultLogger = logWrapper{Logger: log.New(os.Stderr, "", log.LstdFlags)}
}

type logWrapper struct {
	Logger *log.Logger
}

// Warnf implements Logger.
func (logger logWrapper) Warnf(format string, args ...interface{}) {
	logger.Logger.Printf("[fiano][WARN] "+format, args...)
}

// Errorf implements Logger.
func (logger logWrapper) Errorf(format string, args ...interface{}) {
	logger.Logger.Printf("[fiano][ERROR] "+format, args...)
}

// Fatalf implements Logger.
func (logger logWrapper) Fatalf(format string, args ...interface{}) {
	logger.Logger.Fatalf("[fiano][FATAL] "+format, args...)
}

// Warnf logs an warning message.
func Warnf(format string, args ...interface{}) {
	DefaultLogger.Warnf(format, args...)
}

// Errorf logs an error message.
func Errorf(format string, args ...interface{}) {
	DefaultLogger.Errorf(format, args...)
}

// Fatalf logs a fatal message and immediately exits the application
// with os.Exit (which is expected to be called by the DefaultLogger.Fatalf).
func Fatalf(format string, args ...interface{}) {
	DefaultLogger.Fatalf(format, args...)
}

```

`pkg/uefi/biosregion.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"errors"
)

// BIOSPadding holds the padding in between firmware volumes
// This may sometimes hold data, even though it shouldn't. We need
// to preserve it though.
type BIOSPadding struct {
	buf    []byte
	Offset uint64

	// Metadata
	ExtractPath string
}

// NewBIOSPadding parses a sequence of bytes and returns a BIOSPadding
// object.
func NewBIOSPadding(buf []byte, offset uint64) (*BIOSPadding, error) {
	bp := &BIOSPadding{buf: buf, Offset: offset}
	return bp, nil
}

// Buf returns the buffer
func (bp *BIOSPadding) Buf() []byte {
	return bp.buf
}

// SetBuf sets the buffer
func (bp *BIOSPadding) SetBuf(buf []byte) {
	bp.buf = buf
}

// Apply a visitor to the BIOSPadding.
func (bp *BIOSPadding) Apply(v Visitor) error {
	return v.Visit(bp)
}

// ApplyChildren applies a visitor to all the direct children of the BIOSPadding
func (bp *BIOSPadding) ApplyChildren(v Visitor) error {
	return nil
}

// BIOSRegion represents the Bios Region in the firmware.
// It holds all the FVs as well as padding
type BIOSRegion struct {
	// holds the raw data
	buf      []byte
	Elements []*TypedFirmware `json:",omitempty"`

	// Metadata for extraction and recovery
	ExtractPath string
	Length      uint64
	// This is a pointer to the FlashRegion struct laid out in the ifd.
	FRegion    *FlashRegion
	RegionType FlashRegionType
}

// Type returns the flash region type.
func (br *BIOSRegion) Type() FlashRegionType {
	return RegionTypeBIOS
}

// SetFlashRegion sets the Flash Region.
func (br *BIOSRegion) SetFlashRegion(fr *FlashRegion) {
	br.FRegion = fr
}

// FlashRegion gets the Flash Region.
func (br *BIOSRegion) FlashRegion() (fr *FlashRegion) {
	return br.FRegion
}

// NewBIOSRegion parses a sequence of bytes and returns a Region
// object, if a valid one is passed, or an error. It also points to the
// Region struct uncovered in the ifd.
func NewBIOSRegion(buf []byte, r *FlashRegion, _ FlashRegionType) (Region, error) {
	br := BIOSRegion{FRegion: r, Length: uint64(len(buf)),
		RegionType: RegionTypeBIOS}
	var absOffset uint64

	// Copy the buffer
	if ReadOnly {
		br.buf = buf
	} else {
		br.buf = make([]byte, len(buf))
		copy(br.buf, buf)
	}

	for {
		offset := FindFirmwareVolumeOffset(buf)
		if offset < 0 {
			// no firmware volume found, stop searching
			// There shouldn't be padding near the end, but store it in case anyway
			if len(buf) != 0 {
				bp, err := NewBIOSPadding(buf, absOffset)
				if err != nil {
					return nil, err
				}
				br.Elements = append(br.Elements, MakeTyped(bp))
			}
			break
		}
		if offset > 0 {
			// There is some padding here, store it in case there is data.
			// We could check and conditionally store, but that makes things more complicated
			bp, err := NewBIOSPadding(buf[:offset], absOffset)
			if err != nil {
				return nil, err
			}
			br.Elements = append(br.Elements, MakeTyped(bp))
		}
		absOffset += uint64(offset)                                  // Find start of volume relative to bios region.
		fv, err := NewFirmwareVolume(buf[offset:], absOffset, false) // False as top level FVs are not resizable
		if err != nil {
			return nil, err
		}
		if fv.Length == 0 {
			//avoid infinite loop
			return nil, errors.New("FV len 0; cannot progress")
		}
		absOffset += fv.Length
		buf = buf[uint64(offset)+fv.Length:]
		br.Elements = append(br.Elements, MakeTyped(fv))
	}
	return &br, nil
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (br *BIOSRegion) Buf() []byte {
	return br.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (br *BIOSRegion) SetBuf(buf []byte) {
	br.buf = buf
}

// Apply calls the visitor on the BIOSRegion.
func (br *BIOSRegion) Apply(v Visitor) error {
	return v.Visit(br)
}

// ApplyChildren calls the visitor on each child node of BIOSRegion.
func (br *BIOSRegion) ApplyChildren(v Visitor) error {
	for _, f := range br.Elements {
		if err := f.Value.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// FirstFV finds the first firmware volume in the BIOSRegion.
func (br *BIOSRegion) FirstFV() (*FirmwareVolume, error) {
	for _, e := range br.Elements {
		if f, ok := e.Value.(*FirmwareVolume); ok {
			return f, nil
		}
	}
	return nil, errors.New("no firmware volumes in BIOS Region")
}

```

`pkg/uefi/file.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
)

// FVFileType represents the different types possible in an EFI file.
type FVFileType uint8

// UEFI FV File types.
const (
	FVFileTypeAll FVFileType = iota
	FVFileTypeRaw
	FVFileTypeFreeForm
	FVFileTypeSECCore
	FVFileTypePEICore
	FVFileTypeDXECore
	FVFileTypePEIM
	FVFileTypeDriver
	FVFileTypeCombinedPEIMDriver
	FVFileTypeApplication
	FVFileTypeSMM
	FVFileTypeVolumeImage
	FVFileTypeCombinedSMMDXE
	FVFileTypeSMMCore
	FVFileTypeSMMStandalone
	FVFileTypeSMMCoreStandalone
	FVFileTypeOEMMin   FVFileType = 0xC0
	FVFileTypeOEMMax   FVFileType = 0xDF
	FVFileTypeDebugMin FVFileType = 0xE0
	FVFileTypeDebugMax FVFileType = 0xEF
	FVFileTypePad      FVFileType = 0xF0
	FVFileTypeFFSMin   FVFileType = 0xF0
	FVFileTypeFFSMax   FVFileType = 0xFF
)

// SupportedFiles is a list of files types which will be parsed. File types not
// on this list are treated as opaque binary blobs.
var SupportedFiles = map[FVFileType]bool{
	// These are the file types that we'll actually try to parse sections for.
	FVFileTypeRaw:      false,
	FVFileTypeFreeForm: true,
	FVFileTypeSECCore:  true,
	FVFileTypePEICore:  true,
	FVFileTypeDXECore:  true,
	// TODO: Commenting out this line prevents PEI modules from being
	// decompressed. This solves the problem of PEI being too big when recompressed.
	//FVFileTypePEIM:               true,
	FVFileTypeDriver:             true,
	FVFileTypeCombinedPEIMDriver: true,
	FVFileTypeApplication:        true,
	FVFileTypeSMM:                true,
	FVFileTypeVolumeImage:        true,
	FVFileTypeCombinedSMMDXE:     true,
	FVFileTypeSMMCore:            true,
	FVFileTypeSMMStandalone:      true,
	FVFileTypeSMMCoreStandalone:  true,
}

var fileTypeNames = map[FVFileType]string{
	FVFileTypeRaw:                "EFI_FV_FILETYPE_RAW",
	FVFileTypeFreeForm:           "EFI_FV_FILETYPE_FREEFORM",
	FVFileTypeSECCore:            "EFI_FV_FILETYPE_SECURITY_CORE",
	FVFileTypePEICore:            "EFI_FV_FILETYPE_PEI_CORE",
	FVFileTypeDXECore:            "EFI_FV_FILETYPE_DXE_CORE",
	FVFileTypePEIM:               "EFI_FV_FILETYPE_PEIM",
	FVFileTypeDriver:             "EFI_FV_FILETYPE_DRIVER",
	FVFileTypeCombinedPEIMDriver: "EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER",
	FVFileTypeApplication:        "EFI_FV_FILETYPE_APPLICATION",
	FVFileTypeSMM:                "EFI_FV_FILETYPE_MM",
	FVFileTypeVolumeImage:        "EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE",
	FVFileTypeCombinedSMMDXE:     "EFI_FV_FILETYPE_COMBINED_MM_DXE",
	FVFileTypeSMMCore:            "EFI_FV_FILETYPE_MM_CORE",
	FVFileTypeSMMStandalone:      "EFI_FV_FILETYPE_MM_STANDALONE",
	FVFileTypeSMMCoreStandalone:  "EFI_FV_FILETYPE_MM_CORE_STANDALONE",
}

// NamesToFileType maps from common file type strings to the actual type.
var NamesToFileType map[string]FVFileType

func init() {
	NamesToFileType = make(map[string]FVFileType)
	for k, v := range fileTypeNames {
		NamesToFileType[strings.TrimPrefix(v, "EFI_FV_FILETYPE_")] = k
	}
}

// String creates a string representation for the file type.
func (f FVFileType) String() string {
	switch {
	case FVFileTypeOEMMin <= f && f <= FVFileTypeOEMMax:
		return fmt.Sprintf("EFI_FV_FILETYPE_OEM (%#x)", uint8(f))
	case FVFileTypeDebugMin <= f && f <= FVFileTypeDebugMax:
		return fmt.Sprintf("EFI_FV_FILETYPE_DEBUG (%#x)", uint8(f))
	// We use the non-inclusive '<' operator here because pad files belong
	// to the FFS filetype, but are also their own type.
	case FVFileTypeFFSMin < f && f <= FVFileTypeFFSMax:
		return fmt.Sprintf("EFI_FV_FILETYPE_FFS (%#x)", uint8(f))
	case f == FVFileTypePad:
		return "EFI_FV_FILETYPE_FFS_PAD"
	}
	if t, ok := fileTypeNames[f]; ok {
		return t
	}
	return "UNKNOWN"
}

// Stock GUIDS
var (
	ZeroGUID = guid.MustParse("00000000-0000-0000-0000-000000000000")
	FFGUID   = guid.MustParse("FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF")
)

// FileAlignments specifies the correct alignments based on the field in the file header.
var fileAlignments = []uint64{
	// These alignments are not computable, we have to look them up.
	1,
	16,
	128,
	512,
	1024,
	4 * 1024,
	32 * 1024,
	64 * 1024,
	128 * 1024,
	256 * 1024,
	512 * 1024,
	1024 * 1024,
	2 * 1024 * 1024,
	4 * 1024 * 1024,
	8 * 1024 * 1024,
	16 * 1024 * 1024,
}

const (
	// FileHeaderMinLength is the minimum length of a firmware file header.
	FileHeaderMinLength = 0x18
	// FileHeaderExtMinLength is the minimum length of an extended firmware file header.
	FileHeaderExtMinLength = 0x20
	// EmptyBodyChecksum is the value placed in the File IntegrityCheck field if the body checksum bit isn't set.
	EmptyBodyChecksum uint8 = 0xAA
)

// IntegrityCheck holds the two 8 bit checksums for the file header and body separately.
type IntegrityCheck struct {
	Header uint8
	File   uint8
}

type fileAttr uint8

// FileState (needs to be xored with Attributes.ErasePolarity)
type FileState uint8

// File State Bits
const (
	FileStateHeaderConstruction FileState = 0x01
	FileStateHeaderValid        FileState = 0x02
	FileStateDataValid          FileState = 0x04
	FileStateMarkeForUpdate     FileState = 0x08
	FileStateDeleted            FileState = 0x10
	FileStateHeaderInvalid      FileState = 0x20

	FileStateValid FileState = FileStateHeaderConstruction | FileStateHeaderValid | FileStateDataValid
)

type ThreeUint8 [3]uint8

func (t *ThreeUint8) UnmarshalJSON(b []byte) error {
	if copy(t[:], b) == 0 {
		return fmt.Errorf("cannot unmarshal 3 uint8 from %v", b)
	}
	return nil
}

func (t *ThreeUint8) MarshalJSON() ([]byte, error) {
	res := Read3Size(*t)
	return json.Marshal(res)
}

// FileHeader represents an EFI File header.
type FileHeader struct {
	GUID       guid.GUID      // This is the GUID of the file.
	Checksum   IntegrityCheck `json:"-"`
	Type       FVFileType
	Attributes fileAttr
	Size       ThreeUint8
	State      FileState
}

// IsLarge checks if the large file attribute is set.
func (a fileAttr) IsLarge() bool {
	return a&0x01 != 0
}

// GetAlignment returns the byte alignment specified by the file header.
func (a fileAttr) GetAlignment() uint64 {
	alignVal := (a & 0x38) >> 3
	alignVal |= (a & 0x02) << 2
	return fileAlignments[alignVal]
}

// Sets the large file attribute.
func (a *fileAttr) setLarge(large bool) {
	if large {
		*a |= 0x01
	} else {
		*a &= 0xFE
	}
}

// HasChecksum checks if we need to checksum the file body.
func (a fileAttr) HasChecksum() bool {
	return a&0x40 != 0
}

// SetState sets file state respecting erase polarity
func (fh *FileHeader) SetState(s FileState) {
	fh.State = s ^ FileState(Attributes.ErasePolarity)
}

// HeaderLen returns the length of the file header depending on the file size.
func (f *File) HeaderLen() uint64 {
	if f.Header.Attributes.IsLarge() {
		return FileHeaderExtMinLength
	}
	return FileHeaderMinLength
}

// ChecksumHeader returns a checksum of the header.
func (f *File) ChecksumHeader() uint8 {
	fh := f.Header
	headerSize := FileHeaderMinLength
	if fh.Attributes.IsLarge() {
		headerSize = FileHeaderExtMinLength
	}
	// Sum over header without State and IntegrityCheck.File.
	// To do that we just sum over the whole header and subtract.
	// UEFI PI Spec 3.2.3 EFI_FFS_FILE_HEADER
	sum := Checksum8(f.buf[:headerSize])
	sum -= fh.Checksum.File
	sum -= uint8(fh.State)
	return sum
}

// FileHeaderExtended represents an EFI File header with the
// large file attribute set.
// We also use this as the generic header for all EFI files, regardless of whether
// they are actually large. This makes it easier for us to just return one type
// All sizes are also copied into the ExtendedSize field so we only have to check once
type FileHeaderExtended struct {
	FileHeader
	ExtendedSize uint64 `json:"-"`
}

// File represents an EFI File.
type File struct {
	Header FileHeaderExtended
	Type   string

	// a File can contain either Sections or an NVarStore but not both
	Sections  []*Section `json:",omitempty"`
	NVarStore *NVarStore `json:",omitempty"`

	//Metadata for extraction and recovery
	buf         []byte
	ExtractPath string
	DataOffset  uint64
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (f *File) Buf() []byte {
	return f.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (f *File) SetBuf(buf []byte) {
	f.buf = buf
}

// Apply calls the visitor on the File.
func (f *File) Apply(v Visitor) error {
	return v.Visit(f)
}

// ApplyChildren calls the visitor on each child node of File.
func (f *File) ApplyChildren(v Visitor) error {
	if f.NVarStore != nil {
		if err := f.NVarStore.Apply(v); err != nil {
			return err
		}
		return nil
	}
	for _, s := range f.Sections {
		if err := s.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// SetSize sets the size into the File struct.
// If resizeFile is true, if the file is too large the file will be enlarged to make space
// for the ExtendedHeader
func (f *File) SetSize(size uint64, resizeFile bool) {
	fh := &f.Header
	// See if we need the extended size
	// Check if size > 3 bytes size field
	fh.ExtendedSize = size
	fh.Attributes.setLarge(false)
	if fh.ExtendedSize > 0xFFFFFF {
		// Can't fit, need extended header
		if resizeFile {
			// Increase the file size by the additional space needed
			// for the extended header.
			fh.ExtendedSize += FileHeaderExtMinLength - FileHeaderMinLength
		}
		fh.Attributes.setLarge(true)
	}
	// This will set size to 0xFFFFFF if too big.
	fh.Size = Write3Size(fh.ExtendedSize)
}

// ChecksumAndAssemble takes in the fileData and assembles the file binary
func (f *File) ChecksumAndAssemble(fileData []byte) error {
	// Checksum the header and body, then write out the header.
	// To checksum the header we write the temporary header to the file buffer first.
	fh := &f.Header

	header := new(bytes.Buffer)
	err := binary.Write(header, binary.LittleEndian, fh)
	if err != nil {
		return fmt.Errorf("unable to construct binary header of file %v, got %v",
			fh.GUID, err)
	}
	f.buf = header.Bytes()
	// We need to get rid of whatever it sums to so that the overall sum is zero
	// Sorry about the name :(
	fh.Checksum.Header -= f.ChecksumHeader()

	// Checksum the body
	fh.Checksum.File = EmptyBodyChecksum
	if fh.Attributes.HasChecksum() {
		// if the empty checksum had been set to 0 instead of 0xAA
		// this could have been a bit nicer. BUT NOOOOOOO.
		fh.Checksum.File = 0 - Checksum8(fileData)
	}

	// Write out the updated header to the buffer with the new checksums.
	// Write the extended header only if the large attribute flag is set.
	header = new(bytes.Buffer)
	if fh.Attributes.IsLarge() {
		err = binary.Write(header, binary.LittleEndian, fh)
	} else {
		err = binary.Write(header, binary.LittleEndian, fh.FileHeader)
	}
	if err != nil {
		return err
	}
	f.buf = header.Bytes()

	f.buf = append(f.buf, fileData...)
	return nil
}

// CreatePadFile creates an empty pad file in order to align the next file.
func CreatePadFile(size uint64) (*File, error) {
	if size < FileHeaderMinLength {
		return nil, fmt.Errorf("size too small! min size required is %#x bytes, requested %#x",
			FileHeaderMinLength, size)
	}

	f := File{}
	fh := &f.Header

	// Create empty guid
	if Attributes.ErasePolarity == 0xFF {
		fh.GUID = *FFGUID
	} else if Attributes.ErasePolarity == 0 {
		fh.GUID = *ZeroGUID
	} else {
		return nil, fmt.Errorf("erase polarity not 0x00 or 0xFF, got %#x", Attributes.ErasePolarity)
	}

	// TODO: I see examples of this where the attributes are just 0 and not dependent on the
	// erase polarity. Is that right? Check and handle.
	fh.Attributes = 0

	// Set the size. If the file is too big, we take up more of the padding for the header.
	// This also sets the large file attribute if file is big.
	f.SetSize(size, false)
	fh.Type = FVFileTypePad
	f.Type = fh.Type.String()

	// Create empty pad filedata based on size
	var fileData []byte
	fileData = make([]byte, size-FileHeaderMinLength)
	if fh.Attributes.IsLarge() {
		fileData = make([]byte, size-FileHeaderExtMinLength)
	}
	// Fill with empty bytes
	for i, dataLen := 0, len(fileData); i < dataLen; i++ {
		fileData[i] = Attributes.ErasePolarity
	}

	fh.SetState(FileStateValid)

	// Everything has been setup. Checksum and create.
	if err := f.ChecksumAndAssemble(fileData); err != nil {
		return nil, err
	}
	return &f, nil
}

// NewFile parses a sequence of bytes and returns a File
// object, if a valid one is passed, or an error. If no error is returned and the File
// pointer is nil, it means we've reached the volume free space at the end of the FV.
func NewFile(buf []byte) (*File, error) {
	f := File{}
	f.DataOffset = FileHeaderMinLength
	// Read in standard header.
	r := bytes.NewReader(buf)
	if err := binary.Read(r, binary.LittleEndian, &f.Header.FileHeader); err != nil {
		return nil, err
	}

	// Map type to string.
	f.Type = f.Header.Type.String()

	// TODO: Check Attribute flag as well. How important is the attribute flag? we already
	// have FFFFFF in the size
	if f.Header.Size == [3]uint8{0xFF, 0xFF, 0xFF} {
		// Extended Header
		if err := binary.Read(r, binary.LittleEndian, &f.Header.ExtendedSize); err != nil {
			return nil, err
		}
		if f.Header.ExtendedSize == 0xFFFFFFFFFFFFFFFF {
			// Start of free space
			// Note: this is not a pad file. Pad files also have valid headers.
			return nil, nil
		}
		f.DataOffset = FileHeaderExtMinLength
	} else {
		// Copy small size into big for easier handling.
		// Damn the 3 byte sizes.
		f.Header.ExtendedSize = Read3Size(f.Header.Size)
	}

	if buflen := len(buf); f.Header.ExtendedSize > uint64(buflen) {
		return nil, fmt.Errorf("File size too big! File with GUID: %v has length %v, but is only %v bytes big",
			f.Header.GUID, f.Header.ExtendedSize, buflen)
	}

	if ReadOnly {
		f.buf = buf[:f.Header.ExtendedSize]
	} else {
		// Copy out the buffer.
		newBuf := buf[:f.Header.ExtendedSize]
		f.buf = make([]byte, f.Header.ExtendedSize)
		copy(f.buf, newBuf)
	}

	// Special case for NVAR Store stored in raw file
	if f.Header.Type == FVFileTypeRaw && f.Header.GUID == *NVAR {
		if f.DataOffset >= uint64(len(f.buf)) {
			return nil, fmt.Errorf("data offset %#x exceeds buffer size %#x", f.DataOffset, len(f.buf))
		}
		ns, err := NewNVarStore(f.buf[f.DataOffset:])
		if err != nil {
			log.Errorf("error parsing NVAR store in file %v: %v", f.Header.GUID, err)
		}
		// Note that ns is nil if there was an error, so this assign is fine either way.
		f.NVarStore = ns
	}

	// Parse sections
	if !SupportedFiles[f.Header.Type] {
		return &f, nil
	}

	for i, offset := 0, f.DataOffset; offset < f.Header.ExtendedSize; i++ {
		s, err := NewSection(f.buf[offset:], i)
		if err != nil {
			return nil, fmt.Errorf("error parsing sections of file %v: %v", f.Header.GUID, err)
		}
		if s.Header.ExtendedSize == 0 {
			return nil, fmt.Errorf("invalid length of section of file %v", f.Header.GUID)
		}
		offset += uint64(s.Header.ExtendedSize)
		// Align to 4 bytes for now. The PI Spec doesn't say what alignment it should be
		// but UEFITool aligns to 4 bytes, and this seems to work on everything I have.
		offset = Align4(offset)
		f.Sections = append(f.Sections, s)
	}
	return &f, nil
}

```

`pkg/uefi/file_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"testing"
)

var (
	// File headers
	// Hardcoded checksums for testing :(
	// I don't know how to do it better without rewriting or calling code under test.
	emptyPadHeader = append(FFGUID[:],
		[]byte{8, EmptyBodyChecksum, byte(FVFileTypePad), 0, FileHeaderMinLength, 0x00, 0x00, 0xF8}...) // Empty pad file header with no data
	goodFreeFormHeader = append(FFGUID[:],
		[]byte{202, EmptyBodyChecksum, byte(FVFileTypeFreeForm), 0, FileHeaderMinLength, 0x00, 0x00, 0xF8}...) // Empty freeform file header with no data
)

var (
	// File examples
	emptyFile        = []byte{}       // nolint, Empty file
	emptyPadFile     = emptyPadHeader // Empty pad file with no data
	badFreeFormFile  []byte           // File with bad checksum. Should construct fine, but not validate
	goodFreeFormFile []byte           // Good file
)

func init() {
	goodFreeFormFile = append(goodFreeFormHeader, linuxSec...)
	goodFreeFormFile = append(goodFreeFormFile, smallSec...)
	goodFreeFormFile = append(goodFreeFormFile, []byte{0, 0}...) // Alignment
	goodFreeFormFile = append(goodFreeFormFile, tinySec...)
	goodFreeFormFile[20] = byte(FileHeaderMinLength + len(tinySec) + 2 + len(linuxSec) + len(smallSec))

	badFreeFormFile = make([]byte, len(goodFreeFormFile))
	copy(badFreeFormFile, goodFreeFormFile)
	badFreeFormFile[16] = 0 // Zero out checksum
}

func TestNewFile(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msg  string
	}{
		{"emptyFile", emptyFile, "EOF"},
		{"emptyPadFile", emptyPadFile, ""},
		{"badFreeFormFile", badFreeFormFile, ""},
		{"goodFreeFormFile", goodFreeFormFile, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewFile(test.buf)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
		})
	}
}

```

`pkg/uefi/firmwarevolume.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
)

// FirmwareVolume constants
const (
	FirmwareVolumeFixedHeaderSize  = 56
	FirmwareVolumeMinSize          = FirmwareVolumeFixedHeaderSize + 8 // +8 for the null block that terminates the block list
	FirmwareVolumeExtHeaderMinSize = 20
)

// Valid FV GUIDs
var (
	FFS1      = guid.MustParse("7a9354d9-0468-444a-81ce-0bf617d890df")
	FFS2      = guid.MustParse("8c8ce578-8a3d-4f1c-9935-896185c32dd3")
	FFS3      = guid.MustParse("5473c07a-3dcb-4dca-bd6f-1e9689e7349a")
	EVSA      = guid.MustParse("fff12b8d-7696-4c8b-a985-2747075b4f50")
	NVAR      = guid.MustParse("cef5b9a3-476d-497f-9fdc-e98143e0422c")
	EVSA2     = guid.MustParse("00504624-8a59-4eeb-bd0f-6b36e96128e0")
	AppleBoot = guid.MustParse("04adeead-61ff-4d31-b6ba-64f8bf901f5a")
	PFH1      = guid.MustParse("16b45da2-7d70-4aea-a58d-760e9ecb841d")
	PFH2      = guid.MustParse("e360bdba-c3ce-46be-8f37-b231e5cb9f35")
)

// FVGUIDs holds common FV type names
var FVGUIDs = map[guid.GUID]string{
	*FFS1:      "FFS1",
	*FFS2:      "FFS2",
	*FFS3:      "FFS3",
	*EVSA:      "NVRAM_EVSA",
	*NVAR:      "NVRAM_NVAR",
	*EVSA2:     "NVRAM_EVSA2",
	*AppleBoot: "APPLE_BOOT",
	*PFH1:      "PFH1",
	*PFH2:      "PFH2",
}

// These are the FVs we actually try to parse beyond the header
// We don't parse anything except FFS2 and FFS3
var supportedFVs = map[guid.GUID]bool{
	*FFS2: true,
	*FFS3: true,
}

// Block describes number and size of the firmware volume blocks
type Block struct {
	Count uint32
	Size  uint32
}

// FirmwareVolumeFixedHeader contains the fixed fields of a firmware volume
// header
type FirmwareVolumeFixedHeader struct {
	_               [16]uint8
	FileSystemGUID  guid.GUID
	Length          uint64
	Signature       uint32
	Attributes      uint32 // UEFI PI spec volume 3.2.1 EFI_FIRMWARE_VOLUME_HEADER
	HeaderLen       uint16
	Checksum        uint16
	ExtHeaderOffset uint16
	Reserved        uint8 `json:"-"`
	Revision        uint8
	// _               [3]uint8
}

// FirmwareVolumeExtHeader contains the fields of an extended firmware volume
// header
type FirmwareVolumeExtHeader struct {
	FVName        guid.GUID
	ExtHeaderSize uint32
}

// FirmwareVolume represents a firmware volume. It combines the fixed header and
// a variable list of blocks
type FirmwareVolume struct {
	FirmwareVolumeFixedHeader
	// there must be at least one that is zeroed and indicates the end of the
	// block list
	// We don't really have to care about blocks because we just read everything in.
	Blocks []Block
	FirmwareVolumeExtHeader
	Files []*File `json:",omitempty"`

	// Variables not in the binary for us to keep track of stuff/print
	DataOffset  uint64
	FVType      string `json:"-"`
	buf         []byte
	FVOffset    uint64 // Byte offset from start of BIOS region.
	ExtractPath string
	Resizable   bool   // Determines if this FV is resizable.
	FreeSpace   uint64 `json:"-"`
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fv *FirmwareVolume) Buf() []byte {
	return fv.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fv *FirmwareVolume) SetBuf(buf []byte) {
	fv.buf = buf
}

// Apply calls the visitor on the FirmwareVolume.
func (fv *FirmwareVolume) Apply(v Visitor) error {
	return v.Visit(fv)
}

// ApplyChildren calls the visitor on each child node of FirmwareVolume.
func (fv *FirmwareVolume) ApplyChildren(v Visitor) error {
	for _, f := range fv.Files {
		if err := f.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// GetErasePolarity gets the erase polarity
func (fv *FirmwareVolume) GetErasePolarity() uint8 {
	if fv.Attributes&0x800 != 0 {
		return 0xFF
	}
	return 0
}

// String creates a string representation for the firmware volume.
func (fv FirmwareVolume) String() string {
	if fv.ExtHeaderOffset != 0 {
		return fv.FVName.String()
	}
	return fv.FileSystemGUID.String()
}

// InsertFile appends the file to the end of the buffer according to alignment requirements.
func (fv *FirmwareVolume) InsertFile(alignedOffset uint64, fBuf []byte) error {
	// fv.Length should contain the minimum fv size.
	// If Resizable is not set, this is the exact FV size.
	bufLen := uint64(len(fv.buf))
	if bufLen > alignedOffset {
		return fmt.Errorf("aligned offset is in the middle of the FV, offset was %#x, fv buffer was %#x",
			alignedOffset, bufLen)
	}

	// add padding for alignment
	for i, num := uint64(0), alignedOffset-bufLen; i < num; i++ {
		fv.buf = append(fv.buf, Attributes.ErasePolarity)
	}

	// Check size
	fLen := uint64(len(fBuf))
	if fLen == 0 {
		return errors.New("trying to insert empty file")
	}
	// Overwrite old data in the firmware volume.
	fv.buf = append(fv.buf, fBuf...)
	return nil
}

// FindFirmwareVolumeOffset searches for a firmware volume signature, "_FVH"
// using 8-byte alignment. If found, returns the offset from the start of the
// bios region, otherwise returns -1.
func FindFirmwareVolumeOffset(data []byte) int64 {
	if len(data) < 32 {
		return -1
	}
	var (
		offset int64
		fvSig  = []byte("_FVH")
	)
	for offset = 32; offset+4 < int64(len(data)); offset += 8 {
		if bytes.Equal(data[offset:offset+4], fvSig) {
			return offset - 40 // the actual volume starts 40 bytes before the signature
		}
	}
	return -1
}

// NewFirmwareVolume parses a sequence of bytes and returns a FirmwareVolume
// object, if a valid one is passed, or an error
func NewFirmwareVolume(data []byte, fvOffset uint64, resizable bool) (*FirmwareVolume, error) {
	fv := FirmwareVolume{Resizable: resizable}

	if len(data) < FirmwareVolumeMinSize {
		return nil, fmt.Errorf("Firmware Volume size too small: expected %v bytes, got %v",
			FirmwareVolumeMinSize,
			len(data),
		)
	}
	reader := bytes.NewReader(data)
	if err := binary.Read(reader, binary.LittleEndian, &fv.FirmwareVolumeFixedHeader); err != nil {
		return nil, err
	}
	// read the block map
	blocks := make([]Block, 0)
	for {
		var block Block
		if err := binary.Read(reader, binary.LittleEndian, &block); err != nil {
			return nil, err
		}
		if block.Count == 0 && block.Size == 0 {
			// found the terminating block
			break
		}
		blocks = append(blocks, block)
	}
	fv.Blocks = blocks

	// Set the erase polarity
	if err := SetErasePolarity(fv.GetErasePolarity()); err != nil {
		return nil, err
	}

	// Boundary checks (to return an error instead of panicking)
	if fv.Length > uint64(len(data)) {
		return nil, fmt.Errorf("invalid FV length (is greater than the data length): %d > %d",
			fv.Length, len(data))
	}

	// Parse the extended header and figure out the start of data
	fv.DataOffset = uint64(fv.HeaderLen)
	if fv.ExtHeaderOffset != 0 &&
		fv.Length >= FirmwareVolumeExtHeaderMinSize &&
		uint64(fv.ExtHeaderOffset) < fv.Length-FirmwareVolumeExtHeaderMinSize {

		// jump to ext header offset.
		r := bytes.NewReader(data[fv.ExtHeaderOffset:])
		if err := binary.Read(r, binary.LittleEndian, &fv.FirmwareVolumeExtHeader); err != nil {
			return nil, fmt.Errorf("unable to parse FV extended header, got: %v", err)
		}
		// TODO: will the ext header ever end before the regular header? I don't believe so. Add a check?
		fv.DataOffset = uint64(fv.ExtHeaderOffset) + uint64(fv.ExtHeaderSize)
	}
	// Make sure DataOffset is 8 byte aligned at least.
	// TODO: handle alignment field in header.
	fv.DataOffset = Align8(fv.DataOffset)

	fv.FVType = FVGUIDs[fv.FileSystemGUID]
	fv.FVOffset = fvOffset

	if ReadOnly {
		fv.buf = data[:fv.Length]
	} else {
		// copy out the buffer.
		newBuf := data[:fv.Length]
		fv.buf = make([]byte, fv.Length)
		copy(fv.buf, newBuf)
	}

	// Parse the files.
	// TODO: handle fv data alignment.
	// Start from the end of the fv header.
	// Test if the fv type is supported.
	if _, ok := supportedFVs[fv.FileSystemGUID]; !ok {
		log.Warnf("unsupported fv type %v,%v not parsing it", fv.FileSystemGUID.String(), fv.FVType)
		return &fv, nil
	}
	lh := fv.Length - FileHeaderMinLength
	var prevLen uint64
	for offset := fv.DataOffset; offset < lh; offset += prevLen {
		offset = Align8(offset)
		if uint64(len(data)) <= offset {
			return nil, fmt.Errorf("offset %#x is beyond end of FV data (%#x)", offset, len(data))
		}
		file, err := NewFile(data[offset:])
		if err != nil {
			return nil, fmt.Errorf("unable to construct firmware file at offset %#x into FV: %v", offset, err)
		}
		if file == nil {
			// We've reached free space. Terminate
			fv.FreeSpace = fv.Length - offset
			break
		}
		fv.Files = append(fv.Files, file)
		prevLen = file.Header.ExtendedSize
		if prevLen == 0 {
			return nil, fmt.Errorf("invalid length of file at offset %#x", offset)
		}
	}
	return &fv, nil
}

```

`pkg/uefi/firmwarevolume_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"fmt"
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/log"
)

var (
	// FV examples
	emptyFV  = []byte{} // Empty file
	sampleFV []byte     // Sample FV from OVMF
)

func init() {
	var err error
	sampleFV, err = os.ReadFile("../../integration/roms/ovmfSECFV.fv")
	if err != nil {
		log.Fatalf("%v", err)
	}
}

func TestNewFirmwareVolume(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msg  string
	}{
		{"emptyFV", emptyFV, fmt.Sprintf("Firmware Volume size too small: expected %d bytes, got %d",
			FirmwareVolumeMinSize, len(emptyFV))},
		{"sampleFV", sampleFV, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewFirmwareVolume(test.buf, 0, false)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
		})
	}
}

```

`pkg/uefi/flash.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/hex"
	"errors"
	"fmt"
	"os"
	"sort"
)

// FlashSignature is the sequence of bytes that a Flash image is expected to
// start with.
var (
	FlashSignature = []byte{0x5a, 0xa5, 0xf0, 0x0f}
	ErrTooShort    = errors.New("too small to be firmware")
)

const (
	// FlashDescriptorLength represents the size of the descriptor region.
	FlashDescriptorLength = 0x1000
)

// FlashDescriptor is the main structure that represents an Intel Flash Descriptor.
type FlashDescriptor struct {
	// Holds the raw buffer
	buf                []byte
	DescriptorMapStart uint
	RegionStart        uint
	MasterStart        uint
	DescriptorMap      *FlashDescriptorMap
	Region             *FlashRegionSection
	Master             *FlashMasterSection

	//Metadata for extraction and recovery
	ExtractPath string
}

// FindSignature searches for an Intel flash signature.
func FindSignature(buf []byte) (int, error) {
	if len(buf) < 20 {
		return -1, ErrTooShort
	}
	if bytes.Equal(buf[16:16+len(FlashSignature)], FlashSignature) {
		// 16 + 4 since the descriptor starts after the signature
		return 20, nil
	}
	if len(buf) >= len(FlashSignature) && bytes.Equal(buf[:len(FlashSignature)], FlashSignature) {
		// + 4 since the descriptor starts after the signature
		return len(FlashSignature), nil
	}

	firstBytesCnt := 20
	if len(buf) < firstBytesCnt {
		firstBytesCnt = len(buf)
	}
	return -1, fmt.Errorf("flash signature not found: first %d bytes are:\n%s:%w",
		firstBytesCnt, hex.Dump(buf[:firstBytesCnt]), os.ErrNotExist)
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fd *FlashDescriptor) Buf() []byte {
	return fd.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fd *FlashDescriptor) SetBuf(buf []byte) {
	fd.buf = buf
}

// Apply calls the visitor on the FlashDescriptor.
func (fd *FlashDescriptor) Apply(v Visitor) error {
	return v.Visit(fd)
}

// ApplyChildren calls the visitor on each child node of FlashDescriptor.
func (fd *FlashDescriptor) ApplyChildren(v Visitor) error {
	return nil
}

// ParseFlashDescriptor parses the ifd from the buffer
func (fd *FlashDescriptor) ParseFlashDescriptor() error {
	if buflen := len(fd.buf); buflen != FlashDescriptorLength {
		return fmt.Errorf("flash descriptor length not %#x, was %#x", FlashDescriptorLength, buflen)
	}

	descriptorMapStart, err := FindSignature(fd.buf)
	if err != nil {
		return err
	}
	fd.DescriptorMapStart = uint(descriptorMapStart)

	// Descriptor Map
	desc, err := NewFlashDescriptorMap(fd.buf[fd.DescriptorMapStart:])
	if err != nil {
		return err
	}
	fd.DescriptorMap = desc

	// Region
	fd.RegionStart = uint(fd.DescriptorMap.RegionBase) * 0x10
	regionEnd := fd.RegionStart + uint(FlashRegionSectionSize)
	if buflen := uint(len(fd.buf)); fd.RegionStart >= buflen || regionEnd >= buflen {
		return fmt.Errorf("flash descriptor region out of bounds: range [%#x:%#x], buflen %#x", fd.RegionStart, regionEnd, buflen)
	}
	region, err := NewFlashRegionSection(fd.buf[fd.RegionStart:regionEnd])
	if err != nil {
		return err
	}
	fd.Region = region

	// Master
	fd.MasterStart = uint(fd.DescriptorMap.MasterBase) * 0x10
	master, err := NewFlashMasterSection(fd.buf[fd.MasterStart : fd.MasterStart+uint(FlashMasterSectionSize)])
	if err != nil {
		return err
	}
	fd.Master = master

	return nil
}

// FlashImage is the main structure that represents an Intel Flash image. It
// implements the Firmware interface.
type FlashImage struct {
	// Holds the raw buffer
	buf []byte
	// Holds the Flash Descriptor
	IFD FlashDescriptor
	// Actual regions
	Regions []*TypedFirmware `json:",omitempty"`

	// Metadata for extraction and recovery
	ExtractPath string
	FlashSize   uint64
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (f *FlashImage) Buf() []byte {
	return f.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (f *FlashImage) SetBuf(buf []byte) {
	f.buf = buf
}

// Apply calls the visitor on the FlashImage.
func (f *FlashImage) Apply(v Visitor) error {
	return v.Visit(f)
}

// ApplyChildren calls the visitor on each child node of FlashImage.
func (f *FlashImage) ApplyChildren(v Visitor) error {
	if err := f.IFD.Apply(v); err != nil {
		return err
	}
	for _, r := range f.Regions {
		if err := r.Value.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// IsPCH returns whether the flash image has the more recent PCH format, or not.
// PCH images have the first 16 bytes reserved, and the 4-bytes signature starts
// immediately after. Older images (ICH8/9/10) have the signature at the
// beginning.
// TODO: Check this. What if we have the signature in both places? I feel like the check
// should be IsICH because I expect the ICH to override PCH if the signature exists in 0:4
// since in that case 16:20 should be data. If that's the case, FindSignature needs to
// be fixed as well
func (f *FlashImage) IsPCH() bool {
	return bytes.Equal(f.buf[16:16+len(FlashSignature)], FlashSignature)
}

// FindSignature looks for the Intel flash signature, and returns its offset
// from the start of the image. The PCH images are located at offset 16, while
// in ICH8/9/10 they start at 0. If no signature is found, it returns -1.
func (f *FlashImage) FindSignature() (int, error) {
	return FindSignature(f.buf)
}

func (f *FlashImage) String() string {
	return fmt.Sprintf("FlashImage{Size=%v, Descriptor=%v, Region=%v, Master=%v}",
		len(f.buf),
		f.IFD.DescriptorMap.String(),
		f.IFD.Region.String(),
		f.IFD.Master.String(),
	)
}

func (f *FlashImage) fillRegionGaps() error {
	// Search for gaps and fill in with unknown regions
	offset := uint64(FlashDescriptorLength)
	var newRegions []*TypedFirmware
	for _, t := range f.Regions {
		r, _ := t.Value.(Region)
		nextBase := uint64(r.FlashRegion().BaseOffset())
		if nextBase < offset {
			// Something is wrong, overlapping regions
			// TODO: print a better error message describing what it overlaps with
			return fmt.Errorf("overlapping regions! region type %s overlaps with the previous region",
				r.Type().String())
		}
		if nextBase > offset {
			// There is a gap, create an unknown region
			tempFR := &FlashRegion{Base: uint16(offset / RegionBlockSize),
				Limit: uint16(nextBase/RegionBlockSize) - 1}
			newRegions = append(newRegions, MakeTyped(&RawRegion{buf: f.buf[offset:nextBase],
				FRegion:    tempFR,
				RegionType: RegionTypeUnknown}))
		}
		offset = uint64(r.FlashRegion().EndOffset())
		newRegions = append(newRegions, MakeTyped(r))
	}
	// check for the last region
	if offset != f.FlashSize {
		tempFR := &FlashRegion{Base: uint16(offset / RegionBlockSize),
			Limit: uint16(f.FlashSize/RegionBlockSize) - 1}
		newRegions = append(newRegions, MakeTyped(&RawRegion{buf: f.buf[offset:f.FlashSize],
			FRegion:    tempFR,
			RegionType: RegionTypeUnknown}))
	}
	f.Regions = newRegions
	return nil
}

// NewFlashImage tries to create a FlashImage structure, and returns a FlashImage
// and an error if any. This only works with images that operate in Descriptor
// mode.
func NewFlashImage(buf []byte) (*FlashImage, error) {
	if len(buf) < FlashDescriptorLength {
		return nil, fmt.Errorf("NewFlashImage: need at least %d bytes, only %d provided:%w", FlashDescriptorLength, len(buf), ErrTooShort)
	}
	f := FlashImage{FlashSize: uint64(len(buf))}

	// Copy out buffers
	f.buf = make([]byte, len(buf))
	copy(f.buf, buf)
	f.IFD.buf = make([]byte, FlashDescriptorLength)
	copy(f.IFD.buf, buf[:FlashDescriptorLength])

	if err := f.IFD.ParseFlashDescriptor(); err != nil {
		return nil, err
	}

	// FlashRegions is an array, make a slice to keep reference to it's content
	frs := f.IFD.Region.FlashRegions[:]

	// BIOS region has to be valid
	if !frs[RegionTypeBIOS].Valid() {
		return nil, fmt.Errorf("no BIOS region: invalid region parameters %v", frs[RegionTypeBIOS])
	}

	nr := int(f.IFD.DescriptorMap.NumberOfRegions)
	// Parse all the regions
	for i, fr := range frs {
		// Parse only a smaller number of regions if number of regions isn't 0
		// Number of regions is deprecated in newer IFDs and is just 0, older IFDs report
		// the number of regions and have falsely "valid" regions after that number.
		if nr != 0 && i >= nr {
			break
		}
		if !fr.Valid() {
			continue
		}
		if o := uint64(fr.BaseOffset()); o >= f.FlashSize {
			fmt.Printf("region %s (%d, %v) out of bounds: BaseOffset %#x, Flash size %#x, skipping...\n",
				flashRegionTypeNames[FlashRegionType(i)], i, fr, o, f.FlashSize)
			continue
		}
		if o := uint64(fr.EndOffset()); o > f.FlashSize {
			fmt.Printf("region %s (%d, %v) out of bounds: EndOffset %#x, Flash size %#x, skipping...\n",
				flashRegionTypeNames[FlashRegionType(i)], i, fr, o, f.FlashSize)
			continue
		}
		if c, ok := regionConstructors[FlashRegionType(i)]; ok {
			r, err := c(buf[fr.BaseOffset():fr.EndOffset()], &frs[i], FlashRegionType(i))
			if err != nil {
				return nil, err
			}
			f.Regions = append(f.Regions, MakeTyped(r))
		}
	}

	// Sort the regions by offset so we can look for gaps
	sort.Slice(f.Regions, func(i, j int) bool {
		ri := f.Regions[i].Value.(Region)
		rj := f.Regions[j].Value.(Region)
		return ri.FlashRegion().Base < rj.FlashRegion().Base
	})

	if err := f.fillRegionGaps(); err != nil {
		return nil, err
	}
	return &f, nil
}

```

`pkg/uefi/flash_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"encoding/hex"
	"errors"
	"os"
	"testing"
)

var (
	// Signature examples
	emptySig      = make([]byte, 40)                            // Empty flash signature
	ichSig        = append(FlashSignature, make([]byte, 20)...) // Old ICH version
	pchSig        = append(make([]byte, 16), FlashSignature...) // New PCH version
	misalignedSig = append(append(make([]byte, 10), FlashSignature...),
		make([]byte, 20)...) // Misaligned flash signature

	// FlashRegion Examples
	fr1 = FlashRegion{Base: 1, Limit: 1}
	fr2 = FlashRegion{Base: 2, Limit: 2}
	fr3 = FlashRegion{Base: 3, Limit: 3}
	// Region Examples
	rr1 = &RawRegion{FRegion: &fr1, RegionType: RegionTypeUnknown}
	br  = &BIOSRegion{FRegion: &fr2, RegionType: RegionTypeBIOS}
	rr2 = &RawRegion{FRegion: &fr3, RegionType: RegionTypeUnknown}
	// Empty buffer
	emptyFlashBuf = make([]byte, 0x4000)

	// FlashImage Region test examples
	trr1 = MakeTyped(rr1)
	trr2 = MakeTyped(rr2)
	tbr  = MakeTyped(br)
	f1   = FlashImage{buf: emptyFlashBuf, FlashSize: 0x4000, Regions: []*TypedFirmware{trr1, tbr, trr2}} // Full image
	f2   = FlashImage{buf: emptyFlashBuf, FlashSize: 0x4000, Regions: []*TypedFirmware{tbr, trr2}}       // Front gap
	f3   = FlashImage{buf: emptyFlashBuf, FlashSize: 0x4000, Regions: []*TypedFirmware{trr1, tbr}}       // Back gap
	f4   = FlashImage{buf: emptyFlashBuf, FlashSize: 0x4000, Regions: []*TypedFirmware{trr1, trr1}}      // Overlap!
	// Final result
	regions = []*TypedFirmware{trr1, tbr, trr2}
)

func TestFindSignature(t *testing.T) {
	var tests = []struct {
		name   string
		buf    []byte
		offset int
		err    error
	}{
		{"empty buffer", nil, -1, ErrTooShort},
		{"short buffer", []byte{1, 2, 3}, -1, ErrTooShort},
		{"empty signature", emptySig, -1, os.ErrNotExist},
		{"ichSign", ichSig, 4, nil},
		{"pchSig", pchSig, 20, nil},
		{"misaligned sig", misalignedSig, -1, os.ErrNotExist},
	}
	for _, test := range tests {
		f := FlashImage{buf: test.buf}
		offset, err := f.FindSignature()
		if offset != test.offset {
			t.Errorf("Offset was not correct, expected %v, got %v", test.offset, offset)
		}
		if !errors.Is(err, test.err) {
			t.Errorf("%s: got %v, want %v", test.name, err, test.err)
		}
	}
}

func TestIsPCH(t *testing.T) {
	var tests = []struct {
		buf []byte
		out bool
	}{
		{emptySig, false},
		{ichSig, false},
		{pchSig, true},
		{misalignedSig, false},
	}
	for _, test := range tests {
		f := FlashImage{buf: test.buf}
		out := f.IsPCH()
		if out != test.out {
			t.Errorf("IsPCH was not correct, expected %v, got %v for \n%s", test.out, out, hex.Dump(test.buf))
		}
	}
}

func TestFillRegionGaps(t *testing.T) {
	var tests = []struct {
		name string
		f    FlashImage
		out  []*TypedFirmware // expected output after gap filling
		msg  string           // Error message
	}{
		{"FullImage", f1, regions, ""},
		{"FrontRegionGap", f2, regions, ""},
		{"BackRegionGap", f3, regions, ""},
		{"OverlapRegion", f4, nil, "overlapping regions! region type Unknown Region (-1) overlaps with the previous region"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			err := test.f.fillRegionGaps()

			// Check error regions
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
			// for cases with no error
			if test.msg == "" {
				if len(test.out) != len(test.f.Regions) {
					t.Fatalf("Mismatched Region length! Expected %d regions, got %d", len(test.out), len(test.f.Regions))
				}
				for i := range test.out {
					ans := test.out[i].Value.(Region)
					reg := test.f.Regions[i].Value.(Region)
					if ans.Type() != reg.Type() {
						t.Errorf("Region type mismatch, expected \n%v\n got \n%v\n", ans.Type(), reg.Type())
					}
					afr := ans.FlashRegion()
					rfr := reg.FlashRegion()
					if afr.Base != rfr.Base {
						t.Errorf("Region base mismatch, expected \n%v\n got \n%v\n", afr.Base, rfr.Base)
					}
					if afr.Limit != rfr.Limit {
						t.Errorf("Region Limit mismatch, expected \n%v\n got \n%v\n", afr.Limit, rfr.Limit)
					}
				}
			}
		})
	}
}

```

`pkg/uefi/flashdescriptormap.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

const (
	// FlashDescriptorMapMaxBase is the maximum base address for a flash descriptor
	// region
	FlashDescriptorMapMaxBase = 0xe0

	// FlashDescriptorMapSize is the size in byte of the FlashDescriptorMap
	FlashDescriptorMapSize = 16
)

// FlashDescriptorMap represent an Intel flash descriptor. This object provides
// accessors to the various descriptor fields.
type FlashDescriptorMap struct {
	// FLMAP0
	ComponentBase      uint8
	NumberOfFlashChips uint8
	RegionBase         uint8
	NumberOfRegions    uint8
	// FLMAP1
	MasterBase        uint8
	NumberOfMasters   uint8
	PchStrapsBase     uint8
	NumberOfPchStraps uint8
	// FLMAP2
	ProcStrapsBase          uint8
	NumberOfProcStraps      uint8
	IccTableBase            uint8
	NumberOfIccTableEntries uint8
	// FLMAP3
	DmiTableBase            uint8
	NumberOfDmiTableEntries uint8
	Reserved0               uint8
	Reserved1               uint8
}

// NewFlashDescriptorMap initializes a FlashDescriptor from a slice of bytes.
func NewFlashDescriptorMap(buf []byte) (*FlashDescriptorMap, error) {
	r := bytes.NewReader(buf)
	var descriptor FlashDescriptorMap
	if err := binary.Read(r, binary.LittleEndian, &descriptor); err != nil {
		return nil, err
	}
	return &descriptor, nil
}

func (d *FlashDescriptorMap) String() string {
	return fmt.Sprintf("FlashDescriptorMap{NumberOfRegions=%v, NumberOfFlashChips=%v, NumberOfMasters=%v, NumberOfPCHStraps=%v, NumberOfProcessorStraps=%v, NumberOfICCTableEntries=%v, DMITableEntries=%v}",
		d.NumberOfRegions,
		d.NumberOfFlashChips,
		d.NumberOfMasters,
		d.NumberOfPchStraps,
		d.NumberOfProcStraps,
		d.NumberOfIccTableEntries,
		d.NumberOfDmiTableEntries,
	)
}

```

`pkg/uefi/flashmastersection.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"fmt"
)

// FlashMasterSectionSize is the size in bytes of the FlashMaster section
const FlashMasterSectionSize = 12

// RegionPermissions holds the read/write permissions for other regions.
type RegionPermissions struct {
	ID    uint16
	Read  uint8
	Write uint8
}

func (r *RegionPermissions) String() string {
	return fmt.Sprintf("RegionPermissions{ID=%v, Read=0x%x, Write=0x%x}",
		r.ID, r.Read, r.Write)
}

// FlashMasterSection holds all the IDs and read/write permissions for other regions
// This controls whether the bios region can read/write to the ME for example.
type FlashMasterSection struct {
	BIOS RegionPermissions
	ME   RegionPermissions
	GBE  RegionPermissions
}

func (m *FlashMasterSection) String() string {
	return fmt.Sprintf("FlashMasterSection{Bios %v, Me %v, Gbe %v}",
		m.BIOS, m.ME, m.GBE)
}

// NewFlashMasterSection parses a sequence of bytes and returns a FlashMasterSection
// object, if a valid one is passed, or an error
func NewFlashMasterSection(buf []byte) (*FlashMasterSection, error) {
	if len(buf) < FlashMasterSectionSize {
		return nil, fmt.Errorf("flash Master Section size too small: expected %v bytes, got %v",
			FlashMasterSectionSize,
			len(buf),
		)
	}
	var master FlashMasterSection
	reader := bytes.NewReader(buf)
	if err := binary.Read(reader, binary.LittleEndian, &master); err != nil {
		return nil, err
	}
	return &master, nil
}

```

`pkg/uefi/flashparams.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"fmt"
)

const (
	// FlashParamsSize is the size of a FlashParams struct
	FlashParamsSize = 4
)

// FlashFrequency is the type used for Frequency fields
type FlashFrequency uint

// Flash frequency constants
const (
	Freq20MHz      FlashFrequency = 0
	Freq33MHz      FlashFrequency = 1
	Freq48MHz      FlashFrequency = 2
	Freq50MHz30MHz FlashFrequency = 4
	Freq17MHz      FlashFrequency = 6
)

// FlashFrequencyStringMap maps frequency constants to strings
var FlashFrequencyStringMap = map[FlashFrequency]string{
	Freq20MHz:      "20MHz",
	Freq33MHz:      "33MHz",
	Freq48MHz:      "48MHz",
	Freq50MHz30MHz: "50Mhz30MHz",
	Freq17MHz:      "17MHz",
}

// FlashParams is a 4-byte object that holds the flash parameters information.
type FlashParams [4]byte

// FirstChipDensity returns the size of the first chip.
func (p *FlashParams) FirstChipDensity() uint {
	return uint(p[0] & 0x0f)
}

// SecondChipDensity returns the size of the second chip.
func (p *FlashParams) SecondChipDensity() uint {
	return uint((p[0] >> 4) & 0x0f)
}

// ReadClockFrequency returns the chip frequency while reading from the flash.
func (p *FlashParams) ReadClockFrequency() FlashFrequency {
	return FlashFrequency((p[2] >> 1) & 0x07)
}

// FastReadEnabled returns if FastRead is enabled.
func (p *FlashParams) FastReadEnabled() uint {
	return uint((p[2] >> 4) & 0x01)
}

// FastReadFrequency returns the frequency under FastRead.
func (p *FlashParams) FastReadFrequency() FlashFrequency {
	return FlashFrequency((p[2] >> 5) & 0x07)
}

// FlashWriteFrequency returns the chip frequency for writing.
func (p *FlashParams) FlashWriteFrequency() FlashFrequency {
	return FlashFrequency(p[3] & 0x07)
}

// FlashReadStatusFrequency returns the chip frequency while reading the flash status.
func (p *FlashParams) FlashReadStatusFrequency() FlashFrequency {
	return FlashFrequency((p[3] >> 3) & 0x07)
}

// DualOutputFastReadSupported returns if Dual Output Fast Read is supported.
func (p *FlashParams) DualOutputFastReadSupported() uint {
	return uint(p[3] >> 7)
}

func (p *FlashParams) String() string {
	return "FlashParams{...}"
}

// NewFlashParams initializes a FlashParam struct from a slice of bytes
func NewFlashParams(buf []byte) (*FlashParams, error) {
	if len(buf) != FlashParamsSize {
		return nil, fmt.Errorf("invalid image size: expected %v bytes, got %v",
			FlashParamsSize,
			len(buf),
		)
	}
	var p FlashParams
	copy(p[:], buf[0:FlashParamsSize])
	return &p, nil
}

```

`pkg/uefi/flashregionsection.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"strings"
)

// FlashRegionSectionSize is the size of the Region descriptor. It is made up by 16 fields, each 2x16-bits large.
const FlashRegionSectionSize = 64

// FlashRegionSection holds the metadata of all the different flash regions like PDR, Gbe and the Bios region.
type FlashRegionSection struct {
	_                   uint16
	FlashBlockEraseSize uint16

	// This isn't documented anywhere, but I've only seen images with 16 slots for FlashRegion entries, with the
	// FlashMasterSection coming immediately after, so I'm assuming that's the max for now.
	FlashRegions [15]FlashRegion
}

// ValidRegions returns a list of names of the regions with non-zero size.
func (f *FlashRegionSection) ValidRegions() []string {
	var regions []string
	for i, r := range f.FlashRegions {
		if r.Valid() {
			regions = append(regions, flashRegionTypeNames[FlashRegionType(i)])
		}
	}
	return regions
}

func (f *FlashRegionSection) String() string {
	return fmt.Sprintf("FlashRegionSection{Regions=%v}",
		strings.Join(f.ValidRegions(), ","),
	)
}

// NewFlashRegionSection initializes a FlashRegionSection from a slice of bytes
func NewFlashRegionSection(data []byte) (*FlashRegionSection, error) {
	if len(data) < FlashRegionSectionSize {
		return nil, fmt.Errorf("flash Region Section size too small: expected %v bytes, got %v",
			FlashRegionSectionSize,
			len(data),
		)
	}
	var region FlashRegionSection
	reader := bytes.NewReader(data)
	if err := binary.Read(reader, binary.LittleEndian, &region); err != nil {
		return nil, err
	}
	return &region, nil
}

```

`pkg/uefi/fuzz.go`:

```go
// Copyright 2020 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gofuzz

package uefi

import (
	"log"
)

// go get github.com/dvyukov/go-fuzz/go-fuzz
// go get github.com/dvyukov/go-fuzz/go-fuzz-build
//
// mkdir fuzz
// go-fuzz-build
// go-fuzz -bin uefi-fuzz.zip -workdir fuzz

type nopWriter struct{}

func (n *nopWriter) Write(_ []byte) (int, error) { return 0, nil }

func init() {
	//speed up logging
	log.SetFlags(0)
	log.SetOutput(&nopWriter{})
}

const (
	ICK int = iota - 1
	MEH
	WOW
)

// func Parse(buf []byte) (Firmware, error)
func Fuzz(b []byte) int {
	//initialize, since something could have changed the polarity
	Attributes = ROMAttributes{ErasePolarity: poisonedPolarity}
	_, err := Parse(b)
	if err == nil {
		return MEH
	}
	return WOW
}

```

`pkg/uefi/fuzz_test.go`:

```go
// Copyright 2020 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// SPDX-License-Identifier: BSD-3-Clause
//

package uefi

import (
	"archive/tar"
	"fmt"
	"io"
	"log"
	"os"
	fp "path/filepath"
	"testing"

	"github.com/ulikunitz/xz"
)

// no-op writer to minimize logging overhead
type nopWriter struct{}

func (n *nopWriter) Write(_ []byte) (int, error) { return 0, nil }

// Tests using input from fuzzing runs. Ignores any errors, just checks that the
// inputs do not cause crashes.
//
// To update the input zip after a fuzzing run:
// cd fuzz/corpus
// zip ../../testdata/fuzz_in.zip *
//
// Similarly, the zip can be extracted to use as input corpus. See fuzz.go for
// go-fuzz instructions.
func TestFuzzInputs(t *testing.T) {
	// if testing.CoverMode() != "" {
	// NOTE - since this test doesn't validate the outputs, coverage from
	// it is very low value, essentially inflating the coverage numbers.
	// t.Skip("this test will inflate coverage")
	// }

	// not available in go < 1.13
	// //restore log behavior at end
	// logOut := log.Writer()
	// defer log.SetOutput(logOut)

	//no logging output for this test, to increase speed
	log.SetOutput(&nopWriter{})
	log.SetFlags(0)

	txz, err := os.Open("testdata/fuzz_in.txz")
	if err != nil {
		t.Fatal(err)
	}
	defer txz.Close()
	x, err := xz.NewReader(txz)
	if err != nil {
		t.Fatal(err)
	}
	tr := tar.NewReader(x)
	for i := 0; ; i++ {
		zf, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			t.Error(err)
			continue
		}
		n := fp.Base(zf.Name)
		if len(n) > 10 {
			n = n[:10]
		} else {
			t.Logf("short: %s", n)
		}
		name := fmt.Sprintf("%03d_%s", i, n)
		t.Run(name, func(t *testing.T) {
			data, err := io.ReadAll(tr)
			if err != nil {
				t.Error(err)
			}
			//reset polarity before each run, some fuzz files change it
			Attributes = ROMAttributes{ErasePolarity: poisonedPolarity}
			//ignore any errors - just catch crashes
			_, _ = Parse(data)
		})
	}
}

```

`pkg/uefi/meregion.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/linuxboot/fiano/pkg/log"
)

// ME Partition parsing, the goal is to spot a padding in the ME Region
// after the ME partitions so that this region can be shrunk in the IFD.
//
// Information taken from multiple sources:
// https://web.archive.org/web/20200523203129/https://me.bios.io/ME_blob_format
// https://github.com/platomav/MEAnalyzer/
// https://fahrplan.events.ccc.de/congress/2017/Fahrplan/system/event_attachments/attachments/000/003/391/original/Intel_ME_myths_and_reality.pdf
// https://github.com/corna/me_cleaner/wiki/How-does-it-work%3F
// https://github.com/mostav02/Remove_IntelME_FPT
// https://io.netgarage.org/me/

// MEFPTSignature is the sequence of bytes that an ME Flash Partition
// Table is expected to start with ie "$FPT".
var (
	MEFPTSignature = []byte{0x24, 0x46, 0x50, 0x54}
)

const (
	// MEPartitionDescriptorMinLength is the min size of the descriptor
	MEPartitionDescriptorMinLength = 28
	// MEPartitionTableEntryLength is the size of a partition table entry
	MEPartitionTableEntryLength = 32
)

// MEFPT is the main structure that represents an ME Flash Partition Table.
type MEFPT struct {
	// Holds the raw buffer
	buf []byte

	PartitionCount    uint32
	PartitionMapStart int
	Entries           []MEPartitionEntry
	// Metadata for extraction and recovery
	ExtractPath string
}

// MEPartitionEntry is an entry in FTP
type MEPartitionEntry struct {
	Name     MEName
	Owner    [4]byte
	Offset   uint32
	Length   uint32
	Reserved [3]uint32
	Flags    uint32
}

// MEName represent 4 bytes with JSON string support
type MEName [4]byte

// MarshalText converts MEName to a byte range (for JSON)
func (n MEName) MarshalText() ([]byte, error) {
	return bytes.TrimRight(n[:], "\x00"), nil
}

// UnmarshalText converts a byte range to MEName (for JSON)
func (n *MEName) UnmarshalText(b []byte) error {
	var m MEName
	copy(m[:], b)
	*n = m
	if len(b) > len(m) {
		return fmt.Errorf("can’t unmarshal %q to MEName, %d > %d", b, len(b), len(m))
	}
	return nil
}

func (n MEName) String() string {
	b, _ := n.MarshalText()
	return string(b)
}

// OffsetIsValid returns true if the entry has a valid offset
func (e MEPartitionEntry) OffsetIsValid() bool {
	return e.Offset != 0 && e.Offset != 0xffffffff
}

var mePartitionEntryTypeNames = map[byte]string{0: "Code", 1: "Data", 2: "NVRAM", 3: "Generic", 4: "EFFS", 5: "ROM"}

// Type returns the type of the entry
func (e MEPartitionEntry) Type() string {
	t := byte(e.Flags & 0x7f)
	if s, ok := mePartitionEntryTypeNames[t]; ok {
		return s
	}
	return fmt.Sprintf("Unknown (%d)", t)
}

// FindMEDescriptor searches for an Intel ME FPT signature
func FindMEDescriptor(buf []byte) (int, error) {
	// In some images, the signature may occur right at the start,
	// in others, it occurs in the second 16 bytes, and
	// in some cases, it appears somewhere else in the ME region.
	// NOTE: This library excludes the signature from the descriptor.
	fptOffset := bytes.Index(buf, MEFPTSignature)
	if fptOffset >= 0 {
		return fptOffset + len(MEFPTSignature), nil
	}
	return -1, fmt.Errorf("ME Flash Partition Table signature %#02x not found", MEFPTSignature)
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fp *MEFPT) Buf() []byte {
	return fp.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (fp *MEFPT) SetBuf(buf []byte) {
	fp.buf = buf
}

// Apply calls the visitor on the MEFPT.
func (fp *MEFPT) Apply(v Visitor) error {
	return v.Visit(fp)
}

// ApplyChildren calls the visitor on each child node of MEFPT.
func (fp *MEFPT) ApplyChildren(v Visitor) error {
	return nil
}

// NewMEFPT tries to create a MEFPT
func NewMEFPT(buf []byte) (*MEFPT, error) {
	o, err := FindMEDescriptor(buf)
	if err != nil {
		return nil, err
	}
	if len(buf) < o+MEPartitionDescriptorMinLength {
		return nil, fmt.Errorf("ME section (%#x) too small for ME Flash Partition Table (%#x)", len(buf), o+MEPartitionDescriptorMinLength)
	}
	fp := &MEFPT{PartitionMapStart: o + MEPartitionDescriptorMinLength}
	r := bytes.NewReader(buf[o:])
	if err := binary.Read(r, binary.LittleEndian, &fp.PartitionCount); err != nil {
		return nil, err
	}
	l := fp.PartitionMapStart + MEPartitionTableEntryLength*int(fp.PartitionCount)
	if len(buf) < l {
		return nil, fmt.Errorf("ME section (%#x) too small for %d entries in ME Flash Partition Table (%#x)", len(buf), fp.PartitionCount, l)
	}

	fp.buf = make([]byte, l)
	copy(fp.buf, buf[:l])
	if err := fp.parsePartitions(); err != nil {
		return nil, err
	}
	return fp, nil
}

func (fp *MEFPT) parsePartitions() error {
	fp.Entries = make([]MEPartitionEntry, fp.PartitionCount)
	r := bytes.NewReader(fp.buf[fp.PartitionMapStart:])
	return binary.Read(r, binary.LittleEndian, fp.Entries)
}

// MERegion implements Region for a raw chunk of bytes in the firmware image.
type MERegion struct {
	FPT *MEFPT
	// holds the raw data
	buf []byte
	// Metadata for extraction and recovery
	ExtractPath string
	// This is a pointer to the FlashRegion struct laid out in the ifd.
	FRegion *FlashRegion
	// Region Type as per the IFD
	RegionType FlashRegionType
	// Computed free space after parsing the partition table
	FreeSpaceOffset uint64
}

// SetFlashRegion sets the flash region.
func (rr *MERegion) SetFlashRegion(fr *FlashRegion) {
	rr.FRegion = fr
}

// FlashRegion gets the flash region.
func (rr *MERegion) FlashRegion() (fr *FlashRegion) {
	return rr.FRegion
}

// NewMERegion creates a new region.
func NewMERegion(buf []byte, r *FlashRegion, rt FlashRegionType) (Region, error) {
	rr := &MERegion{FRegion: r, RegionType: rt}
	rr.buf = make([]byte, len(buf))
	copy(rr.buf, buf)
	fp, err := NewMEFPT(buf)
	if err != nil {
		log.Errorf("error parsing ME Flash Partition Table: %v", err)
		return rr, nil
	}
	rr.FPT = fp
	// Compute FreeSpaceOffset
	for _, p := range fp.Entries {
		if p.OffsetIsValid() {
			endOffset := uint64(p.Offset) + uint64(p.Length)
			if endOffset > rr.FreeSpaceOffset {
				rr.FreeSpaceOffset = endOffset
			}
		}
	}

	return rr, nil
}

// Type returns the flash region type.
func (rr *MERegion) Type() FlashRegionType {
	return RegionTypeME
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (rr *MERegion) Buf() []byte {
	return rr.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (rr *MERegion) SetBuf(buf []byte) {
	rr.buf = buf
}

// Apply calls the visitor on the MERegion.
func (rr *MERegion) Apply(v Visitor) error {
	return v.Visit(rr)
}

// ApplyChildren calls the visitor on each child node of MERegion.
func (rr *MERegion) ApplyChildren(v Visitor) error {
	if rr.FPT == nil {
		return nil
	}
	return rr.FPT.Apply(v)
}

```

`pkg/uefi/meregion_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"os"
	"reflect"
	"testing"
)

func TestMEName_MarshalText(t *testing.T) {
	var tests = []struct {
		name string
		me   MEName
	}{
		{"NAME", MEName{'N', 'A', 'M', 'E'}},
		{"NAM", MEName{'N', 'A', 'M', 0}},
		{"NA", MEName{'N', 'A', 0, 0}},
		{"N", MEName{'N', 0, 0, 0}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			b, err := test.me.MarshalText()
			if err != nil {
				t.Errorf("Unexpected error %v", err)
			}
			if string(b) != test.name {
				t.Errorf("error got %q want %q", b, test.name)
			}
		})
	}
}

func TestMEName_UnmarshalText(t *testing.T) {
	var tests = []struct {
		name string
		me   MEName
		msg  string
	}{
		{"NAME", MEName{'N', 'A', 'M', 'E'}, ""},
		{"NAM", MEName{'N', 'A', 'M', 0}, ""},
		{"NA", MEName{'N', 'A', 0, 0}, ""},
		{"N", MEName{'N', 0, 0, 0}, ""},
		{"NAME1", MEName{'N', 'A', 'M', 'E'}, "can’t unmarshal \"NAME1\" to MEName, 5 > 4"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			me := MEName{'F', 'U', 'L', 'L'}
			err := me.UnmarshalText([]byte(test.name))
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if !reflect.DeepEqual(me, test.me) {
				t.Errorf("error got %q want %q", me, test.me)
			}

		})
	}
}

func TestFindFPTSignature(t *testing.T) {
	var empty16 = make([]byte, 16)
	var empty12 = make([]byte, 12)
	var empty = make([]byte, 128)

	var firstRow = append(MEFPTSignature, empty12...)
	var secondRow = append(empty16, firstRow...)
	var elsewhere = append(empty, firstRow...)

	var tests = []struct {
		name string
		blob []byte
		res  int
	}{
		{"beginning", firstRow, 4},
		{"2nd row", secondRow, 20},
		{"elsewhere", elsewhere, 132},
		{"nowhere", empty, -1},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			r, e := FindMEDescriptor(test.blob)
			if r != test.res {
				t.Errorf("got position %d want %d (%q)", r, test.res, e)
			}
			if test.res == -1 && e == nil {
				t.Errorf("expected error")
			}
		})
	}
}

func TestParseFPT(t *testing.T) {
	t.Run("parse ME FPT", func(t *testing.T) {
		fixtureFile := "../../data/PurleySiliconBinPkg/MeFirmware/IgnitionFirmware/MeRegion.bin"
		meRegion, err := os.ReadFile(fixtureFile)
		if err != nil {
			t.Fatalf("could not read test fixture %q", fixtureFile)
		}
		expectedEntries := 10

		fpt, err := NewMEFPT(meRegion)
		if err != nil {
			t.Fatalf("reading ME FPT: got %v, want nil", err)
		}
		entries := len(fpt.Entries)
		if entries != expectedEntries {
			t.Errorf("len(fpt.Entries): got %d, want %d", entries, expectedEntries)
		}
		if entries != int(fpt.PartitionCount) {
			t.Errorf("fpt.PartitionCount: got %d, want %d (matching number of entries)", fpt.PartitionCount, entries)
		}
	})
}

```

`pkg/uefi/nvram.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// NVAR decoding logic ported from UEFITool Copyright (c) 2016, Nikolaj Schlej.
// https://github.com/LongSoft/UEFITool/blob/new_engine/common/nvramparser.cpp
// The author described his reverse engineering work on his blog:
// https://habr.com/en/post/281901/

package uefi

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/unicode"
)

// NVarAttribute represent Attributes
type NVarAttribute uint8

// Attributes
const (
	NVarEntryRuntime       NVarAttribute = 0x01
	NVarEntryASCIIName     NVarAttribute = 0x02
	NVarEntryGUID          NVarAttribute = 0x04
	NVarEntryDataOnly      NVarAttribute = 0x08
	NVarEntryExtHeader     NVarAttribute = 0x10
	NVarEntryHWErrorRecord NVarAttribute = 0x20
	NVarEntryAuthWrite     NVarAttribute = 0x40
	NVarEntryValid         NVarAttribute = 0x80
)

// IsValid returns the Valid attribute as boolean
func (a NVarAttribute) IsValid() bool {
	return a&NVarEntryValid != 0
}

// NVarEntrySignature value for 'NVAR' signature
const NVarEntrySignature uint32 = 0x5241564E

// NVarHeader represents an NVAR entry header
type NVarHeader struct {
	Signature  uint32 `json:"-"`
	Size       uint16
	Next       [3]uint8 `json:"-"`
	Attributes NVarAttribute
}

// NVarEntryType represent the computed type of an NVAR entry
type NVarEntryType uint8

// Types
const (
	InvalidNVarEntry NVarEntryType = iota
	InvalidLinkNVarEntry
	LinkNVarEntry
	DataNVarEntry
	FullNVarEntry
)

var nVarEntryTypeName = map[NVarEntryType]string{
	InvalidNVarEntry:     "Invalid",
	InvalidLinkNVarEntry: "Invalid link",
	LinkNVarEntry:        "Link",
	DataNVarEntry:        "Data",
	FullNVarEntry:        "Full",
}

func (t NVarEntryType) String() string {
	if s, ok := nVarEntryTypeName[t]; ok {
		return s
	}
	return "UNKNOWN"
}

// NVarExtAttribute represent extended attributes
type NVarExtAttribute uint8

// Extended attributes values
const (
	NVarEntryExtChecksum    NVarExtAttribute = 0x01
	NVarEntryExtAuthWrite   NVarExtAttribute = 0x10
	NVarEntryExtTimeBased   NVarExtAttribute = 0x20
	NVarEntryExtUnknownMask NVarExtAttribute = 0xCE
)

// NVar represent an NVAR entry
type NVar struct {
	Header    NVarHeader
	GUID      guid.GUID
	GUIDIndex *uint8 `json:",omitempty"`
	Name      string

	NVarStore *NVarStore `json:",omitempty"`

	//Decoded data
	Type       NVarEntryType
	Offset     uint64
	NextOffset uint64

	//Extended Header
	ExtAttributes               *NVarExtAttribute `json:",omitempty"`
	Checksum                    *uint8            `json:",omitempty"`
	ExpectedChecksum            *uint8            `json:",omitempty"`
	TimeStamp                   *uint64           `json:",omitempty"`
	Hash                        []byte            `json:",omitempty"`
	UnknownExtendedHeaderFormat bool              `json:",omitempty"`

	//Metadata for extraction and recovery
	buf         []byte
	ExtractPath string
	DataOffset  int64
	ExtOffset   int64 `json:",omitempty"`
}

// String returns the String value of the NVAR: Type and Name if valid
func (v *NVar) String() string {
	if v.IsValid() {
		return fmt.Sprintf("[%s] %v", v.Type, v.Name)
	}
	return fmt.Sprintf("[%s]", v.Type)
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (v *NVar) Buf() []byte {
	return v.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (v *NVar) SetBuf(buf []byte) {
	v.buf = buf
}

// Apply calls the visitor on the NVar.
func (v *NVar) Apply(vr Visitor) error {
	return vr.Visit(v)
}

// ApplyChildren calls the visitor on each child node of NVar.
func (v *NVar) ApplyChildren(vr Visitor) error {
	if v.NVarStore != nil {
		if err := v.NVarStore.Apply(vr); err != nil {
			return err
		}
	}
	return nil
}

// NVarStore represent an NVAR store
type NVarStore struct {
	Entries   []*NVar
	GUIDStore []guid.GUID `json:",omitempty"`

	//Metadata for extraction and recovery
	buf             []byte
	FreeSpaceOffset uint64
	GUIDStoreOffset uint64
	Length          uint64
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (s *NVarStore) Buf() []byte {
	return s.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (s *NVarStore) SetBuf(buf []byte) {
	s.buf = buf
}

// Apply calls the visitor on the NVarStore.
func (s *NVarStore) Apply(v Visitor) error {
	return v.Visit(s)
}

// ApplyChildren calls the visitor on each child node of NVarStore.
func (s *NVarStore) ApplyChildren(v Visitor) error {
	for _, nv := range s.Entries {
		if err := nv.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

func (s *NVarStore) getGUIDFromStore(i uint8) guid.GUID {
	var GUID guid.GUID
	if len(s.GUIDStore) < int(i+1) {
		// Read GUID in reverse order from the buffer
		r := bytes.NewReader(s.buf)
		if _, err := r.Seek(-int64(binary.Size(GUID))*int64(i+1), io.SeekEnd); err != nil {
			// not returning an error as this is really unlikely, in most
			// overflow case we will read NVAR content as GUID as the store
			// buffer is expected to be big enough...
			return *ZeroGUID
		}
		a := make([]guid.GUID, int(i+1)-len(s.GUIDStore))
		for j := int(i) - len(s.GUIDStore); j >= 0; j-- {
			// no error check as the Seek will fail first
			if err := binary.Read(r, binary.LittleEndian, &a[j]); err != nil {
				break
			}
		}
		s.GUIDStore = append(s.GUIDStore, a...)
	}
	if int(i) >= len(s.GUIDStore) {
		return *ZeroGUID
	}
	return s.GUIDStore[i]
}

func (v *NVar) parseHeader(buf []byte) error {
	// Read in standard header.
	r := bytes.NewReader(buf)
	if err := binary.Read(r, binary.LittleEndian, &v.Header); err != nil {
		return err
	}
	if v.Header.Signature != NVarEntrySignature {
		return fmt.Errorf("NVAR Signature not found")
	}
	if len(buf) < int(v.Header.Size) {
		return fmt.Errorf("NVAR Size bigger than remaining size")
	}
	v.DataOffset = int64(binary.Size(v.Header))
	return nil
}

// IsValid tells whether an entry is valid
func (v *NVar) IsValid() bool {
	switch v.Type {
	case LinkNVarEntry, DataNVarEntry, FullNVarEntry:
		return true
	default:
		return false
	}
}

func (v *NVar) parseNext() error {
	var lastVariableFlag uint64
	if Attributes.ErasePolarity == 0xFF {
		lastVariableFlag = 0xFFFFFF
	} else if Attributes.ErasePolarity == 0 {
		lastVariableFlag = 0
	} else {
		return fmt.Errorf("erase polarity not 0x00 or 0xFF, got %#x", Attributes.ErasePolarity)
	}

	// Add next node information
	next := Read3Size(v.Header.Next)
	if next != lastVariableFlag {
		v.Type = LinkNVarEntry
		v.NextOffset = v.Offset + next
	}
	return nil
}

func (v *NVar) parseExtendedHeader() error {
	var knownExtDataFormat bool
	if v.Header.Attributes&NVarEntryExtHeader == 0 {
		return nil
	}
	var extendedHeaderSize uint16
	r := bytes.NewReader(v.buf)
	if _, err := r.Seek(-int64(binary.Size(extendedHeaderSize)), io.SeekEnd); err != nil {
		return err
	}
	if err := binary.Read(r, binary.LittleEndian, &extendedHeaderSize); err != nil {
		return err
	}
	// Sanity check extendedHeaderSize < body size
	bodySize := int64(v.Header.Size) - v.DataOffset
	if int64(extendedHeaderSize) > bodySize {
		return fmt.Errorf("extended header size (%#x) is greater than body size (%#x)", extendedHeaderSize, bodySize)
	}
	v.ExtOffset = int64(v.Header.Size) - int64(extendedHeaderSize)
	if _, err := r.Seek(v.ExtOffset, io.SeekStart); err != nil {
		return err
	}
	var extAttributes NVarExtAttribute
	if err := binary.Read(r, binary.LittleEndian, &extAttributes); err != nil {
		return err
	}
	v.ExtAttributes = &extAttributes
	// Variable with checksum
	if extAttributes&NVarEntryExtChecksum != 0 {
		// Get stored checksum
		var storedChecksum uint8
		storedChecksum = v.buf[int64(v.Header.Size)-int64(binary.Size(extendedHeaderSize)+binary.Size(storedChecksum))]
		v.Checksum = &storedChecksum
		// Recalculate checksum for the variable
		calculatedChecksum := uint8(0)
		// [0-3] _Skip_  entry 'NVAR' signature
		// [4-5] Include entry size and flags
		// [6-8] _Skip_  entry next (So linking will not invalidate the sum)
		// [ 9 ] Include entry attributes
		// [10-] Include entry data
		for i := int64(4); i < int64(v.Header.Size); i++ {
			calculatedChecksum += v.buf[i]
			if i == 5 {
				i += 3 // Skip Next
			}
		}
		if calculatedChecksum != 0 {
			calculatedChecksum = -calculatedChecksum
			v.ExpectedChecksum = &calculatedChecksum
		}
		knownExtDataFormat = true
	}

	if v.Header.Attributes&NVarEntryAuthWrite == 0 {
		var timestamp uint64
		if err := binary.Read(r, binary.LittleEndian, &timestamp); err != nil {
			switch err {
			case io.EOF, io.ErrUnexpectedEOF:
				return fmt.Errorf("extended header size (%#x) is too small for timestamp", extendedHeaderSize)
			default:
				return err
			}
		}
		if v.Header.Attributes&NVarEntryDataOnly != 0 {
			// Full or link variable have hash
			hashstart, err := r.Seek(0, io.SeekCurrent)
			if err != nil {
				return err
			}
			if hashstart+sha256.Size > int64(v.Header.Size) {
				return fmt.Errorf("extended header size (%#x) is too small for hash", extendedHeaderSize)
			}
			v.Hash = make([]byte, sha256.Size)
			copy(v.Hash, v.buf[hashstart:hashstart+sha256.Size])
		}
		knownExtDataFormat = true
	}
	v.UnknownExtendedHeaderFormat = !knownExtDataFormat
	return nil
}

func (v *NVar) parseDataOnly(s *NVarStore) bool {
	if v.Header.Attributes&NVarEntryDataOnly == 0 {
		return false
	}
	// Search previously added entries for a link to this variable
	// Note: We expect links to be from previous to new entries as links
	// are used to replace the values while keeping the Name and GUID.
	// TODO: fix if we ever met legitimate rom that defeat this assumption.
	var link *NVar
	for _, l := range s.Entries {
		if l.IsValid() && l.NextOffset == v.Offset {
			link = l
			break
		}
	}
	if link != nil {
		v.GUID = link.GUID
		v.Name = link.Name
		if v.NextOffset == 0 {
			v.Type = DataNVarEntry
		}
	} else {
		v.Name = "Invalid link"
		v.Type = InvalidLinkNVarEntry
	}

	return true
}

func (v *NVar) parseGUID(s *NVarStore) error {
	r := bytes.NewReader(v.buf[v.DataOffset:])
	if v.Header.Attributes&NVarEntryGUID != 0 {
		// GUID in variable
		if err := binary.Read(r, binary.LittleEndian, &v.GUID); err != nil {
			return err
		}
		v.DataOffset += int64(binary.Size(v.GUID))
	} else {
		// GUID index in store
		var guidIndex uint8
		if err := binary.Read(r, binary.LittleEndian, &guidIndex); err != nil {
			return err
		}
		v.GUIDIndex = &guidIndex
		v.GUID = s.getGUIDFromStore(guidIndex)
		v.DataOffset += int64(binary.Size(guidIndex))
	}
	return nil
}

func (v *NVar) parseName() error {
	if v.Header.Attributes&NVarEntryASCIIName != 0 {
		// Name is stored as ASCII string of CHAR8s
		namebuf := v.buf[v.DataOffset:]
		end := bytes.IndexByte(namebuf, 0)
		if end == -1 {
			return io.EOF
		}
		v.Name = string(namebuf[:end])
		v.DataOffset += int64(end) + 1
	} else {
		// Name is stored as UCS2 string of CHAR16s
		namebuf := v.buf[v.DataOffset:]
		end := bytes.Index(namebuf, []byte{0, 0})
		if end == -1 {
			return io.EOF
		}
		v.Name = unicode.UCS2ToUTF8(namebuf[:end])
		v.DataOffset += int64(end) + 2
	}
	return nil
}

func (v *NVar) parseContent(buf []byte) error {
	// Try parsing as NVAR storage if it begins with NVAR signature
	r := bytes.NewReader(buf)
	var signature uint32
	if err := binary.Read(r, binary.LittleEndian, &signature); err != nil {
		return err
	}
	if signature != NVarEntrySignature {
		return fmt.Errorf("NVAR Signature not found")
	}
	ns, err := NewNVarStore(buf)
	if err != nil {
		return fmt.Errorf("error parsing NVAR store in var %v: %v", v.Name, err)
	}
	v.NVarStore = ns
	return nil
}

// newNVar parses a sequence of bytes and returns an NVar
// object, if a valid one is passed, returns nil if buf is clear, or an error.
func newNVar(buf []byte, offset uint64, s *NVarStore) (*NVar, error) {
	// Check if remaining space is erased
	if IsErased(buf, Attributes.ErasePolarity) {
		return nil, nil
	}

	v := NVar{Type: FullNVarEntry, Offset: offset}
	// read the header and check for existing NVAR
	if err := v.parseHeader(buf); err != nil {
		return nil, err
	}

	// Copy out the buffer.
	newBuf := buf[:v.Header.Size]
	v.buf = make([]byte, v.Header.Size)
	copy(v.buf, newBuf)

	// Entry is marked as invalid
	if !v.Header.Attributes.IsValid() {
		v.Name = "Invalid"
		v.Type = InvalidNVarEntry
		return &v, nil
	}

	// Parse next node information
	if err := v.parseNext(); err != nil {
		return nil, err
	}

	// Entry with extended header
	if err := v.parseExtendedHeader(); err != nil {
		v.Name = fmt.Sprintf("Invalid ExtHeader, %v", err)
		v.Type = InvalidNVarEntry
		return &v, nil
	}

	// Entry is data-only (nameless and GUIDless entry or link)
	if !v.parseDataOnly(s) {
		// Get entry name and GUID
		if err := v.parseGUID(s); err != nil {
			return nil, err
		}
		if err := v.parseName(); err != nil {
			return nil, err
		}
	}

	// Try parsing the entry content
	_ = v.parseContent(v.buf[v.DataOffset:])

	return &v, nil
}

// Assemble takes in the content and assembles the NVAR binary
// Warning: when checkOnly is false the resulting NVar must be Assembled again
// to fix the header content
func (v *NVar) Assemble(content []byte, checkOnly bool) error {
	if !v.IsValid() {
		return errors.New("unable to construct Invalid NVAR")
	}
	vData := new(bytes.Buffer)
	v.Header.Signature = NVarEntrySignature
	if v.NextOffset != 0 && !checkOnly {
		return errors.New("unable to update data in link, use compact first")
	}
	if v.NextOffset != 0 {
		v.Header.Next = Write3Size(v.NextOffset - v.Offset)
	} else {
		v.Header.Next = [3]uint8{Attributes.ErasePolarity, Attributes.ErasePolarity, Attributes.ErasePolarity}
	}
	err := binary.Write(vData, binary.LittleEndian, v.Header)
	if err != nil {
		return fmt.Errorf("unable to construct binary header of NVAR: got %v", err)
	}
	// GUID
	if v.Header.Attributes&NVarEntryDataOnly == 0 {
		if v.Header.Attributes&NVarEntryGUID != 0 {
			err := binary.Write(vData, binary.LittleEndian, v.GUID)
			if err != nil {
				return fmt.Errorf("unable to add GUID to NVAR: got %v", err)
			}
		} else {
			err := binary.Write(vData, binary.LittleEndian, *v.GUIDIndex)
			if err != nil {
				return fmt.Errorf("unable to add GUID index to NVAR: got %v", err)
			}
		}
		// Name
		if v.Header.Attributes&NVarEntryASCIIName != 0 {
			_, err := vData.Write([]byte(v.Name))
			if err != nil {
				return fmt.Errorf("unable to add Name to NVAR: got %v", err)
			}
			err = vData.WriteByte(0)
			if err != nil {
				return fmt.Errorf("unable to add Name to NVAR: got %v", err)
			}
		} else {
			_, err := vData.Write(unicode.UTF8ToUCS2(v.Name))
			if err != nil {
				return fmt.Errorf("unable to add Name to NVAR: got %v", err)
			}
		}
	}
	//check/update DataOffset
	if checkOnly {
		if v.DataOffset != int64(vData.Len()) {
			return fmt.Errorf("NVAR header size mismatch, expected %v got %v", v.DataOffset, vData.Len())
		}
	} else {
		v.DataOffset = int64(vData.Len())
	}
	_, err = vData.Write(content)
	if err != nil {
		return fmt.Errorf("unable to add content to NVAR: got %v", err)
	}
	//check/update Header.Size
	if checkOnly {
		if v.Header.Size != uint16(vData.Len()) {
			return fmt.Errorf("NVAR size mismatch, expected %v got %v", v.Header.Size, vData.Len())
		}
	} else {
		v.Header.Size = uint16(vData.Len())
	}
	v.SetBuf(vData.Bytes())
	return nil
}

// NewNVarStore parses a sequence of bytes and returns an NVarStore
// object, if a valid one is passed, or an error.
func NewNVarStore(buf []byte) (*NVarStore, error) {
	s := NVarStore{}

	// Copy out the buffer.
	s.buf = make([]byte, len(buf))
	copy(s.buf, buf)

	s.Length = uint64(len(buf))
	s.GUIDStoreOffset = s.Length

	for s.FreeSpaceOffset = uint64(0); s.FreeSpaceOffset < s.GUIDStoreOffset; {
		v, err := newNVar(s.buf[s.FreeSpaceOffset:s.GUIDStoreOffset], s.FreeSpaceOffset, &s)
		if err != nil {
			return nil, fmt.Errorf("error parsing NVAR entry at offset %#x: %v", s.FreeSpaceOffset, err)
		}
		if v == nil {
			break
		}
		s.Entries = append(s.Entries, v)
		s.FreeSpaceOffset += uint64(v.Header.Size)
		s.GUIDStoreOffset = s.Length - uint64(binary.Size(guid.GUID{}))*uint64(len(s.GUIDStore))
	}

	return &s, nil
}

// GetGUIDStoreBuf returns the binary representation of the GUIDStore
func (s *NVarStore) GetGUIDStoreBuf() ([]byte, error) {
	guidStoreWBuf := new(bytes.Buffer)
	for i := len(s.GUIDStore) - 1; i >= 0; i-- {
		err := binary.Write(guidStoreWBuf, binary.LittleEndian, s.GUIDStore[i])
		if err != nil {
			return nil, fmt.Errorf("unable to write GUID index to store: got %v", err)
		}
	}
	return guidStoreWBuf.Bytes(), nil
}

```

`pkg/uefi/nvram_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/hex"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
)

func TestNVarAttribute_IsValid(t *testing.T) {
	var tests = []struct {
		name string
		attr NVarAttribute
		res  bool
	}{
		{"zero", NVarAttribute(0), false},
		{"validOnly", NVarEntryValid, true},
		{"NotValid", NVarEntryValid ^ 0xff, false},
		{"ff", NVarAttribute(0xff), true},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if res := test.attr.IsValid(); res != test.res {
				t.Errorf("IsValid wrong result!, input was %#x, wanted %v, got %v", test.attr, test.res, res)
			}
		})
	}
}

var (
	// Small buffs to reuse
	emptyNVarBuf       = []byte{}
	erasedSmallNVarBuf = []byte{0xFF, 0xFF, 0xFF, 0xFF}
	zeroed16NVarBuf    = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	erased16NVarBuf    = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
	signatureNVarBuf   = []byte{0x4E, 0x56, 0x41, 0x52}
	noNextNVarBuf      = []byte{0xFF, 0xFF, 0xFF}
)
var (
	// Header & NVar Tests
	headerOnlyEmptyNVar      = append(append(append(signatureNVarBuf[:], []byte{10, 0}...), noNextNVarBuf...), byte(NVarEntryValid|NVarEntryDataOnly))
	badIncompleteNVar        = append(append(append(signatureNVarBuf[:], []byte{11, 0}...), noNextNVarBuf...), byte(NVarEntryValid|NVarEntryDataOnly))
	invalidNVar              = append(append(append(signatureNVarBuf[:], []byte{10, 0}...), noNextNVarBuf...), byte(0))
	badMissingGUIDNVar       = append(append(append(signatureNVarBuf[:], []byte{10, 0}...), noNextNVarBuf...), byte(NVarEntryValid|NVarEntryASCIIName))
	badMissingNameEndNVAR    = append(append(append(signatureNVarBuf[:], []byte{15, 0}...), noNextNVarBuf...), []byte{byte(NVarEntryValid | NVarEntryASCIIName), 0, byte('T'), byte('e'), byte('s'), byte('t')}...)
	stored0GUIDASCIINameNVar = append(append(append(signatureNVarBuf[:], []byte{16, 0}...), noNextNVarBuf...), []byte{byte(NVarEntryValid | NVarEntryASCIIName), 0, byte('T'), byte('e'), byte('s'), byte('t'), 0}...)
	stored1GUIDASCIINameNVar = append(append(append(signatureNVarBuf[:], []byte{16, 0}...), noNextNVarBuf...), []byte{byte(NVarEntryValid | NVarEntryASCIIName), 1, byte('T'), byte('e'), byte('s'), byte('t'), 0}...)
)
var (
	testNVarStore = append(append(headerOnlyEmptyNVar, stored0GUIDASCIINameNVar...), erased16NVarBuf...)
)

func TestNVar_parseHeader(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msg  string
	}{
		{"emptyNVarBuf", emptyNVarBuf, "EOF"},
		{"erasedSmallNVarBuf", erasedSmallNVarBuf, "unexpected EOF"},
		{"erased16NVarBuf", erased16NVarBuf, "NVAR Signature not found"},
		{"badIncompleteNVar", badIncompleteNVar, "NVAR Size bigger than remaining size"},
		{"goodEmptyNVar", headerOnlyEmptyNVar, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var v NVar
			err := v.parseHeader(test.buf)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err == nil && v.DataOffset != 10 {
				t.Errorf("Invalid DataOffset, expected 10 got %v", v.DataOffset)
			}
		})
	}
}

const NoNVarEntry NVarEntryType = 0xFF

func TestNewNVar_noStore(t *testing.T) {
	var tests = []struct {
		name       string
		buf        []byte
		msg        string
		t          NVarEntryType
		DataOffset int64
	}{
		{"emptyNVarBuf", emptyNVarBuf, "", NoNVarEntry, 0},
		{"erasedSmallNVarBuf", erasedSmallNVarBuf, "", NoNVarEntry, 0},
		{"erased16NVarBuf", erased16NVarBuf, "", NoNVarEntry, 0},
		{"badIncompleteNVar", badIncompleteNVar, "NVAR Size bigger than remaining size", InvalidNVarEntry, 10},
		{"goodEmptyNVar", headerOnlyEmptyNVar, "", InvalidLinkNVarEntry, 10},
		{"invalidNVar", invalidNVar, "", InvalidNVarEntry, 10},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var s NVarStore
			Attributes.ErasePolarity = 0xFF
			v, err := newNVar(test.buf, 0, &s)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err != nil {
				// expected error
				return
			}
			if test.t == NoNVarEntry {
				if v != nil {
					t.Errorf("No NVar expected got \n%v\n", v)

				}
				return
			} else if v == nil {
				t.Error("No NVar returned")
				return

			}

			if v.Type != test.t {
				t.Errorf("Invalid Type, expected %v got %v", test.t, v.Type)
			}
			if v.DataOffset != test.DataOffset {
				t.Errorf("Invalid DataOffset, expected %v got %v", test.DataOffset, v.DataOffset)
			}
		})
	}
}

func TestNewNVar_ErasePolarity(t *testing.T) {
	var tests = []struct {
		name string
		ep   byte
		msg  string
	}{
		{"ErasePolarity", 0xF0, "erase polarity not 0x00 or 0xFF, got 0xf0"},
		{"ErasePolarity", 0x00, ""},
		{"ErasePolarity", 0xFF, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var s NVarStore
			Attributes.ErasePolarity = test.ep
			v, err := newNVar(headerOnlyEmptyNVar, 0, &s)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err == nil && v == nil {
				t.Error("No NVar returned")
			}
		})
	}
}

func TestNewNVar_Store(t *testing.T) {
	var tests = []struct {
		name       string
		offset     uint64
		buf        []byte
		msg        string
		t          NVarEntryType
		DataOffset int64
		GUID       *guid.GUID
		Name       string
	}{
		{"goodEmptyNVar", 123, headerOnlyEmptyNVar, "", DataNVarEntry, 10, guid.MustParse("2df19db9-a1b4-4b02-b4bb-5ddb4866e13f"), "Stored"},
		{"badMissingGUIDNVar", 0, badMissingGUIDNVar, "EOF", FullNVarEntry, 16, nil, ""},
		{"badMissingNameEndNVAR", 0, badMissingNameEndNVAR, "EOF", FullNVarEntry, 15, nil, ""},
		{"stored0GUIDASCIINameNVar", 0, stored0GUIDASCIINameNVar, "", FullNVarEntry, 16, FFGUID, "Test"},
		{"stored1GUIDASCIINameNVar", 0, stored1GUIDASCIINameNVar, "", FullNVarEntry, 16, ZeroGUID, "Test"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			storedVar := NVar{GUID: *guid.MustParse("2df19db9-a1b4-4b02-b4bb-5ddb4866e13f"), Name: "Stored", Type: LinkNVarEntry, NextOffset: 123}
			invalidVar := NVar{Type: InvalidNVarEntry}
			s := NVarStore{buf: erased16NVarBuf}
			s.Entries = append(s.Entries, &invalidVar, &storedVar)
			Attributes.ErasePolarity = 0xFF
			v, err := newNVar(test.buf, test.offset, &s)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err != nil {
				// expected error
				return
			}
			if test.t == NoNVarEntry {
				if v != nil {
					t.Errorf("No NVar expected got \n%v\n", v)

				}
				return
			} else if v == nil {
				t.Error("No NVar returned")
				return

			}

			if v.Type != test.t {
				t.Errorf("Invalid Type, expected %v got %v", test.t, v.Type)
			}
			if v.DataOffset != test.DataOffset {
				t.Errorf("Invalid DataOffset, expected %v got %v", test.DataOffset, v.DataOffset)
			}
			if test.GUID != nil && v.GUID != *test.GUID {
				t.Errorf("Invalid GUID, expected %v got %v", *test.GUID, v.GUID)
			}
			if v.Name != test.Name {
				t.Errorf("Invalid Name, expected %v got %v", test.Name, v.Name)
			}
		})
	}
}

func TestNVar_parseContent(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msg  string
	}{
		{"emptyNVarBuf", emptyNVarBuf, "EOF"},
		{"tooSmallNVarBuf", noNextNVarBuf, "unexpected EOF"},
		{"erasedSmallNVarBuf", erasedSmallNVarBuf, "NVAR Signature not found"},
		{"badIncompleteNVar", badIncompleteNVar, "error parsing NVAR store in var StoreInVar: error parsing NVAR entry at offset 0x0: NVAR Size bigger than remaining size"},
		{"goodEmptyNVar", headerOnlyEmptyNVar, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			v := NVar{Name: "StoreInVar"}
			Attributes.ErasePolarity = 0xFF
			err := v.parseContent(test.buf)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err == nil && v.NVarStore == nil {
				t.Errorf("No NVarStore parsed, got nil")
			}
		})
	}
}

func TestNVar_NewNVarStore(t *testing.T) {
	var tests = []struct {
		name  string
		buf   []byte
		msg   string
		count int
	}{
		{"emptyNVarBuf", emptyNVarBuf, "", 0},
		{"tooSmallNVarBuf", noNextNVarBuf, "", 0},
		{"erasedSmallNVarBuf", erasedSmallNVarBuf, "", 0},
		{"erased16NVarBuf", erased16NVarBuf, "", 0},
		{"badIncompleteNVar", badIncompleteNVar, "error parsing NVAR entry at offset 0x0: NVAR Size bigger than remaining size", 0},
		{"goodEmptyNVar", headerOnlyEmptyNVar, "", 1},
		{"testNVarStore", testNVarStore, "", 2},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			Attributes.ErasePolarity = 0xFF
			s, err := NewNVarStore(test.buf)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err == nil && len(s.Entries) != test.count {
				t.Errorf("Wrong number of NVar found, expected %v got %v", test.count, len(s.Entries))
			}
		})
	}
}

func TestNVar_Assemble(t *testing.T) {
	var stored1GUIDIndex = uint8(1)
	var tests = []struct {
		name      string
		nvar      NVar
		buf       []byte
		checkOnly bool
		msg       string
	}{
		{"Invalid", NVar{}, []byte{}, true, "unable to construct Invalid NVAR"},
		{"badLinkUpdate", NVar{Type: LinkNVarEntry, NextOffset: 1}, []byte{}, false, "unable to update data in link, use compact first"},
		{"badHeaderSize", NVar{Type: DataNVarEntry, Header: NVarHeader{Attributes: NVarEntryValid | NVarEntryDataOnly}}, headerOnlyEmptyNVar, true, "NVAR header size mismatch, expected 0 got 10"},
		{"badSize", NVar{Type: DataNVarEntry, Header: NVarHeader{Attributes: NVarEntryValid | NVarEntryDataOnly}, DataOffset: 10}, headerOnlyEmptyNVar, true, "NVAR size mismatch, expected 0 got 10"},
		{"goodEmpty", NVar{Type: DataNVarEntry, Header: NVarHeader{Size: 10, Attributes: NVarEntryValid | NVarEntryDataOnly}, DataOffset: 10}, headerOnlyEmptyNVar, true, ""},
		{"goodEmptyUpdate", NVar{Type: DataNVarEntry, Header: NVarHeader{Size: 10, Attributes: NVarEntryValid | NVarEntryDataOnly}, DataOffset: 10}, headerOnlyEmptyNVar, false, ""},
		{"badMissingName", NVar{Type: DataNVarEntry, Header: NVarHeader{Size: 16, Attributes: NVarEntryValid | NVarEntryASCIIName}, DataOffset: 16, GUIDIndex: &stored1GUIDIndex}, stored1GUIDASCIINameNVar, true, "NVAR header size mismatch, expected 16 got 12"},
		{"good1GUIDASCIINameNVar", NVar{Type: DataNVarEntry, Header: NVarHeader{Size: 16, Attributes: NVarEntryValid | NVarEntryASCIIName}, Name: "Test", DataOffset: 16, GUIDIndex: &stored1GUIDIndex}, stored1GUIDASCIINameNVar, true, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			v := test.nvar
			err := v.Assemble(test.buf[v.DataOffset:], test.checkOnly)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err != nil {
				// expected error
				return
			}
			if !bytes.Equal(test.buf, v.Buf()) {
				t.Errorf("Bad assembled variable content, expected \n%v\n got \n%v\n", hex.Dump(test.buf), hex.Dump(v.Buf()))
			}

		})
	}
}

func TestNVarStore_GetGUIDStoreBuf(t *testing.T) {
	var tests = []struct {
		name      string
		GUIDStore []guid.GUID
		buf       []byte
		msg       string
	}{
		{"empty", []guid.GUID{}, []byte{}, ""},
		{"1GUID", []guid.GUID{*FFGUID}, erased16NVarBuf, ""},
		{"2GUID", []guid.GUID{*FFGUID, *ZeroGUID}, append(zeroed16NVarBuf, erased16NVarBuf...), ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			var s NVarStore
			s.GUIDStore = test.GUIDStore
			buf, err := s.GetGUIDStoreBuf()
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			} else if err != nil {
				// expected error
				return
			}
			if !bytes.Equal(test.buf, buf) {
				t.Errorf("Bad assembled GUID store content, expected \n%v\n got \n%v\n", hex.Dump(test.buf), hex.Dump(buf))
			}

		})
	}
}

```

`pkg/uefi/rawregion.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

// RawRegion implements Region for a raw chunk of bytes in the firmware image.
type RawRegion struct {
	// holds the raw data
	buf []byte
	// Metadata for extraction and recovery
	ExtractPath string
	// This is a pointer to the FlashRegion struct laid out in the ifd.
	FRegion *FlashRegion
	// Region Type as per the IFD
	RegionType FlashRegionType
}

// SetFlashRegion sets the flash region.
func (rr *RawRegion) SetFlashRegion(fr *FlashRegion) {
	rr.FRegion = fr
}

// FlashRegion gets the flash region.
func (rr *RawRegion) FlashRegion() (fr *FlashRegion) {
	return rr.FRegion
}

// NewRawRegion creates a new region.
func NewRawRegion(buf []byte, r *FlashRegion, rt FlashRegionType) (Region, error) {
	rr := &RawRegion{FRegion: r, RegionType: rt}
	rr.buf = make([]byte, len(buf))
	copy(rr.buf, buf)
	return rr, nil
}

// Type returns the flash region type.
func (rr *RawRegion) Type() FlashRegionType {
	return rr.RegionType
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (rr *RawRegion) Buf() []byte {
	return rr.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (rr *RawRegion) SetBuf(buf []byte) {
	rr.buf = buf
}

// Apply calls the visitor on the RawRegion.
func (rr *RawRegion) Apply(v Visitor) error {
	return v.Visit(rr)
}

// ApplyChildren calls the visitor on each child node of RawRegion.
func (rr *RawRegion) ApplyChildren(v Visitor) error {
	return nil
}

```

`pkg/uefi/region.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"fmt"
)

const (
	// RegionBlockSize assumes the region struct values correspond to blocks of 0x1000 in size
	RegionBlockSize = 0x1000
)

// FlashRegionType represents the different types possible in a flash region.
type FlashRegionType int

// IFD Region types.
// This also corresponds to their index in the flash region section.
// Referenced from github.com/LongSoft/UEFITool, common/descriptor.h.
const (
	RegionTypeBIOS FlashRegionType = iota
	RegionTypeME
	RegionTypeGBE
	RegionTypePD
	RegionTypeDevExp1
	RegionTypeBIOS2
	RegionTypeMicrocode
	RegionTypeEC
	RegionTypeDevExp2
	RegionTypeIE
	RegionTypeTGBE1
	RegionTypeTGBE2
	RegionTypeReserved1
	RegionTypeReserved2
	RegionTypePTT

	RegionTypeUnknown FlashRegionType = -1
)

var flashRegionTypeNames = map[FlashRegionType]string{
	RegionTypeBIOS:      "BIOS",
	RegionTypeME:        "ME",
	RegionTypeGBE:       "GbE",
	RegionTypePD:        "PD",
	RegionTypeDevExp1:   "DevExp1",
	RegionTypeBIOS2:     "BIOS2",
	RegionTypeMicrocode: "Microcode",
	RegionTypeEC:        "EC",
	RegionTypeDevExp2:   "DevExp2",
	RegionTypeIE:        "IE",
	RegionTypeTGBE1:     "10GbE1",
	RegionTypeTGBE2:     "10GbE2",
	RegionTypeReserved1: "Reserved1",
	RegionTypeReserved2: "Reserved2",
	RegionTypePTT:       "PTT",
	// RegionTypeUnknown doesn't have a string name, we want it
	// to fallback and print the number
}

func (rt FlashRegionType) String() string {
	if s, ok := flashRegionTypeNames[rt]; ok {
		return s
	}
	return fmt.Sprintf("Unknown Region (%d)", rt)
}

// FlashRegion holds the base and limit of every type of region. Each region such as the bios region
// should point back to it.
// TODO: figure out of block sizes are read from some location on flash or fixed.
// Right now we assume they're fixed to 4KiB
type FlashRegion struct {
	Base  uint16 // Index of first 4KiB block
	Limit uint16 // Index of last block
}

// Valid checks to see if a region is valid
func (r *FlashRegion) Valid() bool {
	// The ODROID bios seems to be different from all other bioses, and seems to not report
	// invalid regions correctly. They report a limit and base of 0xFFFF instead of a limit of 0
	return r.Limit > 0 && r.Limit >= r.Base && r.Limit != 0xFFFF && r.Base != 0xFFFF
}

func (r *FlashRegion) String() string {
	return fmt.Sprintf("[%#x, %#x)", r.Base, r.Limit)
}

// BaseOffset calculates the offset into the flash image where the Region begins
func (r *FlashRegion) BaseOffset() uint32 {
	return uint32(r.Base) * RegionBlockSize
}

// EndOffset calculates the offset into the flash image where the Region ends
func (r *FlashRegion) EndOffset() uint32 {
	return (uint32(r.Limit) + 1) * RegionBlockSize
}

var regionConstructors = map[FlashRegionType]func(buf []byte, r *FlashRegion, rt FlashRegionType) (Region, error){
	RegionTypeBIOS:      NewBIOSRegion,
	RegionTypeME:        NewMERegion,
	RegionTypeGBE:       NewRawRegion,
	RegionTypePD:        NewRawRegion,
	RegionTypeDevExp1:   NewRawRegion,
	RegionTypeBIOS2:     NewRawRegion,
	RegionTypeMicrocode: NewRawRegion,
	RegionTypeEC:        NewRawRegion,
	RegionTypeDevExp2:   NewRawRegion,
	RegionTypeIE:        NewRawRegion,
	RegionTypeTGBE1:     NewRawRegion,
	RegionTypeTGBE2:     NewRawRegion,
	RegionTypeReserved1: NewRawRegion,
	RegionTypeReserved2: NewRawRegion,
	RegionTypePTT:       NewRawRegion,
	RegionTypeUnknown:   NewRawRegion,
}

// Region contains the start and end of a region in flash. This can be a BIOS, ME, PDR or GBE region.
type Region interface {
	Firmware
	Type() FlashRegionType
	FlashRegion() *FlashRegion
	SetFlashRegion(fr *FlashRegion)
}

```

`pkg/uefi/region_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import "testing"

var regionTestcases = [...]struct {
	in    FlashRegion
	valid bool
	base  uint32
	end   uint32
}{
	// Invalid
	{
		in:    FlashRegion{0, 0},
		valid: false,
		base:  0,
		end:   0x1000,
	},
	{
		in:    FlashRegion{1, 0},
		valid: false,
		base:  0x1000,
		end:   0x1000,
	},
	// Valid
	{
		in:    FlashRegion{1, 1},
		valid: true,
		base:  0x1000,
		end:   0x2000,
	},
	{
		in:    FlashRegion{100, 200},
		valid: true,
		base:  0x64000,
		end:   0xC9000,
	},
	{
		in:    FlashRegion{0x0004, 0xFFFF},
		valid: false,
		base:  0x00004000,
		end:   0x10000000,
	},
	{
		in:    FlashRegion{0x0004, 0xFFFE},
		valid: true,
		base:  0x00004000,
		end:   0x0FFFF000,
	},
	{
		in:    FlashRegion{0xFFFF, 0xFFFF},
		valid: false,
		base:  0x0FFFF000,
		end:   0x10000000,
	},
}

func TestFlashRegionValid(t *testing.T) {
	for _, tc := range regionTestcases {
		if out := tc.in.Valid(); out != tc.valid {
			t.Errorf("%#v.Valid() = %v; want = %v", tc.in, out, tc.valid)
		}
	}
}

func TestFlashRegionBaseOffset(t *testing.T) {
	for _, tc := range regionTestcases {
		if out := tc.in.BaseOffset(); out != tc.base {
			t.Errorf("%#v.BaseOffset() = %d; want = %d", tc.in, out, tc.base)
		}
	}
}

func TestFlashRegionEndOffset(t *testing.T) {
	for _, tc := range regionTestcases {
		if out := tc.in.EndOffset(); out != tc.end {
			t.Errorf("%#v.EndOffset() = %d; want = %d", tc.in, out, tc.end)
		}
	}
}

```

`pkg/uefi/section.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"unsafe"

	"github.com/linuxboot/fiano/pkg/compression"
	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/unicode"
)

const (
	// SectionMinLength is the minimum length of a file section header.
	SectionMinLength = 0x04
	// SectionExtMinLength is the minimum length of an extended file section header.
	SectionExtMinLength = 0x08
)

// SectionType holds a section type value
type SectionType uint8

// UEFI Section types
const (
	SectionTypeAll                 SectionType = 0x00
	SectionTypeCompression         SectionType = 0x01
	SectionTypeGUIDDefined         SectionType = 0x02
	SectionTypeDisposable          SectionType = 0x03
	SectionTypePE32                SectionType = 0x10
	SectionTypePIC                 SectionType = 0x11
	SectionTypeTE                  SectionType = 0x12
	SectionTypeDXEDepEx            SectionType = 0x13
	SectionTypeVersion             SectionType = 0x14
	SectionTypeUserInterface       SectionType = 0x15
	SectionTypeCompatibility16     SectionType = 0x16
	SectionTypeFirmwareVolumeImage SectionType = 0x17
	SectionTypeFreeformSubtypeGUID SectionType = 0x18
	SectionTypeRaw                 SectionType = 0x19
	SectionTypePEIDepEx            SectionType = 0x1b
	SectionMMDepEx                 SectionType = 0x1c
)

var sectionTypeNames = map[SectionType]string{
	SectionTypeCompression:         "EFI_SECTION_COMPRESSION",
	SectionTypeGUIDDefined:         "EFI_SECTION_GUID_DEFINED",
	SectionTypeDisposable:          "EFI_SECTION_DISPOSABLE",
	SectionTypePE32:                "EFI_SECTION_PE32",
	SectionTypePIC:                 "EFI_SECTION_PIC",
	SectionTypeTE:                  "EFI_SECTION_TE",
	SectionTypeDXEDepEx:            "EFI_SECTION_DXE_DEPEX",
	SectionTypeVersion:             "EFI_SECTION_VERSION",
	SectionTypeUserInterface:       "EFI_SECTION_USER_INTERFACE",
	SectionTypeCompatibility16:     "EFI_SECTION_COMPATIBILITY16",
	SectionTypeFirmwareVolumeImage: "EFI_SECTION_FIRMWARE_VOLUME_IMAGE",
	SectionTypeFreeformSubtypeGUID: "EFI_SECTION_FREEFORM_SUBTYPE_GUID",
	SectionTypeRaw:                 "EFI_SECTION_RAW",
	SectionTypePEIDepEx:            "EFI_SECTION_PEI_DEPEX",
	SectionMMDepEx:                 "EFI_SECTION_MM_DEPEX",
}

// String creates a string representation for the section type.
func (s SectionType) String() string {
	if t, ok := sectionTypeNames[s]; ok {
		return t
	}
	return "UNKNOWN"
}

// GUIDEDSectionAttribute holds a GUIDED section attribute bitfield
type GUIDEDSectionAttribute uint16

// UEFI GUIDED Section Attributes
const (
	GUIDEDSectionProcessingRequired GUIDEDSectionAttribute = 0x01
	GUIDEDSectionAuthStatusValid    GUIDEDSectionAttribute = 0x02
)

// SectionHeader represents an EFI_COMMON_SECTION_HEADER as specified in
// UEFI PI Spec 3.2.4 Firmware File Section
type SectionHeader struct {
	Size [3]uint8 `json:"-"`
	Type SectionType
}

// SectionExtHeader represents an EFI_COMMON_SECTION_HEADER2 as specified in
// UEFI PI Spec 3.2.4 Firmware File Section
type SectionExtHeader struct {
	SectionHeader
	ExtendedSize uint32 `json:"-"`
}

// SectionGUIDDefinedHeader contains the fields for a EFI_SECTION_GUID_DEFINED
// encapsulated section header.
type SectionGUIDDefinedHeader struct {
	GUID       guid.GUID
	DataOffset uint16
	Attributes uint16
}

// SectionGUIDDefined contains the type specific fields for a
// EFI_SECTION_GUID_DEFINED section.
type SectionGUIDDefined struct {
	SectionGUIDDefinedHeader

	// Metadata
	Compression string
}

// GetBinHeaderLen returns the length of the binary typ specific header
func (s *SectionGUIDDefined) GetBinHeaderLen() uint32 {
	return uint32(unsafe.Sizeof(s.SectionGUIDDefinedHeader))
}

// TypeHeader interface forces type specific headers to report their length
type TypeHeader interface {
	GetBinHeaderLen() uint32
}

// TypeSpecificHeader is used for marshalling and unmarshalling from JSON
type TypeSpecificHeader struct {
	Type   SectionType
	Header TypeHeader
}

var headerTypes = map[SectionType]func() TypeHeader{
	SectionTypeGUIDDefined: func() TypeHeader { return &SectionGUIDDefined{} },
}

// UnmarshalJSON unmarshals a TypeSpecificHeader struct and correctly deduces the
// type of the interface.
func (t *TypeSpecificHeader) UnmarshalJSON(b []byte) error {
	var getType struct {
		Type   SectionType
		Header json.RawMessage
	}
	if err := json.Unmarshal(b, &getType); err != nil {
		return err
	}
	factory, ok := headerTypes[getType.Type]
	if !ok {
		return fmt.Errorf("unknown TypeSpecificHeader type '%v', unable to unmarshal", getType.Type)
	}
	t.Type = SectionType(getType.Type)
	t.Header = factory()
	return json.Unmarshal(getType.Header, &t.Header)
}

// DepExOpCode is one opcode for the dependency expression section.
type DepExOpCode string

// DepExOpCodes maps the numeric code to the string.
var DepExOpCodes = map[byte]DepExOpCode{
	0x0: "BEFORE",
	0x1: "AFTER",
	0x2: "PUSH",
	0x3: "AND",
	0x4: "OR",
	0x5: "NOT",
	0x6: "TRUE",
	0x7: "FALSE",
	0x8: "END",
	0x9: "SOR",
}

// DepExNamesToOpCodes maps the operation back to the code.
var DepExNamesToOpCodes = map[DepExOpCode]byte{}

func init() {
	for k, v := range DepExOpCodes {
		DepExNamesToOpCodes[v] = k
	}
}

// DepExOp contains one operation for the dependency expression.
type DepExOp struct {
	OpCode DepExOpCode
	GUID   *guid.GUID `json:",omitempty"`
}

// Section represents a Firmware File Section
type Section struct {
	Header SectionExtHeader
	Type   string
	buf    []byte

	// Metadata for extraction and recovery
	ExtractPath string
	FileOrder   int `json:"-"`

	// Type specific fields
	// TODO: It will be simpler if this was not an interface
	TypeSpecific *TypeSpecificHeader `json:",omitempty"`

	// For EFI_SECTION_USER_INTERFACE
	Name string `json:",omitempty"`

	// For EFI_SECTION_VERSION
	BuildNumber uint16 `json:",omitempty"`
	Version     string `json:",omitempty"`

	// For EFI_SECTION_DXE_DEPEX, EFI_SECTION_PEI_DEPEX, and EFI_SECTION_MM_DEPEX
	DepEx []DepExOp `json:",omitempty"`

	// Encapsulated firmware
	Encapsulated []*TypedFirmware `json:",omitempty"`
}

// String returns the String value of the section if it makes sense,
// such as the name or the version string.
func (s *Section) String() string {
	switch s.Header.Type {
	case SectionTypeUserInterface:
		return s.Name
	case SectionTypeVersion:
		return "Version " + s.Version
	}
	return ""
}

// SetType sets the section type in the header and updates the string name.
func (s *Section) SetType(t SectionType) {
	s.Header.Type = t
	s.Type = t.String()
}

// Buf returns the buffer.
// Used mostly for things interacting with the Firmware interface.
func (s *Section) Buf() []byte {
	return s.buf
}

// SetBuf sets the buffer.
// Used mostly for things interacting with the Firmware interface.
func (s *Section) SetBuf(buf []byte) {
	s.buf = buf
}

// Apply calls the visitor on the Section.
func (s *Section) Apply(v Visitor) error {
	return v.Visit(s)
}

// ApplyChildren calls the visitor on each child node of Section.
func (s *Section) ApplyChildren(v Visitor) error {
	for _, f := range s.Encapsulated {
		if err := f.Value.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// CreateSection creates a new section from minimal components.
// The guid is only used in the case of a GUID Defined section type.
func CreateSection(t SectionType, buf []byte, encap []Firmware, g *guid.GUID) (*Section, error) {
	s := &Section{}

	s.Header.Type = t
	// Map type to string.
	s.Type = s.Header.Type.String()

	s.buf = append([]byte{}, buf...) // Copy out buffer.

	for _, e := range encap {
		s.Encapsulated = append(s.Encapsulated, MakeTyped(e))
	}

	// Create type section header
	switch s.Header.Type {
	case SectionTypeGUIDDefined:
		if g == nil {
			return nil, errors.New("guid was nil, can't make guid defined section")
		}
		guidDefHeader := &SectionGUIDDefined{}
		guidDefHeader.GUID = *g
		switch *g {
		case compression.BROTLIGUID:
			guidDefHeader.Compression = "BROTLI"
		case compression.LZMAGUID:
			guidDefHeader.Compression = "LZMA"
		case compression.LZMAX86GUID:
			guidDefHeader.Compression = "LZMAX86"
		default:
			guidDefHeader.Compression = "UNKNOWN"
		}
		guidDefHeader.Attributes = uint16(GUIDEDSectionProcessingRequired)
		s.TypeSpecific = &TypeSpecificHeader{SectionTypeGUIDDefined, guidDefHeader}
	}

	return s, nil
}

// GenSecHeader generates a full binary header for the section data.
// It assumes that the passed in section struct already contains section data in the buffer,
// the section type in the Type field, and the type specific header in the TypeSpecific field.
// It modifies the calling Section.
func (s *Section) GenSecHeader() error {
	var err error
	// Calculate size
	headerLen := uint32(SectionMinLength)
	if s.TypeSpecific != nil && s.TypeSpecific.Header != nil {
		headerLen += s.TypeSpecific.Header.GetBinHeaderLen()
	}
	s.Header.ExtendedSize = uint32(len(s.buf)) + headerLen // TS header lengths are part of headerLen at this point
	if s.Header.ExtendedSize >= 0xFFFFFF {
		headerLen += 4 // Add space for the extended header.
		s.Header.ExtendedSize += 4
	}

	// Set the correct data offset for GUID Defined headers.
	// This is terrible
	if s.Header.Type == SectionTypeGUIDDefined {
		gd := s.TypeSpecific.Header.(*SectionGUIDDefined)
		gd.DataOffset = uint16(headerLen)
		// append type specific header in front of data
		tsh := new(bytes.Buffer)
		if err = binary.Write(tsh, binary.LittleEndian, &gd.SectionGUIDDefinedHeader); err != nil {
			return err
		}
		s.buf = append(tsh.Bytes(), s.buf...)
	}

	// Append common header
	s.Header.Size = Write3Size(uint64(s.Header.ExtendedSize))
	h := new(bytes.Buffer)
	if s.Header.ExtendedSize >= 0xFFFFFF {
		err = binary.Write(h, binary.LittleEndian, &s.Header)
	} else {
		err = binary.Write(h, binary.LittleEndian, &s.Header.SectionHeader)
	}
	if err != nil {
		return err
	}
	s.buf = append(h.Bytes(), s.buf...)
	return nil
}

// ErrOversizeHdr is the error returned by NewSection when the header is oversize.
type ErrOversizeHdr struct {
	hdrsiz uintptr
	bufsiz int
}

func (e *ErrOversizeHdr) Error() string {
	return fmt.Sprintf("Header size %#x larger than available data %#x", e.hdrsiz, e.bufsiz)
}

// NewSection parses a sequence of bytes and returns a Section
// object, if a valid one is passed, or an error.
func NewSection(buf []byte, fileOrder int) (*Section, error) {
	s := Section{FileOrder: fileOrder}
	// Read in standard header.
	r := bytes.NewReader(buf)
	if err := binary.Read(r, binary.LittleEndian, &s.Header.SectionHeader); err != nil {
		return nil, err
	}

	// Map type to string.
	s.Type = s.Header.Type.String()

	headerSize := unsafe.Sizeof(SectionHeader{})
	switch s.Header.Type {
	case SectionTypeAll, SectionTypeCompression, SectionTypeGUIDDefined, SectionTypeDisposable,
		SectionTypePE32, SectionTypePIC, SectionTypeTE, SectionTypeDXEDepEx, SectionTypeVersion,
		SectionTypeUserInterface, SectionTypeCompatibility16, SectionTypeFirmwareVolumeImage,
		SectionTypeFreeformSubtypeGUID, SectionTypeRaw, SectionTypePEIDepEx, SectionMMDepEx:
		if s.Header.Size == [3]uint8{0xFF, 0xFF, 0xFF} {
			// Extended Header
			if err := binary.Read(r, binary.LittleEndian, &s.Header.ExtendedSize); err != nil {
				return nil, err
			}
			if s.Header.ExtendedSize == 0xFFFFFFFF {
				return nil, errors.New("section size and extended size are all FFs! there should not be free space inside a file")
			}
			headerSize = unsafe.Sizeof(SectionExtHeader{})
		} else {
			// Copy small size into big for easier handling.
			// Section's extended size is 32 bits unlike file's
			s.Header.ExtendedSize = uint32(Read3Size(s.Header.Size))
		}
	default:
		s.Header.ExtendedSize = uint32(Read3Size(s.Header.Size))
		if buflen := len(buf); int(s.Header.ExtendedSize) > buflen {
			s.Header.ExtendedSize = uint32(buflen)
		}
	}

	if buflen := len(buf); int(s.Header.ExtendedSize) > buflen {
		return nil, fmt.Errorf("section size mismatch! Section has size %v, but buffer is %v bytes big",
			s.Header.ExtendedSize, buflen)
	}

	if ReadOnly {
		s.buf = buf[:s.Header.ExtendedSize]
	} else {
		// Copy out the buffer.
		newBuf := buf[:s.Header.ExtendedSize]
		s.buf = make([]byte, s.Header.ExtendedSize)
		copy(s.buf, newBuf)
	}

	// Section type specific data
	switch s.Header.Type {
	case SectionTypeGUIDDefined:
		typeSpec := &SectionGUIDDefined{}
		if err := binary.Read(r, binary.LittleEndian, &typeSpec.SectionGUIDDefinedHeader); err != nil {
			return nil, err
		}
		s.TypeSpecific = &TypeSpecificHeader{Type: SectionTypeGUIDDefined, Header: typeSpec}

		// Determine how to interpret the section based on the GUID.
		var encapBuf []byte
		if typeSpec.Attributes&uint16(GUIDEDSectionProcessingRequired) != 0 && !DisableDecompression {
			if compressor := compression.CompressorFromGUID(&typeSpec.GUID); compressor != nil {
				typeSpec.Compression = compressor.Name()
				var err error
				encapBuf, err = compressor.Decode(buf[typeSpec.DataOffset:])
				if err != nil {
					log.Errorf("%v", err)
					typeSpec.Compression = "UNKNOWN"
					encapBuf = []byte{}
				}
			} else {
				typeSpec.Compression = "UNKNOWN"
			}
		}

		for i, offset := 0, uint64(0); offset < uint64(len(encapBuf)); i++ {
			encapS, err := NewSection(encapBuf[offset:], i)
			if err != nil {
				return nil, fmt.Errorf("error parsing encapsulated section #%d at offset %d: %v",
					i, offset, err)
			}
			// Align to 4 bytes for now. The PI Spec doesn't say what alignment it should be
			// but UEFITool aligns to 4 bytes, and this seems to work on everything I have.
			offset = Align4(offset + uint64(encapS.Header.ExtendedSize))
			s.Encapsulated = append(s.Encapsulated, MakeTyped(encapS))
		}

	case SectionTypeUserInterface:
		if len(s.buf) <= int(headerSize) {
			return nil, &ErrOversizeHdr{hdrsiz: headerSize, bufsiz: len(s.buf)}
		}
		s.Name = unicode.UCS2ToUTF8(s.buf[headerSize:])

	case SectionTypeVersion:
		if len(s.buf) <= int(headerSize+2) {
			return nil, &ErrOversizeHdr{hdrsiz: headerSize + 2, bufsiz: len(s.buf)}
		}
		s.BuildNumber = binary.LittleEndian.Uint16(s.buf[headerSize : headerSize+2])
		s.Version = unicode.UCS2ToUTF8(s.buf[headerSize+2:])

	case SectionTypeFirmwareVolumeImage:
		if len(s.buf) <= int(headerSize) {
			return nil, &ErrOversizeHdr{hdrsiz: headerSize, bufsiz: len(s.buf)}
		}
		fv, err := NewFirmwareVolume(s.buf[headerSize:], 0, true)
		if err != nil {
			return nil, err
		}
		s.Encapsulated = []*TypedFirmware{MakeTyped(fv)}

	case SectionTypeDXEDepEx, SectionTypePEIDepEx, SectionMMDepEx:
		if len(s.buf) <= int(headerSize) {
			return nil, &ErrOversizeHdr{hdrsiz: headerSize, bufsiz: len(s.buf)}
		}
		var err error
		if s.DepEx, err = parseDepEx(s.buf[headerSize:]); err != nil {
			log.Warnf("%v", err)
		}
	}

	return &s, nil
}

func parseDepEx(b []byte) ([]DepExOp, error) {
	depEx := []DepExOp{}
	r := bytes.NewBuffer(b)
	for {
		opCodeByte, err := r.ReadByte()
		if err != nil {
			return nil, errors.New("invalid DEPEX, no END")
		}
		if opCodeStr, ok := DepExOpCodes[opCodeByte]; ok {
			op := DepExOp{OpCode: opCodeStr}
			if opCodeStr == "BEFORE" || opCodeStr == "AFTER" || opCodeStr == "PUSH" {
				op.GUID = &guid.GUID{}
				if err := binary.Read(r, binary.LittleEndian, op.GUID); err != nil {
					return nil, fmt.Errorf("invalid DEPEX, could not read GUID: %v", err)
				}
			}
			depEx = append(depEx, op)
			if opCodeStr == "END" {
				break
			}
		} else {
			return nil, fmt.Errorf("invalid DEPEX opcode, %#v", opCodeByte)
		}
	}
	return depEx, nil
}

```

`pkg/uefi/section_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
)

var (
	// Section examples
	emptySec     = make([]byte, 0)                                                     // Empty section
	tinySec      = []byte{4, 0, 0, byte(SectionTypeRaw)}                               // Section header with no data
	wrongSizeSec = append([]byte{40, 0, 0, byte(SectionTypeRaw)}, make([]byte, 20)...) // Section with a size mismatch
	largeSizeSec = append([]byte{10, 0, 0, byte(SectionTypeRaw)}, make([]byte, 20)...) // Section with a big buffer
	smallSec     = append([]byte{22, 0, 0, byte(SectionTypeRaw)}, make([]byte, 18)...) // 20 byte Section
	linuxSec     = []byte{0x10, 0x00, 0x00, 0x15, 0x4c, 0x00, 0x69, 0x00,
		0x6e, 0x00, 0x75, 0x00, 0x78, 0x00, 0x00, 0x00} // Linux UI section
)

func TestSetType(t *testing.T) {
	var tests = []struct {
		name       string
		t          SectionType
		typeString string
	}{
		{"SetUIType", SectionTypeUserInterface, "EFI_SECTION_USER_INTERFACE"},
		{"SetBadType", 0x55, "UNKNOWN"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			s := Section{}
			s.SetType(test.t)
			if s.Type != test.typeString {
				t.Errorf("Section Type field mismatch, expected \"%v\", got \"%v\"", test.typeString, s.Type)
			}
		})
	}
}

func TestUISection(t *testing.T) {
	var tests = []struct {
		name      string
		buf       []byte
		fileOrder int
		val       string
	}{
		{"UISection", linuxSec, 1, "Linux"},
		{"nonUISection", smallSec, 1, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			s, err := NewSection(test.buf, test.fileOrder)
			if err != nil {
				t.Fatalf("Unable to parse section object %v, got %v", test.buf, err.Error())
			}
			if s.Name != test.val {
				t.Errorf("Section Name field mismatch, expected \"%v\", got \"%v\"", test.val, s.Name)
			}
		})
	}
}

func TestNewSection(t *testing.T) {
	var tests = []struct {
		name      string
		buf       []byte
		fileOrder int
		msg       string
	}{
		{"emptySec", emptySec, 0, "EOF"},
		{"wrongSizeSec", wrongSizeSec, 0,
			fmt.Sprintf("section size mismatch! Section has size %v, but buffer is %v bytes big",
				40, len(wrongSizeSec))},
		{"largeSizeSec", largeSizeSec, 0, ""},
		{"tinySec", tinySec, 0, ""},
		{"smallSec", smallSec, 0, ""},
		{"linuxSec", linuxSec, 0, ""},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			_, err := NewSection(test.buf, test.fileOrder)
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
		})
	}
}

func TestParseDepEx(t *testing.T) {
	var tests = []struct {
		name string
		in   []byte
		out  []DepExOp
		err  string
	}{
		{
			name: "empty",
			in:   []byte{},
			err:  "invalid DEPEX, no END",
		},
		{
			name: "end",
			in:   []byte{0x08},
			out:  []DepExOp{{OpCode: "END"}},
		},
		{
			name: "no end",
			in:   []byte{0x06},
			err:  "invalid DEPEX, no END",
		},
		{
			name: "simple",
			in:   []byte{0x06, 0x08},
			out:  []DepExOp{{OpCode: "TRUE"}, {OpCode: "END"}},
		},
		{
			name: "spec example",
			// Example from the Platform Initialization Specification, Vol. 2, Chapter 10.
			in: []byte{
				0x02, // PUSH
				0xF6, 0x3F, 0x5E, 0x66, 0xCC, 0x46, 0xD4, 0x11,
				0x9A, 0x38, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D,
				0x02, // PUSH
				0xB1, 0xCC, 0xBA, 0x26, 0x42, 0x6F, 0xD4, 0x11,
				0xBC, 0xE7, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81,
				0x03, // AND
				0x02, // PUSH
				0xB2, 0xCC, 0xBA, 0x26, 0x42, 0x6F, 0xD4, 0x11,
				0xBC, 0xE7, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81,
				0x02, // PUSH
				0x72, 0x70, 0xA9, 0x1D, 0xDC, 0xBD, 0x30, 0x4B,
				0x99, 0xF1, 0x72, 0xA0, 0xB5, 0x6F, 0xFF, 0x2A,
				0x03, // AND
				0x03, // AND
				0x02, // PUSH
				0x87, 0xAC, 0xCF, 0x27, 0xCC, 0x46, 0xD4, 0x11,
				0x9A, 0x38, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D,
				0x02, // PUSH
				0x88, 0xAC, 0xCF, 0x27, 0xCC, 0x46, 0xD4, 0x11,
				0x9A, 0x38, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D,
				0x03, // AND
				0x02, // PUSH
				0x53, 0x82, 0xD0, 0x96, 0x83, 0x84, 0xD4, 0x11,
				0xBC, 0xF1, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81,
				0x02, // PUSH
				0xE3, 0x23, 0x64, 0xA4, 0x17, 0x46, 0xF1, 0x49,
				0xB9, 0xFF, 0xD1, 0xBF, 0xA9, 0x11, 0x58, 0x39,
				0x02, // PUSH
				0xB3, 0xCC, 0xBA, 0x26, 0x42, 0x6F, 0xD4, 0x11,
				0xBC, 0xE7, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81,
				0x03, // AND
				0x02, // PUSH
				0xE2, 0x68, 0x56, 0x1E, 0x81, 0x84, 0xD4, 0x11,
				0xBC, 0xF1, 0x00, 0x80, 0xC7, 0x3C, 0x88, 0x81,
				0x02, // PUSH
				0x18, 0xF8, 0x41, 0x64, 0x62, 0x63, 0x44, 0x4E,
				0xB5, 0x70, 0x7D, 0xBA, 0x31, 0xDD, 0x24, 0x53,
				0x03, // AND
				0x03, // AND
				0x03, // AND
				0x02, // PUSH
				0xF5, 0x3F, 0x5E, 0x66, 0xCC, 0x46, 0xD4, 0x11,
				0x9A, 0x38, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D,
				0x03, // AND
				0x08, // END
			},
			out: []DepExOp{
				{OpCode: "PUSH", GUID: guid.MustParse("665E3FF6-46CC-11D4-9A38-0090273FC14D")},
				{OpCode: "PUSH", GUID: guid.MustParse("26BACCB1-6F42-11D4-BCE7-0080C73C8881")},
				{OpCode: "AND"},
				{OpCode: "PUSH", GUID: guid.MustParse("26BACCB2-6F42-11D4-BCE7-0080C73C8881")},
				{OpCode: "PUSH", GUID: guid.MustParse("1DA97072-BDDC-4B30-99F1-72A0B56FFF2A")},
				{OpCode: "AND"},
				{OpCode: "AND"},
				{OpCode: "PUSH", GUID: guid.MustParse("27CFAC87-46CC-11D4-9A38-0090273FC14D")},
				{OpCode: "PUSH", GUID: guid.MustParse("27CFAC88-46CC-11D4-9A38-0090273FC14D")},
				{OpCode: "AND"},
				{OpCode: "PUSH", GUID: guid.MustParse("96D08253-8483-11D4-BCF1-0080C73C8881")},
				{OpCode: "PUSH", GUID: guid.MustParse("A46423E3-4617-49F1-B9FF-D1BFA9115839")},
				{OpCode: "PUSH", GUID: guid.MustParse("26BACCB3-6F42-11D4-BCE7-0080C73C8881")},
				{OpCode: "AND"},
				{OpCode: "PUSH", GUID: guid.MustParse("1E5668E2-8481-11D4-BCF1-0080C73C8881")},
				{OpCode: "PUSH", GUID: guid.MustParse("6441F818-6362-4E44-B570-7DBA31DD2453")},
				{OpCode: "AND"},
				{OpCode: "AND"},
				{OpCode: "AND"},
				{OpCode: "PUSH", GUID: guid.MustParse("665E3FF5-46CC-11D4-9A38-0090273FC14D")},
				{OpCode: "AND"},
				{OpCode: "END"}},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			depEx, err := parseDepEx(tt.in)
			if tt.err == "" {
				// Expects no error.
				if err != nil {
					t.Fatalf("unexpected error, %v", err)
				}
				if !reflect.DeepEqual(depEx, tt.out) {
					t.Fatalf("expected %s, got %s", tt.out, depEx)
				}
			} else {
				// Expects error.
				if err == nil {
					t.Fatal("expected error")
				}
				if tt.err != err.Error() {
					t.Fatalf("expected error %q, got %q", tt.err, err)
				}
			}
		})
	}
}

```

`pkg/uefi/uefi.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package uefi contents data types for the components found in UEFI and an
// Parse function for reading an image.
package uefi

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"reflect"
)

var (
	// ReadOnly breaks firmware modification operations, but optimizes
	// memory and CPU consumption for read-only operations.
	//
	// DO NOT USE THIS OPTION UNLESS YOU KNOW WHAT ARE YOU DOING. IF YOU
	// WILL MODIFY A FIRMWARE WITH THIS OPTION BEING ENABLED, THIS FIRMWARE
	// MIGHT BRICK YOUR DEVICE.
	ReadOnly = false

	// DisableDecompression disables section decompression.
	//
	// DO NOT USE THIS OPTION UNLESS YOU KNOW WHAT ARE YOU DOING. IF YOU
	// WILL MODIFY A FIRMWARE WITH THIS OPTION BEING ENABLED, THIS FIRMWARE
	// MIGHT BRICK YOUR DEVICE.
	DisableDecompression = false
)

// ROMAttributes is used to hold global variables that apply across the whole image.
// We have to do this to avoid passing too many things down each time.
type ROMAttributes struct {
	ErasePolarity byte // Either 0xFF or 0
}

const poisonedPolarity byte = 0xF0

// Attributes holds the global attributes
var Attributes = ROMAttributes{ErasePolarity: poisonedPolarity}

// SuppressErasePolarityError forces to ignore the "conflicting erase polarities"
// error.
//
// See also: https://github.com/linuxboot/fiano/issues/329
var SuppressErasePolarityError = false

// SetErasePolarity sets the Erase Polarity for the flash image.
// It checks to see if there are conflicting Erase Polarities.
func SetErasePolarity(ep byte) error {
	if ep != 0xFF && ep != 0 {
		// Invalid erase polarity requested.
		return fmt.Errorf("invalid erase polarity requested, should only be 0x00 or 0xFF, got 0x%02X",
			ep)
	}
	// Set it only once.
	if Attributes.ErasePolarity != poisonedPolarity && !SuppressErasePolarityError {
		// it's already been set. Check that they are the same.
		if Attributes.ErasePolarity != ep {
			return fmt.Errorf("conflicting erase polarities, was 0x%02X, requested 0x%02X",
				Attributes.ErasePolarity, ep)
		}
		return nil
	}
	Attributes.ErasePolarity = ep
	return nil
}

// Firmware is an interface to describe generic firmware types. When the
// firmware is parsed, all the Firmware objects are laid out in a tree (similar
// to an AST). This interface represents one node in said tree. The
// implementations (e.g. Flash image, or FirmwareVolume) must implement this
// interface.
type Firmware interface {
	Buf() []byte
	SetBuf(buf []byte)

	// Apply a visitor to the Firmware.
	Apply(v Visitor) error

	// Apply a visitor to all the direct children of the Firmware
	// (excluding the Firmware itself).
	ApplyChildren(v Visitor) error
}

// TypedFirmware includes the Firmware interface's type when exporting it to
// JSON. The type is required when unmarshalling.
type TypedFirmware struct {
	Type  string
	Value Firmware
}

// MakeTyped takes a Firmware interface and makes a (type, value) pair.
func MakeTyped(f Firmware) *TypedFirmware {
	return &TypedFirmware{
		Type:  reflect.TypeOf(f).String(),
		Value: f,
	}
}

// UnmarshalJSON unmarshals a TypedFirmware struct and correctly deduces the
// type of the interface.
func (f *TypedFirmware) UnmarshalJSON(b []byte) error {
	var getType struct {
		Type  string
		Value json.RawMessage
	}
	if err := json.Unmarshal(b, &getType); err != nil {
		return err
	}
	factory, ok := firmwareTypes[getType.Type]
	if !ok {
		return fmt.Errorf("unknown TypedFirmware type '%s', unable to unmarshal", getType.Type)
	}
	f.Type = getType.Type
	f.Value = factory()
	return json.Unmarshal(getType.Value, &f.Value)
}

// This should never be exposed, it is only used for marshalling different types to json.
type marshalFirmware struct {
	FType           string
	FirmwareElement json.RawMessage
}

var firmwareTypes = map[string]func() Firmware{
	"*uefi.BIOSRegion":      func() Firmware { return &BIOSRegion{} },
	"*uefi.BIOSPadding":     func() Firmware { return &BIOSPadding{} },
	"*uefi.File":            func() Firmware { return &File{} },
	"*uefi.FirmwareVolume":  func() Firmware { return &FirmwareVolume{} },
	"*uefi.FlashDescriptor": func() Firmware { return &FlashDescriptor{} },
	"*uefi.FlashImage":      func() Firmware { return &FlashImage{} },
	"*uefi.MERegion":        func() Firmware { return &MERegion{} },
	"*uefi.RawRegion":       func() Firmware { return &RawRegion{} },
	"*uefi.Section":         func() Firmware { return &Section{} },
}

// MarshalFirmware marshals the firmware element to JSON, including the type information at the top.
func MarshalFirmware(f Firmware) ([]byte, error) {
	b, err := json.MarshalIndent(f, "", "    ")
	if err != nil {
		return nil, err
	}

	m := marshalFirmware{FType: reflect.TypeOf(f).String(), FirmwareElement: json.RawMessage(b)}
	return json.MarshalIndent(m, "", "    ")
}

// UnmarshalFirmware unmarshals the firmware element from JSON, using the type information at the top.
func UnmarshalFirmware(b []byte) (Firmware, error) {
	var m marshalFirmware
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	factory, ok := firmwareTypes[m.FType]
	if !ok {
		return nil, fmt.Errorf("unknown Firmware type '%s', unable to unmarshal", m.FType)
	}
	f := factory()
	err := json.Unmarshal(m.FirmwareElement, &f)
	return f, err
}

// Parse exposes a high-level parser for generic firmware types. It does not
// implement any parser itself, but it calls known parsers that implement the
// Firmware interface.
func Parse(buf []byte) (Firmware, error) {
	if _, err := FindSignature(buf); err == nil {
		// Intel rom.
		return NewFlashImage(buf)
	}
	// Non intel image such as edk2's OVMF
	// We don't know how to parse this header, so treat it as a large BIOSRegion
	return NewBIOSRegion(buf, nil, RegionTypeBIOS)
}

// Checksum8 does a 8 bit checksum of the slice passed in.
func Checksum8(buf []byte) uint8 {
	var sum uint8
	for _, val := range buf {
		sum += val
	}
	return sum
}

// Checksum16 does a 16 bit checksum of the byte slice passed in.
func Checksum16(buf []byte) (uint16, error) {
	r := bytes.NewReader(buf)
	buflen := len(buf)
	if buflen%2 != 0 {
		return 0, fmt.Errorf("byte slice does not have even length, not able to do 16 bit checksum. Length was %v",
			buflen)
	}
	var temp, sum uint16
	for i := 0; i < buflen; i += 2 {
		if err := binary.Read(r, binary.LittleEndian, &temp); err != nil {
			return 0, err
		}
		sum += temp
	}
	return sum, nil
}

// Read3Size reads a 3-byte size and returns it as a uint64
func Read3Size(size [3]uint8) uint64 {
	return uint64(size[2])<<16 |
		uint64(size[1])<<8 | uint64(size[0])
}

// Write3Size writes a size into a 3-byte array
func Write3Size(size uint64) [3]uint8 {
	if size >= 0xFFFFFF {
		return [3]uint8{0xFF, 0xFF, 0xFF}
	}
	b := [3]uint8{uint8(size), uint8(size >> 8), uint8(size >> 16)}
	return b
}

// Align aligns an address
func Align(val uint64, base uint64) uint64 {
	return (val + base - 1) & ^(base - 1)
}

// Align4 aligns an address to 4 bytes
func Align4(val uint64) uint64 {
	return Align(val, 4)
}

// Align8 aligns an address to 8 bytes
func Align8(val uint64) uint64 {
	return Align(val, 8)
}

// Erase sets the buffer to be ErasePolarity
func Erase(buf []byte, polarity byte) {
	for j, blen := 0, len(buf); j < blen; j++ {
		buf[j] = Attributes.ErasePolarity
	}
}

// IsErased check if the buffer is ErasePolarity
func IsErased(buf []byte, polarity byte) bool {
	for _, c := range buf {
		if c != polarity {
			return false
		}
	}
	return true
}

```

`pkg/uefi/uefi_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

import (
	"encoding/json"
	"fmt"
	"testing"
)

func TestSetErasePolarity(t *testing.T) {
	type epTest struct {
		ep     byte
		errStr string
	}

	var err error
	var tests = []struct {
		name   string
		rounds []epTest
	}{
		{name: "badPolarity", rounds: []epTest{
			{
				ep: poisonedPolarity,
				errStr: fmt.Sprintf("invalid erase polarity requested, should only be 0x00 or 0xFF, got 0x%2X",
					poisonedPolarity)},
		}},
		{name: "good0xFF", rounds: []epTest{
			{
				ep:     0xFF,
				errStr: ""},
		}},
		{name: "good0x00", rounds: []epTest{
			{
				ep:     0x00,
				errStr: ""},
		}},
		{name: "good0xFFSetTwice", rounds: []epTest{
			{
				ep:     0xFF,
				errStr: ""},
			{
				ep:     0xFF,
				errStr: ""},
		}},
		{name: "MismatchedPolarity", rounds: []epTest{
			{
				ep:     0xFF,
				errStr: ""},
			{
				ep:     0x00,
				errStr: "conflicting erase polarities, was 0xFF, requested 0x00"},
		}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// Reset ErasePolarity
			Attributes.ErasePolarity = 0xF0
			for _, r := range test.rounds {
				err = SetErasePolarity(r.ep)
				if err != nil {
					if errStr := err.Error(); errStr != r.errStr {
						t.Errorf("error mismatch, expected \"%v\", got \"%v\"",
							r.errStr, errStr)
					}
				} else if r.errStr != "" {
					t.Errorf("Expected Error %v, got nil", r.errStr)
				}
			}
		})
	}
}

func TestUnmarshalTypedFirmware(t *testing.T) {
	inFirmware := MakeTyped(&Section{Name: "CHARLIE"})

	j, err := json.Marshal(inFirmware)
	if err != nil {
		t.Fatal(err)
	}
	t.Log(string(j))

	var outFirmware TypedFirmware
	if err := json.Unmarshal(j, &outFirmware); err != nil {
		t.Fatal(err)
	}

	if outFirmware.Type != "*uefi.Section" {
		t.Errorf("got %q, expected *uefi.Section", outFirmware.Type)
	}
	outSection, ok := outFirmware.Value.(*Section)
	if !ok {
		t.Fatalf("got %T; expected *uefi.Section", outFirmware.Value)
	}
	if outSection.Name != "CHARLIE" {
		t.Errorf("got %q, expected CHARLIE", outSection.Name)
	}
}

var (
	// Checksum Tests
	emptyBuf  = []byte{}
	sampleBuf = []byte{1, 2, 3, 4}
	overBuf   = []byte{0x1, 0x2, 0xFF, 0xFF}
	zeroBuf   = []byte{0, 0, 0, 0}
	threeBuf  = []byte{3, 3, 3}
)

func TestChecksum8(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		res  uint8
	}{
		{"emptyBuf", emptyBuf, 0},
		{"sampleBuf", sampleBuf, 10},
		{"overBuf", overBuf, 0x1},
		{"zeroBuf", zeroBuf, 0},
		{"threeBuf", threeBuf, 9},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if res := Checksum8(test.buf); res != test.res {
				t.Errorf("Checksum8 wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.buf, test.res, res)
			}
		})
	}
}

func TestChecksum16(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		res  uint16
		msg  string
	}{
		{"emptyBuf", emptyBuf, 0, ""},
		{"sampleBuf", sampleBuf, 0x604, ""},
		{"overBuf", overBuf, 0x200, ""},
		{"zeroBuf", zeroBuf, 0, ""},
		{"threeBuf", threeBuf, 0, fmt.Sprintf("byte slice does not have even length, not able to do 16 bit checksum. Length was %v",
			len(threeBuf))},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			res, err := Checksum16(test.buf)
			if res != test.res {
				t.Errorf("Checksum16 wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.buf, test.res, res)
			}
			if err == nil && test.msg != "" {
				t.Errorf("Error was not returned, expected %v", test.msg)
			} else if err != nil && err.Error() != test.msg {
				t.Errorf("Mismatched Error returned, expected \n%v\n got \n%v\n", test.msg, err.Error())
			}
		})
	}
}

func TestWrite3Size(t *testing.T) {
	var tests = []struct {
		name string
		val  uint64
		res  [3]byte
	}{
		{"emptySize", 0x0, [3]byte{0, 0, 0}},
		{"sampleSize", 0xABCDEF, [3]byte{0xEF, 0xCD, 0xAB}},
		{"max3ByteSize", 0xFFFFFF, [3]byte{0xFF, 0xFF, 0xFF}},
		{"over3ByteSize", 0x1000000, [3]byte{0xFF, 0xFF, 0xFF}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if res := Write3Size(test.val); res != test.res {
				t.Errorf("Write3Size wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.val, test.res, res)
			}
		})
	}
}

func TestRead3Size(t *testing.T) {
	var tests = []struct {
		name string
		val  uint64
		arr  [3]byte
	}{
		{"emptySize", 0x0, [3]byte{0, 0, 0}},
		{"sampleSize", 0xABCDEF, [3]byte{0xEF, 0xCD, 0xAB}},
		{"max3ByteSize", 0xFFFFFF, [3]byte{0xFF, 0xFF, 0xFF}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			if val := Read3Size(test.arr); val != test.val {
				t.Errorf("Read3Size wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.arr, test.val, val)
			}
		})
	}
}

func TestAlign4(t *testing.T) {
	var tests = []struct {
		val uint64
		res uint64
	}{
		{0x4, 0x4},
		{0x5, 0x8},
	}
	for _, test := range tests {
		if res := Align4(test.val); res != test.res {
			t.Errorf("Align4 wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.val, test.res, res)
		}
	}
}

func TestAlign8(t *testing.T) {
	var tests = []struct {
		val uint64
		res uint64
	}{
		{0x4, 0x8},
		{0x5, 0x8},
		{0x8, 0x8},
		{0x9, 0x10},
	}
	for _, test := range tests {
		if res := Align8(test.val); res != test.res {
			t.Errorf("Align8 wrong result!, input was %#x, wanted \n%#x\n, got \n%#x\n", test.val, test.res, res)
		}
	}
}

```

`pkg/uefi/visitor.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package uefi

// Visitor represents an operation which can be applied to the Firmware.
// Typically, the Visit function contains a type switch for the different
// firmware types and a default case. For example:
//
//	func (v *Example) Visit(f uefi.Firmware) error {
//	    switch f := f.(type) {
//
//	    case *uefi.File:
//	        fmt.Println("f is a file")
//	        return f.ApplyChildren(v) // Children are recursed over
//
//	    case *uefi.Section:
//	        fmt.Println("f is a section")
//	        return nil // Children are not visited
//
//	    default:
//	        // The default action is to recurse over children.
//	        return f.ApplyChildren(v)
//	    }
//	}
type Visitor interface {
	// Run wraps Visit. Additionally, it performs some setup and teardown
	// tasks. As a consumer of the visitor, Run is typically the function
	// you should call.
	Run(Firmware) error

	// Visit applies the visitor to the Firmware and (usually) recurses
	// over the children.
	Visit(Firmware) error
}

```

`pkg/unicode/ucs2.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package unicode converts between UCS2 cand UTF8.
package unicode

import (
	"github.com/linuxboot/fiano/pkg/log"
	"golang.org/x/text/encoding/unicode"
	"golang.org/x/text/transform"
)

// UCS2ToUTF8 converts from UCS2 to UTF8.
func UCS2ToUTF8(input []byte) string {
	e := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM)
	output, _, err := transform.Bytes(e.NewDecoder(), input)
	if err != nil {
		log.Errorf("could not decode UCS2: %v", err)
		return string(input)
	}
	// Remove null terminator if one exists.
	if output[len(output)-1] == 0 {
		output = output[:len(output)-1]
	}
	return string(output)
}

// UTF8ToUCS2 converts from UTF8 to UCS2.
func UTF8ToUCS2(input string) []byte {
	e := unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM)
	input = input + "\000" // null terminator
	output, _, err := transform.Bytes(e.NewEncoder(), []byte(input))
	if err != nil {
		log.Errorf("could not encode UCS2: %v", err)
		return []byte(input)
	}
	return output
}

```

`pkg/utk/utk.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package utk is where the implementation of the utk command lives.
package utk

import (
	"errors"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
	"github.com/linuxboot/fiano/pkg/visitors"
)

// Run runs the utk command with the given arguments.
func Run(args ...string) error {
	if len(args) == 0 {
		return errors.New("at least one argument is required")
	}

	v, err := visitors.ParseCLI(args[1:])
	if err != nil {
		return err
	}

	// Load and parse the image.
	path := args[0]
	f, err := os.Stat(path)
	if err != nil {
		return err
	}
	var parsedRoot uefi.Firmware
	if m := f.Mode(); m.IsDir() {
		// Call ParseDir
		pd := visitors.ParseDir{BasePath: path}
		if parsedRoot, err = pd.Parse(); err != nil {
			return err
		}
		// Assemble the tree from the bottom up
		a := visitors.Assemble{}
		if err = a.Run(parsedRoot); err != nil {
			return err
		}
	} else {
		// Regular file
		image, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		parsedRoot, err = uefi.Parse(image)
		if err != nil {
			return err
		}
	}

	// Execute the instructions from the command line.
	return visitors.ExecuteCLI(parsedRoot, v)
}

```

`pkg/visitors/assemble.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"sort"

	"github.com/linuxboot/fiano/pkg/compression"
	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
	"github.com/linuxboot/fiano/pkg/unicode"
)

// Assemble reconstitutes the firmware tree assuming that the leaf node buffers are accurate
type Assemble struct {
	// This is set when a file or section >=16MiB is encountered during assembly.
	// This tells the enclosing FV to use the FFSV3 GUID instead of the FFSV2 GUID,
	// and the enclosing FV resets it.
	// TODO: figure out if, in the case where the FVs are triply nested, must the FVs further up
	// also use the FFSV3 GUID? In that case we should fix this since only the innermost
	// enclosing FV changes to FFSV3
	useFFS3 bool
}

// Run just applies the visitor.
func (v *Assemble) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit applies the Assemble visitor to any Firmware type.
func (v *Assemble) Visit(f uefi.Firmware) error {
	var err error

	// Get the damn Erase Polarity
	if f, ok := f.(*uefi.FirmwareVolume); ok {
		// Set Erase Polarity
		if err = uefi.SetErasePolarity(f.GetErasePolarity()); err != nil {
			return err
		}
	}

	// We first assemble the children.
	// Sounds horrible but has to be done =(
	if err = f.ApplyChildren(v); err != nil {
		return err
	}

	switch f := f.(type) {

	case *uefi.FirmwareVolume:
		if len(f.Files) == 0 {
			// No children, buffer should already contain data.
			return nil
		}
		// We assume the buffer already contains the header. We repopulate the header from the buffer
		// Construct the full buffer.
		// The FV header is the only thing we've read in so far.
		fBuf := f.Buf()
		fBufLen := uint64(len(fBuf))
		// The reason I check against f.Length and fBuf instead of the min size is that the volume could
		// have extended headers.
		if f.Length < fBufLen {
			return fmt.Errorf("buffer read in bigger than FV length!, expected %v got %v bytes",
				f.Length, fBufLen)
		}

		fileOffset := f.DataOffset
		if f.DataOffset != fBufLen {
			// remove all old file data
			fBuf = fBuf[:f.DataOffset]
			f.SetBuf(fBuf)
		}

		for _, file := range f.Files {
			fileBuf := file.Buf()
			fileLen := uint64(len(fileBuf))
			if fileLen == 0 {
				log.Fatalf("%v", file.Header.GUID)
			}

			// Pad to the 8 byte alignments.
			alignedOffset := uefi.Align8(fileOffset)
			// Read out the file alignment requirements
			if alignBase := file.Header.Attributes.GetAlignment(); alignBase != 1 {
				hl := file.HeaderLen()
				// We need to align the data, not the header. This is so terrible.
				fileDataOffset := uefi.Align(alignedOffset+hl, alignBase)
				// Calculate the starting offset of the file
				newOffset := fileDataOffset - hl
				if gap := (newOffset - alignedOffset); gap >= 8 && gap < uefi.FileHeaderMinLength {
					// We need to re align to the next boundary cause we can't put a pad file in here.
					// Who thought this was a good idea?
					fileDataOffset = uefi.Align(fileDataOffset+1, alignBase)
					newOffset = fileDataOffset - hl
				}
				if newOffset != alignedOffset {
					// Add a pad file starting from alignedOffset to newOffset
					pfile, err := uefi.CreatePadFile(newOffset - alignedOffset)
					if err != nil {
						return err
					}
					if err = f.InsertFile(alignedOffset, pfile.Buf()); err != nil {
						return fmt.Errorf("file %s: %v", pfile.Header.GUID, err)
					}
				}
				alignedOffset = newOffset
			}
			if err = f.InsertFile(alignedOffset, fileBuf); err != nil {
				return fmt.Errorf("file %s: %v", file.Header.GUID, err)
			}
			fileOffset = alignedOffset + fileLen
		}

		// Check if we're out of space.
		newFVLen := uint64(len(f.Buf()))
		if f.Length < newFVLen && !f.Resizable {
			return fmt.Errorf("out of space in firmware volume. space available: %v bytes, new size: %v, reduce size by %v bytes", f.Length, newFVLen, newFVLen-f.Length)
		}

		if f.Length < newFVLen {
			// We've expanded the FV, resize
			if f.Blocks[0].Size == 0 {
				return fmt.Errorf("first block in FV has zero size! block was %v", f.Blocks[0])
			}
			// Align to the next block boundary
			// Make sure there are enough blocks for the length
			f.Length = uefi.Align(newFVLen, uint64(f.Blocks[0].Size))
			// Right now we assume there's only one block entry
			// TODO: handle multiple block entries
			f.Blocks[0].Count = uint32(f.Length / uint64(f.Blocks[0].Size))
		}
		if f.Length > newFVLen {
			// If the buffer is not long enough, pad ErasePolarity
			extLen := f.Length - newFVLen
			emptyBuf := make([]byte, extLen)
			uefi.Erase(emptyBuf, uefi.Attributes.ErasePolarity)
			f.SetBuf(append(f.Buf(), emptyBuf...))
		}

		f.FreeSpace = f.Length - uefi.Align8(newFVLen)
		fBuf = f.Buf()

		// Write the length to the correct spot
		// TODO: handle the whole header instead of doing this
		binary.LittleEndian.PutUint64(fBuf[32:], f.Length)

		// Write the correct GUID to the correct spot
		// Refer to EFI_FIRMWARE_FILE_SYSTEM3_GUID in section 3.2.2, volume 3 in
		// the UEFI PI Specification version 1.6
		if v.useFFS3 && f.FileSystemGUID == *uefi.FFS2 {
			// There is a large file or section, we need to swap to FFSV3
			f.FileSystemGUID = *uefi.FFS3
			// Write it out
			copy(fBuf[16:32], f.FileSystemGUID[:])
		}
		v.useFFS3 = false

		// Write the block map count
		binary.LittleEndian.PutUint32(fBuf[56:], f.Blocks[0].Count)
		// Checksum the header again
		// TODO: handle the whole header instead of doing this
		// First we zero out the original checksum
		binary.LittleEndian.PutUint16(fBuf[50:], 0)
		sum, err := uefi.Checksum16(fBuf[:f.HeaderLen])
		if err != nil {
			return err
		}
		newSum := 0 - sum
		binary.LittleEndian.PutUint16(fBuf[50:], newSum)

		// Save the buffer
		f.SetBuf(fBuf)

	case *uefi.File:
		if len(f.Sections) == 0 && f.NVarStore == nil {
			// No children, buffer should already contain data.
			// we don't support this file type, just return the raw buffer.
			// Or we've removed the sections and just want to replace the file directly
			// We have to make sure the state is correct, so we still need to write out
			// the file header.

			// TODO: Not setting to valid used to cause some failures on some bioses, verify that it no longer fails.
			// There are some bioses that don't set the valid bits correctly,
			// fh.State = 0x07 ^ uefi.Attributes.ErasePolarity
			return nil
		}

		// Otherwise, we reconstruct the entire file from the sections and the
		// file header using data from the JSON/existing header struct. This means
		// that some JSON values are now respected, including GUID changes.
		// However file lengths and checksums will be recalculated.

		// Assemble all sections so we know the final file size. We need to do this
		// to know if we need to use the extended header.
		fileData := []byte{}
		dLen := uint64(0)
		if f.NVarStore != nil {
			fileData = f.NVarStore.Buf()
			dLen = f.NVarStore.Length
		} else {
			for _, s := range f.Sections {
				// Align to 4 bytes and extend with 00s
				// Why is it 00s? I don't know. Everything else has been extended with FFs
				// but somehow in between sections alignment is done with 0s. What the heck.
				for count := uefi.Align4(dLen) - dLen; count > 0; count-- {
					fileData = append(fileData, 0x00)
				}
				dLen = uefi.Align4(dLen)

				// Append the section
				sData := s.Buf()
				dLen += uint64(len(sData))
				fileData = append(fileData, sData...)
			}
		}

		f.SetSize(uefi.FileHeaderMinLength+dLen, true)
		// We need to use FFSV3
		if f.Header.ExtendedSize > 0xFFFFFF {
			v.useFFS3 = true
		}

		// TODO: Not setting to valid used to cause some failures on some bioses, verify that it no longer fails.
		// There are some bioses that don't set the valid bits correctly,
		// fh.SetState(uefi.FileStateValid)

		if err = f.ChecksumAndAssemble(fileData); err != nil {
			return err
		}
		return nil

	case *uefi.Section:
		if len(f.Encapsulated) == 0 {
			// No children, buffer should already contain data.
			// We allow for some modifications like UI sections and version
			// sections
			switch f.Header.Type {
			default:
				return nil
			case uefi.SectionTypeUserInterface:
				f.SetBuf(unicode.UTF8ToUCS2(f.Name))
			case uefi.SectionTypeVersion:
				newBuf := make([]byte, 2)
				binary.LittleEndian.PutUint16(newBuf, f.BuildNumber)
				newBuf = append(newBuf, unicode.UTF8ToUCS2(f.Version)...)
				f.SetBuf(newBuf)
			case uefi.SectionTypeDXEDepEx, uefi.SectionTypePEIDepEx,
				uefi.SectionMMDepEx:
				// Assemble dependency sections.
				// TODO: handle differences in opcode support between different dependency sections.
				newBuf := []byte{}
				for _, d := range f.DepEx {
					opcode, ok := uefi.DepExNamesToOpCodes[d.OpCode]
					if !ok {
						return fmt.Errorf("unable to map depex opcode string to opcode, string was: %v",
							d.OpCode)
					}
					newBuf = append(newBuf, opcode)
					// Sanity checks.
					switch d.OpCode {
					case "BEFORE", "AFTER", "PUSH":
						// GUID must not be nil.
						if d.GUID == nil {
							return fmt.Errorf("depex opcode %v must not have nil guid",
								d.OpCode)
						}
						newBuf = append(newBuf, d.GUID[:]...)
					default:
						// GUID must be nil.
						if d.GUID != nil {
							return fmt.Errorf("depex opcode %v must not have a guid! got %v",
								d.OpCode, *d.GUID)
						}
					}
				}
				f.SetBuf(newBuf)
			}

			// We've got the data in the section buffer, now regenerate the header.
			err = f.GenSecHeader()
			if f.Header.ExtendedSize > 0xFFFFFF {
				v.useFFS3 = true
			}
			return err
		}

		// Construct the section data
		secData := []byte{}
		dLen := uint64(0)
		for _, es := range f.Encapsulated {
			// Align to 4 bytes and extend with 00s
			for count := uefi.Align4(dLen) - dLen; count > 0; count-- {
				secData = append(secData, 0x00)
			}
			dLen = uefi.Align4(dLen)

			esData := es.Value.Buf()
			dLen += uint64(len(esData))
			secData = append(secData, esData...)
		}

		// Special processing for some section types
		switch f.Header.Type {
		case uefi.SectionTypeGUIDDefined:
			ts := f.TypeSpecific.Header.(*uefi.SectionGUIDDefined)
			if ts.Attributes&uint16(uefi.GUIDEDSectionProcessingRequired) != 0 {
				compressor := compression.CompressorFromGUID(&ts.GUID)
				if compressor == nil {
					return fmt.Errorf("unknown guid defined from section %v, should not have encapsulated sections", f)
				}
				if fBuf, err := compressor.Encode(secData); err == nil {
					f.SetBuf(fBuf)
				} else {
					return err
				}
			}
		default:
			f.SetBuf(secData)
		}

		// Fix up the header
		err = f.GenSecHeader()
		if f.Header.ExtendedSize > 0xFFFFFF {
			v.useFFS3 = true
		}

	case *uefi.NVarStore:
		nvData := []byte{}
		nvLen := uint64(0)
		// NVAR
		for _, v := range f.Entries {
			// Append the NVar
			vData := v.Buf()
			nvLen += uint64(len(vData))
			nvData = append(nvData, vData...)
		}

		// update offsets
		f.FreeSpaceOffset = nvLen
		f.GUIDStoreOffset = f.Length - uint64(binary.Size(guid.GUID{}))*uint64(len(f.GUIDStore))
		// Erase Empty space
		erased := make([]byte, f.GUIDStoreOffset-f.FreeSpaceOffset)
		uefi.Erase(erased, uefi.Attributes.ErasePolarity)
		nvData = append(nvData, erased...)

		// Copy the GUID store
		var guidStoreBuf []byte
		guidStoreBuf, err = f.GetGUIDStoreBuf()
		if err != nil {
			return err
		}
		nvData = append(nvData, guidStoreBuf...)

		f.SetBuf(nvData)

	case *uefi.NVar:
		// Only rebuild Valid NVAR
		if f.IsValid() {
			var content []byte
			if f.NVarStore == nil {
				content = f.Buf()[f.DataOffset:]
			} else {
				content = f.NVarStore.Buf()
			}

			err = f.Assemble(content, true)
		}

	case *uefi.FlashDescriptor:
		// We only parse Descriptor, Region and Master, so regenerate only that and keep the rest of the buffer.
		// We assume the location in the Flash Descriptor sector have not changed.
		// TODO: verify the integrity of the Start offsets
		fBuf := f.Buf()
		// Regenerate DescriptorMap
		desc := new(bytes.Buffer)
		err = binary.Write(desc, binary.LittleEndian, f.DescriptorMap)
		if err != nil {
			return fmt.Errorf("unable to construct binary DescriptorMap of IFD: got %v", err)
		}
		copy(fBuf[f.DescriptorMapStart:f.DescriptorMapStart+uint(uefi.FlashDescriptorMapSize)], desc.Bytes())
		// Regenerate Region
		region := new(bytes.Buffer)
		err = binary.Write(region, binary.LittleEndian, f.Region)
		if err != nil {
			return fmt.Errorf("unable to construct binary Region of IFD: got %v", err)
		}
		copy(fBuf[f.RegionStart:f.RegionStart+uint(uefi.FlashRegionSectionSize)], region.Bytes())
		// Regenerate Master
		master := new(bytes.Buffer)
		err = binary.Write(master, binary.LittleEndian, f.Master)
		if err != nil {
			return fmt.Errorf("unable to construct binary Master of IFD: got %v", err)
		}
		copy(fBuf[f.MasterStart:f.MasterStart+uint(uefi.FlashMasterSectionSize)], master.Bytes())

		// Set the buffer
		f.SetBuf(fBuf)

		return nil

	case *uefi.BIOSRegion:
		fBuf := make([]byte, f.Length)
		firstFV, err := f.FirstFV()
		if err != nil {
			return err
		}
		if err = uefi.SetErasePolarity(firstFV.GetErasePolarity()); err != nil {
			return err
		}
		uefi.Erase(fBuf, uefi.Attributes.ErasePolarity)
		// Put the elements together
		offset := uint64(0)
		for _, e := range f.Elements {
			// copy the fv over the original
			// TODO: handle different sizes.
			// We'll have to FF out the new regions/ check for clashes
			ebuf := e.Value.Buf()
			copy(fBuf[offset:offset+uint64(len(ebuf))], ebuf)
			offset += uint64(len(ebuf))
		}
		// Set the buffer
		f.SetBuf(fBuf)

		return nil

	case *uefi.FlashImage:
		ifdbuf := f.IFD.Buf()
		// Assemble regions.
		// We need to sort them since a) we don't really know the order until we parse the block numbers
		// and b) the order may have changed anyway.
		if !f.IFD.Region.FlashRegions[uefi.RegionTypeBIOS].Valid() {
			return fmt.Errorf("no BIOS region: invalid region parameters %v",
				f.IFD.Region.FlashRegions[uefi.RegionTypeBIOS])
		}

		// Point FlashRegion to struct read from IFD rather than json.
		nr := int(f.IFD.DescriptorMap.NumberOfRegions)
		for _, t := range f.Regions {
			r := t.Value.(uefi.Region)

			if r.Type() == uefi.RegionTypeUnknown {
				continue
			}
			if nr != 0 && int(r.Type()) > nr {
				// Region exceeds original number of regions.
				// TODO: handle this in some way by increasing the number of regions.
				continue
			}
			if int(r.Type()) >= len(f.IFD.Region.FlashRegions) {
				// This is some new unknown region, there's no IFD entry
				continue
			}
			r.SetFlashRegion(&f.IFD.Region.FlashRegions[r.Type()])
		}

		// Sort Regions, prepare to set flash buffer
		sort.Slice(f.Regions, func(i, j int) bool {
			ri := f.Regions[i].Value.(uefi.Region)
			rj := f.Regions[j].Value.(uefi.Region)
			return ri.FlashRegion().Base < rj.FlashRegion().Base
		})

		// Search for gaps
		// if there are gaps or overlaps, fail immediately
		offset := uint64(uefi.FlashDescriptorLength)
		fBuf := make([]byte, 0)
		fBuf = append(fBuf, ifdbuf...)
		for _, t := range f.Regions {
			r := t.Value.(uefi.Region)
			nextBase := uint64(r.FlashRegion().BaseOffset())
			if nextBase < offset {
				// Something is wrong, overlapping regions
				// TODO: print a better error message describing what it overlaps with
				return fmt.Errorf("overlapping regions! region %v overlaps with the previous region", r)
			}
			if nextBase > offset {
				// There is a gap
				return fmt.Errorf("gap between regions from %v to %v", offset, nextBase)
			}
			offset = uint64(r.FlashRegion().EndOffset())
			fBuf = append(fBuf, r.Buf()...)
		}
		// check for the last region
		if offset != f.FlashSize {
			return fmt.Errorf("gap between at end of flash from %v to %v", offset, f.FlashSize)
		}

		f.SetBuf(fBuf)
		return nil

	}

	return err

}

```

`pkg/visitors/assemble_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"fmt"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	ZeroGUID = guid.MustParse("00000000-0000-0000-0000-000000000000")
)

func TestBadDepex(t *testing.T) {
	var tests = []struct {
		name string
		op   uefi.DepExOp
		err  string
	}{
		{"badOpCode", uefi.DepExOp{OpCode: "BLAH", GUID: nil},
			"unable to map depex opcode string to opcode, string was: BLAH"},
		{"pushNoGUID", uefi.DepExOp{OpCode: "PUSH", GUID: nil},
			"depex opcode PUSH must not have nil guid"},
		{"trueWithGUID", uefi.DepExOp{OpCode: "TRUE", GUID: ZeroGUID},
			fmt.Sprintf("depex opcode TRUE must not have a guid! got %v", *ZeroGUID)},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			s := &uefi.Section{}
			s.SetType(uefi.SectionTypeDXEDepEx)
			s.DepEx = []uefi.DepExOp{test.op}
			a := &Assemble{}
			err := a.Run(s)
			if err == nil {
				t.Fatalf("Expected error: %v, got nil!", test.err)
			}
			if errStr := err.Error(); test.err != errStr {
				t.Errorf("Expected error: %v, got %v instead", test.err, errStr)
			}
		})
	}
}

```

`pkg/visitors/cat.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Cat concatenates all RAW data sections from a file into a single byte slice.
type Cat struct {
	// Input
	Predicate func(f uefi.Firmware) bool

	// Output
	io.Writer
	Matches []uefi.Firmware
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Cat) Run(f uefi.Firmware) error {
	// First run "find" to generate a list of matches to replace.
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	v.Matches = find.Matches
	for _, m := range v.Matches {
		if err := m.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// Visit applies the Extract visitor to any Firmware type.
func (v *Cat) Visit(f uefi.Firmware) error {
	switch f := f.(type) {

	case *uefi.File:
		return f.ApplyChildren(v)

	case *uefi.Section:
		if f.Header.Type == uefi.SectionTypeRaw {
			// TODO: figure out how to compute how many bytes
			// to throw away. We tried once and gave up.
			// UEFI ... what can you say.
			if _, err := v.Write(f.Buf()[4:]); err != nil {
				return err
			}
		}
		return f.ApplyChildren(v)

	default:
		// Must be applied to a File to have any effect.
		return nil
	}
}

func init() {
	RegisterCLI("cat", "cat a file with a regexp that matches a GUID", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &Cat{
			Predicate: pred,
			Writer:    os.Stdout,
		}, nil
	})
}

```

`pkg/visitors/cat_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"reflect"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
)

var (
	catGUID = guid.MustParse("1B45CC0A-156A-428A-AF62-49864DA0E6E6")
	catdat  = []byte{79, 218, 58, 155, 86, 174, 36, 76, 141, 234, 240, 59, 117, 88, 174, 80}
)

func TestCat(t *testing.T) {
	f := parseImage(t)

	// Apply the visitor.
	var b bytes.Buffer
	cat := &Cat{
		Predicate: FindFileGUIDPredicate(*catGUID),
		Writer:    &b,
	}
	if err := cat.Run(f); err != nil {
		t.Fatal(err)
	}

	// We expect one match.
	if len(cat.Matches) != 1 {
		t.Fatalf("got %d matches; expected 1", len(cat.Matches))
	}

	if !reflect.DeepEqual(b.Bytes(), catdat) {
		t.Errorf("bytes.Buffer: want %v; got %v", catdat, b.Bytes())
	}
}

```

`pkg/visitors/cli.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package visitors uses the Visitor interface to recursively apply an
// operation over the firmware image. Also, functions are exported for using
// the visitors through the command line.
package visitors

import (
	"fmt"
	"sort"

	"github.com/linuxboot/fiano/pkg/uefi"
)

var visitorRegistry = map[string]visitorEntry{}

type visitorEntry struct {
	numArgs       int
	help          string
	createVisitor func([]string) (uefi.Visitor, error)
}

const (
	helpMessage = "Usage: utk FILE [COMMAND [ARGS]]..."
)

// RegisterCLI registers a function `createVisitor` to be called when parsing
// the arguments with `ParseCLI`. For a Visitor to be accessible from the
// command line, it should have an init function which registers a
// `createVisitor` function here.
func RegisterCLI(name string, help string, numArgs int, createVisitor func([]string) (uefi.Visitor, error)) {
	if _, ok := visitorRegistry[name]; ok {
		panic(fmt.Sprintf("two visitors registered the same name: '%s'", name))
	}
	visitorRegistry[name] = visitorEntry{
		numArgs:       numArgs,
		createVisitor: createVisitor,
		help:          help,
	}
}

// ParseCLI constructs a list of visitors from the given CLI argument list.
func ParseCLI(args []string) ([]uefi.Visitor, error) {
	visitors := []uefi.Visitor{}
	for len(args) > 0 {
		cmd := args[0]
		args = args[1:]
		o, ok := visitorRegistry[cmd]
		if !ok {
			return []uefi.Visitor{}, fmt.Errorf("could not find command '%s'\n%s", cmd, helpMessage)
		}
		if o.numArgs > len(args) {
			return []uefi.Visitor{}, fmt.Errorf("too few arguments for command '%s', got %d, expected %d.\nSynopsis: %s",
				cmd, len(args), o.numArgs, o.help)
		}
		visitor, err := o.createVisitor(args[:o.numArgs])
		if err != nil {
			return []uefi.Visitor{}, err
		}
		visitors = append(visitors, visitor)
		args = args[o.numArgs:]
	}
	return visitors, nil
}

// ExecuteCLI applies each Visitor over the firmware in sequence.
func ExecuteCLI(f uefi.Firmware, v []uefi.Visitor) error {
	for i := range v {
		if err := v[i].Run(f); err != nil {
			return err
		}
	}
	return nil
}

// ListCLI prints out the help entries in the visitor struct
// as a newline-separated string in the form:
//
//	name: help
func ListCLI() string {
	var s string
	names := []string{}
	for n := range visitorRegistry {
		names = append(names, n)
	}
	sort.Strings(names)
	for _, n := range names {
		s += fmt.Sprintf("  %-22s: %s\n", n, visitorRegistry[n].help)
	}
	return s
}

```

`pkg/visitors/comment.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Comment holds the io.Writer and args for a comment
type Comment struct {
	W io.Writer
	s string
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Comment) Run(f uefi.Firmware) error {
	fmt.Fprintf(v.W, "%s\n", v.s)
	return nil
}

// Visit applies the Comment visitor to any Firmware type.
func (v *Comment) Visit(f uefi.Firmware) error {
	return nil
}

func init() {
	RegisterCLI("comment", "Print one arg", 1, func(args []string) (uefi.Visitor, error) {
		return &Comment{W: os.Stdout, s: args[0]}, nil
	})
}

```

`pkg/visitors/comment_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"
)

func TestComment(t *testing.T) {
	f := parseImage(t)
	results := comment(t, f)

	if len(results) != 0 {
		t.Fatalf("got %d matches; expected 0", len(results))
	}
}

```

`pkg/visitors/count.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"strings"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Count counts the number of each firmware type.
type Count struct {
	// Optionally write result as JSON.
	W io.Writer `json:"-"`

	// Output
	FirmwareTypeCount map[string]int
	FileTypeCount     map[string]int
	SectionTypeCount  map[string]int
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Count) Run(f uefi.Firmware) error {
	v.FirmwareTypeCount = map[string]int{}
	v.FileTypeCount = map[string]int{}
	v.SectionTypeCount = map[string]int{}

	if err := f.Apply(v); err != nil {
		return err
	}

	if v.W != nil {
		b, err := json.MarshalIndent(v, "", "\t")
		if err != nil {
			return err
		}
		_, err = fmt.Fprintln(v.W, string(b))
		return err
	}
	return nil
}

// Visit applies the Count visitor to any Firmware type.
func (v *Count) Visit(f uefi.Firmware) error {
	incr := func(m *map[string]int, key string) {
		if n, ok := (*m)[key]; ok {
			(*m)[key] = n + 1
		} else {
			(*m)[key] = 1
		}
	}

	incr(&v.FirmwareTypeCount, strings.TrimPrefix(fmt.Sprintf("%T", f), "*uefi."))
	if file, ok := f.(*uefi.File); ok {
		incr(&v.FileTypeCount, file.Type)
	}
	if sec, ok := f.(*uefi.Section); ok {
		incr(&v.SectionTypeCount, sec.Type)
	}
	return f.ApplyChildren(v)
}

func init() {
	RegisterCLI("count", "count the number of each firmware type", 0, func(args []string) (uefi.Visitor, error) {
		return &Count{
			W: os.Stdout,
		}, nil
	})
}

```

`pkg/visitors/count_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"
)

func TestCount(t *testing.T) {
	f := parseImage(t)

	count := &Count{}
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}

	tests := []struct {
		mapPtr       *map[string]int
		firmwareType string
		atLeast      int
	}{
		{&count.FirmwareTypeCount, "BIOSRegion", 1},
		{&count.FirmwareTypeCount, "File", 2},
		{&count.FirmwareTypeCount, "FirmwareVolume", 2},
		{&count.FirmwareTypeCount, "Section", 2},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_APPLICATION", 2},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_DRIVER", 2},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_DXE_CORE", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_FFS_PAD", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_FREEFORM", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_PEIM", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_PEI_CORE", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_RAW", 1},
		{&count.FileTypeCount, "EFI_FV_FILETYPE_SECURITY_CORE", 1},
		{&count.SectionTypeCount, "EFI_SECTION_DXE_DEPEX", 2},
		{&count.SectionTypeCount, "EFI_SECTION_FIRMWARE_VOLUME_IMAGE", 1},
		{&count.SectionTypeCount, "EFI_SECTION_GUID_DEFINED", 1},
		{&count.SectionTypeCount, "EFI_SECTION_PE32", 2},
		{&count.SectionTypeCount, "EFI_SECTION_RAW", 2},
		{&count.SectionTypeCount, "EFI_SECTION_USER_INTERFACE", 2},
		{&count.SectionTypeCount, "EFI_SECTION_VERSION", 2},
	}

	for _, tt := range tests {
		t.Run(tt.firmwareType, func(t *testing.T) {
			if _, ok := (*tt.mapPtr)[tt.firmwareType]; !ok {
				t.Fatalf("expected %q to be in the count", tt.firmwareType)
			}
			if (*tt.mapPtr)[tt.firmwareType] < tt.atLeast {
				t.Fatalf("expected to count at least %d of type %q, got %d",
					tt.atLeast, tt.firmwareType, (*tt.mapPtr)[tt.firmwareType])
			}

		})
	}
}

```

`pkg/visitors/createfv.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"strconv"
	"unsafe"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// CreateFV creates a firmware volume at given offset
type CreateFV struct {
	AbsOffset uint64
	Size      uint64
	Name      guid.GUID

	found bool
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *CreateFV) Run(f uefi.Firmware) error {
	err := f.Apply(v)
	if err != nil {
		return err
	}
	if !v.found {
		return fmt.Errorf("cannot create FV at %#x (+%#x) no BIOS region found", v.AbsOffset, v.Size)
	}
	return nil
}

// Visit applies the CreateFV visitor to any Firmware type.
func (v *CreateFV) Visit(f uefi.Firmware) error {
	if v.found {
		return nil
	}
	var offset, end uint64
	switch f := f.(type) {
	case *uefi.BIOSRegion:
		if f.FRegion != nil {
			offset = uint64(f.FRegion.BaseOffset())
			end = uint64(f.FRegion.EndOffset())
		} else {
			end = f.Length
		}
		if v.AbsOffset < offset {
			return fmt.Errorf("cannot create FV at %#x, BIOS region starts at %#x", v.AbsOffset, offset)
		}
		if v.AbsOffset+v.Size > end {
			return fmt.Errorf("cannot create FV ending at %#x (%#x + %#x), BIOS region ends at %#x", v.AbsOffset+v.Size, v.AbsOffset, v.Size, end)
		}

		// Manually visit children, we want the index
		idx := -1
		var bp *uefi.BIOSPadding
	L:
		for i, e := range f.Elements {
			switch f := e.Value.(type) {
			case *uefi.BIOSPadding:
				bp = f
				bpOffset := offset + f.Offset
				bpEnd := bpOffset + uint64(len(f.Buf()))
				// Warning: This won't work if for whatever reason we have two biospads that are contiguous
				// TODO: join contiguous before !
				if v.AbsOffset >= bpOffset && v.AbsOffset+v.Size <= bpEnd {

					idx = i
					break L
				}
			}
		}

		if idx == -1 {
			return fmt.Errorf("cannot create FV at %#x (+%#x) no matching BIOS Pad found", v.AbsOffset, v.Size)
		}
		v.found = true
		fv, err := createEmptyFirmwareVolume(v.AbsOffset-offset, v.Size, &v.Name)
		if err != nil {
			return err
		}
		return insertFVinBP(f, v.AbsOffset-offset, bp, idx, fv)
	}

	return f.ApplyChildren(v)
}

func insertFVinBP(br *uefi.BIOSRegion, offset uint64, bp *uefi.BIOSPadding, idx int, fv *uefi.FirmwareVolume) error {
	// Copy the Elements before the modified BIOS Pad
	newElements := make([]*uefi.TypedFirmware, idx, len(br.Elements))
	copy(newElements, br.Elements[:idx])

	bpBuf := bp.Buf()
	// keep part of the BIOS Pad before the new fv if needed
	if bp.Offset < offset {
		hbp, err := uefi.NewBIOSPadding(bpBuf[:offset-bp.Offset], bp.Offset)
		if err != nil {
			return err
		}
		newElements = append(newElements, uefi.MakeTyped(hbp))
	}

	// Add the FV
	newElements = append(newElements, uefi.MakeTyped(fv))

	// keep part of the BIOS Pad after the new fv if needed
	tbpStart := offset - bp.Offset + fv.Length
	if tbpStart < uint64(len(bpBuf)) {
		tbp, err := uefi.NewBIOSPadding(bpBuf[tbpStart:], offset+fv.Length)
		if err != nil {
			return err
		}
		newElements = append(newElements, uefi.MakeTyped(tbp))
	}

	// Keep the remaining Elements in the BIOS Region
	if idx+1 < len(br.Elements) {
		newElements = append(newElements, br.Elements[idx+1:]...)
	}
	br.Elements = newElements
	return nil
}

func createEmptyFirmwareVolume(fvOffset, size uint64, name *guid.GUID) (*uefi.FirmwareVolume, error) {
	// TODO: can this be refactored with the code in repack.go and assemble.go ?
	fv := &uefi.FirmwareVolume{} // new Firmware Volume
	// Set up volume header first.
	fv.FileSystemGUID = *uefi.FFS2
	fv.Signature = binary.LittleEndian.Uint32([]byte("_FVH"))
	// TODO: retrieve all details from (all) other fv in BIOS Region
	fv.Attributes = 0x0004FEFF
	fv.Revision = 2
	// Create Blocks
	fv.Blocks = make([]uefi.Block, 2)
	fv.Blocks[0] = uefi.Block{Size: 4096, Count: uint32(size / 4096)}
	fv.Blocks[1] = uefi.Block{}
	// Calculate the HeaderLen field
	fv.HeaderLen = uint16(uefi.FirmwareVolumeFixedHeaderSize + int(unsafe.Sizeof(uefi.Block{}))*len(fv.Blocks))

	fv.DataOffset = uint64(fv.HeaderLen) // unless we add the extended header
	fv.Length = size

	if name != nil {
		// TODO: compute the extended header offset (especially if more than 2 Blocks, this offset will be wrong)
		fv.ExtHeaderOffset = 0x60
		fv.FVName = *name
		fv.ExtHeaderSize = uefi.FirmwareVolumeExtHeaderMinSize
	}
	// Generate binary header.
	header := new(bytes.Buffer)
	err := binary.Write(header, binary.LittleEndian, fv.FirmwareVolumeFixedHeader)
	if err != nil {
		return nil, fmt.Errorf("unable to construct binary header of new firmware volume: got %v", err)
	}
	for _, b := range fv.Blocks {
		err = binary.Write(header, binary.LittleEndian, b)
		if err != nil {
			return nil, fmt.Errorf("unable to construct binary header of new firmware volume: got %v", err)
		}

	}
	buf := header.Bytes()

	// Checksum the header
	sum, err := uefi.Checksum16(buf[:fv.HeaderLen])
	if err != nil {
		return nil, err
	}
	newSum := 0 - sum
	binary.LittleEndian.PutUint16(buf[50:], newSum)

	// Store the header buffer in
	fv.SetBuf(buf)

	if name != nil {
		// Build the ExtHeader
		extHeader := new(bytes.Buffer)
		err = binary.Write(extHeader, binary.LittleEndian, fv.FirmwareVolumeExtHeader)
		if err != nil {
			return nil, fmt.Errorf("unable to construct binary extended header of new firmware volume: got %v", err)
		}

		// The extended header in encapsulated in a PadFile just after the header.
		// The UEFI PI Specification is not clear on that point, however the implementation in tianocore GenFv tools is clear:
		// At [1] `GenerateFvImage` gives the extended header as an argument to `AddPadFile` implemented at [2].
		// [1]: https://github.com/tianocore/edk2/blob/master/BaseTools/Source/C/GenFv/GenFvInternalLib.c#L2772
		// [2]: https://github.com/tianocore/edk2/blob/master/BaseTools/Source/C/GenFv/GenFvInternalLib.c#L563
		extHeaderFile, err := uefi.CreatePadFile(uint64(uefi.FileHeaderMinLength + fv.ExtHeaderSize))
		if err != nil {
			return nil, fmt.Errorf("building ExtHeader %v", err)
		}
		if err := extHeaderFile.ChecksumAndAssemble(extHeader.Bytes()); err != nil {
			return nil, fmt.Errorf("building ExtHeader %v", err)
		}

		// Add the extended header in a Padfile just after the header.
		extHeaderFileBuf := extHeaderFile.Buf()
		if err = fv.InsertFile(fv.DataOffset, extHeaderFileBuf); err != nil {
			return nil, fmt.Errorf("adding ExtHeader %v", err)
		}
		fv.DataOffset += uint64(len(extHeaderFileBuf))
	}
	// Add empty space
	extLen := fv.Length - fv.DataOffset
	emptyBuf := make([]byte, extLen)
	uefi.Erase(emptyBuf, uefi.Attributes.ErasePolarity)

	// Store the buffer in
	fv.SetBuf(append(fv.Buf(), emptyBuf...))

	// Make sure DataOffset is 8 byte aligned at least.
	fv.DataOffset = uefi.Align8(fv.DataOffset)

	// Internal fields
	fv.FVOffset = fvOffset
	fv.FreeSpace = fv.Length - fv.DataOffset

	return fv, nil
}

func init() {
	RegisterCLI("create-fv", "creates a FV given an offset, size and volume GUID (can only replace a BIOS Padding)", 3, func(args []string) (uefi.Visitor, error) {
		offset, err := strconv.ParseUint(args[0], 0, 64)
		if err != nil {
			return nil, err
		}
		size, err := strconv.ParseUint(args[1], 0, 64)
		if err != nil {
			return nil, err
		}
		name, err := guid.Parse(args[2])
		if err != nil {
			return nil, err
		}
		return &CreateFV{
			AbsOffset: offset,
			Size:      size,
			Name:      *name,
		}, nil
	})
}

```

`pkg/visitors/createfv_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

type testLayout struct {
	Type   string
	offset uint64
	length uint64
}

func checkBRLayout(t *testing.T, br *uefi.BIOSRegion, layout []testLayout) {
	// basic check
	if len(br.Elements) != len(layout) {
		t.Fatalf("wrong number of elements in BIOSRegion, got %d want %d", len(br.Elements), len(layout))
	}

	var nextoffset uint64
	// check the final layout
	for i, e := range br.Elements {
		var offset, length uint64
		switch f := e.Value.(type) {
		case *uefi.FirmwareVolume:
			offset = f.FVOffset
			length = f.Length
		case *uefi.BIOSPadding:
			offset = f.Offset
			length = uint64(len(f.Buf()))
		default:
			t.Fatalf("Unexpected Element at %d: %s", i, e.Type)
		}
		if e.Type != layout[i].Type {
			t.Errorf("Wrong Element Type at %d, got %s, want %s", i, e.Type, layout[i].Type)
		}
		if offset != layout[i].offset {
			t.Errorf("Wrong Element offset at %d, got %#x, want %#x", i, offset, layout[i].offset)
		}
		if length != layout[i].length {
			t.Errorf("Wrong Element length at %d, got %#x, want %#x", i, length, layout[i].length)
		}
		// sanity check
		if layout[i].offset != nextoffset {
			t.Errorf("Next offset inconsistency got %#x, want %#x", layout[i].offset, nextoffset)
		}
		nextoffset = layout[i].offset + layout[i].length
	}
	if br.Length != nextoffset {
		t.Errorf("Next offset inconsistency got %#x, want %#x", br.Length, nextoffset)
	}

}

func TestInsertFVinBP(t *testing.T) {
	// Create an empty BIOSRegion
	buf := make([]byte, 0x10000)
	uefi.Erase(buf, uefi.Attributes.ErasePolarity)
	r, err := uefi.NewBIOSRegion(buf, nil, uefi.RegionTypeBIOS)
	if err != nil {
		t.Fatal(err)
	}
	br := r.(*uefi.BIOSRegion)

	// Create an FV in the middle to check
	// creation of padding before and after FV
	fv, err := createEmptyFirmwareVolume(0x8000, 0x1000, nil)
	if err != nil {
		t.Fatal(err)
	}
	bp := br.Elements[0].Value.(*uefi.BIOSPadding)
	err = insertFVinBP(br, 0x8000, bp, 0, fv)
	if err != nil {
		t.Fatal(err)
	}
	// basic check
	if len(br.Elements) != 3 {
		t.Fatalf("wrong number of elements in BIOSRegion, got %d want 3", len(br.Elements))
	}

	// Create an FV at the beginning to check
	// - no padding creation before the FV
	// - no existing elements lost after the FV
	fv, err = createEmptyFirmwareVolume(0, 0x1000, nil)
	if err != nil {
		t.Fatal(err)
	}
	bp = br.Elements[0].Value.(*uefi.BIOSPadding)
	err = insertFVinBP(br, 0, bp, 0, fv)
	if err != nil {
		t.Fatal(err)
	}
	// basic check
	if len(br.Elements) != 4 {
		t.Fatalf("wrong number of elements in BIOSRegion, got %d want 4", len(br.Elements))
	}

	// Create an FV just before first created FV to check
	// - no padding creation after the FV
	// - no existing elements lost before and after the FV
	fv, err = createEmptyFirmwareVolume(0x7000, 0x1000, nil)
	if err != nil {
		t.Fatal(err)
	}
	bp = br.Elements[1].Value.(*uefi.BIOSPadding)
	err = insertFVinBP(br, 0x7000, bp, 1, fv)
	if err != nil {
		t.Fatal(err)
	}
	// basic check
	if len(br.Elements) != 5 {
		t.Fatalf("wrong number of elements in BIOSRegion, got %d want 4", len(br.Elements))
	}

	var want = []testLayout{
		{"*uefi.FirmwareVolume", 0, 0x1000},
		{"*uefi.BIOSPadding", 0x1000, 0x6000},
		{"*uefi.FirmwareVolume", 0x7000, 0x1000},
		{"*uefi.FirmwareVolume", 0x8000, 0x1000},
		{"*uefi.BIOSPadding", 0x9000, 0x7000},
	}
	checkBRLayout(t, br, want)
}

func TestCreateFV(t *testing.T) {
	// Set erasepolarity to FF
	uefi.Attributes.ErasePolarity = 0xFF
	// Create an empty BIOSRegion
	buf := make([]byte, 0x10000)
	uefi.Erase(buf, uefi.Attributes.ErasePolarity)
	r, err := uefi.NewBIOSRegion(buf, nil, uefi.RegionTypeBIOS)
	if err != nil {
		t.Fatal(err)
	}
	// Create the visitor
	v := &CreateFV{
		AbsOffset: 0x8000,
		Size:      0x1000,
		Name:      *guid.MustParse("DECAFBAD-0000-0000-0000-000000000000"),
	}

	if err := v.Run(r); err != nil {
		t.Fatalf("Failed to create firmware volume, got %v", err)
	}

	br := r.(*uefi.BIOSRegion)
	want := []testLayout{
		{"*uefi.BIOSPadding", 0x0000, 0x8000},
		{"*uefi.FirmwareVolume", 0x8000, 0x1000},
		{"*uefi.BIOSPadding", 0x9000, 0x7000},
	}
	checkBRLayout(t, br, want)

}

```

`pkg/visitors/dump.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"errors"
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Dump a firmware file using a GUID or a name
type Dump struct {
	// Input
	Predicate func(f uefi.Firmware) bool

	// Output
	// The file is written to this writer.
	W io.Writer
}

// Run just calls the visitor
func (v *Dump) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit uses find to dump a file to W.
func (v *Dump) Visit(f uefi.Firmware) error {
	// First run "find" to generate a list to dump
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	// There must only be one match.
	if numMatch := len(find.Matches); numMatch > 1 {
		return fmt.Errorf("more than one match, only one match allowed! got %v", find.Matches)
	} else if numMatch == 0 {
		return errors.New("no matches found")
	}

	m := find.Matches[0]
	// TODO: We may need to call assemble here before dumping as the buffer may be empty
	_, err := v.W.Write(m.Buf())
	return err
}

func init() {
	RegisterCLI("dump", "dump a firmware file", 2, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}

		file, err := os.OpenFile(args[1], os.O_RDWR|os.O_CREATE, 0755)
		if err != nil {
			return nil, err
		}

		// Find all the matching files and replace their inner PE32s.
		return &Dump{
			Predicate: pred,
			W:         file,
		}, nil
	})
}

```

`pkg/visitors/dump_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"os"
	"testing"
)

func TestDump(t *testing.T) {
	f := parseImage(t)

	b := bytes.Buffer{}
	// Apply the visitor.
	dump := &Dump{
		Predicate: FindFileGUIDPredicate(*testGUID),
		W:         &b,
	}
	if err := dump.Run(f); err != nil {
		t.Fatal(err)
	}

	// Read in expected file.
	file, err := os.ReadFile("../../integration/roms/testfile.ffs")
	if err != nil {
		t.Fatal(err)
	}
	// W should now contain the file.
	if !bytes.Equal(b.Bytes(), file) {
		// TODO: Should dump the file somewhere for comparison.
		t.Errorf("files are not equal! expected file is in integration/roms/testfile.ffs")
	}
}

```

`pkg/visitors/dxecleaner.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"context"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"regexp"
	"strings"
	"syscall"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// DXECleaner removes DXEs sequentially in multiple rounds. Each round, an
// attempt is made to remove each DXE. The Test function determines if the
// removal was successful. Additional rounds are performed until all DXEs are
// removed.
type DXECleaner struct {
	// This function tests whether the firmware boots. The return values can be:
	//
	//     - (false, nil): The firmware was tested and failed to boot.
	//     - (false, err): The firmware was tested and failed to boot due to err.
	//     - (true, nil):  The firmware was tested and booted.
	//     - (true, err):  Failed to test the firmware due to err.
	Test func(f uefi.Firmware) (bool, error)

	// Predicate to determine whether a DXE can be removed.
	Predicate FindPredicate

	// List of GUIDs which were removed.
	Removals []guid.GUID

	// Logs are written to this writer.
	W io.Writer
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *DXECleaner) Run(f uefi.Firmware) error {
	var printf = func(format string, a ...interface{}) {
		if v.W != nil {
			fmt.Fprintf(v.W, format, a...)
		}
	}

	// Find list of DXEs.
	find := (&Find{Predicate: v.Predicate})
	if err := find.Run(f); err != nil {
		return err
	}
	var dxes []guid.GUID
	for i := range find.Matches {
		dxes = append(dxes, find.Matches[i].(*uefi.File).Header.GUID)
	}
	if len(dxes) == 0 {
		return errors.New("found no DXEs in firmware image")
	}

	// Print list of removals in a format which can be passed back into UTK.
	defer func() {
		printf("Summary of removed DXEs:\n")
		if len(v.Removals) == 0 {
			printf("  Could not remove any DXEs\n")
		} else {
			for _, r := range v.Removals {
				printf("  remove %s \\\n", r)
			}
		}
	}()

	// Main algorithm to remove DXEs.
	moreRoundsNeeded := true
	for i := 0; moreRoundsNeeded; i++ {
		printf("Beginning of round %d\n", i+1)
		moreRoundsNeeded = false
		for i := 0; i < len(dxes); i++ {
			// Remove the DXE from the image.
			printf("Trying to remove %v\n", dxes[i])
			remove := &Remove{Predicate: FindFileGUIDPredicate(dxes[i])}
			if err := remove.Run(f); err != nil {
				return err
			}

			if removedSuccessfully, err := v.Test(f); err == context.Canceled {
				printf("Canceled by user %v!\n", dxes[i])
				return nil
			} else if removedSuccessfully && err != nil {
				return err
			} else if removedSuccessfully {
				printf("  Success %v!\n", dxes[i])
				v.Removals = append(v.Removals, dxes[i])
				dxes = append(dxes[:i], dxes[i+1:]...)
				i--
				moreRoundsNeeded = true
			} else {
				printf("  Failed %v!\n", dxes[i])
				remove.Undo()
			}
		}
	}
	return nil
}

// Visit applies the DXEClearn visitor to any Firmware type.
func (v *DXECleaner) Visit(f uefi.Firmware) error {
	return nil
}

// readBlackList returns a regex to filter DXEs according to the black list
// file. Each line in the black list is the GUID or name of a firmware file.
// Empty lines and lines beginning with '#' are ignored.
func parseBlackList(fileName, fileContents string) (string, error) {
	blackList := ""
	for i, line := range strings.Split(fileContents, "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		// skip multiple words, We need this for linuxboot file parsing
		fw := strings.Split(line, " ")[0]
		_, err := regexp.Compile(fw)
		if err != nil {
			return "", fmt.Errorf("cannot compile regex %q from blacklist file %q on line %v: %v",
				fw, fileName, i, err)
		}
		blackList += "|(" + fw + ")"
	}
	if blackList != "" {
		blackList = blackList[1:]
	}
	return blackList, nil
}

func init() {
	register := func(args []string) (uefi.Visitor, error) {
		// When the user enters CTRL-C, the DXECleaner should stop, but
		// also output the current progress.
		ctx, cancel := context.WithCancel(context.Background())
		c := make(chan os.Signal, 1)
		signal.Notify(c, os.Interrupt)
		go func() {
			<-c
			cancel()
		}()

		predicate := FindFileTypePredicate(uefi.FVFileTypeDriver)

		// Create blacklist for DXEs which can be skipped.
		useBlackList := len(args) == 2
		if useBlackList {
			fileName := args[1]
			fileContents, err := os.ReadFile(fileName)
			if err != nil {
				return nil, fmt.Errorf("cannot read blacklist file %q: %v", fileName, err)
			}
			blackListRegex, err := parseBlackList(fileName, string(fileContents))
			if err != nil {
				return nil, err
			}
			if blackListRegex != "" {
				blackListPredicate, err := FindFilePredicate(blackListRegex)
				if err != nil {
					return nil, err
				}
				predicate = FindAndPredicate(predicate, FindNotPredicate(blackListPredicate))
			}
		}

		return &DXECleaner{
			Test: func(f uefi.Firmware) (bool, error) {
				tmpDir, err := os.MkdirTemp("", "dxecleaner")
				if err != nil {
					return true, err
				}
				defer os.RemoveAll(tmpDir)
				tmpFile := filepath.Join(tmpDir, "bios.bin")

				if err := (&Save{tmpFile}).Run(f); err != nil {
					return true, err
				}
				cmd := exec.CommandContext(ctx, args[0], tmpFile)
				cmd.Stdin, cmd.Stdout, cmd.Stderr = os.Stdin, os.Stdout, os.Stderr
				if err := cmd.Run(); err != nil {
					if _, ok := err.(*exec.ExitError); !ok {
						return true, err
					}
					status, ok := err.(*exec.ExitError).Sys().(syscall.WaitStatus)
					if !ok {
						return true, err
					}
					switch status.ExitStatus() {
					case 1:
						return true, err
					case 2:
						return false, err
					default:
						return true, fmt.Errorf("unexpected exit status %d", status.ExitStatus())
					}
				}
				return true, nil
			},
			Predicate: predicate,
			W:         os.Stdout,
		}, nil
	}

	RegisterCLI("dxecleaner", "automates removal of UEFI drivers", 1, register)
	RegisterCLI("dxecleaner_blacklist", "automates removal of UEFI drivers with a blacklist file", 2, register)
}

```

`pkg/visitors/dxecleaner_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	testDXE1 = guid.MustParse("93B80004-9FB3-11D4-9A3A-0090273FC14D")
	testDXE2 = guid.MustParse("4B28E4C7-FF36-4E10-93CF-A82159E777C5")
	testDXE3 = guid.MustParse("C8339973-A563-4561-B858-D8476F9DEFC4")
	testDXE4 = guid.MustParse("378D7B65-8DA9-4773-B6E4-A47826A833E1")
	testDXE5 = guid.MustParse("33CB97AF-6C33-4C42-986B-07581FA366D4")
)

func contains(t *testing.T, f uefi.Firmware, g *guid.GUID) bool {
	return len(find(t, f, g)) > 0
}

func TestDXECleaner(t *testing.T) {
	// This test to see if an image "boots" by looking for fake dependencies
	// between the DXEs.
	testDXEDependencies := func(f uefi.Firmware) (bool, error) {
		// Dependencies
		return contains(t, f, testDXE5) &&
			(!contains(t, f, testDXE5) || contains(t, f, testDXE4)) &&
			(!contains(t, f, testDXE2) || contains(t, f, testDXE1)) &&
			(!contains(t, f, testDXE3) || contains(t, f, testDXE2)), nil
	}

	// Parse image and run the visitor.
	f := parseImage(t)
	dxeCleaner := DXECleaner{
		Test:      testDXEDependencies,
		Predicate: FindFileTypePredicate(uefi.FVFileTypeDriver),
		W:         os.Stdout,
	}
	if err := dxeCleaner.Run(f); err != nil {
		t.Fatal(err)
	}

	// Check that the correct DXEs remain.
	for _, d := range []*guid.GUID{testDXE1, testDXE2, testDXE3} {
		if contains(t, f, d) {
			t.Errorf("expected %v to be deleted", d)
		}
	}
	for _, d := range []*guid.GUID{testDXE4, testDXE5} {
		if !contains(t, f, d) {
			t.Errorf("expected %v to be remain", d)
		}
	}
}

func TestParseBlackList(t *testing.T) {
	tests := []struct {
		name, input, output string
	}{
		{"empty_file", "", ""},
		{"regex_and_comments", "a.*c \nde\n # comment\nf\n", "(a.*c)|(de)|(f)"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			re, err := parseBlackList(tt.name, tt.input)
			if err != nil {
				t.Error(err)
			}
			if re != tt.output {
				t.Errorf("parseBlackList() = %q; want %q", re, tt.output)
			}
		})
	}
}

```

`pkg/visitors/extract.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	force  = flag.Bool("force", false, "force extract to non empty directory")
	remove = flag.Bool("remove", false, "remove existing directory before extracting")
)

// Extract extracts any Firmware node to DirPath
type Extract struct {
	BasePath string
	DirPath  string
	Index    *uint64
}

// extractBinary simply dumps the binary to a specified directory and filename.
// It creates the directory if it doesn't already exist, and dumps the buffer to it.
// It returns the filepath of the binary, and an error if it exists.
// This is meant as a helper function for other Extract functions.
func (v *Extract) extractBinary(buf []byte, filename string) (string, error) {
	// Create the directory if it doesn't exist
	dirPath := filepath.Join(v.BasePath, v.DirPath)
	if err := os.MkdirAll(dirPath, 0755); err != nil {
		return "", err
	}

	// Dump the binary.
	fp := filepath.Join(dirPath, filename)
	if err := os.WriteFile(fp, buf, 0666); err != nil {
		// Make sure we return "" since we don't want an invalid path to be serialized out.
		return "", err
	}
	// Return only the relative path from the root of the tree
	return filepath.Join(v.DirPath, filename), nil
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Extract) Run(f uefi.Firmware) error {
	// Optionally remove directory if it already exists.
	if *remove {
		if err := os.RemoveAll(v.BasePath); err != nil {
			return err
		}
	}

	if !*force {
		// Check that directory does not exist or is empty.
		files, err := os.ReadDir(v.BasePath)
		if err == nil {
			if len(files) != 0 {
				return errors.New("existing directory not empty, use --force to override")
			}
		} else if !os.IsNotExist(err) {
			// Error was not EEXIST, we do not know what went wrong.
			return err
		}
	}

	// Create the directory if it does not exist.
	if err := os.MkdirAll(v.BasePath, 0755); err != nil {
		return err
	}

	// Reset the index
	*v.Index = 0
	if err := f.Apply(v); err != nil {
		return err
	}

	// Output summary json.
	json, err := uefi.MarshalFirmware(f)
	if err != nil {
		return err
	}
	return os.WriteFile(filepath.Join(v.BasePath, "summary.json"), json, 0666)
}

// Visit applies the Extract visitor to any Firmware type.
func (v *Extract) Visit(f uefi.Firmware) error {
	// The visitor must be cloned before modification; otherwise, the
	// sibling's values are modified.
	v2 := *v

	var err error
	switch f := f.(type) {

	case *uefi.FirmwareVolume:
		v2.DirPath = filepath.Join(v.DirPath, fmt.Sprintf("%#x", f.FVOffset))
		if len(f.Files) == 0 {
			f.ExtractPath, err = v2.extractBinary(f.Buf(), "fv.bin")
		} else {
			f.ExtractPath, err = v2.extractBinary(f.Buf()[:f.DataOffset], "fvh.bin")
		}

	case *uefi.File:
		// For files we use the GUID as the folder name.
		v2.DirPath = filepath.Join(v.DirPath, f.Header.GUID.String())
		// Crappy hack to make unique ids unique
		v2.DirPath = filepath.Join(v2.DirPath, fmt.Sprint(*v.Index))
		*v.Index++
		if len(f.Sections) == 0 && f.NVarStore == nil {
			f.ExtractPath, err = v2.extractBinary(f.Buf(), fmt.Sprintf("%v.ffs", f.Header.GUID))
		}

	case *uefi.Section:
		// For sections we use the file order as the folder name.
		v2.DirPath = filepath.Join(v.DirPath, fmt.Sprint(f.FileOrder))
		if len(f.Encapsulated) == 0 {
			f.ExtractPath, err = v2.extractBinary(f.Buf(), fmt.Sprintf("%v.sec", f.FileOrder))
		}

	case *uefi.NVar:
		// For NVar we use the GUID as the folder name the Name as file name and add the offset to links to make them unique
		v2.DirPath = filepath.Join(v.DirPath, f.GUID.String())
		if f.IsValid() {
			if f.NVarStore == nil {
				if f.Type == uefi.LinkNVarEntry {
					f.ExtractPath, err = v2.extractBinary(f.Buf()[f.DataOffset:], fmt.Sprintf("%v-%#x.bin", f.Name, f.Offset))
				} else {
					f.ExtractPath, err = v2.extractBinary(f.Buf()[f.DataOffset:], fmt.Sprintf("%v.bin", f.Name))
				}
			}
		} else {
			f.ExtractPath, err = v2.extractBinary(f.Buf(), fmt.Sprintf("%#x.nvar", f.Offset))
		}

	case *uefi.FlashDescriptor:
		v2.DirPath = filepath.Join(v.DirPath, "ifd")
		f.ExtractPath, err = v2.extractBinary(f.Buf(), "flashdescriptor.bin")

	case *uefi.BIOSRegion:
		v2.DirPath = filepath.Join(v.DirPath, "bios")
		if len(f.Elements) == 0 {
			f.ExtractPath, err = v2.extractBinary(f.Buf(), "biosregion.bin")
		}

	case *uefi.MERegion:
		v2.DirPath = filepath.Join(v.DirPath, "me")
		f.ExtractPath, err = v2.extractBinary(f.Buf(), "meregion.bin")

	case *uefi.RawRegion:
		v2.DirPath = filepath.Join(v.DirPath, f.Type().String())
		f.ExtractPath, err = v2.extractBinary(f.Buf(), fmt.Sprintf("%#x.bin", f.FlashRegion().BaseOffset()))

	case *uefi.BIOSPadding:
		v2.DirPath = filepath.Join(v.DirPath, fmt.Sprintf("biospad_%#x", f.Offset))
		f.ExtractPath, err = v2.extractBinary(f.Buf(), "pad.bin")
	}
	if err != nil {
		return err
	}

	return f.ApplyChildren(&v2)
}

func init() {
	var fileIndex uint64
	RegisterCLI("extract", "extract dir\n extract the files to directory `dir`", 1, func(args []string) (uefi.Visitor, error) {
		return &Extract{
			BasePath: args[0],
			DirPath:  ".",
			Index:    &fileIndex,
		}, nil
	})
}

```

`pkg/visitors/extract_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"

	utk_test "github.com/linuxboot/fiano/integration"
	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	// File headers
	// Hardcoded checksums for testing :(
	// I don't know how to do it better without rewriting or calling code under test.
	emptyPadHeader = append(uefi.FFGUID[:],
		[]byte{8, uefi.EmptyBodyChecksum, byte(uefi.FVFileTypePad), 0, uefi.FileHeaderMinLength, 0x00, 0x00, 0xF8}...) // Empty pad file header with no data
	goodFreeFormHeader = append(uefi.FFGUID[:],
		[]byte{202, uefi.EmptyBodyChecksum, byte(uefi.FVFileTypeFreeForm), 0, uefi.FileHeaderMinLength, 0x00, 0x00, 0xF8}...) // Empty freeform file header with no data
	nvarStoreHeader = append(uefi.NVAR[:],
		[]byte{182, uefi.EmptyBodyChecksum, byte(uefi.FVFileTypeRaw), 0, uefi.FileHeaderMinLength, 0x00, 0x00, 0xF8}...) // Empty NVAR file header with no data
)

var (
	// File examples
	emptyPadFile     = emptyPadHeader // Empty pad file with no data
	badFreeFormFile  []byte           // File with bad checksum. Should construct fine, but not validate
	goodFreeFormFile []byte           // Good file
	nvarStoreFile    []byte           // File containing an NVarStore
)

func init() {
	goodFreeFormFile = append(goodFreeFormHeader, linuxSec...)
	goodFreeFormFile = append(goodFreeFormFile, smallSec...)
	goodFreeFormFile = append(goodFreeFormFile, []byte{0, 0}...) // Alignment
	goodFreeFormFile = append(goodFreeFormFile, tinySec...)
	goodFreeFormFile[20] = byte(uefi.FileHeaderMinLength + len(tinySec) + 2 + len(linuxSec) + len(smallSec))

	badFreeFormFile = make([]byte, len(goodFreeFormFile))
	copy(badFreeFormFile, goodFreeFormFile)
	badFreeFormFile[16] = 0 // Zero out checksum

	nvarStoreFile = append(nvarStoreHeader, nvarEntryHeader...)
	nvarStoreFile = append(nvarStoreFile, byte(0))
	nvarStoreFile = append(nvarStoreFile, []byte("Test")...)
	nvarStoreFile = append(nvarStoreFile, byte(0))
	nvarStoreFile = append(nvarStoreFile, uefi.FFGUID[:]...)
	nvarStoreFile[20] = byte(uefi.FileHeaderMinLength + len(nvarEntryHeader) + 6 + len(uefi.FFGUID))

}

var (
	// NVAR examples
	nvarEntryHeader = []byte{0x4E, 0x56, 0x41, 0x52, 16, 0, 0xFF, 0xFF, 0xFF, byte(uefi.NVarEntryValid | uefi.NVarEntryASCIIName)}
)

var (
	// Section examples
	tinySec  = []byte{4, 0, 0, byte(uefi.SectionTypeRaw)}                               // Section header with no data
	smallSec = append([]byte{22, 0, 0, byte(uefi.SectionTypeRaw)}, make([]byte, 18)...) // 20 byte Section
	linuxSec = []byte{0x10, 0x00, 0x00, 0x15, 0x4c, 0x00, 0x69, 0x00,
		0x6e, 0x00, 0x75, 0x00, 0x78, 0x00, 0x00, 0x00} // Linux UI section
)

func TestExtractAssembleFile(t *testing.T) {
	var tests = []struct {
		name    string
		origBuf []byte
		newBuf  []byte
	}{
		{"emptyPadFile", emptyPadFile, emptyPadFile},
		{"badFreeFormFile", badFreeFormFile, goodFreeFormFile},
		{"goodFreeFormFile", goodFreeFormFile, goodFreeFormFile},
		{"nvarStoreFile", nvarStoreFile, nvarStoreFile},
	}
	// Set erasepolarity to FF
	uefi.Attributes.ErasePolarity = 0xFF
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			tmpDir := t.TempDir()

			f, err := uefi.NewFile(test.origBuf)
			if err != nil {
				t.Fatalf("Unable to parse file object %v, got %v", test.origBuf, err.Error())
			}
			var fIndex uint64
			if err = f.Apply(&Extract{BasePath: tmpDir, DirPath: ".", Index: &fIndex}); err != nil {
				t.Fatalf("Unable to extract file %v, got %v", test.origBuf, err.Error())
			}
			if err = f.Apply(&ParseDir{BasePath: tmpDir}); err != nil {
				t.Fatalf("Unable to parse files %v, got %v", test.origBuf, err.Error())
			}
			if err = f.Apply(&Assemble{}); err != nil {
				t.Fatalf("Unable to reassemble file %v, got %v", test.origBuf, err.Error())
			}
			nb := f.Buf()
			if len(test.newBuf) != len(nb) {
				t.Fatalf("Binary sizes differ!\n Expected: %v\n Assembled: %v\n", len(test.newBuf), len(nb))
			}
			for i := range test.newBuf {
				if test.newBuf[i] != nb[i] {
					t.Fatalf("Binaries differ at %v!\n Expected: %v\n Assembled: %v\n", i, test.newBuf[i], nb[i])
				}
			}
		})
	}
}

func TestExtractAssembleFV(t *testing.T) {
	var tests = []struct {
		name    string
		origBuf []byte
		newBuf  []byte
	}{
		{"sampleFV", utk_test.OVMFSecFV, utk_test.OVMFSecFV},
	}
	// Set erasepolarity to FF
	uefi.Attributes.ErasePolarity = 0xFF
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			tmpDir := t.TempDir()

			fv, err := uefi.NewFirmwareVolume(test.origBuf, 0, false)
			if err != nil {
				t.Fatalf("Unable to parse file object %v, got %v", test.origBuf, err.Error())
			}
			var fIndex uint64
			if err = fv.Apply(&Extract{BasePath: tmpDir, DirPath: ".", Index: &fIndex}); err != nil {
				t.Fatalf("Unable to extract file %v, got %v", test.origBuf, err.Error())
			}
			if err = fv.Apply(&ParseDir{BasePath: tmpDir}); err != nil {
				t.Fatalf("Unable to parse files %v, got %v", test.origBuf, err.Error())
			}
			if err = fv.Apply(&Assemble{}); err != nil {
				t.Fatalf("Unable to reassemble file %v, got %v", test.origBuf, err.Error())
			}
			nb := fv.Buf()
			if len(test.newBuf) != len(nb) {
				t.Fatalf("Binary sizes differ!\n Expected: %v\n Assembled: %v\n", len(test.newBuf), len(nb))
			}
			for i := range test.newBuf {
				if test.newBuf[i] != nb[i] {
					t.Fatalf("Binaries differ at %v!\n Expected: %v\n Assembled: %v\n", i, test.newBuf[i], nb[i])
				}
			}
		})
	}
}

func TestExtractAssembleSection(t *testing.T) {
	var tests = []struct {
		name      string
		buf       []byte
		fileOrder int
	}{
		{"tinySec", tinySec, 0},
		{"tinySec", tinySec, 1},
		{"smallSec", smallSec, 0},
		{"smallSec", smallSec, 1},
		{"linuxSec", linuxSec, 0},
		{"linuxSec", linuxSec, 1},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			tmpDir := t.TempDir()

			s, err := uefi.NewSection(test.buf, test.fileOrder)
			if err != nil {
				t.Fatalf("Unable to parse section object %v, got %v", test.buf, err.Error())
			}
			var fIndex uint64
			if err = s.Apply(&Extract{BasePath: tmpDir, DirPath: ".", Index: &fIndex}); err != nil {
				t.Fatalf("Unable to extract section %v, got %v", test.buf, err.Error())
			}
			if err = s.Apply(&ParseDir{BasePath: tmpDir}); err != nil {
				t.Fatalf("Unable to parse files %v, got %v", test.buf, err.Error())
			}
			if err = s.Apply(&Assemble{}); err != nil {
				t.Fatalf("Unable to reassemble file %v, got %v", test.buf, err.Error())
			}
			nb := s.Buf()
			if len(test.buf) != len(nb) {
				t.Fatalf("Binary sizes differ!\n Expected: %v\n Assembled: %v\n", len(test.buf), len(nb))
			}
			for i := range test.buf {
				if test.buf[i] != nb[i] {
					t.Fatalf("Binaries differ at %v!\n Expected: %v\n Assembled: %v\n", i, test.buf[i], nb[i])
				}
			}
		})
	}
}

```

`pkg/visitors/find.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"regexp"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// FindPredicate is used to filter matches in the Find visitor.
type FindPredicate = func(f uefi.Firmware) bool

// Find a firmware file given its name or GUID.
type Find struct {
	// Input
	// Only when this functions returns true will the file appear in the
	// `Matches` slice.
	Predicate FindPredicate

	// Output
	Matches []uefi.Firmware

	// JSON is written to this writer.
	W io.Writer

	// Private
	currentFile *uefi.File
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Find) Run(f uefi.Firmware) error {
	if err := f.Apply(v); err != nil {
		return err
	}
	if v.W != nil {
		b, err := json.MarshalIndent(v.Matches, "", "\t")
		if err != nil {
			log.Fatalf("%v", err)
		}
		fmt.Fprintln(v.W, string(b))
	}
	return nil
}

// Visit applies the Find visitor to any Firmware type.
func (v *Find) Visit(f uefi.Firmware) error {
	switch f := f.(type) {

	case *uefi.File:
		// Clone the visitor so the `currentFile` is passed only to descendents.
		v2 := &Find{
			Predicate:   v.Predicate,
			currentFile: f,
		}

		if v.Predicate(f) {
			v.Matches = append(v.Matches, f)
			// Don't match with direct descendents.
			v2.currentFile = nil
		}

		err := f.ApplyChildren(v2)
		v.Matches = append(v.Matches, v2.Matches...) // Merge together
		return err

	case *uefi.Section:
		if v.currentFile != nil && v.Predicate(f) {
			v.Matches = append(v.Matches, v.currentFile)
			v.currentFile = nil // Do not double-match with a sibling if there are duplicate names.
		}
		return f.ApplyChildren(v)

	case *uefi.NVar:
		// don't find NVar embedded in NVar (TODO have a parameter for that ?)
		if v.Predicate(f) {
			v.Matches = append(v.Matches, f)
		}
		return nil

	default:
		if v.Predicate(f) {
			v.Matches = append(v.Matches, f)
		}
		return f.ApplyChildren(v)
	}
}

// FindFileGUIDPredicate is a generic predicate for searching file GUIDs only.
func FindFileGUIDPredicate(r guid.GUID) FindPredicate {
	return func(f uefi.Firmware) bool {
		if f, ok := f.(*uefi.File); ok {
			return f.Header.GUID == r
		}
		return false
	}
}

// FindFileTypePredicate is a generic predicate for searching file types only.
func FindFileTypePredicate(t uefi.FVFileType) FindPredicate {
	return func(f uefi.Firmware) bool {
		if f, ok := f.(*uefi.File); ok {
			return f.Header.Type == t
		}
		return false
	}
}

// FindFilePredicate is a generic predicate for searching files and UI sections only.
func FindFilePredicate(r string) (func(f uefi.Firmware) bool, error) {
	ciRE, err := regexp.Compile("^(?i)(" + r + ")$")
	if err != nil {
		return nil, err
	}
	return func(f uefi.Firmware) bool {
		switch f := f.(type) {
		case *uefi.File:
			return ciRE.MatchString(f.Header.GUID.String())
		case *uefi.Section:
			return ciRE.MatchString(f.Name)
		}
		return false
	}, nil
}

// FindFileFVPredicate is a generic predicate for searching FVs, files and UI sections.
func FindFileFVPredicate(r string) (func(f uefi.Firmware) bool, error) {
	ciRE, err := regexp.Compile("^(?i)" + r + "$")
	if err != nil {
		return nil, err
	}
	return func(f uefi.Firmware) bool {
		switch f := f.(type) {
		case *uefi.FirmwareVolume:
			return ciRE.MatchString(f.FVName.String())
		case *uefi.File:
			return ciRE.MatchString(f.Header.GUID.String())
		case *uefi.Section:
			return ciRE.MatchString(f.Name)
		}
		return false
	}, nil
}

// FindNotPredicate is a generic predicate which takes the logical NOT of an existing predicate.
func FindNotPredicate(predicate FindPredicate) FindPredicate {
	return func(f uefi.Firmware) bool {
		return !predicate(f)
	}
}

// FindAndPredicate is a generic predicate which takes the logical OR of two existing predicates.
func FindAndPredicate(predicate1 FindPredicate, predicate2 FindPredicate) FindPredicate {
	return func(f uefi.Firmware) bool {
		return predicate1(f) && predicate2(f)
	}
}

// FindExactlyOne does a find using a supplied predicate and errors if there's more than one.
func FindExactlyOne(f uefi.Firmware, pred func(f uefi.Firmware) bool) (uefi.Firmware, error) {
	find := &Find{
		Predicate: pred,
	}
	if err := find.Run(f); err != nil {
		return nil, err
	}
	// There should only be one match, there should only be one Dxe Core.
	if mlen := len(find.Matches); mlen != 1 {
		return nil, fmt.Errorf("expected exactly one match, got %v, matches were: %v", mlen, find.Matches)
	}
	return find.Matches[0], nil
}

// FindEnclosingFV finds the FV that contains a file.
func FindEnclosingFV(f uefi.Firmware, file *uefi.File) (*uefi.FirmwareVolume, error) {
	pred := func(f uefi.Firmware) bool {
		switch f := f.(type) {
		case *uefi.FirmwareVolume:
			for _, v := range f.Files {
				if v == file {
					return true
				}
			}
		}
		return false
	}
	dxeFV, err := FindExactlyOne(f, pred)
	if err != nil {
		return nil, fmt.Errorf("unable to find DXE FV, got: %v", err)
	}
	// result must be a FV.
	fv, ok := dxeFV.(*uefi.FirmwareVolume)
	if !ok {
		return nil, fmt.Errorf("result was not a firmware volume! was type %T", dxeFV)
	}

	return fv, nil
}

// FindDXEFV is a helper function to quickly retrieve the firmware volume that contains the DxeCore.
func FindDXEFV(f uefi.Firmware) (*uefi.FirmwareVolume, error) {
	// We identify the Dxe Firmware Volume via the presence of the DxeCore
	// This will cause problems if there are multiple dxe volumes.
	pred := FindFileTypePredicate(uefi.FVFileTypeDXECore)
	dxeCore, err := FindExactlyOne(f, pred)
	if err != nil {
		return nil, fmt.Errorf("unable to find DXE Core, got: %v", err)
	}

	// result must be a File.
	file, ok := dxeCore.(*uefi.File)
	if !ok {
		return nil, fmt.Errorf("result was not a file! was type %T", file)
	}
	return FindEnclosingFV(f, file)
}

// FindNVarPredicate is a generic predicate for searching NVar only.
func FindNVarPredicate(r string) (func(f uefi.Firmware) bool, error) {
	searchRE, err := regexp.Compile("^(" + r + ")$")
	if err != nil {
		return nil, err
	}
	return func(f uefi.Firmware) bool {
		switch f := f.(type) {
		case *uefi.NVar:
			return searchRE.MatchString(f.Name)
		}
		return false
	}, nil
}

func init() {
	RegisterCLI("find", "find a file by GUID or Name", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &Find{
			Predicate: pred,
			W:         os.Stdout,
		}, nil
	})
	RegisterCLI("find_nvar", "find an NVAR by Name", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindNVarPredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &Find{
			Predicate: pred,
			W:         os.Stdout,
		}, nil
	})
}

```

`pkg/visitors/find_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/uefi"
)

func TestFind(t *testing.T) {
	f := parseImage(t)
	results := find(t, f, testGUID)

	// We expect one match
	if len(results) != 1 {
		t.Fatalf("got %d matches; expected 1", len(results))
	}
}

func TestFindExactlyOne(t *testing.T) {
	f := parseImage(t)
	_, err := FindExactlyOne(f, func(_ uefi.Firmware) bool {
		return true
	})
	if err == nil {
		t.Errorf("should have an error from matching too many, got no error")
	}

	_, err = FindExactlyOne(f, func(_ uefi.Firmware) bool {
		return false
	})
	if err == nil {
		t.Errorf("should have an error from matching none, got no error")
	}

	pred := FindFileTypePredicate(uefi.FVFileTypeDXECore)
	res, err := FindExactlyOne(f, pred)
	if err != nil {
		t.Fatalf("should match one Dxe Core, got: %v", err)
	}

	dxecore, ok := res.(*uefi.File)
	if !ok {
		t.Fatalf("result was not a file, got %T", res)
	}
	if dxecore.Header.Type != uefi.FVFileTypeDXECore {
		t.Errorf("result was not the correct file type! got %v", dxecore.Header.Type)
	}
}

func TestFindDXEFV(t *testing.T) {
	f := parseImage(t)
	fv, err := FindDXEFV(f)
	if err != nil {
		t.Fatalf("should return one dxe FV, got err: %v", err)
	}

	if fv == nil {
		t.Fatalf("got nil fv")
	}

	// Search through files for dxecore
	var found bool
	for _, v := range fv.Files {
		if v.Header.Type == uefi.FVFileTypeDXECore {
			found = true
		}
	}

	if !found {
		t.Errorf("unable to find DXECore in fv's files, this is probably not the DXE firmware volume")
	}
}

```

`pkg/visitors/flatten.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Flatten places all nodes into a single slice and removes their children.
// Each node contains the index of its parent (the root node's parent is
// itself). This format is suitable for insertion into a database.
type Flatten struct {
	// Optionally write result as JSON.
	W io.Writer

	// Outputted flattened tree.
	List []FlattenedFirmware

	parent int
}

// FlattenedFirmware appears in the Flatten.List, contains the index of the
// parrent and has no children.
type FlattenedFirmware struct {
	Parent int
	Type   string
	Value  uefi.Firmware
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Flatten) Run(f uefi.Firmware) error {
	if err := f.Apply(v); err != nil {
		return err
	}

	// Remove children otherwise the output contains many duplicates of each node.
	for _, f := range v.List {
		switch f := f.Value.(type) {
		case *uefi.BIOSRegion:
			f.Elements = nil
		case *uefi.File:
			f.Sections = nil
		case *uefi.FirmwareVolume:
			f.Files = nil
		case *uefi.FlashImage:
			// TODO: Cannot remove IFD
			// f.IFD = nil
			f.Regions = nil
		case *uefi.Section:
			f.Encapsulated = nil
		}
	}

	// Optionally print as JSON
	if v.W != nil {
		b, err := json.MarshalIndent(v.List, "", "\t")
		if err != nil {
			return err
		}
		_, err = fmt.Fprintln(v.W, string(b))
		return err
	}
	return nil
}

// Visit applies the Flatten visitor to any Firmware type.
func (v *Flatten) Visit(f uefi.Firmware) error {
	parent := v.parent
	v.parent = len(v.List)
	v.List = append(v.List, FlattenedFirmware{
		Parent: parent,
		Type:   fmt.Sprintf("%T", f),
		Value:  f,
	})
	if err := f.ApplyChildren(v); err != nil {
		return err
	}
	v.parent = parent
	return nil
}

func init() {
	RegisterCLI("flatten", "prints a JSON list of nodes", 0, func(args []string) (uefi.Visitor, error) {
		return &Flatten{
			W: os.Stdout,
		}, nil
	})
}

```

`pkg/visitors/helpers_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// This GUID exists somewhere in the OVMF image.
var testGUID = guid.MustParse("DF1CCEF6-F301-4A63-9661-FC6030DCC880")
var dxeCoreGUID = guid.MustParse("D6A2CB7F-6A18-4E2F-B43B-9920A733700A")

func parseImage(t *testing.T) uefi.Firmware {
	image, err := os.ReadFile("../../integration/roms/OVMF.rom")
	if err != nil {
		t.Fatal(err)
	}
	parsedRoot, err := uefi.Parse(image)
	if err != nil {
		t.Fatal(err)
	}
	return parsedRoot
}

func find(t *testing.T, f uefi.Firmware, guid *guid.GUID) []uefi.Firmware {
	find := &Find{
		Predicate: FindFileGUIDPredicate(*guid),
	}
	if err := find.Run(f); err != nil {
		t.Fatal(err)
	}
	return find.Matches
}

func comment(t *testing.T, f uefi.Firmware) []uefi.Firmware {
	var b bytes.Buffer
	c := &Comment{W: &b, s: "hi"}
	if err := c.Run(f); err != nil {
		t.Fatal(err)
	}
	if b.String() != "hi\n" {
		t.Fatalf("Comment: go %q, wanted 'hi'", b.String())
	}
	return nil
}

```

`pkg/visitors/insert.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// InsertType defines the insert type operation that is requested
type InsertType int

// Insert Types
const (

	// == Deprectated ==

	// These first two specify a firmware volume.

	// InsertTypeFront inserts a file at the beginning of the firmware volume,
	// which is specified by 1) FVname GUID, or (File GUID/File name) of a file
	// inside that FV.
	InsertTypeFront InsertType = iota
	// InsertTypeEnd inserts a file at the end of the specified firmware volume.
	InsertTypeEnd

	// These two specify a File to insert before or after
	// InsertTypeAfter inserts after the specified file,
	// which is specified by a File GUID or File name.
	InsertTypeAfter
	// InsertTypeBefore inserts before the specified file.
	InsertTypeBefore
	// InsertTypeDXE inserts into the Dxe Firmware Volume. This works by searching
	// for the DxeCore first to identify the Dxe Firmware Volume.
	InsertTypeDXE

	// == Not deprecated ==

	// InsertTypeReplaceFFS replaces the found file with the new FFS. This is used
	// as a shortcut for remove and insert combined, but also when we want to make
	// sure that the starting offset of the new file is the same as the old.
	InsertTypeReplaceFFS
	// TODO: Add InsertIn

	// InsertTypeInsert is generalization of all InsertTypeInsert* above. Arguments:
	// * The first argument specifies the type of what to insert (possible values: "file" or "pad_file")
	// * The second argument specifies the content of what to insert:
	//     - If the first argument is "file" then a path to the file content is expected.
	//     - If the first argument is "pad_file" then the size is expected.
	// * The third argument specifies the preposition of where to insert to (possible values: "front", "end", "after", "before").
	// * The forth argument specifies the preposition object of where to insert to. It could be FV_or_File GUID_or_name.
	//   For example combination "end 5C60F367-A505-419A-859E-2A4FF6CA6FE5" means to insert to the end of volume
	//   "5C60F367-A505-419A-859E-2A4FF6CA6FE5".
	//
	// A complete example: "pad_file 256 after FC510EE7-FFDC-11D4-BD41-0080C73C8881" means to insert a pad file
	// of size 256 bytes after file with GUID "FC510EE7-FFDC-11D4-BD41-0080C73C8881".
	InsertTypeInsert
)

var insertTypeNames = map[InsertType]string{
	InsertTypeInsert:     "insert",
	InsertTypeReplaceFFS: "replace_ffs",

	// Deprecated:
	InsertTypeFront:  "insert_front",
	InsertTypeEnd:    "insert_end",
	InsertTypeAfter:  "insert_after",
	InsertTypeBefore: "insert_before",
	InsertTypeDXE:    "insert_dxe",
}

// String creates a string representation for the insert type.
func (i InsertType) String() string {
	if t, ok := insertTypeNames[i]; ok {
		return t
	}
	return "UNKNOWN"
}

// InsertWhatType defines the type of inserting object
type InsertWhatType int

const (
	InsertWhatTypeUndefined = InsertWhatType(iota)
	InsertWhatTypeFile
	InsertWhatTypePadFile

	EndOfInsertWhatType
)

// String implements fmt.Stringer.
func (t InsertWhatType) String() string {
	switch t {
	case InsertWhatTypeUndefined:
		return "undefined"
	case InsertWhatTypeFile:
		return "file"
	case InsertWhatTypePadFile:
		return "pad_file"
	}
	return fmt.Sprintf("unknown_%d", t)
}

// ParseInsertWhatType converts a string to InsertWhatType
func ParseInsertWhatType(s string) InsertWhatType {
	// TODO: it is currently O(n), optimize

	s = strings.Trim(strings.ToLower(s), " \t")
	for t := InsertWhatTypeUndefined; t < EndOfInsertWhatType; t++ {
		if t.String() == s {
			return t
		}
	}
	return InsertWhatTypeUndefined
}

// InsertWherePreposition defines the type of inserting object
type InsertWherePreposition int

const (
	InsertWherePrepositionUndefined = InsertWherePreposition(iota)
	InsertWherePrepositionFront
	InsertWherePrepositionEnd
	InsertWherePrepositionAfter
	InsertWherePrepositionBefore

	EndOfInsertWherePreposition
)

// String implements fmt.Stringer.
func (p InsertWherePreposition) String() string {
	switch p {
	case InsertWherePrepositionUndefined:
		return "undefined"
	case InsertWherePrepositionFront:
		return "front"
	case InsertWherePrepositionEnd:
		return "end"
	case InsertWherePrepositionAfter:
		return "after"
	case InsertWherePrepositionBefore:
		return "before"
	}
	return fmt.Sprintf("unknown_%d", p)
}

// ParseInsertWherePreposition converts a string to InsertWherePreposition
func ParseInsertWherePreposition(s string) InsertWherePreposition {
	// TODO: it is currently O(n), optimize

	s = strings.Trim(strings.ToLower(s), " \t")
	for t := InsertWherePrepositionUndefined; t < EndOfInsertWherePreposition; t++ {
		if t.String() == s {
			return t
		}
	}
	return InsertWherePrepositionUndefined
}

// Insert inserts a firmware file into an FV
type Insert struct {
	// TODO: use InsertWherePreposition to define the location, instead of InsertType

	// Input
	Predicate func(f uefi.Firmware) bool
	NewFile   *uefi.File
	InsertType

	// Matched File
	FileMatch uefi.Firmware
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Insert) Run(f uefi.Firmware) error {
	// First run "find" to generate a position to insert into.
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	if numMatch := len(find.Matches); numMatch > 1 {
		return fmt.Errorf("more than one match, only one match allowed! got %v", find.Matches)
	} else if numMatch == 0 {
		return errors.New("no matches found")
	}

	// Find should only match a file or a firmware volume. If it's an FV, we can
	// edit the FV directly.
	if fvMatch, ok := find.Matches[0].(*uefi.FirmwareVolume); ok {
		switch v.InsertType {
		case InsertTypeFront:
			fvMatch.Files = append([]*uefi.File{v.NewFile}, fvMatch.Files...)
		case InsertTypeEnd:
			fvMatch.Files = append(fvMatch.Files, v.NewFile)
		default:
			return fmt.Errorf("matched FV but insert operation was %s, which only matches Files",
				v.InsertType.String())
		}
		return nil
	}
	var ok bool
	if v.FileMatch, ok = find.Matches[0].(*uefi.File); !ok {
		return fmt.Errorf("match was not a file or a firmware volume: got %T, unable to insert", find.Matches[0])
	}
	// Match is a file, apply visitor.
	return f.Apply(v)
}

// Visit applies the Insert visitor to any Firmware type.
func (v *Insert) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.FirmwareVolume:
		for i := 0; i < len(f.Files); i++ {
			if f.Files[i] == v.FileMatch {
				// TODO: use InsertWherePreposition to define the location, instead of InsertType
				switch v.InsertType {
				case InsertTypeFront:
					f.Files = append([]*uefi.File{v.NewFile}, f.Files...)
				case InsertTypeDXE:
					fallthrough
				case InsertTypeEnd:
					f.Files = append(f.Files, v.NewFile)
				case InsertTypeAfter:
					f.Files = append(f.Files[:i+1], append([]*uefi.File{v.NewFile}, f.Files[i+1:]...)...)
				case InsertTypeBefore:
					f.Files = append(f.Files[:i], append([]*uefi.File{v.NewFile}, f.Files[i:]...)...)
				case InsertTypeReplaceFFS:
					f.Files = append(f.Files[:i], append([]*uefi.File{v.NewFile}, f.Files[i+1:]...)...)
				}
				return nil
			}
		}
	}

	return f.ApplyChildren(v)
}

func parseFile(filePath string) (*uefi.File, error) {
	fileBytes, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("unable to read file '%s': %w", filePath, err)
	}

	file, err := uefi.NewFile(fileBytes)
	if err != nil {
		return nil, fmt.Errorf("unable to parse file '%s': %w", filePath, err)
	}

	return file, nil
}

func genInsertRegularFileCLI(iType InsertType) func(args []string) (uefi.Visitor, error) {
	return func(args []string) (uefi.Visitor, error) {
		var pred FindPredicate
		var err error
		var filename string

		if iType == InsertTypeDXE {
			pred = FindFileTypePredicate(uefi.FVFileTypeDXECore)
			filename = args[0]
		} else {
			pred, err = FindFileFVPredicate(args[0])
			if err != nil {
				return nil, err
			}
			filename = args[1]
		}

		file, err := parseFile(filename)
		if err != nil {
			return nil, fmt.Errorf("unable to parse file '%s': %w", args[1], err)
		}

		// Insert File.
		return &Insert{
			Predicate:  pred,
			NewFile:    file,
			InsertType: iType,
		}, nil
	}
}

func genInsertFileCLI() func(args []string) (uefi.Visitor, error) {
	return func(args []string) (uefi.Visitor, error) {
		whatType := ParseInsertWhatType(args[0])
		if whatType == InsertWhatTypeUndefined {
			return nil, fmt.Errorf("unknown what-type: '%s'", args[0])
		}

		var file *uefi.File
		switch whatType {
		case InsertWhatTypeFile:
			var err error
			file, err = parseFile(args[1])
			if err != nil {
				return nil, fmt.Errorf("unable to parse file '%s': %w", args[1], err)
			}
		case InsertWhatTypePadFile:
			padSize, err := strconv.ParseUint(args[1], 0, 64)
			if err != nil {
				return nil, fmt.Errorf("unable to parse pad file size '%s': %w", args[1], err)
			}
			file, err = uefi.CreatePadFile(padSize)
			if err != nil {
				return nil, fmt.Errorf("unable to create a pad file of size %d: %w", padSize, err)
			}
		default:
			return nil, fmt.Errorf("what-type '%s' is not supported, yet", whatType)
		}

		wherePreposition := ParseInsertWherePreposition(args[2])
		if wherePreposition == InsertWherePrepositionUndefined {
			return nil, fmt.Errorf("unknown where-preposition: '%s'", args[2])
		}

		pred, err := FindFileFVPredicate(args[3])
		if err != nil {
			return nil, fmt.Errorf("unable to parse the predicate parameters '%s': %w", args[0], err)
		}

		// TODO: use InsertWherePreposition to define the location, instead of InsertType
		var insertType InsertType
		switch wherePreposition {
		case InsertWherePrepositionFront:
			insertType = InsertTypeFront
		case InsertWherePrepositionEnd:
			insertType = InsertTypeEnd
		case InsertWherePrepositionAfter:
			insertType = InsertTypeAfter
		case InsertWherePrepositionBefore:
			insertType = InsertTypeBefore
		default:
			return nil, fmt.Errorf("where-preposition '%s' is not supported, yet", wherePreposition)
		}

		// Insert File.
		return &Insert{
			Predicate: pred,
			NewFile:   file,
			// TODO: use InsertWherePreposition to define the location, instead of InsertType
			InsertType: insertType,
		}, nil
	}
}

func init() {
	RegisterCLI(insertTypeNames[InsertTypeInsert],
		"insert a file", 4, genInsertFileCLI())
	RegisterCLI(insertTypeNames[InsertTypeReplaceFFS],
		"replace a file with another file", 2, genInsertRegularFileCLI(InsertTypeReplaceFFS))
	RegisterCLI(insertTypeNames[InsertTypeFront],
		"(deprecated) insert a file at the beginning of a firmware volume", 2, genInsertRegularFileCLI(InsertTypeFront))
	RegisterCLI(insertTypeNames[InsertTypeEnd],
		"(deprecated) insert a file at the end of a firmware volume", 2, genInsertRegularFileCLI(InsertTypeEnd))
	RegisterCLI(insertTypeNames[InsertTypeDXE],
		"(deprecated) insert a file at the end of the DXE firmware volume", 1, genInsertRegularFileCLI(InsertTypeDXE))
	RegisterCLI(insertTypeNames[InsertTypeAfter],
		"(deprecated) insert a file after another file", 2, genInsertRegularFileCLI(InsertTypeAfter))
	RegisterCLI(insertTypeNames[InsertTypeBefore],
		"(deprecated) insert a file before another file", 2, genInsertRegularFileCLI(InsertTypeBefore))
}

```

`pkg/visitors/insert_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"os"
	"strings"
	"testing"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

const (
	insertTestFile = "../../integration/roms/testfile.ffs"
)

func testRunObsoleteInsert(t *testing.T, f uefi.Firmware, insertType InsertType, testGUID guid.GUID) (*Insert, error) {
	file, err := os.ReadFile(insertTestFile)
	if err != nil {
		t.Fatal(err)
	}

	ffs, err := uefi.NewFile(file)
	if err != nil {
		t.Fatal(err)
	}
	// Apply the visitor.
	var pred FindPredicate
	if insertType == InsertTypeDXE {
		pred = FindFileTypePredicate(uefi.FVFileTypeDXECore)
	} else {
		pred = FindFileGUIDPredicate(testGUID)
	}
	insert := &Insert{
		Predicate:  pred,
		NewFile:    ffs,
		InsertType: insertType,
	}

	return insert, insert.Run(f)
}

func TestObsoleteInsert(t *testing.T) {
	var tests = []struct {
		name string
		InsertType
	}{
		{InsertTypeFront.String(), InsertTypeFront},
		{InsertTypeEnd.String(), InsertTypeEnd},
		{InsertTypeAfter.String(), InsertTypeAfter},
		{InsertTypeBefore.String(), InsertTypeBefore},
		{InsertTypeDXE.String(), InsertTypeDXE},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			f := parseImage(t)

			_, err := testRunObsoleteInsert(t, f, test.InsertType, *testGUID)
			if err != nil {
				t.Fatal(err)
			}

			// Now check that f has two copies of testGUID (There was one, we inserted another).
			// TODO: Check for position in the future to make sure we actually insert where we want to.
			find := &Find{
				Predicate: FindFileGUIDPredicate(*testGUID),
			}
			if err = find.Run(f); err != nil {
				t.Fatal(err)
			}
			if len(find.Matches) != 2 {
				t.Errorf("Incorrect number of matches after insertion! expected 2, got %v", len(find.Matches))
			}
		})
	}
}

func testInsertCLI(t *testing.T, whatType InsertWhatType, wherePreposition InsertWherePreposition) {
	f := parseImage(t)

	args := []string{
		whatType.String(),
	}
	switch whatType {
	case InsertWhatTypeFile:
		args = append(args, insertTestFile)
	case InsertWhatTypePadFile:
		args = append(args, "256")
	default:
		t.Fatalf("unknown what-type '%s'", whatType)
	}

	args = append(args, wherePreposition.String(), testGUID.String())

	visitor, err := genInsertFileCLI()(args)
	if err != nil {
		t.Fatal(err)
	}

	if err := visitor.Run(f); err != nil {
		t.Fatal(err)
	}

	switch whatType {
	case InsertWhatTypeFile:
		find := &Find{
			Predicate: FindFileGUIDPredicate(*testGUID),
		}
		if err = find.Run(f); err != nil {
			t.Fatal(err)
		}
		if len(find.Matches) != 2 {
			t.Errorf("incorrect number of matches after insertion! expected 2, got %v", len(find.Matches))
		}
	case InsertWhatTypePadFile:
		find := &Find{
			Predicate: func(f uefi.Firmware) bool {
				file, ok := f.(*uefi.File)
				if !ok {
					return false
				}
				if file.Header.GUID.String() != "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF" {
					return false
				}
				if len(file.Buf()) != 256 {
					return false
				}
				return true
			},
		}
		if err = find.Run(f); err != nil {
			t.Fatal(err)
		}
		if len(find.Matches) != 1 {
			t.Errorf("incorrect number of matches after insertion! expected 1, got %v", len(find.Matches))
		}
	default:
		t.Fatalf("unknown what-type '%s'", whatType)
	}
}

func TestInsert(t *testing.T) {
	for whatType := InsertWhatTypeUndefined + 1; whatType < EndOfInsertWhatType; whatType++ {
		t.Run(whatType.String(), func(t *testing.T) {
			for wherePreposition := InsertWherePrepositionUndefined + 1; wherePreposition < EndOfInsertWherePreposition; wherePreposition++ {
				t.Run(wherePreposition.String(), func(t *testing.T) {
					testInsertCLI(t, whatType, wherePreposition)
				})
			}
		})
	}
}

func TestDoubleFindInsert(t *testing.T) {
	var tests = []struct {
		name string
		InsertType
	}{
		{"insert_after double result", InsertTypeAfter},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			f := parseImage(t)

			insert, err := testRunObsoleteInsert(t, f, test.InsertType, *testGUID)
			if err != nil {
				t.Fatal(err)
			}

			// Run it again, it should fail
			if err = insert.Run(f); err == nil {
				t.Fatal("Expected error, got nil.")
			}
			if !strings.HasPrefix(err.Error(), "more than one match, only one match allowed! got ") {
				t.Errorf("Mismatched error, got %v.", err.Error())
			}

		})
	}
}

func TestNoFindInsert(t *testing.T) {
	var tests = []struct {
		name string
		InsertType
	}{
		{"insert_after no file", InsertTypeAfter},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			f := parseImage(t)

			_, err := testRunObsoleteInsert(t, f, test.InsertType,
				*guid.MustParse("DECAFBAD-0000-0000-0000-000000000000"))
			// It should fail due to no such file
			if err == nil {
				t.Fatal("Expected error, got nil.")
			}
			if err.Error() != "no matches found" {
				t.Errorf("Mismatched error, got %v.", err.Error())
			}

		})
	}
}

```

`pkg/visitors/json.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// JSON prints any Firmware node as JSON.
type JSON struct {
	// JSON is written to this writer.
	W io.Writer
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *JSON) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit applies the JSON visitor to any Firmware type.
func (v *JSON) Visit(f uefi.Firmware) error {
	b, err := json.MarshalIndent(f, "", "\t")
	if err != nil {
		return err
	}
	fmt.Fprintln(v.W, string(b))
	return nil
}

func init() {
	RegisterCLI("json", "produce JSON for the full firmware volume", 0, func(args []string) (uefi.Visitor, error) {
		return &JSON{
			W: os.Stdout,
		}, nil
	})
}

```

`pkg/visitors/json_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"encoding/json"
	"testing"
)

// TestJSON tests the JSON visitor. The amount of testing is negligible. This
// simply tests that valid ROMs produce valid JSON.
func TestJSON(t *testing.T) {
	f := parseImage(t)

	out := &bytes.Buffer{}
	jason := &JSON{
		W: out,
	}

	if err := f.Apply(jason); err != nil {
		t.Fatal(err)
	}

	var dec interface{}
	if err := json.Unmarshal(out.Bytes(), &dec); err != nil {
		t.Errorf("invalid json: %q", out.String())
	}
}

```

`pkg/visitors/nvarinvalidate.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// NVarInvalidate set NVar as Invalid
type NVarInvalidate struct {
	// Input
	Predicate func(f uefi.Firmware) bool

	// Output
	Matches []uefi.Firmware
	// logs are written to this writer.
	W io.Writer
}

func (v *NVarInvalidate) printf(format string, a ...interface{}) {
	if v.W != nil {
		fmt.Fprintf(v.W, format, a...)
	}
}

// Run uses find and wraps Visit.
func (v *NVarInvalidate) Run(f uefi.Firmware) error {
	// First run "find" to generate a list of matches to replace.
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	v.Matches = find.Matches
	for _, m := range v.Matches {
		if err := m.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// Visit set NVar as Invalid
func (v *NVarInvalidate) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.NVar:
		v.printf("Invalidate: %v  %v\n", f.GUID, f)
		f.Type = uefi.InvalidNVarEntry
	}
	return nil
}

func init() {
	RegisterCLI("invalidate_nvar", "invalidate NVar by Name", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindNVarPredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &NVarInvalidate{
			Predicate: pred,
			W:         os.Stdout,
		}, nil
	})
	RegisterCLI("invalidate_nvar_except", "invalidate all NVar except those in the specified file", 1, func(args []string) (uefi.Visitor, error) {
		fileName := args[0]
		fileContents, err := os.ReadFile(fileName)
		if err != nil {
			return nil, fmt.Errorf("cannot read blacklist file %q: %v", fileName, err)
		}
		blackListRegex, err := parseBlackList(fileName, string(fileContents))
		if err != nil {
			return nil, err
		}
		blackListPredicate, err := FindNVarPredicate(blackListRegex)
		if err != nil {
			return nil, err
		}
		pred := FindNotPredicate(blackListPredicate)

		return &NVarInvalidate{
			Predicate: pred,
			W:         os.Stdout,
		}, nil
	})

}

```

`pkg/visitors/nvarinvalidate_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"os"
	"testing"

	"github.com/linuxboot/fiano/pkg/uefi"
)

func TestNVarInvalidate(t *testing.T) {

	path := "../../integration/roms/nvartest/"

	var parsedRoot uefi.Firmware
	// Call ParseDir
	pd := ParseDir{BasePath: path}
	if parsedRoot, err = pd.Parse(); err != nil {
		t.Fatal(err)
	}
	// Assemble the tree from the bottom up
	a := Assemble{}
	if err = a.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	// initial count
	count := &Count{}
	if err = count.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	want := 6
	got := count.FirmwareTypeCount["NVar"]
	if got != want {
		t.Fatalf("counted %d NVar, want %d", got, want)
	}

	// invalidate "Test0"
	pred, err := FindNVarPredicate("Test0")
	if err != nil {
		t.Fatal(err)
	}
	inval := &NVarInvalidate{
		Predicate: pred,
		W:         os.Stdout,
	}
	if err = inval.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	// Compact (remove links and invalidated NVars)
	compact := &NVRamCompact{}
	if err = compact.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	// count
	if err = count.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	want = 4
	got = count.FirmwareTypeCount["NVar"]
	if got != want {
		t.Fatalf("counted %d NVar, want %d", got, want)
	}

}

```

`pkg/visitors/nvramcompact.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/uefi"
)

func compactNVarStore(s *uefi.NVarStore) error {
	var keepEntries []*uefi.NVar
	linkedNVar := make(map[uint64]*uefi.NVar)
	// Find Data entries and associated metadata entries
	for _, v := range s.Entries {
		if !v.IsValid() {
			continue
		}
		h, ok := linkedNVar[v.Offset]
		if !ok {
			h = v
		}
		if v.NextOffset != 0 {
			linkedNVar[v.NextOffset] = h
			continue
		}
		linkedNVar[v.Offset] = h
		keepEntries = append(keepEntries, v)
	}
	var newEntries []*uefi.NVar
	var guidStore []guid.GUID
	guidStoredIndex := make(map[guid.GUID]uint8)
	var offset uint64
	// Rebuild GUID store and entries
	for _, k := range keepEntries {
		h := linkedNVar[k.Offset]
		v := uefi.NVar{Type: uefi.FullNVarEntry, Header: h.Header, GUID: h.GUID, Name: h.Name, Offset: offset, NVarStore: k.NVarStore}
		if v.Header.Attributes&uefi.NVarEntryGUID == 0 {
			guidIndex, ok := guidStoredIndex[v.GUID]
			if !ok {

				guidIndex = uint8(len(guidStore))
				guidStoredIndex[v.GUID] = guidIndex
				guidStore = append(guidStore, v.GUID)
			}
			v.GUIDIndex = &guidIndex

		}
		if err := v.Assemble(k.Buf()[k.DataOffset:], false); err != nil {
			return err
		}
		offset += uint64(len(v.Buf()))
		newEntries = append(newEntries, &v)
	}
	// replace entries and GUID store
	s.Entries = newEntries
	s.GUIDStore = guidStore

	// Assemble the tree just to make sure things are right
	// It will do the mandatory second Assemble of NVar and update the Offsets
	a := &Assemble{}
	return a.Run(s)
}

// NVRamCompact compact nvram content by removing old version of variables
type NVRamCompact struct {
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *NVRamCompact) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit applies the NVRamCompact visitor to any Firmware type.
func (v *NVRamCompact) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.NVarStore:
		// First apply to children to compact nested stores in vars
		err := f.ApplyChildren(v)
		if err != nil {
			return err
		}
		// call the compact function
		return compactNVarStore(f)
	}
	return f.ApplyChildren(v)
}

func init() {
	RegisterCLI("nvram-compact", "compact nvram content by removing old versions of variables", 0, func(args []string) (uefi.Visitor, error) {
		return &NVRamCompact{}, nil
	})
}

```

`pkg/visitors/nvramcompact_test.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"

	"github.com/linuxboot/fiano/pkg/uefi"
)

func TestNVRamCompact(t *testing.T) {
	path := "../../integration/roms/nvartest/"

	var parsedRoot uefi.Firmware
	// Call ParseDir
	pd := ParseDir{BasePath: path}
	if parsedRoot, err = pd.Parse(); err != nil {
		t.Fatal(err)
	}
	// Assemble the tree from the bottom up
	a := Assemble{}
	if err = a.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	// initial count
	count := &Count{}
	if err = count.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	want := 6
	got := count.FirmwareTypeCount["NVar"]
	if got != want {
		t.Fatalf("counted %d NVar, want %d", got, want)
	}

	// Compact
	compact := &NVRamCompact{}
	if err = compact.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	// count
	if err = count.Run(parsedRoot); err != nil {
		t.Fatal(err)
	}

	want = 5
	got = count.FirmwareTypeCount["NVar"]
	if got != want {
		t.Fatalf("counted %d NVar, want %d", got, want)
	}

}

```

`pkg/visitors/parsedir.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"errors"
	"os"
	"path/filepath"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// ParseDir creates the firmware tree and reads the binaries from the provided directory
type ParseDir struct {
	BasePath string
}

// Run is not actually implemented cause we can't fit the interface
func (v *ParseDir) Run(f uefi.Firmware) error {
	return errors.New("func Run for ParseDir is not implemented, do not use")
}

// Parse parses a directory and creates the tree.
func (v *ParseDir) Parse() (uefi.Firmware, error) {
	// Read in the json and construct the tree.
	jsonbuf, err := os.ReadFile(filepath.Join(v.BasePath, "summary.json"))
	if err != nil {
		return nil, err
	}
	f, err := uefi.UnmarshalFirmware(jsonbuf)
	if err != nil {
		return nil, err
	}

	if err = f.Apply(v); err != nil {
		return nil, err
	}
	return f, nil
}

func (v *ParseDir) readBuf(ExtractPath string) ([]byte, error) {
	if ExtractPath != "" {
		return os.ReadFile(filepath.Join(v.BasePath, ExtractPath))
	}
	return nil, nil
}

// Visit applies the ParseDir visitor to any Firmware type.
func (v *ParseDir) Visit(f uefi.Firmware) error {
	var err error
	var fBuf []byte
	switch f := f.(type) {

	case *uefi.FirmwareVolume:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.File:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.Section:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.NVar:
		if f.IsValid() {
			var fValBuf []byte
			fValBuf, err = v.readBuf(f.ExtractPath)
			fBuf = append(make([]byte, f.DataOffset), fValBuf...)
		} else {
			fBuf, err = v.readBuf(f.ExtractPath)
		}

	case *uefi.FlashDescriptor:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.BIOSRegion:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.MERegion:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.RawRegion:
		fBuf, err = v.readBuf(f.ExtractPath)

	case *uefi.BIOSPadding:
		fBuf, err = v.readBuf(f.ExtractPath)
	}

	if err != nil {
		return err
	}
	f.SetBuf(fBuf)

	return f.ApplyChildren(v)
}

```

`pkg/visitors/remove.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Remove all firmware files with the given GUID.
type Remove struct {
	// Input
	Predicate  func(f uefi.Firmware) bool
	Pad        bool
	RemoveDxes bool // I hate this, but there's no good way to work around our current structure

	// Output
	Matches []uefi.Firmware
	// Calling this function undoes the removals performed by this visitor.
	Undo func()
	// logs are written to this writer.
	W io.Writer
}

func (v *Remove) printf(format string, a ...interface{}) {
	if v.W != nil {
		fmt.Fprintf(v.W, format, a...)
	}
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Remove) Run(f uefi.Firmware) error {
	// First run "find" to generate a list of matches to delete.
	find := Find{
		Predicate: v.Predicate,
	}
	if v.RemoveDxes {
		dxeFV, err := FindDXEFV(f)
		if err != nil {
			return err
		}
		if err := find.Run(dxeFV); err != nil {
			return err
		}
		// We've found all the files in the blacklist
		// now, we invert the matches
		// Note, we can't use the NotPredicate here because that will match the
		// sections of all files even if they are supposed to be excluded.
		// This is terrible and my fault.
		newMatches := []uefi.Firmware{}
		for _, file := range dxeFV.Files {
			var keep bool
			for _, match := range find.Matches {
				if match == file {
					keep = true
					break
				}
			}
			if !keep {
				newMatches = append(newMatches, file)
			}
		}

		// Use this list of matches when removing files.
		v.Matches = newMatches
		return dxeFV.Apply(v)
	}
	if err := find.Run(f); err != nil {
		return err
	}

	// Use this list of matches when removing files.
	v.Matches = find.Matches
	return f.Apply(v)
}

// Visit applies the Remove visitor to any Firmware type.
func (v *Remove) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.FirmwareVolume:
		for i := 0; i < len(f.Files); i++ {
			for _, m := range v.Matches {
				if f.Files[i] == m {
					originalList := append([]*uefi.File{}, f.Files...)

					m := m.(*uefi.File)
					if v.Pad || m.Header.Type == uefi.FVFileTypePEIM {
						// Create a new pad file of the exact same size
						pf, err := uefi.CreatePadFile(m.Header.ExtendedSize)
						if err != nil {
							return err
						}
						f.Files[i] = pf
					} else {
						f.Files = append(f.Files[:i], f.Files[i+1:]...)
					}
					v.printf("Remove: %d files now\n", len(f.Files))

					// Creates a stack of undoes in case there are multiple FVs.
					prev := v.Undo
					v.Undo = func() {
						f.Files = originalList
						v.printf("Undo: %d files now\n", len(f.Files))
						v.Undo = prev
					}
				}
			}
		}
	}

	return f.ApplyChildren(v)
}

func init() {
	RegisterCLI("remove", "remove a file from the volume", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &Remove{
			Predicate: pred,
			Pad:       false,
			W:         os.Stdout,
		}, nil
	})
	RegisterCLI("remove_pad", "remove a file from the volume and replace it with a pad file of the same size", 1, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}
		return &Remove{
			Predicate: pred,
			Pad:       true,
			W:         os.Stdout,
		}, nil
	})
	RegisterCLI("remove_dxes_except", "remove all files from the volume except those in the specified file", 1, func(args []string) (uefi.Visitor, error) {
		fileName := args[0]
		fileContents, err := os.ReadFile(fileName)
		if err != nil {
			return nil, fmt.Errorf("cannot read blacklist file %q: %v", fileName, err)
		}
		blackListRegex, err := parseBlackList(fileName, string(fileContents))
		if err != nil {
			return nil, err
		}
		blackListPredicate, err := FindFilePredicate(blackListRegex)
		if err != nil {
			return nil, err
		}
		pred := blackListPredicate

		return &Remove{
			Predicate:  pred,
			RemoveDxes: true,
		}, nil
	})
}

```

`pkg/visitors/remove_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"
)

func TestRemoveNoPad(t *testing.T) {
	f := parseImage(t)

	count := &Count{}
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}
	padCount := count.FileTypeCount["EFI_FV_FILETYPE_FFS_PAD"]
	// Apply the visitor.
	remove := &Remove{
		Predicate: FindFileGUIDPredicate(*testGUID),
		Pad:       false,
	}
	if err := remove.Run(f); err != nil {
		t.Fatal(err)
	}

	// We expect one match.
	if len(remove.Matches) != 1 {
		t.Fatalf("got %d matches; expected 1", len(remove.Matches))
	}

	// We expect no match.
	results := find(t, f, testGUID)
	if len(results) != 0 {
		t.Errorf("got %d matches; expected 0", len(results))
	}
	// We expect the same number of pad files
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}
	if newPadCount := count.FileTypeCount["EFI_FV_FILETYPE_FFS_PAD"]; padCount != newPadCount {
		t.Errorf("differing number of pad files: originally had %v, after removal got %v",
			padCount, newPadCount)
	}
}

func TestRemovePad(t *testing.T) {
	f := parseImage(t)

	count := &Count{}
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}
	padCount := count.FileTypeCount["EFI_FV_FILETYPE_FFS_PAD"]
	// Apply the visitor.
	remove := &Remove{
		Predicate: FindFileGUIDPredicate(*testGUID),
		Pad:       true,
	}
	if err := remove.Run(f); err != nil {
		t.Fatal(err)
	}

	// We expect one match.
	if len(remove.Matches) != 1 {
		t.Fatalf("got %d matches; expected 1", len(remove.Matches))
	}

	// We expect no match.
	results := find(t, f, testGUID)
	if len(results) != 0 {
		t.Fatalf("got %d matches; expected 0", len(results))
	}
	// We expect one more pad file
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}
	if newPadCount := count.FileTypeCount["EFI_FV_FILETYPE_FFS_PAD"]; padCount+1 != newPadCount {
		t.Errorf("differing number of pad files: expected %v, got %v",
			padCount+1, newPadCount)
	}
}

func TestRemoveExcept(t *testing.T) {
	f := parseImage(t)

	pred, err := FindFilePredicate(dxeCoreGUID.String())
	if err != nil {
		t.Fatal(err)
	}
	remove := &Remove{
		Predicate:  pred,
		RemoveDxes: true,
	}
	if err := remove.Run(f); err != nil {
		t.Fatal(err)
	}

	// We expect no more dxe drivers since we only kept the core.
	count := &Count{}
	if err := count.Run(f); err != nil {
		t.Fatal(err)
	}
	dxeCount := count.FileTypeCount["EFI_FV_FILETYPE_DRIVER"]
	coreCount := count.FileTypeCount["EFI_FV_FILETYPE_DXE_CORE"]
	if dxeCount != 0 {
		t.Errorf("expected no more drivers, got %v", dxeCount)
	}
	if coreCount != 1 {
		t.Errorf("expected one dxecore remaining, got %v", coreCount)
	}

}

func TestRemoveExceptBlackList(t *testing.T) {
	// The following blacklist contains corner case:
	// - start, mid or end of existing names but no full name
	// - start, mid or end of existing GUID but no full GUID
	// so it should behave as an empty blacklist, ie remove all
	var blacklists = []string{
		"INEXISTING_FILENAME\nINEXISTING_FILENAME2",
		"Isa\nDisk\nDxe",
		"D6A2CB7F\n11E3\n9920A733700A",
	}
	for _, blacklist := range blacklists {
		f := parseImage(t)

		blackListRegex, err := parseBlackList("(embedded)", blacklist)
		if err != nil {
			t.Fatal(err)
		}

		pred, err := FindFilePredicate(blackListRegex)
		if err != nil {
			t.Fatal(err)
		}
		remove := &Remove{
			Predicate:  pred,
			RemoveDxes: true,
		}
		if err := remove.Run(f); err != nil {
			t.Fatal(err)
		}

		// We expect no more dxe drivers since we only kept the core.
		count := &Count{}
		if err := count.Run(f); err != nil {
			t.Fatal(err)
		}
		dxeCount := count.FileTypeCount["EFI_FV_FILETYPE_DRIVER"]
		coreCount := count.FileTypeCount["EFI_FV_FILETYPE_DXE_CORE"]
		if dxeCount != 0 {
			t.Errorf("expected no more drivers, got %v", dxeCount)
		}
		if coreCount != 0 {
			t.Errorf("expected no more dxecore, got %v", coreCount)
		}
	}
}

```

`pkg/visitors/repack.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"crypto/sha1"
	"encoding/binary"
	"errors"
	"fmt"
	"unsafe"

	"github.com/linuxboot/fiano/pkg/compression"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// Repack repacks a per file compressed FV into a singularly compressed nested FV
type Repack struct {
	// Input
	Predicate func(f uefi.Firmware) bool

	// Matched File
	FileMatch *uefi.File
}

// removeFileCompression goes through a newly created, nested firmware volume
// and removes the first level compressed section.
func removeFileCompression(nfv *uefi.FirmwareVolume) error {
	for _, f := range nfv.Files {
		newSectionList := []*uefi.Section{}
		for _, s := range f.Sections {
			if s.Header.Type != uefi.SectionTypeGUIDDefined {
				// This doesn't have a compressed section
				newSectionList = append(newSectionList, s)
				continue
			}
			gdh := s.TypeSpecific.Header.(*uefi.SectionGUIDDefined)
			if guid := gdh.GUID; guid != compression.LZMAGUID && guid != compression.LZMAX86GUID {
				// This doesn't have a compressed section
				newSectionList = append(newSectionList, s)
				continue
			}
			// This is a compressed section we understand, remove it and add children directly to file.
			for _, es := range s.Encapsulated {
				child, ok := es.Value.(*uefi.Section)
				if !ok {
					// This should never happen, die
					return fmt.Errorf("file %v has non sections inside a compressed section, discarding", f.Header.GUID)
				}
				newSectionList = append(newSectionList, child)
			}
		}
		f.Sections = newSectionList
	}
	return nil
}

func createFirmwareVolume(pfv *uefi.FirmwareVolume) (*uefi.FirmwareVolume, error) {
	nfv := &uefi.FirmwareVolume{} // new Firmware Volume

	// Create new firmware volume that encloses all the old files.
	// Set up volume header first.
	nfv.FileSystemGUID = *uefi.FFS2
	nfv.Signature = binary.LittleEndian.Uint32([]byte("_FVH"))
	// Copy over attributes from parent. We may want to change this in the future.
	// We don't need the alignment fields since we're nested,
	// so we really only need the lower 16 bits.
	nfv.Attributes = pfv.Attributes & 0x0000FFFF
	nfv.Revision = pfv.Revision
	// Copy and use parent's block size. We assume there's only one nonzero block entry
	nfv.Blocks = make([]uefi.Block, 2)
	if bLen := len(pfv.Blocks); bLen < 1 {
		// According to the spec, should always be two blocks, one null to terminate the block list, but
		// some bioses are not compliant.
		return nil, fmt.Errorf("parent firmware volume block list is too short: need at least 1, got %v",
			bLen)
	}
	if pfv.Blocks[0].Size == 0 {
		return nil, errors.New("first parent firmware volume block has 0 block size, malformed parent block")
	}
	// We use the parent's block size
	nfv.Blocks[0] = uefi.Block{Size: pfv.Blocks[0].Size}
	nfv.Blocks[1] = uefi.Block{}

	// Calculate the HeaderLen field
	nfv.HeaderLen = uint16(uefi.FirmwareVolumeFixedHeaderSize + int(unsafe.Sizeof(uefi.Block{}))*len(nfv.Blocks))

	// Create firmware volume metadata
	nfv.DataOffset = uint64(nfv.HeaderLen) // Since we don't have the extended header, HeaderLen is DataOffset.
	nfv.Length = nfv.DataOffset
	nfv.Resizable = true // This is a nested firmware volume, so we can resize it as needed.

	// Generate binary header.
	header := new(bytes.Buffer)
	err := binary.Write(header, binary.LittleEndian, nfv.FirmwareVolumeFixedHeader)
	if err != nil {
		return nil, fmt.Errorf("unable to construct binary header of nested firmware volume: got %v", err)
	}
	for _, b := range nfv.Blocks {
		err = binary.Write(header, binary.LittleEndian, b)
		if err != nil {
			return nil, fmt.Errorf("unable to construct binary header of nested firmware volume: got %v", err)
		}

	}
	nfv.SetBuf(header.Bytes())
	// Copy out parent's files
	nfv.Files = append([]*uefi.File{}, pfv.Files...)

	return nfv, nil
}

func createVolumeImageFile(cs *uefi.Section) (*uefi.File, error) {
	f := &uefi.File{}

	f.Header.Type = uefi.FVFileTypeVolumeImage
	f.Header.SetState(uefi.FileStateValid)

	f.Sections = []*uefi.Section{cs}

	// Call assemble to populate cs's buffer. then sha1 it for the guid.
	a := &Assemble{}
	if err := a.Run(cs); err != nil {
		return nil, err
	}
	sum := sha1.Sum(cs.Buf())
	copy(f.Header.GUID[:], sum[:]) // GUIDs are smaller, so only 16 bytes are copied

	return f, nil
}

func repackFV(fv *uefi.FirmwareVolume) error {
	// fv should be the pointer to the enclosing firmware volume that needs to be repacked.

	// Create new Firmware Volume.
	// This copies out the parent list of files and assigns it to the new fv
	nfv, err := createFirmwareVolume(fv)
	if err != nil {
		return err
	}

	// Remove per file compression
	if err = removeFileCompression(nfv); err != nil {
		return err
	}

	// Create new Volume Image section
	vs, err := uefi.CreateSection(uefi.SectionTypeFirmwareVolumeImage, []byte{}, []uefi.Firmware{nfv}, nil)
	if err != nil {
		return err
	}

	// Create new compressed section
	cs, err := uefi.CreateSection(uefi.SectionTypeGUIDDefined, []byte{}, []uefi.Firmware{vs}, &compression.LZMAGUID)
	if err != nil {
		return err
	}

	// Create new FV image file
	file, err := createVolumeImageFile(cs)
	if err != nil {
		return err
	}

	// Set new file as the only firmware file in the original fv.
	fv.Files = append([]*uefi.File{}, file)
	return nil
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Repack) Run(f uefi.Firmware) error {
	// Check that fv being repacked isn't already nested.
	// First run "find" to generate a position to insert into.
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	if numMatch := len(find.Matches); numMatch > 1 {
		return fmt.Errorf("more than one match, only one match allowed! got %v", find.Matches)
	} else if numMatch == 0 {
		return errors.New("no matches found")
	}

	// Find should only match a file or a firmware volume. If it's an FV, we can
	// edit the FV directly.
	if fvMatch, ok := find.Matches[0].(*uefi.FirmwareVolume); ok {
		// Call repack function.
		return repackFV(fvMatch)
	}
	var ok bool
	if v.FileMatch, ok = find.Matches[0].(*uefi.File); !ok {
		return fmt.Errorf("match was not a file or a firmware volume: got %T, unable to insert", find.Matches[0])
	}
	// Match is a file, apply visitor.
	if err := f.Apply(v); err != nil {
		return err
	}

	// Assemble the tree just to make sure things are right.
	a := &Assemble{}
	return a.Run(f)
}

// Visit applies the Repack visitor to any Firmware type.
func (v *Repack) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.FirmwareVolume:
		for i := 0; i < len(f.Files); i++ {
			if f.Files[i] == v.FileMatch {
				// call repack function.
				return repackFV(f)
			}
		}
	}

	return f.ApplyChildren(v)
}

func init() {
	RegisterCLI("repack",
		"repack a per file compressed fv to a nested compressed fv", 1,
		func(args []string) (uefi.Visitor, error) {
			pred, err := FindFileFVPredicate(args[0])
			if err != nil {
				return nil, err
			}

			// Repack File.
			return &Repack{
				Predicate: pred,
			}, nil
		})
}

```

`pkg/visitors/repack_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/binary"
	"testing"

	"github.com/linuxboot/fiano/pkg/compression"
	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
)

var (
	file1GUID = guid.MustParse("01234567-89AB-CDEF-0123-456789ABCDEF")
	file2GUID = guid.MustParse("DEADBEEF-DEAD-BEEF-DEAD-BEEFDEADBEEF")

	ss1 *uefi.Section
	ss2 *uefi.Section
	rs1 *uefi.Section
	cs1 *uefi.Section
	cs2 *uefi.Section

	f1  *uefi.File
	f2  *uefi.File
	pfv *uefi.FirmwareVolume

	err error
)

func init() {
	// Level 2 sections: sections that are inside compressed sections.
	ss1, err = uefi.CreateSection(uefi.SectionTypeRaw, []byte("Subsection 1 data"), nil, nil)
	if err != nil {
		log.Fatalf("%v", err)
	}
	ss2, err = uefi.CreateSection(uefi.SectionTypeRaw, []byte("Subsection 2 data"), nil, nil)
	if err != nil {
		log.Fatalf("%v", err)
	}

	// Level 1 sections: includes guid defined compression sections.
	cs1, err = uefi.CreateSection(uefi.SectionTypeGUIDDefined, nil, []uefi.Firmware{ss1}, &compression.LZMAGUID)
	if err != nil {
		log.Fatalf("%v", err)
	}
	rs1, err = uefi.CreateSection(uefi.SectionTypeRaw, []byte("Raw section data"), nil, nil)
	if err != nil {
		log.Fatalf("%v", err)
	}
	cs2, err = uefi.CreateSection(uefi.SectionTypeGUIDDefined, nil, []uefi.Firmware{ss2}, &compression.LZMAGUID)
	if err != nil {
		log.Fatalf("%v", err)
	}

	// Sample Files
	f1 = &uefi.File{}
	f1.Header.GUID = *file1GUID
	f1.Header.Type = uefi.FVFileTypeDriver
	f1.Sections = []*uefi.Section{rs1, cs1}

	f2 = &uefi.File{}
	f2.Header.GUID = *file2GUID
	f2.Header.Type = uefi.FVFileTypeDriver
	f2.Sections = []*uefi.Section{cs2}

	// Sample original firmware volume
	pfv = &uefi.FirmwareVolume{}
	pfv.FileSystemGUID = *uefi.FFS2
	pfv.Signature = binary.LittleEndian.Uint32([]byte("_FVH"))
	pfv.Attributes = 0x89ABCDEF
	pfv.Revision = 0xFF
	pfv.Blocks = []uefi.Block{{Count: 1024, Size: 4096}}
	pfv.HeaderLen = 56
	pfv.Files = []*uefi.File{f1, f2}
}

func TestRepack(t *testing.T) {
	if err := repackFV(pfv); err != nil {
		t.Fatalf("Failed to repack firmware volume, got %v", err)
	}

	// pfv should have repacked firmware volume
	if fvlen := len(pfv.Files); fvlen != 1 {
		t.Fatalf("There should be exactly one file in repacked FV! got %v files", fvlen)
	}

	f := pfv.Files[0]
	if f.Header.Type != uefi.FVFileTypeVolumeImage {
		t.Fatalf("File should be of type EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE, got %s", f.Header.Type)
	}
	if flen := len(f.Sections); flen != 1 {
		t.Fatalf("Wrong number of sections in file, got %v", flen)
	}

	cs := f.Sections[0]
	if cs.Header.Type != uefi.SectionTypeGUIDDefined {
		t.Fatalf("Section should be of type EFI_SECTION_GUID_DEFINED, got %s", cs.Header.Type)
	}
	if elen := len(cs.Encapsulated); elen != 1 {
		t.Fatalf("Wrong number of encapsulated section in compressed section, got %v", elen)
	}

	vs, ok := cs.Encapsulated[0].Value.(*uefi.Section)
	if !ok {
		t.Fatal("Encapsulated section was not of type uefi.Section")
	}
	if vs.Header.Type != uefi.SectionTypeFirmwareVolumeImage {
		t.Fatalf("Section should be of type EFI_SECTION_VOLUME_IMAGE, got %s", vs.Header.Type)
	}
	if elen := len(vs.Encapsulated); elen != 1 {
		t.Fatalf("Wrong number of encapsulated section in volume image section, got %v", elen)
	}

	nfv, ok := vs.Encapsulated[0].Value.(*uefi.FirmwareVolume)
	if !ok {
		t.Fatal("Volume Image Section did not contain firmware volume!")
	}
	if fvlen := len(nfv.Files); fvlen != 2 {
		t.Fatalf("There should be 2 files in repacked FV! got %v files", fvlen)
	}
	// Check file pointers.
	if nfv.Files[0] != f1 {
		t.Fatalf("file 1 mismatch: expected %v, got %v", f1, nfv.Files[0])
	}
	if nfv.Files[1] != f2 {
		t.Fatalf("file 2 mismatch: expected %v, got %v", f2, nfv.Files[1])
	}

	if slen := len(f1.Sections); slen != 2 {
		t.Fatalf("There should be 2 sections in file 1! got %v sections", slen)
	}
	if f1.Sections[0] != rs1 {
		t.Fatalf("file 1 section 1 mismatch: expected %v, got %v", rs1, f1.Sections[0])
	}
	if f1.Sections[1] != ss1 {
		t.Fatalf("file 1 section 1 mismatch: expected %v, got %v", ss1, f1.Sections[1])
	}

	if slen := len(f2.Sections); slen != 1 {
		t.Fatalf("There should be 1 sections in file 2! got %v sections", slen)
	}
	if f2.Sections[0] != ss2 {
		t.Fatalf("file 2 mismatch: expected %v, got %v", ss2, f2.Sections[0])
	}
}

```

`pkg/visitors/replacepe32.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"errors"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// ReplacePE32 replaces PE32 sections with NewPE32 for all files matching Predicate.
type ReplacePE32 struct {
	// Input
	Predicate func(f uefi.Firmware) bool
	NewPE32   []byte

	// Output
	Matches []uefi.Firmware
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *ReplacePE32) Run(f uefi.Firmware) error {
	// Check that we're actually replacing with a PE32 image
	if !bytes.HasPrefix(v.NewPE32, []byte("MZ")) {
		return errors.New("supplied binary is not a valid pe32 image")
	}

	// Run "find" to generate a list of matches to replace.
	find := Find{
		Predicate: v.Predicate,
	}
	if err := find.Run(f); err != nil {
		return err
	}

	// Use this list of matches for replacing sections.
	v.Matches = find.Matches
	if len(find.Matches) == 0 {
		return errors.New("no matches found for replacement")
	}
	if len(find.Matches) > 1 {
		return errors.New("multiple matches found! There can be only one. Use find to list all matches")
	}

	for _, m := range v.Matches {
		if err := m.Apply(v); err != nil {
			return err
		}
	}
	return nil
}

// Visit applies the Extract visitor to any Firmware type.
func (v *ReplacePE32) Visit(f uefi.Firmware) error {
	switch f := f.(type) {

	case *uefi.File:
		return f.ApplyChildren(v)

	case *uefi.Section:
		if f.Header.Type == uefi.SectionTypePE32 {
			f.SetBuf(v.NewPE32)
			f.Encapsulated = nil // Should already be empty
			if err := f.GenSecHeader(); err != nil {
				return err
			}
		}
		return f.ApplyChildren(v)

	default:
		// Must be applied to a File to have any effect.
		return nil
	}
}

func init() {
	RegisterCLI("replace_pe32", "replace a pe32 given a GUID and new file", 2, func(args []string) (uefi.Visitor, error) {
		pred, err := FindFilePredicate(args[0])
		if err != nil {
			return nil, err
		}

		filename := args[1]
		newPE32, err := os.ReadFile(filename)
		if err != nil {
			return nil, err
		}

		// Find all the matching files and replace their inner PE32s.
		return &ReplacePE32{
			Predicate: pred,
			NewPE32:   newPE32,
		}, nil
	})
}

```

`pkg/visitors/replacepe32_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"reflect"
	"testing"

	"github.com/linuxboot/fiano/pkg/uefi"
)

func TestReplacePE32(t *testing.T) {
	f := parseImage(t)

	// Apply the visitor.
	replace := &ReplacePE32{
		Predicate: FindFileGUIDPredicate(*testGUID),
		NewPE32:   []byte("MZbanana"),
	}
	if err := replace.Run(f); err != nil {
		t.Fatal(err)
	}

	// We expect one match.
	if len(replace.Matches) != 1 {
		t.Fatalf("got %d matches; expected 1", len(replace.Matches))
	}

	// Find the section and make sure it contains the expected data.
	results := find(t, f, testGUID)
	if len(results) != 1 {
		t.Fatalf("got %d matches; expected 1", len(results))
	}
	want := []byte{0x0c, 0x00, 0x00, byte(uefi.SectionTypePE32), 'M', 'Z', 'b', 'a', 'n', 'a', 'n', 'a'}
	file, ok := results[0].(*uefi.File)
	if !ok {
		t.Fatalf("did not match a file, got type :%T", file)
	}
	got := file.Sections[0].Buf()
	if !reflect.DeepEqual(want, got) {
		t.Fatalf("want %v; got %v", want, got)
	}
}

func TestErrors(t *testing.T) {
	f := parseImage(t)

	var tests = []struct {
		name    string
		newPE32 []byte
		match   string
		err     string
	}{
		{"No Matches", []byte("MZbanana"), "no-match-string",
			"no matches found for replacement"},
		{"Multiple Matches", []byte("MZbanana"), ".*",
			"multiple matches found! There can be only one. Use find to list all matches"},
		{"Not PE32", []byte("banana"), ".*",
			"supplied binary is not a valid pe32 image"},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// Apply the visitor.
			pred, err := FindFilePredicate(test.match)
			if err != nil {
				t.Fatal(err)
			}
			replace := &ReplacePE32{
				Predicate: pred,
				NewPE32:   test.newPE32,
			}
			err = replace.Run(f)
			if err == nil {
				t.Fatalf("Expected Error (%v), got nil", test.err)
			} else if err.Error() != test.err {
				t.Fatalf("Mismatched Error: Expected %v, got %v", test.err, err.Error())
			}
		})
	}
}

```

`pkg/visitors/save.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Save calls Assemble, then outputs the top image to a file.
type Save struct {
	DirPath string
}

// Run just applies the visitor.
func (v *Save) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit calls the assemble visitor to make sure everything is reconstructed.
// It then outputs the top level buffer to a file.
func (v *Save) Visit(f uefi.Firmware) error {
	a := &Assemble{}
	// Assemble the binary to make sure the top level buffer is correct
	if err := f.Apply(a); err != nil {
		return err
	}
	return os.WriteFile(v.DirPath, f.Buf(), 0666)
}

func init() {
	RegisterCLI("save", "assemble a firmware volume from a directory tree", 1, func(args []string) (uefi.Visitor, error) {
		return &Save{
			DirPath: args[0],
		}, nil
	})
}

```

`pkg/visitors/table.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/tabwriter"

	"github.com/linuxboot/fiano/pkg/knownguids"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// Table prints the GUIDS, types and sizes as a compact table.
type Table struct {
	W         *tabwriter.Writer
	Scan      bool
	Layout    bool
	Depth     int
	indent    int
	offset    uint64
	curOffset uint64
	printRow  func(v *Table, node, name, typez interface{}, offset, length uint64)
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Table) Run(f uefi.Firmware) error {
	return f.Apply(v)
}

// Visit applies the Table visitor to any Firmware type.
func (v *Table) Visit(f uefi.Firmware) error {
	var offset uint64
	switch f := f.(type) {
	case *uefi.FlashImage:
		if v.Depth > 0 { // Depth <= 0 means all
			v.Depth++
		}
		return v.printFirmware(f, "Image", "", "", 0, 0)
	case *uefi.FirmwareVolume:
		return v.printFirmware(f, "FV", f.String(), f.FVType, v.offset+f.FVOffset, v.offset+f.FVOffset+f.DataOffset)
	case *uefi.File:
		// TODO: make name part of the file node
		return v.printFirmware(f, "File", f.Header.GUID.String(), f.Header.Type, v.curOffset, v.curOffset+f.DataOffset)
	case *uefi.Section:
		// Reset offset to O for (compressed) section content
		return v.printFirmware(f, "Sec", f.String(), f.Type, v.curOffset, 0)
	case *uefi.FlashDescriptor:
		return v.printFirmware(f, "IFD", "", "", 0, 0)
	case *uefi.BIOSRegion:
		if f.FRegion != nil {
			offset = uint64(f.FRegion.BaseOffset())
		}
		return v.printFirmware(f, "BIOS", "", "", offset, offset)
	case *uefi.BIOSPadding:
		return v.printFirmware(f, "BIOS Pad", "", "", v.offset+f.Offset, 0)
	case *uefi.NVarStore:
		return v.printFirmware(f, "NVAR Store", "", "", v.curOffset, v.curOffset)
	case *uefi.NVar:
		return v.printFirmware(f, "NVAR", f.GUID.String(), f, v.curOffset, v.curOffset+uint64(f.DataOffset))
	case *uefi.MERegion:
		if f.FRegion != nil {
			offset = uint64(f.FRegion.BaseOffset())
		}
		return v.printFirmware(f, "ME", "", "", offset, offset)
	case *uefi.MEFPT:
		return v.printFirmware(f, "$FPT", "", "", v.offset, 0)
	case *uefi.RawRegion:
		if f.FRegion != nil {
			offset = uint64(f.FRegion.BaseOffset())
		}
		return v.printFirmware(f, f.Type().String(), "", "", offset, offset)
	default:
		return v.printFirmware(f, fmt.Sprintf("%T", f), "", "", 0, 0)
	}
}

func indent(n int) string {
	return strings.Repeat(" ", n)
}

func scanGUID(v *Table, b []byte) {
	for g := range knownguids.GUIDs {
		if bytes.Contains(b, g[:]) {
			fmt.Fprintf(v.W, "%s\t(RAW)\t%s\n", indent(v.indent), g.String())
		}
		if strings.Contains(string(b), g.String()) {
			fmt.Fprintf(v.W, "%s\t(STRING)\t%s\n", indent(v.indent), g.String())
		}
	}
}

func (v *Table) printFirmware(f uefi.Firmware, node, name, typez interface{}, offset, dataOffset uint64) error {
	// Init: Print title and select printRow func
	if v.W == nil {
		v.W = tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
		defer func() { v.W.Flush() }()
		if v.Layout {
			fmt.Fprintf(v.W, "%sNode\tGUID/Name/Type\tOffset\tSize\n", indent(v.indent))
			v.printRow = printRowLayout
		} else {
			fmt.Fprintf(v.W, "%sNode\tGUID/Name\tType\tSize\n", indent(v.indent))
			v.printRow = printRowStd
		}
	}

	// Prepare data and print
	length := uint64(len(f.Buf()))
	if typez == "" {
		if uefi.IsErased(f.Buf(), uefi.Attributes.ErasePolarity) {
			typez = "(empty)"
		}
	}
	v.printRow(v, node, name, typez, offset, length)
	v2 := *v
	v2.indent++
	v2.offset = dataOffset
	v2.curOffset = v2.offset

	if v.Scan {
		switch s := f.(type) {
		case *uefi.Section:
			switch s.Header.Type {
			case uefi.SectionTypeFirmwareVolumeImage:
			case uefi.SectionTypeDXEDepEx, uefi.SectionTypePEIDepEx, uefi.SectionMMDepEx:
				fmt.Fprintf(v.W, "%s\t%v\n", indent(v.indent), s.DepEx)
			default:
				scanGUID(&v2, s.Buf())
			}
		case *uefi.NVar:
			scanGUID(&v2, s.Buf())
		case *uefi.File:
			if s.Header.Type == uefi.FVFileTypeRaw {
				scanGUID(&v2, s.Buf())
			}
		}
	}

	// Compute offset and visit children
	if v.Depth <= 0 || v.indent < v.Depth {
		if err := f.ApplyChildren(&v2); err != nil {
			return err
		}
	}
	v.curOffset += length

	// Print footer
	switch f := f.(type) {
	case *uefi.FirmwareVolume:
		// Print free space at the end of the volume
		v2.printRow(&v2, "Free", "", "", offset+length-f.FreeSpace, f.FreeSpace)
	case *uefi.NVarStore:
		// Print free space and GUID store
		v2.printRow(&v2, "Free", "", "", offset+f.FreeSpaceOffset, f.GUIDStoreOffset-f.FreeSpaceOffset)
		v2.printRow(&v2, "GUIDStore", "", fmt.Sprintf("%d GUID", len(f.GUIDStore)), offset+f.GUIDStoreOffset, f.Length-f.GUIDStoreOffset)
	case *uefi.MERegion:
		v2.printRow(&v2, "Free", "", "", offset+f.FreeSpaceOffset, length-f.FreeSpaceOffset)
	case *uefi.MEFPT:
		// MERegion is not entered, simply print the $FPT content here
		for _, p := range f.Entries {
			var po uint64
			if p.OffsetIsValid() {
				po = offset + uint64(p.Offset)
			}
			v2.printRow(&v2, p.Name, "", p.Type(), po, uint64(p.Length))
		}
	case *uefi.File:
		// Align
		v.curOffset = uefi.Align8(v.curOffset)
	}
	return nil
}

func printRowLayout(v *Table, node, name, typez interface{}, offset, length uint64) {
	if name == "" {
		name = typez
	}
	fmt.Fprintf(v.W, "%s%v\t%v\t%#08x\t%#08x\n", indent(v.indent), node, name, offset, length)
}

func printRowStd(v *Table, node, name, typez interface{}, offset, length uint64) {
	fmt.Fprintf(v.W, "%s%v\t%v\t%v\t%#8x\n", indent(v.indent), node, name, typez, length)
}

func init() {
	RegisterCLI("table", "print out important information in a pretty table", 0, func(args []string) (uefi.Visitor, error) {
		return &Table{}, nil
	})
	RegisterCLI("layout-table", "print out offset and size information of top level firmware volumes in a pretty table", 0, func(args []string) (uefi.Visitor, error) {
		return &Table{Layout: true, Depth: 1}, nil
	})
	RegisterCLI("layout-table-full", "print out offset and size information in a pretty table", 0, func(args []string) (uefi.Visitor, error) {
		return &Table{Layout: true}, nil
	})
	RegisterCLI("scan", "scan the table for GUIDs and print those found", 0, func(args []string) (uefi.Visitor, error) {
		return &Table{Scan: true}, nil
	})
}

```

`pkg/visitors/tightenme.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"fmt"

	"github.com/linuxboot/fiano/pkg/log"
	"github.com/linuxboot/fiano/pkg/uefi"
)

// TightenME tighten ME's belt to give more room for LinuxBoot
// This changes the ME Region Limit to fit the actual content as described in the ME partitions. Also update the BIOS Region Base to start just after the ME Region
type TightenME struct {
	fd  *uefi.FlashDescriptor
	mer *uefi.MERegion
	br  *uefi.BIOSRegion
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *TightenME) Run(f uefi.Firmware) error {
	err := f.Apply(v)
	if err != nil {
		return fmt.Errorf("error looking for IFD, ME and BIOS regions: %v", err)
	}

	return v.process()
}

// Visit applies the TightenME visitor to any Firmware type.
func (v *TightenME) Visit(f uefi.Firmware) error {
	switch f := f.(type) {
	case *uefi.FlashDescriptor:
		v.fd = f
		return nil
	case *uefi.MERegion:
		v.mer = f
		return nil
	case *uefi.BIOSRegion:
		v.br = f
		return nil
	default:
		return f.ApplyChildren(v)
	}
}

func (v *TightenME) process() error {
	// Ensuring IFD exists also ensure FRegion are populated in Regions
	if v.fd == nil {
		return fmt.Errorf("no IFD found")
	}
	if v.mer == nil {
		return fmt.Errorf("no ME region found")
	}
	if v.br == nil {
		return fmt.Errorf("no BIOS region found")
	}
	// TODO: We might be able to relax this restriction if there is a region
	// in between that can be shifted, but this needs more tests...
	if v.mer.FRegion.EndOffset() != v.br.FRegion.BaseOffset() {
		return fmt.Errorf("ME and BIOS regions are not contiguous: ME end at %#x BIOS starts at %#x", v.mer.FRegion.EndOffset(), v.br.FRegion.BaseOffset())

	}
	// Compute the new limit
	updateOffset := uint64(v.mer.FRegion.BaseOffset()) + v.mer.FreeSpaceOffset
	updateBase := (updateOffset + uefi.RegionBlockSize - 1) / uefi.RegionBlockSize
	// align the new absolute offset to uefi.RegionBlockSize
	updateOffset = updateBase * uefi.RegionBlockSize
	bufOffset := updateOffset - uint64(v.mer.FRegion.BaseOffset())
	// check the zone if empty
	buf := v.mer.Buf()
	if !uefi.IsErased(buf[bufOffset:], uefi.Attributes.ErasePolarity) {
		return fmt.Errorf("ME unused space in not erased as expected")
	}
	// Shrink ME Region
	v.mer.FRegion.Limit = uint16(updateBase - 1)
	v.mer.SetBuf(buf[:bufOffset])
	// Expand BIOS Region
	offsetShift := uint64(v.br.FRegion.BaseOffset()) - updateOffset
	v.br.FRegion.Base = uint16(updateBase)
	v.br.Length += offsetShift
	if v.br.Length > 16*1024*1024 {
		log.Warnf("new BIOS Regions length %d (%#x) exceed 16MiB limit", v.br.Length, v.br.Length)
	}
	// update elements offsets
	for i, e := range v.br.Elements {
		switch f := e.Value.(type) {
		case *uefi.FirmwareVolume:
			f.FVOffset += offsetShift
		case *uefi.BIOSPadding:
			f.Offset += offsetShift
		default:
			return fmt.Errorf("unexpected Element at %d: %s", i, e.Type)
		}
	}
	// insert BIOSPad
	bp, err := uefi.NewBIOSPadding(buf[bufOffset:], 0)
	if err != nil {
		return fmt.Errorf("could not create BIOS Padding: %v", err)
	}
	v.br.Elements = append([]*uefi.TypedFirmware{uefi.MakeTyped(bp)}, v.br.Elements...)
	// Assemble will regenerate IFD so regions will be updated in the image

	return nil
}

func init() {
	RegisterCLI("tighten_me", "tighten ME's belt to give more room for LinuxBoot", 0, func(args []string) (uefi.Visitor, error) {
		return &TightenME{}, nil
	})
}

```

`pkg/visitors/validate.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"os"

	"github.com/linuxboot/fiano/pkg/uefi"
)

// Validate performs extra checks on the firmware image.
type Validate struct {
	// An optional Writer for writing errors when validation is complete.
	// When the writer it set, Run will also call os.Exit(1) upon finding
	// an error.
	W io.Writer

	// List of validation errors.
	Errors []error
}

// Run wraps Visit and performs some setup and teardown tasks.
func (v *Validate) Run(f uefi.Firmware) error {
	if err := f.Apply(v); err != nil {
		return err
	}

	if v.W != nil && len(v.Errors) != 0 {
		for _, e := range v.Errors {
			fmt.Println(e)
		}
		os.Exit(1)
	}
	return nil
}

// Visit applies the Validate visitor to any Firmware type.
func (v *Validate) Visit(f uefi.Firmware) error {
	// TODO: add more verification where needed
	switch f := f.(type) {
	case *uefi.FlashImage:
		_, err := f.FindSignature()
		if err != nil {
			v.Errors = append(v.Errors, err)
		}

	case *uefi.FlashDescriptor:
		d := f.DescriptorMap
		if d.MasterBase > uefi.FlashDescriptorMapMaxBase {
			v.Errors = append(v.Errors, fmt.Errorf("MasterBase too large: expected %v bytes, got %v",
				uefi.FlashDescriptorMapMaxBase,
				d.MasterBase,
			))
		}
		if d.RegionBase > uefi.FlashDescriptorMapMaxBase {
			v.Errors = append(v.Errors, fmt.Errorf("RegionBase too large: expected %v bytes, got %v",
				uefi.FlashDescriptorMapMaxBase,
				d.RegionBase,
			))
		}
		if d.MasterBase > uefi.FlashDescriptorMapMaxBase {
			v.Errors = append(v.Errors, fmt.Errorf("ComponentBase too large: expected %v bytes, got %v",
				uefi.FlashDescriptorMapMaxBase,
				d.MasterBase,
			))
		}
		if d.MasterBase == d.RegionBase {
			v.Errors = append(v.Errors, fmt.Errorf("MasterBase must be different from RegionBase: both are at 0x%x",
				d.MasterBase,
			))
		}
		if d.MasterBase == d.ComponentBase {
			v.Errors = append(v.Errors, fmt.Errorf("MasterBase must be different from ComponentBase: both are at 0x%x",
				d.MasterBase,
			))
		}
		if d.RegionBase == d.ComponentBase {
			v.Errors = append(v.Errors, fmt.Errorf("RegionBase must be different from ComponentBase: both are at 0x%x",
				d.RegionBase,
			))
		}

	case *uefi.FirmwareVolume:
		// Check for min length
		fvlen := uint64(len(f.Buf()))
		// We need this check in case HeaderLen doesn't exist, and bail out early
		if fvlen < uefi.FirmwareVolumeMinSize {
			v.Errors = append(v.Errors, fmt.Errorf("length too small!, buffer is only %#x bytes long", fvlen))
			break
		}
		// Check header length
		if f.HeaderLen < uefi.FirmwareVolumeMinSize {
			v.Errors = append(v.Errors, fmt.Errorf("header length too small, got: %#x", f.HeaderLen))
			break
		}
		// Check for full header and bail out if its not fully formed.
		if fvlen < uint64(f.HeaderLen) {
			v.Errors = append(v.Errors, fmt.Errorf("buffer smaller than header!, header is %#x bytes, buffer is %#x bytes",
				f.HeaderLen, fvlen))
			break
		}
		// Do we want to fail in this case? maybe not.
		if uefi.FVGUIDs[f.FileSystemGUID] == "" {
			v.Errors = append(v.Errors, fmt.Errorf("unknown FV type! Guid was %v", f.FileSystemGUID))
		}
		// UEFI PI spec says version should always be 2
		if f.Revision != 2 {
			v.Errors = append(v.Errors, fmt.Errorf("revision should be 2, was %v", f.Revision))
		}
		// Check Signature
		fvSigInt := binary.LittleEndian.Uint32([]byte("_FVH"))
		if f.Signature != fvSigInt {
			v.Errors = append(v.Errors, fmt.Errorf("signature was not _FVH, got: %#08x", f.Signature))
		}
		// Check length
		if f.Length != fvlen {
			v.Errors = append(v.Errors, fmt.Errorf("length mismatch!, header has %#x, buffer is %#x bytes long", f.Length, fvlen))
		}
		// Check checksum
		sum, err := uefi.Checksum16(f.Buf()[:f.HeaderLen]) // TODO: use the Header() function which does not exist yet
		if err != nil {
			v.Errors = append(v.Errors, fmt.Errorf("unable to checksum FV header: %v", err))
		} else if sum != 0 {
			v.Errors = append(v.Errors, fmt.Errorf("header did not sum to 0, got: %#x", sum))
		}

	case *uefi.File:
		buflen := uint64(len(f.Buf()))
		blankSize := [3]uint8{0xFF, 0xFF, 0xFF}
		if buflen < uefi.FileHeaderMinLength {
			v.Errors = append(v.Errors, fmt.Errorf("file length too small!, buffer is only %#x bytes long", buflen))
			break
		}

		// Size Checks
		fh := &f.Header
		if fh.Size == blankSize {
			if buflen < uefi.FileHeaderExtMinLength {
				v.Errors = append(v.Errors, fmt.Errorf("file %v length too small!, buffer is only %#x bytes long for extended header",
					fh.GUID, buflen))
				break
			}
			if !fh.Attributes.IsLarge() {
				v.Errors = append(v.Errors, fmt.Errorf("file %v using extended header, but large attribute is not set",
					fh.GUID))
				break
			}
		} else if uefi.Read3Size(f.Header.Size) != fh.ExtendedSize {
			v.Errors = append(v.Errors, fmt.Errorf("file %v size not copied into extendedsize",
				fh.GUID))
			break
		}
		if buflen != fh.ExtendedSize {
			v.Errors = append(v.Errors, fmt.Errorf("file %v size mismatch! Size is %#x, buf length is %#x",
				fh.GUID, fh.ExtendedSize, buflen))
			break
		}

		// Header Checksums
		if sum := f.ChecksumHeader(); sum != 0 {
			v.Errors = append(v.Errors, fmt.Errorf("file %v header checksum failure! sum was %v",
				fh.GUID, sum))
		}

		// Body Checksum
		if !fh.Attributes.HasChecksum() && fh.Checksum.File != uefi.EmptyBodyChecksum {
			v.Errors = append(v.Errors, fmt.Errorf("file %v body checksum failure! Attribute was not set, but sum was %v instead of %v",
				fh.GUID, fh.Checksum.File, uefi.EmptyBodyChecksum))
		} else if fh.Attributes.HasChecksum() {
			headerSize := uefi.FileHeaderMinLength
			if fh.Attributes.IsLarge() {
				headerSize = uefi.FileHeaderExtMinLength
			}
			if sum := uefi.Checksum8(f.Buf()[headerSize:]); sum != 0 { // TODO: use the Payload function which does not exist yet
				v.Errors = append(v.Errors, fmt.Errorf("file %v body checksum failure! sum was %v",
					fh.GUID, sum))
			}
		}

	case *uefi.Section:
		buflen := uint32(len(f.Buf()))
		blankSize := [3]uint8{0xFF, 0xFF, 0xFF}

		// Size Checks
		sh := &f.Header
		if sh.Size == blankSize {
			if buflen < uefi.SectionExtMinLength {
				v.Errors = append(v.Errors, fmt.Errorf("section length too small!, buffer is only %#x bytes long for extended header",
					buflen))
				break
			}
		} else if uint32(uefi.Read3Size(f.Header.Size)) != sh.ExtendedSize {
			v.Errors = append(v.Errors, errors.New("section size not copied into extendedsize"))
			break
		}
		if buflen != sh.ExtendedSize {
			v.Errors = append(v.Errors, fmt.Errorf("section size mismatch! Size is %#x, buf length is %#x",
				sh.ExtendedSize, buflen))
			break
		}

	case *uefi.BIOSRegion:
		if f.FlashRegion() != nil && !f.FlashRegion().Valid() {
			v.Errors = append(v.Errors, fmt.Errorf("BIOSRegion is not valid, region was %v", *f.FlashRegion()))
		}

		if _, err := f.FirstFV(); err != nil {
			v.Errors = append(v.Errors, err)
		}

		for i, e := range f.Elements {
			if err := e.Value.Apply(v); err != nil {
				return err
			}
			f, ok := e.Value.(*uefi.FirmwareVolume)
			if !ok {
				// Not a firmware volume
				continue
			}
			// We have to do this because they didn't put an encapsulating structure around the FVs.
			// This means it's possible for different firmware volumes to report different erase polarities.
			// Now we have to check to see if we're in some insane state.
			if ep := f.GetErasePolarity(); ep != uefi.Attributes.ErasePolarity {
				v.Errors = append(v.Errors, fmt.Errorf("erase polarity mismatch! fv 0 has %#x and fv %d has %#x",
					uefi.Attributes.ErasePolarity, i, ep))
			}
		}
		return nil // We already traversed the children manually.

	case *uefi.MERegion:
		if f.FlashRegion() == nil {
			v.Errors = append(v.Errors, errors.New("region position is nil"))
		}
		if !f.FlashRegion().Valid() {
			v.Errors = append(v.Errors, fmt.Errorf("region is not valid, region was %v", *f.FlashRegion()))
		}

	case *uefi.RawRegion:
		if f.FlashRegion() == nil {
			v.Errors = append(v.Errors, errors.New("region position is nil"))
		}
		if !f.FlashRegion().Valid() {
			v.Errors = append(v.Errors, fmt.Errorf("region is not valid, region was %v", *f.FlashRegion()))
		}
	}
	return f.ApplyChildren(v)
}

func init() {
	RegisterCLI("validate", "perform extra validation checks", 0, func(args []string) (uefi.Visitor, error) {
		return &Validate{}, nil
	})
}

```

`pkg/visitors/validate_test.go`:

```go
// Copyright 2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package visitors

import (
	"testing"

	utk_test "github.com/linuxboot/fiano/integration"
	"github.com/linuxboot/fiano/pkg/uefi"
)

func TestValidateFV(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msgs []string
	}{
		{"sampleFV", utk_test.OVMFSecFV, nil},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			fv, err := uefi.NewFirmwareVolume(test.buf, 0, false)
			if err != nil {
				t.Fatalf("Error was not expected, got %v", err.Error())
			}
			v := &Validate{}
			if err := v.Run(fv); err != nil {
				t.Fatal(err)
			}
			if len(v.Errors) != len(test.msgs) {
				t.Errorf("Errors mismatched, wanted \n%v\n, got \n%v\n", test.msgs, v.Errors)
			} else {
				for i := range v.Errors {
					if v.Errors[i].Error() != test.msgs[i] {
						t.Errorf("Error mismatched, wanted \n%v\n, got \n%v\n", test.msgs[i], v.Errors[i].Error())
					}
				}
			}
		})
	}
}

func TestValidateFile(t *testing.T) {
	var tests = []struct {
		name string
		buf  []byte
		msgs []string
	}{
		{"emptyPadFile", emptyPadFile, nil},
		{"badFreeFormFile", badFreeFormFile, []string{"file FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF header checksum failure! sum was 54"}},
		{"goodFreeFormFile", goodFreeFormFile, nil},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			f, err := uefi.NewFile(test.buf)
			if err != nil {
				t.Fatalf("Error was not expected, got %v", err.Error())
			}
			v := &Validate{}
			if err := v.Run(f); err != nil {
				t.Fatal(err)
			}
			if len(v.Errors) != len(test.msgs) {
				t.Errorf("Errors mismatched, wanted \n%v\n, got \n%v\n", test.msgs, v.Errors)
			} else {
				for i := range v.Errors {
					if v.Errors[i].Error() != test.msgs[i] {
						t.Errorf("Error mismatched, wanted \n%v\n, got \n%v\n", test.msgs[i], v.Errors[i].Error())
					}
				}
			}
		})
	}
}

```

`scripts/checklicenses/checklicenses.go`:

```go
// Copyright 2017-2018 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Run with `go run checklicenses.go`. This script has one drawback:
//   - It does not correct the licenses; it simply outputs a list of files which
//     do not conform and returns 1 if the list is non-empty.
package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

var absPath = flag.Bool("a", false, "Print absolute paths")

const uroot = "$GOPATH/src/github.com/u-root/u-root"

// The first few lines of every go file is expected to contain this license.
var license = regexp.MustCompile(
	`^// Copyright [\d\-, ]+ the LinuxBoot Authors\. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file\.
`)

type rule struct {
	*regexp.Regexp
	invert bool
}

func accept(s string) rule {
	return rule{
		regexp.MustCompile("^" + s + "$"),
		false,
	}
}

func reject(s string) rule {
	return rule{
		regexp.MustCompile("^" + s + "$"),
		true,
	}
}

// A file is checked iff all the accepts and none of the rejects match.
var rules = []rule{
	accept(`.*\.go`),
	reject(`vendor/.*`), // Various authors
}

func main() {
	flag.Parse()
	uroot := os.ExpandEnv(uroot)
	incorrect := []string{}

	// List files added to u-root.
	out, err := exec.Command("git", "ls-files").Output()
	if err != nil {
		log.Fatalln("error running git ls-files:", err)
	}
	files := strings.Fields(string(out))

	// Iterate over files.
outer:
	for _, file := range files {
		// Test rules.
		trimmedPath := strings.TrimPrefix(file, uroot)
		for _, r := range rules {
			if r.MatchString(trimmedPath) == r.invert {
				continue outer
			}
		}

		// Make sure it is not a directory.
		info, err := os.Stat(file)
		if err != nil {
			log.Fatalln("cannot stat", file, err)
		}
		if info.IsDir() {
			continue
		}

		// Read from the file.
		r, err := os.Open(file)
		if err != nil {
			log.Fatalln("cannot open", file, err)
		}
		defer r.Close()
		contents, err := io.ReadAll(r)
		if err != nil {
			log.Fatalln("cannot read", file, err)
		}
		if !license.Match(contents) {
			p := trimmedPath
			if *absPath {
				p = file
			}
			incorrect = append(incorrect, p)
		}
	}
	if err != nil {
		log.Fatal(err)
	}

	// Print files with incorrect licenses.
	if len(incorrect) > 0 {
		fmt.Println(strings.Join(incorrect, "\n"))
		os.Exit(1)
	}
}

```

`scripts/namecollect/namecollect.go`:

```go
// Copyright 2019 the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Run with `go run namecollect.go`. This updates the knownguids.go file with
// names from EDK2.
package main

import (
	"flag"
	"go/build"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/linuxboot/fiano/pkg/guid"
	"github.com/linuxboot/fiano/pkg/knownguids"
)

const knownGUIDsFile = "src/github.com/linuxboot/fiano/pkg/knownguids/guids.go"

var (
	debug              = flag.Bool("d", false, "debug prints")
	knownGUIDsTemplate = `// Copyright {{.Year}} the LinuxBoot Authors. All rights reserved
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package knownguids contains a list of guids and their names.
// THIS FILE IS GENERATED! DO NOT MODIFY!
// To regenerate, run: go run scripts/namecollect/namecollect.go
package knownguids

import "github.com/linuxboot/fiano/pkg/guid"

// GUIDs is a mapping from a GUID to its name.
var GUIDs = map[guid.GUID]string {
	{{- range .GUIDs}}
	*guid.MustParse({{printf "%q" .GUID}}): {{printf "%q" .Name}},
	{{- end}}
}
`
)

func getGUIDsFile() string {
	gopath := build.Default.GOPATH
	if gopath == "" {
		gopath = os.ExpandEnv("$HOME/go")
	}
	o := filepath.Join(gopath, knownGUIDsFile)
	if *debug {
		log.Printf("Writing to %s", o)
	}
	return o
}

func downloadEdk2() (tmpDir string, err error) {
	tmpDir, err = os.MkdirTemp("", "namecollect")
	if err != nil {
		return "", err
	}
	github := "https://github.com/tianocore/edk2"
	cmd := exec.Command("git", "clone", "--depth=1", github, tmpDir)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		os.RemoveAll(tmpDir)
		return "", err
	}
	return tmpDir, nil
}

func findGUIDs(dir string) (map[guid.GUID]string, error) {
	guids := map[guid.GUID]string{}
	baseNameRegex := regexp.MustCompile(`[\t ]*BASE_NAME[\t ]*=([^\n#]+)`)
	fileGUIDRegex := regexp.MustCompile(`[\t ]*FILE_GUID[\t ]*=([^\n#]+)`)
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("skipping %q due to error: %v", path, err)
			return nil
		}
		if info.Mode().IsRegular() && strings.HasSuffix(path, ".inf") {
			if *debug {
				log.Printf("Check %s", path)
			}
			contents, err := os.ReadFile(path)
			if err != nil {
				log.Printf("skipping %q due to error: %v", path, err)
				return nil
			}
			baseNames := baseNameRegex.FindAllSubmatch(contents, -1)
			fileGUIDs := fileGUIDRegex.FindAllSubmatch(contents, -1)
			if len(baseNames) == 0 || len(fileGUIDs) == 0 {
				log.Printf("skipping %q because is does not contain BASE_NAME or FILE_GUID", path)
				return nil
			}
			if len(baseNames) != 1 || len(fileGUIDs) != 1 {
				log.Printf("skipping %q because it contains multiple of BASE_NAME or FILE_GUID", path)
				return nil
			}
			g, err := guid.Parse(strings.TrimSpace(string(fileGUIDs[0][1])))
			if err != nil {
				log.Printf("skipping %q because the GUID %q cannot be parsed: %v",
					path, fileGUIDs[0][1], err)
				return nil
			}
			name := strings.TrimSpace(string(baseNames[0][1]))
			if prevName, ok := guids[*g]; ok && prevName != name {
				name = prevName + "/" + name
				log.Printf("warning %v has two names %q and %q", *g, prevName, name)
			}
			guids[*g] = name
		}
		return nil
	})
	return guids, err
}

func main() {
	flag.Parse()
	tmpl, err := template.New("knownguids").Parse(knownGUIDsTemplate)
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(getGUIDsFile())
	if err != nil {
		log.Fatal(err)
	}

	tmpDir, err := downloadEdk2()
	if err != nil {
		log.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	newGUIDs, err := findGUIDs(tmpDir)
	if err != nil {
		log.Fatal(err)
	}

	previousGUIDs := knownguids.GUIDs
	for guid, n := range previousGUIDs {
		_, ok := newGUIDs[guid]
		if !ok {
			log.Printf("warning %v[%v] was in the old but not the new", n, guid)
			newGUIDs[guid] = n
		}
		if newGUIDs[guid] != n {
			log.Printf("warning %v name changed from %q to %q", guid, n, newGUIDs[guid])
			newGUIDs[guid] = n + "/" + newGUIDs[guid]
		}
	}

	// Sort so the order is deterministic.
	type guidNamePair struct {
		GUID guid.GUID
		Name string
	}
	sortedGUIDs := []guidNamePair{}
	for k, v := range newGUIDs {
		sortedGUIDs = append(sortedGUIDs, guidNamePair{k, v})
	}
	sort.SliceStable(sortedGUIDs, func(i, j int) bool {
		return strings.Compare(sortedGUIDs[i].Name, sortedGUIDs[j].Name) < 0
	})

	err = tmpl.Execute(f, struct {
		Year  int
		GUIDs []guidNamePair
	}{
		Year:  time.Now().Year(),
		GUIDs: sortedGUIDs,
	})
	if err != nil {
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatalln("error closing file:", err)
	}
}

```

`scripts/pre-commit`:

```
# Copyright 2018 the LinuxBoot Authors. All rights reserved
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

#!/bin/bash

set -e

echo "Running Pre-Commit"

FILES=`git diff --diff-filter=AM --staged --name-only | grep '.*\.go' | cat`

if [ -z "$FILES" ];
then
	echo "No go files to check. Skipping."
	exit 0
fi

gofmt -w -s $FILES
echo $FILES | xargs -n 1 golint -set_exit_status
go vet ./...

# Check it builds

for x in $(ls cmds); do
    (cd cmds/$x && go build .)
done

# Check tests

go test ./...
echo "Pre-Commit Passed"

```