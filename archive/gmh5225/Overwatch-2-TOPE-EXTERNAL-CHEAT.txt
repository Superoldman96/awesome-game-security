Project Path: arc_gmh5225_Overwatch-2-TOPE-EXTERNAL-CHEAT_5vyesw4_

Source Tree:

```txt
arc_gmh5225_Overwatch-2-TOPE-EXTERNAL-CHEAT_5vyesw4_
├── Config.hpp
├── Overwatch.hpp
├── Renderer.hpp
├── SDK.hpp
├── TOPE.sln
├── Target.hpp
├── Vector.hpp
├── example.vcxproj
├── example.vcxproj.filters
├── example.vcxproj.user
├── imgui.ini
├── includes.hpp
├── main.cpp
├── offsets.hpp
├── safecallez.h
├── skStr.h
└── xor.hpp

```

`Config.hpp`:

```hpp
#pragma once

namespace OW {
	namespace Config {
		/* Aimbot */
		float Flick_smooth = 2.f;
		float Tracking_smooth = 2.f;
		float Flick_speed = 2.f;
		float Tracking_speed = 2.f;
		float huintens = .1f;
		bool interception = false;
		float Fov = 90.f;
		float Within = 20.f;
		float SetFOV = 103.f;
		float y_pitch = 0.85f;
		float hitbox = 0.125f;
		float predit_level = 11.f;
		float lower = .4f;
		float bone = 0.30f;
		float boneorgy = 0.30f;
		bool Flick = false;
		bool dus = true;
		bool mouseevents = false;
		bool sendinput = false;
		bool Tracking = false;
		bool Silent = false;
		bool humamaim = false;
		int hero = 0;
		const char* heroes[] = { "Hanzo", "Genji", "Ana", "Sojourn", "Lucio", "Eco", "Pharah", "Orisa", "Torb", "Zen" };
		/* Draw */
		bool prediction = true;
		bool fovchanger = false;
		bool snapl = false;
		bool cornerbox = true;
		bool rectangle = true;
		bool triggerbot = false;
		bool filledrect = true;
		int selectedItem = 0;
		int ingameSensitivity = 15;
		bool geekmenu = false;
		bool draw_fov = true;
		int screenrezX = 1920;
		int screenrezY = 1080;
		bool draw_box = false;
		bool draw_edge = true;
		bool draw_3dbox = false;
		bool predd = true;
		float FlickMulti = 1.2f;
		double caps = 0.4;
		int key = VK_LBUTTON;
		int tkey = VK_MENU;
		int menukey = VK_INSERT;
		int closekey = VK_END;
		int apples = VK_F9;

		/* Draw Menu */
		bool Menu = true;
		bool force = true;

		/* Team */
		bool is_team = false;
		int delay = 45;
		int requestsper = 3;

		/* Color */
		ImVec4 EdgeESPColor = ImVec4(255, 0, 0, 255);
		ImVec4 EdgeESPinFOV = ImVec4(0, 1, 0, 1);
	}
}
```

`Overwatch.hpp`:

```hpp
#pragma once
#include "Target.hpp"
#include "Config.hpp"
#include <complex>
HWND Qum = SpoofFindWindowA("TankWindowClass", NULL);
#include "winuser.h"
HWND hwnd1;
static const char* KeyNames[] = {
"OFF",
"VK_LBUTTON",
"VK_RBUTTON",
"VK_CANCEL",
"VK_MBUTTON",
"VK_XBUTTON1",
"VK_XBUTTON2",
"Unknown",
"VK_BACK",
"VK_TAB",
"Unknown",
"Unknown",
"VK_CLEAR",
"VK_RETURN",
"Unknown",
"Unknown",
"VK_SHIFT",
"VK_CONTROL",
"VK_MENU",
"VK_PAUSE",
"VK_CAPITAL",
"VK_KANA",
"Unknown",
"VK_JUNJA",
"VK_FINAL",
"VK_KANJI",
"Unknown",
"VK_ESCAPE",
"VK_CONVERT",
"VK_NONCONVERT",
"VK_ACCEPT",
"VK_MODECHANGE",
"VK_SPACE",
"VK_PRIOR",
"VK_NEXT",
"VK_END",
"VK_HOME",
"VK_LEFT",
"VK_UP",
"VK_RIGHT",
"VK_DOWN",
"VK_SELECT",
"VK_PRINT",
"VK_EXECUTE",
"VK_SNAPSHOT",
"VK_INSERT",
"VK_DELETE",
"VK_HELP",
"0",
"1",
"2",
"3",
"4",
"5",
"6",
"7",
"8",
"9",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"A",
"B",
"C",
"D",
"E",
"F",
"G",
"H",
"I",
"J",
"K",
"L",
"M",
"N",
"O",
"P",
"Q",
"R",
"S",
"T",
"U",
"V",
"W",
"X",
"Y",
"Z",
"VK_LWIN",
"VK_RWIN",
"VK_APPS",
"Unknown",
"VK_SLEEP",
"VK_NUMPAD0",
"VK_NUMPAD1",
"VK_NUMPAD2",
"VK_NUMPAD3",
"VK_NUMPAD4",
"VK_NUMPAD5",
"VK_NUMPAD6",
"VK_NUMPAD7",
"VK_NUMPAD8",
"VK_NUMPAD9",
"VK_MULTIPLY",
"VK_ADD",
"VK_SEPARATOR",
"VK_SUBTRACT",
"VK_DECIMAL",
"VK_DIVIDE",
"VK_F1",
"VK_F2",
"VK_F3",
"VK_F4",
"VK_F5",
"VK_F6",
"VK_F7",
"VK_F8",
"VK_F9",
"VK_F10",
"VK_F11",
"VK_F12",
"VK_F13",
"VK_F14",
"VK_F15",
"VK_F16",
"VK_F17",
"VK_F18",
"VK_F19",
"VK_F20",
"VK_F21",
"VK_F22",
"VK_F23",
"VK_F24",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"VK_NUMLOCK",
"VK_SCROLL",
"VK_OEM_NEC_EQUAL",
"VK_OEM_FJ_MASSHOU",
"VK_OEM_FJ_TOUROKU",
"VK_OEM_FJ_LOYA",
"VK_OEM_FJ_ROYA",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"Unknown",
"VK_LSHIFT",
"VK_RSHIFT",
"VK_LCONTROL",
"VK_RCONTROL",
"VK_LMENU",
"VK_RMENU"
};
static const int KeyCodes[] = {
	0x0,  //Undefined
	0x01,
	0x02,
	0x03,
	0x04,
	0x05,
	0x06,
	0x07, //Undefined
	0x08,
	0x09,
	0x0A, //Reserved
	0x0B, //Reserved
	0x0C,
	0x0D,
	0x0E, //Undefined
	0x0F, //Undefined
	0x10,
	0x11,
	0x12,
	0x13,
	0x14,
	0x15,
	0x16, //IME On
	0x17,
	0x18,
	0x19,
	0x1A, //IME Off
	0x1B,
	0x1C,
	0x1D,
	0x1E,
	0x1F,
	0x20,
	0x21,
	0x22,
	0x23,
	0x24,
	0x25,
	0x26,
	0x27,
	0x28,
	0x29,
	0x2A,
	0x2B,
	0x2C,
	0x2D,
	0x2E,
	0x2F,
	0x30,
	0x31,
	0x32,
	0x33,
	0x34,
	0x35,
	0x36,
	0x37,
	0x38,
	0x39,
	0x3A, //Undefined
	0x3B, //Undefined
	0x3C, //Undefined
	0x3D, //Undefined
	0x3E, //Undefined
	0x3F, //Undefined
	0x40, //Undefined
	0x41,
	0x42,
	0x43,
	0x44,
	0x45,
	0x46,
	0x47,
	0x48,
	0x49,
	0x4A,
	0x4B,
	0x4C,
	0x4B,
	0x4E,
	0x4F,
	0x50,
	0x51,
	0x52,
	0x53,
	0x54,
	0x55,
	0x56,
	0x57,
	0x58,
	0x59,
	0x5A,
	0x5B,
	0x5C,
	0x5D,
	0x5E, //Rservered
	0x5F,
	0x60, //Numpad1
	0x61, //Numpad2
	0x62, //Numpad3
	0x63, //Numpad4
	0x64, //Numpad5
	0x65, //Numpad6
	0x66, //Numpad7
	0x67, //Numpad8
	0x68, //Numpad8
	0x69, //Numpad9
	0x6A,
	0x6B,
	0x6C,
	0x6D,
	0x6E,
	0x6F,
	0x70, //F1
	0x71, //F2
	0x72, //F3
	0x73, //F4
	0x74, //F5
	0x75, //F6
	0x76, //F7
	0x77, //F8
	0x78, //F9
	0x79, //F10
	0x7A, //F11
	0x7B, //F12
	0x7C, //F13
	0x7D, //F14
	0x7E, //F15
	0x7F, //F16
	0x80, //F17
	0x81, //F18
	0x82, //F19
	0x83, //F20
	0x84, //F21
	0x85, //F22
	0x86, //F23
	0x87, //F24
	0x88, //Unkown
	0x89, //Unkown
	0x8A, //Unkown
	0x8B, //Unkown
	0x8C, //Unkown
	0x8D, //Unkown
	0x8E, //Unkown
	0x8F, //Unkown
	0x90,
	0x91,
	0x92, //OEM Specific
	0x93, //OEM Specific
	0x94, //OEM Specific
	0x95, //OEM Specific
	0x96, //OEM Specific
	0x97, //Unkown
	0x98, //Unkown
	0x99, //Unkown
	0x9A, //Unkown
	0x9B, //Unkown
	0x9C, //Unkown
	0x9D, //Unkown
	0x9E, //Unkown 
	0x9F, //Unkown
	0xA0,
	0xA1,
	0xA2,
	0xA3,
	0xA4,
	0xA5
};
static int degrees = 0;

static void ImGui::Hotkey(int* k, const ImVec2& size_arg = ImVec2(0, 0))
{
	static bool waitingforkey = false;
	if (waitingforkey == false) {
		if (ImGui::Button(KeyNames[*(int*)k], size_arg))
			waitingforkey = true;
	}
	else if (waitingforkey == true) {
		ImGui::Button("...", size_arg);
		std::this_thread::sleep_for(std::chrono::milliseconds(20));
		for (auto& Key : KeyCodes)
		{
			if (GetAsyncKeyState(Key)) {
				*(int*)k = Key;
				waitingforkey = false;
			}
		}
	}
}
static void ImGui::Hotkey1(int* k, const ImVec2& size_arg = ImVec2(0, 0))
{
	static bool waitingforkey = false;
	if (waitingforkey == false) {
		if (ImGui::Button(KeyNames[*(int*)k], size_arg))
			waitingforkey = true;
	}
	else if (waitingforkey == true) {
		ImGui::Button("...", size_arg);
		std::this_thread::sleep_for(std::chrono::milliseconds(20));
		for (auto& Key : KeyCodes)
		{
			if (GetAsyncKeyState(Key)) {
				*(int*)k = Key;
				waitingforkey = false;
			}
		}
	}
}
static void ImGui::Hotkey2(int* k, const ImVec2& size_arg = ImVec2(0, 0))
{
	static bool waitingforkey = false;
	if (waitingforkey == false) {
		if (ImGui::Button(KeyNames[*(int*)k], size_arg))
			waitingforkey = true;
	}
	else if (waitingforkey == true) {
		ImGui::Button("...", size_arg);
		std::this_thread::sleep_for(std::chrono::milliseconds(20));
		for (auto& Key : KeyCodes)
		{
			if (GetAsyncKeyState(Key)) {
				*(int*)k = Key;
				waitingforkey = false;
			}
		}
	}
}
static void ImGui::Hotkey3(int* k, const ImVec2& size_arg = ImVec2(0, 0))
{
	static bool waitingforkey = false;
	if (waitingforkey == false) {
		if (ImGui::Button(KeyNames[*(int*)k], size_arg))
			waitingforkey = true;
	}
	else if (waitingforkey == true) {
		ImGui::Button("...", size_arg);
		std::this_thread::sleep_for(std::chrono::milliseconds(20));
		for (auto& Key : KeyCodes)
		{
			if (GetAsyncKeyState(Key)) {
				*(int*)k = Key;
				waitingforkey = false;
			}
		}
	}
}
static void ImGui::Hotkey4(int* k, const ImVec2& size_arg = ImVec2(0, 0))
{
	static bool waitingforkey = false;
	if (waitingforkey == false) {
		if (ImGui::Button(KeyNames[*(int*)k], size_arg))
			waitingforkey = true;
	}
	else if (waitingforkey == true) {
		ImGui::Button("...", size_arg);
		std::this_thread::sleep_for(std::chrono::milliseconds(20));
		for (auto& Key : KeyCodes)
		{
			if (GetAsyncKeyState(Key)) {
				*(int*)k = Key;
				waitingforkey = false;
			}
		}
	}
}

namespace OW {

	inline void velocity_thread() {

		while (true) {
			if (Config::prediction) {
				__try {

					for (int i = 0; i < Entity_t.size(); i++)
					{
						clock_t currTime = clock();
						if (Entitys[i].Team && Entitys[i].Live) {
							if ((currTime - Entitys[i].lastVelocityUpdate) >= 20)
							{
								//std::cout << Entitys[i].lastVelocityUpdate << "\n";
								Entitys[i].Velocity.X = (Entitys[i].Loc.X - Entitys[i].lastPos.X) / (currTime - Entitys[i].lastVelocityUpdate);
								//std::cout << "I: " << i << " X: " << Entitys[i].Velocity.X << "\n";
								Entitys[i].Velocity.Y = (Entitys[i].Loc.Y - Entitys[i].lastPos.Y) / (currTime - Entitys[i].lastVelocityUpdate);
								Entitys[i].Velocity.Z = (Entitys[i].Loc.Z - Entitys[i].lastPos.Z) / (currTime - Entitys[i].lastVelocityUpdate);
								Entitys[i].lastPos = Entitys[i].Loc;

								Entitys[i].lastVelocityUpdate = currTime;
							}
						}

					}
				}
				__except (0) {
					Sleep(1);
				}
			}

		}

	}
	void SolveQuartic(const std::complex<float> coefficients[5], std::complex<float> roots[4]) {
		const std::complex<float> a = coefficients[4];
		const std::complex<float> b = coefficients[3] / a;
		const std::complex<float> c = coefficients[2] / a;
		const std::complex<float> d = coefficients[1] / a;
		const std::complex<float> e = coefficients[0] / a;

		const std::complex<float> Q1 = c * c - 3.f * b * d + 12.f * e;
		const std::complex<float> Q2 = 2.f * c * c * c - 9.f * b * c * d + 27.f * d * d + 27.f * b * b * e - 72.f * c * e;
		const std::complex<float> Q3 = 8.f * b * c - 16.f * d - 2.f * b * b * b;
		const std::complex<float> Q4 = 3.f * b * b - 8.f * c;

		const std::complex<float> Q5 = std::pow(Q2 / 2.f + std::sqrt(Q2 * Q2 / 4.f - Q1 * Q1 * Q1), 1.f / 3.f);
		const std::complex<float> Q6 = (Q1 / Q5 + Q5) / 3.f;
		const std::complex<float> Q7 = 2.f * std::sqrt(Q4 / 12.f + Q6);

		roots[0] = (-b - Q7 - std::sqrt(4.f * Q4 / 6.f - 4.f * Q6 - Q3 / Q7)) / 4.f;
		roots[1] = (-b - Q7 + std::sqrt(4.f * Q4 / 6.f - 4.f * Q6 - Q3 / Q7)) / 4.f;
		roots[2] = (-b + Q7 - std::sqrt(4.f * Q4 / 6.f - 4.f * Q6 + Q3 / Q7)) / 4.f;
		roots[3] = (-b + Q7 + std::sqrt(4.f * Q4 / 6.f - 4.f * Q6 + Q3 / Q7)) / 4.f;
	}
	Vector3 predictCalc(Vector3 EnPos, float Speed, Vector3 Velocity)
	{
		__try {
			Vector3 Predict;
			auto origin = viewMatrix.GetCameraVec();
			origin.X -= 0.5;
			origin.Y -= 0.85;
			origin.Z -= 0.5;
			double G = -9.81f;
			double A = origin.X;
			double B = origin.Y;
			double C = origin.Z;
			double M = EnPos.X;
			double N = EnPos.Y;
			double O = EnPos.Z;
			double P = Velocity.X * 1000;
			double Q = Velocity.Y * 1000;
			double R = Velocity.Z * 1000;
			double S = Speed;
			double H = M - A;
			double J = O - C;
			double K = N - B;
			double L = -.5f * G;
			double c4 = L * L;
			double c3 = -2 * Q * L;
			double c2 = (Q * Q) - (2 * K * L) - (S * S) + (P * P) + (R * R);
			double c1 = (2 * K * Q) + (2 * H * P) + (2 * J * R);
			double c0 = (K * K) + (H * H) + (J * J);

			std::complex<float> pOutRoots[4];
			const std::complex<float> pInCoeffs[5] = { c0, c1, c2, c3, c4 };
			SolveQuartic(pInCoeffs, pOutRoots);
			float fBestRoot = FLT_MAX;
			for (int i = 0; i < 4; i++) {
				if (pOutRoots[i].real() > 0.f && std::abs(pOutRoots[i].imag()) < 0.0001f && pOutRoots[i].real() < fBestRoot) {
					fBestRoot = pOutRoots[i].real();
				}
			}

			Predict.X = EnPos.X + (Velocity.X * fBestRoot * 1000);
			Predict.Y = EnPos.Y + (Velocity.Y * fBestRoot * 1000);
			Predict.Z = EnPos.Z + (Velocity.Z * fBestRoot * 1000);
			return Predict;
		}
		__except (0) {

		}

	}
	inline void prediction_thread() {
		while (true) {
			std::vector<DWORD64>temp_entity = Entity_t;
			if (temp_entity.size() > 0)
			{

				for (int i = 0; i < temp_entity.size(); i++)
				{
					__try {
						float speed = 0;
						//"Hanzo", "Widow", "Genji", "Ana", "Sojourn", "Lucio", "Eco", "Pharah", "Orisa", "Torb", "Zen"
						if (Config::heroes[Config::hero] == "Hanzo") speed = 110.0f;
						if (Config::heroes[Config::hero] == "Genji") speed = 60.0f;
						if (Config::heroes[Config::hero] == "Ana") speed = 52.2f;
						if (Config::heroes[Config::hero] == "Sojourn") speed = 160.0f;
						if (Config::heroes[Config::hero] == "Lucio") speed = 50.0f;
						if (Config::heroes[Config::hero] == "Eco") speed = 75.0f;
						if (Config::heroes[Config::hero] == "Pharah") speed = 35.0f;
						if (Config::heroes[Config::hero] == "Orisa") speed = 90.0f;
						if (Config::heroes[Config::hero] == "Torb") speed = 70.0f;
						if (Config::heroes[Config::hero] == "Zen") speed = 90.0f;

						Entitys[i].predict = predictCalc(Vector3(Entitys[i].Loc.X, Entitys[i].Loc.Y + Config::bone, Entitys[i].Loc.Z), speed, Entitys[i].Velocity);
					}
					__except (0) {

					}
				}
				Sleep(1);
			}
			else {
				Sleep(5);
			}
		}
	}

	inline void scan_matrix_ex();
	inline void entity_thread() {
		while (true) {
			std::this_thread::sleep_for(std::chrono::milliseconds(3));
			std::vector<DWORD64>temp_entity = Entity_t;
			if (temp_entity.size() > 0)
			{
				for (int i = 0; i < temp_entity.size(); i++)
				{
					Entitys[i].base = SDK->RPM<Vector3>(temp_entity[i] - 0x9C); // base offset
					Entitys[i].headbase = SDK->RPM<Vector3>(temp_entity[i] - 0x8C); // head?
					Entitys[i].center = Vector3(Entitys[i].base.X + 0.4717, Entitys[i].base.Y + 1, Entitys[i].base.Z + 0.54717); // offset for esp
					Entitys[i].head = Vector3(Entitys[i].headbase.X + (-5.2 / 10), Entitys[i].headbase.Y + (-3.5 / 10), Entitys[i].headbase.Z + (-4.8 / 10)); // offset for aimbot
					Entitys[i].head2 = SDK->RPM<Vector3>(temp_entity[i] - 0x9C);
					Entitys[i].Loc = Vector3(Entitys[i].head2.X + 0.5f, Entitys[i].head2.Y + 0.6f, Entitys[i].head2.Z + 0.5f);
					Config::bone = Config::boneorgy;
					// If the user is pressing VK_Shift, lower Entitys[i].head.Y by 0.4. This is for aimbot against ana, etc
					if (GetKeyState(20)) {
						Entitys[i].head.Y -= Config::lower;
						Config::bone -= Config::lower;
					}
					else {
					}
					Entitys[i].Live = SDK->RPM<BYTE>(temp_entity[i] - 0x1) == 0x14; // living check
					if (!Config::is_team)
						Entitys[i].Team = SDK->RPM<BYTE>(temp_entity[i] - 0x4) != 0x8; // team check
					else
						Entitys[i].Team = SDK->RPM<BYTE>(temp_entity[i] - 0x4) != 0x10;
					if (GetAsyncKeyState(Config::apples)) {
						Sleep(1000);
						if (Config::is_team -= false)
							Config::is_team -= true;
						else if (Config::is_team -= true)
							Config::is_team -= false;
					}
				}
				viewMatrix = SDK->RPM<Matrix>(viewMatrixPtr);
				//scan_matrix_ex();
				std::this_thread::sleep_for(std::chrono::milliseconds(3));
			}
			else
			{
				std::this_thread::sleep_for(std::chrono::milliseconds(5));
			}
		}
	}

	inline void esp() {
		__try {
			ImDrawList* Draw = ImGui::GetBackgroundDrawList();
			ImVec2 CrossHair = ImVec2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
			if (Config::draw_edge) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z), &Vec2_A))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_B))
							continue;
						float Size = abs(Vec2_A.Y - Vec2_B.Y) / 2.0f;
						float Size2 = abs(Vec2_A.Y - Vec2_B.Y) / 20.0f;
						float Height2 = abs(Vec2_A.Y - Vec2_B.Y);
						int num7 = (float)(1500 / (int)Height2);
						float xpos = (Vec2_A.X + Vec2_B.X) / 2.f;
						float ypos = Vec2_A.Y + Size / 5;
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Render::DrawEdges(ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size2 / 1.5f, Vec2_A.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
						}
						else {
							Render::DrawEdges(ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size2 / 1.5f, Vec2_A.Y), ImGui::GetColorU32(Config::EdgeESPColor));
						}
						//Render::DrawEdges(ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size2 / 1.5f, Vec2_A.Y), ImGui::GetColorU32(Config::EdgeESPColor));

					}
				}
			}
			if (Config::draw_box) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z), &Vec2_A))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_B))
							continue;

						float Size = abs(Vec2_A.Y - Vec2_B.Y) / 2.0f;
						float Size2 = abs(Vec2_A.Y - Vec2_B.Y) / 20.0f;
						float Height2 = abs(Vec2_A.Y - Vec2_B.Y);
						int num7 = (float)(1500 / (int)Height2);
						float xpos = (Vec2_A.X + Vec2_B.X) / 2.f;
						float ypos = Vec2_A.Y + Size / 5;
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Draw->AddRect(ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddRectFilled(ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImGui::GetColorU32(ImVec4(0, 0, 0, 0.4)));
							//Draw->AddCircle(ImVec2(xpos, ypos - Height2), 5, ImGui::GetColorU32(Config::EdgeESPinFOV));
						}

						else
						{
							Draw->AddRect(ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddRectFilled(ImVec2(xpos + Size / 1.5f, Vec2_B.Y), ImVec2(xpos - Size / 1.5f, Vec2_A.Y), ImGui::GetColorU32(ImVec4(0, 0, 0, 0.4)));
						}
					}
				}
			}
			if (Config::predd) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector2 Vec2_Q;
						if (!viewMatrix.WorldToScreen(Entitys[i].predict, &Vec2_Q))
							continue;
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z), &Vec2_A))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_B))
							continue;

						float Size = abs(Vec2_A.Y - Vec2_B.Y) / 2.0f;
						float Size2 = abs(Vec2_A.Y - Vec2_B.Y) / 20.0f;
						float Height2 = abs(Vec2_A.Y - Vec2_B.Y);
						int num7 = (float)(1500 / (int)Height2);
						float xpos = (Vec2_A.X + Vec2_B.X) / 2.f;
						float ypos = Vec2_A.Y + Size / 5;
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Draw->AddCircle(ImVec2(Vec2_Q.X, Vec2_Q.Y), 3, ImGui::GetColorU32(Config::EdgeESPinFOV));
							//Draw->AddCircle(ImVec2(xpos, ypos - Height2), 5, ImGui::GetColorU32(Config::EdgeESPinFOV));
						}

						else
						{
							Draw->AddCircle(ImVec2(Vec2_Q.X, Vec2_Q.Y), 3, ImGui::GetColorU32(Config::EdgeESPColor));
						}
					}
				}
			}
			if (Config::draw_3dbox) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						Vector2 Vec2_C{}, Vec2_D{}, Vec2_E{}, Vec2_F{}, Vec2_G{}, Vec2_H{}, Vec2_I{}, Vec2_J{}, Vec2_K{}, Vec2_L{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X + 1.0f, Vec3.Y + 0.8f, Vec3.Z), &Vec2_C))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X - 1.0f, Vec3.Y + 0.8f, Vec3.Z), &Vec2_D))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z + 1.0f), &Vec2_E))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z - 1.0f), &Vec2_F))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X + 1.0f, Vec3.Y - 1.5f, Vec3.Z), &Vec2_G))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X - 1.0f, Vec3.Y - 1.5f, Vec3.Z), &Vec2_H))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z + 1.0f), &Vec2_I))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z - 1.0f), &Vec2_J))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_K))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X - 2.0f, Vec3.Y + 0.8f, Vec3.Z + 2.0f), &Vec2_L))
							continue;
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_E.X, Vec2_E.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_F.X, Vec2_F.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_E.X, Vec2_E.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_F.X, Vec2_F.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							//
							Draw->AddLine(ImVec2(Vec2_G.X, Vec2_G.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_G.X, Vec2_G.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_H.X, Vec2_H.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_H.X, Vec2_H.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							//
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_G.X, Vec2_G.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_H.X, Vec2_H.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_E.X, Vec2_E.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
							Draw->AddLine(ImVec2(Vec2_F.X, Vec2_F.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPinFOV));
						}
						else
						{
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_E.X, Vec2_E.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_F.X, Vec2_F.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_E.X, Vec2_E.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_F.X, Vec2_F.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							//
							Draw->AddLine(ImVec2(Vec2_G.X, Vec2_G.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_G.X, Vec2_G.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_H.X, Vec2_H.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_H.X, Vec2_H.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							//
							Draw->AddLine(ImVec2(Vec2_C.X, Vec2_C.Y), ImVec2(Vec2_G.X, Vec2_G.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_D.X, Vec2_D.Y), ImVec2(Vec2_H.X, Vec2_H.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_E.X, Vec2_E.Y), ImVec2(Vec2_I.X, Vec2_I.Y), ImGui::GetColorU32(Config::EdgeESPColor));
							Draw->AddLine(ImVec2(Vec2_F.X, Vec2_F.Y), ImVec2(Vec2_J.X, Vec2_J.Y), ImGui::GetColorU32(Config::EdgeESPColor));
						}
					}
				}
			}
			if (Config::snapl) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						Vector2 Vec2_C{}, Vec2_D{}, Vec2_E{}, Vec2_F{}, Vec2_G{}, Vec2_H{}, Vec2_I{}, Vec2_J{}, Vec2_K{}, Vec2_L{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z), &Vec2_A))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_B))
							continue;
						float Size = abs(Vec2_A.Y - Vec2_B.Y) / 2.0f;
						float Size2 = abs(Vec2_A.Y - Vec2_B.Y) / 20.0f;
						float Height2 = abs(Vec2_A.Y - Vec2_B.Y);
						int num7 = (float)(1500 / (int)Height2);
						float xpos = (Vec2_A.X + Vec2_B.X) / 2.f;
						float ypos = Vec2_A.Y + Size / 5;
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Draw->AddLine(ImVec2(960, 0), ImVec2(xpos, ypos - Height2), ImGui::GetColorU32(Config::EdgeESPinFOV), 1.0f);
							//Draw->AddCircle(ImVec2(xpos, ypos - Height2), 5, ImGui::GetColorU32(Config::EdgeESPinFOV));
						}

						else
						{
							Draw->AddLine(ImVec2(960, 0), ImVec2(xpos, ypos - Height2), ImGui::GetColorU32(Config::EdgeESPColor), 1.0f);
						}
					}
				}
			}
			if (Config::dus) {
				for (int i = 0; i < Entity_t.size(); i++) {
					if (Entitys[i].Team && Entitys[i].Live) {
						Vector3 Vec3 = Entitys[i].center;
						Vector2 Vec2_A{}, Vec2_B{};
						Vector2 Vec2_C{}, Vec2_D{}, Vec2_E{}, Vec2_F{}, Vec2_G{}, Vec2_H{}, Vec2_I{}, Vec2_J{}, Vec2_K{}, Vec2_L{};
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y - 1.5f, Vec3.Z), &Vec2_A))
							continue;
						if (!viewMatrix.WorldToScreen(Vector3(Vec3.X, Vec3.Y + 0.8f, Vec3.Z), &Vec2_B))
							continue;
						float Size = abs(Vec2_A.Y - Vec2_B.Y) / 2.0f;
						float Size2 = abs(Vec2_A.Y - Vec2_B.Y) / 20.0f;
						float Height2 = abs(Vec2_A.Y - Vec2_B.Y);
						int num7 = (float)(1500 / (int)Height2);
						float xpos = (Vec2_A.X + Vec2_B.X) / 2.f;
						float ypos = Vec2_A.Y + Size / 5;
						auto cool = viewMatrix.GetCameraVec();
						int distance = sqrt(((cool.X - Entitys[i].Loc.X) * (cool.X - Entitys[i].Loc.X)) + ((cool.Y - (Entitys[i].Loc.Y + Config::bone)) * (cool.Y - (Entitys[i].Loc.Y + Config::bone))) + ((cool.Z - Entitys[i].Loc.Z) * (cool.Z - Entitys[i].Loc.Z)));
						std::string distance2 = "[" + std::to_string(distance) + "]";
						ImVec2 textSize = ImGui::CalcTextSize(distance2.c_str());
						Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
						Vector2 RealVe2 = Vector2(Vec2_B.X - CrossHair.X, Vec2_B.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2_B);
						float origin = FLT_MAX;
						if (CrossDist < origin && CrossDist < Config::Fov) {
							Draw->AddText(ImVec2(xpos - (textSize.x / 2), ypos), ImGui::GetColorU32(Config::EdgeESPinFOV), (char*)distance2.c_str());
							//Draw->AddCircle(ImVec2(xpos, ypos - Height2), 5, ImGui::GetColorU32(Config::EdgeESPinFOV));
						}

						else
						{
							Draw->AddText(ImVec2(xpos - (textSize.x / 2), ypos), ImGui::GetColorU32(Config::EdgeESPColor), (char*)distance2.c_str());
						}
					}
				}
			}
			if (Config::draw_fov) {
				Draw->AddCircle(CrossHair, Config::Fov, 0xFFFFFFFF, 100);
			}
		}
		__except (1) {

		}
	}

	inline void overlay_thread() {
		std::chrono::system_clock::time_point a = std::chrono::system_clock::now();
		std::chrono::system_clock::time_point b = std::chrono::system_clock::now();

		HWND tWnd = SpoofFindWindowA("TankWindowClass", NULL);
		WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, "MedalOverlay", NULL };
		RegisterClassEx(&wc);
		HWND hwnd;
		if (!windows11yes) {
			hwnd = FindWindowA("MedalOverlayClass", "MedalOverlay");
			if (!hwnd) {
				MessageBox(0, "Failed to find Medal\nPress OK to proceed to website", "Failed to hijack Window", MB_OK);
				system("start https://medal.tv/");
				exit(1);
			}
		}
		else {
			hwnd = CreateWindowA(wc.lpszClassName, "Discord", WS_POPUP, 0, 0, 0, 0, NULL, NULL, wc.hInstance, NULL);
		}
		if (!CreateDeviceD3D(hwnd))
		{
			CleanupDeviceD3D();
			UnregisterClass(wc.lpszClassName, wc.hInstance);
		
		}

		MARGINS margins = { -1 };
		if (windows11yes) {
			DwmExtendFrameIntoClientArea(hwnd, &margins);
		}

		SpoofSetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
		SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_NOACTIVATE);


		IMGUI_CHECKVERSION();
		ImGui::CreateContext();

		ImGuiIO& io = ImGui::GetIO(); (void)io;

		ImGui::StyleColorsDark();

		ImGui_ImplWin32_Init(tWnd);
		ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

		MSG msg;
		ZeroMemory(&msg, sizeof(msg));
		int FPS;
		while (SpoofFindWindowA("TankWindowClass", NULL))
		{

			io.DeltaTime = 1.0f / 60.0f;

			std::this_thread::sleep_for(std::chrono::milliseconds(1));
			DEVMODE dm;
			dm.dmSize = sizeof(DEVMODE);

			EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &dm);

			FPS = dm.dmDisplayFrequency;

			a = std::chrono::system_clock::now();
			std::chrono::duration<double, std::milli> work_time = a - b;
			if (work_time.count() < 1000 / FPS)
			{
				std::chrono::duration<double, std::milli> delta_ms(1000 / FPS - work_time.count());
				auto delta_ms_duration = std::chrono::duration_cast<std::chrono::milliseconds>(delta_ms);
				std::this_thread::sleep_for(std::chrono::milliseconds(delta_ms_duration.count()));
			}

			b = std::chrono::system_clock::now();
			std::chrono::duration<double, std::milli> sleep_time = b - a;

			DWORD Style = GetWindowLong(tWnd, GWL_STYLE);
			RECT rect;
			GetWindowRect(tWnd, &rect);

			SpoofSetWindowPos(hwnd, HWND_TOPMOST, rect.left, rect.top, rect.right, rect.bottom, SWP_NOZORDER);

			SpoofSetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			ShowWindow(hwnd, SW_SHOWDEFAULT);
			UpdateWindow(hwnd);
			if (::PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
			{
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
				continue;
			}

			if (GetKeyRandomized(VK_LBUTTON))
			{
				ImGui::GetIO().MouseDown[0] = true;
			}
			else
			{
				ImGui::GetIO().MouseDown[0] = false;
			}

			//io.Fonts->AddFontFromFileTTF("C:\\Windows\\Fonts\\Arial.ttf", 14); fucking memory leak :/

			auto& colors = ImGui::GetStyle().Colors;
			colors[ImGuiCol_WindowBg] = ImVec4{ 0.1f, 0.1f, 0.13f, 1.0f };
			colors[ImGuiCol_MenuBarBg] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };

			// Border
			colors[ImGuiCol_Border] = ImVec4{ 0.44f, 0.37f, 0.61f, 0.29f };
			colors[ImGuiCol_BorderShadow] = ImVec4{ 0.0f, 0.0f, 0.0f, 0.24f };

			// Text
			colors[ImGuiCol_Text] = ImVec4{ 1.0f, 1.0f, 1.0f, 1.0f };
			colors[ImGuiCol_TextDisabled] = ImVec4{ 0.5f, 0.5f, 0.5f, 1.0f };

			// Headers
			colors[ImGuiCol_Header] = ImVec4{ 0.13f, 0.13f, 0.17, 1.0f };
			colors[ImGuiCol_HeaderHovered] = ImVec4{ 0.19f, 0.2f, 0.25f, 1.0f };
			colors[ImGuiCol_HeaderActive] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };

			// Buttons
			colors[ImGuiCol_Button] = ImVec4{ 0.13f, 0.13f, 0.17, 1.0f };
			colors[ImGuiCol_ButtonHovered] = ImVec4{ 0.19f, 0.2f, 0.25f, 1.0f };
			colors[ImGuiCol_ButtonActive] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_CheckMark] = ImVec4{ 0.74f, 0.58f, 0.98f, 1.0f };

			// Popups
			colors[ImGuiCol_PopupBg] = ImVec4{ 0.1f, 0.1f, 0.13f, 0.92f };

			// Slider
			colors[ImGuiCol_SliderGrab] = ImVec4{ 0.44f, 0.37f, 0.61f, 0.54f };
			colors[ImGuiCol_SliderGrabActive] = ImVec4{ 0.74f, 0.58f, 0.98f, 0.54f };

			// Frame BG
			colors[ImGuiCol_FrameBg] = ImVec4{ 0.13f, 0.13, 0.17, 1.0f };
			colors[ImGuiCol_FrameBgHovered] = ImVec4{ 0.19f, 0.2f, 0.25f, 1.0f };
			colors[ImGuiCol_FrameBgActive] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };

			// Tabs
			colors[ImGuiCol_Tab] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_TabHovered] = ImVec4{ 0.24, 0.24f, 0.32f, 1.0f };
			colors[ImGuiCol_TabActive] = ImVec4{ 0.2f, 0.22f, 0.27f, 1.0f };
			colors[ImGuiCol_TabUnfocused] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_TabUnfocusedActive] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };

			// Title
			colors[ImGuiCol_TitleBg] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_TitleBgActive] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_TitleBgCollapsed] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };

			// Scrollbar
			colors[ImGuiCol_ScrollbarBg] = ImVec4{ 0.1f, 0.1f, 0.13f, 1.0f };
			colors[ImGuiCol_ScrollbarGrab] = ImVec4{ 0.16f, 0.16f, 0.21f, 1.0f };
			colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4{ 0.19f, 0.2f, 0.25f, 1.0f };
			colors[ImGuiCol_ScrollbarGrabActive] = ImVec4{ 0.24f, 0.24f, 0.32f, 1.0f };

			// Seperator
			colors[ImGuiCol_Separator] = ImVec4{ 0.44f, 0.37f, 0.61f, 1.0f };
			colors[ImGuiCol_SeparatorHovered] = ImVec4{ 0.74f, 0.58f, 0.98f, 1.0f };
			colors[ImGuiCol_SeparatorActive] = ImVec4{ 0.84f, 0.58f, 1.0f, 1.0f };

			// Resize Grip
			colors[ImGuiCol_ResizeGrip] = ImVec4{ 0.44f, 0.37f, 0.61f, 0.29f };
			colors[ImGuiCol_ResizeGripHovered] = ImVec4{ 0.74f, 0.58f, 0.98f, 0.29f };
			colors[ImGuiCol_ResizeGripActive] = ImVec4{ 0.84f, 0.58f, 1.0f, 0.29f };


			auto& style = ImGui::GetStyle();
			style.TabRounding = 4;
			style.ScrollbarRounding = 9;
			style.WindowRounding = 7;
			style.GrabRounding = 3;
			style.FrameRounding = 3;
			style.PopupRounding = 4;
			style.ChildRounding = 4;



			ImGui_ImplDX11_NewFrame();
			ImGui_ImplWin32_NewFrame();
			ImGui::NewFrame();
			bool _visible = true;
			if (Config::Menu)
			{
				ImGui::SetNextWindowPos(ImVec2{ 50, 30 }, ImGuiCond_Once);
				if (ImGui::Begin(skCrypt("Aim"), &_visible, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) {
					ImGui::Checkbox(skCrypt("Aimbot"), &Config::Tracking);
					ImGui::Checkbox(skCrypt("Flick Bot"), &Config::Flick);
					ImGui::Checkbox(skCrypt("Triggerbot"), &Config::triggerbot);
					ImGui::Text(skCrypt("Turn on CapsLock to aim lower"));
					ImGui::Separator();
					ImGui::SliderFloat(skCrypt("Aim Smoothness"), &Config::Tracking_smooth, 0.f, 10.f, "%0.1f");
					ImGui::SliderFloat(skCrypt("Flick Smoothing"), &Config::Flick_smooth, 0.f, 20.f, "%0.1f");
					ImGui::SliderFloat(skCrypt("CapsLock Lowerness"), &Config::lower, -5.f, 5.f, "%0.1f");
					ImGui::Separator();
					//ImGui::Text(skCrypt("Advanced Flick Precision"));
					//ImGui::SliderFloat(skCrypt("Flick Speed/Smoothness"), &Config::Flick_smooth, 0.f, 15.f, "%.01f");
					//ImGui::SliderInt(skCrypt("Flick Delay Before Shot"), &Config::delay, 1, 100, "%.001f");
					//ImGui::SliderInt(skCrypt("Flick Aim Requests"), &Config::requestsper, 1, 20, "%.001f");
					//ImGui::InputDouble(Config::caps);
					//ImGui::InputDouble("CapsLock Lowering", &Config::down, -3, 3);
					ImGui::Separator();
					ImGui::Text(skCrypt("Prediction:"));
					ImGui::Checkbox(skCrypt("Prediction"), &Config::prediction);
					ImGui::Combo(skCrypt("Hero"), &Config::hero, Config::heroes, IM_ARRAYSIZE(Config::heroes));
					ImGui::Text(skCrypt("Bone"));
					ImGui::SliderFloat(skCrypt("Bone"), &Config::boneorgy, 0.f, 1.0f, "%.02f");
					ImGui::Separator();
					ImGui::Text(skCrypt("Aim Key"));
					ImGui::Hotkey(&Config::key, ImVec2(90, 40));
					ImGui::Text(skCrypt("Trigger/Flick Key"));
					ImGui::Hotkey1(&Config::tkey, ImVec2(90, 40));
				}
				ImGui::SetNextWindowPos(ImVec2{ 450, 30 }, ImGuiCond_Once);
				if (ImGui::Begin(skCrypt("Visuals"), &_visible, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) {
					ImGui::Checkbox(skCrypt("Draw FOV"), &Config::draw_fov);
					ImGui::Checkbox(skCrypt("Box ESP"), &Config::draw_box);
					ImGui::Checkbox(skCrypt("Prediction Circle ESP"), &Config::predd);
					ImGui::Checkbox(skCrypt("Distance ESP"), &Config::dus);
					ImGui::Checkbox(skCrypt("3D Box ESP"), &Config::draw_3dbox);
					ImGui::Checkbox(skCrypt("Corner ESP"), &Config::draw_edge);
					ImGui::Checkbox(skCrypt("Snaplines"), &Config::snapl);
					ImGui::ColorEdit4(skCrypt("ESP Color (In FOV)"), (float*)&Config::EdgeESPinFOV, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);
					ImGui::ColorEdit4(skCrypt("ESP Color (Not in FOV)"), (float*)&Config::EdgeESPColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoLabel);
					ImGui::Separator();
					ImGui::SliderFloat(skCrypt("Circle FOV"), &Config::Fov, 20.0f, 1000.0f, "%.01f");
				}
				ImGui::SetNextWindowPos(ImVec2{ 800, 30 }, ImGuiCond_Once);
				if (ImGui::Begin(skCrypt("Misc"), &_visible, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) {
					ImGui::Checkbox(skCrypt("Switch Team Target"), &Config::is_team);
					ImGui::Text(skCrypt("Team Target (Keybind)"));
					ImGui::Hotkey4(&Config::apples, ImVec2(70, 30));
					ImGui::Separator();
					ImGui::Text(skCrypt("Open/Close Menu"));
					ImGui::Hotkey2(&Config::menukey, ImVec2(90, 40));
					ImGui::Text(skCrypt("Close Cheat"));
					ImGui::Hotkey3(&Config::closekey, ImVec2(90, 40));
				}
				ImGui::End();
			}

			esp();
			ImGui::EndFrame();
			ImGui::Render();
			g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
			auto ss = ImVec4(0, 0, 0, 0);
			g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, (float*)&ss);
			ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

			g_pSwapChain->Present(1, 0);
		}

		ImGui_ImplDX11_Shutdown();
		ImGui_ImplWin32_Shutdown();
		ImGui::DestroyContext();

		CleanupDeviceD3D();
		::DestroyWindow(hwnd);
		if (windows11yes) {
			::UnregisterClass(wc.lpszClassName, wc.hInstance);
		}
	}
	inline void aimbot_thread() {
		__try {
			timeBeginPeriod(1);
			Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);
			static float origin_sens = 0.f;

			bool shooted = false;
			while (true) {
				//Tracking
				if (Config::Tracking) {
					Config::Flick = false;
					Config::humamaim = false;
					Config::triggerbot = false;
					Config::Silent = false;
					//Vector2 TarGet = GetAimEnemy();
					while (GetKeyRandomized(Config::key))
					{
						Vector2 TarGet = GetAimEnemy();
						{
							SpoofedMouseEvent(MOUSEEVENTF_MOVE, TarGet.X * Config::Tracking_smooth / (3.f * 8.f), TarGet.Y * Config::Tracking_smooth / (3.f * 8.f), NULL, NULL);
						}
						std::this_thread::sleep_for(std::chrono::milliseconds(1));
					}
				}
				else if (Config::Flick) {

					Config::Tracking = false;
					Config::humamaim = false;
					Config::triggerbot = false;
					Vector2 TarGets = GetAimEnemy();
					while (GetKeyRandomized(Config::tkey))
					{

						Vector2 TarGet = GetAimEnemy();
						{
							SpoofedMouseEvent(MOUSEEVENTF_MOVE, TarGet.X * Config::Flick_smooth / (3.f * 8.f), TarGet.Y * Config::Flick_smooth / (3.f * 8.f), NULL, NULL);
							SpoofedMouseEvent(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
							SpoofedMouseEvent(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
						}
					}
				}
				else if (Config::triggerbot) {
					Config::Tracking = false;
					Config::Flick = false;
					Config::Silent = false;
					Config::humamaim = false;
					Vector2 TarGets = GetAimEnemy();
					while (GetKeyRandomized(Config::tkey))
					{
						Vector2 TarGet = GetAimEnemy();
						if (TarGet.X != 0 && TarGet.Y != 0)
						{
							SpoofedMouseEvent(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
							SpoofedMouseEvent(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
							std::this_thread::sleep_for(std::chrono::milliseconds(1));
						}
					}
				}
			}
			timeBeginPeriod(1);
		}
		__except (1) {
			std::this_thread::sleep_for(std::chrono::milliseconds(1));
		}
	}


	inline bool compress_mbis = false;
	inline std::vector<MEMORY_BASIC_INFORMATION64> mbis = {};

	inline bool update_memory_query()
	{
		MEMORY_BASIC_INFORMATION64 mbi = { 0, };
		MEMORY_BASIC_INFORMATION64 old = { 0, };
		uintptr_t current_address = 0x7ffe0000;
		std::vector<MEMORY_BASIC_INFORMATION64> addresses;
		while (true)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(1));
			if (!VirtualQueryEx(SDK->hProcess, (LPVOID)current_address, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(MEMORY_BASIC_INFORMATION64)))
				break;
			if ((mbi.State & 0x1000) != 0 && (mbi.Protect & 0x100) == 0)
			{
				if (old.BaseAddress + old.RegionSize == mbi.BaseAddress && compress_mbis)
					old.RegionSize += mbi.RegionSize;
				else
					addresses.push_back(mbi);

				old = mbi;
			}
			current_address = mbi.BaseAddress + mbi.RegionSize;
		}

		mbis = addresses;

		return (mbis.size() > 0);
	}

	inline void scan_matrix_ex()
	{
		if (!update_memory_query())
			return;

		Matrix view_matrix{};
		Vector3 local_pos = Vector3(viewMatrix.get_location().x, viewMatrix.get_location().y, viewMatrix.get_location().z);

		for (size_t i = 0; i < mbis.size(); ++i)
		{
			MEMORY_BASIC_INFORMATION64 mbi = mbis[i];

			char* buffer = new char[mbi.RegionSize];
			SDK->read_buf(mbi.BaseAddress, buffer, mbi.RegionSize);

			for (int j = 0; j < mbi.RegionSize; j++)
			{
				memcpy(&view_matrix, &buffer[j], sizeof(Matrix));
				auto local_camera = view_matrix.GetCameraVec();

				if (local_pos.DistTo(local_camera) < 2.0f)
				{
					printf("%p %.2f %.2f %.2f | %.2f %.2f %.2f\n", mbi.BaseAddress + j, local_pos.X, local_pos.Y, local_pos.Z, local_camera.X, local_camera.Y, local_camera.Z);
				}
			}

			delete[]buffer;
		}

		printf("finished\n");
	}
}


```

`Renderer.hpp`:

```hpp
#pragma once

namespace OW {
	namespace Render {
		inline void DrawEdges(const ImVec2& top, const ImVec2& bot, const ImVec2& base, ImU32 col)
		{
			ImDrawList* Draw = ImGui::GetBackgroundDrawList();
			float scale = (bot.y - top.y) / 3.0f;
			float length = scale / 2;
			Draw->AddLine(ImVec2(base.x - scale, top.y), ImVec2(base.x - scale + length, top.y), col, 2.0f); //  --- Top left
			Draw->AddLine(ImVec2(base.x - scale, top.y), ImVec2(base.x - scale, top.y + length), col, 2.0f); // | Top left
			Draw->AddLine(ImVec2(base.x + scale / 3, top.y), ImVec2(base.x + scale / 3 + length, top.y), col, 2.0f); // --- Top right
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, top.y), ImVec2(base.x + scale / 3 + length, top.y + length), col, 2.0f); // | Top right
			Draw->AddLine(ImVec2(base.x - scale, bot.y), ImVec2(base.x - scale + length, bot.y), col, 2.0f); // --- Bottom left
			Draw->AddLine(ImVec2(base.x - scale, bot.y), ImVec2(base.x - scale, bot.y - length), col, 2.0f); // | Bottom left
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, bot.y), ImVec2(base.x + scale / 3, bot.y), col, 2.0f); // --- Bottom right
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, bot.y), ImVec2(base.x + scale / 3 + length, bot.y - length), col, 2.0f); // | Bottom right
		}
		inline void DrawBoxes(const ImVec2& top, const ImVec2& bot, const ImVec2& base, ImU32 col)
		{
			ImDrawList* Draw = ImGui::GetBackgroundDrawList();
			float scale = (bot.y - top.y) / 4.0f;
			float length = scale / 0.5;
			Draw->AddLine(ImVec2(base.x - scale, top.y), ImVec2(base.x - scale + length, top.y), col, 2.0f); //  --- Top left
			Draw->AddLine(ImVec2(base.x - scale, top.y), ImVec2(base.x - scale, top.y + length), col, 2.0f); // | Top left
			Draw->AddLine(ImVec2(base.x + scale / 3, top.y), ImVec2(base.x + scale / 3 + length, top.y), col, 2.0f); // --- Top right
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, top.y), ImVec2(base.x + scale / 3 + length, top.y + length), col, 2.0f); // | Top right
			Draw->AddLine(ImVec2(base.x - scale, bot.y), ImVec2(base.x - scale + length, bot.y), col, 2.0f); // --- Bottom left
			Draw->AddLine(ImVec2(base.x - scale, bot.y), ImVec2(base.x - scale, bot.y - length), col, 2.0f); // | Bottom left
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, bot.y), ImVec2(base.x + scale / 3, bot.y), col, 2.0f); // --- Bottom right
			Draw->AddLine(ImVec2(base.x + scale / 3 + length, bot.y), ImVec2(base.x + scale / 3 + length, bot.y - length), col, 2.0f); // | Bottom right
		}
	}
}
```

`SDK.hpp`:

```hpp
#pragma once
#include "includes.hpp"

namespace OW {
	class MemorySDK {
	private:
		std::vector<MEMORY_BASIC_INFORMATION64> mbis;
		bool CompressMbis = false;

		inline uintptr_t GetModuleBaseAddress(DWORD procId, const char* modName)
		{
			uintptr_t modBaseAddr = 0;
			HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
			if (hSnap != INVALID_HANDLE_VALUE)
			{
				MODULEENTRY32 modEntry;
				modEntry.dwSize = sizeof(modEntry);
				if (Module32First(hSnap, &modEntry))
				{
					do
					{
						if (!_stricmp(modEntry.szModule, modName))
						{
							modBaseAddr = (uintptr_t)modEntry.modBaseAddr;
							break;
						}
					} while (Module32Next(hSnap, &modEntry));
					Sleep(1);
				}
			}
			CloseHandle(hSnap);
			return modBaseAddr;
		}
	public:
		HANDLE hProcess = 0;
		uint64_t dwGameBase = 0;
	public:
		inline bool Initialize()
		{
			DWORD dwPID;
			GetWindowThreadProcessId(FindWindowA("TankWindowClass", NULL), &dwPID);

			hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, dwPID);
			dwGameBase = GetModuleBaseAddress(dwPID, "Overwatch.exe");
			return dwGameBase;
		}

		template <typename WPMType>
		__forceinline bool WPM(DWORD_PTR Address, WPMType Buffer)
		{
			return WriteProcessMemory(hProcess, LPVOID(Address), &Buffer, sizeof(Buffer), nullptr);
		}

		template <typename RPMType>
		__forceinline RPMType RPM(DWORD_PTR Address)
		{
			RPMType Buffer;
			ReadProcessMemory(hProcess, LPVOID(Address), &Buffer, sizeof(Buffer), nullptr);
			return Buffer;
		}
		__forceinline uintptr_t calc_relative(uintptr_t current, int32_t relative)
		{
			return current + RPM<int32_t>(current) + relative;
		}
		__forceinline void read_buf(const DWORD_PTR address, char* buffer, SIZE_T size) {
			ReadProcessMemory(hProcess, reinterpret_cast<LPVOID>(address), (void*)buffer, size, nullptr);
		}

		__forceinline bool UpdateMemoryQuery()
		{
			MEMORY_BASIC_INFORMATION64 mbi = { 0, };
			MEMORY_BASIC_INFORMATION64 old = { 0, };
			DWORD64 current_address = 0x7ffe0000;
			std::vector<MEMORY_BASIC_INFORMATION64> addresses;
			while (true)
			{
				//Sleep(1);
				if (!VirtualQueryEx(hProcess, (LPVOID)current_address, (PMEMORY_BASIC_INFORMATION)&mbi, sizeof(MEMORY_BASIC_INFORMATION64)))
					break;
				if ((mbi.State & 0x1000) != 0 && (mbi.Protect & 0x100) == 0)
				{
					if (old.BaseAddress + old.RegionSize == mbi.BaseAddress && CompressMbis)
						old.RegionSize += mbi.RegionSize;
					else
						addresses.push_back(mbi);

					old = mbi;
				}
				current_address = mbi.BaseAddress + mbi.RegionSize;
			}

			mbis = addresses;


			return (mbis.size() > 0);
		}

		__forceinline DWORD64 FindPattern(BYTE* buffer, BYTE* pattern, std::string mask, int bufSize)
		{
			int pattern_len = mask.length();
			for (int i = 0; i < bufSize - pattern_len; i++)
			{
				bool found = true;
				for (int j = 0; j < pattern_len; j++)
				{
					if (mask[j] != '?' && pattern[j] != buffer[(i + j)])
					{
						found = false;
						break;
					}
				}
				if (found)
					return i;
			}
			return -1;
		}

		__forceinline std::vector<DWORD64> FindPatternEx(DWORD64 start, DWORD64 end, BYTE* pattern, std::string mask, MEMORY_BASIC_INFORMATION64 mbi, DWORD64 RgSize)
		{
			DWORD64 current_chunk = start;
			std::vector<DWORD64> found;
			if ((end - current_chunk > RgSize && RgSize != 0) || (end - current_chunk < RgSize && RgSize != 0))
				return found;
			while (current_chunk < end)
			{
				Sleep(1);
				int bufSize = (int)(end - start);
				BYTE* buffer = new BYTE[bufSize];
				if (!ReadProcessMemory(hProcess, (LPVOID)current_chunk, buffer, bufSize, nullptr))
				{
					current_chunk += bufSize;
					delete[] buffer;
					continue;
				}

				DWORD64 internal_address = FindPattern(buffer, pattern, mask, bufSize);
				if (internal_address != -1)
				{
					found.push_back(current_chunk + internal_address);
				}
				current_chunk += bufSize;
				delete[] buffer;

			}
			return found;
		}

		__forceinline std::vector<DWORD64> FindPatterns(BYTE* buffer, BYTE* pattern, std::string mask, int bufSize)
		{
			std::vector<DWORD64> ret;
			int pattern_len = mask.length();
			for (int i = 0; i < bufSize - pattern_len; i++)
			{
				bool found = true;
				for (int j = 0; j < pattern_len; j++)
				{
					if (mask[j] != '?' && pattern[j] != buffer[i + j])
					{
						found = false;
						break;
					}
				}
				if (found)
					ret.push_back(i);
			}
			return ret;
		}

		__forceinline DWORD64 FindPatternExReg(BYTE* pattern, std::string mask, DWORD64 RgSize)
		{
			if (!UpdateMemoryQuery())
				return 0;

			for (int i = 0; i < mbis.size(); i++) {
				MEMORY_BASIC_INFORMATION64 info = mbis[i];

				std::vector<DWORD64> arr = FindPatternEx(info.BaseAddress, info.RegionSize + info.BaseAddress, pattern, mask, info, RgSize);
				if (arr.size() > 0)
					return arr[0];
			}

			return 0;
		}

		__forceinline std::vector<DWORD64> FindPatternExRegs(BYTE* pattern, std::string mask, DWORD64 RgSize)
		{
			std::vector<DWORD64> Result;
			if (!UpdateMemoryQuery())
				return Result;

			for (int i = 0; i < mbis.size(); i++) {
				MEMORY_BASIC_INFORMATION64 info = mbis[i];

				std::vector<DWORD64> arr = FindPatternEx(info.BaseAddress, info.RegionSize + info.BaseAddress, pattern, mask, info, RgSize);
				if (arr.size() > 0)
					Result.push_back(arr[0]);
			}

			return Result;
		}

		__forceinline std::vector<DWORD64> FindPatternsExReg(BYTE* pattern, std::string mask, DWORD64 RgSize)
		{
			std::vector<DWORD64> Result;
			DWORD64 EntityStart = FindPatternExReg(pattern, mask, RgSize);
			if (EntityStart)
			{
				for (int i = 0; i < mbis.size(); i++) {
					if (mbis[i].BaseAddress < EntityStart && EntityStart - mbis[i].BaseAddress < mbis[i].RegionSize) {
						EntityStart = mbis[i].BaseAddress;
					}
				}

				BYTE* buf = new BYTE[RgSize];
				ReadProcessMemory(hProcess, LPVOID(EntityStart), buf, RgSize, nullptr);

				std::vector<DWORD64> Pointers = FindPatterns(buf, pattern, mask, RgSize);
				delete[] buf;

				for (int i = 0; i < Pointers.size(); i++)
					Pointers[i] += EntityStart;

				Result = Pointers;
			}

			return Result;
		}

		__forceinline std::vector<DWORD64> FindPatternsExRegs(BYTE* pattern, std::string mask, DWORD64 RgSize)
		{
			std::vector<DWORD64> Result;
			std::vector<DWORD64> StartPointers = FindPatternExRegs(pattern, mask, RgSize);

			for (int i = 0; i < StartPointers.size(); i++)
			{
				for (int j = 0; j < mbis.size(); j++) {
					if (mbis[j].BaseAddress < StartPointers[i] && StartPointers[i] - mbis[j].BaseAddress < mbis[j].RegionSize) {
						StartPointers[i] = mbis[j].BaseAddress;
					}
				}

				BYTE* buf = new BYTE[RgSize];
				ReadProcessMemory(hProcess, LPVOID(StartPointers[i]), buf, RgSize, nullptr);

				std::vector<DWORD64> Pointers = FindPatterns(buf, pattern, mask, RgSize);
				delete[] buf;

				for (int j = 0; j < Pointers.size(); j++)
					Pointers[j] += StartPointers[i];

				for (int j = 0; j < Pointers.size(); j++)
				{
					Result.push_back(Pointers[j]);
				}
			}
			return Result;
		}
	};
	inline auto SDK = std::make_unique<MemorySDK>();
}
```

`TOPE.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31624.102
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "example", "example.vcxproj", "{3E584710-D844-49E5-9938-B4EFA4928B17}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Debug|x64.ActiveCfg = Debug|x64
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Debug|x64.Build.0 = Debug|x64
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Debug|x86.ActiveCfg = Debug|Win32
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Debug|x86.Build.0 = Debug|Win32
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Release|x64.ActiveCfg = Release|x64
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Release|x64.Build.0 = Release|x64
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Release|x86.ActiveCfg = Release|Win32
		{3E584710-D844-49E5-9938-B4EFA4928B17}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9EE66AFE-8CA5-4A35-9001-B4A57E4493E3}
	EndGlobalSection
EndGlobal

```

`Target.hpp`:

```hpp
#pragma once
#include "includes.hpp";
namespace OW {
	static Vector2 GetAimEnemy()
	{
		int TarGetIndex = -1;
		Vector2 target = Vector2(0, 0);
		Vector2 CrossHair = Vector2(GetSystemMetrics(SM_CXSCREEN) / 2.0f, GetSystemMetrics(SM_CYSCREEN) / 2.0f);

		float origin = FLT_MAX;

		if (TarGetIndex == -1)
		{
			if (Entity_t.size() > 0)
			{
				for (int i = 0; i < Entity_t.size(); i++)
				{
					if (Entitys[i].Live && Entitys[i].Team)
					{
						Vector2 Vec2{};
						if (Config::prediction) {
							if (!viewMatrix.WorldToScreen(Entitys[i].predict, &Vec2))
								continue;
						}
						else {
							if (!viewMatrix.WorldToScreen(Entitys[i].head, &Vec2))
								continue;
						}



						Vector2 RealVe2 = Vector2(Vec2.X - CrossHair.X, Vec2.Y - CrossHair.Y);
						float CrossDist = CrossHair.Distance(Vec2);

						if (CrossDist < origin && CrossDist < Config::Fov)
						{
							target = RealVe2;
							origin = CrossDist;
							TarGetIndex = i;
						}
						else
						{
							TarGetIndex = -1;
						}
					}
					else
					{
						TarGetIndex = -1;
					}

				}
			}
		}
		else
		{
			if (Entitys[TarGetIndex].Live && Entitys[TarGetIndex].Team)
			{
				Vector2 Vec2{};

				if (Config::prediction) {
					if (!viewMatrix.WorldToScreen(Entitys[TarGetIndex].predict, &Vec2))
						return { 0 , 0 };
				}
				else {
					if (!viewMatrix.WorldToScreen(Entitys[TarGetIndex].center, &Vec2))
						return { 0 , 0 };
				}


				Vector2 RealVe2 = Vector2(Vec2.X - CrossHair.X, Vec2.Y - CrossHair.Y);
				float CrossDist = CrossHair.Distance(Vec2);

				if (CrossDist < origin && CrossDist < Config::Fov)
				{
					target = RealVe2;
					origin = CrossDist;
				}
				else
				{
					TarGetIndex = -1;

				}
			}
			else
			{
				TarGetIndex = -1;
			}
		}

		return target;
	}
}
```

`Vector.hpp`:

```hpp
#pragma once
#include "includes.hpp"
#include "safecallez.h"
using namespace DirectX;
namespace OW {
	class Vector2 {
	public:
		float X, Y;

		Vector2() { X = 0; Y = 0; }

		Vector2(float _X, float _Y)
		{
			X = _X;
			Y = _Y;
		}

		inline float Distance(Vector2 v)
		{
			return float(sqrtf(powf(v.X - X, 2.0) + powf(v.Y - Y, 2.0)));
		}

		inline float get_length()
		{
			return float(sqrtf(powf(X, 2.0) + powf(Y, 2.0)));
		}

		inline Vector2 operator+(Vector2 v)
		{
			return { X + v.X, Y + v.Y };
		}

		inline Vector2 operator-(Vector2 v)
		{
			return { X - v.X, Y - v.Y };
		}
	};
#pragma pack(push, 1)
	struct Vector3
	{
	public:
		float X;
		float Y;
		float Z;

		inline Vector3()
			: X(0), Y(0), Z(0) {
		}

		inline Vector3(float x, float y, float z) : X(x), Y(y), Z(z) {}

		__forceinline Vector3 operator-(const Vector3& V) {
			return Vector3(X - V.X, Y - V.Y, Z - V.Z);
		}

		__forceinline Vector3 operator+(const Vector3& V) {
			return Vector3(X + V.X, Y + V.Y, Z + V.Z);
		}

		__forceinline Vector3 operator*(float Scale) const {
			return Vector3(X * Scale, Y * Scale, Z * Scale);
		}

		__forceinline Vector3 operator/(float Scale) const {
			const float RScale = 1.f / Scale;
			return Vector3(X * RScale, Y * RScale, Z * RScale);
		}

		__forceinline Vector3 operator+(float A) const {
			return Vector3(X + A, Y + A, Z + A);
		}

		__forceinline Vector3 operator-(float A) const {
			return Vector3(X - A, Y - A, Z - A);
		}

		__forceinline Vector3 operator*(const Vector3& V) const {
			return Vector3(X * V.X, Y * V.Y, Z * V.Z);
		}

		__forceinline Vector3 operator/(const Vector3& V) const {
			return Vector3(X / V.X, Y / V.Y, Z / V.Z);
		}

		__forceinline float operator|(const Vector3& V) const {
			return X * V.X + Y * V.Y + Z * V.Z;
		}

		__forceinline float operator^(const Vector3& V) const {
			return X * V.Y - Y * V.X - Z * V.Z;
		}

		__forceinline Vector3& operator+=(const Vector3& v) {
			X += v.X;
			Y += v.Y;
			Z += v.Z;
			return *this;
		}

		__forceinline Vector3& operator-=(const Vector3& v) {
			X -= v.X;
			Y -= v.Y;
			Z -= v.Z;
			return *this;
		}

		__forceinline Vector3& operator*=(const Vector3& v) {
			X *= v.X;
			Y *= v.Y;
			Z *= v.Z;
			return *this;
		}

		__forceinline Vector3& operator/=(const Vector3& v) {
			X /= v.X;
			Y /= v.Y;
			Z /= v.Z;
			return *this;
		}

		__forceinline bool operator==(const Vector3& src) const {
			return (src.X == X) && (src.Y == Y) && (src.Z == Z);
		}

		__forceinline bool operator!=(const Vector3& src) const {
			return (src.X != X) || (src.Y != Y) || (src.Z != Z);
		}

		__forceinline Vector3 Rotate(float angle)
		{
			return Vector3(X * cos(-angle) - Z * sin(-angle), Y, X * sin(-angle) + Z * cos(-angle));
		}

		__forceinline float Size() const {
			return sqrt(X * X + Y * Y + Z * Z);
		}

		__forceinline float DistTo(Vector3 targetTo) const {
			return (targetTo - *this).Size();
		}

		__forceinline Vector3 toRotator(Vector3 targetTo)
		{
			Vector3 Normalized = (targetTo - *this);
			return Normalized * (1 / Normalized.Size());
		}
	};
	class Matrix : public XMMATRIX
	{
	public:
		float m11, m12, m13, m14,
			m21, m22, m23, m24,
			m31, m32, m33, m34,
			m41, m42, m43, m44;

		XMFLOAT3 get_location()
		{
			__try
			{
				XMMATRIX invView = XMMatrixInverse(NULL, (XMMATRIX)*this);
				return XMFLOAT3(XMVectorGetX(invView.r[3]) / XMVectorGetW(invView.r[3]), XMVectorGetY(invView.r[3]) / XMVectorGetW(invView.r[3]), XMVectorGetZ(invView.r[3]) / XMVectorGetW(invView.r[3]));
			}
			__except (EXCEPTION_EXECUTE_HANDLER) {}
			return XMFLOAT3(0, 0, 0);
		}

		XMFLOAT3 get_rotation()
		{
			__try {
				return XMFLOAT3(XMVectorGetZ(r[0]), XMVectorGetZ(r[1]), XMVectorGetZ(r[2]));
			}
			__except (EXCEPTION_EXECUTE_HANDLER) {}
			return XMFLOAT3(0, 0, 0);
		}

		Vector3 GetCameraVec()
		{
			float	A = m22 * m33 - m32 * m23,
				B = m32 * m13 - m12 * m33,
				C = m12 * m23 - m22 * m13,
				Z = m11 * A + m21 * B + m31 * C;

			if (abs(Z) < 0.0001) return Vector3();

			float	D = m31 * m23 - m21 * m33,
				E = m11 * m33 - m31 * m13,
				F = m21 * m13 - m11 * m23,
				G = m21 * m32 - m31 * m22,
				H = m31 * m12 - m11 * m32,
				K = m11 * m22 - m21 * m12;

			return Vector3(-(A * m41 + D * m42 + G * m43) / Z, -(B * m41 + E * m42 + H * m43) / Z, -(C * m41 + F * m42 + K * m43) / Z);
		}

		bool WorldToScreen(Vector3 worldPos, Vector2* OutPos, bool ignoreret = false)
		{
			float screenX = (r[0].m128_f32[0] * worldPos.X) + (r[1].m128_f32[0] * worldPos.Y) + (r[2].m128_f32[0] * worldPos.Z) + r[3].m128_f32[0];
			float screenY = (r[0].m128_f32[1] * worldPos.X) + (r[1].m128_f32[1] * worldPos.Y) + (r[2].m128_f32[1] * worldPos.Z) + r[3].m128_f32[1];
			float screenW = (r[0].m128_f32[3] * worldPos.X) + (r[1].m128_f32[3] * worldPos.Y) + (r[2].m128_f32[3] * worldPos.Z) + r[3].m128_f32[3];

			float camX = GetSystemMetrics(SM_CXSCREEN) / 2.0f;
			float camY = GetSystemMetrics(SM_CYSCREEN) / 2.0f;

			float x = camX + (camX * screenX / screenW);
			float y = camY - (camY * screenY / screenW);

			if (x < 0 || y < 0 || x >= GetSystemMetrics(SM_CXSCREEN) || y >= GetSystemMetrics(SM_CYSCREEN)) { return false; }

			*OutPos = { x, y };

			return (screenW > 0.001f) || ignoreret;
		}

		Vector2 WorldToScreen(Vector3 worldPos)
		{
			float screenX = (r[0].m128_f32[0] * worldPos.X) + (r[1].m128_f32[0] * worldPos.Y) + (r[2].m128_f32[0] * worldPos.Z) + r[3].m128_f32[0];
			float screenY = (r[0].m128_f32[1] * worldPos.X) + (r[1].m128_f32[1] * worldPos.Y) + (r[2].m128_f32[1] * worldPos.Z) + r[3].m128_f32[1];
			float screenW = (r[0].m128_f32[3] * worldPos.X) + (r[1].m128_f32[3] * worldPos.Y) + (r[2].m128_f32[3] * worldPos.Z) + r[3].m128_f32[3];

			float camX = GetSystemMetrics(SM_CXSCREEN) / 2.0f;
			float camY = GetSystemMetrics(SM_CYSCREEN) / 2.0f;

			float x = camX + (camX * screenX / screenW);
			float y = camY - (camY * screenY / screenW);

			if (x < 0 || y < 0 || x >= GetSystemMetrics(SM_CXSCREEN) || y >= GetSystemMetrics(SM_CYSCREEN)) { return Vector2{}; }

			return { x ,y };
		}
	};
}
```

`example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3e584710-d844-49e5-9938-b4efa4928b17}</ProjectGuid>
    <RootNamespace>example</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>tope</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>.\;$(IncludePath)</IncludePath>
    <LibraryPath>.\;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>.\;$(IncludePath)</IncludePath>
    <LibraryPath>.\;$(LibraryPath)</LibraryPath>
    <TargetName>production</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>CURL_STATICLIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>libcurl.lib;library_x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>HighestAvailable</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="imgai\imgui.cpp" />
    <ClCompile Include="imgai\imgui_demo.cpp" />
    <ClCompile Include="imgai\imgui_draw.cpp" />
    <ClCompile Include="imgai\imgui_impl_dx11.cpp" />
    <ClCompile Include="imgai\imgui_impl_win32.cpp" />
    <ClCompile Include="imgai\imgui_tables.cpp" />
    <ClCompile Include="imgai\imgui_widgets.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Config.hpp" />
    <ClInclude Include="imgai\imconfig.h" />
    <ClInclude Include="imgai\imgui.h" />
    <ClInclude Include="imgai\imgui_impl_dx11.h" />
    <ClInclude Include="imgai\imgui_impl_win32.h" />
    <ClInclude Include="imgai\imgui_internal.h" />
    <ClInclude Include="imgai\imstb_rectpack.h" />
    <ClInclude Include="imgai\imstb_textedit.h" />
    <ClInclude Include="imgai\imstb_truetype.h" />
    <ClInclude Include="includes.hpp" />
    <ClInclude Include="offsets.hpp" />
    <ClInclude Include="Overwatch.hpp" />
    <ClInclude Include="Renderer.hpp" />
    <ClInclude Include="safecallez.h" />
    <ClInclude Include="SDK.hpp" />
    <ClInclude Include="skStr.h" />
    <ClInclude Include="Target.hpp" />
    <ClInclude Include="Vector.hpp" />
    <ClInclude Include="xor.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`example.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Source Files\chese">
      <UniqueIdentifier>{69ad27ec-c902-484c-b1a5-a415357146b8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\gui">
      <UniqueIdentifier>{ab0ee07b-4ed4-482c-b2a8-d11ecb05788b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\protects">
      <UniqueIdentifier>{4f688cee-221a-4079-b846-5ad3d5687f51}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\Protection">
      <UniqueIdentifier>{587eab74-13d3-4764-9f32-49b7924744df}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="imgai\imgui.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_demo.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_draw.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_impl_dx11.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_impl_win32.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_tables.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="imgai\imgui_widgets.cpp">
      <Filter>Source Files\gui</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="skStr.h">
      <Filter>Header Files\Protection</Filter>
    </ClInclude>
    <ClInclude Include="Config.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="Overwatch.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="SDK.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="Target.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="Vector.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imconfig.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imgui.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imgui_impl_dx11.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imgui_impl_win32.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imgui_internal.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imstb_rectpack.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imstb_textedit.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="imgai\imstb_truetype.h">
      <Filter>Source Files\gui</Filter>
    </ClInclude>
    <ClInclude Include="xor.hpp">
      <Filter>Source Files\protects</Filter>
    </ClInclude>
    <ClInclude Include="Renderer.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="includes.hpp">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="safecallez.h">
      <Filter>Source Files\chese</Filter>
    </ClInclude>
    <ClInclude Include="offsets.hpp" />
  </ItemGroup>
</Project>
```

`example.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`imgui.ini`:

```ini
[Window][Debug##Default]
Pos=60,60
Size=400,400
Collapsed=0

[Window][Aim]
Pos=60,60
Size=389,563
Collapsed=0

[Window][Visuals]
Pos=568,73
Size=249,269
Collapsed=0

[Window][Misc]
Pos=864,40
Size=305,481
Collapsed=0


```

`includes.hpp`:

```hpp
#pragma once
#define DEG2RAD(x) x * M_PI / 180.0
#define M_PI       3.14159265358979323846
#define DIRECTINPUT_VERSION 0x0800

/* WinApi C++ 17 */
#include <Windows.h>
#include <iostream>
#include <filesystem>
#include <fstream>
#include <string>
#include <direct.h>
#include <TlHelp32.h>
#include <vector>
#include <process.h>
#include <thread>
#include <bitset>
#include <mutex>
#include <array>
#include <dwmapi.h>


/* D3D SDK */
#include <d3d11.h>
#include <DirectXMath.h>
#include <d3d9types.h>

/* Overlay & Imgui */
#include "imgai/imgui.h"
#include "imgai/imgui_impl_dx11.h"
#include "imgai/imgui_impl_win32.h"
#include "imgai/imgui_internal.h"
#include "SDK.hpp"

/* String Encrypted */
//#include "Xor.hpp"

/* Offset & Address */
#include "Offsets.hpp"

/* Config */
#include "Config.hpp"

/* Render */
#include "Renderer.hpp"
#include "Vector.hpp"

/* Lib */
#pragma comment(lib, "winmm.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "dwmapi.lib")

#pragma warning(disable : 4996)
bool windows11yes = false;
namespace fs = std::filesystem;
using namespace DirectX;

typedef int (FAR WINAPI* pDD_btn)(int btn);
typedef int (FAR WINAPI* pDD_key)(int keycode, int flag);
typedef int (FAR WINAPI* pDD_movR)(int dx, int dy);

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
struct CurrentProcess {
	DWORD ID;
	HANDLE Handle;
	HWND Hwnd;
	WNDPROC WndProc;
	int WindowWidth;
	int WindowHeight;
	int WindowLeft;
	int WindowRight;
	int WindowTop;
	int WindowBottom;
	LPCSTR Title;
	LPCSTR ClassName;
	LPCSTR Path;
}Process;
class Rect {
public:
	float x;
	float y;
	float width;
	float height;

	Rect() {
		this->x = 0;
		this->y = 0;
		this->width = 0;
		this->height = 0;
	}

	Rect(float x, float y, float width, float height) {
		this->x = x;
		this->y = y;
		this->width = width;
		this->height = height;
	}

	bool operator==(const Rect& src) const {
		return (src.x == this->x && src.y == this->y && src.height == this->height && src.width == this->width);
	}

	bool operator!=(const Rect& src) const {
		return (src.x != this->x && src.y != this->y && src.height != this->height && src.width != this->width);
	}
};
bool IsCorrectTargetArchitecture(HANDLE hProc) {
	BOOL bTarget = FALSE;
	if (!IsWow64Process(hProc, &bTarget)) {
		printf("Can't confirm target process architecture: 0x%X\n", GetLastError());
		return false;
	}

	BOOL bHost = FALSE;
	IsWow64Process(GetCurrentProcess(), &bHost);

	return (bTarget == bHost);
}
namespace OW {
	struct Entity
	{

		Vector3 Loc;
		Vector3 foot;
		float health;
		Vector3 savedVelocity;
		Vector3 Velocity;
		clock_t lastVelocityUpdate;
		Vector3 lastPos;
		Vector3 predict;
		Vector3 head;
		Vector3 base;
		Vector3 headbase;
		Vector3 center;
		Vector3 head2;
		bool Live;

		bool Team;
	};

	inline UINT g_Width{}, g_Height{};
	inline std::vector<uint64_t> Entity_t{};
	inline Entity Entitys[20] = {};
	inline Matrix viewMatrix{};
	inline uint64_t viewMatrixPtr{};

	// Data
	static ID3D11Device* g_pd3dDevice = NULL;
	static ID3D11DeviceContext* g_pd3dDeviceContext = NULL;
	static IDXGISwapChain* g_pSwapChain = NULL;
	static ID3D11RenderTargetView* g_mainRenderTargetView = NULL;

	inline void CleanupRenderTarget()
	{
		if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = NULL; }
	}

	inline void CleanupDeviceD3D()
	{
		CleanupRenderTarget();
		if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = NULL; }
		if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
		if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
	}

	inline void CreateRenderTarget()
	{
		ID3D11Texture2D* pBackBuffer;
		g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
		g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView);
		pBackBuffer->Release();
	}

	inline bool CreateDeviceD3D(HWND hWnd)
	{
		// Setup swap chain
		DXGI_SWAP_CHAIN_DESC sd;
		ZeroMemory(&sd, sizeof(sd));
		sd.BufferCount = 2;
		sd.BufferDesc.Width = 0;
		sd.BufferDesc.Height = 0;
		sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		sd.BufferDesc.RefreshRate.Numerator = 60;
		sd.BufferDesc.RefreshRate.Denominator = 1;
		sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
		sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
		sd.OutputWindow = hWnd;
		sd.SampleDesc.Count = 1;
		sd.SampleDesc.Quality = 0;
		sd.Windowed = TRUE;
		sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

		UINT createDeviceFlags = 0;
		//createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
		D3D_FEATURE_LEVEL featureLevel;
		const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
		if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext) != S_OK)
			return false;

		CreateRenderTarget();
		return true;
	}

	// Win32 message handler
	inline LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
		if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
			return true;

		switch (msg)
		{
		case WM_SIZE:
			if (g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED)
			{
				CleanupRenderTarget();
				g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
				CreateRenderTarget();
			}
			return 0;
		case WM_SYSCOMMAND:
			if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
				return 0;
			break;
		case WM_DESTROY:
			::PostQuitMessage(0);
			return 0;
		}
		return ::DefWindowProc(hWnd, msg, wParam, lParam);
	}
}
```

`main.cpp`:

```cpp
#include <Windows.h>
#include <string>
#include "skStr.h"
#include "includes.hpp"
#include "Overwatch.hpp"
#include "SDK.hpp"
#include <iostream>
#include <Windows.h>
#include <string>
#include <TlHelp32.h>
#include <io.h>
#include <vector>
#include <filesystem>
#include <fstream>
#include <regex>


DWORD GetProcessId(const char* cProcessName)
{
	DWORD dwProcessId = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	if (hSnap && hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 procEntry;
		procEntry.dwSize = sizeof(procEntry);

		if (Process32First(hSnap, &procEntry))
		{
			do
			{
				if (!_stricmp(procEntry.szExeFile, cProcessName))
				{
					dwProcessId = procEntry.th32ProcessID;
					break;
				}
			} while (Process32Next(hSnap, &procEntry));
		}
		CloseHandle(hSnap);
	}
	return dwProcessId;
}
std::string GetExeFileName()
{
	char buffer[MAX_PATH];
	GetModuleFileName(NULL, buffer, MAX_PATH);
	return std::string(buffer);
}

std::string GetExePath()
{
	std::string f = GetExeFileName();
	return f.substr(0, f.find_last_of("\\/"));
}
#include <Windows.h>

using namespace OW;
DWORD base_address;
#include <ShlObj.h>
#include <cstdlib>
DWORD checker;
HWND hwnd;
int main()
{
	system("cls");

	std::cout << skCrypt("\n Waiting for Overwatch 2...\n\n");
	while (hwnd == NULL)
	{
		hwnd = SpoofFindWindowA("TankWindowClass", 0);
		Sleep(100);
	}
	HWND tWn1d = SpoofFindWindowA("TankWindowClass", 0);
	RECT rect;
	DWORD pidow2 = GetProcessId("Overwatch.exe");
	std::cout << skCrypt(" PID: ");
	std::cout << pidow2;
	
	if (MessageBoxA(NULL, "Would you like to hook External cheat?", "External Hook", MB_YESNO) == IDYES)
	{
		if (MessageBoxA(NULL, "Would you like to create a new window instead of hijacking Medal.tv?\nHijacking Medal.tv doesn't work on Windows 11\nIf you don't use medal the cheat may die mid game", "Create New Window Instead Of Medal", MB_YESNO) == IDYES)
		{
			windows11yes = true;
		}
		//Sleep(4000);
		//ShowWindow(::GetConsoleWindow(), SW_HIDE);
		if (!SDK->Initialize())
			//MessageBox(NULL, "Error 21", "ERROR", MB_OK | MB_ICONERROR);
			exit(0);
		_beginthread((_beginthread_proc_type)prediction_thread, 0, 0);
		_beginthread((_beginthread_proc_type)entity_thread, 0, 0);
		_beginthread((_beginthread_proc_type)aimbot_thread, 0, 0);
		_beginthread((_beginthread_proc_type)overlay_thread, 0, 0);
		_beginthread((_beginthread_proc_type)velocity_thread, 0, 0);

		while (SpoofFindWindowA("TankWindowClass", NULL))
		{
			BYTE AOB[] = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF\x02\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00";
			std::string MASK = "??xx??xx?xxx?xxxxxxxxxxxxxxx???";
			Entity_t = SDK->FindPatternsExRegs(AOB, MASK, 0x180000);
			uint64_t viewMatrixVal = SDK->RPM<uint64_t>(SDK->dwGameBase + offset::ViewMatrix);
			viewMatrixVal = SDK->RPM<uint64_t>(viewMatrixVal + 0x5A0);
			viewMatrixVal = SDK->RPM<uint64_t>(viewMatrixVal + 0x118);
			auto view = SDK->RPM<uint64_t>(SDK->dwGameBase + offset::ViewMatrix) + offset::ViewMatrix_PTR;
			viewMatrixPtr = view;
			viewMatrix = SDK->RPM<Matrix>(viewMatrixPtr);
			if (GetKeyRandomized(Config::menukey)) {
				Config::Menu = !Config::Menu;
				Sleep(250);
			}
			if (GetKeyRandomized(Config::closekey)) {
				exit(0);
			}
		}
	}
	exit(2);
}
```

`offsets.hpp`:

```hpp
#pragma once
namespace OW {
	namespace offset {
		constexpr auto ViewMatrix = 0x0;
		constexpr auto ViewMatrix_PTR = 0x7E0;
	}
}
```

`safecallez.h`:

```h
/*
 SpoofCall Made by AC and remade by proxy :abdul:

*/
#include <iostream>
#include <windows.h>
#include <random>
#include <dwmapi.h>

typedef SHORT(*GetAsyncKeyState_t)(int);

typedef INT(*GetSystemMetrics_t)(int);
typedef BOOL(*SetLayeredWindowAttributes_t)(HWND, COLORREF, BYTE, DWORD);
typedef BOOL(*ShowWindow_t)(HWND, int);
typedef HRESULT(*DwmExtendFrameIntoClientArea_t)(HWND, const MARGINS*); //ignore
typedef BOOL(*UpdateWindow_t)(HWND);
typedef HGDIOBJ(*GetStockObject_t)(int);
typedef HANDLE(*CreateThread_t)(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD);
typedef BOOL(*SetWindowPos_t)(HWND, HWND, int, int, int, int, UINT);
typedef LONG(*SetWindowLong_t)(HWND, int, LONG);
typedef HWND(*FindWindow_t)(LPCTSTR, LPCTSTR);
typedef HWND(*FindWindowA_t)(LPCSTR, LPCSTR);
typedef HWND(*CreateWindowA_t)(LPCSTR, LPCTSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);
typedef BOOL(*mouse_event_t)(DWORD, DWORD, DWORD, DWORD, ULONG_PTR);
typedef VOID(*keybd_event_t)(BYTE, BYTE, DWORD, ULONG_PTR);

VOID SpoofedKeybdEvent(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
{
    static keybd_event_t origkeybd_event = (keybd_event_t)GetProcAddress(GetModuleHandleA("user32.dll"), "keybd_event");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (bVk == VK_RETURN)
    {
        if (random_number == 0)
            std::cout << "keybd_event\n";
    }

    return origkeybd_event(bVk, bScan, dwFlags, dwExtraInfo);
}
INT SpoofGetSystemMetrics(int nIndex)
{
    static GetSystemMetrics_t origGetSystemMetrics = (GetSystemMetrics_t)GetProcAddress(GetModuleHandleA("user32.dll"), "GetSystemMetrics");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (nIndex == SM_CXSCREEN)
    {
        if (random_number == 0)
            std::cout << "GetSystemMetrics\n";
    }

    return origGetSystemMetrics(nIndex);
}

BOOL SpoofSetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
{
    static SetLayeredWindowAttributes_t origSetLayeredWindowAttributes = (SetLayeredWindowAttributes_t)GetProcAddress(GetModuleHandleA("user32.dll"), "SetLayeredWindowAttributes");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (bAlpha == 255)
    {
        if (random_number == 0)
            std::cout << "SetLayeredWindowAttributes\n";
    }

    return origSetLayeredWindowAttributes(hwnd, crKey, bAlpha, dwFlags);
}

BOOL SpoofShowWindow(HWND hWnd, int nCmdShow)
{
    static ShowWindow_t origShowWindow = (ShowWindow_t)GetProcAddress(GetModuleHandleA("user32.dll"), "ShowWindow");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (nCmdShow == SW_SHOW)
    {
        if (random_number == 0)
            std::cout << "ShowWindow\n";
    }

    return origShowWindow(hWnd, nCmdShow);
}

HRESULT SpoofDwmExtendFrameIntoClientArea(HWND hWnd, const MARGINS* pMarInset)
{
    static DwmExtendFrameIntoClientArea_t origDwmExtendFrameIntoClientArea = (DwmExtendFrameIntoClientArea_t)GetProcAddress(GetModuleHandleA("user32.dll"), "DwmExtendFrameIntoClientArea");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (pMarInset->cxLeftWidth == 0)
    {
        if (random_number == 0)
            std::cout << "DwmExtendFrameIntoClientArea\n";
    }

    return origDwmExtendFrameIntoClientArea(hWnd, pMarInset);
}

BOOL SpoofUpdateWindow(HWND hWnd)
{
    static UpdateWindow_t origUpdateWindow = (UpdateWindow_t)GetProcAddress(GetModuleHandleA("user32.dll"), "UpdateWindow");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (IsWindowVisible(hWnd))
    {
        if (random_number == 0)
            std::cout << "UpdateWindow\n";
    }

    return origUpdateWindow(hWnd);
}

HGDIOBJ SpoofGetStockObject(int nIndex)
{
    static GetStockObject_t origGetStockObject = (GetStockObject_t)GetProcAddress(GetModuleHandleA("gdi32.dll"), "GetStockObject");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (nIndex == BLACK_BRUSH)
    {
        if (random_number == 0)
            std::cout << "GetStockObject\n";
    }

    return origGetStockObject(nIndex);
}

HANDLE SpoofCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
    static CreateThread_t origCreateThread = (CreateThread_t)GetProcAddress(GetModuleHandleA("kernel32.dll"), "CreateThread");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (dwCreationFlags == 0)
    {
        if (random_number == 0)
            std::cout << "CreateThread\n";
    }

    return origCreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
}

BOOL SpoofSetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
{
    static SetWindowPos_t origSetWindowPos = (SetWindowPos_t)GetProcAddress(GetModuleHandleA("user32.dll"), "SetWindowPos");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (uFlags == 0)
    {
        if (random_number == 0)
            std::cout << "SetWindowPos\n";
    }

    return origSetWindowPos(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
}

LONG SpoofSetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
    static SetWindowLong_t origSetWindowLong = (SetWindowLong_t)GetProcAddress(GetModuleHandleA("user32.dll"), "SetWindowLong");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (nIndex == GWL_STYLE)
    {
        if (random_number == 0)
            std::cout << "SetWindowLong\n";
    }

    return origSetWindowLong(hWnd, nIndex, dwNewLong);
}

HWND SpoofFindWindow(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    static FindWindow_t origFindWindow = (FindWindow_t)GetProcAddress(GetModuleHandleA("user32.dll"), "FindWindow");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (lpClassName == NULL)
    {
        if (random_number == 0)
            std::cout << "FindWindow\n";
    }

    return origFindWindow(lpClassName, lpWindowName);
}

HWND SpoofFindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
{
    static FindWindowA_t origFindWindowA = (FindWindow_t)GetProcAddress(GetModuleHandleA("user32.dll"), "FindWindowA");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (lpClassName == NULL)
    {
        if (random_number == 0)
            std::cout << "FindWindowA\n";
    }

    return origFindWindowA(lpClassName, lpWindowName);
}

HWND SpoofCreateWindowA(LPCSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
{
    static CreateWindowA_t origCreateWindowA = (CreateWindowA_t)GetProcAddress(GetModuleHandleA("user32.dll"), "CreateWindowA");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (dwStyle == WS_VISIBLE)
    {
        if (random_number == 0)
            std::cout << "CreateWindowA\n";
    }

    return origCreateWindowA(lpClassName, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

BOOL SpoofedMouseEvent(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
{
    static mouse_event_t origmouse_event = (mouse_event_t)GetProcAddress(GetModuleHandleA("user32.dll"), "mouse_event");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (dwFlags == MOUSEEVENTF_LEFTDOWN)
    {
        if (random_number == 0)
            std::cout << "mouse_event\n";
    }

    return origmouse_event(dwFlags, dx, dy, dwData, dwExtraInfo);
}

SHORT GetKeyRandomized(int vKey)
{
    static GetAsyncKeyState_t origGetAsyncKeyState = (GetAsyncKeyState_t)GetProcAddress(GetModuleHandleA("user32.dll"), "GetAsyncKeyState");

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 1);
    int random_number = dis(gen);

    if (vKey == VK_SHIFT)
    {
        if (random_number == 0)
            std::cout << "GetAsyncKeyState\n";
    }

    return origGetAsyncKeyState(vKey);
}


```

`skStr.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`xor.hpp`:

```hpp
#pragma once
#include <string>
#include <utility>

namespace
{
	constexpr int const_atoi(char c)
	{
		return c - '0';
	}
}

#ifdef _MSC_VER
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

template<typename _string_type, size_t _length>
class _Basic_XorStr
{
	using value_type = typename _string_type::value_type;
	static constexpr auto _length_minus_one = _length - 1;

public:
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length])
		: _Basic_XorStr(str, std::make_index_sequence<_length_minus_one>())
	{

	}

	inline auto c_str() const
	{
		decrypt();

		return data;
	}

	inline auto str() const
	{
		decrypt();

		return _string_type(data, data + _length_minus_one);
	}

	inline operator _string_type() const
	{
		return str();
	}

private:
	template<size_t... indices>
	constexpr ALWAYS_INLINE _Basic_XorStr(value_type const (&str)[_length], std::index_sequence<indices...>)
		: data{ crypt(str[indices], indices)..., '\0' },
		encrypted(true)
	{

	}

	static constexpr auto XOR_KEY = static_cast<value_type>(
		const_atoi(__TIME__[7]) +
		const_atoi(__TIME__[6]) * 10 +
		const_atoi(__TIME__[4]) * 60 +
		const_atoi(__TIME__[3]) * 600 +
		const_atoi(__TIME__[1]) * 3600 +
		const_atoi(__TIME__[0]) * 36000
		);

	static ALWAYS_INLINE constexpr auto crypt(value_type c, size_t i)
	{
		return static_cast<value_type>(c ^ (XOR_KEY + i));
	}

	inline void decrypt() const
	{
		if (encrypted)
		{
			for (size_t t = 0; t < _length_minus_one; t++)
			{
				data[t] = crypt(data[t], t);
			}
			encrypted = false;
		}
	}

	mutable value_type data[_length];
	mutable bool encrypted;
};
//---------------------------------------------------------------------------
template<size_t _length>
using XorStrA = _Basic_XorStr<std::string, _length>;
template<size_t _length>
using XorStrW = _Basic_XorStr<std::wstring, _length>;
template<size_t _length>
using XorStrU16 = _Basic_XorStr<std::u16string, _length>;
template<size_t _length>
using XorStrU32 = _Basic_XorStr<std::u32string, _length>;
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator==(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	static_assert(_length == _length2, "XorStr== different length");

	return _length == _length2 && lhs.str() == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator==(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs.size() == _length && lhs == rhs.str();
}
//---------------------------------------------------------------------------
template<typename _stream_type, typename _string_type, size_t _length>
inline auto& operator<<(_stream_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	lhs << rhs.c_str();

	return lhs;
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length, size_t _length2>
inline auto operator+(const _Basic_XorStr<_string_type, _length>& lhs, const _Basic_XorStr<_string_type, _length2>& rhs)
{
	return lhs.str() + rhs.str();
}
//---------------------------------------------------------------------------
template<typename _string_type, size_t _length>
inline auto operator+(const _string_type& lhs, const _Basic_XorStr<_string_type, _length>& rhs)
{
	return lhs + rhs.str();
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char const (&str)[_length])
{
	return XorStrA<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(wchar_t const (&str)[_length])
{
	return XorStrW<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char16_t const (&str)[_length])
{
	return XorStrU16<_length>(str);
}
//---------------------------------------------------------------------------
template<size_t _length>
constexpr ALWAYS_INLINE auto _xor_(char32_t const (&str)[_length])
{
	return XorStrU32<_length>(str);
}
//---------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////
template <int X> struct EnsureCompileTime {
    enum : int {
        Value = X
    };
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//Use Compile-Time as seed
#define Seed ((__TIME__[7] - '0') * 1  + (__TIME__[6] - '0') * 10  + \
              (__TIME__[4] - '0') * 60   + (__TIME__[3] - '0') * 600 + \
              (__TIME__[1] - '0') * 3600 + (__TIME__[0] - '0') * 36000)
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
constexpr int LinearCongruentGenerator(int Rounds) {
    return 1013904223 + 1664525 * ((Rounds > 0) ? LinearCongruentGenerator(Rounds - 1) : Seed & 0xFFFFFFFF);
}
#define Random() EnsureCompileTime<LinearCongruentGenerator(10)>::Value //10 Rounds
#define RandomNumber(Min, Max) (Min + (Random() % (Max - Min + 1)))
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <int... Pack> struct IndexList {};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <typename IndexList, int Right> struct Append;
template <int... Left, int Right> struct Append<IndexList<Left...>, Right> {
    typedef IndexList<Left..., Right> Result;
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
template <int N> struct ConstructIndexList {
    typedef typename Append<typename ConstructIndexList<N - 1>::Result, N - 1>::Result Result;
};
template <> struct ConstructIndexList<0> {
    typedef IndexList<> Result;
};
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
const char XORKEY = static_cast<char>(RandomNumber(0, 0xFF));

constexpr char EncryptCharacter(const char Character, int Index) {
    return Character ^ (XORKEY + Index);
}

template <typename IndexList> class CXorString;
template <int... Index> class CXorString<IndexList<Index...> > {
private:
    char Value[sizeof...(Index) + 1];
public:
    constexpr CXorString(const char* const String)
        : Value{ EncryptCharacter(String[Index], Index)... } {}

    char* decrypt() {
        for (int t = 0; t < sizeof...(Index); t++) {
            Value[t] = Value[t] ^ (XORKEY + t);
        }
        Value[sizeof...(Index)] = '\0';
        return Value;
    }

    char* get() {
        return Value;
    }
};
#define XorS(X, String) CXorString<ConstructIndexList<sizeof(String)-1>::Result> X(String)
```