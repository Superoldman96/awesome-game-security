Project Path: arc_gmh5225_CiDllDemo_3oy2zqed

Source Tree:

```txt
arc_gmh5225_CiDllDemo_3oy2zqed
├── CiDemoDriver
│   ├── CiDemoDriver
│   │   ├── CiDemoDriver.inf
│   │   ├── CiDemoDriver.vcxproj
│   │   ├── CiDemoDriver.vcxproj.filters
│   │   ├── CiDemoDriver.vcxproj.user
│   │   └── ImportLibs
│   │       ├── x64
│   │       │   └── ci.lib
│   │       └── x86
│   │           └── ci.lib
│   ├── CiDemoDriver.sln
│   ├── RAIIUtils.h
│   ├── SignatureCheck.cpp
│   ├── SignatureCheck.h
│   ├── ci.h
│   └── main.cpp
├── ExecutablesForTesting
│   └── notepad++.exe
├── GeneratingLibFiles
│   ├── CiStubs.cpp
│   ├── README.md
│   ├── ci.def
│   └── main.cpp
├── LICENSE.txt
└── README.md

```

`CiDemoDriver/CiDemoDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29215.179
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CiDemoDriver", "CiDemoDriver\CiDemoDriver.vcxproj", "{D5187004-259E-4B49-86B6-20488447F3B2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM.ActiveCfg = Debug|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM.Build.0 = Debug|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM.Deploy.0 = Debug|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM64.Build.0 = Debug|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x64.ActiveCfg = Debug|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x64.Build.0 = Debug|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x64.Deploy.0 = Debug|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x86.ActiveCfg = Debug|Win32
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x86.Build.0 = Debug|Win32
		{D5187004-259E-4B49-86B6-20488447F3B2}.Debug|x86.Deploy.0 = Debug|Win32
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM.ActiveCfg = Release|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM.Build.0 = Release|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM.Deploy.0 = Release|ARM
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM64.ActiveCfg = Release|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM64.Build.0 = Release|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|ARM64.Deploy.0 = Release|ARM64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x64.ActiveCfg = Release|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x64.Build.0 = Release|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x64.Deploy.0 = Release|x64
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x86.ActiveCfg = Release|Win32
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x86.Build.0 = Release|Win32
		{D5187004-259E-4B49-86B6-20488447F3B2}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A45D8F27-7DDF-4BE8-93F8-85AB8EE80C61}
	EndGlobalSection
EndGlobal

```

`CiDemoDriver/CiDemoDriver/CiDemoDriver.inf`:

```inf
;
; CiDemoDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
Provider=%ManufacturerName%
DriverVer=
CatalogFile=CiDemoDriver.cat

[DestinationDirs]
DefaultDestDir				= %DIRID_DRIVERS%
CiDemoDriver.DriverFiles	= %DIRID_DRIVERS%            ;%windir%\system32\drivers

[DefaultInstall]
OptionDesc          = %ServiceDescription%
CopyFiles           = CiDemoDriver.DriverFiles

[DefaultInstall.Services]
AddService          = %ServiceName%,,CiDemoDriver.Service

;;
;; Default uninstall sections
;;

[DefaultUninstall]
DelFiles            = CiDemoDriver.DriverFiles

[DefaultUninstall.Services]
DelService			= %ServiceName%,0x200      ;Ensure service is stopped before deleting

;
; Services Section
;

[CiDemoDriver.Service]
DisplayName      = %ServiceName%
Description      = %ServiceDescription%
ServiceBinary    = %12%\%DriverName%.sys        ;%windir%\system32\drivers\
ServiceType      = %SERVICE_KERNEL_DRIVER%
StartType        = %SERVICE_DEMAND_START%
ErrorControl     = %SERVICE_ERROR_NORMAL%

;
; Copy Files
;

[CiDemoDriver.DriverFiles]
CiDemoDriver.sys

[CiDemoDriver.UserFiles]
; No user files

[SourceDisksFiles]
CiDemoDriver.sys = 1,,

[SourceDisksNames]
1 = %DiskName%,,,""

[Standard.NT$ARCH$]

[Strings]
DIRID_DRIVERS = 12
SERVICE_FILE_SYSTEM_DRIVER = 2
SERVICE_DEMAND_START = 3
SERVICE_ERROR_NORMAL = 1
SERVICE_KERNEL_DRIVER = 1
ServiceDescription      = "CiDemoDriver"
ServiceName             = "CiDemoDriver"
DriverName              = "CiDemoDriver"
ManufacturerName="Ido Moshe"
ClassName=""
DiskName="CiDemoDriver Source Disk"

```

`CiDemoDriver/CiDemoDriver/CiDemoDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D5187004-259E-4B49-86B6-20488447F3B2}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>CiDemoDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <Inf2CatUseLocalTime>true</Inf2CatUseLocalTime>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Link>
      <AdditionalOptions> /integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ImportLibs\x86\ci.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalOptions> /integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ImportLibs\x64\ci.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalOptions> /integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ImportLibs\x64\ci.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Link>
      <AdditionalOptions> /integritycheck %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>ImportLibs\x86\ci.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="CiDemoDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\ci.h" />
    <ClInclude Include="..\RAIIUtils.h" />
    <ClInclude Include="..\SignatureCheck.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\main.cpp" />
    <ClCompile Include="..\SignatureCheck.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CiDemoDriver/CiDemoDriver/CiDemoDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="CiDemoDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\ci.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\RAIIUtils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\SignatureCheck.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\SignatureCheck.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`CiDemoDriver/CiDemoDriver/CiDemoDriver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`CiDemoDriver/RAIIUtils.h`:

```h
#pragma once

#include <ntddk.h>
#include <wdm.h>
#include "ci.h"


/**
 *  create a file handle for read.
 *  release handle when exiting the current context.
 */
class FileReadHandleGuard
{
public:
    FileReadHandleGuard(PCUNICODE_STRING imageFileName): _handle(nullptr), _isValid(false)
    {
        IO_STATUS_BLOCK ioStatusBlock = { 0 };
        OBJECT_ATTRIBUTES  objAttr = { 0 };
        InitializeObjectAttributes(
            &objAttr,
            const_cast<PUNICODE_STRING>(imageFileName),
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            nullptr,
            nullptr);

        const NTSTATUS openFileRet = ZwOpenFile(
            &_handle,
            SYNCHRONIZE | FILE_READ_DATA, // ACCESS_MASK, we use SYNCHRONIZE because we might need to wait on the handle in order to wait for the file to be read
            &objAttr,
            &ioStatusBlock,
            FILE_SHARE_READ,
            FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT // FILE_SYNCHRONOUS_IO_NONALERT so that zwReadfile will pend for us until reading is done
        );

        if (!NT_SUCCESS(openFileRet))
        {
            KdPrint(("failed to open file - openFileRet = %d\n", openFileRet));
            return;
        }

        if (ioStatusBlock.Status != STATUS_SUCCESS || _handle == nullptr)
        {
            KdPrint(("ioStatusBlock.Status != STATUS_SUCCESS, or _handle is null\n"));
            return;
        }

        _isValid = true;
    }

    ~FileReadHandleGuard()
    {
        if (_handle != nullptr)
        {
            ZwClose(_handle);
        }
    }

    HANDLE& get() { return _handle; }
    bool isValid() const { return _isValid; }

private:
    HANDLE _handle;
    bool _isValid;
};


/**
 *  create a section handle.
 *  release handle when exiting the current context.
 */
class SectionHandleGuard
{
public:
    SectionHandleGuard(HANDLE& fileHandle) : _handle(nullptr), _isValid(false)
    {
        OBJECT_ATTRIBUTES objectAttributes = { 0 };
        InitializeObjectAttributes(
            &objectAttributes,
            nullptr,
            OBJ_KERNEL_HANDLE, // to make sure user mode cannot access this handle
            nullptr,
            nullptr);

        const NTSTATUS createSectionRet = ZwCreateSection(
            &_handle,
            SECTION_MAP_READ,
            &objectAttributes,
            nullptr, // maximum size - use the file size, in order to map the entire file
            PAGE_READONLY,
            SEC_COMMIT, // map as commit and not as SEC_IMAGE, because SEC_IMAGE will not map things which are not needed for the PE - such as resources and certificates
            fileHandle
        );

        if (!NT_SUCCESS(createSectionRet))
        {
            KdPrint(("failed to create section - ZwCreateSection returned %x\n", createSectionRet));
            return;
        }

        _isValid = true;
    }

    ~SectionHandleGuard()
    {
        if (_handle != nullptr)
        {
            ZwClose(_handle);
        }
    }

    HANDLE& get() { return _handle; }
    bool isValid() const { return _isValid; }

private:
    HANDLE _handle;
    bool _isValid;
};


/**
 *  retrieve a section object from a section handle.
 *  release object reference when exiting the current context.
 */
class SectionObjectGuard
{
public:
    SectionObjectGuard(HANDLE& sectionHandle) : _object(nullptr), _isValid(false)
    {
        const NTSTATUS ret = ObReferenceObjectByHandle(
            sectionHandle,
            SECTION_MAP_READ,
            nullptr,
            KernelMode,
            &_object,
            nullptr
        );

        if (!NT_SUCCESS(ret))
        {
            KdPrint(("ObReferenceObjectByHandle failed -  returned %x\n", ret));
            return;
        }

        _isValid = true;
    }

    ~SectionObjectGuard()
    {
        if (_object != nullptr)
        {
            ObfDereferenceObject(_object);
        }
    }

    PVOID& get() { return _object; }
    bool isValid() const { return _isValid; }

private:
    PVOID _object;
    bool _isValid;
};


/**
 *  create a view of file.
 *  unmap the view when exiting the current context.
 */
class SectionViewGuard
{
public:
    SectionViewGuard(PVOID sectionObject) : _baseAddrOfView(nullptr), _viewSize(0), _isValid(false)
    {
        const NTSTATUS ret = MmMapViewInSystemSpace(
            sectionObject,
            &_baseAddrOfView,
            &_viewSize
        );

        if (!NT_SUCCESS(ret))
        {
            KdPrint(("MmMapViewInSystemSpace failed -  returned %x\n", ret));
            return;
        }

        _isValid = true;
    }

    ~SectionViewGuard()
    {
        if (_baseAddrOfView != nullptr)
        {
            MmUnmapViewInSystemSpace(_baseAddrOfView);
        }
    }

    PVOID getViewBaseAddress() const { return _baseAddrOfView; }
    SIZE_T getViewSize() const { return _viewSize; }
    bool isValid() const { return _isValid; }

private:
    PVOID _baseAddrOfView;
    SIZE_T _viewSize;
    bool _isValid;
};


/**
 *  create a PoicyInfo struct.
 *  Release the memory used by the struct when exiting the current context.
 */
class PolicyInfoGuard
{
public:
    PolicyInfoGuard() : _policyInfo{} {} 

    ~PolicyInfoGuard()
    {
        // CiFreePolicyInfo checks internally if there's memory to free
        CiFreePolicyInfo(&_policyInfo);
    }

    PolicyInfo& get() { return _policyInfo; }

private:
    PolicyInfo _policyInfo;
};
```

`CiDemoDriver/SignatureCheck.cpp`:

```cpp
#include "RAIIUtils.h"
#include "SignatureCheck.h"
#include "ci.h"

#define SHA1_IDENTIFIER 0x8004
#define SHA256_IDENTIFIER 0x800C
#define IMAGE_DIRECTORY_ENTRY_SECURITY  4


extern "C" PVOID RtlImageDirectoryEntryToData(PVOID BaseAddress, BOOLEAN MappedAsImage, USHORT Directory, PULONG Size);
bool inRange(const BYTE* rangeStartAddr, const BYTE* rangeEndAddr, const BYTE* addrToCheck);
void parsePolicyInfo(const pPolicyInfo policyInfo);
bool ciCheckSignedFileWrapper(const LPWIN_CERTIFICATE win_cert, ULONG sizeOfSecurityDirectory);


void validateFileUsingCiCheckSignedFile(PCUNICODE_STRING imageFileName)
{
    KdPrint(("Validating file using CiCheckSignedFile...\n"));

    FileReadHandleGuard fileHandleGuard(imageFileName);
    if (!fileHandleGuard.isValid()) return;

    // create section for the file
    SectionHandleGuard sectionHandleGuard(fileHandleGuard.get());
    if (!sectionHandleGuard.isValid()) return;

    // get section object from section handle
    SectionObjectGuard sectionObjectGuard(sectionHandleGuard.get());
    if (!sectionObjectGuard.isValid()) return;

    // map a view of the section
    SectionViewGuard viewGuard(sectionObjectGuard.get());
    if (!viewGuard.isValid()) return;

    // fetch the security directory
    PVOID securityDirectoryEntry = nullptr;
    ULONG securityDirectoryEntrySize = 0;
    securityDirectoryEntry = RtlImageDirectoryEntryToData(
        viewGuard.getViewBaseAddress(),
        TRUE, // we tell RtlImageDirectoryEntryToData it's mapped as image because then it will treat the RVA as offset from the beginning of the view, which is what we want. See https://doxygen.reactos.org/dc/d30/dll_2win32_2dbghelp_2compat_8c_source.html#l00102
        IMAGE_DIRECTORY_ENTRY_SECURITY,
        &securityDirectoryEntrySize
    );

    if (securityDirectoryEntry == nullptr)
    {
        KdPrint(("no security directory\n"));
        return;
    }

    KdPrint(("securityDirectoryEntry found at: %p, size: %x\n",
        securityDirectoryEntry, securityDirectoryEntrySize));

    // Make sure the security directory is contained in the file view
    const BYTE* endOfFileAddr = static_cast<BYTE*>(viewGuard.getViewBaseAddress()) + viewGuard.getViewSize();
    const BYTE* endOfSecurityDir = static_cast<BYTE*>(securityDirectoryEntry) + securityDirectoryEntrySize;
    if (endOfSecurityDir > endOfFileAddr || securityDirectoryEntry < viewGuard.getViewBaseAddress())
    {
        KdPrint(("security directory is not contained in file view!\n"));
        return;
    }

    // technically, there can be several WIN_CERTIFICATE in a file. This not common, and, for simplicity,
    // we'll assume there's only one
    LPWIN_CERTIFICATE winCert = static_cast<LPWIN_CERTIFICATE>(securityDirectoryEntry);
    KdPrint(("WIN_CERTIFICATE at: %p, revision = %x, type = %x, length = %xd, bCertificate = %p\n",
        securityDirectoryEntry, winCert->wRevision, winCert->wCertificateType, winCert->dwLength, static_cast<PVOID>(winCert->bCertificate)));

    ciCheckSignedFileWrapper(winCert, securityDirectoryEntrySize);
}


bool ciCheckSignedFileWrapper(const LPWIN_CERTIFICATE win_cert, ULONG sizeOfSecurityDirectory)
{
    // prepare the parameters required for calling CiCheckSignedFile
    PolicyInfoGuard signerPolicyInfo;
    PolicyInfoGuard timestampingAuthorityPolicyInfo;
    LARGE_INTEGER signingTime = {};
    const int digestSize = 20; // sha1 len, 0x14
    const int digestIdentifier = 0x8004; // sha1
    const BYTE digestBuffer[] = // digest of notepad++.exe
            { 0x83, 0xF6, 0x68, 0x3E, 0x64, 0x9C, 0x70, 0xB9, 0x8D, 0x0B,
              0x5A, 0x8D, 0xBF, 0x9B, 0xD4, 0x70, 0xE6, 0x05, 0xE6, 0xA7 };

    // CiCheckSignedFile() allocates memory from the paged pool, so make sure we're at IRQL < 2,
    // where access to paged memory is allowed
    NT_ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    const NTSTATUS status = CiCheckSignedFile(
        (PVOID)digestBuffer,
        digestSize,
        digestIdentifier,
        win_cert,
        (int)sizeOfSecurityDirectory,
        &signerPolicyInfo.get(),
        &signingTime,
        &timestampingAuthorityPolicyInfo.get());
    KdPrint(("CiCheckSignedFile returned 0x%08X\n", status));

    if (NT_SUCCESS(status))
    {
        parsePolicyInfo(&signerPolicyInfo.get());
        return true;
    }

    return false;
}

void validateFileUsingCiValidateFileObject(PFILE_OBJECT fileObject)
{
    KdPrint(("Validating file using CiValidateFileObject...\n"));
    NT_ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PolicyInfoGuard signerPolicyInfo;
    PolicyInfoGuard timestampingAuthorityPolicyInfo;
    LARGE_INTEGER signingTime = {};
    int digestSize = 64;
    int digestIdentifier = 0;
    BYTE digestBuffer[64] = {};

    const NTSTATUS status = CiValidateFileObject(
        fileObject,
        0,
        0,
        &signerPolicyInfo.get(),
        &timestampingAuthorityPolicyInfo.get(),
        &signingTime,
        digestBuffer,
        &digestSize,
        &digestIdentifier
    );

    KdPrint(("CiValidateFileObject returned 0x%08X\n", status));
    if (NT_SUCCESS(status))
    {
        parsePolicyInfo(&signerPolicyInfo.get());
        return;
    }
}

void parsePolicyInfo(const pPolicyInfo policyInfo)
{
    if (policyInfo == nullptr)
    {
        KdPrint(("parsePolicyInfo - paramter is null\n"));
        return;
    }

    if (policyInfo->structSize == 0)
    {
        KdPrint(("policy info is empty\n"));
        return;
    }

    if (policyInfo->certChainInfo == nullptr)
    {
        KdPrint(("certChainInfo is null\n"));
        return;
    }

    const pCertChainInfoHeader chainInfoHeader = policyInfo->certChainInfo;

    const BYTE* startOfCertChainInfo = (BYTE*)(chainInfoHeader);
    const BYTE* endOfCertChainInfo = (BYTE*)(policyInfo->certChainInfo) + chainInfoHeader->bufferSize;

    if (!inRange(startOfCertChainInfo, endOfCertChainInfo, (BYTE*)chainInfoHeader->ptrToCertChainMembers))
    {
        KdPrint(("chain members out of range\n"));
        return;
    }

    // need to make sure we have enough room to accomodate the chain member struct
    if (!inRange(startOfCertChainInfo, endOfCertChainInfo, (BYTE*)chainInfoHeader->ptrToCertChainMembers + sizeof(CertChainMember)))
    {
        KdPrint(("chain member out of range\n"));
        return;
    }

    // we are interested in the first certificate in the chain - the signer itself
    pCertChainMember signerChainMember = chainInfoHeader->ptrToCertChainMembers;

    KdPrint(("Signer certificate:\n  digest algorithm - 0x%x\n  size - %zu\n  subject - %.*s\n  issuer - %.*s\n",   \
        signerChainMember->digestIdetifier,                                                                         \
        signerChainMember->certificate.size,                                                                        \
        signerChainMember->subjectName.nameLen,                                                                     \
        static_cast<char*>(signerChainMember->subjectName.pointerToName),                                           \
        signerChainMember->issuerName.nameLen,                                                                      \
        static_cast<char*>(signerChainMember->issuerName.pointerToName))                                            \
    );

    UNREFERENCED_PARAMETER(signerChainMember);
}

bool inRange(const BYTE* rangeStartAddr, const BYTE* rangeEndAddr, const BYTE* addrToCheck)
{
    if (addrToCheck > rangeEndAddr || addrToCheck < rangeStartAddr)
    {
        return false;
    }

    return true;
}

```

`CiDemoDriver/SignatureCheck.h`:

```h
#pragma once

#include <wdm.h>


void validateFileUsingCiValidateFileObject(PFILE_OBJECT FileObject);
void validateFileUsingCiCheckSignedFile(PCUNICODE_STRING imageFileName);

```

`CiDemoDriver/ci.h`:

```h
#pragma once

#include <wdm.h>
#include <minwindef.h>


/**
*  This struct was copied from <wintrust.h> and encapsulates a signature used in verifying executable files.
*/
typedef struct _WIN_CERTIFICATE {
    DWORD dwLength;                         // Specifies the length, in bytes, of the signature
    WORD  wRevision;                        // Specifies the certificate revision
    WORD  wCertificateType;                 // Specifies the type of certificate
    BYTE  bCertificate[ANYSIZE_ARRAY];      // An array of certificates
} WIN_CERTIFICATE, * LPWIN_CERTIFICATE;


/**
*  Describes the location (address) and size of a ASN.1 blob within a buffer.
*
*  @note  The data itself is not contained in the struct.
*/
typedef struct _Asn1BlobPtr
{
    int size;               // size of the ASN.1 blob
    PVOID ptrToData;        // where the ASN.1 blob starts
} Asn1BlobPtr, * pAsn1BlobPtr;


/**
*  Describes the location (address) and size of a certificate subject/issuer name, within a buffer.
*
*  @note  The data itself (name) is not contained in the struct.
*
*  @note  the reason for separating these fields into their own struct was to match the padding we
*         observed in CertChainMember struct after the second 'short' field - once you enclose it 
*         into a struct, on x64 bit machines there will be a padding of 4 bytes at the end of the struct,
*         because the largest member of the struct is of size 8 and it dictates the alignment of the struct.
*/
typedef struct _CertificatePartyName
{
    PVOID pointerToName;
    short nameLen;
    short unknown;
} CertificatePartyName, * pCertificatePartyName;


/**
*  Contains various data about a specific certificate in the chain and also points to the actual certificate.
*
*  @note  the digest described in this struct is the digest that was used to create the certificate - not for
*         signing the file.
*
*  @note  The size reserved for digest is 64 byte regardless of the digest type, in order to accomodate SHA2/3's
*         max size of 512bit. The memory is not zeroed, so we must take the actual digestSize into account when
*         reading it.
*/
typedef struct _CertChainMember
{
    int digestIdetifier;                // e.g. 0x800c for SHA256
    int digestSize;                     // e.g. 0x20 for SHA256
    BYTE digestBuffer[64];              // contains the digest itself, where the digest size is dictated by digestSize

    CertificatePartyName subjectName;   // pointer to the subject name
    CertificatePartyName issuerName;    // pointer to the issuer name

    Asn1BlobPtr certificate;            // ptr to actual cert in ASN.1 - including the public key
} CertChainMember, * pCertChainMember;


/**
*  Describes the format of certChainInfo buffer member of PolicyInfo struct. This header maps the types,
*  locations, and quantities of the data which is contained in the buffer.
*
*  @note  when using this struct make sure to check its size first (bufferSize) because it's not guaranteed
*         that all the fields below will exist.
*/
typedef struct _CertChainInfoHeader
{
    // The size of the dynamically allocated buffer
    int bufferSize;

    // points to the start of a series of Asn1Blobs which contain the public keys of the certificates in the chain
    pAsn1BlobPtr ptrToPublicKeys;
    int numberOfPublicKeys;
    
    // points to the start of a series of Asn1Blobs which contain the EKUs
    pAsn1BlobPtr ptrToEkus;
    int numberOfEkus;

    // points to the start of a series of CertChainMembers
    pCertChainMember ptrToCertChainMembers;
    int numberOfCertChainMembers;

    int unknown;

    // ASN.1 blob of authenticated attributes - spcSpOpusInfo, contentType, etc.
    Asn1BlobPtr variousAuthenticodeAttributes;
} CertChainInfoHeader, * pCertChainInfoHeader;


/**
*  Contains information regarding the certificates that were used for signing/timestamping
*
*  @note  you must check structSize before accessing the other members, since some members were added later.
*
*  @note  all structs members, including the length, are populated by ci functions - no need
*         to fill them in adavnce.
*/
typedef struct _PolicyInfo
{
    int structSize;
    NTSTATUS verificationStatus;
    int flags;
    pCertChainInfoHeader certChainInfo; // if not null - contains info about certificate chain
    FILETIME revocationTime;            // when was the certificate revoked (if applicable)
    FILETIME notBeforeTime;             // the certificate is not valid before this time
    FILETIME notAfterTime;              // the certificate is not valid before this time
} PolicyInfo, *pPolicyInfo;


/**
*  Given a file digest and signature of a file, verify the signature and provide information regarding
*  the certificates that was used for signing (the entire certificate chain)
*
*  @note  the function allocates a buffer from the paged pool --> can be used only where IRQL < DISPATCH_LEVEL
*
*  @param  digestBuffer - buffer containing the digest
*
*  @param  digestSize - size of the digest, e.g. 0x20 for SHA256, 0x14 for SHA1
*
*  @param  digestIdentifier - digest algorithm identifier, e.g. 0x800c for SHA256, 0x8004 for SHA1
*
*  @param  winCert - pointer to the start of the security directory
*
*  @param  sizeOfSecurityDirectory - size the security directory
*
*  @param  policyInfoForSigner[out] - PolicyInfo containing information about the signer certificate chain
*
*  @param  signingTime[out] - when the file was signed (FILETIME format)
*
*  @param  policyInfoForTimestampingAuthority[out] - PolicyInfo containing information about the timestamping 
*          authority (TSA) certificate chain
*
*  @return  0 if the file digest in the signature matches the given digest and the signer cetificate is verified.
*           Various error values otherwise, for example:
*           STATUS_INVALID_IMAGE_HASH - the digest does not match the digest in the signature
*           STATUS_IMAGE_CERT_REVOKED - the certificate used for signing the file is revoked
*           STATUS_IMAGE_CERT_EXPIRED - the certificate used for signing the file has expired
*/
extern "C" __declspec(dllimport) NTSTATUS _stdcall CiCheckSignedFile(
    const PVOID digestBuffer,
    int digestSize,
    int digestIdentifier,
    const LPWIN_CERTIFICATE winCert,
    int sizeOfSecurityDirectory,
    PolicyInfo* policyInfoForSigner,
    LARGE_INTEGER* signingTime,
    PolicyInfo* policyInfoForTimestampingAuthority);


/**
*  Resets a PolicyInfo struct - frees the dynamically allocated buffer in PolicyInfo (certChainInfo) if not null.
*  Zeros the entire PolicyInfo struct.
*
*  @param  policyInfo - the struct to reset.
*
*  @return  the struct which was reset.
*/
extern "C" __declspec(dllimport) PVOID _stdcall CiFreePolicyInfo(PolicyInfo* policyInfo);


/**
*  Given a file object, verify the signature and provide information regarding
*  the certificates that was used for signing (the entire certificate chain)
*
*  @note  the function allocates memory from the paged pool --> can be used only where IRQL < DISPATCH_LEVEL
*
*  @param  fileObject[in] - fileObject of the PE in question
*
*  @param  a2[in] - unknown, needs to be reversed. 0 is a valid value.
*
*  @param  a3[in] - unknown, needs to be reversed. 0 is a valid value.
*
*  @param  policyInfoForSigner[out] - PolicyInfo containing information about the signer certificate chain
*
*  @param  signingTime[out] - when the file was signed
*
*  @param  policyInfoForTimestampingAuthority[out] - PolicyInfo containing information about the timestamping
*          authority (TSA) certificate chain
*
*  @param  digestBuffer[out] - buffer to be filled with the digest, must be at least 64 bytes
*
*  @param  digestSize[inout] - size of the digest. Must be at leat 64 and will be changed by the function to 
*                              reflect the actual digest length.
*
*  @param  digestIdentifier[out] - digest algorithm identifier, e.g. 0x800c for SHA256, 0x8004 for SHA1
*
*  @return  0 if the file digest in the signature matches the given digest and the signer cetificate is verified.
*           Various error values otherwise, for example:
*           STATUS_INVALID_IMAGE_HASH - the digest does not match the digest in the signature
*           STATUS_IMAGE_CERT_REVOKED - the certificate used for signing the file is revoked
*           STATUS_IMAGE_CERT_EXPIRED - the certificate used for signing the file has expired
*/
extern "C" __declspec(dllimport) NTSTATUS _stdcall CiValidateFileObject(
    struct _FILE_OBJECT* fileObject,
    int a2,
    int a3,
    PolicyInfo* policyInfoForSigner,
    PolicyInfo* policyInfoForTimestampingAuthority,
    LARGE_INTEGER* signingTime,
    BYTE* digestBuffer,
    int* digestSize,
    int* digestIdentifier
);
```

`CiDemoDriver/main.cpp`:

```cpp
#include <ntddk.h> // PsSetCreateProcessNotifyRoutineEx
#include <wdm.h>
#include "SignatureCheck.h"


DRIVER_UNLOAD MyDriverUnload;
void registerProcessCallback();
void unregisterProcessCallback();
void ProcessCreateProcessNotifyRoutineEx(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo);

extern "C" NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(DriverObject);
    UNREFERENCED_PARAMETER(RegistryPath);
    DriverObject->DriverUnload = MyDriverUnload;

    KdPrint(("CiDemoDriver load\n"));

    registerProcessCallback();

    return STATUS_SUCCESS;
}

VOID MyDriverUnload(_In_ struct _DRIVER_OBJECT* DriverObject)
{
    UNREFERENCED_PARAMETER(DriverObject);
    KdPrint(("CiDemoDriver unload\n"));
    unregisterProcessCallback();
}

void registerProcessCallback()
{
    const NTSTATUS registerCallbackStatus = PsSetCreateProcessNotifyRoutineEx(ProcessCreateProcessNotifyRoutineEx, FALSE);
    if (!NT_SUCCESS(registerCallbackStatus))
    {
        KdPrint(("failed to register callback with status %d\n", registerCallbackStatus));
    }
    else
    {
        KdPrint(("successfully registered callback\n"));
    }
}

void unregisterProcessCallback()
{
    const NTSTATUS registerCallbackStatus = PsSetCreateProcessNotifyRoutineEx(ProcessCreateProcessNotifyRoutineEx, TRUE);
    if (!NT_SUCCESS(registerCallbackStatus))
    {
        KdPrint(("failed to unregister callback\n"));
    }
    else
    {
        KdPrint(("successfully unregistered callback\n"));
    }
}

void ProcessCreateProcessNotifyRoutineEx(
    PEPROCESS Process,
    HANDLE ProcessId,
    PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
    UNREFERENCED_PARAMETER(Process);
    UNREFERENCED_PARAMETER(ProcessId);

    if (CreateInfo == nullptr) return; //process died

    if (CreateInfo->FileObject == nullptr) return;
    if (nullptr == CreateInfo->ImageFileName) return;

    KdPrint(("New process - image name: %wZ\n", CreateInfo->ImageFileName));

    validateFileUsingCiValidateFileObject(CreateInfo->FileObject);
    validateFileUsingCiCheckSignedFile(CreateInfo->ImageFileName);
}

```

`GeneratingLibFiles/CiStubs.cpp`:

```cpp
#include <windows.h>

extern "C" __declspec(dllexport) NTSTATUS _stdcall CiCheckSignedFile(
    const PVOID digestBuffer,
    int digestSize,
    int digestIdentifier,
    const PVOID winCert,
    int sizeOfSecurityDirectory,
    PVOID policyInfoForSigner,
    PVOID signingTime,
    PVOID policyInfoForTimestampingAuthority)
{
    NTSTATUS dummyReturnValue = 0;
    return dummyReturnValue;
}

extern "C" __declspec(dllexport) PVOID _stdcall CiFreePolicyInfo(PVOID policyInfoPtr)
{
    PVOID dummyReturnValue = nullptr;
    return dummyReturnValue;
}

extern "C" __declspec(dllexport) NTSTATUS _stdcall CiValidateFileObject(
    PVOID fileObject,
    int a2,
    int a3,
    PVOID policyInfoForSigner,
    PVOID policyInfoForTimestampingAuthority,
    LARGE_INTEGER * signingTime,
    BYTE * digestBuffer,
    int* digestSize,
    int* digestIdentifier
)
{
    NTSTATUS dummyReturnValue = 0;
    return dummyReturnValue;
}
```

`GeneratingLibFiles/README.md`:

```md
# Generating import libraries (.lib files)

Usually when linking with a certain dll, you’d use an import library provided by the vendor. 
In our case, no such ci.lib file is provided and we need to generate it ourselves.
This lib file should be added as a linker input in the project properties.

## 64 bit

Get the exported functions from the dll, using dumpbin utility: 

`dumpbin /EXPORTS c:\windows\system32\ci.dll`

Create a .def file. It will looks something like this:

```c
LIBRARY ci.dll
EXPORTS
CiCheckSignedFile
CiFreePolicyInfo
CiValidateFileObject
```

Generate the .lib file using the lib utility:

`lib /def:ci.def /machine:x64 /out:ci.lib`


## 32 bit

Here the situation gets a bit trickier, since in 32bit the functions are decorated to
include the sum of the arguments (in bytes), for example:

`CiFreePolicyInfo@4`

But ci.dll is exporting the functions in their non-decorated shape, so we need to create a .lib file that makes this translation.

- Follow the first two steps of the 64bit section above.

- Create a C++ file with function stubs - the same signature but dummy body. You basically mimic what the vendor did when exporting
  the functions from their code. For example:
  
```c
extern "C" __declspec(dllexport) PVOID _stdcall CiFreePolicyInfo(PVOID policyInfoPtr)
{
    PVOID dummyReturnValue = nullptr;
    return dummyReturnValue;
}
```

An example of such file is included in this repo under the name CiStubs.cpp.

- Compile it into an OBJ file.

- Generate the .lib file using the lib utility, this time with the OBJ file:

`lib /def:ci.def /machine:x86 /out:ci.lib <obj file>`

```

`GeneratingLibFiles/ci.def`:

```def
LIBRARY ci.dll
EXPORTS
CiCheckSignedFile
CiFreePolicyInfo
CiValidateFileObject
```

`GeneratingLibFiles/main.cpp`:

```cpp
int main()
{
    return 0;
}
```

`LICENSE.txt`:

```txt
MIT License

Copyright (c) [2020] [Ido Moshe, Liron Zuarets]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# CiDemoDriver

A joint effort of Liron Zuarets and I, CiDemoDriver is a very simple driver which demonstrates using ci.dll
API in order to validate files. This repository complements a [write-up] we published about the subject.

### Logic

The driver registers a ProcessCreateProcessNotify routine and whenever a new process is created, it tries to verify its
Authentocide signature using two ci.dll APIs:
- CiValidateFileObject: which acts directly on the file object
- CiCheckSignedFile: which requires the caller to provide a file digest. Since file digest calculation is
beyond the scope of this demo, we hard-coded the file digest of Notepad++.exe (this PE is included under "ExecutablesForTesting"
folder) and the function will only succeed for this file.

If the file's signature was verified successfully, the driver will parse the output PolicyInfo structure in order to extract the
signing certificate and its details.

### Requirements

- Supports **Windows 10**. If you want to use earlier OS versions, you need to remove the dependency in CiValidateFileObject
from the code and the lib files, and change the project properties to the appropriate OS.
- Supports **x86**, **x64** architectures
- Can be compiled using Visual Studio 2019. The solution file is included.
- In case you need to link against additional ci.dll functions, refer to the README inside GeneratingLibFiles.
- In order to run the driver, use the .inf file to install and then load the driver by: `sc start CiDemoDriver`

### License

This software is open-source under the MIT license. See the LICENSE.txt file in this repository.

  [write-up]: <https://medium.com/cybereason/code-integrity-in-the-kernel-66b3f5cce5f>
```