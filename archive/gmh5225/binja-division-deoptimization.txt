Project Path: arc_gmh5225_binja-division-deoptimization_x0v__4zq

Source Tree:

```txt
arc_gmh5225_binja-division-deoptimization_x0v__4zq
├── LICENSE
├── README.md
├── __init__.py
├── deoptimization.py
├── images
│   ├── after_running.png
│   ├── before_running.png
│   └── deoptimize_function.png
├── instructions.py
├── integer_division_binary_search.py
├── modulo_binary_search.py
├── plugin.json
├── state.py
└── tests
    └── optimize.c

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Nathan Peercy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Binary Ninja Division and Modulo Deoptimizer

This plugin uses z3 and a binary search to deoptimize divisions and modulos in binary ninja. It operates on MLIL, so it should be architecture agnostic. Because z3 is used and instructions are followed, the deoptimization is also pattern agnostic, so different compiler optimizations should still work.

It works by following the operands of a SSA MLIL instruction. After following the operands, the z3 value representing the final MLIL variable will be a function of an unconstrained input variable. We can use a binary search with different arguments to that function to determine what the actual divisor is.

Notes about speed: This is slow. It takes about a second per MLIL instruction tested, so large functions will not be analyzed quickly. There are a couple easy speed improvements that can be made, and some more complex ones. Testing every other MLIL line should still catch most if not all divisions/modulos, only running the division pass or modulo pass, not analyzing instructions that are too far away from relevant arethmetic, and reusing analysis effort on nearby lines are some potential future speed improvements.

# Usage

The plugin registers two commands - "Deoptimize Operations - Function" and "Deoptimize Operations - Line". 

![](images/before_running.png)

For "Deoptimize Operations - Line", open the context menu on the line in which the result of the division is stored in a register or IL variable. Then run the analysis, and if a division is found, a comment will be added.

![](images/after_running.png)

To analyze every line in the current function, run "Deoptimize Operation - Function".

![](images/deoptimize_function.png)

# Installation

Clone or symlink this repository into your plugin folder. (https://docs.binary.ninja/guide/plugins.html#using-plugins)

In addition, ensure that `z3-solver` is installed in your python environment.

# Known Failures

These failures are caused by the incomplete impletation of the MLIL.

 - 64 bit dividing or performing modulos by very large numbers.
 - 32 bit, when large enough numbers are used that `__divdi3` and similar methods are called.
```c
    int b;
    unsigned long e;
    scanf("%d", &b);
    printf("b / 435939234853 = %d", x / 435939234853); // Doesn't work
    scanf("%ld", &e);
    printf("UNSIGNED LONG b / 435939234853 = %ld", x / 435939234853); // Also doesn't work
    scanf("%d", &b);
    printf("b % 435939234853 = %d", x % 435939234853); // Still doesn't work
    scanf("%ld", &e);
    printf("UNSIGNED LONG b % 435939234853 = %ld", x % 435939234853); // Still doesn't work
```

 - 64 bit, divide or modulo by 32, and possibly other powers of 2. There's an issue with variable sizes so that a division of a 4-byte int results in 9223372032559808544, which is technically correct... `c_int(9223372032559808544).value == 32`. Modulo doesn't have any result.

```

`__init__.py`:

```py
from binaryninja.plugin import PluginCommand
from binaryninja.interaction import get_choice_input, show_message_box
from binaryninja import MessageBoxButtonSet, log

def register_commands():
    from .deoptimization import (
        annotate_operations_ending_at_address,
        annotate_operations_in_function,
    )

    PluginCommand.register_for_address(
        "Deoptimize Operations - Line",
        "Uses z3 to deoptimize divisions and modulos ending at the specified line.",
        action=annotate_operations_ending_at_address,
    )

    PluginCommand.register_for_function(
        "Deoptimize Operations - Function",
        "Uses z3 to deoptimize divisions and modulos through the current function.",
        action=annotate_operations_in_function,
    )

try:
    import z3
    register_commands()
except ImportError:
    choice = show_message_box("Binja Deoptimizer - Error", "z3-solver is not installed in your current environment and is required to run the deoptimization plugin. Please install z3-solver and restart binaryninja.", MessageBoxButtonSet.OKButtonSet)
    log.log_error("Binja Deoptimizer - z3-solver not installed, unable to run.")

```

`deoptimization.py`:

```py
from .integer_division_binary_search import integer_division_binary_search
from .modulo_binary_search import modulo_binary_search
from .modulo_binary_search import modulo_binary_search
from .state import BacktrackingState
from .instructions import MLILInstructionExecutor
from z3 import Solver, simplify, sat
from binaryninja import (
    MediumLevelILOperation,
    BackgroundTaskThread,
    log,
    BinaryView,
    MediumLevelILInstruction,
    Function,
)


def annotate_operations_ending_at_mlil_instruction(
    bv: BinaryView, instruction: MediumLevelILInstruction, function: Function
):
    """
    Annotate divisions and modulos that end at the specified MLIL instruction

    :bv: Current binaryview
    :instruction: Instruction to examine
    :function: Current function
    """
    ssa_instruction = instruction.ssa_form

    # TODO: There is probably an easy way to know more instructions that can be skipped.

    if ssa_instruction.operation != MediumLevelILOperation.MLIL_SET_VAR_SSA:
        log.log_debug("Deoptimizer: Skipping Instruction")
        return None

    # 15 found experimentially. There may be longer modulo optimiztions.
    backtracking_state = BacktrackingState(bv, function, depth=15)
    start = MLILInstructionExecutor(bv, ssa_instruction)

    try:
        start.execute(backtracking_state)
    except NotImplementedError as e:
        log.log_debug(
            "Unsupported Instruction: {}. If this instruction is necessary to deoptimize your code, please report this to the github: https://github.com/jmprdi/binja-division-deoptimization".format(
                e.args[0]
            )
        )
        return
    except Exception as e:
        log.log_warn(
            "Deoptimizer Error: {} Please report this to the github: https://github.com/jmprdi/binja-division-deoptimization".format(
                repr(e)
            )
        )
        raise e
        return

    if len(backtracking_state.potential_inputs) == 0:
        log.log_debug("Deoptimizer: No potential inputs")
        return None

    input_bv = backtracking_state.potential_inputs[-1]
    output_bv = backtracking_state.variables[ssa_instruction.dest]

    def do_operation(dividend):
        s = Solver()
        s.set("timeout", 10)
        s.add(input_bv == dividend)
        r = s.check()
        if r != sat:
            return None
        m = s.model()
        solved = m.eval(output_bv)
        try:
            return solved.as_long()
        except AttributeError:
            return None

    modulo = modulo_binary_search(do_operation, 2 ** input_bv.size())
    if modulo is not None:
        bv.set_comment_at(ssa_instruction.address, "modulo by {}".format(modulo))
        return

    divisor = integer_division_binary_search(do_operation, 2 ** input_bv.size())
    if divisor is not None:
        bv.set_comment_at(ssa_instruction.address, "divide by {}".format(divisor))
        return


class AnnotateAtMLILInstruction(BackgroundTaskThread):
    """
    Thread to annotate divisions and modulos that end at the specified MLIL instruction
    """

    def __init__(
        self, bv: BinaryView, instruction: MediumLevelILInstruction, function: Function
    ):
        BackgroundTaskThread.__init__(
            self, "Deoptmizing Operations - Instruction", True
        )
        self.bv = bv
        self.instruction = instruction
        self.function = function

    def run(self):
        annotate_operations_ending_at_mlil_instruction(
            self.bv, self.instruction, self.function
        )


class AnnotateAtFunction(BackgroundTaskThread):
    """
    Thread to annotate divisions and modulos on every line in a function.
    """

    def __init__(self, bv: BinaryView, function: Function):
        BackgroundTaskThread.__init__(self, "Deoptimizing Operations - Function", True)
        self.bv = bv
        self.function = function

    def run(self):
        for bb in self.function.mlil_basic_blocks:
            for instruction in bb:
                annotate_operations_ending_at_mlil_instruction(
                    self.bv, instruction, self.function
                )


def annotate_operations_ending_at_address(bv: BinaryView, address: int):
    """
    Plugin command to annotate divisions and modulos that end at an address.

    :bv: Current binaryview
    :address: Address to check
    """
    function = bv.get_functions_containing(address)[0]
    instruction = function.get_low_level_il_at(address).mlil

    t = AnnotateAtMLILInstruction(bv, instruction, function)
    t.start()


def annotate_operations_in_function(bv: BinaryView, function: Function):
    """
    Plugin command to annotate divisions and modulos on every line in a function.

    :bv: Current binaryview
    :function: Function to check
    """
    t = AnnotateAtFunction(bv, function)
    t.start()

```

`instructions.py`:

```py
from binaryninja import log, BinaryView, MediumLevelILInstruction

from z3 import LShR, ZeroExt, SignExt, BitVec, BitVecVal, Extract

from typing import List


class MLILInstructionExecutor:
    """
    Class to execute MLIL instructions.
    """

    def __init__(self, bv: BinaryView, instruction: MediumLevelILInstruction):
        self.bv = bv
        self.instruction = instruction

    def instructions_to_operands(
        self, instructions: List[MediumLevelILInstruction], state, size: int
    ):
        """
        Get operands from instruction list, increasing their size if needed.

        :instructions: List of instructions to convert to operands
        :state: Current active state
        :size: Minimum size in bytes of the operands
        """
        operands = []
        largest_size = size * 8
        for instruction in instructions:
            ops = MLILInstructionExecutor(self.bv, instruction).execute(state)
            # TODO: Is this needed:
            for op in ops:
                if op.size() > largest_size:
                    largest_size = op.size()
                operands.append(op)

        for i, op in enumerate(operands):
            if op.size() < largest_size:
                operands[i] = ZeroExt(largest_size - op.size(), op)

        return operands

    def execute(self, state):
        """
        Execute instruction that this class was initialized with.

        :state: Current active state
        """

        operation = self.instruction.operation.name
        log.log_debug(
            "Evaluating {}: {} @ {}".format(
                operation, self.instruction, hex(self.instruction.address)
            )
        )

        try:
            if self.instruction.value.is_constant:
                size = self.instruction.size * 8
                return [BitVecVal(self.instruction.value.value, size)]
        except AttributeError:
            pass

        executor = getattr(self, "evaluate_" + operation, None)

        if executor is not None:
            result = executor(state)
        else:
            raise NotImplementedError(repr(operation))

        for i in range(len(result)):
            width = self.instruction.size * 8
            if operation.endswith("_DP"):
                # Double precision
                width = width * 2
            if width < result[i].size():
                result[i] = Extract(width - 1, 0, result[i])
            if width > result[i].size():
                result[i] = ZeroExt(width - result[i].size(), result[i])

        log.log_debug(
            "Completed {}: {} @ {}".format(
                operation, self.instruction, hex(self.instruction.address)
            )
        )

        return result

    def evaluate_MLIL_ADD(self, state):
        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        return [operand_1 + operand_2]

    def evaluate_MLIL_ASR(self, state):
        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        return [operand_1 >> operand_2]

    def evaluate_MLIL_LSL(self, state):
        # TODO: Is an arethmetic shift fine here, or should a logical shift be used?

        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        return [operand_1 << operand_2]

    def evaluate_MLIL_LSR(self, state):
        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        return [LShR(operand_1, operand_2)]

    def evaluate_MLIL_LOAD_SSA(self, state):
        # TODO: Should more be done here?

        (instruction, ssa_number) = self.instruction.operands
        # memory_location_1 = MLILInstructionExecutor(self.bv, instruction_1).execute(state)
        return [state.get_ssa_memory_at(None, None)]

    def evaluate_MLIL_MUL(self, state):
        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        return [operand_1 * operand_2]

    def evaluate_MLIL_MULS_DP(self, state):
        # TODO: CONFIRM THIS IS CORRECT
        # FIXME: Possibly broken on 64 bit; Might also be SET_VAR_SPLIT_SSA.

        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        result_size = self.instruction.size * 8 * 2

        result = SignExt(result_size // 2, operand_1) * SignExt(
            result_size // 2, operand_2
        )

        return [result]

    def evaluate_MLIL_MULU_DP(self, state):
        # TODO: CONFIRM THIS IS CORRECT
        # FIXME: Possibly broken on 64 bit; Might also be SET_VAR_SPLIT_SSA.

        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )

        result_size = self.instruction.size * 8 * 2

        result = ZeroExt(result_size // 2, operand_1) * ZeroExt(
            result_size // 2, operand_2
        )

        return [result]

    def evaluate_MLIL_SET_VAR_SSA(self, state):
        (ssa_variable, next_instruction) = self.instruction.operands
        [value] = self.instructions_to_operands(
            [next_instruction], state, self.instruction.size
        )
        state.set_ssa_variable(ssa_variable, value)

        return []

    def evaluate_MLIL_SET_VAR_SPLIT_SSA(self, state):
        (ssa_variable_1, ssa_variable_2, next_instruction) = self.instruction.operands
        [value] = self.instructions_to_operands(
            [next_instruction], state, self.instruction.size
        )

        value1 = Extract(value.size() - 1, value.size() // 2, value)
        value2 = Extract(value.size() // 2 - 1, 0, value)

        state.set_ssa_variable(ssa_variable_1, value1)
        state.set_ssa_variable(ssa_variable_2, value2)

        return []

    def evaluate_MLIL_SUB(self, state):
        operand_1, operand_2 = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )
        return [operand_1 - operand_2]

    def evaluate_MLIL_SX(self, state):
        # TODO: Confirm size
        [operand] = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )
        return [SignExt(32, operand)]

    def evaluate_MLIL_VAR_PHI(self, state):
        # TODO: Should this be followed? In what cases?
        (ssa_variable, instructions) = self.instruction.operands

        var = state.get_unconstrained_variable(
            repr(ssa_variable), ssa_variable.var.type.width
        )
        state.set_ssa_variable(ssa_variable, var)
        return []

    def evaluate_MLIL_VAR_ALIASED(self, state):
        # TODO: Figure out if there is a more correct way to execute this
        (ssa_variable,) = self.instruction.operands
        return [state.get_ssa_variable(ssa_variable)]

    def evaluate_MLIL_VAR_SSA(self, state):
        (ssa_variable,) = self.instruction.operands
        return [state.get_ssa_variable(ssa_variable)]

    def evaluate_MLIL_VAR_SSA_FIELD(self, state):
        (ssa_variable, offset) = self.instruction.operands
        var = state.get_ssa_variable(ssa_variable)
        return [Extract(31, offset, var)]

    def evaluate_MLIL_ZX(self, state):
        # TODO: Confirm size
        [operand] = self.instructions_to_operands(
            self.instruction.operands, state, self.instruction.size
        )
        return [ZeroExt(32, operand)]

```

`integer_division_binary_search.py`:

```py
import ctypes


def int_div_test(equation, val):
    """
    Comparison for the integer division binary search.

    :equation: Equation to test
    :val: Input to the division
    """

    r1 = equation(val)
    if r1 == None:
        return None
    r2 = equation(val - 1)
    if r2 == None:
        return None
    if r1 == 1 and r2 == 0:
        return 0
    elif r1 >= 1:
        return 1
    else:
        return -1


def integer_division_binary_search(equation, size):
    """
    Find the divisor of an integer division equation via a binary search.

    :equation: Equation to test
    :size: Maximum size of divisor
    """

    i = size // 2 // 2  # This only handles positive divisors
    move_amount = i
    done = False
    while not done:
        tst = int_div_test(equation, i)
        if tst == None:
            return None
        elif tst == 0:
            if i == 1:
                # Remove a set of technically-correct, but not intentional divisions
                return None
            return i
        elif tst > 0:
            move_amount //= 2
            i = i - move_amount
        elif tst < 0:
            move_amount //= 2
            i = i + move_amount

        if move_amount == 0:
            return None


def equ_test(x):
    q = x // 53
    return q


if __name__ == "__main__":
    print(integer_division_binary_search(equ_test, 2 ** 31))

```

`modulo_binary_search.py`:

```py
import ctypes


def mod_test(equation, val):
    """
    Comparison for the modulo binary search.

    :equation: Equation to test
    :val: Input to the division
    """

    r1 = equation(val)
    if r1 == None:
        return None
    if r1 == 0:
        return 0
    elif r1 != val:
        return 1
    elif r1 == val:
        return -1


def modulo_binary_search(equation, size):
    """
    Find the modulo of an equation via a binary search.

    :equation: Equation to test
    :size: Maximum size of modulo
    """

    i = size // 2
    move_amount = i
    done = False
    while not done:
        tst = mod_test(equation, i)
        if tst == None:
            return None
        if tst == 0:
            result = equation(i - 1) + 1
            if result == 1:
                return None
            # Test that it is actually a modulo
            if (i - 1 + result) % result != result - 1:
                return None
            if (i - 2 + result) % result != equation(i - 2):
                return None
            return result
        elif tst > 0:
            move_amount //= 2
            i = i - move_amount
        elif tst < 0:
            move_amount //= 2
            i = i + move_amount

        if move_amount == 0:
            return None


def equ_test(x):
    q = x % 1337
    return q


if __name__ == "__main__":
    print(modulo_binary_search(equ_test, 2 ** 32))

```

`plugin.json`:

```json
{
	"pluginmetadataversion" : 2,
	"name": "Division and Modulo Deoptimizer",
	"type": ["ui", "binaryview", "helper"],
	"api": ["python3"],
	"description": "Deoptimize Divisions and Modulos in Binary Ninja.",
	"longdescription": "# Binary Ninja Division and Modulo Deoptimizer\n\nThis plugin uses z3 and a binary search to deoptimize divisions and modulos in binary ninja. It operates on MLIL, so it should be architecture agnostic. Because z3 is used and instructions are followed, the deoptimization is also pattern agnostic, so different compiler optimizations should still work.\n\nIt works by following the operands of a SSA MLIL instruction. After following the operands, the z3 value representing the final MLIL variable will be a function of an unconstrained input variable. We can use a binary search with different arguments to that function to determine what the actual divisor is.\n\nNotes about speed: This is slow. It takes about a second per MLIL instruction tested, so large functions will not be analyzed quickly. There are a couple easy speed improvements that can be made, and some more complex ones. Testing every other MLIL line should still catch most if not all divisions/modulos, only running the division pass or modulo pass, not analyzing instructions that are too far away from relevant arethmetic are some examples of potential speed improvements, and reusing analysis effort on nearby lines are some potential future speed improvements.\n\n# Usage\n\nThe plugin registers two commands - \"Deoptimize Operations - Function\" and \"Deoptimize Operations - Line\". \n\n![](images/before_running.png)\n\nFor \"Deoptimize Operations - Line\", open the context menu on the line in which the result of the division is stored in a register or IL variable. Then run the analysis, and if a division is found, a comment will be added.\n\n![](images/after_running.png)\n\nTo analyze every line in the current function, run \"Deoptimize Operation - Function\".\n\n![](images/deoptimize_function.png)\n\n# Installation\n\nClone or symlink this repository into your plugin folder. (https://docs.binary.ninja/guide/plugins.html#using-plugins)\n\n# Known Failures\n\nThese failures are caused by the incomplete impletation of the MLIL.\n\n - 64 bit dividing or performing modulos by very large numbers.\n - 32 bit, when large enough numbers are used that `__divdi3` and similar methods are called.\n```c\n    int b;\n    unsigned long e;\n    scanf(\"%d\", &b);\n    printf(\"b / 435939234853 = %d\", x / 435939234853); // Doesn't work\n    scanf(\"%ld\", &e);\n    printf(\"UNSIGNED LONG b / 435939234853 = %ld\", x / 435939234853); // Also doesn't work\n    scanf(\"%d\", &b);\n    printf(\"b % 435939234853 = %d\", x % 435939234853); // Still doesn't work\n    scanf(\"%ld\", &e);\n    printf(\"UNSIGNED LONG b % 435939234853 = %ld\", x % 435939234853); // Shockingly, this still doesn't work\n```\n\n - 64 bit, divide or modulo by 32, and possibly other powers of 2. There's an issue with variable sizes so that a division of a 4-byte int results in 9223372032559808544, which is technically correct... `c_int(9223372032559808544).value == 32`. Modulo doesn't have any result.\n",
	"license": {
		"name": "MIT",
		"text": "Copyright (c) 2020 Nathan Peercy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
	},
	"platforms" : ["Darwin", "Linux", "Windows"],
	"installinstructions" : {
		"Darwin": "To install this manually, please see the \"Using Plugins\" section of the [Getting Started Guide](https://docs.binary.ninja/getting-started.html#using-plugins).",
		"Linux": "To install this manually, please see the \"Using Plugins\" section of the [Getting Started Guide](https://docs.binary.ninja/getting-started.html#using-plugins).",
		"Windows": "To install this manually, please see the \"Using Plugins\" section of the [Getting Started Guide](https://docs.binary.ninja/getting-started.html#using-plugins)."
	},
	"dependencies": {
		"pip": ["z3-solver"],
		"apt": [],
		"installers": [],
		"other": []
	},
	"version": "0.1.3",
	"author": "Nathan Peercy",
	"minimumbinaryninjaversion": 2085,
    "projectUrl": "https://github.com/jmprdi/binja-division-deoptimization"
}

```

`state.py`:

```py
from binaryninja import SSAVariable, BinaryView, Function
from z3 import BitVecRef, BitVec
from copy import copy
from .instructions import MLILInstructionExecutor


class State:
    """
    State of the current execution
    """

    def __init__(self, bv: BinaryView, function: Function):
        self.bv = bv
        self.function = function

    def get_ssa_variable(self, variable: SSAVariable):
        raise NotImplementedError

    def set_ssa_variable(self, variable: SSAVariable, value: BitVecRef):
        raise NotImplementedError

    def get_ssa_memory_at(self, location: BitVecRef, ssa_index: BitVecRef):
        raise NotImplementedError


class BacktrackingState(State):
    """
    Backtracking state that can look up requested variables via the SSA variable definitions.
    """

    def __init__(self, bv: BinaryView, function: Function, depth: int):
        super().__init__(bv, function)
        # TODO: Make variables an object that errors upon assigning the same value twice?
        # NOTE: This variables object is shared by all states that are copies of this one.
        self.variables = {}
        self.depth = depth
        # This might not be needed. The variables object may be useable... (oldest variable in it...?)
        # NOTE: This potential_inputs object is shared by all states that are copies of this one.
        self.potential_inputs = []

    def get_ssa_variable(self, variable: SSAVariable):
        """
        Look up SSA variable by executing the instruction in which it was defined

        :variable: SSAVariable to look up.
        """
        definition_instruction = self.function.mlil.ssa_form.get_ssa_var_definition(
            variable
        )
        result = None
        if definition_instruction and self.depth > 0:
            MLILInstructionExecutor(self.bv, definition_instruction).execute(
                self.next_state()
            )
            result = self.variables[variable]
        else:
            name = repr(variable)
            size = variable.var.type.width * 8
            result = BitVec(name, size)
            self.potential_inputs.append(result)

        self.variables[variable] = result
        return result

    def get_unconstrained_variable(self, name: str, size_bytes: int):
        """
        Return an unconstrained BitVec

        :name: Name of the bitvector
        :size_bytes: Size of the bitvector in bytes
        """
        size = size_bytes * 8
        result = BitVec(name, size)
        self.potential_inputs.append(result)

        return result

    def set_ssa_variable(self, variable: SSAVariable, value: BitVecRef):
        """
        Set a SSA variable to a value

        :variable: Variable to set
        :value: Value to set the variable to
        """
        self.variables[variable] = value

    def get_ssa_memory_at(self, location: BitVecRef, ssa_index: BitVecRef):
        """
        Read ssa memory. Currently only returns a bitvec.

        :location: Location to read memory from
        :ssa_index: SSA memory index
        """
        # TODO: This can be much more better.
        name = repr(location)
        size = self.bv.arch.address_size * 8
        result = BitVec(name, size)
        self.potential_inputs.append(result)
        return result

    def next_state(self):
        """
        Get the next state for a newly executed instruction
        """

        state = BacktrackingState(self.bv, self.function, self.depth - 1)
        state.variables = self.variables
        state.potential_inputs = self.potential_inputs
        return state

```

`tests/optimize.c`:

```c
#include <stdio.h>

int main() {
    int x;
    int a;
    int b;
    int c;
    int d;
    unsigned long e;
    unsigned int y;
    long z;

    scanf("%d", &x);
    printf("x / 683958287 = %d", x / 683958287);
    scanf("%d", &a);
    printf("a / 3 = %d", x / 3);
    scanf("%d", &b);
    printf("b / 435939234853 = %d", x / 435939234853);
    scanf("%d", &c);
    printf("c / 4200 = %d", x / 4200);
    scanf("%d", &d);
    printf("c / 32 = %d", x / 32);
    scanf("%ld", &e);
    printf("UNSIGNED LONG b / 435939234853 = %ld", x / 435939234853);

    scanf("%u", &y);
    printf("UNSIGNED y / 582 = %d", y / 582);

    scanf("%lx", &z);
    printf("LONG z / 5831 = %d", y / 5831);

    scanf("%d", &x);
    printf("x % 683958287 = %d", x % 683958287);
    scanf("%d", &a);
    printf("a % 3 = %d", x % 3);
    scanf("%d", &b);
    printf("b % 435939234853 = %d", x % 435939234853);
    scanf("%d", &c);
    printf("c % 4200 = %d", x % 4200);
    scanf("%d", &d);
    printf("c % 32 = %d", x % 32);
    scanf("%ld", &e);
    printf("UNSIGNED LONG b % 435939234853 = %ld", x % 435939234853);

    scanf("%u", &y);
    printf("UNSIGNED y % 582 = %d", y % 582);

    scanf("%lx", &z);
    printf("LONG z % 5831 = %d", y % 5831);
}

```