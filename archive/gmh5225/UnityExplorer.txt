Project Path: arc_gmh5225_UnityExplorer_qwcm0ha6

Source Tree:

```txt
arc_gmh5225_UnityExplorer_qwcm0ha6
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ THIRDPARTY_LICENSES.md
â”œâ”€â”€ img
â”‚   â”œâ”€â”€ icon.png
â”‚   â””â”€â”€ preview.png
â”œâ”€â”€ lib
â”‚   â”œâ”€â”€ BepInEx.5
â”‚   â”‚   â””â”€â”€ BepInEx.dll
â”‚   â”œâ”€â”€ BepInEx.6.IL2CPP
â”‚   â”‚   â”œâ”€â”€ BepInEx.Core.dll
â”‚   â”‚   â””â”€â”€ BepInEx.IL2CPP.dll
â”‚   â”œâ”€â”€ BepInEx.6.Mono
â”‚   â”‚   â”œâ”€â”€ BepInEx.Core.dll
â”‚   â”‚   â””â”€â”€ BepInEx.Unity.dll
â”‚   â”œâ”€â”€ MelonLoader
â”‚   â”‚   â””â”€â”€ MelonLoader.dll
â”‚   â”œâ”€â”€ mcs-unity
â”‚   â”œâ”€â”€ mono
â”‚   â”‚   â”œâ”€â”€ UnityEngine.UI.dll
â”‚   â”‚   â””â”€â”€ UnityEngine.dll
â”‚   â””â”€â”€ unhollowed
â”‚       â”œâ”€â”€ Il2CppSystem.Core.dll
â”‚       â”œâ”€â”€ Il2Cppmscorlib.dll
â”‚       â”œâ”€â”€ UnityEngine.AssetBundleModule.dll
â”‚       â”œâ”€â”€ UnityEngine.AudioModule.dll
â”‚       â”œâ”€â”€ UnityEngine.CoreModule.dll
â”‚       â”œâ”€â”€ UnityEngine.IMGUIModule.dll
â”‚       â”œâ”€â”€ UnityEngine.PhysicsModule.dll
â”‚       â”œâ”€â”€ UnityEngine.TextRenderingModule.dll
â”‚       â”œâ”€â”€ UnityEngine.UI.dll
â”‚       â”œâ”€â”€ UnityEngine.UIModule.dll
â”‚       â””â”€â”€ UnityEngine.dll
â””â”€â”€ src
    â”œâ”€â”€ CSConsole
    â”‚   â”œâ”€â”€ CSAutoCompleter.cs
    â”‚   â”œâ”€â”€ ConsoleController.cs
    â”‚   â”œâ”€â”€ LexerBuilder.cs
    â”‚   â”œâ”€â”€ Lexers
    â”‚   â”‚   â”œâ”€â”€ CommentLexer.cs
    â”‚   â”‚   â”œâ”€â”€ KeywordLexer.cs
    â”‚   â”‚   â”œâ”€â”€ Lexer.cs
    â”‚   â”‚   â”œâ”€â”€ NumberLexer.cs
    â”‚   â”‚   â”œâ”€â”€ StringLexer.cs
    â”‚   â”‚   â””â”€â”€ SymbolLexer.cs
    â”‚   â”œâ”€â”€ ScriptEvaluator.cs
    â”‚   â””â”€â”€ ScriptInteraction.cs
    â”œâ”€â”€ CacheObject
    â”‚   â”œâ”€â”€ CacheConfigEntry.cs
    â”‚   â”œâ”€â”€ CacheConstructor.cs
    â”‚   â”œâ”€â”€ CacheField.cs
    â”‚   â”œâ”€â”€ CacheKeyValuePair.cs
    â”‚   â”œâ”€â”€ CacheListEntry.cs
    â”‚   â”œâ”€â”€ CacheMember.cs
    â”‚   â”œâ”€â”€ CacheMemberFactory.cs
    â”‚   â”œâ”€â”€ CacheMethod.cs
    â”‚   â”œâ”€â”€ CacheObjectBase.cs
    â”‚   â”œâ”€â”€ CacheProperty.cs
    â”‚   â”œâ”€â”€ ICacheObjectController.cs
    â”‚   â”œâ”€â”€ IValues
    â”‚   â”‚   â”œâ”€â”€ InteractiveColor.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveDictionary.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveEnum.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveList.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveString.cs
    â”‚   â”‚   â”œâ”€â”€ InteractiveValue.cs
    â”‚   â”‚   â””â”€â”€ InteractiveValueStruct.cs
    â”‚   â””â”€â”€ Views
    â”‚       â”œâ”€â”€ CacheConfigCell.cs
    â”‚       â”œâ”€â”€ CacheKeyValuePairCell.cs
    â”‚       â”œâ”€â”€ CacheListEntryCell.cs
    â”‚       â”œâ”€â”€ CacheMemberCell.cs
    â”‚       â””â”€â”€ CacheObjectCell.cs
    â”œâ”€â”€ Config
    â”‚   â”œâ”€â”€ ConfigElement.cs
    â”‚   â”œâ”€â”€ ConfigHandler.cs
    â”‚   â”œâ”€â”€ ConfigManager.cs
    â”‚   â”œâ”€â”€ IConfigElement.cs
    â”‚   â””â”€â”€ InternalConfigHandler.cs
    â”œâ”€â”€ ExplorerBehaviour.cs
    â”œâ”€â”€ ExplorerCore.cs
    â”œâ”€â”€ Hooks
    â”‚   â”œâ”€â”€ AddHookCell.cs
    â”‚   â”œâ”€â”€ HookCell.cs
    â”‚   â”œâ”€â”€ HookInstance.cs
    â”‚   â””â”€â”€ HookManager.cs
    â”œâ”€â”€ ILRepack.targets
    â”œâ”€â”€ Inspectors
    â”‚   â”œâ”€â”€ GameObjectInspector.cs
    â”‚   â”œâ”€â”€ GameObjectWidgets
    â”‚   â”‚   â”œâ”€â”€ ComponentCell.cs
    â”‚   â”‚   â”œâ”€â”€ ComponentList.cs
    â”‚   â”‚   â””â”€â”€ GameObjectControls.cs
    â”‚   â”œâ”€â”€ InspectorBase.cs
    â”‚   â”œâ”€â”€ InspectorManager.cs
    â”‚   â”œâ”€â”€ InspectorTab.cs
    â”‚   â”œâ”€â”€ MouseInspector.cs
    â”‚   â”œâ”€â”€ MouseInspectors
    â”‚   â”‚   â”œâ”€â”€ MouseInspectorBase.cs
    â”‚   â”‚   â”œâ”€â”€ UiInspector.cs
    â”‚   â”‚   â””â”€â”€ WorldInspector.cs
    â”‚   â””â”€â”€ ReflectionInspector.cs
    â”œâ”€â”€ Loader
    â”‚   â”œâ”€â”€ BepInEx
    â”‚   â”‚   â”œâ”€â”€ BepInExConfigHandler.cs
    â”‚   â”‚   â””â”€â”€ ExplorerBepInPlugin.cs
    â”‚   â”œâ”€â”€ IExplorerLoader.cs
    â”‚   â”œâ”€â”€ MelonLoader
    â”‚   â”‚   â”œâ”€â”€ ExplorerMelonMod.cs
    â”‚   â”‚   â””â”€â”€ MelonLoaderConfigHandler.cs
    â”‚   â””â”€â”€ Standalone
    â”‚       â”œâ”€â”€ Editor
    â”‚       â”‚   â”œâ”€â”€ ExplorerEditorBehaviour.cs
    â”‚       â”‚   â””â”€â”€ ExplorerEditorLoader.cs
    â”‚       â”œâ”€â”€ ExplorerStandalone.cs
    â”‚       â””â”€â”€ StandaloneConfigHandler.cs
    â”œâ”€â”€ ObjectExplorer
    â”‚   â”œâ”€â”€ ObjectSearch.cs
    â”‚   â”œâ”€â”€ SceneExplorer.cs
    â”‚   â”œâ”€â”€ SceneHandler.cs
    â”‚   â””â”€â”€ SearchProvider.cs
    â”œâ”€â”€ Properties
    â”‚   â””â”€â”€ AssemblyInfo.cs
    â”œâ”€â”€ Runtime
    â”‚   â”œâ”€â”€ Il2CppHelper.cs
    â”‚   â”œâ”€â”€ MonoHelper.cs
    â”‚   â”œâ”€â”€ UERuntimeHelper.cs
    â”‚   â””â”€â”€ UnityCrashPrevention.cs
    â”œâ”€â”€ Tests
    â”‚   â””â”€â”€ TestClass.cs
    â”œâ”€â”€ UI
    â”‚   â”œâ”€â”€ DisplayManager.cs
    â”‚   â”œâ”€â”€ Notification.cs
    â”‚   â”œâ”€â”€ Panels
    â”‚   â”‚   â”œâ”€â”€ AutoCompleteModal.cs
    â”‚   â”‚   â”œâ”€â”€ CSConsolePanel.cs
    â”‚   â”‚   â”œâ”€â”€ ClipboardPanel.cs
    â”‚   â”‚   â”œâ”€â”€ HookManagerPanel.cs
    â”‚   â”‚   â”œâ”€â”€ InspectorPanel.cs
    â”‚   â”‚   â”œâ”€â”€ LogPanel.cs
    â”‚   â”‚   â”œâ”€â”€ ObjectExplorerPanel.cs
    â”‚   â”‚   â”œâ”€â”€ OptionsPanel.cs
    â”‚   â”‚   â”œâ”€â”€ PanelDragger.cs
    â”‚   â”‚   â”œâ”€â”€ UIPanel.cs
    â”‚   â”‚   â””â”€â”€ UiInspectorResultsPanel.cs
    â”‚   â”œâ”€â”€ UIManager.cs
    â”‚   â””â”€â”€ Widgets
    â”‚       â”œâ”€â”€ AutoComplete
    â”‚       â”‚   â”œâ”€â”€ EnumCompleter.cs
    â”‚       â”‚   â”œâ”€â”€ ISuggestionProvider.cs
    â”‚       â”‚   â”œâ”€â”€ Suggestion.cs
    â”‚       â”‚   â””â”€â”€ TypeCompleter.cs
    â”‚       â”œâ”€â”€ EvaluateWidget
    â”‚       â”‚   â”œâ”€â”€ BaseArgumentHandler.cs
    â”‚       â”‚   â”œâ”€â”€ EvaluateWidget.cs
    â”‚       â”‚   â”œâ”€â”€ GenericArgumentHandler.cs
    â”‚       â”‚   â””â”€â”€ ParameterHandler.cs
    â”‚       â”œâ”€â”€ TransformTree
    â”‚       â”‚   â”œâ”€â”€ CachedTransform.cs
    â”‚       â”‚   â”œâ”€â”€ TransformCell.cs
    â”‚       â”‚   â””â”€â”€ TransformTree.cs
    â”‚       â””â”€â”€ UnityObjects
    â”‚           â”œâ”€â”€ AudioClipWidget.cs
    â”‚           â”œâ”€â”€ Texture2DWidget.cs
    â”‚           â””â”€â”€ UnityObjectWidget.cs
    â”œâ”€â”€ UnityExplorer.csproj
    â”œâ”€â”€ UnityExplorer.sln
    â”œâ”€â”€ nuget.config
    â””â”€â”€ packages.config

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
<p align="center">
  <img align="center" src="img/icon.png">
</p>

<p align="center">
  ğŸ” An in-game UI for exploring, debugging and modifying Unity games.
</p>
<p align="center">
  âœ”ï¸ Supports most Unity versions from 5.2 to 2021+ (IL2CPP and Mono).
</p>
<p align="center">
  âœ¨ Powered by <a href="https://github.com/sinai-dev/UniverseLib">UniverseLib</a>
</p>

# Releases  [![](https://img.shields.io/github/downloads/sinai-dev/UnityExplorer/total.svg)](../../releases)

[![](https://img.shields.io/github/release/sinai-dev/UnityExplorer.svg?label=version)](../../releases/latest) [![](https://img.shields.io/github/workflow/status/sinai-dev/UnityExplorer/Build%20UnityExplorer)](https://github.com/sinai-dev/UnityExplorer/actions) [![](https://img.shields.io/github/downloads/sinai-dev/UnityExplorer/latest/total.svg)](../../releases/latest)

âš¡ Thunderstore releases: [BepInEx Mono](https://thunderstore.io/package/sinai-dev/UnityExplorer) | [BepInEx IL2CPP](https://gtfo.thunderstore.io/package/sinai-dev/UnityExplorer_IL2CPP) | [MelonLoader IL2CPP](https://boneworks.thunderstore.io/package/sinai-dev/UnityExplorer_IL2CPP_ML)

## BepInEx

| Release | IL2CPP | Mono |
| ------- | ------ | ---- |
| BIE 6.X | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx.Il2Cpp.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx6.Mono.zip) |
| BIE 5.X | âœ–ï¸ n/a | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.BepInEx5.Mono.zip) |

1. Take the `UnityExplorer.BIE.[version].dll` and the `UniverseLib.[version].dll` files and put them in `BepInEx\plugins\`

<i>Note: BepInEx 6 is obtainable via [BepisBuilds](https://builds.bepis.io/projects/bepinex_be)</i>

## MelonLoader

| Release | IL2CPP | Mono |
| ------- | ------ | ---- |
| ML 0.4+ | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.MelonLoader.Il2Cpp.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.MelonLoader.Mono.zip) | 

1. Take the `UnityExplorer.ML.[version].dll` file and put them in the `Mods\` folder created by MelonLoader, and then put the `UniverseLib.[version].dll` file in the `UserLibs\` folder.

## Standalone

| IL2CPP | Mono |
| ------ | ---- |
| âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Standalone.Il2Cpp.zip) | âœ… [link](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Standalone.Mono.zip) | 

The standalone release can be used with any injector or loader of your choice, but it requires you to load the dependencies manually.

1. Ensure the required libs are loaded - UniverseLib, HarmonyX and MonoMod. Take them from the [`UnityExplorer.Editor`](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Editor.zip) release if you need them.
2. For IL2CPP, load Il2CppAssemblyUnhollower and start an [Il2CppAssemblyUnhollower runtime](https://github.com/knah/Il2CppAssemblyUnhollower#required-external-setup)
2. Load the UnityExplorer DLL
3. Create an instance of Unity Explorer with `UnityExplorer.ExplorerStandalone.CreateInstance();`
4. Optionally subscribe to the `ExplorerStandalone.OnLog` event to handle logging if you wish

## Unity Editor

1. Download the [`UnityExplorer.Editor`](https://github.com/sinai-dev/UnityExplorer/releases/latest/download/UnityExplorer.Editor.zip) release.
2. Install the package, either by using the Package Manager and importing the `package.json` file, or by manually dragging the folder into your `Assets` folder.
3. Drag the `Runtime/UnityExplorer` prefab into your scene, or create a GameObject and add the `Explorer Editor Behaviour` script to it.

# Common issues and solutions

Although UnityExplorer should work out of the box for most Unity games, in some cases you may need to tweak the settings for it to work properly.

To adjust the settings, open the config file:
* BepInEx: `BepInEx\config\com.sinai.unityexplorer.cfg`
* MelonLoader: `UserData\MelonPreferences.cfg`
* Standalone: `UnityExplorer\config.cfg`

Try adjusting the following settings and see if it fixes your issues:
* `Startup_Delay_Time` - increase to 5-10 seconds (or more as needed), can fix issues with UnityExplorer being destroyed or corrupted during startup.
* `Disable_EventSystem_Override` - if input is not working properly, try setting this to `true`.

If these fixes do not work, please create an issue in this repo and I'll do my best to look into it.

# Features

<p align="center">
  <a href="https://raw.githubusercontent.com/sinai-dev/UnityExplorer/master/img/preview.png">
    <img src="img/preview.png" />
  </a>
</p>

### Object Explorer

* Use the <b>Scene Explorer</b> tab to traverse the active scenes, as well as the DontDestroyOnLoad and HideAndDontSave objects.
  * The "HideAndDontSave" scene contains objects with that flag, as well as Assets and Resources which are not in any scene but behave the same way.
  * You can use the Scene Loader to easily load any of the scenes in the build (may not work for Unity 5.X games)
* Use the <b>Object Search</b> tab to search for Unity objects (including GameObjects, Components, etc), C# Singletons or Static Classes.
  * Use the UnityObject search to look for any objects which derive from `UnityEngine.Object`, with optional filters
  * The singleton search will look for any classes with a typical "Instance" field, and check it for a current value. This may cause unexpected behaviour in some IL2CPP games as we cannot distinguish between true properties and field-properties, so some property accessors will be invoked.

### Inspector

The inspector is used to see detailed information on objects of any type and manipulate their values, as well as to inspect C# Classes with static reflection.

* The <b>GameObject Inspector</b> (tab prefix `[G]`) is used to inspect a `GameObject`, and to see and manipulate its Transform and Components.
  * You can edit any of the input fields in the inspector (excluding readonly fields) and press <b>Enter</b> to apply your changes. You can also do this to the GameObject path as a way to change the GameObject's parent. Press the <b>Escape</b> key to cancel your edits.
  * <i>note: When inspecting a GameObject with a Canvas, the transform controls may be overridden by the RectTransform anchors.</i>
* The <b>Reflection Inspectors</b> (tab prefix `[R]` and `[S]`) are used for everything else
  * Automatic updating is not enabled by default, and you must press Apply for any changes you make to take effect.
  * Press the `â–¼` button to expand certain values such as strings, enums, lists, dictionaries, some structs, etc
  * Use the filters at the top to quickly find the members you are looking for
  * For `Texture2D` objects, there is a `View Texture` button at the top of the inspector which lets you view it and save it as a PNG file. Currently there are no other similar helpers yet, but I may add more at some point for Mesh, Sprite, Material, etc

### C# Console

* The C# Console uses the `Mono.CSharp.Evaluator` to define temporary classes or run immediate REPL code.
* You can execute a script automatically on startup by naming it `startup.cs` and placing it in the `UnityExplorer\Scripts\` folder (this folder will be created where you placed the DLL file).
* See the "Help" dropdown in the C# console menu for more detailed information.

### Hook Manager

* The Hooks panel allows you to hook methods at the click of a button for debugging purposes.
  * Simply enter any class (generic types not yet supported) and hook the methods you want from the menu. 
  * You can edit the source code of the generated hook with the "Edit Hook Source" button. Accepted method names are `Prefix` (which can return `bool` or `void`), `Postfix`, `Finalizer` (which can return `Exception` or `void`), and `Transpiler` (which must return `IEnumerable<HarmonyLib.CodeInstruction>`). You can define multiple patches if you wish.

### Mouse-Inspect

* The "Mouse Inspect" dropdown in the "Inspector" panel allows you to inspect objects under the mouse.
  * <b>World</b>: uses Physics.Raycast to look for Colliders
  * <b>UI</b>: uses GraphicRaycasters to find UI objects

### Clipboard

* The "Clipboard" panel allows you to see your current paste value, or clear it (resets it to `null`)
  * Can copy the value from any member in a Reflection Inspector, Enumerable or Dictionary, and from the target of any Inspector tab
  * Can paste values onto any member in a Reflection Inspector
  * Non-parsable arguments in Method/Property Evaluators allow pasting values
  * The C# Console has helper methods `Copy(obj)` and `Paste()` for accessing the Clipboard

### Settings

* You can change the settings via the "Options" tab of the menu, or directly from the config file.
  * BepInEx: `BepInEx\config\com.sinai.unityexplorer.cfg`
  * MelonLoader: `UserData\MelonPreferences.cfg`
  * Standalone `{DLL_location}\UnityExplorer\config.cfg`

# Building

0. Clone the repository and run `git submodule update --init --recursive` to get the submodules.
1. Open the `src\UnityExplorer.sln` project.
2. Build `mcs` (Release/AnyCPU, you may need to run `nuget restore mcs.sln`)
3. Build the UnityExplorer release(s) you want to use, either by selecting the config as the Active Config, or batch-building.

If you fork the repository on GitHub you can build using the [dotnet workflow](https://github.com/sinai-dev/UnityExplorer/blob/master/.github/workflows/dotnet.yml):

0. Click on the Actions tab and enable workflows in your repository
1. Click on the "Build UnityExplorer" workflow, then click "Run Workflow" and run it manually, or make a new commit to trigger the workflow.
2. Take the artifact from the completed run.

# Acknowledgments

* [ManlyMarco](https://github.com/ManlyMarco) for [Runtime Unity Editor](https://github.com/ManlyMarco/RuntimeUnityEditor) \[[license](THIRDPARTY_LICENSES.md#runtimeunityeditor-license)\], the ScriptEvaluator from RUE's REPL console was used as the base for UnityExplorer's C# console.
* [Geoffrey Horsington](https://github.com/ghorsington) for [mcs-unity](https://github.com/sinai-dev/mcs-unity) \[no license\], used as the `Mono.CSharp` reference for the C# Console.

### Disclaimer

UnityExplorer is in no way associated with Unity Technologies. "Unity", Unity logos, and other Unity trademarks are trademarks or registered trademarks of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`THIRDPARTY_LICENSES.md`:

```md
* [RuntimeUnityEditor License](#runtimeunityeditor-license)
* [MelonLoader License](#melonloader-license)

## RuntimeUnityEditor License

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


## MelonLoader License

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2020 - 2021 Lava Gang

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`src/CSConsole/CSAutoCompleter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.CSConsole.Lexers;
using UnityExplorer.UI;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.CSConsole
{
    public class CSAutoCompleter : ISuggestionProvider
    {
        public InputFieldRef InputField => ConsoleController.Input;

        public bool AnchorToCaretPosition => true;

        bool ISuggestionProvider.AllowNavigation => true;

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            ConsoleController.InsertSuggestionAtCaret(suggestion.UnderlyingValue);
            AutoCompleteModal.Instance.ReleaseOwnership(this);
        }

        private readonly HashSet<char> delimiters = new()
        {
            '{', '}', ',', ';', '<', '>', '(', ')', '[', ']', '=', '|', '&', '?'
        };

        private readonly List<Suggestion> suggestions = new List<Suggestion>();

        public void CheckAutocompletes()
        {
            if (string.IsNullOrEmpty(InputField.Text))
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
                return;
            }

            suggestions.Clear();

            int caret = Math.Max(0, Math.Min(InputField.Text.Length - 1, InputField.Component.caretPosition - 1));
            int startIdx = caret;

            // If the character at the caret index is whitespace or delimiter,
            // or if the next character (if it exists) is not whitespace,
            // then we don't want to provide suggestions.
            if (char.IsWhiteSpace(InputField.Text[caret])
                || delimiters.Contains(InputField.Text[caret])
                || (InputField.Text.Length > caret + 1 && !char.IsWhiteSpace(InputField.Text[caret + 1])))
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
                return;
            }

            // get the current composition string (from caret back to last delimiter)
            while (startIdx > 0)
            {
                startIdx--;
                char c = InputField.Text[startIdx];
                if (delimiters.Contains(c) || char.IsWhiteSpace(c))
                {
                    startIdx++;
                    break;
                }
            }
            string input = InputField.Text.Substring(startIdx, caret - startIdx + 1);

            // Get MCS completions

            string[] evaluatorCompletions = ConsoleController.Evaluator.GetCompletions(input, out string prefix);

            if (evaluatorCompletions != null && evaluatorCompletions.Any())
            {
                suggestions.AddRange(from completion in evaluatorCompletions
                                     select new Suggestion(GetHighlightString(prefix, completion), completion));
            }

            // Get manual namespace completions

            foreach (var ns in ReflectionUtility.AllNamespaces)
            {
                if (ns.StartsWith(input))
                {
                    if (!namespaceHighlights.ContainsKey(ns))
                        namespaceHighlights.Add(ns, $"<color=#CCCCCC>{ns}</color>");

                    string completion = ns.Substring(input.Length, ns.Length - input.Length);
                    suggestions.Add(new Suggestion(namespaceHighlights[ns], completion));
                }
            }

            // Get manual keyword completions

            foreach (var kw in KeywordLexer.keywords)
            {
                if (kw.StartsWith(input))// && kw.Length > input.Length)
                {
                    if (!keywordHighlights.ContainsKey(kw))
                        keywordHighlights.Add(kw, $"<color=#{SignatureHighlighter.keywordBlueHex}>{kw}</color>");

                    string completion = kw.Substring(input.Length, kw.Length - input.Length);
                    suggestions.Add(new Suggestion(keywordHighlights[kw], completion));
                }
            }

            if (suggestions.Any())
            {
                AutoCompleteModal.Instance.TakeOwnership(this);
                AutoCompleteModal.Instance.SetSuggestions(suggestions);
            }
            else
            {
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
        }


        private readonly Dictionary<string, string> namespaceHighlights = new Dictionary<string, string>();

        private readonly Dictionary<string, string> keywordHighlights = new Dictionary<string, string>();

        private readonly StringBuilder highlightBuilder = new StringBuilder();
        private const string OPEN_HIGHLIGHT = "<color=cyan>";

        private string GetHighlightString(string prefix, string completion)
        {
            highlightBuilder.Clear();
            highlightBuilder.Append(OPEN_HIGHLIGHT);
            highlightBuilder.Append(prefix);
            highlightBuilder.Append(SignatureHighlighter.CLOSE_COLOR);
            highlightBuilder.Append(completion);
            return highlightBuilder.ToString();
        }
    }
}

```

`src/CSConsole/ConsoleController.cs`:

```cs
using Mono.CSharp;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UniverseLib.Input;
using UnityExplorer.CSConsole;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib;
using UniverseLib.UI.Models;
using UniverseLib.Utility;
using HarmonyLib;
using UniverseLib.Runtime;

namespace UnityExplorer.CSConsole
{
    public static class ConsoleController
    {
        public static ScriptEvaluator Evaluator;
        public static LexerBuilder Lexer;
        public static CSAutoCompleter Completer;

        private static HashSet<string> usingDirectives;
        private static StringBuilder evaluatorOutput;
        private static StringWriter evaluatorStringWriter;

        public static CSConsolePanel Panel => UIManager.GetPanel<CSConsolePanel>(UIManager.Panels.CSConsole);
        public static InputFieldRef Input => Panel.Input;

        public static int LastCaretPosition { get; private set; }
        internal static float defaultInputFieldAlpha;

        // Todo save as config?
        public static bool EnableCtrlRShortcut { get; private set; } = true;
        public static bool EnableAutoIndent { get; private set; } = true;
        public static bool EnableSuggestions { get; private set; } = true;

        internal static string ScriptsFolder => Path.Combine(ExplorerCore.Loader.ExplorerFolder, "Scripts");

        internal static readonly string[] DefaultUsing = new string[]
        {
            "System",
            "System.Linq",
            "System.Text",
            "System.Collections",
            "System.Collections.Generic",
            "UnityEngine",
#if CPP
            "UnhollowerBaseLib",
            "UnhollowerRuntimeLib",
#endif
        };

        public static void Init()
        {
            InitEventSystemPropertyHandlers();

            // Make sure console is supported on this platform
            try
            {
                ResetConsole(false);
                // ensure the compiler is supported (if this fails then SRE is probably stubbed)
                Evaluator.Compile("0 == 0");
            }
            catch (Exception ex)
            {
                DisableConsole(ex);
                return;
            }

            // Setup console
            Lexer = new LexerBuilder();
            Completer = new CSAutoCompleter();

            SetupHelpInteraction();

            Panel.OnInputChanged += OnInputChanged;
            Panel.InputScroller.OnScroll += OnInputScrolled;
            Panel.OnCompileClicked += Evaluate;
            Panel.OnResetClicked += ResetConsole;
            Panel.OnHelpDropdownChanged += HelpSelected;
            Panel.OnAutoIndentToggled += OnToggleAutoIndent;
            Panel.OnCtrlRToggled += OnToggleCtrlRShortcut;
            Panel.OnSuggestionsToggled += OnToggleSuggestions;
            Panel.OnPanelResized += OnInputScrolled;

            // Run startup script
            try
            {
                if (!Directory.Exists(ScriptsFolder))
                    Directory.CreateDirectory(ScriptsFolder);

                var startupPath = Path.Combine(ScriptsFolder, "startup.cs");
                if (File.Exists(startupPath))
                {
                    ExplorerCore.Log($"Executing startup script from '{startupPath}'...");
                    var text = File.ReadAllText(startupPath);
                    Input.Text = text;
                    Evaluate();
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception executing startup script: {ex}");
            }
        }

        #region UI Listeners and options

        // TODO save

        private static void OnToggleAutoIndent(bool value)
        {
            EnableAutoIndent = value;
        }

        private static void OnToggleCtrlRShortcut(bool value)
        {
            EnableCtrlRShortcut = value;
        }

        private static void OnToggleSuggestions(bool value)
        {
            EnableSuggestions = value;
        }

        #endregion


        #region Evaluating

        private static void GenerateTextWriter()
        {
            evaluatorOutput = new StringBuilder();
            evaluatorStringWriter = new StringWriter(evaluatorOutput);
        }

        public static void ResetConsole() => ResetConsole(true);

        public static void ResetConsole(bool logSuccess = true)
        {
            if (SRENotSupported)
                return;

            if (Evaluator != null)
                Evaluator.Dispose();

            GenerateTextWriter();
            Evaluator = new ScriptEvaluator(evaluatorStringWriter)
            {
                InteractiveBaseClass = typeof(ScriptInteraction)
            };

            usingDirectives = new HashSet<string>();
            foreach (var use in DefaultUsing)
                AddUsing(use);

            if (logSuccess)
                ExplorerCore.Log($"C# Console reset. Using directives:\r\n{Evaluator.GetUsing()}");
        }

        public static void AddUsing(string assemblyName)
        {
            if (!usingDirectives.Contains(assemblyName))
            {
                Evaluate($"using {assemblyName};", true);
                usingDirectives.Add(assemblyName);
            }
        }

        public static void Evaluate()
        {
            if (SRENotSupported)
                return;

            Evaluate(Input.Text);
        }

        public static void Evaluate(string input, bool supressLog = false)
        {
            if (SRENotSupported)
                return;

            if (evaluatorStringWriter == null || evaluatorOutput == null)
            {
                GenerateTextWriter();
                Evaluator._textWriter = evaluatorStringWriter;
            }

            try
            {
                // Compile the code. If it returned a CompiledMethod, it is REPL.
                CompiledMethod repl = Evaluator.Compile(input);

                if (repl != null)
                {
                    // Valid REPL, we have a delegate to the evaluation.
                    try
                    {
                        object ret = null;
                        repl.Invoke(ref ret);
                        var result = ret?.ToString();
                        if (!string.IsNullOrEmpty(result))
                            ExplorerCore.Log($"Invoked REPL, result: {ret}");
                        else
                            ExplorerCore.Log($"Invoked REPL (no return value)");
                    }
                    catch (Exception ex)
                    {
                        ExplorerCore.LogWarning($"Exception invoking REPL: {ex}");
                    }
                }
                else
                {
                    // The compiled code was not REPL, so it was a using directive or it defined classes.

                    string output = Evaluator._textWriter.ToString();
                    var outputSplit = output.Split('\n');
                    if (outputSplit.Length >= 2)
                        output = outputSplit[outputSplit.Length - 2];
                    evaluatorOutput.Clear();

                    if (ScriptEvaluator._reportPrinter.ErrorsCount > 0)
                        throw new FormatException($"Unable to compile the code. Evaluator's last output was:\r\n{output}");
                    else if (!supressLog)
                        ExplorerCore.Log($"Code compiled without errors.");
                }
            }
            catch (FormatException fex)
            {
                if (!supressLog)
                    ExplorerCore.LogWarning(fex.Message);
            }
            catch (Exception ex)
            {
                if (!supressLog)
                    ExplorerCore.LogWarning(ex);
            }
        }

        #endregion


        // Updating and event listeners

        private static bool settingCaretCoroutine;

        private static void OnInputScrolled() => HighlightVisibleInput();

        private static string previousInput;

        // Invoked at most once per frame
        private static void OnInputChanged(string value)
        {
            if (SRENotSupported)
                return;

            // prevent escape wiping input
            if (InputManager.GetKeyDown(KeyCode.Escape))
            {
                Input.Text = previousInput;

                if (EnableSuggestions && AutoCompleteModal.CheckEscape(Completer))
                    OnAutocompleteEscaped();

                return;
            }

            previousInput = value;

            if (EnableSuggestions && AutoCompleteModal.CheckEnter(Completer))
                OnAutocompleteEnter();

            if (!settingCaretCoroutine)
            {
                if (EnableAutoIndent)
                    DoAutoIndent();
            }

            var inStringOrComment = HighlightVisibleInput();

            if (!settingCaretCoroutine)
            {
                if (EnableSuggestions)
                {
                    if (inStringOrComment)
                        AutoCompleteModal.Instance.ReleaseOwnership(Completer);
                    else
                        Completer.CheckAutocompletes();
                }
            }

            UpdateCaret(out _);
        }

        private static float timeOfLastCtrlR;

        public static void Update()
        {
            if (SRENotSupported)
                return;

            UpdateCaret(out bool caretMoved);

            if (!settingCaretCoroutine && EnableSuggestions)
            {
                if (AutoCompleteModal.CheckEscape(Completer))
                {
                    OnAutocompleteEscaped();
                    return;
                }

                if (caretMoved)
                    AutoCompleteModal.Instance.ReleaseOwnership(Completer);
            }

            if (EnableCtrlRShortcut
                && (InputManager.GetKey(KeyCode.LeftControl) || InputManager.GetKey(KeyCode.RightControl))
                && InputManager.GetKeyDown(KeyCode.R)
                && timeOfLastCtrlR.OccuredEarlierThanDefault())
            {
                timeOfLastCtrlR = Time.realtimeSinceStartup;
                Evaluate(Panel.Input.Text);
            }
        }

        private const int CSCONSOLE_LINEHEIGHT = 18;

        private static void UpdateCaret(out bool caretMoved)
        {
            int prevCaret = LastCaretPosition;
            caretMoved = false;

            // Override up/down arrow movement when autocompleting
            if (EnableSuggestions && AutoCompleteModal.CheckNavigation(Completer))
            {
                Input.Component.caretPosition = LastCaretPosition;
                return;
            }

            if (Input.Component.isFocused)
            {
                LastCaretPosition = Input.Component.caretPosition;
                caretMoved = LastCaretPosition != prevCaret;
            }

            if (Input.Text.Length == 0)
                return;

            // If caret moved, ensure caret is visible in the viewport
            if (caretMoved)
            {
                var charInfo = Input.TextGenerator.characters[LastCaretPosition];
                var charTop = charInfo.cursorPos.y;
                var charBot = charTop - CSCONSOLE_LINEHEIGHT;

                var viewportMin = Input.Transform.rect.height - Input.Transform.anchoredPosition.y - (Input.Transform.rect.height * 0.5f);
                var viewportMax = viewportMin - Panel.InputScroller.ViewportRect.rect.height;

                float diff = 0f;
                if (charTop > viewportMin)
                    diff = charTop - viewportMin;
                else if (charBot < viewportMax)
                    diff = charBot - viewportMax;

                if (Math.Abs(diff) > 1)
                {
                    var rect = Input.Transform;
                    rect.anchoredPosition = new Vector2(rect.anchoredPosition.x, rect.anchoredPosition.y - diff);
                }
            }
        }

        private static void SetCaretPosition(int caretPosition)
        {
            settingCaretCoroutine = true;
            Input.Component.readOnly = true;
            RuntimeHelper.StartCoroutine(SetCaretCoroutine(caretPosition));
        }

        static void InitEventSystemPropertyHandlers()
        {
            try
            {
                foreach (var member in typeof(EventSystem).GetMembers(AccessTools.all))
                {
                    if (member.Name == "m_CurrentSelected")
                    {
                        Type backingType;
                        if (member.MemberType == MemberTypes.Property)
                            backingType = (member as PropertyInfo).PropertyType;
                        else
                            backingType = (member as FieldInfo).FieldType;

                        usingEventSystemDictionaryMembers = ReflectionUtility.IsDictionary(backingType);
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception checking EventSystem property backing type: {ex}");
            }
        }

        static bool usingEventSystemDictionaryMembers;

        static readonly AmbiguousMemberHandler<EventSystem, GameObject> m_CurrentSelected_Handler_Normal 
            = new(true, true, "m_CurrentSelected", "m_currentSelected");
        static readonly AmbiguousMemberHandler<EventSystem, Dictionary<int, GameObject>> m_CurrentSelected_Handler_Dictionary 
            = new(true, true, "m_CurrentSelected", "m_currentSelected");

        static readonly AmbiguousMemberHandler<EventSystem, bool> m_SelectionGuard_Handler_Normal 
            = new(true, true, "m_SelectionGuard", "m_selectionGuard");
        static readonly AmbiguousMemberHandler<EventSystem, Dictionary<int, bool>> m_SelectionGuard_Handler_Dictionary 
            = new(true, true, "m_SelectionGuard", "m_selectionGuard");

        static void SetCurrentSelectedGameObject(EventSystem instance, GameObject value)
        {
            instance.SetSelectedGameObject(value);

            if (usingEventSystemDictionaryMembers)
                m_CurrentSelected_Handler_Dictionary.GetValue(instance)[0] = value;
            else
                m_CurrentSelected_Handler_Normal.SetValue(instance, value);
        }

        static void SetSelectionGuard(EventSystem instance, bool value)
        {
            if (usingEventSystemDictionaryMembers)
                m_SelectionGuard_Handler_Dictionary.GetValue(instance)[0] = value;
            else
                m_SelectionGuard_Handler_Normal.SetValue(instance, value);
        }

        private static IEnumerator SetCaretCoroutine(int caretPosition)
        {
            var color = Input.Component.selectionColor;
            color.a = 0f;
            Input.Component.selectionColor = color;

            try { SetCurrentSelectedGameObject(CursorUnlocker.CurrentEventSystem, null); } 
            catch (Exception ex) { ExplorerCore.Log($"Failed removing selected object: {ex}"); }

            yield return null; // ~~~~~~~ YIELD FRAME ~~~~~~~~~

            try { SetSelectionGuard(CursorUnlocker.CurrentEventSystem, false); }
            catch (Exception ex) { ExplorerCore.Log($"Failed setting selection guard: {ex}"); }

            try { SetCurrentSelectedGameObject(CursorUnlocker.CurrentEventSystem, Input.GameObject); } 
            catch (Exception ex) { ExplorerCore.Log($"Failed setting selected gameobject: {ex}"); }

            yield return null; // ~~~~~~~ YIELD FRAME ~~~~~~~~~

            Input.Component.Select();

            Input.Component.caretPosition = caretPosition;
            Input.Component.selectionFocusPosition = caretPosition;
            LastCaretPosition = Input.Component.caretPosition;

            color.a = defaultInputFieldAlpha;
            Input.Component.selectionColor = color;

            Input.Component.readOnly = false;
            settingCaretCoroutine = false;
        }

        #region Lexer Highlighting

        /// <summary>
        /// Returns true if caret is inside string or comment, false otherwise
        /// </summary>
        private static bool HighlightVisibleInput()
        {
            if (string.IsNullOrEmpty(Input.Text))
            {
                Panel.HighlightText.text = "";
                Panel.LineNumberText.text = "1";
                return false;
            }

            // Calculate the visible lines

            int topLine = -1;
            int bottomLine = -1;

            // the top and bottom position of the viewport in relation to the text height
            // they need the half-height adjustment to normalize against the 'line.topY' value.
            var viewportMin = Input.Transform.rect.height - Input.Transform.anchoredPosition.y - (Input.Transform.rect.height * 0.5f);
            var viewportMax = viewportMin - Panel.InputScroller.ViewportRect.rect.height;

            for (int i = 0; i < Input.TextGenerator.lineCount; i++)
            {
                var line = Input.TextGenerator.lines[i];
                // if not set the top line yet, and top of line is below the viewport top
                if (topLine == -1 && line.topY <= viewportMin)
                    topLine = i;
                // if bottom of line is below the viewport bottom
                if ((line.topY - line.height) >= viewportMax)
                    bottomLine = i;
            }

            topLine = Math.Max(0, topLine - 1);
            bottomLine = Math.Min(Input.TextGenerator.lineCount - 1, bottomLine + 1);

            int startIdx = Input.TextGenerator.lines[topLine].startCharIdx;
            int endIdx = (bottomLine >= Input.TextGenerator.lineCount - 1)
                ? Input.Text.Length - 1
                : (Input.TextGenerator.lines[bottomLine + 1].startCharIdx - 1);


            // Highlight the visible text with the LexerBuilder

            Panel.HighlightText.text = Lexer.BuildHighlightedString(Input.Text, startIdx, endIdx, topLine, LastCaretPosition, out bool ret);

            // Set the line numbers

            // determine true starting line number (not the same as the cached TextGenerator line numbers)
            int realStartLine = 0;
            for (int i = 0; i < startIdx; i++)
            {
                if (LexerBuilder.IsNewLine(Input.Text[i]))
                    realStartLine++;
            }
            realStartLine++;
            char lastPrev = '\n';

            var sb = new StringBuilder();

            // append leading new lines for spacing (no point rendering line numbers we cant see)
            for (int i = 0; i < topLine; i++)
                sb.Append('\n');

            // append the displayed line numbers
            for (int i = topLine; i <= bottomLine; i++)
            {
                if (i > 0)
                    lastPrev = Input.Text[Input.TextGenerator.lines[i].startCharIdx - 1];

                // previous line ended with a newline character, this is an actual new line.
                if (LexerBuilder.IsNewLine(lastPrev))
                {
                    sb.Append(realStartLine.ToString());
                    realStartLine++;
                }

                sb.Append('\n');
            }

            Panel.LineNumberText.text = sb.ToString();

            return ret;
        }

        #endregion


        #region Autocompletes

        public static void InsertSuggestionAtCaret(string suggestion)
        {
            settingCaretCoroutine = true;
            Input.Text = Input.Text.Insert(LastCaretPosition, suggestion);

            SetCaretPosition(LastCaretPosition + suggestion.Length);
            LastCaretPosition = Input.Component.caretPosition;
        }

        private static void OnAutocompleteEnter()
        {
            // Remove the new line
            int lastIdx = Input.Component.caretPosition - 1;
            Input.Text = Input.Text.Remove(lastIdx, 1);

            // Use the selected suggestion
            Input.Component.caretPosition = LastCaretPosition;
            Completer.OnSuggestionClicked(AutoCompleteModal.SelectedSuggestion);
        }

        private static void OnAutocompleteEscaped()
        {
            AutoCompleteModal.Instance.ReleaseOwnership(Completer);
            SetCaretPosition(LastCaretPosition);
        }


        #endregion


        #region Auto indenting

        private static int prevContentLen = 0;

        private static void DoAutoIndent()
        {
            if (Input.Text.Length > prevContentLen)
            {
                int inc = Input.Text.Length - prevContentLen;

                if (inc == 1)
                {
                    int caret = Input.Component.caretPosition;
                    Input.Text = Lexer.IndentCharacter(Input.Text, ref caret);
                    Input.Component.caretPosition = caret;
                    LastCaretPosition = caret;
                }
                else
                {
                    // todo indenting for copy+pasted content

                    //ExplorerCore.Log("Content increased by " + inc);
                    //var comp = Input.Text.Substring(PreviousCaretPosition, inc);
                    //ExplorerCore.Log("composition string: " + comp);
                }
            }

            prevContentLen = Input.Text.Length;
        }

        #endregion


        #region "Help" interaction

        private static bool SRENotSupported;

        private static void DisableConsole(Exception ex)
        {
            SRENotSupported = true;
            Input.Component.readOnly = true;
            Input.Component.textComponent.color = "5d8556".ToColor();

            if (ex is NotSupportedException)
            {
                Input.Text = $@"The C# Console has been disabled because System.Reflection.Emit threw an exception: {ex.ReflectionExToString()}

If the game was built with Unity's stubbed netstandard 2.0 runtime, you can fix this with UnityDoorstop:
    * Download the Unity Editor version that the game uses
    * Navigate to the folder:
      - Editor\Data\PlaybackEngines\windowsstandalonesupport\Variations\mono\Managed
      - or, Editor\Data\MonoBleedingEdge\lib\mono\4.5
    * Copy the mscorlib.dll and System.Reflection.Emit DLLs from the folder
    * Make a subfolder in the folder that contains doorstop_config.ini
    * Put the DLLs inside the subfolder
    * Set the 'dllSearchPathOverride' in doorstop_config.ini to the subfolder name";
            }
            else
            {
                Input.Text = $@"The C# Console has been disabled because of an unknown error.
{ex}";
            }
        }

        private static readonly Dictionary<string, string> helpDict = new();

        public static void SetupHelpInteraction()
        {
            var drop = Panel.HelpDropdown;

            helpDict.Add("Help", "");
            helpDict.Add("Usings", HELP_USINGS);
            helpDict.Add("REPL", HELP_REPL);
            helpDict.Add("Classes", HELP_CLASSES);
            helpDict.Add("Coroutines", HELP_COROUTINES);

            foreach (var opt in helpDict)
                drop.options.Add(new Dropdown.OptionData(opt.Key));
        }

        public static void HelpSelected(int index)
        {
            if (index == 0)
                return;

            var helpText = helpDict.ElementAt(index);

            Input.Text = helpText.Value;

            Panel.HelpDropdown.value = 0;
        }


        internal const string STARTUP_TEXT = @"<color=#5d8556>// Welcome to the UnityExplorer C# Console!

// It is recommended to use the Log panel (or a console log window) while using this tool.
// Use the Help dropdown to see detailed examples of how to use the console.

// To execute a script automatically on startup, put the script at 'UnityExplorer\Scripts\startup.cs'</color>";

        internal const string HELP_USINGS = @"// You can add a using directive to any namespace, but you must compile for it to take effect.
// It will remain in effect until you Reset the console.
using UnityEngine.UI;

// To see your current usings, use the ""GetUsing();"" helper.
// Note: You cannot add usings and evaluate REPL at the same time.";

        internal const string HELP_REPL = @"/* REPL (Read-Evaluate-Print-Loop) is a way to execute code immediately.
 * REPL code cannot contain any using directives or classes.
 * The return value of the last line of your REPL will be printed to the log.
 * Variables defined in REPL will exist until you Reset the console.
*/

// eg: This code would print 'Hello, World!', and then print 6 as the return value.
Log(""Hello, world!"");
var x = 5;
++x;

/* The following helpers are available in REPL mode:
 * CurrentTarget;     - System.Object, the target of the active Inspector tab
 * AllTargets;        - System.Object[], the targets of all Inspector tabs
 * Log(obj);          - prints a message to the console log
 * Inspect(obj);      - inspect the object with the Inspector
 * Inspect(someType); - inspect a Type with static reflection
 * Start(enumerator); - Coroutine, starts the IEnumerator as a Coroutine, and returns the Coroutine.
 * Stop(coroutine);   - stop the Coroutine ONLY if it was started with Start(ienumerator).
 * Copy(obj);         - copies the object to the UnityExplorer Clipboard
 * Paste();           - System.Object, the contents of the Clipboard.
 * GetUsing();        - prints the current using directives to the console log
 * GetVars();         - prints the names and values of the REPL variables you have defined
 * GetClasses();      - prints the names and members of the classes you have defined
 * help;              - the default REPL help command, contains additional helpers.
*/";

        internal const string HELP_CLASSES = @"// Classes you compile will exist until the application closes.
// You can soft-overwrite a class by compiling it again with the same name. The old class will still technically exist in memory.

// Compiled classes can be accessed from both inside and outside this console.
// Note: in IL2CPP, you must declare a Namespace to inject these classes with ClassInjector or it will crash the game.

public class HelloWorld
{
    public static void Main()
    {
        UnityExplorer.ExplorerCore.Log(""Hello, world!"");
    }
}

// In REPL, you could call the example method above with ""HelloWorld.Main();""
// Note: The compiler does not allow you to run REPL code and define classes at the same time.

// In REPL, use the ""GetClasses();"" helper to see the classes you have defined since the last Reset.";

        internal const string HELP_COROUTINES = @"// To start a Coroutine directly, use ""Start(SomeCoroutine());"" in REPL mode.

// To declare a coroutine, you will need to compile it separately. For example:
public class MyCoro
{
    public static IEnumerator Main()
    {
        yield return null;
        UnityExplorer.ExplorerCore.Log(""Hello, world after one frame!"");
    }
}
// To run this Coroutine in REPL, it would look like ""Start(MyCoro.Main());""";

        #endregion
    }
}

```

`src/CSConsole/LexerBuilder.cs`:

```cs
using Mono.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CSConsole.Lexers;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.CSConsole
{
    public struct MatchInfo
    {
        public int startIndex;
        public int endIndex;
        public bool isStringOrComment;
        public bool matchToEndOfLine;
        public string htmlColorTag;
    }

    public class LexerBuilder
    {
        #region Core and initialization

        public const char WHITESPACE = ' ';
        public readonly HashSet<char> IndentOpenChars = new HashSet<char> { '{', '(' };
        public readonly HashSet<char> IndentCloseChars = new HashSet<char> { '}', ')' };

        private readonly Lexer[] lexers;
        private readonly HashSet<char> delimiters = new HashSet<char>();

        private readonly StringLexer stringLexer = new StringLexer();
        private readonly CommentLexer commentLexer = new CommentLexer();

        public LexerBuilder()
        {
            lexers = new Lexer[]
            {
                commentLexer,
                stringLexer,
                new SymbolLexer(),
                new NumberLexer(),
                new KeywordLexer(),
            };

            foreach (var matcher in lexers)
            {
                foreach (char c in matcher.Delimiters)
                {
                    if (!delimiters.Contains(c))
                        delimiters.Add(c);
                }
            }
        }

        #endregion

        /// <summary>The last committed index for a match or no-match. Starts at -1 for a new parse.</summary>
        public int CommittedIndex { get; private set; }
        /// <summary>The index of the character we are currently parsing, at minimum it will be CommittedIndex + 1.</summary>
        public int CurrentIndex { get; private set; }

        /// <summary>The current character we are parsing, determined by CurrentIndex.</summary>
        public char Current => !EndOfInput ? currentInput[CurrentIndex] : WHITESPACE;
        /// <summary>The previous character (CurrentIndex - 1), or whitespace if no previous character.</summary>
        public char Previous => CurrentIndex >= 1 ? currentInput[CurrentIndex - 1] : WHITESPACE;

        /// <summary>Returns true if CurrentIndex is >= the current input length.</summary>
        public bool EndOfInput => CurrentIndex > currentEndIdx;
        /// <summary>Returns true if EndOfInput or current character is a new line.</summary>
        public bool EndOrNewLine => EndOfInput || IsNewLine(Current);

        public static bool IsNewLine(char c) => c == '\n' || c == '\r';

        private string currentInput;
        private int currentStartIdx;
        private int currentEndIdx;

        /// <summary>
        /// Parse the range of the string with the Lexer and build a RichText-highlighted representation of it.
        /// </summary>
        /// <param name="input">The entire input string which you want to parse a section (or all) of</param>
        /// <param name="startIdx">The first character you want to highlight</param>
        /// <param name="endIdx">The last character you want to highlight</param>
        /// <param name="leadingLines">The amount of leading empty lines you want before the first character in the return string.</param>
        /// <returns>A string which contains the amount of leading lines specified, as well as the rich-text highlighted section.</returns>
        public string BuildHighlightedString(string input, int startIdx, int endIdx, int leadingLines, int caretIdx, out bool caretInStringOrComment)
        {
            caretInStringOrComment = false;

            if (string.IsNullOrEmpty(input) || endIdx <= startIdx)
                return input;

            currentInput = input;
            currentStartIdx = startIdx;
            currentEndIdx = endIdx;

            var sb = new StringBuilder();

            for (int i = 0; i < leadingLines; i++)
                sb.Append('\n');

            int lastUnhighlighted = startIdx;
            foreach (var match in GetMatches())
            {
                // append non-highlighted text between last match and this
                for (int i = lastUnhighlighted; i < match.startIndex; i++)
                    sb.Append(input[i]);

                // append the highlighted match
                sb.Append(match.htmlColorTag);
                for (int i = match.startIndex; i <= match.endIndex && i <= currentEndIdx; i++)
                    sb.Append(input[i]);
                sb.Append(SignatureHighlighter.CLOSE_COLOR);

                // update the last unhighlighted start index
                lastUnhighlighted = match.endIndex + 1;

                int matchEndIdx = match.endIndex;
                if (match.matchToEndOfLine)
                {
                    while (input.Length - 1 >= matchEndIdx)
                    {
                        matchEndIdx++;
                        if (IsNewLine(input[matchEndIdx]))
                            break;
                    }
                }

                // check caretIdx to determine inStringOrComment state
                if (caretIdx >= match.startIndex && (caretIdx <= (matchEndIdx+1) || (caretIdx >= input.Length && matchEndIdx >= input.Length - 1)))
                    caretInStringOrComment = match.isStringOrComment;
            }

            // Append trailing unhighlighted input
            while (lastUnhighlighted <= endIdx)
            {
                sb.Append(input[lastUnhighlighted]);
                lastUnhighlighted++;
            }

            return sb.ToString();
        }


        // Match builder, iterates through each Lexer and returns all matches found.

        public IEnumerable<MatchInfo> GetMatches()
        {
            CommittedIndex = currentStartIdx - 1;
            Rollback();

            while (!EndOfInput)
            {
                SkipWhitespace();
                bool anyMatch = false;
                int startIndex = CommittedIndex + 1;

                foreach (var lexer in lexers)
                {
                    if (lexer.TryMatchCurrent(this))
                    {
                        anyMatch = true;

                        yield return new MatchInfo
                        {
                            startIndex = startIndex,
                            endIndex = CommittedIndex,
                            htmlColorTag = lexer.ColorTag,
                            isStringOrComment = lexer is StringLexer || lexer is CommentLexer,
                        };
                        break;
                    }
                    else
                        Rollback();
                }

                if (!anyMatch)
                {
                    CurrentIndex = CommittedIndex + 1;
                    Commit();
                }
            }
        }

        // Methods used by the Lexers for interfacing with the current parse process

        public char PeekNext(int amount = 1)
        {
            CurrentIndex += amount;
            return Current;
        }

        public void Commit()
        {
            CommittedIndex = Math.Min(currentEndIdx, CurrentIndex);
        }

        public void Rollback()
        {
            CurrentIndex = CommittedIndex + 1;
        }

        public void RollbackBy(int amount)
        {
            CurrentIndex = Math.Max(CommittedIndex + 1, CurrentIndex - amount);
        }

        public bool IsDelimiter(char character, bool orWhitespace = false, bool orLetterOrDigit = false)
        {
            return delimiters.Contains(character)
                || (orWhitespace && char.IsWhiteSpace(character))
                || (orLetterOrDigit && char.IsLetterOrDigit(character));
        }

        private void SkipWhitespace()
        {
            // peek and commit as long as there is whitespace
            while (!EndOfInput && char.IsWhiteSpace(Current))
            {
                Commit();
                PeekNext();
            }

            if (!char.IsWhiteSpace(Current))
                Rollback();
        }

        #region Auto Indenting

        // Using the Lexer for indenting as it already has what we need to tokenize strings and comments.
        // At the moment this only handles when a single newline or close-delimiter is composed.
        // Does not handle copy+paste or any other characters yet.

        public string IndentCharacter(string input, ref int caretIndex)
        {
            int lastCharIndex = caretIndex - 1;
            char c = input[lastCharIndex];

            // we only want to indent for new lines and close indents
            if (!IsNewLine(c) && !IndentCloseChars.Contains(c))
                return input;

            // perform a light parse up to the caret to determine indent level
            currentInput = input;
            currentStartIdx = 0;
            currentEndIdx = lastCharIndex;
            CommittedIndex = -1;
            Rollback();

            int indent = 0;

            while (!EndOfInput)
            {
                if (CurrentIndex >= lastCharIndex)
                {
                    // reached the caret index
                    if (indent <= 0)
                        break;

                    if (IsNewLine(c))
                        input = IndentNewLine(input, indent, ref caretIndex);
                    else // closing indent
                        input = IndentCloseDelimiter(input, indent, lastCharIndex, ref caretIndex);

                    break;
                }

                // Try match strings and comments (Lexer will commit to the end of the match)
                if (stringLexer.TryMatchCurrent(this) || commentLexer.TryMatchCurrent(this))
                {
                    PeekNext();
                    continue;
                }

                // Still parsing, check indent

                if (IndentOpenChars.Contains(Current))
                    indent++;
                else if (IndentCloseChars.Contains(Current))
                    indent--;

                Commit();
                PeekNext();
            }

            return input;
        }

        private string IndentNewLine(string input, int indent, ref int caretIndex)
        {
            // continue until the end of line or next non-whitespace character.
            // if there's a close-indent on this line, reduce the indent level.
            while (CurrentIndex < input.Length - 1)
            {
                CurrentIndex++;
                char next = input[CurrentIndex];
                if (IsNewLine(next))
                    break;
                if (char.IsWhiteSpace(next))
                    continue;
                else if (IndentCloseChars.Contains(next))
                    indent--;

                break;
            }

            if (indent > 0)
            {
                input = input.Insert(caretIndex, new string('\t', indent));
                caretIndex += indent;
            }

            return input;
        }

        private string IndentCloseDelimiter(string input, int indent, int lastCharIndex, ref int caretIndex)
        {
            if (CurrentIndex > lastCharIndex)
            {
                return input;
            }

            // lower the indent level by one as we would not have accounted for this closing symbol
            indent--;

            // go back from the caret to the start of the line, calculate how much indent we need to adjust.
            while (CurrentIndex > 0)
            {
                CurrentIndex--;
                char prev = input[CurrentIndex];
                if (IsNewLine(prev))
                    break;
                if (!char.IsWhiteSpace(prev))
                {
                    // the line containing the closing bracket has non-whitespace characters before it. do not indent.
                    indent = 0;
                    break;
                }
                else if (prev == '\t')
                    indent--;
            }

            if (indent > 0)
            {
                input = input.Insert(caretIndex, new string('\t', indent));
                caretIndex += indent;
            }
            else if (indent < 0)
            {
                // line is overly indented
                input = input.Remove(lastCharIndex - 1, -indent);
                caretIndex += indent;
            }

            return input;
        }

        #endregion
    }
}

```

`src/CSConsole/Lexers/CommentLexer.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace UnityExplorer.CSConsole.Lexers
{
    public class CommentLexer : Lexer
    {
        private enum CommentType
        {
            Line,
            Block
        }

        // forest green
        protected override Color HighlightColor => new Color(0.34f, 0.65f, 0.29f, 1.0f);

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            if (lexer.Current == '/')
            {
                lexer.PeekNext();
                if (lexer.Current == '/')
                {
                    // line comment. read to end of line or file.
                    do
                    {
                        lexer.Commit();
                        lexer.PeekNext();
                    }
                    while (!lexer.EndOrNewLine);

                    return true;
                }
                else if (lexer.Current == '*')
                {
                    // block comment, read until end of file or closing '*/'
                    lexer.PeekNext();
                    do
                    {
                        lexer.PeekNext();
                        lexer.Commit();
                    }
                    while (!lexer.EndOfInput && !(lexer.Current == '/' && lexer.Previous == '*'));

                    return true;
                }
            }

            return false;
        }
    }
}

```

`src/CSConsole/Lexers/KeywordLexer.cs`:

```cs
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace UnityExplorer.CSConsole.Lexers
{
    public class KeywordLexer : Lexer
    {
        // system blue
        protected override Color HighlightColor => new Color(0.33f, 0.61f, 0.83f, 1.0f);

        public static readonly HashSet<string> keywords = new HashSet<string>
        {
// reserved keywords
"abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue",
"decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally",
"fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
"long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
"readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch",
"this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void",
"volatile", "while",
// contextual keywords
"add", "and", "alias", "ascending", "async", "await", "by", "descending", "dynamic", "equals", "from", "get",
"global", "group", "init", "into", "join", "let", "managed", "nameof",  "not", "notnull", "on",
"or", "orderby", "partial", "record", "remove", "select", "set", "unmanaged", "value", "var", "when", "where",
"where", "with", "yield", "nint", "nuint"
        };

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            var prev = lexer.Previous;
            var first = lexer.Current;

            // check for keywords
            if (lexer.IsDelimiter(prev, true) && char.IsLetter(first))
            {
                // can be a keyword...

                var sb = new StringBuilder();
                sb.Append(lexer.Current);
                while (!lexer.EndOfInput && char.IsLetter(lexer.PeekNext()))
                    sb.Append(lexer.Current);

                // next must be whitespace or delimiter
                if (!lexer.EndOfInput && !(char.IsWhiteSpace(lexer.Current) || lexer.IsDelimiter(lexer.Current)))
                    return false;

                if (keywords.Contains(sb.ToString()))
                {
                    if (!lexer.EndOfInput)
                        lexer.RollbackBy(1);
                    lexer.Commit();
                    return true;
                }

                return false;

            }
            else
                return false;
        }
    }
}

```

`src/CSConsole/Lexers/Lexer.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.CSConsole.Lexers
{
    public abstract class Lexer
    {
        public virtual IEnumerable<char> Delimiters => Enumerable.Empty<char>();

        protected abstract Color HighlightColor { get; }

        public string ColorTag => colorTag ?? (colorTag = "<color=#" + HighlightColor.ToHex() + ">");
        private string colorTag;

        public abstract bool TryMatchCurrent(LexerBuilder lexer);
    }
}

```

`src/CSConsole/Lexers/NumberLexer.cs`:

```cs
using UnityEngine;

namespace UnityExplorer.CSConsole.Lexers
{
    public class NumberLexer : Lexer
    {
        // Maroon
        protected override Color HighlightColor => new Color(0.58f, 0.33f, 0.33f, 1.0f);

        private bool IsNumeric(char c) => char.IsNumber(c) || c == '.';

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            // previous character must be whitespace or delimiter
            if (!lexer.IsDelimiter(lexer.Previous, true))
                return false;

            if (!IsNumeric(lexer.Current))
                return false;

            while (!lexer.EndOfInput)
            {
                lexer.Commit();
                if (!IsNumeric(lexer.PeekNext()))
                    break;
            }

            return true;
        }
    }

}

```

`src/CSConsole/Lexers/StringLexer.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;

namespace UnityExplorer.CSConsole.Lexers
{
    public class StringLexer : Lexer
    {
        public override IEnumerable<char> Delimiters => new[] { '"', '\'', };

        // orange
        protected override Color HighlightColor => new Color(0.79f, 0.52f, 0.32f, 1.0f);

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            if (lexer.Current == '"')
            {
                if (lexer.Previous == '@')
                {
                    // verbatim string, continue until un-escaped quote.
                    while (!lexer.EndOfInput)
                    {
                        lexer.Commit();
                        if (lexer.PeekNext() == '"')
                        {
                            lexer.Commit();
                            // possibly the end, check for escaped quotes.
                            // commit the character and flip the escape bool for each quote.
                            bool escaped = false;
                            while (lexer.PeekNext() == '"')
                            {
                                lexer.Commit();
                                escaped = !escaped;
                            }
                            // if the last quote wasnt escaped, that was the end of the string.
                            if (!escaped)
                                break;
                        }
                    }
                }
                else
                {
                    // normal string
                    // continue until a quote which is not escaped, or end of input

                    while (!lexer.EndOfInput)
                    {
                        lexer.Commit();
                        lexer.PeekNext();
                        if ((lexer.Current == '"') && lexer.Previous != '\\')
                        {
                            lexer.Commit();
                            break;
                        }
                    }
                }

                return true;
            }
            else if (lexer.Current == '\'')
            {
                // char

                while (!lexer.EndOfInput)
                {
                    lexer.Commit();
                    lexer.PeekNext();
                    if ((lexer.Current == '\'') && lexer.Previous != '\\')
                    {
                        lexer.Commit();
                        break;
                    }
                }

                return true;
            }
            else
                return false;
        }
    }
}

```

`src/CSConsole/Lexers/SymbolLexer.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace UnityExplorer.CSConsole.Lexers
{
    public class SymbolLexer : Lexer
    {
        // silver
        protected override Color HighlightColor => new Color(0.6f, 0.6f, 0.6f);

        // all symbols are delimiters
        public override IEnumerable<char> Delimiters => symbols.Where(it => it != '.'); // '.' is not a delimiter, only a separator.

        public static bool IsSymbol(char c) => symbols.Contains(c);

        public static readonly HashSet<char> symbols = new HashSet<char>
        {
            '[', '{', '(',                  // open
            ']', '}', ')',                  // close
            '.', ',', ';', ':', '?', '@',   // special

            // operators
            '+', '-', '*', '/', '%', '&', '|', '^', '~', '=', '<', '>', '!',
        };

        public override bool TryMatchCurrent(LexerBuilder lexer)
        {
            // previous character must be delimiter, whitespace, or alphanumeric.
            if (!lexer.IsDelimiter(lexer.Previous, true, true))
                return false;

            if (IsSymbol(lexer.Current))
            {
                do
                {
                    lexer.Commit();
                    lexer.PeekNext();
                }
                while (IsSymbol(lexer.Current));

                return true;
            }

            return false;
        }
    }
}

```

`src/CSConsole/ScriptEvaluator.cs`:

```cs
using Mono.CSharp;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

// Thanks to ManlyMarco for this

namespace UnityExplorer.CSConsole
{
    public class ScriptEvaluator : Evaluator, IDisposable
    {
        private static readonly HashSet<string> StdLib = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase)
        {
            "mscorlib", "System.Core", "System", "System.Xml"
        };

        internal TextWriter _textWriter;
        internal static StreamReportPrinter _reportPrinter;

        public ScriptEvaluator(TextWriter tw) : base(BuildContext(tw))
        {
            _textWriter = tw;

            ImportAppdomainAssemblies(Reference);
            AppDomain.CurrentDomain.AssemblyLoad += OnAssemblyLoad;
        }

        public void Dispose()
        {
            AppDomain.CurrentDomain.AssemblyLoad -= OnAssemblyLoad;
            _textWriter.Dispose();
        }

        private void OnAssemblyLoad(object sender, AssemblyLoadEventArgs args)
        {
            string name = args.LoadedAssembly.GetName().Name;

            if (StdLib.Contains(name))
                return;

            Reference(args.LoadedAssembly);
        }

        private void Reference(Assembly asm)
        {
            var name = asm.GetName().Name;
            if (name == "completions")
                return;
            ReferenceAssembly(asm);
        }

        private static CompilerContext BuildContext(TextWriter tw)
        {
            _reportPrinter = new StreamReportPrinter(tw);

            var settings = new CompilerSettings
            {
                Version = LanguageVersion.Experimental,
                GenerateDebugInfo = false,
                StdLib = true,
                Target = Target.Library,
                WarningLevel = 0,
                EnhancedWarnings = false
            };

            return new CompilerContext(settings, _reportPrinter);
        }

        private static void ImportAppdomainAssemblies(Action<Assembly> import)
        {
            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                string name = assembly.GetName().Name;
                if (StdLib.Contains(name))
                    continue;

                import(assembly);
            }
        }
    }
}

```

`src/CSConsole/ScriptInteraction.cs`:

```cs
using HarmonyLib;
using Mono.CSharp;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.Runtime;
using UnityExplorer.UI.Panels;
using UniverseLib;

namespace UnityExplorer.CSConsole
{
    public class ScriptInteraction : InteractiveBase
    {
        public static object CurrentTarget
            => InspectorManager.ActiveInspector?.Target;

        public static object[] AllTargets
            => InspectorManager.Inspectors.Select(it => it.Target).ToArray();

        public static void Log(object message)
            => ExplorerCore.Log(message);

        public static void Inspect(object obj)
            => InspectorManager.Inspect(obj);

        public static void Inspect(Type type)
            => InspectorManager.Inspect(type);

        public static Coroutine Start(IEnumerator ienumerator) 
            => RuntimeHelper.StartCoroutine(ienumerator);

        public static void Stop(Coroutine coro)
            => RuntimeHelper.StopCoroutine(coro);

        public static void Copy(object obj) 
            => ClipboardPanel.Copy(obj);

        public static object Paste() 
            => ClipboardPanel.Current;

        public static void GetUsing()
            => Log(Evaluator.GetUsing());

        public static void GetVars()
        {
            var vars = Evaluator.GetVars()?.Trim();
            if (string.IsNullOrEmpty(vars))
                ExplorerCore.LogWarning("No variables seem to be defined!");
            else
                Log(vars);
        }

        public static void GetClasses()
        {
            if (AccessTools.Field(typeof(Evaluator), "source_file")
                    .GetValue(Evaluator) is CompilationSourceFile sourceFile
                && sourceFile.Containers.Any())
            {
                var sb = new StringBuilder();
                sb.Append($"There are {sourceFile.Containers.Count} defined classes:");
                foreach (TypeDefinition type in sourceFile.Containers.Where(it => it is TypeDefinition))
                {
                    sb.Append($"\n\n{type.MemberName.Name}:");
                    foreach (var member in type.Members)
                        sb.Append($"\n\t- {member.AttributeTargets}: \"{member.MemberName.Name}\" ({member.ModFlags})");
                }
                Log(sb.ToString());
            }
            else
                ExplorerCore.LogWarning("No classes seem to be defined.");

        }
    }
}

```

`src/CacheObject/CacheConfigEntry.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.Config;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public class CacheConfigEntry : CacheObjectBase
    {
        public CacheConfigEntry(IConfigElement configElement)
        {
            this.RefConfigElement = configElement;
            this.FallbackType = configElement.ElementType;

            this.NameLabelText = $"<color=cyan>{configElement.Name}</color>" +
                $"\r\n<color=grey><i>{configElement.Description}</i></color>";
            this.NameLabelTextRaw = string.Empty;

            configElement.OnValueChangedNotify += UpdateValueFromSource;
        }

        public IConfigElement RefConfigElement;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => true;

        public void UpdateValueFromSource()
        {
            //if (RefConfigElement.BoxedValue.Equals(this.Value))
            //    return;

            SetValueFromSource(RefConfigElement.BoxedValue);

            if (this.CellView != null)
                this.SetDataToCell(CellView);
        }

        public override void TrySetUserValue(object value)
        {
            this.Value = value;
            RefConfigElement.BoxedValue = value;
        }

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheConstructor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityExplorer.Inspectors;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject
{
    public class CacheConstructor : CacheMember
    {
        public ConstructorInfo CtorInfo { get; }
        readonly Type typeForStructConstructor;

        public override Type DeclaringType => typeForStructConstructor ?? CtorInfo.DeclaringType;
        public override bool IsStatic => true;
        public override bool ShouldAutoEvaluate => false;
        public override bool CanWrite => false;

        public CacheConstructor(ConstructorInfo ci)
        {
            this.CtorInfo = ci;
        }

        public CacheConstructor(Type typeForStructConstructor)
        {
            this.typeForStructConstructor = typeForStructConstructor;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            Type ctorReturnType;
            // if is parameterless struct ctor
            if (typeForStructConstructor != null)
            {
                ctorReturnType = typeForStructConstructor;
                this.Owner = inspector;

                // eg. Vector3.Vector3()
                this.NameLabelText = SignatureHighlighter.Parse(typeForStructConstructor, false);
                NameLabelText += $".{NameLabelText}()";

                this.NameForFiltering = SignatureHighlighter.RemoveHighlighting(NameLabelText);
                this.NameLabelTextRaw = NameForFiltering;
                return;
            }
            else
            {
                base.SetInspectorOwner(inspector, member);

                Arguments = CtorInfo.GetParameters();
                ctorReturnType = CtorInfo.DeclaringType;
            }
            
            if (ctorReturnType.IsGenericTypeDefinition)
                GenericArguments = ctorReturnType.GetGenericArguments();
        }

        protected override object TryEvaluate()
        {
            try
            {
                Type returnType = DeclaringType;

                if (returnType.IsGenericTypeDefinition)
                    returnType = DeclaringType.MakeGenericType(Evaluator.TryParseGenericArguments());

                object ret;
                if (HasArguments)
                    ret = Activator.CreateInstance(returnType, Evaluator.TryParseArguments());
                else
                    ret = Activator.CreateInstance(returnType, ArgumentUtility.EmptyArgs);

                HadException = false;
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                HadException = true;
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value) => throw new NotImplementedException("You can't set a constructor");
    }
}

```

`src/CacheObject/CacheField.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityExplorer.Inspectors;

namespace UnityExplorer.CacheObject
{
    public class CacheField : CacheMember
    {
        public FieldInfo FieldInfo { get; internal set; }
        public override Type DeclaringType => FieldInfo.DeclaringType;
        public override bool IsStatic => FieldInfo.IsStatic;
        public override bool CanWrite => m_canWrite ?? (bool)(m_canWrite = !(FieldInfo.IsLiteral && !FieldInfo.IsInitOnly));
        private bool? m_canWrite;

        public override bool ShouldAutoEvaluate => true;

        public CacheField(FieldInfo fi)
        {
            this.FieldInfo = fi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);
        }

        protected override object TryEvaluate()
        {
            try
            {
                var ret = FieldInfo.GetValue(DeclaringInstance);
                HadException = false;
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                HadException = true;
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value)
        {
            try
            {
                FieldInfo.SetValue(DeclaringInstance, value);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning(ex);
            }
        }
    }
}

```

`src/CacheObject/CacheKeyValuePair.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject
{
    public class CacheKeyValuePair : CacheObjectBase
    {
        //public InteractiveList CurrentList { get; set; }

        public int DictIndex;
        public object DictKey;
        public object DisplayedKey;

        public bool KeyInputWanted;
        public bool InspectWanted;
        public string KeyLabelText;
        public string KeyInputText;
        public string KeyInputTypeText;

        public float DesiredKeyWidth;
        public float DesiredValueWidth;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => Owner.CanWrite;

        public void SetDictOwner(InteractiveDictionary dict, int index)
        {
            this.Owner = dict;
            this.DictIndex = index;
        }

        public void SetKey(object key)
        {
            this.DictKey = key;
            this.DisplayedKey = key.TryCast();

            var type = DisplayedKey.GetType();
            if (ParseUtility.CanParse(type))
            {
                KeyInputWanted = true;
                KeyInputText = ParseUtility.ToStringForInput(DisplayedKey, type);
                KeyInputTypeText = SignatureHighlighter.Parse(type, false);
            }
            else
            {
                KeyInputWanted = false;
                InspectWanted = type != typeof(bool) && !type.IsEnum;
                KeyLabelText = ToStringUtility.ToStringWithType(DisplayedKey, type, true);
            }
        }

        public override void SetDataToCell(CacheObjectCell cell)
        {
            base.SetDataToCell(cell);

            var kvpCell = cell as CacheKeyValuePairCell;

            kvpCell.NameLabel.text = $"{DictIndex}:";
            kvpCell.HiddenNameLabel.Text = "";
            kvpCell.Image.color = DictIndex % 2 == 0 ? CacheListEntryCell.EvenColor : CacheListEntryCell.OddColor;

            if (KeyInputWanted)
            {
                kvpCell.KeyInputField.UIRoot.SetActive(true);
                kvpCell.KeyInputTypeLabel.gameObject.SetActive(true);
                kvpCell.KeyLabel.gameObject.SetActive(false);
                kvpCell.KeyInspectButton.Component.gameObject.SetActive(false);

                kvpCell.KeyInputField.Text = KeyInputText;
                kvpCell.KeyInputTypeLabel.text = KeyInputTypeText;
            }
            else
            {
                kvpCell.KeyInputField.UIRoot.SetActive(false);
                kvpCell.KeyInputTypeLabel.gameObject.SetActive(false);
                kvpCell.KeyLabel.gameObject.SetActive(true);
                kvpCell.KeyInspectButton.Component.gameObject.SetActive(InspectWanted);

                kvpCell.KeyLabel.text = KeyLabelText;
            }
        }

        public override void TrySetUserValue(object value)
        {
            (Owner as InteractiveDictionary).TrySetValueToKey(DictKey, value, DictIndex);
        }


        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheListEntry.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public class CacheListEntry : CacheObjectBase
    {
        public int ListIndex;

        public override bool ShouldAutoEvaluate => true;
        public override bool HasArguments => false;
        public override bool CanWrite => Owner?.CanWrite ?? false;

        public void SetListOwner(InteractiveList list, int listIndex)
        {
            this.Owner = list;
            this.ListIndex = listIndex;
        }

        public override void SetDataToCell(CacheObjectCell cell)
        {
            base.SetDataToCell(cell);

            var listCell = cell as CacheListEntryCell;

            listCell.NameLabel.text = $"{ListIndex}:";
            listCell.HiddenNameLabel.Text = "";
            listCell.Image.color = ListIndex % 2 == 0 ? CacheListEntryCell.EvenColor : CacheListEntryCell.OddColor;
        }

        public override void TrySetUserValue(object value)
        {
            (Owner as InteractiveList).TrySetValueToIndex(value, this.ListIndex);
        }

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell) => true;
    }
}

```

`src/CacheObject/CacheMember.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityExplorer.Runtime;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Inspectors;
using UniverseLib.UI.Models;
using UnityExplorer.UI;
using UniverseLib;
using UniverseLib.UI;
using UnityExplorer.UI.Widgets;
using UniverseLib.Utility;
using UniverseLib.UI.ObjectPool;
using System.Collections;
using HarmonyLib;

namespace UnityExplorer.CacheObject
{
    public abstract class CacheMember : CacheObjectBase
    {
        public abstract Type DeclaringType { get; }
        public string NameForFiltering { get; protected set; }
        public object DeclaringInstance => IsStatic ? null : (m_declaringInstance ??= Owner.Target.TryCast(DeclaringType));
        private object m_declaringInstance;

        public abstract bool IsStatic { get; }
        public override bool HasArguments => Arguments?.Length > 0 || GenericArguments.Length > 0;
        public ParameterInfo[] Arguments { get; protected set; } = new ParameterInfo[0];
        public Type[] GenericArguments { get; protected set; } = ArgumentUtility.EmptyTypes;
        public EvaluateWidget Evaluator { get; protected set; }
        public bool Evaluating => Evaluator != null && Evaluator.UIRoot.activeSelf;

        public virtual void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            this.Owner = inspector;
            this.NameLabelText = this switch
            {
                CacheMethod => SignatureHighlighter.HighlightMethod(member as MethodInfo),
                CacheConstructor => SignatureHighlighter.HighlightConstructor(member as ConstructorInfo),
                _ => SignatureHighlighter.Parse(member.DeclaringType, false, member),
            };

            this.NameForFiltering = SignatureHighlighter.RemoveHighlighting(NameLabelText);
            this.NameLabelTextRaw = NameForFiltering;
        }

        public override void ReleasePooledObjects()
        {
            base.ReleasePooledObjects();

            if (this.Evaluator != null)
            {
                this.Evaluator.OnReturnToPool();
                Pool<EvaluateWidget>.Return(this.Evaluator);
                this.Evaluator = null;
            }
        }

        public override void UnlinkFromView()
        {
            if (this.Evaluator != null)
                this.Evaluator.UIRoot.transform.SetParent(Pool<EvaluateWidget>.Instance.InactiveHolder.transform, false);

            base.UnlinkFromView();
        }

        protected abstract object TryEvaluate();

        protected abstract void TrySetValue(object value);

        /// <summary>
        /// Evaluate is called when first shown (if ShouldAutoEvaluate), or else when Evaluate button is clicked, or auto-updated.
        /// </summary>
        public void Evaluate()
        {
            SetValueFromSource(TryEvaluate());
        }

        /// <summary>
        /// Called when user presses the Evaluate button.
        /// </summary>
        public void EvaluateAndSetCell()
        {
            Evaluate();
            if (CellView != null)
                SetDataToCell(CellView);
        }

        public override void TrySetUserValue(object value)
        {
            TrySetValue(value);
            Evaluate();
        }

        protected override void SetValueState(CacheObjectCell cell, ValueStateArgs args)
        {
            base.SetValueState(cell, args);
        }

        private static readonly Color evalEnabledColor = new(0.15f, 0.25f, 0.15f);
        private static readonly Color evalDisabledColor = new(0.15f, 0.15f, 0.15f);

        protected override bool TryAutoEvaluateIfUnitialized(CacheObjectCell objectcell)
        {
            var cell = objectcell as CacheMemberCell;

            cell.EvaluateHolder.SetActive(!ShouldAutoEvaluate);
            if (!ShouldAutoEvaluate)
            {
                cell.EvaluateButton.Component.gameObject.SetActive(true);
                if (HasArguments)
                {
                    if (!Evaluating)
                        cell.EvaluateButton.ButtonText.text = $"Evaluate ({Arguments.Length + GenericArguments.Length})";
                    else
                    {
                        cell.EvaluateButton.ButtonText.text = "Hide";
                        Evaluator.UIRoot.transform.SetParent(cell.EvaluateHolder.transform, false);
                        RuntimeHelper.SetColorBlock(cell.EvaluateButton.Component, evalEnabledColor, evalEnabledColor * 1.3f);
                    }
                }
                else
                    cell.EvaluateButton.ButtonText.text = "Evaluate";

                if (!Evaluating)
                    RuntimeHelper.SetColorBlock(cell.EvaluateButton.Component, evalDisabledColor, evalDisabledColor * 1.3f);
            }

            if (State == ValueState.NotEvaluated && !ShouldAutoEvaluate)
            {
                SetValueState(cell, ValueStateArgs.Default);
                cell.RefreshSubcontentButton();

                return false;
            }

            if (State == ValueState.NotEvaluated)
                Evaluate();

            return true;
        }

        public void OnEvaluateClicked()
        {
            if (!HasArguments)
            {
                EvaluateAndSetCell();
            }
            else
            {
                if (Evaluator == null)
                {
                    this.Evaluator = Pool<EvaluateWidget>.Borrow();
                    Evaluator.OnBorrowedFromPool(this);
                    Evaluator.UIRoot.transform.SetParent((CellView as CacheMemberCell).EvaluateHolder.transform, false);
                    TryAutoEvaluateIfUnitialized(CellView);
                }
                else
                {
                    if (Evaluator.UIRoot.activeSelf)
                        Evaluator.UIRoot.SetActive(false);
                    else
                        Evaluator.UIRoot.SetActive(true);

                    TryAutoEvaluateIfUnitialized(CellView);
                }
            }
        }
    }
}

```

`src/CacheObject/CacheMemberFactory.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityExplorer.Inspectors;
using UnityExplorer.Runtime;
using UniverseLib;
using HarmonyLib;
using HarmonyLib.Tools;

namespace UnityExplorer.CacheObject
{
    public static class CacheMemberFactory
    {
        public static List<CacheMember> GetCacheMembers(Type type, ReflectionInspector inspector)
        {
            //var list = new List<CacheMember>();
            HashSet<string> cachedSigs = new();
            List<CacheMember> props = new();
            List<CacheMember> fields = new();
            List<CacheMember> ctors = new();
            List<CacheMember> methods = new();

            var types = ReflectionUtility.GetAllBaseTypes(type);

            var flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static;
            if (!inspector.StaticOnly)
                flags |= BindingFlags.Instance;

            if (!type.IsAbstract)
            {
                // Get non-static constructors of the main type.
                // There's no reason to get the static cctor, it will be invoked when we inspect the class.
                // Also no point getting ctors on inherited types.
                foreach (var ctor in type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
                    TryCacheMember(ctor, ctors, cachedSigs, type, inspector);

                // structs always have a parameterless constructor
                if (type.IsValueType)
                {
                    CacheConstructor cached = new(type);
                    cached.SetFallbackType(type);
                    cached.SetInspectorOwner(inspector, null);
                    ctors.Add(cached);
                }
            }

            foreach (var declaringType in types)
            {
                foreach (var prop in declaringType.GetProperties(flags))
                    if (prop.DeclaringType == declaringType)
                        TryCacheMember(prop, props, cachedSigs, declaringType, inspector);

                foreach (var field in declaringType.GetFields(flags))
                    if (field.DeclaringType == declaringType)
                        TryCacheMember(field, fields, cachedSigs, declaringType, inspector);

                foreach (var method in declaringType.GetMethods(flags))
                    if (method.DeclaringType == declaringType)
                        TryCacheMember(method, methods, cachedSigs, declaringType, inspector);

            }

            var sorted = new List<CacheMember>();
            sorted.AddRange(props.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(fields.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(ctors.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            sorted.AddRange(methods.OrderBy(it => Array.IndexOf(types, it.DeclaringType))
                                 .ThenBy(it => it.NameForFiltering));
            return sorted;
        }

        static void TryCacheMember<T>(MemberInfo member, List<T> list, HashSet<string> cachedSigs, 
            Type declaringType, ReflectionInspector inspector, bool ignorePropertyMethodInfos = true) 
            where T : CacheMember
        {
            try
            {
                if (UERuntimeHelper.IsBlacklisted(member))
                    return;

                string sig = member switch
                {
                    // method or constructor
                    MethodBase mb => mb.FullDescription(),
                    // property or field
                    PropertyInfo or FieldInfo => $"{member.DeclaringType.FullDescription()}.{member.Name}",
                    _ => throw new NotImplementedException(),
                };

                if (cachedSigs.Contains(sig))
                    return;

                // ExplorerCore.Log($"Trying to cache member {sig}... ({member.MemberType})");

                CacheMember cached;
                Type returnType;

                switch (member.MemberType)
                {
                    case MemberTypes.Constructor:
                        {
                            var ci = member as ConstructorInfo;
                            cached = new CacheConstructor(ci);
                            returnType = ci.DeclaringType;
                        }
                        break;

                    case MemberTypes.Method:
                        {
                            var mi = member as MethodInfo;
                            if (ignorePropertyMethodInfos
                                && (mi.Name.StartsWith("get_") || mi.Name.StartsWith("set_")))
                                return;

                            cached = new CacheMethod(mi);
                            returnType = mi.ReturnType;
                            break;
                        }

                    case MemberTypes.Property:
                        {
                            var pi = member as PropertyInfo;

                            if (!pi.CanRead && pi.CanWrite)
                            {
                                // write-only property, cache the set method instead.
                                var setMethod = pi.GetSetMethod(true);
                                if (setMethod != null)
                                    TryCacheMember(setMethod, list, cachedSigs, declaringType, inspector, false);
                                return;
                            }

                            cached = new CacheProperty(pi);
                            returnType = pi.PropertyType;
                            break;
                        }

                    case MemberTypes.Field:
                        {
                            var fi = member as FieldInfo;
                            cached = new CacheField(fi);
                            returnType = fi.FieldType;
                            break;
                        }

                    default:
                        throw new NotImplementedException();
                }

                cachedSigs.Add(sig);

                cached.SetFallbackType(returnType);
                cached.SetInspectorOwner(inspector, member);

                list.Add((T)cached);
            }
            catch (Exception e)
            {
                ExplorerCore.LogWarning($"Exception caching member {member.DeclaringType.FullName}.{member.Name}!");
                ExplorerCore.Log(e);
            }
        }
    }
}

```

`src/CacheObject/CacheMethod.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityExplorer.Inspectors;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject
{
    public class CacheMethod : CacheMember
    {
        public MethodInfo MethodInfo { get; }
        public override Type DeclaringType => MethodInfo.DeclaringType;
        public override bool CanWrite => false;
        public override bool IsStatic => MethodInfo.IsStatic;

        public override bool ShouldAutoEvaluate => false;

        public CacheMethod (MethodInfo mi)
        {
            this.MethodInfo = mi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);

            Arguments = MethodInfo.GetParameters();
            if (MethodInfo.IsGenericMethod)
                GenericArguments = MethodInfo.GetGenericArguments();
        }

        protected override object TryEvaluate()
        {
            try
            {
                var methodInfo = MethodInfo;
                if (methodInfo.IsGenericMethod)
                    methodInfo = MethodInfo.MakeGenericMethod(Evaluator.TryParseGenericArguments());

                object ret;
                if (HasArguments)
                    ret = methodInfo.Invoke(DeclaringInstance, Evaluator.TryParseArguments());
                else 
                    ret = methodInfo.Invoke(DeclaringInstance, ArgumentUtility.EmptyArgs);
                HadException = false;
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                HadException = true;
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value) => throw new NotImplementedException("You can't set a method");
    }
}

```

`src/CacheObject/CacheObjectBase.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Runtime;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.CacheObject.Views;
using UniverseLib.UI.Models;
using UnityExplorer.UI;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.Utility;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.CacheObject
{
    public enum ValueState
    {
        NotEvaluated,
        Exception,
        Boolean,
        Number,
        String,
        Enum,
        Collection,
        Dictionary,
        ValueStruct,
        Color,
        Unsupported
    }

    public abstract class CacheObjectBase
    {
        public ICacheObjectController Owner { get; set; }

        public CacheObjectCell CellView { get; internal set; }

        public object Value { get; protected set; }
        public Type FallbackType { get; protected set; }
        public bool LastValueWasNull { get; private set; }

        public ValueState State = ValueState.NotEvaluated;
        public Type LastValueType;

        public InteractiveValue IValue { get; private set; }
        public Type CurrentIValueType { get; private set; }
        public bool SubContentShowWanted { get; private set; }

        public string NameLabelText { get; protected set; }
        public string NameLabelTextRaw { get; protected set; }
        public string ValueLabelText { get; protected set; }

        public abstract bool ShouldAutoEvaluate { get; }
        public abstract bool HasArguments { get; }
        public abstract bool CanWrite { get; }
        public bool HadException { get; protected set; }
        public Exception LastException { get; protected set; }

        public virtual void SetFallbackType(Type fallbackType)
        {
            this.FallbackType = fallbackType;
            this.ValueLabelText = GetValueLabel();
        }

        protected const string NOT_YET_EVAL = "<color=grey>Not yet evaluated</color>";

        public virtual void ReleasePooledObjects()
        {
            if (this.IValue != null)
                ReleaseIValue();

            if (this.CellView != null)
                UnlinkFromView();
        }

        public virtual void SetView(CacheObjectCell cellView)
        {
            this.CellView = cellView;
            cellView.Occupant = this;
        }

        public virtual void UnlinkFromView()
        {
            if (this.CellView == null)
                return;

            this.CellView.Occupant = null;
            this.CellView = null;

            if (this.IValue != null)
                this.IValue.UIRoot.transform.SetParent(InactiveIValueHolder.transform, false);
        }

        // Updating and applying values

        public void SetUserValue(object value)
        {
            value = value.TryCast(FallbackType);

            TrySetUserValue(value);

            if (CellView != null)
                SetDataToCell(CellView);

            // If the owner's parent CacheObject is set, we are setting the value of an inspected struct.
            // Set the inspector target as the value back to that parent cacheobject.
            if (Owner.ParentCacheObject != null)
                Owner.ParentCacheObject.SetUserValue(Owner.Target);
        }

        public abstract void TrySetUserValue(object value);

        // The only method which sets the CacheObjectBase.Value
        public virtual void SetValueFromSource(object value)
        {
            this.Value = value;

            if (!Value.IsNullOrDestroyed())
                Value = Value.TryCast();

            ProcessOnEvaluate();

            if (this.IValue != null)
            {
                if (SubContentShowWanted)
                    this.IValue.SetValue(Value);
                else
                    IValue.PendingValueWanted = true;
            }
        }

        protected virtual void ProcessOnEvaluate()
        {
            var prevState = State;

            if (HadException)
            {
                LastValueWasNull = true;
                LastValueType = FallbackType;
                State = ValueState.Exception;
            }
            else if (Value.IsNullOrDestroyed())
            {
                LastValueWasNull = true;
                State = GetStateForType(FallbackType);
            }
            else
            {
                LastValueWasNull = false;
                State = GetStateForType(Value.GetActualType());
            }

            if (IValue != null)
            {
                // If we changed states (always needs IValue change)
                // or if the value is null, and the fallback type isnt string (we always want to edit strings).
                if (State != prevState || (State != ValueState.String && Value.IsNullOrDestroyed()))
                {
                    // need to return IValue
                    ReleaseIValue();
                    SubContentShowWanted = false;
                }
            }

            // Set label text
            this.ValueLabelText = GetValueLabel();
        }

        public ValueState GetStateForType(Type type)
        {
            if (LastValueType == type)
                return State;

            LastValueType = type;
            if (type == typeof(bool))
                return ValueState.Boolean;
            else if (type.IsPrimitive || type == typeof(decimal))
                return ValueState.Number;
            else if (type == typeof(string))
                return ValueState.String;
            else if (type.IsEnum)
                return ValueState.Enum;
            else if (type == typeof(Color) || type == typeof(Color32))
                return ValueState.Color;
            else if (InteractiveValueStruct.SupportsType(type))
                return ValueState.ValueStruct;
            else if (ReflectionUtility.IsDictionary(type))
                return ValueState.Dictionary;
            else if (!typeof(Transform).IsAssignableFrom(type) && ReflectionUtility.IsEnumerable(type))
                return ValueState.Collection;
            else
                return ValueState.Unsupported;
        }

        protected string GetValueLabel()
        {
            string label = "";

            switch (State)
            {
                case ValueState.NotEvaluated:
                    return $"<i>{NOT_YET_EVAL} ({SignatureHighlighter.Parse(FallbackType, true)})</i>";

                case ValueState.Exception:
                    return $"<i><color=red>{LastException.ReflectionExToString()}</color></i>";

                // bool and number dont want the label for the value at all
                case ValueState.Boolean:
                case ValueState.Number:
                    return null;

                // and valuestruct also doesnt want it if we can parse it
                case ValueState.ValueStruct:
                    if (ParseUtility.CanParse(LastValueType))
                        return null;
                    break;

                // string wants it trimmed to max 200 chars
                case ValueState.String:
                    if (!LastValueWasNull)
                        return $"\"{ToStringUtility.PruneString(Value as string, 200, 5)}\"";
                    break;

                // try to prefix the count of the collection for lists and dicts
                case ValueState.Collection:
                    if (!LastValueWasNull)
                    {
                        if (Value is IList iList)
                            label = $"[{iList.Count}] ";
                        else if (Value is ICollection iCol)
                            label = $"[{iCol.Count}] ";
                        else
                            label = "[?] ";
                    }
                    break;

                case ValueState.Dictionary:
                    if (!LastValueWasNull)
                    {
                        if (Value is IDictionary iDict)
                            label = $"[{iDict.Count}] ";
                        else
                            label = "[?] ";
                    }
                    break;
            }

            // Cases which dont return will append to ToStringWithType

            return label += ToStringUtility.ToStringWithType(Value, FallbackType, true);
        }

        // Setting cell state from our model

        /// <summary>Return false if SetCell should abort, true if it should continue.</summary>
        protected abstract bool TryAutoEvaluateIfUnitialized(CacheObjectCell cell);

        public virtual void SetDataToCell(CacheObjectCell cell)
        {
            cell.NameLabel.text = NameLabelText;
            if (cell.HiddenNameLabel != null)
                cell.HiddenNameLabel.Text = NameLabelTextRaw ?? string.Empty;
            cell.ValueLabel.gameObject.SetActive(true);

            cell.SubContentHolder.gameObject.SetActive(SubContentShowWanted);
            if (IValue != null)
            {
                IValue.UIRoot.transform.SetParent(cell.SubContentHolder.transform, false);
                IValue.SetLayout();
            }

            bool evaluated = TryAutoEvaluateIfUnitialized(cell);

            if (cell.CopyButton != null)
            {
                bool hasEvaluated = State != ValueState.NotEvaluated && State != ValueState.Exception;
                cell.CopyButton.Component.gameObject.SetActive(hasEvaluated);
                cell.PasteButton.Component.gameObject.SetActive(hasEvaluated && this.CanWrite);
            }

            if (!evaluated)
                return;

            // The following only executes if the object has evaluated.
            // For members and properties with args, they will return by default now.

            switch (State)
            {
                case ValueState.Exception:
                    SetValueState(cell, ValueStateArgs.Default);
                    break;
                case ValueState.Boolean:
                    SetValueState(cell, new ValueStateArgs(false, toggleActive: true, applyActive: CanWrite));
                    break;
                case ValueState.Number:
                    SetValueState(cell, new ValueStateArgs(false, typeLabelActive: true, inputActive: true, applyActive: CanWrite));
                    break;
                case ValueState.String:
                    if (LastValueWasNull)
                        SetValueState(cell, new ValueStateArgs(true, subContentButtonActive: true));
                    else
                        SetValueState(cell, new ValueStateArgs(true, false, SignatureHighlighter.StringOrange, subContentButtonActive: true));
                    break;
                case ValueState.Enum:
                    SetValueState(cell, new ValueStateArgs(true, subContentButtonActive: CanWrite));
                    break;
                case ValueState.Color:
                case ValueState.ValueStruct:
                    if (ParseUtility.CanParse(LastValueType))
                        SetValueState(cell, new ValueStateArgs(false, false, null, true, false, true, CanWrite, true, true));
                    else
                        SetValueState(cell, new ValueStateArgs(true, inspectActive: true, subContentButtonActive: true));
                    break;
                case ValueState.Collection:
                case ValueState.Dictionary:
                    SetValueState(cell, new ValueStateArgs(true, inspectActive: !LastValueWasNull, subContentButtonActive: !LastValueWasNull));
                    break;
                case ValueState.Unsupported:
                    SetValueState(cell, new ValueStateArgs(true, inspectActive: !LastValueWasNull));
                    break;
            }

            cell.RefreshSubcontentButton();
        }

        protected virtual void SetValueState(CacheObjectCell cell, ValueStateArgs args)
        {
            // main value label
            if (args.valueActive)
            {
                cell.ValueLabel.text = ValueLabelText;
                cell.ValueLabel.supportRichText = args.valueRichText;
                cell.ValueLabel.color = args.valueColor;
            }
            else
                cell.ValueLabel.text = "";

            // Type label (for primitives)
            cell.TypeLabel.gameObject.SetActive(args.typeLabelActive);
            if (args.typeLabelActive)
                cell.TypeLabel.text = SignatureHighlighter.Parse(LastValueType, false);

            // toggle for bools
            cell.Toggle.gameObject.SetActive(args.toggleActive);
            if (args.toggleActive)
            {
                cell.Toggle.interactable = CanWrite;
                cell.Toggle.isOn = (bool)Value;
                cell.ToggleText.text = Value.ToString();
            }

            // inputfield for numbers
            cell.InputField.UIRoot.SetActive(args.inputActive);
            if (args.inputActive)
            {
                cell.InputField.Text = ParseUtility.ToStringForInput(Value, LastValueType);
                cell.InputField.Component.readOnly = !CanWrite;
            }

            // apply for bool and numbers
            cell.ApplyButton.Component.gameObject.SetActive(args.applyActive);

            // Inspect button only if last value not null.
            if (cell.InspectButton != null)
                cell.InspectButton.Component.gameObject.SetActive(args.inspectActive && !LastValueWasNull);

            // allow IValue for null strings though
            cell.SubContentButton.Component.gameObject.SetActive(args.subContentButtonActive && (!LastValueWasNull || State == ValueState.String));
        }

        // CacheObjectCell Apply

        public virtual void OnCellApplyClicked()
        {
            if (State == ValueState.Boolean)
                SetUserValue(this.CellView.Toggle.isOn);
            else
            {
                if (ParseUtility.TryParse(CellView.InputField.Text, LastValueType, out object value, out Exception ex))
                {
                    SetUserValue(value);
                }
                else
                {
                    ExplorerCore.LogWarning("Unable to parse input!");
                    if (ex != null)
                        ExplorerCore.Log(ex.ReflectionExToString());
                }
            }

            SetDataToCell(this.CellView);
        }

        // IValues

        public virtual void OnCellSubContentToggle()
        {
            if (this.IValue == null)
            {
                var ivalueType = InteractiveValue.GetIValueTypeForState(State);

                if (ivalueType == null)
                    return;

                IValue = (InteractiveValue)Pool.Borrow(ivalueType);
                CurrentIValueType = ivalueType;

                IValue.OnBorrowed(this);
                IValue.SetValue(this.Value);
                IValue.UIRoot.transform.SetParent(CellView.SubContentHolder.transform, false);
                CellView.SubContentHolder.SetActive(true);
                SubContentShowWanted = true;

                // update our cell after creating the ivalue (the value may have updated, make sure its consistent)
                this.ProcessOnEvaluate();
                this.SetDataToCell(this.CellView);
            }
            else
            {
                SubContentShowWanted = !SubContentShowWanted;
                CellView.SubContentHolder.SetActive(SubContentShowWanted);

                if (SubContentShowWanted && IValue.PendingValueWanted)
                {
                    IValue.PendingValueWanted = false;
                    this.ProcessOnEvaluate();
                    this.SetDataToCell(this.CellView);
                    IValue.SetValue(this.Value);
                }
            }

            CellView.RefreshSubcontentButton();
        }

        public virtual void ReleaseIValue()
        {
            if (IValue == null)
                return;

            IValue.ReleaseFromOwner();
            Pool.Return(CurrentIValueType, IValue);

            IValue = null;
        }

        internal static GameObject InactiveIValueHolder
        {
            get
            {
                if (!inactiveIValueHolder)
                {
                    inactiveIValueHolder = new GameObject("Temp_IValue_Holder");
                    GameObject.DontDestroyOnLoad(inactiveIValueHolder);
                    inactiveIValueHolder.transform.parent = UniversalUI.PoolHolder.transform;
                    inactiveIValueHolder.SetActive(false);
                }
                return inactiveIValueHolder;
            }
        }
        private static GameObject inactiveIValueHolder;

        // Value state args helper

        public struct ValueStateArgs
        {
            public ValueStateArgs(bool valueActive = true, bool valueRichText = true, Color? valueColor = null,
                bool typeLabelActive = false, bool toggleActive = false, bool inputActive = false, bool applyActive = false,
                bool inspectActive = false, bool subContentButtonActive = false)
            {
                this.valueActive = valueActive;
                this.valueRichText = valueRichText;
                this.valueColor = valueColor == null ? Color.white : (Color)valueColor;
                this.typeLabelActive = typeLabelActive;
                this.toggleActive = toggleActive;
                this.inputActive = inputActive;
                this.applyActive = applyActive;
                this.inspectActive = inspectActive;
                this.subContentButtonActive = subContentButtonActive;
            }

            public static ValueStateArgs Default => _default;
            private static ValueStateArgs _default = new ValueStateArgs(true);

            public bool valueActive, valueRichText, typeLabelActive, toggleActive,
                inputActive, applyActive, inspectActive, subContentButtonActive;

            public Color valueColor;
        }
    }
}

```

`src/CacheObject/CacheProperty.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityExplorer.Inspectors;
using UnityExplorer.Runtime;

namespace UnityExplorer.CacheObject
{
    public class CacheProperty : CacheMember
    {
        public PropertyInfo PropertyInfo { get; internal set; }
        public override Type DeclaringType => PropertyInfo.DeclaringType;
        public override bool CanWrite => PropertyInfo.CanWrite;
        public override bool IsStatic => m_isStatic ?? (bool)(m_isStatic = PropertyInfo.GetAccessors(true)[0].IsStatic);
        private bool? m_isStatic;

        public override bool ShouldAutoEvaluate => !HasArguments;

        public CacheProperty(PropertyInfo pi)
        {
            this.PropertyInfo = pi;
        }

        public override void SetInspectorOwner(ReflectionInspector inspector, MemberInfo member)
        {
            base.SetInspectorOwner(inspector, member);

            Arguments = PropertyInfo.GetIndexParameters();
        }

        protected override object TryEvaluate()
        {
            try
            {
                object ret;
                if (HasArguments)
                    ret = PropertyInfo.GetValue(DeclaringInstance, this.Evaluator.TryParseArguments());
                else
                    ret = PropertyInfo.GetValue(DeclaringInstance, null);
                HadException = false;
                LastException = null;
                return ret;
            }
            catch (Exception ex)
            {
                HadException = true;
                LastException = ex;
                return null;
            }
        }

        protected override void TrySetValue(object value)
        {
            if (!CanWrite)
                return;

            try
            {
                bool _static = PropertyInfo.GetAccessors(true)[0].IsStatic;

                if (HasArguments)
                    PropertyInfo.SetValue(DeclaringInstance, value, Evaluator.TryParseArguments());
                else
                    PropertyInfo.SetValue(DeclaringInstance, value, null);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning(ex);
            }
        }
    }
}

```

`src/CacheObject/ICacheObjectController.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;

namespace UnityExplorer.CacheObject
{
    public interface ICacheObjectController
    {
        CacheObjectBase ParentCacheObject { get; }

        object Target { get; }
        Type TargetType { get; }

        bool CanWrite { get; }
    }

    public static class CacheObjectControllerHelper
    {
        // Helper so that this doesn't need to be copy+pasted between each implementation of the interface

        public static void SetCell(CacheObjectCell cell, int index, IList cachedEntries, Action<CacheObjectCell> onDataSetToCell)
        {
            if (index < 0 || index >= cachedEntries.Count)
            {
                if (cell.Occupant != null)
                    cell.Occupant.UnlinkFromView();

                cell.Disable();
                return;
            }

            var entry = (CacheObjectBase)cachedEntries[index];

            if (entry.CellView != null && entry.CellView != cell)
                entry.UnlinkFromView();

            if (cell.Occupant != null && cell.Occupant != entry)
                cell.Occupant.UnlinkFromView();

            if (entry.CellView != cell)
                entry.SetView(cell);

            entry.SetDataToCell(cell);

            onDataSetToCell?.Invoke(cell);
        }
    }
}

```

`src/CacheObject/IValues/InteractiveColor.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.UI;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveColor : InteractiveValue
    {
        public bool IsValueColor32;

        public Color EditedColor;

        private Image colorImage;
        private readonly InputFieldRef[] inputs = new InputFieldRef[4];
        private readonly Slider[] sliders = new Slider[4];

        private ButtonRef applyButton;

        private static readonly string[] fieldNames = new[] { "R", "G", "B", "A" };

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            applyButton.Component.gameObject.SetActive(owner.CanWrite);

            foreach (var slider in sliders)
                slider.interactable = owner.CanWrite;
            foreach (var input in inputs)
                input.Component.readOnly = !owner.CanWrite;
        }

        // owner setting value to this
        public override void SetValue(object value)
        {
            OnOwnerSetValue(value);
        }

        private void OnOwnerSetValue(object value)
        {
            if (value is Color32 c32)
            {
                IsValueColor32 = true;
                EditedColor = c32;
                inputs[0].Text = c32.r.ToString();
                inputs[1].Text = c32.g.ToString();
                inputs[2].Text = c32.b.ToString();
                inputs[3].Text = c32.a.ToString();
                foreach (var slider in sliders)
                    slider.maxValue = 255;
            }
            else
            {
                IsValueColor32 = false;
                EditedColor = (Color)value;
                inputs[0].Text = EditedColor.r.ToString();
                inputs[1].Text = EditedColor.g.ToString();
                inputs[2].Text = EditedColor.b.ToString();
                inputs[3].Text = EditedColor.a.ToString();
                foreach (var slider in sliders)
                    slider.maxValue = 1;
            }

            if (colorImage)
                colorImage.color = EditedColor;
        }

        // setting value to owner

        public void SetValueToOwner()
        {
            if (IsValueColor32)
                CurrentOwner.SetUserValue((Color32)EditedColor);
            else
                CurrentOwner.SetUserValue(EditedColor);
        }

        private void SetColorField(float val, int fieldIndex)
        {
            switch (fieldIndex)
            {
                case 0: EditedColor.r = val; break;
                case 1: EditedColor.g = val; break;
                case 2: EditedColor.b = val; break;
                case 3: EditedColor.a = val; break;
            }

            if (colorImage)
                colorImage.color = EditedColor;
        }

        private void OnInputChanged(string val, int fieldIndex)
        {
            try
            {
                float f;
                if (IsValueColor32)
                {
                    byte value = byte.Parse(val);
                    sliders[fieldIndex].value = value;
                    f = (float)((decimal)value / 255);
                }
                else
                {
                    f = float.Parse(val);
                    sliders[fieldIndex].value = f;
                }

                SetColorField(f, fieldIndex);
            }
            catch (ArgumentException) { } // ignore bad user input
            catch (FormatException) { }
            catch (OverflowException) { }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("InteractiveColor OnInput: " + ex.ToString());
            }
        }

        private void OnSliderValueChanged(float val, int fieldIndex)
        {
            try
            {
                if (IsValueColor32)
                {
                    inputs[fieldIndex].Text = ((byte)val).ToString();
                    val /= 255f;
                }
                else
                {
                    inputs[fieldIndex].Text = val.ToString();
                }

                SetColorField(val, fieldIndex);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("InteractiveColor OnSlider: " + ex.ToString());
            }
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveColor", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));

            // hori group

            var horiGroup = UIFactory.CreateHorizontalGroup(UIRoot, "ColorEditor", false, false, true, true, 5,
                default, new Color(1, 1, 1, 0), TextAnchor.MiddleLeft);

            // sliders / inputs

            var grid = UIFactory.CreateGridGroup(horiGroup, "Grid", new Vector2(140, 25), new Vector2(2, 2), new Color(1, 1, 1, 0));
            UIFactory.SetLayoutElement(grid, minWidth: 580, minHeight: 25, flexibleWidth: 0);

            for (int i = 0; i < 4; i++)
                AddEditorRow(i, grid);

            // apply button

            applyButton = UIFactory.CreateButton(horiGroup, "ApplyButton", "Apply", new Color(0.2f, 0.26f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 90);
            applyButton.OnClick += SetValueToOwner;

            // image of color

            var imgObj = UIFactory.CreateUIObject("ColorImageHelper", horiGroup);
            UIFactory.SetLayoutElement(imgObj, minHeight: 25, minWidth: 50, flexibleWidth: 50);
            colorImage = imgObj.AddComponent<Image>();

            return UIRoot;
        }

        internal void AddEditorRow(int index, GameObject groupObj)
        {
            var row = UIFactory.CreateHorizontalGroup(groupObj, "EditorRow_" + fieldNames[index],
                false, true, true, true, 5, default, new Color(1, 1, 1, 0));

            var label = UIFactory.CreateLabel(row, "RowLabel", $"{fieldNames[index]}:", TextAnchor.MiddleRight, Color.cyan);
            UIFactory.SetLayoutElement(label.gameObject, minWidth: 17, flexibleWidth: 0, minHeight: 25);

            var input = UIFactory.CreateInputField(row, "Input", "...");
            UIFactory.SetLayoutElement(input.UIRoot, minWidth: 40, minHeight: 25, flexibleHeight: 0);
            inputs[index] = input;
            input.OnValueChanged += (string val) => { OnInputChanged(val, index); };

            var sliderObj = UIFactory.CreateSlider(row, "Slider", out Slider slider);
            sliders[index] = slider;
            UIFactory.SetLayoutElement(sliderObj, minHeight: 25, minWidth: 70, flexibleWidth: 999, flexibleHeight: 0);
            slider.minValue = 0;
            slider.maxValue = 1;
            slider.onValueChanged.AddListener((float val) => { OnSliderValueChanged(val, index); });
        }
    }
}

```

`src/CacheObject/IValues/InteractiveDictionary.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Inspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveDictionary : InteractiveValue, ICellPoolDataSource<CacheKeyValuePairCell>, ICacheObjectController
    {
        CacheObjectBase ICacheObjectController.ParentCacheObject => this.CurrentOwner;
        object ICacheObjectController.Target => this.CurrentOwner.Value;
        public Type TargetType { get; private set; }

        public override bool CanWrite => base.CanWrite && RefIDictionary != null && !RefIDictionary.IsReadOnly;

        public Type KeysType;
        public Type ValuesType;
        public IDictionary RefIDictionary;

        public int ItemCount => cachedEntries.Count;
        private readonly List<CacheKeyValuePair> cachedEntries = new List<CacheKeyValuePair>();

        public ScrollPool<CacheKeyValuePairCell> DictScrollPool { get; private set; }

        private Text NotSupportedLabel;

        public Text TopLabel;

        public LayoutElement KeyTitleLayout;
        public LayoutElement ValueTitleLayout;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            DictScrollPool.Refresh(true, true);
        }

        public override void ReleaseFromOwner()
        {
            base.ReleaseFromOwner();

            ClearAndRelease();
        }

        private void ClearAndRelease()
        {
            RefIDictionary = null;

            foreach (var entry in cachedEntries)
            {
                entry.UnlinkFromView();
                entry.ReleasePooledObjects();
            }

            cachedEntries.Clear();
        }

        public override void SetValue(object value)
        {
            if (value == null)
            {
                // should never be null
                ClearAndRelease();
                return;
            }
            else
            {
                var type = value.GetActualType();
                ReflectionUtility.TryGetEntryTypes(type, out KeysType, out ValuesType);

                CacheEntries(value);

                TopLabel.text = $"[{cachedEntries.Count}] {SignatureHighlighter.Parse(type, false)}";
            }

            this.DictScrollPool.Refresh(true, false);
        }

        private void CacheEntries(object value)
        {
            RefIDictionary = value as IDictionary;

            if (ReflectionUtility.TryGetDictEnumerator(value, out IEnumerator<DictionaryEntry> dictEnumerator))
            {
                NotSupportedLabel.gameObject.SetActive(false);

                int idx = 0;
                while (dictEnumerator.MoveNext())
                {
                    CacheKeyValuePair cache;
                    if (idx >= cachedEntries.Count)
                    {
                        cache = new CacheKeyValuePair();
                        cache.SetDictOwner(this, idx);
                        cachedEntries.Add(cache);
                    }
                    else
                        cache = cachedEntries[idx];

                    cache.SetFallbackType(ValuesType);
                    cache.SetKey(dictEnumerator.Current.Key);
                    cache.SetValueFromSource(dictEnumerator.Current.Value);

                    idx++;
                }

                // Remove excess cached entries if dict count decreased
                if (cachedEntries.Count > idx)
                {
                    for (int i = cachedEntries.Count - 1; i >= idx; i--)
                    {
                        var cache = cachedEntries[i];
                        if (cache.CellView != null)
                            cache.UnlinkFromView();

                        cache.ReleasePooledObjects();
                        cachedEntries.RemoveAt(i);
                    }
                }
            }
            else
            {
                NotSupportedLabel.gameObject.SetActive(true);
            }
        }

        // Setting value to dictionary

        public void TrySetValueToKey(object key, object value, int keyIndex)
        {
            try
            {
                if (!RefIDictionary.Contains(key))
                {
                    ExplorerCore.LogWarning("Unable to set key! Key may have been boxed to/from Il2Cpp Object.");
                    return;
                }

                RefIDictionary[key] = value;

                var entry = cachedEntries[keyIndex];
                entry.SetValueFromSource(value);
                if (entry.CellView != null)
                    entry.SetDataToCell(entry.CellView);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting IDictionary key! {ex}");
            }
        }

        // KVP entry scroll pool

        public void OnCellBorrowed(CacheKeyValuePairCell cell) { }

        public void SetCell(CacheKeyValuePairCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, cachedEntries, SetCellLayout);
        }

        public int AdjustedWidth => (int)UIRect.rect.width - 80;

        public override void SetLayout()
        {
            var minHeight = 5f;

            KeyTitleLayout.minWidth = AdjustedWidth * 0.44f;
            ValueTitleLayout.minWidth = AdjustedWidth * 0.55f;

            foreach (var cell in DictScrollPool.CellPool)
            {
                SetCellLayout(cell);
                if (cell.Enabled)
                    minHeight += cell.Rect.rect.height;
            }

            this.scrollLayout.minHeight = Math.Min(InspectorPanel.CurrentPanelHeight - 400f, minHeight);
        }

        private void SetCellLayout(CacheObjectCell objcell)
        {
            var cell = objcell as CacheKeyValuePairCell;
            cell.KeyGroupLayout.minWidth = cell.AdjustedWidth * 0.44f;
            cell.RightGroupLayout.minWidth = cell.AdjustedWidth * 0.55f;

            if (cell.Occupant?.IValue != null)
                cell.Occupant.IValue.SetLayout();
        }

        private LayoutElement scrollLayout;
        private RectTransform UIRect;

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveDict", true, true, true, true, 6, new Vector4(10, 3, 15, 4),
                new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(UIRoot, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 475);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            UIRect = UIRoot.GetComponent<RectTransform>();

            // Entries label

            TopLabel = UIFactory.CreateLabel(UIRoot, "EntryLabel", "not set", TextAnchor.MiddleLeft, fontSize: 16);
            TopLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            // key / value titles

            var titleGroup = UIFactory.CreateUIObject("TitleGroup", UIRoot);
            UIFactory.SetLayoutElement(titleGroup, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 0);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(titleGroup, false, true, true, true, padLeft: 65, padRight: 0, childAlignment: TextAnchor.LowerLeft);

            var keyTitle = UIFactory.CreateLabel(titleGroup, "KeyTitle", "Keys", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(keyTitle.gameObject, minWidth: 100, flexibleWidth: 0);
            KeyTitleLayout = keyTitle.GetComponent<LayoutElement>();

            var valueTitle = UIFactory.CreateLabel(titleGroup, "ValueTitle", "Values", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(valueTitle.gameObject, minWidth: 100, flexibleWidth: 0);
            ValueTitleLayout = valueTitle.GetComponent<LayoutElement>();

            // entry scroll pool

            DictScrollPool = UIFactory.CreateScrollPool<CacheKeyValuePairCell>(UIRoot, "EntryList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 150, flexibleHeight: 0);
            DictScrollPool.Initialize(this, SetLayout);
            scrollLayout = scrollObj.GetComponent<LayoutElement>();

            NotSupportedLabel = UIFactory.CreateLabel(DictScrollPool.Content.gameObject, "NotSupportedMessage",
                "The IDictionary failed to enumerate. This is likely due to an issue with Unhollowed interfaces.",
                TextAnchor.MiddleLeft, Color.red);

            UIFactory.SetLayoutElement(NotSupportedLabel.gameObject, minHeight: 25, flexibleWidth: 9999);
            NotSupportedLabel.gameObject.SetActive(false);

            return UIRoot;
        }
    }
}
```

`src/CacheObject/IValues/InteractiveEnum.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.UI;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveEnum : InteractiveValue
    {
        public bool IsFlags;
        public Type EnumType;

        private Type lastType;

        public OrderedDictionary CurrentValues;

        private InputFieldRef inputField;
        private ButtonRef enumHelperButton;
        private EnumCompleter enumCompleter;

        private GameObject toggleHolder;
        private readonly List<Toggle> flagToggles = new();
        private readonly List<Text> flagTexts = new();

        public CachedEnumValue ValueAtIndex(int idx) => (CachedEnumValue)CurrentValues[idx];
        public CachedEnumValue ValueAtKey(object key) => (CachedEnumValue)CurrentValues[key];

        // Setting value from owner
        public override void SetValue(object value)
        {
            EnumType = value.GetType();

            if (lastType != EnumType)
            {
                CurrentValues = GetEnumValues(EnumType);

                IsFlags = EnumType.GetCustomAttributes(typeof(FlagsAttribute), true) is object[] fa && fa.Any();
                if (IsFlags)
                    SetupTogglesForEnumType();
                else
                {
                    inputField.Component.gameObject.SetActive(true);
                    enumHelperButton.Component.gameObject.SetActive(true);
                    toggleHolder.SetActive(false);
                }

                enumCompleter.EnumType = EnumType;
                enumCompleter.CacheEnumValues();

                lastType = EnumType;
            }

            if (!IsFlags)
                inputField.Text = value.ToString();
            else
                SetTogglesForValue(value);

            this.enumCompleter.chosenSuggestion = value.ToString();
            AutoCompleteModal.Instance.ReleaseOwnership(this.enumCompleter);
        }

        private void SetTogglesForValue(object value)
        {
            try
            {
                for (int i = 0; i < CurrentValues.Count; i++)
                    flagToggles[i].isOn = (value as Enum).HasFlag(ValueAtIndex(i).ActualValue as Enum);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting flag toggles: " + ex);
            }
        }

        // Setting value to owner

        private void OnApplyClicked()
        {
            try
            {
                if (!IsFlags)
                {
                    if (ParseUtility.TryParse(this.inputField.Text, EnumType, out object value, out Exception ex))
                        CurrentOwner.SetUserValue(value);
                    else
                        throw ex;
                }
                else
                {
                    SetValueFromFlags();
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting from dropdown: " + ex);
            }
        }

        private void SetValueFromFlags()
        {
            try
            {
                List<string> values = new List<string>();
                for (int i = 0; i < CurrentValues.Count; i++)
                {
                    if (flagToggles[i].isOn)
                        values.Add(ValueAtIndex(i).Name);
                }

                CurrentOwner.SetUserValue(Enum.Parse(EnumType, string.Join(", ", values.ToArray())));
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting from flag toggles: " + ex);
            }
        }

        // UI Construction

        private void EnumHelper_OnClick()
        {
            enumCompleter.HelperButtonClicked();
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveEnum", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 9999, flexibleWidth: 9999);

            var hori = UIFactory.CreateUIObject("Hori", UIRoot);
            UIFactory.SetLayoutElement(hori, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(hori, false, false, true, true, 2);

            var applyButton = UIFactory.CreateButton(hori, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 100);
            applyButton.OnClick += OnApplyClicked;

            inputField = UIFactory.CreateInputField(hori, "InputField", "Enter name or underlying value...");
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            enumHelperButton = UIFactory.CreateButton(hori, "EnumHelper", "â–¼");
            UIFactory.SetLayoutElement(enumHelperButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            enumHelperButton.OnClick += EnumHelper_OnClick;

            enumCompleter = new EnumCompleter(this.EnumType, this.inputField);

            toggleHolder = UIFactory.CreateUIObject("ToggleHolder", UIRoot);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(toggleHolder, false, false, true, true, 4);
            UIFactory.SetLayoutElement(toggleHolder, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 9999);

            return UIRoot;
        }

        private void SetupTogglesForEnumType()
        {
            toggleHolder.SetActive(true);
            inputField.Component.gameObject.SetActive(false);
            enumHelperButton.Component.gameObject.SetActive(false);

            // create / set / hide toggles
            for (int i = 0; i < CurrentValues.Count || i < flagToggles.Count; i++)
            {
                if (i >= CurrentValues.Count)
                {
                    if (i >= flagToggles.Count)
                        break;

                    flagToggles[i].gameObject.SetActive(false);
                    continue;
                }

                if (i >= flagToggles.Count)
                    AddToggleRow();

                flagToggles[i].isOn = false;
                flagTexts[i].text = ValueAtIndex(i).Name;
            }
        }

        private void AddToggleRow()
        {
            var row = UIFactory.CreateUIObject("ToggleRow", toggleHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(row, false, false, true, true, 2);
            UIFactory.SetLayoutElement(row, minHeight: 25, flexibleWidth: 9999);

            var toggleObj = UIFactory.CreateToggle(row, "ToggleObj", out Toggle toggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, flexibleWidth: 9999);

            flagToggles.Add(toggle);
            flagTexts.Add(toggleText);
        }

        #region Enum cache 

        internal static readonly Dictionary<string, OrderedDictionary> enumCache = new Dictionary<string, OrderedDictionary>();

        internal static OrderedDictionary GetEnumValues(Type enumType)
        {
            //isFlags = enumType.GetCustomAttributes(typeof(FlagsAttribute), true) is object[] fa && fa.Any();

            if (!enumCache.ContainsKey(enumType.AssemblyQualifiedName))
            {
                var dict = new OrderedDictionary();
                var addedNames = new HashSet<string>();

                int i = 0;
                foreach (var value in Enum.GetValues(enumType))
                {
                    var name = value.ToString();
                    if (addedNames.Contains(name))
                        continue;
                    addedNames.Add(name);

                    dict.Add(value, new CachedEnumValue(value, i, name));
                    i++;
                }

                enumCache.Add(enumType.AssemblyQualifiedName, dict);
            }

            return enumCache[enumType.AssemblyQualifiedName];
        }

        #endregion
    }

    public struct CachedEnumValue
    {
        public CachedEnumValue(object value, int index, string name)
        {
            EnumIndex = index;
            Name = name;
            ActualValue = value;
        }

        public readonly object ActualValue;
        public int EnumIndex;
        public readonly string Name;
    }
}

```

`src/CacheObject/IValues/InteractiveList.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Inspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveList : InteractiveValue, ICellPoolDataSource<CacheListEntryCell>, ICacheObjectController
    {
        CacheObjectBase ICacheObjectController.ParentCacheObject => this.CurrentOwner;
        object ICacheObjectController.Target => this.CurrentOwner.Value;
        public Type TargetType { get; private set; }

        public override bool CanWrite => base.CanWrite && ((RefIList != null && !RefIList.IsReadOnly) || IsWritableGenericIList);

        public Type EntryType;
        public IList RefIList;

        private bool IsWritableGenericIList;
        private PropertyInfo genericIndexer;

        public int ItemCount => cachedEntries.Count;
        private readonly List<CacheListEntry> cachedEntries = new();

        public ScrollPool<CacheListEntryCell> ListScrollPool { get; private set; }

        public Text TopLabel;
        private LayoutElement scrollLayout;
        private Text NotSupportedLabel;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            ListScrollPool.Refresh(true, true);
        }

        public override void ReleaseFromOwner()
        {
            base.ReleaseFromOwner();

            ClearAndRelease();
        }

        private void ClearAndRelease()
        {
            RefIList = null;

            foreach (var entry in cachedEntries)
            {
                entry.UnlinkFromView();
                entry.ReleasePooledObjects();
            }

            cachedEntries.Clear();
        }

        // List entry scroll pool

        public override void SetLayout()
        {
            var minHeight = 5f;

            foreach (var cell in ListScrollPool.CellPool)
            {
                if (cell.Enabled)
                    minHeight += cell.Rect.rect.height;
            }

            this.scrollLayout.minHeight = Math.Min(InspectorPanel.CurrentPanelHeight - 400f, minHeight);
        }

        public void OnCellBorrowed(CacheListEntryCell cell) { } // not needed

        public void SetCell(CacheListEntryCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, cachedEntries, null);
        }

        // Setting the List value itself to this model
        public override void SetValue(object value)
        {
            if (value == null)
            {
                // should never be null
                if (cachedEntries.Any())
                    ClearAndRelease();
            }
            else
            {
                var type = value.GetActualType();
                ReflectionUtility.TryGetEntryType(type, out EntryType);

                CacheEntries(value);

                TopLabel.text = $"[{cachedEntries.Count}] {SignatureHighlighter.Parse(type, false)}";
            }

            //this.ScrollPoolLayout.minHeight = Math.Min(400f, 35f * values.Count);
            this.ListScrollPool.Refresh(true, false);
        }

        private void CacheEntries(object value)
        {
            RefIList = value as IList;

            // Check if the type implements IList<T> but not IList (ie. Il2CppArrayBase)
            if (RefIList == null)
                CheckGenericIList(value);
            else
                IsWritableGenericIList = false;

            int idx = 0;

            if (ReflectionUtility.TryGetEnumerator(value, out IEnumerator enumerator))
            {
                NotSupportedLabel.gameObject.SetActive(false);

                while (enumerator.MoveNext())
                {
                    var entry = enumerator.Current;

                    // If list count increased, create new cache entries
                    CacheListEntry cache;
                    if (idx >= cachedEntries.Count)
                    {
                        cache = new CacheListEntry();
                        cache.SetListOwner(this, idx);
                        cachedEntries.Add(cache);
                    }
                    else
                        cache = cachedEntries[idx];

                    cache.SetFallbackType(this.EntryType);
                    cache.SetValueFromSource(entry);
                    idx++;
                }

                // Remove excess cached entries if list count decreased
                if (cachedEntries.Count > idx)
                {
                    for (int i = cachedEntries.Count - 1; i >= idx; i--)
                    {
                        var cache = cachedEntries[i];
                        if (cache.CellView != null)
                            cache.UnlinkFromView();

                        cache.ReleasePooledObjects();
                        cachedEntries.RemoveAt(i);
                    }
                }
            }
            else
            {
                NotSupportedLabel.gameObject.SetActive(true);
            }
        }

        private void CheckGenericIList(object value)
        {
            try
            {
                var type = value.GetType();
                if (type.GetInterfaces().Any(it => it.IsGenericType && it.GetGenericTypeDefinition() == typeof(IList<>)))
                    IsWritableGenericIList = !(bool)type.GetProperty("IsReadOnly").GetValue(value, null);
                else
                    IsWritableGenericIList = false;

                if (IsWritableGenericIList)
                {
                    // Find the "this[int index]" property.
                    // It might be a private implementation.
                    foreach (var prop in type.GetProperties(ReflectionUtility.FLAGS))
                    {
                        if ((prop.Name == "Item"
                                || (prop.Name.StartsWith("System.Collections.Generic.IList<") && prop.Name.EndsWith(">.Item")))
                            && prop.GetIndexParameters() is ParameterInfo[] parameters
                            && parameters.Length == 1
                            && parameters[0].ParameterType == typeof(int))
                        {
                            genericIndexer = prop;
                            break;
                        }
                    }

                    if (genericIndexer == null)
                    {
                        ExplorerCore.LogWarning($"Failed to find indexer property for IList<T> type '{type.FullName}'!");
                        IsWritableGenericIList = false;
                    }
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception processing IEnumerable for IList<T> check: {ex.ReflectionExToString()}");
                IsWritableGenericIList = false;
            }
        }

        // Setting the value of an index to the list

        public void TrySetValueToIndex(object value, int index)
        {
            try
            {
                if (!IsWritableGenericIList)
                {
                    RefIList[index] = value;
                }
                else
                {
                    genericIndexer.SetValue(CurrentOwner.Value, value, new object[] { index });
                }

                var entry = cachedEntries[index];
                entry.SetValueFromSource(value);

                if (entry.CellView != null)
                    entry.SetDataToCell(entry.CellView);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting IList value: {ex}");
            }
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveList", true, true, true, true, 6, new Vector4(10, 3, 15, 4),
                new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(UIRoot, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Entries label

            TopLabel = UIFactory.CreateLabel(UIRoot, "EntryLabel", "not set", TextAnchor.MiddleLeft, fontSize: 16);
            TopLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            // entry scroll pool

            ListScrollPool = UIFactory.CreateScrollPool<CacheListEntryCell>(UIRoot, "EntryList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 400, flexibleHeight: 0);
            ListScrollPool.Initialize(this, SetLayout);
            scrollLayout = scrollObj.GetComponent<LayoutElement>();

            NotSupportedLabel = UIFactory.CreateLabel(ListScrollPool.Content.gameObject, "NotSupportedMessage",
                "The IEnumerable failed to enumerate. This is likely due to an issue with Unhollowed interfaces.",
                TextAnchor.MiddleLeft, Color.red);

            UIFactory.SetLayoutElement(NotSupportedLabel.gameObject, minHeight: 25, flexibleWidth: 9999);
            NotSupportedLabel.gameObject.SetActive(false);

            return UIRoot;
        }
    }
}
```

`src/CacheObject/IValues/InteractiveString.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.CacheObject;
using UnityExplorer.UI.Widgets;
using UnityExplorer.UI;
using UniverseLib.UI;
using UniverseLib;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveString : InteractiveValue
    {
        private string RealValue;
        public string EditedValue = "";

        public InputFieldRef inputField;
        public ButtonRef ApplyButton;

        public GameObject SaveFileRow;
        public InputFieldRef SaveFilePath;

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            inputField.Component.readOnly = !owner.CanWrite;
            ApplyButton.Component.gameObject.SetActive(owner.CanWrite);

            SaveFilePath.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, "untitled.txt");
        }

        private bool IsStringTooLong(string s)
        {
            if (s == null)
                return false;

            return s.Length >= UniversalUI.MAX_INPUTFIELD_CHARS;
        }

        public override void SetValue(object value)
        {
            RealValue = value as string;
            SaveFileRow.SetActive(IsStringTooLong(RealValue));

            if (value == null)
            {
                inputField.Text = "";
                EditedValue = "";
            }
            else
            {
                EditedValue = (string)value;
                inputField.Text = EditedValue;
            }
        }

        private void OnApplyClicked()
        {
            CurrentOwner.SetUserValue(EditedValue);
        }

        private void OnInputChanged(string input)
        {
            EditedValue = input;
            SaveFileRow.SetActive(IsStringTooLong(EditedValue));
        }

        private void OnSaveFileClicked()
        {
            if (RealValue == null)
                return;

            if (string.IsNullOrEmpty(SaveFilePath.Text))
            {
                ExplorerCore.LogWarning("Cannot save an empty file path!");
                return;
            }

            var path = IOUtility.EnsureValidFilePath(SaveFilePath.Text);

            if (File.Exists(path))
                File.Delete(path);

            File.WriteAllText(path, RealValue);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveString", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f));

            // Save to file helper

            SaveFileRow = UIFactory.CreateUIObject("SaveFileRow", UIRoot);
            UIFactory.SetLayoutElement(SaveFileRow, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SaveFileRow, false, true, true, true, 3);

            UIFactory.CreateLabel(SaveFileRow, "Info", "<color=red>String is too long! Save to file if you want to see the full string.</color>",
                TextAnchor.MiddleLeft);

            var horizRow = UIFactory.CreateUIObject("Horiz", SaveFileRow);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horizRow, false, false, true, true, 4);

            var saveButton = UIFactory.CreateButton(horizRow, "SaveButton", "Save file");
            UIFactory.SetLayoutElement(saveButton.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveButton.OnClick += OnSaveFileClicked;

            SaveFilePath = UIFactory.CreateInputField(horizRow, "SaveInput", "...");
            UIFactory.SetLayoutElement(SaveFilePath.UIRoot, minHeight: 25, flexibleWidth: 9999);

            // Main Input / apply

            ApplyButton = UIFactory.CreateButton(UIRoot, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            ApplyButton.OnClick += OnApplyClicked;

            inputField = UIFactory.CreateInputField(UIRoot, "InputField", "empty");
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 500, flexibleWidth: 9999);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.OnValueChanged += OnInputChanged;

            return UIRoot;
        }

    }
}

```

`src/CacheObject/IValues/InteractiveValue.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.UI;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.CacheObject.IValues
{
    public abstract class InteractiveValue : IPooledObject
    {
        public static Type GetIValueTypeForState(ValueState state)
        {
            switch (state)
            {
                case ValueState.String:
                    return typeof(InteractiveString);
                case ValueState.Enum:
                    return typeof(InteractiveEnum);
                case ValueState.Collection:
                    return typeof(InteractiveList);
                case ValueState.Dictionary:
                    return typeof(InteractiveDictionary);
                case ValueState.ValueStruct:
                    return typeof(InteractiveValueStruct);
                case ValueState.Color:
                    return typeof(InteractiveColor);
                default: return null;
            }
        }

        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1f;

        public virtual bool CanWrite => this.CurrentOwner.CanWrite;

        public CacheObjectBase CurrentOwner => m_owner;
        private CacheObjectBase m_owner;

        public bool PendingValueWanted;

        public virtual void OnBorrowed(CacheObjectBase owner)
        {
            if (this.m_owner != null)
            {
                ExplorerCore.LogWarning("Setting an IValue's owner but there is already one set. Maybe it wasn't cleaned up?");
                ReleaseFromOwner();
            }

            this.m_owner = owner;
        }

        public virtual void ReleaseFromOwner()
        {
            if (this.m_owner == null)
                return;

            this.m_owner = null;
        }

        public abstract void SetValue(object value);

        public virtual void SetLayout() { }

        public abstract GameObject CreateContent(GameObject parent);
    }
}

```

`src/CacheObject/IValues/InteractiveValueStruct.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.UI;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.IValues
{
    public class InteractiveValueStruct : InteractiveValue
    {
        #region Struct cache / wrapper

        public class StructInfo
        {
            public bool IsSupported;
            public FieldInfo[] Fields;

            public StructInfo(bool isSupported, FieldInfo[] fields)
            {
                IsSupported = isSupported;
                Fields = fields;
            }

            public void SetValue(object instance, string input, int fieldIndex)
            {
                var field = Fields[fieldIndex];

                object val;
                if (field.FieldType == typeof(string))
                    val = input;
                else
                {
                    if (!ParseUtility.TryParse(input, field.FieldType, out val, out Exception ex))
                    {
                        ExplorerCore.LogWarning("Unable to parse input!");
                        if (ex != null) ExplorerCore.Log(ex.ReflectionExToString());
                        return;
                    }
                }

                field.SetValue(instance, val);
            }

            public string GetValue(object instance, int fieldIndex)
            {
                var field = Fields[fieldIndex];
                var value = field.GetValue(instance);
                return ParseUtility.ToStringForInput(value, field.FieldType);
            }
        }

        private static readonly Dictionary<string, StructInfo> typeSupportCache = new();

        private const BindingFlags INSTANCE_FLAGS = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public;
        private const string SYSTEM_VOID = "System.Void";

        public static bool SupportsType(Type type)
        {
            if (!type.IsValueType || string.IsNullOrEmpty(type.AssemblyQualifiedName) || type.FullName == SYSTEM_VOID)
                return false;

            if (typeSupportCache.TryGetValue(type.AssemblyQualifiedName, out var info))
                return info.IsSupported;

            var supported = false;

            var fields = type.GetFields(INSTANCE_FLAGS);
            if (fields.Length > 0)
            {
                if (fields.Any(it => !ParseUtility.CanParse(it.FieldType)))
                {
                    supported = false;
                    info = new StructInfo(supported, null);
                }
                else
                {
                    supported = true;
                    info = new StructInfo(supported, fields);
                }
            }

            typeSupportCache.Add(type.AssemblyQualifiedName, info);

            return supported;
        }

        #endregion

        public object RefInstance;

        public StructInfo CurrentInfo;
        private Type lastStructType;

        private ButtonRef applyButton;
        private readonly List<GameObject> fieldRows = new List<GameObject>();
        private readonly List<InputFieldRef> inputFields = new List<InputFieldRef>();
        private readonly List<Text> labels = new List<Text>();

        public override void OnBorrowed(CacheObjectBase owner)
        {
            base.OnBorrowed(owner);

            applyButton.Component.gameObject.SetActive(owner.CanWrite);
        }

        // Setting value from owner to this

        public override void SetValue(object value)
        {
            RefInstance = value;

            var type = RefInstance.GetType();

            if (type != lastStructType)
            {
                CurrentInfo = typeSupportCache[type.AssemblyQualifiedName];
                SetupUIForType();
                lastStructType = type;
            }

            for (int i = 0; i < CurrentInfo.Fields.Length; i++)
            {
                inputFields[i].Text = CurrentInfo.GetValue(RefInstance, i);
            }
        }

        private void OnApplyClicked()
        {
            try
            {
                for (int i = 0; i < CurrentInfo.Fields.Length; i++)
                {
                    CurrentInfo.SetValue(RefInstance, inputFields[i].Text, i);
                }

                CurrentOwner.SetUserValue(RefInstance);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting value: " + ex);
            }
        }

        // UI Setup for type

        private void SetupUIForType()
        {
            for (int i = 0; i < CurrentInfo.Fields.Length || i <= inputFields.Count; i++)
            {
                if (i >= CurrentInfo.Fields.Length)
                {
                    if (i >= inputFields.Count)
                        break;

                    fieldRows[i].SetActive(false);
                    continue;
                }

                if (i >= inputFields.Count)
                    AddEditorRow();

                fieldRows[i].SetActive(true);

                string label = SignatureHighlighter.Parse(CurrentInfo.Fields[i].FieldType, false);
                label += $" <color={SignatureHighlighter.FIELD_INSTANCE}>{CurrentInfo.Fields[i].Name}</color>:";
                labels[i].text = label;
            }
        }

        private void AddEditorRow()
        {
            var row = UIFactory.CreateUIObject("HoriGroup", UIRoot);
            //row.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(row, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(row, false, false, true, true, 8, childAlignment: TextAnchor.MiddleLeft);

            fieldRows.Add(row);

            var label = UIFactory.CreateLabel(row, "Label", "notset", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(label.gameObject, minHeight: 25, minWidth: 50, flexibleWidth: 0);
            label.horizontalOverflow = HorizontalWrapMode.Wrap;
            labels.Add(label);

            var input = UIFactory.CreateInputField(row, "InputField", "...");
            UIFactory.SetLayoutElement(input.UIRoot, minHeight: 25, minWidth: 200);
            var fitter = input.UIRoot.AddComponent<ContentSizeFitter>();
            fitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            fitter.horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            input.Component.lineType = InputField.LineType.MultiLineNewline;
            inputFields.Add(input);
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "InteractiveValueStruct", false, false, true, true, 3, new Vector4(4, 4, 4, 4),
                new Color(0.06f, 0.06f, 0.06f), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleWidth: 9999);

            applyButton = UIFactory.CreateButton(UIRoot, "ApplyButton", "Apply", new Color(0.2f, 0.27f, 0.2f));
            UIFactory.SetLayoutElement(applyButton.Component.gameObject, minHeight: 25, minWidth: 175);
            applyButton.OnClick += OnApplyClicked;

            return UIRoot;
        }
    }
}

```

`src/CacheObject/Views/CacheConfigCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.Views
{
    public class ConfigEntryCell : CacheObjectCell
    {
        public override GameObject CreateContent(GameObject parent)
        {
            // Main layout

            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(UIRoot, false, false, true, true, 4, 4, 4, 4, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Left label

            NameLabel = UIFactory.CreateLabel(UIRoot, "NameLabel", "<notset>", TextAnchor.MiddleLeft);
            NameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(NameLabel.gameObject, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 300);
            NameLayout = NameLabel.GetComponent<LayoutElement>();

            // horizontal group

            var horiGroup = UIFactory.CreateUIObject("RightHoriGroup", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horiGroup, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(horiGroup, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);

            SubContentButton = UIFactory.CreateButton(horiGroup, "SubContentButton", "â–²", subInactiveColor);
            UIFactory.SetLayoutElement(SubContentButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            SubContentButton.OnClick += SubContentClicked;

            // Type label

            TypeLabel = UIFactory.CreateLabel(horiGroup, "TypeLabel", "<notset>", TextAnchor.MiddleLeft);
            TypeLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(TypeLabel.gameObject, minHeight: 25, flexibleHeight: 150, minWidth: 60, flexibleWidth: 0);

            // Bool and number value interaction

            var toggleObj = UIFactory.CreateToggle(horiGroup, "Toggle", out Toggle, out ToggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ToggleText.color = SignatureHighlighter.KeywordBlue;
            Toggle.onValueChanged.AddListener(ToggleClicked);

            InputField = UIFactory.CreateInputField(horiGroup, "InputField", "...");
            UIFactory.SetLayoutElement(InputField.UIRoot, minWidth: 150, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // Apply

            ApplyButton = UIFactory.CreateButton(horiGroup, "ApplyButton", "Apply", new Color(0.15f, 0.19f, 0.15f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ApplyButton.OnClick += ApplyClicked;

            // Main value label

            ValueLabel = UIFactory.CreateLabel(horiGroup, "ValueLabel", "Value goes here", TextAnchor.MiddleLeft);
            ValueLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(ValueLabel.gameObject, minHeight: 25, flexibleHeight: 150, flexibleWidth: 9999);

            // Subcontent

            SubContentHolder = UIFactory.CreateUIObject("SubContent", UIRoot);
            UIFactory.SetLayoutElement(SubContentHolder.gameObject, minHeight: 30, flexibleHeight: 600, minWidth: 100, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SubContentHolder, true, true, true, true, 2, childAlignment: TextAnchor.UpperLeft);
            //SubContentHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.MinSize;
            SubContentHolder.SetActive(false);

            // Bottom separator
            var separator = UIFactory.CreateUIObject("BottomSeperator", UIRoot);
            UIFactory.SetLayoutElement(separator, minHeight: 1, flexibleHeight: 0, flexibleWidth: 9999);
            separator.AddComponent<Image>().color = Color.black;

            return UIRoot;
        }

        protected override void ConstructEvaluateHolder(GameObject parent) { }
    }
}

```

`src/CacheObject/Views/CacheKeyValuePairCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.Inspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheKeyValuePairCell : CacheObjectCell
    {
        public Image Image { get; private set; }
        public InteractiveDictionary DictOwner => Occupant.Owner as InteractiveDictionary;

        public LayoutElement KeyGroupLayout;
        public Text KeyLabel;
        public ButtonRef KeyInspectButton;
        public InputFieldRef KeyInputField;
        public Text KeyInputTypeLabel;

        public static Color EvenColor = new Color(0.07f, 0.07f, 0.07f);
        public static Color OddColor = new Color(0.063f, 0.063f, 0.063f);

        public int AdjustedWidth => (int)Rect.rect.width - 70;

        //public int HalfWidth => (int)(0.5f * Rect.rect.width) - 75;
        //public int AdjustedKeyWidth => HalfWidth - 50;
        //public int AdjustedRightWidth => HalfWidth;

        private void KeyInspectClicked()
        {
            InspectorManager.Inspect((Occupant as CacheKeyValuePair).DictKey, this.Occupant);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            var root = base.CreateContent(parent);

            Image = root.AddComponent<Image>();

            this.NameLayout.minWidth = 70;
            this.NameLayout.flexibleWidth = 0;
            this.NameLayout.minHeight = 30;
            this.NameLayout.flexibleHeight = 0;
            this.NameLabel.alignment = TextAnchor.MiddleRight;

            this.RightGroupLayout.minWidth = AdjustedWidth * 0.55f;

            // Key area
            var keyGroup = UIFactory.CreateUIObject("KeyHolder", root.transform.Find("HoriGroup").gameObject);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(keyGroup, false, false, true, true, 2, 0, 0, 4, 4, childAlignment: TextAnchor.MiddleLeft);
            KeyGroupLayout = UIFactory.SetLayoutElement(keyGroup, minHeight: 30, minWidth: (int)(AdjustedWidth * 0.44f), flexibleWidth: 0);

            // set to be after the NameLabel (our index label), and before the main horizontal group.
            keyGroup.transform.SetSiblingIndex(1);

            // key Inspect

            KeyInspectButton = UIFactory.CreateButton(keyGroup, "KeyInspectButton", "Inspect", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(KeyInspectButton.Component.gameObject, minWidth: 60, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);
            KeyInspectButton.OnClick += KeyInspectClicked;

            // label

            KeyLabel = UIFactory.CreateLabel(keyGroup, "KeyLabel", "<i>empty</i>", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(KeyLabel.gameObject, minWidth: 50, flexibleWidth: 999, minHeight: 25);

            // Type label for input field

            KeyInputTypeLabel = UIFactory.CreateLabel(keyGroup, "InputTypeLabel", "<i>null</i>", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(KeyInputTypeLabel.gameObject, minWidth: 55, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // input field

            KeyInputField = UIFactory.CreateInputField(keyGroup, "KeyInput", "empty");
            UIFactory.SetLayoutElement(KeyInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 0, preferredWidth: 200);
            //KeyInputField.lineType = InputField.LineType.MultiLineNewline;
            KeyInputField.Component.readOnly = true;

            return root;
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // not used
        }
    }
}

```

`src/CacheObject/Views/CacheListEntryCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject.IValues;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheListEntryCell : CacheObjectCell
    {
        public Image Image { get; private set; }
        public InteractiveList ListOwner => Occupant.Owner as InteractiveList;

        public static Color EvenColor = new Color(0.12f, 0.12f, 0.12f);
        public static Color OddColor = new Color(0.1f, 0.1f, 0.1f);

        public override GameObject CreateContent(GameObject parent)
        {
            var root = base.CreateContent(parent);

            Image = root.AddComponent<Image>();

            this.NameLayout.minWidth = 40;
            this.NameLayout.flexibleWidth = 50;
            this.NameLayout.minHeight = 25;
            this.NameLayout.flexibleHeight = 0;
            this.NameLabel.alignment = TextAnchor.MiddleRight;

            return root;
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // not used
        }

        //protected override void ConstructUpdateToggle(GameObject parent)
        //{
        //    // not used
        //}
    }
}

```

`src/CacheObject/Views/CacheMemberCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.CacheObject.Views
{
    public class CacheMemberCell : CacheObjectCell
    {
        public CacheMember MemberOccupant => Occupant as CacheMember;

        public GameObject EvaluateHolder;
        public ButtonRef EvaluateButton;

        protected virtual void EvaluateClicked()
        {
            this.MemberOccupant.OnEvaluateClicked();
        }

        protected override void ConstructEvaluateHolder(GameObject parent)
        {
            // Evaluate vert group

            EvaluateHolder = UIFactory.CreateUIObject("EvalGroup", parent);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(EvaluateHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(EvaluateHolder, minHeight: 25, flexibleWidth: 9999, flexibleHeight: 775);

            EvaluateButton = UIFactory.CreateButton(EvaluateHolder, "EvaluateButton", "Evaluate", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(EvaluateButton.Component.gameObject, minWidth: 100, minHeight: 25);
            EvaluateButton.OnClick += EvaluateClicked;
        }
    }
}

```

`src/CacheObject/Views/CacheObjectCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.CacheObject.Views
{
    public abstract class CacheObjectCell : ICell
    {
        #region ICell

        public float DefaultHeight => 30f;

        public GameObject UIRoot { get; set; }

        public bool Enabled => m_enabled;
        private bool m_enabled;

        public RectTransform Rect { get; set; }

        public void Disable()
        {
            m_enabled = false;
            UIRoot.SetActive(false);
        }

        public void Enable()
        {
            m_enabled = true;
            UIRoot.SetActive(true);
        }

        #endregion

        public CacheObjectBase Occupant { get; set; }
        public bool SubContentActive => SubContentHolder.activeSelf;

        public LayoutElement NameLayout;
        public GameObject RightGroupContent;
        public LayoutElement RightGroupLayout;
        public GameObject SubContentHolder;

        public Text NameLabel;
        public InputFieldRef HiddenNameLabel; // for selecting the name label
        public Text TypeLabel;
        public Text ValueLabel;
        public Toggle Toggle;
        public Text ToggleText;
        public InputFieldRef InputField;

        public ButtonRef InspectButton;
        public ButtonRef SubContentButton;
        public ButtonRef ApplyButton;

        public ButtonRef CopyButton;
        public ButtonRef PasteButton;

        public readonly Color subInactiveColor = new(0.23f, 0.23f, 0.23f);
        public readonly Color subActiveColor = new(0.23f, 0.33f, 0.23f);

        protected virtual void ApplyClicked()
        {
            Occupant.OnCellApplyClicked();
        }

        protected virtual void InspectClicked()
        {
            InspectorManager.Inspect(Occupant.Value, this.Occupant);
        }

        protected virtual void ToggleClicked(bool value)
        {
            ToggleText.text = value.ToString();
        }

        protected virtual void SubContentClicked()
        {
            this.Occupant.OnCellSubContentToggle();
        }

        protected virtual void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.Occupant.Value);
        }

        protected virtual void OnPasteClicked()
        {
            if (ClipboardPanel.TryPaste(this.Occupant.FallbackType, out object paste))
                this.Occupant.SetUserValue(paste);
        }

        public void RefreshSubcontentButton()
        {
            this.SubContentButton.ButtonText.text = SubContentHolder.activeSelf ? "â–¼" : "â–²";
            Color color = SubContentHolder.activeSelf ? subActiveColor : subInactiveColor;
            RuntimeHelper.SetColorBlock(SubContentButton.Component, color, color * 1.3f);
        }

        protected abstract void ConstructEvaluateHolder(GameObject parent);

        public virtual GameObject CreateContent(GameObject parent)
        {
            // Main layout

            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(UIRoot, false, false, true, true, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            var horiRow = UIFactory.CreateUIObject("HoriGroup", UIRoot);
            UIFactory.SetLayoutElement(horiRow, minHeight: 29, flexibleHeight: 150, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(horiRow, false, false, true, true, 5, 2, childAlignment: TextAnchor.UpperLeft);
            horiRow.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // Left name label

            NameLabel = UIFactory.CreateLabel(horiRow, "NameLabel", "<notset>", TextAnchor.MiddleLeft);
            NameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            NameLayout = UIFactory.SetLayoutElement(NameLabel.gameObject, minHeight: 25, minWidth: 20, flexibleHeight: 300, flexibleWidth: 0);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(NameLabel.gameObject, true, true, true, true);

            HiddenNameLabel = UIFactory.CreateInputField(NameLabel.gameObject, "HiddenNameLabel", "");
            var hiddenRect = HiddenNameLabel.Component.GetComponent<RectTransform>();
            hiddenRect.anchorMin = Vector2.zero;
            hiddenRect.anchorMax = Vector2.one;
            HiddenNameLabel.Component.readOnly = true;
            HiddenNameLabel.Component.lineType = UnityEngine.UI.InputField.LineType.MultiLineNewline;
            HiddenNameLabel.Component.textComponent.horizontalOverflow = HorizontalWrapMode.Wrap;
            HiddenNameLabel.Component.gameObject.GetComponent<Image>().color = Color.clear;
            HiddenNameLabel.Component.textComponent.color = Color.clear;
            UIFactory.SetLayoutElement(HiddenNameLabel.Component.gameObject, minHeight: 25, minWidth: 20, flexibleHeight: 300, flexibleWidth: 0);

            // Right vertical group

            RightGroupContent = UIFactory.CreateUIObject("RightGroup", horiRow);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(RightGroupContent, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(RightGroupContent, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);
            RightGroupLayout = RightGroupContent.GetComponent<LayoutElement>();

            ConstructEvaluateHolder(RightGroupContent);

            // Right horizontal group

            var rightHoriGroup = UIFactory.CreateUIObject("RightHoriGroup", RightGroupContent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rightHoriGroup, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(rightHoriGroup, minHeight: 25, minWidth: 200, flexibleWidth: 9999, flexibleHeight: 800);

            SubContentButton = UIFactory.CreateButton(rightHoriGroup, "SubContentButton", "â–²", subInactiveColor);
            UIFactory.SetLayoutElement(SubContentButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            SubContentButton.OnClick += SubContentClicked;

            // Type label

            TypeLabel = UIFactory.CreateLabel(rightHoriGroup, "ReturnLabel", "<notset>", TextAnchor.MiddleLeft);
            TypeLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(TypeLabel.gameObject, minHeight: 25, flexibleHeight: 150, minWidth: 45, flexibleWidth: 0);

            // Bool and number value interaction

            var toggleObj = UIFactory.CreateToggle(rightHoriGroup, "Toggle", out Toggle, out ToggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ToggleText.color = SignatureHighlighter.KeywordBlue;
            Toggle.onValueChanged.AddListener(ToggleClicked);

            InputField = UIFactory.CreateInputField(rightHoriGroup, "InputField", "...");
            UIFactory.SetLayoutElement(InputField.UIRoot, minWidth: 150, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // Apply

            ApplyButton = UIFactory.CreateButton(rightHoriGroup, "ApplyButton", "Apply", new Color(0.15f, 0.19f, 0.15f));
            UIFactory.SetLayoutElement(ApplyButton.Component.gameObject, minWidth: 70, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            ApplyButton.OnClick += ApplyClicked;

            // Inspect 

            InspectButton = UIFactory.CreateButton(rightHoriGroup, "InspectButton", "Inspect", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(InspectButton.Component.gameObject, minWidth: 70, flexibleWidth: 0, minHeight: 25);
            InspectButton.OnClick += InspectClicked;

            // Main value label

            ValueLabel = UIFactory.CreateLabel(rightHoriGroup, "ValueLabel", "Value goes here", TextAnchor.MiddleLeft);
            ValueLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
            UIFactory.SetLayoutElement(ValueLabel.gameObject, minHeight: 25, flexibleHeight: 150, flexibleWidth: 9999);

            // Copy and Paste buttons

            var buttonHolder = UIFactory.CreateHorizontalGroup(rightHoriGroup, "CopyPasteButtons", false, false, true, true, 4, 
                bgColor: new(1,1,1,0), childAlignment: TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(buttonHolder, minWidth: 60, flexibleWidth: 0);

            CopyButton = UIFactory.CreateButton(buttonHolder, "CopyButton", "Copy", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(CopyButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            CopyButton.ButtonText.color = Color.yellow;
            CopyButton.ButtonText.fontSize = 10;
            CopyButton.OnClick += OnCopyClicked;

            PasteButton = UIFactory.CreateButton(buttonHolder, "PasteButton", "Paste", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(PasteButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            PasteButton.ButtonText.color = Color.green;
            PasteButton.ButtonText.fontSize = 10;
            PasteButton.OnClick += OnPasteClicked;

            // Subcontent

            SubContentHolder = UIFactory.CreateUIObject("SubContent", UIRoot);
            UIFactory.SetLayoutElement(SubContentHolder.gameObject, minHeight: 30, flexibleHeight: 600, minWidth: 100, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(SubContentHolder, true, true, true, true, 2, childAlignment: TextAnchor.UpperLeft);
            //SubContentHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.MinSize;
            SubContentHolder.SetActive(false);

            // Bottom separator
            var separator = UIFactory.CreateUIObject("BottomSeperator", UIRoot);
            UIFactory.SetLayoutElement(separator, minHeight: 1, flexibleHeight: 0, flexibleWidth: 9999);
            separator.AddComponent<Image>().color = Color.black;

            return UIRoot;
        }
    }
}

```

`src/Config/ConfigElement.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace UnityExplorer.Config
{
    public class ConfigElement<T> : IConfigElement
    {
        public string Name { get; }
        public string Description { get; }

        public bool IsInternal { get; }
        public Type ElementType => typeof(T);

        public Action<T> OnValueChanged;
        public Action OnValueChangedNotify { get; set; }

        public object DefaultValue { get; }

        public ConfigHandler Handler => IsInternal
            ? ConfigManager.InternalHandler
            : ConfigManager.Handler;

        public T Value
        {
            get => m_value;
            set => SetValue(value);
        }
        private T m_value;

        object IConfigElement.BoxedValue
        {
            get => m_value;
            set => SetValue((T)value);
        }

        public ConfigElement(string name, string description, T defaultValue, bool isInternal = false)
        {
            Name = name;
            Description = description;

            m_value = defaultValue;
            DefaultValue = defaultValue;

            IsInternal = isInternal;

            ConfigManager.RegisterConfigElement(this);
        }

        private void SetValue(T value)
        {
            if ((m_value == null && value == null) || (m_value != null && m_value.Equals(value)))
                return;

            m_value = value;

            Handler.SetConfigValue(this, value);

            OnValueChanged?.Invoke(value);
            OnValueChangedNotify?.Invoke();

            Handler.OnAnyConfigChanged();
        }

        object IConfigElement.GetLoaderConfigValue() => GetLoaderConfigValue();

        public T GetLoaderConfigValue()
        {
            return Handler.GetConfigValue(this);
        }

        public void RevertToDefaultValue()
        {
            Value = (T)DefaultValue;
        }
    }
}

```

`src/Config/ConfigHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace UnityExplorer.Config
{
    public abstract class ConfigHandler
    {
        public abstract void RegisterConfigElement<T>(ConfigElement<T> element);

        public abstract void SetConfigValue<T>(ConfigElement<T> element, T value);

        public abstract T GetConfigValue<T>(ConfigElement<T> element);

        public abstract void Init();

        public abstract void LoadConfig();

        public abstract void SaveConfig();

        public virtual void OnAnyConfigChanged() { }
    }
}

```

`src/Config/ConfigManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using UnityEngine;
using UnityExplorer.UI;

namespace UnityExplorer.Config
{
    public static class ConfigManager
    {
        internal static readonly Dictionary<string, IConfigElement> ConfigElements = new();
        internal static readonly Dictionary<string, IConfigElement> InternalConfigs = new();

        // Each Mod Loader has its own ConfigHandler.
        // See the UnityExplorer.Loader namespace for the implementations.
        public static ConfigHandler Handler { get; private set; }

        // Actual UE Settings
        public static ConfigElement<KeyCode> Master_Toggle;
        public static ConfigElement<int> Target_Display;
        public static ConfigElement<UIManager.VerticalAnchor> Main_Navbar_Anchor;
        public static ConfigElement<bool> Force_Unlock_Mouse;
        public static ConfigElement<KeyCode> Force_Unlock_Toggle;
        public static ConfigElement<bool> Aggressive_Mouse_Unlock;
        public static ConfigElement<bool> Disable_EventSystem_Override;
        public static ConfigElement<string> Default_Output_Path;
        public static ConfigElement<bool> Log_Unity_Debug;
        public static ConfigElement<bool> Hide_On_Startup;
        public static ConfigElement<float> Startup_Delay_Time;
        public static ConfigElement<string> Reflection_Signature_Blacklist;
        public static ConfigElement<KeyCode> World_MouseInspect_Keybind;
        public static ConfigElement<KeyCode> UI_MouseInspect_Keybind;

        // internal configs
        internal static InternalConfigHandler InternalHandler { get; private set; }
        internal static readonly Dictionary<UIManager.Panels, ConfigElement<string>> PanelSaveData = new();

        internal static ConfigElement<string> GetPanelSaveData(UIManager.Panels panel)
        {
            if (!PanelSaveData.ContainsKey(panel))
                PanelSaveData.Add(panel, new ConfigElement<string>(panel.ToString(), string.Empty, string.Empty, true));
            return PanelSaveData[panel];
        }

        public static void Init(ConfigHandler configHandler)
        {
            Handler = configHandler;
            Handler.Init();

            InternalHandler = new InternalConfigHandler();
            InternalHandler.Init();

            CreateConfigElements();

            Handler.LoadConfig();
            InternalHandler.LoadConfig();

            //InitConsoleCallback();
        }

        internal static void RegisterConfigElement<T>(ConfigElement<T> configElement)
        {
            if (!configElement.IsInternal)
            {
                Handler.RegisterConfigElement(configElement);
                ConfigElements.Add(configElement.Name, configElement);
            }
            else
            {
                InternalHandler.RegisterConfigElement(configElement);
                InternalConfigs.Add(configElement.Name, configElement);
            }
        }

        private static void CreateConfigElements()
        {
            Master_Toggle = new ConfigElement<KeyCode>("UnityExplorer Toggle",
                "The key to enable or disable UnityExplorer's menu and features.",
                KeyCode.F7);

            Target_Display = new ConfigElement<int>("Target Display",
                "The monitor index for UnityExplorer to use, if you have multiple. 0 is the default display, 1 is secondary, etc. " +
                "Restart recommended when changing this setting. Make sure your extra monitors are the same resolution as your primary monitor.",
                0);

            Main_Navbar_Anchor = new ConfigElement<UIManager.VerticalAnchor>("Main Navbar Anchor",
                "The vertical anchor of the main UnityExplorer Navbar, in case you want to move it.",
                UIManager.VerticalAnchor.Top);

            Hide_On_Startup = new ConfigElement<bool>("Hide On Startup",
                "Should UnityExplorer be hidden on startup?",
                false);

            World_MouseInspect_Keybind = new("World Mouse-Inspect Keybind",
                "Optional keybind to being a World-mode Mouse Inspect.",
                KeyCode.None);

            UI_MouseInspect_Keybind = new("UI Mouse-Inspect Keybind", 
                "Optional keybind to begin a UI_mode Mouse Inspect.",
                KeyCode.None);

            Force_Unlock_Mouse = new ConfigElement<bool>("Force Unlock Mouse",
                "Force the Cursor to be unlocked (visible) when the UnityExplorer menu is open.",
                true);
            Force_Unlock_Mouse.OnValueChanged += (bool value) => UniverseLib.Config.ConfigManager.Force_Unlock_Mouse = value;

            Force_Unlock_Toggle = new ConfigElement<KeyCode>("Force Unlock Toggle Key",
                "The keybind to toggle the 'Force Unlock Mouse' setting. Only usable when UnityExplorer is open.",
                KeyCode.None);

            Disable_EventSystem_Override = new ConfigElement<bool>("Disable EventSystem override",
                "If enabled, UnityExplorer will not override the EventSystem from the game.\n<b>May require restart to take effect.</b>",
                false);
            Disable_EventSystem_Override.OnValueChanged += (bool value) => UniverseLib.Config.ConfigManager.Disable_EventSystem_Override = value;

            Log_Unity_Debug = new ConfigElement<bool>("Log Unity Debug",
                "Should UnityEngine.Debug.Log messages be printed to UnityExplorer's log?",
                false);

            Default_Output_Path = new ConfigElement<string>("Default Output Path",
                "The default output path when exporting things from UnityExplorer.",
                Path.Combine(ExplorerCore.Loader.ExplorerFolder, "Output"));

            Startup_Delay_Time = new ConfigElement<float>("Startup Delay Time",
                "The delay on startup before the UI is created.",
                1f);

            Reflection_Signature_Blacklist = new ConfigElement<string>("Member Signature Blacklist",
                "Use this to blacklist certain member signatures if they are known to cause a crash or other issues.\r\n" +
                "Seperate signatures with a semicolon ';'.\r\n" +
                "For example, to blacklist Camera.main, you would add 'UnityEngine.Camera.main;'",
                "");
        }
    }
}

```

`src/Config/IConfigElement.cs`:

```cs
using System;

namespace UnityExplorer.Config
{
    public interface IConfigElement
    {
        string Name { get; }
        string Description { get; }

        bool IsInternal { get; }
        Type ElementType { get; }

        object BoxedValue { get; set; }
        object DefaultValue { get; }

        object GetLoaderConfigValue();

        void RevertToDefaultValue();

        Action OnValueChangedNotify { get; set; }
    }
}

```

`src/Config/InternalConfigHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.UI;
using Tomlet;
using Tomlet.Models;

namespace UnityExplorer.Config
{
    public class InternalConfigHandler : ConfigHandler
    {
        internal static string CONFIG_PATH;

        public override void Init()
        {
            CONFIG_PATH = Path.Combine(ExplorerCore.Loader.ExplorerFolder, "data.cfg");
        }

        public override void LoadConfig()
        {
            if (!TryLoadConfig())
                SaveConfig();
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> element)
        {
            // Not necessary
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            // Not necessary
        }

        // Not necessary, just return the value.
        public override T GetConfigValue<T>(ConfigElement<T> element) => element.Value;

        // Always just auto-save.
        public override void OnAnyConfigChanged() => SaveConfig();

        public bool TryLoadConfig()
        {
            try
            {
                if (!File.Exists(CONFIG_PATH))
                    return false;

                TomlDocument document = TomlParser.ParseFile(CONFIG_PATH);
                foreach (var key in document.Keys)
                {
                    var panelKey = (UIManager.Panels)Enum.Parse(typeof(UIManager.Panels), key);
                    ConfigManager.GetPanelSaveData(panelKey).Value = document.GetString(key);
                }

                return true;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Error loading internal data: " + ex.ToString());
                return false;
            }
        }

        public override void SaveConfig()
        {
            if (UIManager.Initializing)
                return;

            var tomlDocument = TomlDocument.CreateEmpty();
            foreach (var entry in ConfigManager.InternalConfigs)
                tomlDocument.Put(entry.Key, entry.Value.BoxedValue as string, false);

            File.WriteAllText(CONFIG_PATH, tomlDocument.SerializedValue);
        }
    }
}

```

`src/ExplorerBehaviour.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
#if CPP
using UnhollowerRuntimeLib;
#endif

namespace UnityExplorer
{
    // Handles all Behaviour update calls for UnityExplorer (Update, FixedUpdate, OnPostRender).
    // Basically just a wrapper which calls the corresponding methods in ExplorerCore.

    public class ExplorerBehaviour : MonoBehaviour
    {
        internal static ExplorerBehaviour Instance { get; private set; }

        internal static void Setup()
        {
#if CPP
            ClassInjector.RegisterTypeInIl2Cpp<ExplorerBehaviour>();
#endif

            var obj = new GameObject("ExplorerBehaviour");
            GameObject.DontDestroyOnLoad(obj);
            obj.hideFlags |= HideFlags.HideAndDontSave;
            Instance = obj.AddComponent<ExplorerBehaviour>();
        }

#if CPP
        public ExplorerBehaviour(IntPtr ptr) : base(ptr) { }
#endif

        internal void Update()
        {
            ExplorerCore.Update();
        }
    }
}

```

`src/ExplorerCore.cs`:

```cs
using System;
using System.IO;
using UnityEngine;
using UnityExplorer.CacheObject;
using UnityExplorer.Config;
using UnityExplorer.ObjectExplorer;
using UnityExplorer.Runtime;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.Input;

namespace UnityExplorer
{
    public static class ExplorerCore
    {
        public const string NAME = "UnityExplorer";
        public const string VERSION = "4.6.2";
        public const string AUTHOR = "Sinai";
        public const string GUID = "com.sinai.unityexplorer";

        public static IExplorerLoader Loader { get; private set; }

        public static HarmonyLib.Harmony Harmony { get; } = new HarmonyLib.Harmony(GUID);

        /// <summary>
        /// Initialize UnityExplorer with the provided Loader implementation.
        /// </summary>
        public static void Init(IExplorerLoader loader)
        {
            if (Loader != null)
                throw new Exception("UnityExplorer is already loaded.");

            Loader = loader;

            Log($"{NAME} {VERSION} initializing...");

            Directory.CreateDirectory(Loader.ExplorerFolder);
            ConfigManager.Init(Loader.ConfigHandler);

            UERuntimeHelper.Init();
            ExplorerBehaviour.Setup();
            UnityCrashPrevention.Init();

            Universe.Init(ConfigManager.Startup_Delay_Time.Value, LateInit, Log, new()
            {
                Disable_EventSystem_Override = ConfigManager.Disable_EventSystem_Override.Value,
                Force_Unlock_Mouse = ConfigManager.Force_Unlock_Mouse.Value,
                Unhollowed_Modules_Folder = loader.UnhollowedModulesFolder
            });
        }

        // Do a delayed setup so that objects aren't destroyed instantly.
        // This can happen for a multitude of reasons.
        // Default delay is 1 second which is usually enough.
        static void LateInit()
        {
            Log($"Setting up late core features...");

            SceneHandler.Init();

            Log($"Creating UI...");

            UIManager.InitUI();

            Log($"{NAME} {VERSION} ({Universe.Context}) initialized.");

            //InspectorManager.Inspect(typeof(Tests.TestClass));
        }

        internal static void Update()
        {
            // check master toggle
            if (InputManager.GetKeyDown(ConfigManager.Master_Toggle.Value))
                UIManager.ShowMenu = !UIManager.ShowMenu;

            UIManager.Update();
        }

        #region LOGGING

        public static void Log(object message)
            => Log(message, LogType.Log);

        public static void LogWarning(object message)
            => Log(message, LogType.Warning);

        public static void LogError(object message)
            => Log(message, LogType.Error);

        public static void LogUnity(object message, LogType logType)
        {
            if (!ConfigManager.Log_Unity_Debug.Value)
                return;

            Log($"[Unity] {message}", logType);
        }

        private static void Log(object message, LogType logType)
        {
            string log = message?.ToString() ?? "";

            LogPanel.Log(log, logType);

            switch (logType)
            {
                case LogType.Assert:
                case LogType.Log:
                    Loader.OnLogMessage(log);
                    break;

                case LogType.Warning:
                    Loader.OnLogWarning(log);
                    break;

                case LogType.Error:
                case LogType.Exception:
                    Loader.OnLogError(log);
                    break;
            }
        }

        #endregion
    }
}

```

`src/Hooks/AddHookCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class AddHookCell : ICell
    {
        public bool Enabled => UIRoot.activeSelf;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 30;

        public Text MethodNameLabel;
        public Text HookedLabel;
        public ButtonRef HookButton;

        public int CurrentDisplayedIndex;

        private void OnHookClicked()
        {
            HookManager.Instance.AddHookClicked(CurrentDisplayedIndex);
        }

        public void Enable()
        {
            this.UIRoot.SetActive(true);
        }

        public void Disable()
        {
            this.UIRoot.SetActive(false);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            HookedLabel = UIFactory.CreateLabel(UIRoot, "HookedLabel", "âœ“", TextAnchor.MiddleCenter, Color.green);
            UIFactory.SetLayoutElement(HookedLabel.gameObject, minHeight: 25, minWidth: 100);

            HookButton = UIFactory.CreateButton(UIRoot, "HookButton", "Hook", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(HookButton.Component.gameObject, minHeight: 25, minWidth: 100);
            HookButton.OnClick += OnHookClicked;

            MethodNameLabel = UIFactory.CreateLabel(UIRoot, "MethodName", "NOT SET", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(MethodNameLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            return UIRoot;
        }
    }
}

```

`src/Hooks/HookCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.Hooks
{
    public class HookCell : ICell
    {
        public bool Enabled => UIRoot.activeSelf;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 30;

        public Text MethodNameLabel;
        public ButtonRef EditPatchButton;
        public ButtonRef ToggleActiveButton;
        public ButtonRef DeleteButton;

        public int CurrentDisplayedIndex;

        private void OnToggleActiveClicked()
        {
            HookManager.Instance.EnableOrDisableHookClicked(CurrentDisplayedIndex);
        }

        private void OnDeleteClicked()
        {
            HookManager.Instance.DeleteHookClicked(CurrentDisplayedIndex);
        }

        private void OnEditPatchClicked()
        {
            HookManager.Instance.EditPatchClicked(CurrentDisplayedIndex);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject(this.GetType().Name, parent, new Vector2(100, 30));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 4, childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 600);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            MethodNameLabel = UIFactory.CreateLabel(UIRoot, "MethodName", "NOT SET", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(MethodNameLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            ToggleActiveButton = UIFactory.CreateButton(UIRoot, "ToggleActiveBtn", "Enabled", new Color(0.15f, 0.2f, 0.15f));
            UIFactory.SetLayoutElement(ToggleActiveButton.Component.gameObject, minHeight: 25, minWidth: 100);
            ToggleActiveButton.OnClick += OnToggleActiveClicked;

            DeleteButton = UIFactory.CreateButton(UIRoot, "DeleteButton", "Delete", new Color(0.2f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(DeleteButton.Component.gameObject, minHeight: 25, minWidth: 100);
            DeleteButton.OnClick += OnDeleteClicked;

            EditPatchButton = UIFactory.CreateButton(UIRoot, "EditButton", "Edit Hook Source", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(EditPatchButton.Component.gameObject, minHeight: 25, minWidth: 150);
            EditPatchButton.OnClick += OnEditPatchClicked;

            return UIRoot;
        }

        public void Disable()
        {
            UIRoot.SetActive(false);
        }

        public void Enable()
        {
            UIRoot.SetActive(true);
        }
    }
}

```

`src/Hooks/HookInstance.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using HarmonyLib;
using Mono.CSharp;
using UnityExplorer.CSConsole;
using UniverseLib;

namespace UnityExplorer.Hooks
{
    public class HookInstance
    {
        // Static 

        private static readonly StringBuilder evalOutput = new StringBuilder();
        private static readonly ScriptEvaluator scriptEvaluator = new ScriptEvaluator(new StringWriter(evalOutput));

        static HookInstance()
        {
            scriptEvaluator.Run("using System;");
            scriptEvaluator.Run("using System.Reflection;");
            scriptEvaluator.Run("using System.Collections;");
            scriptEvaluator.Run("using System.Collections.Generic;");
        }

        // Instance

        public bool Enabled;
        public MethodInfo TargetMethod;
        public string PatchSourceCode;

        private readonly string shortSignature;
        private PatchProcessor patchProcessor;

        private MethodInfo postfix;
        private MethodInfo prefix;
        private MethodInfo finalizer;
        private MethodInfo transpiler;

        public HookInstance(MethodInfo targetMethod)
        {
            this.TargetMethod = targetMethod;
            this.shortSignature = $"{targetMethod.DeclaringType.Name}.{targetMethod.Name}";

            GenerateDefaultPatchSourceCode(targetMethod);

            if (CompileAndGenerateProcessor(PatchSourceCode))
                Patch();
        }

        // Evaluator.source_file 
        private static readonly FieldInfo fi_sourceFile = AccessTools.Field(typeof(Evaluator), "source_file");
        // TypeDefinition.Definition
        private static readonly PropertyInfo pi_Definition = AccessTools.Property(typeof(TypeDefinition), "Definition");

        public bool CompileAndGenerateProcessor(string patchSource)
        {
            Unpatch();

            try
            {
                patchProcessor = ExplorerCore.Harmony.CreateProcessor(TargetMethod);

                // Dynamically compile the patch method

                var codeBuilder = new StringBuilder();

                codeBuilder.AppendLine($"public class DynamicPatch_{DateTime.Now.Ticks}");
                codeBuilder.AppendLine("{");
                codeBuilder.AppendLine(patchSource);
                codeBuilder.AppendLine("}");

                scriptEvaluator.Run(codeBuilder.ToString());

                if (ScriptEvaluator._reportPrinter.ErrorsCount > 0)
                    throw new FormatException($"Unable to compile the generated patch!");

                // TODO: Publicize MCS to avoid this reflection
                // Get the most recent Patch type in the source file
                var typeContainer = ((CompilationSourceFile)fi_sourceFile.GetValue(scriptEvaluator))
                    .Containers
                    .Last(it => it.MemberName.Name.StartsWith("DynamicPatch_"));
                // Get the TypeSpec from the TypeDefinition, then get its "MetaInfo" (System.Type)
                var patchClass = ((TypeSpec)pi_Definition.GetValue((Class)typeContainer, null)).GetMetaInfo();

                // Create the harmony patches as defined

                postfix = patchClass.GetMethod("Postfix", ReflectionUtility.FLAGS);
                if (postfix != null)
                    patchProcessor.AddPostfix(new HarmonyMethod(postfix));

                prefix = patchClass.GetMethod("Prefix", ReflectionUtility.FLAGS);
                if (prefix != null)
                    patchProcessor.AddPrefix(new HarmonyMethod(prefix));

                finalizer = patchClass.GetMethod("Finalizer", ReflectionUtility.FLAGS);
                if (finalizer != null)
                    patchProcessor.AddFinalizer(new HarmonyMethod(finalizer));

                transpiler = patchClass.GetMethod("Transpiler", ReflectionUtility.FLAGS);
                if (transpiler != null)
                    patchProcessor.AddTranspiler(new HarmonyMethod(transpiler));

                return true;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception creating patch processor for target method {TargetMethod.FullDescription()}!\r\n{ex}");
                return false;
            }
        }

        private string GenerateDefaultPatchSourceCode(MethodInfo targetMethod)
        {
            var codeBuilder = new StringBuilder();
            // Arguments 

            codeBuilder.Append("public static void Postfix(System.Reflection.MethodBase __originalMethod");

            if (!targetMethod.IsStatic)
                codeBuilder.Append($", {targetMethod.DeclaringType.FullName} __instance");

            if (targetMethod.ReturnType != typeof(void))
                codeBuilder.Append($", {targetMethod.ReturnType.FullName} __result");

            var parameters = targetMethod.GetParameters();

            int paramIdx = 0;
            foreach (var param in parameters)
            {
                codeBuilder.Append($", {param.ParameterType.FullDescription().Replace("&", "")} __{paramIdx}");
                paramIdx++;
            }

            codeBuilder.Append(")\n");

            // Patch body

            codeBuilder.AppendLine("{");

            codeBuilder.AppendLine("    try {");

            // Log message 

            var logMessage = new StringBuilder();
            logMessage.Append($"Patch called: {shortSignature}\\n");

            if (!targetMethod.IsStatic)
                logMessage.Append("__instance: {__instance.ToString()}\\n");

            paramIdx = 0;
            foreach (var param in parameters)
            {
                logMessage.Append($"Parameter {paramIdx} {param.Name}: ");
                Type pType = param.ParameterType;
                if (pType.IsByRef) pType = pType.GetElementType();
                if (pType.IsValueType)
                    logMessage.Append($"{{__{paramIdx}.ToString()}}");
                else
                    logMessage.Append($"{{__{paramIdx}?.ToString() ?? \"null\"}}");
                logMessage.Append("\\n");
                paramIdx++;
            }

            if (targetMethod.ReturnType != typeof(void))
            {
                logMessage.Append("Return value: ");
                if (targetMethod.ReturnType.IsValueType)
                    logMessage.Append("{__result.ToString()}");
                else
                    logMessage.Append("{__result?.ToString() ?? \"null\"}");
                logMessage.Append("\\n");
            }

            codeBuilder.AppendLine($"        UnityExplorer.ExplorerCore.Log($\"{logMessage}\");");
            codeBuilder.AppendLine("    }");
            codeBuilder.AppendLine("    catch (System.Exception ex) {");
            codeBuilder.AppendLine($"        UnityExplorer.ExplorerCore.LogWarning($\"Exception in patch of {shortSignature}:\\n{{ex}}\");");
            codeBuilder.AppendLine("    }");

            // End patch body

            codeBuilder.AppendLine("}");

            //ExplorerCore.Log(codeBuilder.ToString());

            return PatchSourceCode = codeBuilder.ToString();
        }

        public void TogglePatch()
        {
            if (!Enabled)
                Patch();
            else
                Unpatch();
        }

        public void Patch()
        {
            try
            {
                patchProcessor.Patch();

                Enabled = true;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception hooking method!\r\n{ex}");
            }
        }

        public void Unpatch()
        {
            try
            {
                if (prefix != null)
                    patchProcessor.Unpatch(prefix);
                if (postfix != null)
                    patchProcessor.Unpatch(postfix);
                if (finalizer != null)
                    patchProcessor.Unpatch(finalizer);
                if (transpiler != null)
                    patchProcessor.Unpatch(transpiler);

                Enabled = false;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception unpatching method: {ex}");
            }
        }
    }
}

```

`src/Hooks/HookManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Reflection;
using System.Text;
using HarmonyLib;
using UnityEngine;
using UnityExplorer.Runtime;
using UnityExplorer.CSConsole;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.Hooks
{
    public class HookManager : ICellPoolDataSource<HookCell>, ICellPoolDataSource<AddHookCell>
    {
        private static HookManager s_instance;
        public static HookManager Instance => s_instance ?? (s_instance = new HookManager());

        public HookManagerPanel Panel => UIManager.GetPanel<HookManagerPanel>(UIManager.Panels.HookManager);

        // This class acts as the data source for both current hooks and eligable methods when adding hooks.
        // 'isAddingMethods' keeps track of which pool is currently the displayed one, so our ItemCount reflects the
        // correct pool cells.
        private bool isAddingMethods;
        public int ItemCount => isAddingMethods ? filteredEligableMethods.Count : currentHooks.Count;

        // current hooks
        private readonly HashSet<string> hookedSignatures = new HashSet<string>();
        private readonly OrderedDictionary currentHooks = new OrderedDictionary();

        // adding hooks
        private readonly List<MethodInfo> currentAddEligableMethods = new List<MethodInfo>();
        private readonly List<MethodInfo> filteredEligableMethods = new List<MethodInfo>();

        // hook editor
        private readonly LexerBuilder Lexer = new LexerBuilder();
        private HookInstance currentEditedHook;

        // ~~~~~~~~~~~ Main Current Hooks window ~~~~~~~~~~~

        public void EnableOrDisableHookClicked(int index)
        {
            var hook = (HookInstance)currentHooks[index];
            hook.TogglePatch();

            Panel.HooksScrollPool.Refresh(true, false);
        }

        public void DeleteHookClicked(int index)
        {
            var hook = (HookInstance)currentHooks[index];
            hook.Unpatch();
            currentHooks.RemoveAt(index);
            hookedSignatures.Remove(hook.TargetMethod.FullDescription());

            Panel.HooksScrollPool.Refresh(true, false);
        }

        public void EditPatchClicked(int index)
        {
            Panel.SetPage(HookManagerPanel.Pages.HookSourceEditor);
            var hook = (HookInstance)currentHooks[index];
            currentEditedHook = hook;
            Panel.EditorInput.Text = hook.PatchSourceCode;
        }

        // Set current hook cell

        public void OnCellBorrowed(HookCell cell) { }

        public void SetCell(HookCell cell, int index)
        {
            if (index >= this.currentHooks.Count)
            {
                cell.Disable();
                return;
            }

            cell.CurrentDisplayedIndex = index;
            var hook = (HookInstance)this.currentHooks[index];

            cell.MethodNameLabel.text = SignatureHighlighter.HighlightMethod(hook.TargetMethod);

            cell.ToggleActiveButton.ButtonText.text = hook.Enabled ? "Enabled" : "Disabled";
            RuntimeHelper.SetColorBlockAuto(cell.ToggleActiveButton.Component,
                hook.Enabled ? new Color(0.15f, 0.2f, 0.15f) : new Color(0.2f, 0.2f, 0.15f));
        }

        // ~~~~~~~~~~~ Add Hooks window ~~~~~~~~~~~

        public void OnClassSelectedForHooks(string typeFullName)
        {
            var type = ReflectionUtility.GetTypeByName(typeFullName);
            if (type == null)
            {
                ExplorerCore.LogWarning($"Could not find any type by name {typeFullName}!");
                return;
            }

            Panel.SetAddHooksLabelType(SignatureHighlighter.Parse(type, true));

            Panel.ResetMethodFilter();
            filteredEligableMethods.Clear();
            currentAddEligableMethods.Clear();
            foreach (var method in type.GetMethods(ReflectionUtility.FLAGS))
            {
                if (method.IsGenericMethod || UERuntimeHelper.IsBlacklisted(method))
                    continue;
                currentAddEligableMethods.Add(method);
                filteredEligableMethods.Add(method);
            }

            isAddingMethods = true;
            Panel.SetPage(HookManagerPanel.Pages.ClassMethodSelector);
            Panel.AddHooksScrollPool.Refresh(true, true);
        }

        public void DoneAddingHooks()
        {
            isAddingMethods = false;
            Panel.SetPage(HookManagerPanel.Pages.CurrentHooks);
            Panel.HooksScrollPool.Refresh(true, false);
        }

        public void AddHookClicked(int index)
        {
            if (index >= this.filteredEligableMethods.Count)
                return;

            AddHook(filteredEligableMethods[index]);
            Panel.AddHooksScrollPool.Refresh(true, false);
        }

        public void AddHook(MethodInfo method)
        {
            var sig = method.FullDescription();
            if (hookedSignatures.Contains(sig))
                return;

            var hook = new HookInstance(method);
            if (hook.Enabled)
            {
                hookedSignatures.Add(sig);
                currentHooks.Add(sig, hook);
            }
        }

        public void OnAddHookFilterInputChanged(string input)
        {
            filteredEligableMethods.Clear();

            if (string.IsNullOrEmpty(input))
                filteredEligableMethods.AddRange(currentAddEligableMethods);
            else
            {
                foreach (var method in currentAddEligableMethods)
                {
                    if (method.Name.ContainsIgnoreCase(input))
                        filteredEligableMethods.Add(method);
                }
            }

            Panel.AddHooksScrollPool.Refresh(true, true);
        }

        // Set eligable method cell

        public void OnCellBorrowed(AddHookCell cell) { }

        public void SetCell(AddHookCell cell, int index)
        {
            if (index >= this.filteredEligableMethods.Count)
            {
                cell.Disable();
                return;
            }

            cell.CurrentDisplayedIndex = index;
            var method = this.filteredEligableMethods[index];

            cell.MethodNameLabel.text = SignatureHighlighter.HighlightMethod(method);

            var sig = method.FullDescription();
            if (hookedSignatures.Contains(sig))
            {
                cell.HookButton.Component.gameObject.SetActive(false);
                cell.HookedLabel.gameObject.SetActive(true);
            }
            else
            {
                cell.HookButton.Component.gameObject.SetActive(true);
                cell.HookedLabel.gameObject.SetActive(false);
            }
        }

        // ~~~~~~~~~~~ Hook source editor window ~~~~~~~~~~~

        public void OnEditorInputChanged(string value)
        {
            Panel.EditorHighlightText.text = Lexer.BuildHighlightedString(value, 0, value.Length - 1, 0,
                Panel.EditorInput.Component.caretPosition, out _);
        }

        public void EditorInputCancel()
        {
            currentEditedHook = null;
            Panel.SetPage(HookManagerPanel.Pages.CurrentHooks);
        }

        public void EditorInputSave()
        {
            var input = Panel.EditorInput.Text;
            bool wasEnabled = currentEditedHook.Enabled;
            if (currentEditedHook.CompileAndGenerateProcessor(input))
            {
                if (wasEnabled)
                    currentEditedHook.Patch();
                currentEditedHook.PatchSourceCode = input;
                currentEditedHook = null;
                Panel.SetPage(HookManagerPanel.Pages.CurrentHooks);
            }
        }
    }
}

```

`src/ILRepack.targets`:

```targets
<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
    
    <Target Name="ILRepacker" AfterTargets="Build">
        <!-- Actual merged assemblies -->
        <ItemGroup>
            <InputAssemblies Include="$(OutputPath)$(AssemblyName).dll" />
            <InputAssemblies Include="..\lib\mcs-unity\mcs\bin\Release\mcs.dll" />
            <InputAssemblies Include="packages\Samboy063.Tomlet.3.1.3\lib\net35\Tomlet.dll" />
        </ItemGroup>

        <!-- Required references for ILRepack -->
        <ItemGroup>
            <ReferenceFolders Include="packages\HarmonyX.2.5.2\lib\net35\" />
            <ReferenceFolders Include="..\lib\BepInEx.6.IL2CPP\" />
            <ReferenceFolders Include="..\lib\BepInEx.6.Mono\" />
            <ReferenceFolders Include="..\lib\BepInEx.5\" />
            <ReferenceFolders Include="..\lib\MelonLoader\" />
            <ReferenceFolders Include="..\lib\Il2CppAssemblyUnhollower\UnhollowerBaseLib\bin\Release\net4.7.2\" />
        </ItemGroup>
        
        <ILRepack
          Parallel="true"
          Internalize="true"
          DebugInfo="false"
          LibraryPath="@(ReferenceFolders)"
          InputAssemblies="@(InputAssemblies)"
          TargetKind="Dll"
          OutputFile="$(OutputPath)$(AssemblyName).dll" 
        />
    </Target>
    
</Project>
```

`src/Inspectors/GameObjectInspector.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.Input;
using UnityExplorer.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI.Widgets;
using UniverseLib.UI;
using UniverseLib;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.Inspectors
{
    public class GameObjectInspector : InspectorBase
    {
        public GameObject GOTarget => Target as GameObject;

        public GameObject Content;

        public GameObjectControls GOControls;

        public TransformTree TransformTree;
        private ScrollPool<TransformCell> transformScroll;
        private readonly List<GameObject> cachedChildren = new List<GameObject>();

        public ComponentList ComponentList;
        private ScrollPool<ComponentCell> componentScroll;

        private InputFieldRef addChildInput;
        private InputFieldRef addCompInput;

        public override void OnBorrowedFromPool(object target)
        {
            base.OnBorrowedFromPool(target);

            Target = target as GameObject;

            GOControls.UpdateGameObjectInfo(true, true);
            GOControls.UpdateTransformControlValues(true);

            RuntimeHelper.StartCoroutine(InitCoroutine());
        }

        private IEnumerator InitCoroutine()
        {
            yield return null;

            LayoutRebuilder.ForceRebuildLayoutImmediate(InspectorPanel.Instance.ContentRect);

            TransformTree.Rebuild();

            ComponentList.ScrollPool.Refresh(true, true);
            UpdateComponents();
        }

        public override void OnReturnToPool()
        {
            base.OnReturnToPool();

            addChildInput.Text = "";
            addCompInput.Text = "";

            TransformTree.Clear();
            UpdateComponents();
        }

        public override void CloseInspector()
        {
            InspectorManager.ReleaseInspector(this);
        }

        public void ChangeTarget(GameObject newTarget)
        {
            this.Target = newTarget;
            GOControls.UpdateGameObjectInfo(true, true);
            GOControls.UpdateTransformControlValues(true);
            TransformTree.RefreshData(true, false, true, false);
            UpdateComponents();
        }

        private float timeOfLastUpdate;

        public override void Update()
        {
            if (!this.IsActive)
                return;

            if (Target.IsNullOrDestroyed(false))
            {
                InspectorManager.ReleaseInspector(this);
                return;
            }

            GOControls.UpdateVectorSlider();
            GOControls.UpdateTransformControlValues(false);

            // Slow update
            if (timeOfLastUpdate.OccuredEarlierThan(1))
            {
                timeOfLastUpdate = Time.realtimeSinceStartup;

                GOControls.UpdateGameObjectInfo(false, false);

                TransformTree.RefreshData(true, false, false, false);
                UpdateComponents();
            }
        }

        // Child and Component Lists

        private IEnumerable<GameObject> GetTransformEntries()
        {
            if (!GOTarget)
                return Enumerable.Empty<GameObject>();

            cachedChildren.Clear();
            for (int i = 0; i < GOTarget.transform.childCount; i++)
                cachedChildren.Add(GOTarget.transform.GetChild(i).gameObject);
            return cachedChildren;
        }

        private readonly List<Component> componentEntries = new List<Component>();
        private readonly HashSet<int> compInstanceIDs = new HashSet<int>();
        private readonly List<Behaviour> behaviourEntries = new List<Behaviour>();
        private readonly List<bool> behaviourEnabledStates = new List<bool>();

        // ComponentList.GetRootEntriesMethod
        private List<Component> GetComponentEntries() => GOTarget ? componentEntries : Enumerable.Empty<Component>().ToList();

        public void UpdateComponents()
        {
            if (!GOTarget)
            {
                componentEntries.Clear();
                compInstanceIDs.Clear();
                behaviourEntries.Clear();
                behaviourEnabledStates.Clear();
                ComponentList.RefreshData();
                ComponentList.ScrollPool.Refresh(true, true);
                return;
            }

            // Check if we actually need to refresh the component cells or not.
            var comps = GOTarget.GetComponents<Component>();
            var behaviours = GOTarget.GetComponents<Behaviour>();

            bool needRefresh = false;

            int count = 0;
            foreach (var comp in comps)
            {
                if (!comp)
                    continue;
                count++;
                if (!compInstanceIDs.Contains(comp.GetInstanceID()))
                {
                    needRefresh = true;
                    break;
                }
            }
            if (!needRefresh)
            {
                if (count != componentEntries.Count)
                    needRefresh = true;
                else
                {
                    count = 0;
                    foreach (var behaviour in behaviours)
                    {
                        if (!behaviour)
                            continue;
                        if (count >= behaviourEnabledStates.Count || behaviour.enabled != behaviourEnabledStates[count])
                        {
                            needRefresh = true;
                            break;
                        }
                        count++;
                    }
                    if (!needRefresh && count != behaviourEntries.Count)
                        needRefresh = true;
                }
            }

            if (!needRefresh)
                return;

            componentEntries.Clear();
            compInstanceIDs.Clear();
            foreach (var comp in comps)
            {
                if (!comp) continue;
                componentEntries.Add(comp);
                compInstanceIDs.Add(comp.GetInstanceID());
            }

            behaviourEntries.Clear();
            behaviourEnabledStates.Clear();
            foreach (var behaviour in behaviours)
            {
                if (!behaviour) continue;
                behaviourEntries.Add(behaviour);
                behaviourEnabledStates.Add(behaviour.enabled);
            }

            ComponentList.RefreshData();
            ComponentList.ScrollPool.Refresh(true);
        }


        private void OnAddChildClicked(string input)
        {
            var newObject = new GameObject(input);
            newObject.transform.parent = GOTarget.transform;

            TransformTree.RefreshData(true, false, true, false);
        }

        private void OnAddComponentClicked(string input)
        {
            if (ReflectionUtility.GetTypeByName(input) is Type type)
            {
                try
                {
                    RuntimeHelper.AddComponent<Component>(GOTarget, type);
                    UpdateComponents();
                }
                catch (Exception ex)
                {
                    ExplorerCore.LogWarning($"Exception adding component: {ex.ReflectionExToString()}");
                }
            }
            else
            {
                ExplorerCore.LogWarning($"Could not find any Type by the name '{input}'!");
            }
        }

        #region UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "GameObjectInspector", true, false, true, true, 5,
                new Vector4(4, 4, 4, 4), new Color(0.065f, 0.065f, 0.065f));

            var scrollObj = UIFactory.CreateScrollView(UIRoot, "GameObjectInspector", out Content, out var scrollbar,
                new Color(0.065f, 0.065f, 0.065f));
            UIFactory.SetLayoutElement(scrollObj, minHeight: 250, preferredHeight: 300, flexibleHeight: 0, flexibleWidth: 9999);

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(Content, spacing: 3, padTop: 2, padBottom: 2, padLeft: 2, padRight: 2);

            // Construct GO Controls
            GOControls = new GameObjectControls(this);

            ConstructLists();

            return UIRoot;
        }

        // Child and Comp Lists

        private void ConstructLists()
        {
            var listHolder = UIFactory.CreateUIObject("ListHolders", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(listHolder, false, true, true, true, 8, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(listHolder, minHeight: 150, flexibleWidth: 9999, flexibleHeight: 9999);

            // Left group (Children)

            var leftGroup = UIFactory.CreateUIObject("ChildrenGroup", listHolder);
            UIFactory.SetLayoutElement(leftGroup, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(leftGroup, false, false, true, true, 2);

            var childrenLabel = UIFactory.CreateLabel(leftGroup, "ChildListTitle", "Children", TextAnchor.MiddleCenter, default, false, 16);
            UIFactory.SetLayoutElement(childrenLabel.gameObject, flexibleWidth: 9999);

            // Add Child
            var addChildRow = UIFactory.CreateUIObject("AddChildRow", leftGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(addChildRow, false, false, true, true, 2);

            addChildInput = UIFactory.CreateInputField(addChildRow, "AddChildInput", "Enter a name...");
            UIFactory.SetLayoutElement(addChildInput.Component.gameObject, minHeight: 25, preferredWidth: 9999);

            var addChildButton = UIFactory.CreateButton(addChildRow, "AddChildButton", "Add Child");
            UIFactory.SetLayoutElement(addChildButton.Component.gameObject, minHeight: 25, minWidth: 80);
            addChildButton.OnClick += () => { OnAddChildClicked(addChildInput.Text); };

            // TransformTree

            transformScroll = UIFactory.CreateScrollPool<TransformCell>(leftGroup, "TransformTree", out GameObject transformObj,
                out GameObject transformContent, new Color(0.11f, 0.11f, 0.11f));
            UIFactory.SetLayoutElement(transformObj, flexibleHeight: 9999);
            UIFactory.SetLayoutElement(transformContent, flexibleHeight: 9999);

            TransformTree = new TransformTree(transformScroll, GetTransformEntries);
            TransformTree.Init();
            TransformTree.OnClickOverrideHandler = ChangeTarget;

            // Right group (Components)

            var rightGroup = UIFactory.CreateUIObject("ComponentGroup", listHolder);
            UIFactory.SetLayoutElement(rightGroup, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(rightGroup, false, false, true, true, 2);

            var compLabel = UIFactory.CreateLabel(rightGroup, "CompListTitle", "Components", TextAnchor.MiddleCenter, default, false, 16);
            UIFactory.SetLayoutElement(compLabel.gameObject, flexibleWidth: 9999);

            // Add Comp
            var addCompRow = UIFactory.CreateUIObject("AddCompRow", rightGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(addCompRow, false, false, true, true, 2);

            addCompInput = UIFactory.CreateInputField(addCompRow, "AddCompInput", "Enter a Component type...");
            UIFactory.SetLayoutElement(addCompInput.Component.gameObject, minHeight: 25, preferredWidth: 9999);

            var addCompButton = UIFactory.CreateButton(addCompRow, "AddCompButton", "Add Comp");
            UIFactory.SetLayoutElement(addCompButton.Component.gameObject, minHeight: 25, minWidth: 80);
            addCompButton.OnClick += () => { OnAddComponentClicked(addCompInput.Text); };

            // comp autocompleter
            new TypeCompleter(typeof(Component), addCompInput);

            // Component List

            componentScroll = UIFactory.CreateScrollPool<ComponentCell>(rightGroup, "ComponentList", out GameObject compObj,
                out GameObject compContent, new Color(0.11f, 0.11f, 0.11f));
            UIFactory.SetLayoutElement(compObj, flexibleHeight: 9999);
            UIFactory.SetLayoutElement(compContent, flexibleHeight: 9999);

            ComponentList = new ComponentList(componentScroll, GetComponentEntries);
            ComponentList.Parent = this;
            componentScroll.Initialize(ComponentList);
        }


        #endregion
    }
}

```

`src/Inspectors/GameObjectWidgets/ComponentCell.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets.ButtonList;

namespace UnityExplorer.Inspectors
{
    public class ComponentCell : ButtonCell
    {
        public Toggle BehaviourToggle;
        public ButtonRef DestroyButton;

        public Action<bool, int> OnBehaviourToggled;
        public Action<int> OnDestroyClicked;

        private void BehaviourToggled(bool val)
        {
            OnBehaviourToggled?.Invoke(val, CurrentDataIndex);
        }

        private void DestroyClicked()
        {
            OnDestroyClicked?.Invoke(CurrentDataIndex);
        }

        public override GameObject CreateContent(GameObject parent)
        {
            var root = base.CreateContent(parent);

            // Add mask to button so text doesnt overlap on Close button
            //this.Button.Component.gameObject.AddComponent<Mask>().showMaskGraphic = true;
            this.Button.ButtonText.horizontalOverflow = HorizontalWrapMode.Wrap;

            // Behaviour toggle

            var toggleObj = UIFactory.CreateToggle(UIRoot, "BehaviourToggle", out BehaviourToggle, out var behavText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, minWidth: 25);
            BehaviourToggle.onValueChanged.AddListener(BehaviourToggled);
            // put at first object
            toggleObj.transform.SetSiblingIndex(0);

            // Destroy button

            DestroyButton = UIFactory.CreateButton(UIRoot, "DestroyButton", "X", new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(DestroyButton.Component.gameObject, minHeight: 21, minWidth: 25);
            DestroyButton.OnClick += DestroyClicked;

            return root;
        }
    }
}

```

`src/Inspectors/GameObjectWidgets/ComponentList.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UniverseLib;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.Inspectors
{
    public class ComponentList : ButtonListHandler<Component, ComponentCell>
    {
        public GameObjectInspector Parent;

        public ComponentList(ScrollPool<ComponentCell> scrollPool, Func<List<Component>> getEntriesMethod)
            : base(scrollPool, getEntriesMethod, null, null, null)
        {
            base.SetICell = SetComponentCell;
            base.ShouldDisplay = CheckShouldDisplay;
            base.OnCellClicked = OnComponentClicked;
        }

        public void Clear()
        {
            RefreshData();
            ScrollPool.Refresh(true, true);
        }

        private bool CheckShouldDisplay(Component _, string __) => true;

        public override void OnCellBorrowed(ComponentCell cell)
        {
            base.OnCellBorrowed(cell);

            cell.OnBehaviourToggled += OnBehaviourToggled;
            cell.OnDestroyClicked += OnDestroyClicked;
        }

        public override void SetCell(ComponentCell cell, int index)
        {
            base.SetCell(cell, index);
        }

        private void OnComponentClicked(int index)
        {
            var entries = GetEntries();

            if (index < 0 || index >= entries.Count)
                return;

            var comp = entries[index];
            if (comp)
                InspectorManager.Inspect(comp);
        }

        private void OnBehaviourToggled(bool value, int index)
        {
            try
            {
                var entries = GetEntries();
                var comp = entries[index];

                if (comp.TryCast<Behaviour>() is Behaviour behaviour)
                    behaviour.enabled = value;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception toggling Behaviour.enabled: {ex.ReflectionExToString()}");
            }
        }

        private void OnDestroyClicked(int index)
        {
            try
            {
                var entries = GetEntries();
                var comp = entries[index];

                GameObject.DestroyImmediate(comp);

                Parent.UpdateComponents();
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception destroying Component: {ex.ReflectionExToString()}");
            }
        }

        private static readonly Dictionary<string, string> compToStringCache = new Dictionary<string, string>();

        // Called from ButtonListHandler.SetCell, will be valid
        private void SetComponentCell(ComponentCell cell, int index)
        {
            var entries = GetEntries();
            cell.Enable();

            var comp = entries[index];
            var type = comp.GetActualType();

            if (!compToStringCache.ContainsKey(type.AssemblyQualifiedName))
                compToStringCache.Add(type.AssemblyQualifiedName, SignatureHighlighter.Parse(type, true));

            cell.Button.ButtonText.text = compToStringCache[type.AssemblyQualifiedName];

            if (typeof(Behaviour).IsAssignableFrom(type))
            {
                cell.BehaviourToggle.interactable = true;
                cell.BehaviourToggle.Set(comp.TryCast<Behaviour>().enabled, false);
                cell.BehaviourToggle.graphic.color = new Color(0.8f, 1, 0.8f, 0.3f);
            }
            else
            {
                cell.BehaviourToggle.interactable = false;
                cell.BehaviourToggle.Set(true, false);
                //RuntimeHelper.SetColorBlock(cell.BehaviourToggle,)
                cell.BehaviourToggle.graphic.color = new Color(0.2f, 0.2f, 0.2f);
            }

            // if component is the first index it must be the transform, dont show Destroy button for it.
            if (index == 0 && cell.DestroyButton.Component.gameObject.activeSelf)
                cell.DestroyButton.Component.gameObject.SetActive(false);
            else if (index > 0 && !cell.DestroyButton.Component.gameObject.activeSelf)
                cell.DestroyButton.Component.gameObject.SetActive(true);
        }
    }
}

```

`src/Inspectors/GameObjectWidgets/GameObjectControls.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.Input;
using UnityExplorer.UI;
using UniverseLib.UI;
using UniverseLib;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.Inspectors
{
    public class GameObjectControls
    {
        public GameObjectInspector Parent;
        private GameObject GOTarget => Parent.GOTarget;

        // Top info

        private ButtonRef ViewParentButton;
        private InputFieldRef PathInput;

        private InputFieldRef NameInput;
        private Toggle ActiveSelfToggle;
        private Text ActiveSelfText;
        private Toggle IsStaticToggle;

        private InputFieldRef SceneInput;
        private InputFieldRef InstanceIDInput;
        private InputFieldRef TagInput;

        private Dropdown LayerDropdown;
        private Dropdown FlagsDropdown;

        // transform controls

        private TransformControl PositionControl;
        private TransformControl LocalPositionControl;
        private TransformControl RotationControl;
        private TransformControl ScaleControl;

        private VectorSlider currentSlidingVectorControl;
        private float currentVectorValue;

        public GameObjectControls(GameObjectInspector parent)
        {
            this.Parent = parent;

            ConstructTopInfo();
            ConstructTransformControls();
        }

        private void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.GOTarget);
        }

        #region GO Controls

        private string lastGoName;
        private string lastPath;
        private bool lastParentState;
        private int lastSceneHandle;
        private string lastTag;
        private int lastLayer;
        private int lastFlags;

        public void UpdateGameObjectInfo(bool firstUpdate, bool force)
        {
            if (firstUpdate)
            {
                InstanceIDInput.Text = GOTarget.GetInstanceID().ToString();
            }

            if (force || (!NameInput.Component.isFocused && GOTarget.name != lastGoName))
            {
                lastGoName = GOTarget.name;
                Parent.Tab.TabText.text = $"[G] {GOTarget.name}";
                NameInput.Text = GOTarget.name;
            }

            if (force || !PathInput.Component.isFocused)
            {
                string path = GOTarget.transform.GetTransformPath();
                if (path != lastPath)
                {
                    lastPath = path;
                    PathInput.Text = path;
                }
            }

            if (force || GOTarget.transform.parent != lastParentState)
            {
                lastParentState = GOTarget.transform.parent;
                ViewParentButton.Component.interactable = lastParentState;
                if (lastParentState)
                {
                    ViewParentButton.ButtonText.color = Color.white;
                    ViewParentButton.ButtonText.text = "â—„ View Parent";
                }
                else
                {
                    ViewParentButton.ButtonText.color = Color.grey;
                    ViewParentButton.ButtonText.text = "No parent";
                }
            }

            if (force || GOTarget.activeSelf != ActiveSelfToggle.isOn)
            {
                ActiveSelfToggle.Set(GOTarget.activeSelf, false);
                ActiveSelfText.color = ActiveSelfToggle.isOn ? Color.green : Color.red;
            }

            if (force || GOTarget.isStatic != IsStaticToggle.isOn)
            {
                IsStaticToggle.Set(GOTarget.isStatic, false);
            }

            if (force || GOTarget.scene.handle != lastSceneHandle)
            {
                lastSceneHandle = GOTarget.scene.handle;
                SceneInput.Text = GOTarget.scene.IsValid() ? GOTarget.scene.name : "None (Asset/Resource)";
            }

            if (force || (!TagInput.Component.isFocused && GOTarget.tag != lastTag))
            {
                lastTag = GOTarget.tag;
                TagInput.Text = lastTag;
            }

            if (force || (GOTarget.layer != lastLayer))
            {
                lastLayer = GOTarget.layer;
                LayerDropdown.value = GOTarget.layer;
            }

            if (force || ((int)GOTarget.hideFlags != lastFlags))
            {
                lastFlags = (int)GOTarget.hideFlags;
                FlagsDropdown.captionText.text = GOTarget.hideFlags.ToString();
            }
        }

        private void OnViewParentClicked()
        {
            if (this.GOTarget && this.GOTarget.transform.parent)
            {
                Parent.ChangeTarget(this.GOTarget.transform.parent.gameObject);
            }
        }

        private void OnPathEndEdit(string input)
        {
            lastPath = input;

            if (string.IsNullOrEmpty(input))
            {
                DoSetParent(null);
            }
            else
            {
                Transform parentToSet = null;

                if (input.EndsWith("/"))
                    input = input.Remove(input.Length - 1);

                // try the easy way
                if (GameObject.Find(input) is GameObject found)
                {
                    parentToSet = found.transform;
                }
                else
                {
                    // look for inactive objects
                    var name = input.Split('/').Last();
                    var allObjects = RuntimeHelper.FindObjectsOfTypeAll(typeof(GameObject));
                    var shortList = new List<GameObject>();
                    foreach (var obj in allObjects)
                        if (obj.name == name) shortList.Add(obj.TryCast<GameObject>());
                    foreach (var go in shortList)
                    {
                        var path = go.transform.GetTransformPath(true);
                        if (path.EndsWith("/"))
                            path = path.Remove(path.Length - 1);
                        if (path == input)
                        {
                            parentToSet = go.transform;
                            break;
                        }
                    }
                }

                if (parentToSet)
                    DoSetParent(parentToSet);
                else
                {
                    ExplorerCore.LogWarning($"Could not find any GameObject name or path '{input}'!");
                    UpdateGameObjectInfo(false, true);
                }
            }

        }

        private void DoSetParent(Transform transform)
        {
            ExplorerCore.Log($"Setting target's transform parent to: {(transform == null ? "null" : $"'{transform.name}'")}");

            if (GOTarget.GetComponent<RectTransform>())
                GOTarget.transform.SetParent(transform, false);
            else
                GOTarget.transform.parent = transform;

            UpdateGameObjectInfo(false, false);
            UpdateTransformControlValues(false);
        }

        private void OnNameEndEdit(string value)
        {
            GOTarget.name = value;
            UpdateGameObjectInfo(false, true);
        }

        private void OnActiveSelfToggled(bool value)
        {
            GOTarget.SetActive(value);
            UpdateGameObjectInfo(false, true);
        }

        private void OnTagEndEdit(string value)
        {
            try
            {
                GOTarget.tag = value;
                UpdateGameObjectInfo(false, true);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting tag! {ex.ReflectionExToString()}");
            }
        }

        private void OnExploreButtonClicked()
        {
            var panel = UIManager.GetPanel<UI.Panels.ObjectExplorerPanel>(UIManager.Panels.ObjectExplorer);
            panel.SceneExplorer.JumpToTransform(this.Parent.GOTarget.transform);
        }

        private void OnLayerDropdownChanged(int value)
        {
            GOTarget.layer = value;
            UpdateGameObjectInfo(false, true);
        }

        private void OnFlagsDropdownChanged(int value)
        {
            try
            {
                var enumVal = hideFlagsValues[FlagsDropdown.options[value].text];
                GOTarget.hideFlags = enumVal;

                UpdateGameObjectInfo(false, true);
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting hideFlags: {ex}");
            }
        }

        private void OnDestroyClicked()
        {
            GameObject.Destroy(this.GOTarget);
            InspectorManager.ReleaseInspector(Parent);
        }

        private void OnInstantiateClicked()
        {
            var clone = GameObject.Instantiate(this.GOTarget);
            InspectorManager.Inspect(clone);
        }

        #endregion


        #region Transform Controls

        private enum TransformType { Position, LocalPosition, Rotation, Scale }

        private class TransformControl
        {
            public TransformType Type;
            public InputFieldRef Input;

            public TransformControl(TransformType type, InputFieldRef input)
            {
                this.Type = type;
                this.Input = input;
            }
        }

        private class VectorSlider
        {
            public int axis;
            public Slider slider;
            public TransformControl parentControl;

            public VectorSlider(int axis, Slider slider, TransformControl parentControl)
            {
                this.axis = axis;
                this.slider = slider;
                this.parentControl = parentControl;
            }
        }

        private Vector3 lastPosValue;
        private Vector3 lastLocalValue;
        private Quaternion lastRotValue;
        private Vector3 lastScaleValue;

        public void UpdateTransformControlValues(bool force)
        {
            var transform = GOTarget.transform;
            if (force || (!PositionControl.Input.Component.isFocused && lastPosValue != transform.position))
            {
                PositionControl.Input.Text = ParseUtility.ToStringForInput(transform.position, typeof(Vector3));
                lastPosValue = transform.position;
            }
            if (force || (!LocalPositionControl.Input.Component.isFocused && lastLocalValue != transform.localPosition))
            {
                LocalPositionControl.Input.Text = ParseUtility.ToStringForInput(transform.localPosition, typeof(Vector3));
                lastLocalValue = transform.localPosition;
            }
            if (force || (!RotationControl.Input.Component.isFocused && lastRotValue != transform.localRotation))
            {
                RotationControl.Input.Text = ParseUtility.ToStringForInput(transform.localRotation, typeof(Quaternion));
                lastRotValue = transform.localRotation;
            }
            if (force || (!ScaleControl.Input.Component.isFocused && lastScaleValue != transform.localScale))
            {
                ScaleControl.Input.Text = ParseUtility.ToStringForInput(transform.localScale, typeof(Vector3));
                lastScaleValue = transform.localScale;
            }
        }

        private void OnTransformInputEndEdit(TransformType type, string input)
        {
            switch (type)
            {
                case TransformType.Position:
                    {
                        if (ParseUtility.TryParse(input, typeof(Vector3), out object boxed, out _))
                            GOTarget.transform.position = (Vector3)boxed;
                    }
                    break;
                case TransformType.LocalPosition:
                    {
                        if (ParseUtility.TryParse(input, typeof(Vector3), out object boxed, out _))
                            GOTarget.transform.localPosition = (Vector3)boxed;
                    }
                    break;
                case TransformType.Rotation:
                    {
                        if (ParseUtility.TryParse(input, typeof(Quaternion), out object boxed, out _))
                            GOTarget.transform.localRotation = (Quaternion)boxed;
                    }
                    break;
                case TransformType.Scale:
                    {
                        if (ParseUtility.TryParse(input, typeof(Vector3), out object boxed, out _))
                            GOTarget.transform.localScale = (Vector3)boxed;
                    }
                    break;
            }

            UpdateTransformControlValues(true);
        }

        private void OnVectorSliderChanged(VectorSlider slider, float value)
        {
            if (value == 0f)
            {
                currentSlidingVectorControl = null;
            }
            else
            {
                currentSlidingVectorControl = slider;
                currentVectorValue = value;
            }
        }

        public void UpdateVectorSlider()
        {
            if (currentSlidingVectorControl == null)
                return;

            if (!InputManager.GetMouseButton(0))
            {
                currentSlidingVectorControl.slider.value = 0f;
                currentSlidingVectorControl = null;
                currentVectorValue = 0f;
                return;
            }

            var transform = GOTarget.transform;

            Vector3 vector = Vector2.zero;
            switch (currentSlidingVectorControl.parentControl.Type)
            {
                case TransformType.Position:
                    vector = transform.position; break;
                case TransformType.LocalPosition:
                    vector = transform.localPosition; break;
                case TransformType.Rotation:
                    vector = transform.eulerAngles; break;
                case TransformType.Scale:
                    vector = transform.localScale; break;
            }

            // apply vector value change
            switch (currentSlidingVectorControl.axis)
            {
                case 0:
                    vector.x += currentVectorValue; break;
                case 1:
                    vector.y += currentVectorValue; break;
                case 2:
                    vector.z += currentVectorValue; break;
            }

            // set vector back to transform
            switch (currentSlidingVectorControl.parentControl.Type)
            {
                case TransformType.Position:
                    transform.position = vector; break;
                case TransformType.LocalPosition:
                    transform.localPosition = vector; break;
                case TransformType.Rotation:
                    transform.eulerAngles = vector; break;
                case TransformType.Scale:
                    transform.localScale = vector; break;
            }

            UpdateTransformControlValues(false);
        }

        #endregion


        #region GO Controls UI Construction

        private void ConstructTopInfo()
        {
            var topInfoHolder = UIFactory.CreateVerticalGroup(Parent.Content, "TopInfoHolder", false, false, true, true, 3,
                new Vector4(3, 3, 3, 3), new Color(0.1f, 0.1f, 0.1f), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(topInfoHolder, minHeight: 100, flexibleWidth: 9999);
            topInfoHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // first row (parent, path)

            var firstRow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(firstRow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(firstRow, minHeight: 25, flexibleWidth: 9999);

            ViewParentButton = UIFactory.CreateButton(firstRow, "ViewParentButton", "â—„ View Parent", new Color(0.2f, 0.2f, 0.2f));
            ViewParentButton.ButtonText.fontSize = 13;
            UIFactory.SetLayoutElement(ViewParentButton.Component.gameObject, minHeight: 25, minWidth: 100);
            ViewParentButton.OnClick += OnViewParentClicked;

            this.PathInput = UIFactory.CreateInputField(firstRow, "PathInput", "...");
            PathInput.Component.textComponent.color = Color.grey;
            PathInput.Component.textComponent.fontSize = 14;
            UIFactory.SetLayoutElement(PathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);
            PathInput.Component.lineType = InputField.LineType.MultiLineSubmit;

            var copyButton = UIFactory.CreateButton(firstRow, "CopyButton", "Copy to Clipboard", new Color(0.2f, 0.2f, 0.2f, 1));
            copyButton.ButtonText.color = Color.yellow;
            UIFactory.SetLayoutElement(copyButton.Component.gameObject, minHeight: 25, minWidth: 120);
            copyButton.OnClick += OnCopyClicked;

            //var pathApplyBtn = UIFactory.CreateButton(firstRow, "PathButton", "Set Parent Path", new Color(0.2f, 0.2f, 0.2f));
            //UIFactory.SetLayoutElement(pathApplyBtn.Component.gameObject, minHeight: 25, minWidth: 120);
            //pathApplyBtn.OnClick += () => { OnPathEndEdit(PathInput.Text); };

            PathInput.Component.GetOnEndEdit().AddListener((string val) => { OnPathEndEdit(val); });

            // Title and update row

            var titleRow = UIFactory.CreateUIObject("TitleRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(titleRow, false, false, true, true, 5);

            var titleLabel = UIFactory.CreateLabel(titleRow, "Title", SignatureHighlighter.Parse(typeof(GameObject), false),
                TextAnchor.MiddleLeft, fontSize: 17);
            UIFactory.SetLayoutElement(titleLabel.gameObject, minHeight: 30, minWidth: 100);

            // name

            NameInput = UIFactory.CreateInputField(titleRow, "NameInput", "untitled");
            UIFactory.SetLayoutElement(NameInput.Component.gameObject, minHeight: 30, minWidth: 100, flexibleWidth: 9999);
            NameInput.Component.textComponent.fontSize = 15;
            NameInput.Component.GetOnEndEdit().AddListener((string val) => { OnNameEndEdit(val); });

            // second row (toggles, instanceID, tag, buttons)

            var secondRow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(secondRow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(secondRow, minHeight: 25, flexibleWidth: 9999);

            // activeSelf
            var activeToggleObj = UIFactory.CreateToggle(secondRow, "ActiveSelf", out ActiveSelfToggle, out ActiveSelfText);
            UIFactory.SetLayoutElement(activeToggleObj, minHeight: 25, minWidth: 100);
            ActiveSelfText.text = "ActiveSelf";
            ActiveSelfToggle.onValueChanged.AddListener(OnActiveSelfToggled);

            // isStatic
            var isStaticObj = UIFactory.CreateToggle(secondRow, "IsStatic", out IsStaticToggle, out Text staticText);
            UIFactory.SetLayoutElement(isStaticObj, minHeight: 25, minWidth: 80);
            staticText.text = "IsStatic";
            staticText.color = Color.grey;
            IsStaticToggle.interactable = false;

            // InstanceID
            var instanceIdLabel = UIFactory.CreateLabel(secondRow, "InstanceIDLabel", "Instance ID:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(instanceIdLabel.gameObject, minHeight: 25, minWidth: 90);

            InstanceIDInput = UIFactory.CreateInputField(secondRow, "InstanceIDInput", "error");
            UIFactory.SetLayoutElement(InstanceIDInput.Component.gameObject, minHeight: 25, minWidth: 110);
            InstanceIDInput.Component.textComponent.color = Color.grey;
            InstanceIDInput.Component.readOnly = true;

            //Tag
            var tagLabel = UIFactory.CreateLabel(secondRow, "TagLabel", "Tag:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(tagLabel.gameObject, minHeight: 25, minWidth: 40);

            TagInput = UIFactory.CreateInputField(secondRow, "TagInput", "none");
            UIFactory.SetLayoutElement(TagInput.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);
            TagInput.Component.textComponent.color = Color.white;
            TagInput.Component.GetOnEndEdit().AddListener((string val) => { OnTagEndEdit(val); });

            // Instantiate
            var instantiateBtn = UIFactory.CreateButton(secondRow, "InstantiateBtn", "Instantiate", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(instantiateBtn.Component.gameObject, minHeight: 25, minWidth: 120);
            instantiateBtn.OnClick += OnInstantiateClicked;

            // Destroy
            var destroyBtn = UIFactory.CreateButton(secondRow, "DestroyBtn", "Destroy", new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(destroyBtn.Component.gameObject, minHeight: 25, minWidth: 80);
            destroyBtn.OnClick += OnDestroyClicked;

            // third row (scene, layer, flags)

            var thirdrow = UIFactory.CreateUIObject("ParentRow", topInfoHolder);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(thirdrow, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(thirdrow, minHeight: 25, flexibleWidth: 9999);

            // Inspect in Explorer button
            var explorerBtn = UIFactory.CreateButton(thirdrow, "ExploreBtn", "Show in Explorer", new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(explorerBtn.Component.gameObject, minHeight: 25, minWidth: 100);
            explorerBtn.ButtonText.fontSize = 12;
            explorerBtn.OnClick += OnExploreButtonClicked;

            // Scene
            var sceneLabel = UIFactory.CreateLabel(thirdrow, "SceneLabel", "Scene:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(sceneLabel.gameObject, minHeight: 25, minWidth: 50);

            SceneInput = UIFactory.CreateInputField(thirdrow, "SceneInput", "untitled");
            UIFactory.SetLayoutElement(SceneInput.Component.gameObject, minHeight: 25, minWidth: 120, flexibleWidth: 999);
            SceneInput.Component.readOnly = true;
            SceneInput.Component.textComponent.color = new Color(0.7f, 0.7f, 0.7f);

            // Layer
            var layerLabel = UIFactory.CreateLabel(thirdrow, "LayerLabel", "Layer:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(layerLabel.gameObject, minHeight: 25, minWidth: 50);

            var layerDrop = UIFactory.CreateDropdown(thirdrow, "LayerDropdown", out LayerDropdown, "0", 14, OnLayerDropdownChanged);
            UIFactory.SetLayoutElement(layerDrop, minHeight: 25, minWidth: 110, flexibleWidth: 999);
            LayerDropdown.captionText.color = SignatureHighlighter.EnumGreen;
            if (layerToNames == null)
                GetLayerNames();
            foreach (var name in layerToNames)
                LayerDropdown.options.Add(new Dropdown.OptionData(name));
            LayerDropdown.value = 0;
            LayerDropdown.RefreshShownValue();

            // Flags
            var flagsLabel = UIFactory.CreateLabel(thirdrow, "FlagsLabel", "Flags:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(flagsLabel.gameObject, minHeight: 25, minWidth: 50);

            var flagsDrop = UIFactory.CreateDropdown(thirdrow, "FlagsDropdown", out FlagsDropdown, "None", 14, OnFlagsDropdownChanged);
            FlagsDropdown.captionText.color = SignatureHighlighter.EnumGreen;
            UIFactory.SetLayoutElement(flagsDrop, minHeight: 25, minWidth: 135, flexibleWidth: 999);
            if (hideFlagsValues == null)
                GetHideFlagNames();
            foreach (var name in hideFlagsValues.Keys)
                FlagsDropdown.options.Add(new Dropdown.OptionData(name));
            FlagsDropdown.value = 0;
            FlagsDropdown.RefreshShownValue();
        }

        private static List<string> layerToNames;

        private static void GetLayerNames()
        {
            layerToNames = new List<string>();
            for (int i = 0; i < 32; i++)
            {
                var name = RuntimeHelper.LayerToName(i);
                if (string.IsNullOrEmpty(name))
                    name = i.ToString();
                layerToNames.Add(name);
            }
        }

        private static Dictionary<string, HideFlags> hideFlagsValues;

        private static void GetHideFlagNames()
        {
            hideFlagsValues = new Dictionary<string, HideFlags>();

            var names = Enum.GetValues(typeof(HideFlags));
            foreach (HideFlags value in names)
            {
                hideFlagsValues.Add(value.ToString(), value);
            }
        }

        #endregion


        #region Transform Controls UI Construction

        private void ConstructTransformControls()
        {
            var transformGroup = UIFactory.CreateVerticalGroup(Parent.Content, "TransformControls", false, false, true, true, 2,
                new Vector4(2, 2, 0, 0), new Color(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(transformGroup, minHeight: 100, flexibleWidth: 9999);
            //transformGroup.SetActive(false);
            //var groupRect = transformGroup.GetComponent<RectTransform>();
            //groupRect.anchorMin = new Vector2(0, 1);
            //groupRect.anchorMax = new Vector2(1, 1);
            //groupRect.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, 0, 100);

            PositionControl = AddTransformRow(transformGroup, "Position:", TransformType.Position);
            LocalPositionControl = AddTransformRow(transformGroup, "Local Position:", TransformType.LocalPosition);
            RotationControl = AddTransformRow(transformGroup, "Rotation:", TransformType.Rotation);
            ScaleControl = AddTransformRow(transformGroup, "Scale:", TransformType.Scale);
        }

        private TransformControl AddTransformRow(GameObject transformGroup, string title, TransformType type)
        {
            var rowObj = UIFactory.CreateUIObject("Row_" + title, transformGroup);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, false, false, true, true, 5, 0, 0, 0, 0, default);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleWidth: 9999);

            var titleLabel = UIFactory.CreateLabel(rowObj, "PositionLabel", title, TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(titleLabel.gameObject, minHeight: 25, minWidth: 110);

            var inputField = UIFactory.CreateInputField(rowObj, "InputField", "...");
            UIFactory.SetLayoutElement(inputField.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);

            inputField.Component.GetOnEndEdit().AddListener((string value) => { OnTransformInputEndEdit(type, value); });

            var control = new TransformControl(type, inputField);

            AddVectorAxisSlider(rowObj, "X", 0, control);
            AddVectorAxisSlider(rowObj, "Y", 1, control);
            AddVectorAxisSlider(rowObj, "Z", 2, control);

            return control;
        }

        private VectorSlider AddVectorAxisSlider(GameObject parent, string title, int axis, TransformControl control)
        {
            var label = UIFactory.CreateLabel(parent, "Label_" + title, title + ":", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(label.gameObject, minHeight: 25, minWidth: 30);

            var sliderObj = UIFactory.CreateSlider(parent, "Slider_" + title, out var slider);
            UIFactory.SetLayoutElement(sliderObj, minHeight: 25, minWidth: 120, flexibleWidth: 0);
            slider.m_FillImage.color = Color.clear;

            slider.minValue = -1;
            slider.maxValue = 1;
            var sliderControl = new VectorSlider(axis, slider, control);

            slider.onValueChanged.AddListener((float val) =>
            {
                OnVectorSliderChanged(sliderControl, val);
            });

            return sliderControl;
        }

        #endregion
    }
}

```

`src/Inspectors/InspectorBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Panels;
using UniverseLib.UI;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.Inspectors
{
    public abstract class InspectorBase : IPooledObject
    {
        public bool IsActive { get; internal set; }
        public object Target { get; set; }

        public InspectorTab Tab { get; internal set; }

        public GameObject UIRoot { get; set; }

        public float DefaultHeight => -1f;
        public abstract GameObject CreateContent(GameObject parent);

        public abstract void Update();

        public abstract void CloseInspector();

        public virtual void OnBorrowedFromPool(object target)
        {
            this.Target = target;
            Tab = Pool<InspectorTab>.Borrow();
            Tab.UIRoot.transform.SetParent(InspectorPanel.Instance.NavbarHolder.transform, false);

            Tab.TabButton.OnClick += OnTabButtonClicked;
            Tab.CloseButton.OnClick += CloseInspector;
        }

        public virtual void OnReturnToPool()
        {
            Pool<InspectorTab>.Return(Tab);

            this.Target = null;

            Tab.TabButton.OnClick -= OnTabButtonClicked;
            Tab.CloseButton.OnClick -= CloseInspector;
        }

        public virtual void OnSetActive()
        {
            Tab.SetTabColor(true);
            UIRoot.SetActive(true);
            IsActive = true;
            LayoutRebuilder.ForceRebuildLayoutImmediate(UIRoot.GetComponent<RectTransform>());
        }

        public virtual void OnSetInactive()
        {
            Tab.SetTabColor(false);
            UIRoot.SetActive(false);
            IsActive = false;
        }

        private void OnTabButtonClicked()
        {
            InspectorManager.SetInspectorActive(this);
        }
    }
}

```

`src/Inspectors/InspectorManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.Inspectors;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.ObjectPool;
using UniverseLib.Utility;

namespace UnityExplorer
{
    public static class InspectorManager
    {
        public static readonly List<InspectorBase> Inspectors = new();

        public static InspectorBase ActiveInspector { get; private set; }
        private static InspectorBase lastActiveInspector;

        public static float PanelWidth;

        public static event Action OnInspectedTabsChanged;

        public static void Inspect(object obj, CacheObjectBase sourceCache = null)
        {
            if (obj.IsNullOrDestroyed())
                return;

            obj = obj.TryCast();

            if (TryFocusActiveInspector(obj))
                return;

            if (obj is GameObject)
                CreateInspector<GameObjectInspector>(obj);
            else
                CreateInspector<ReflectionInspector>(obj, false, sourceCache);
        }

        public static void Inspect(Type type)
        {
            CreateInspector<ReflectionInspector>(type, true);
        }

        private static bool TryFocusActiveInspector(object target)
        {
            foreach (var inspector in Inspectors)
            {
                if (inspector.Target.ReferenceEqual(target))
                {
                    UIManager.SetPanelActive(UIManager.Panels.Inspector, true);
                    SetInspectorActive(inspector);
                    return true;
                }
            }
            return false;
        }

        public static void SetInspectorActive(InspectorBase inspector)
        {
            UnsetActiveInspector();

            ActiveInspector = inspector;
            inspector.OnSetActive();
        }

        public static void UnsetActiveInspector()
        {
            if (ActiveInspector != null)
            {
                lastActiveInspector = ActiveInspector;
                ActiveInspector.OnSetInactive();
                ActiveInspector = null;
            }
        }

        internal static void CloseAllTabs()
        {
            if (Inspectors.Any())
            {
                for (int i = Inspectors.Count - 1; i >= 0; i--)
                    Inspectors[i].CloseInspector();

                Inspectors.Clear();
            }

            UIManager.SetPanelActive(UIManager.Panels.Inspector, false);
        }

        private static void CreateInspector<T>(object target, bool staticReflection = false,
            CacheObjectBase parentObject = null) where T : InspectorBase
        {
            var inspector = Pool<T>.Borrow();
            Inspectors.Add(inspector);
            inspector.Target = target;

            if (parentObject != null && parentObject.CanWrite)
            {
                // only set parent cache object if we are inspecting a struct, otherwise there is no point.
                if (target.GetType().IsValueType && inspector is ReflectionInspector ri)
                    ri.ParentCacheObject = parentObject;
            }

            UIManager.SetPanelActive(UIManager.Panels.Inspector, true);
            inspector.UIRoot.transform.SetParent(InspectorPanel.Instance.ContentHolder.transform, false);

            if (inspector is ReflectionInspector reflectInspector)
                reflectInspector.StaticOnly = staticReflection;

            inspector.OnBorrowedFromPool(target);
            SetInspectorActive(inspector);

            OnInspectedTabsChanged?.Invoke();
        }

        internal static void ReleaseInspector<T>(T inspector) where T : InspectorBase
        {
            if (lastActiveInspector == inspector)
                lastActiveInspector = null;

            bool wasActive = ActiveInspector == inspector;
            int wasIdx = Inspectors.IndexOf(inspector);

            Inspectors.Remove(inspector);
            inspector.OnReturnToPool();
            Pool<T>.Return(inspector);

            if (wasActive)
            {
                ActiveInspector = null;
                // Try focus another inspector, or close the window.
                if (lastActiveInspector != null)
                {
                    SetInspectorActive(lastActiveInspector);
                    lastActiveInspector = null;
                }
                else if (Inspectors.Any())
                {
                    int newIdx = Math.Min(Inspectors.Count - 1, Math.Max(0, wasIdx - 1));
                    SetInspectorActive(Inspectors[newIdx]);
                }
                else
                {
                    UIManager.SetPanelActive(UIManager.Panels.Inspector, false);
                }
            }

            OnInspectedTabsChanged?.Invoke();
        }

        internal static void Update()
        {
            for (int i = Inspectors.Count - 1; i >= 0; i--)
                Inspectors[i].Update();
        }

        internal static void OnPanelResized(float width)
        {
            PanelWidth = width;

            foreach (var obj in Inspectors)
            {
                if (obj is ReflectionInspector inspector)
                {
                    inspector.SetLayouts();
                }
            }
        }
    }
}

```

`src/Inspectors/InspectorTab.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.Inspectors
{
    public class InspectorTab : IPooledObject
    {
        public GameObject UIRoot { get; set; }
        public float DefaultHeight => 25f;

        public ButtonRef TabButton;
        public Text TabText;
        public ButtonRef CloseButton;

        private static readonly Color enabledTabColor = new(0.15f, 0.22f, 0.15f);
        private static readonly Color disabledTabColor = new(0.13f, 0.13f, 0.13f);

        public void SetTabColor(bool active)
        {
            Color color = active ? enabledTabColor : disabledTabColor;
            RuntimeHelper.SetColorBlock(TabButton.Component, color, color * 1.2f);
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateHorizontalGroup(parent, "TabObject", false, true, true, true, 1,
                default, new Color(0.13f, 0.13f, 0.13f), childAlignment: TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 200, flexibleWidth: 0);
            UIRoot.AddComponent<Mask>();
            UIRoot.AddComponent<Outline>();

            TabButton = UIFactory.CreateButton(UIRoot, "TabButton", "");
            UIFactory.SetLayoutElement(TabButton.Component.gameObject, minWidth: 173, flexibleWidth: 0);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(TabButton.Component.gameObject, false, false, true, true, 0, 0, 0, 3);
            TabButton.GameObject.AddComponent<Mask>();

            TabText = TabButton.ButtonText;
            UIFactory.SetLayoutElement(TabText.gameObject, minHeight: 25, minWidth: 150, flexibleWidth: 0);
            TabText.alignment = TextAnchor.MiddleLeft;
            TabText.fontSize = 12;
            TabText.horizontalOverflow = HorizontalWrapMode.Overflow;

            CloseButton = UIFactory.CreateButton(UIRoot, "CloseButton", "X", new Color(0.15f, 0.15f, 0.15f, 1));
            UIFactory.SetLayoutElement(CloseButton.Component.gameObject, minHeight: 25, minWidth: 25, flexibleWidth: 0);
            CloseButton.ButtonText.color = Color.red;

            return UIRoot;
        }
    }
}

```

`src/Inspectors/MouseInspector.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UniverseLib.Input;
using UnityExplorer.Runtime;
using UnityExplorer.Inspectors.MouseInspectors;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.Utility;
using UnityExplorer.Config;

namespace UnityExplorer.Inspectors
{
    public enum MouseInspectMode
    {
        World,
        UI
    }

    public class MouseInspector : UIPanel
    {
        public static MouseInspector Instance { get; private set; }

        private readonly WorldInspector worldInspector;
        private readonly UiInspector uiInspector;

        public static bool Inspecting { get; set; }
        public static MouseInspectMode Mode { get; set; }

        public MouseInspectorBase CurrentInspector => Mode switch
        {
            MouseInspectMode.UI => uiInspector,
            MouseInspectMode.World => worldInspector,
            _ => null,
        };

        private static Vector3 lastMousePos;

        // UIPanel
        internal static readonly string UIBaseGUID = $"{ExplorerCore.GUID}.MouseInspector";
        private UIBase inspectorUIBase;

        public override string Name => "Inspect Under Mouse";
        public override UIManager.Panels PanelType => UIManager.Panels.MouseInspector;
        public override int MinWidth => -1;
        public override int MinHeight => -1;
        public override bool CanDragAndResize => false;
        public override bool NavButtonWanted => false;
        public override bool ShouldSaveActiveState => false;
        public override bool ShowByDefault => false;

        internal Text objNameLabel;
        internal Text objPathLabel;
        internal Text mousePosLabel;

        public MouseInspector() 
        {
            Instance = this;
            worldInspector = new WorldInspector();
            uiInspector = new UiInspector();
        }

        public static void OnDropdownSelect(int index)
        {
            switch (index)
            {
                case 0: return;
                case 1: Instance.StartInspect(MouseInspectMode.World); break;
                case 2: Instance.StartInspect(MouseInspectMode.UI); break;
            }
            InspectorPanel.Instance.MouseInspectDropdown.value = 0;
        }

        public void StartInspect(MouseInspectMode mode)
        {
            Mode = mode;
            Inspecting = true;

            CurrentInspector.OnBeginMouseInspect();

            PanelDragger.ForceEnd();
            UIManager.NavBarRect.gameObject.SetActive(false);
            UIManager.PanelHolder.SetActive(false);

            UIRoot.SetActive(true);
        }

        internal void ClearHitData()
        {
            CurrentInspector.ClearHitData();

            objNameLabel.text = "No hits...";
            objPathLabel.text = "";
        }

        public void StopInspect()
        {
            CurrentInspector.OnEndInspect();
            ClearHitData();
            Inspecting = false;

            UIManager.NavBarRect.gameObject.SetActive(true);
            UIManager.PanelHolder.SetActive(true);

            var drop = InspectorPanel.Instance.MouseInspectDropdown;
            if (drop.transform.Find("Dropdown List") is Transform list)
                drop.DestroyDropdownList(list.gameObject);

            UIRoot.SetActive(false);
        }

        private static float timeOfLastRaycast;

        public bool TryUpdate()
        {
            if (ConfigManager.World_MouseInspect_Keybind.Value != KeyCode.None)
            {
                if (InputManager.GetKeyDown(ConfigManager.World_MouseInspect_Keybind.Value))
                    Instance.StartInspect(MouseInspectMode.World);
            }

            if (ConfigManager.World_MouseInspect_Keybind.Value != KeyCode.None)
            {
                if (InputManager.GetKeyDown(ConfigManager.World_MouseInspect_Keybind.Value))
                    Instance.StartInspect(MouseInspectMode.World);
            }
            
            if (Inspecting)
                UpdateInspect();

            return Inspecting;
        }

        public void UpdateInspect()
        {
            if (InputManager.GetKeyDown(KeyCode.Escape))
            {
                StopInspect();
                return;
            }

            if (InputManager.GetMouseButtonDown(0))
            {
                CurrentInspector.OnSelectMouseInspect();
                StopInspect();
                return;
            }

            var mousePos = InputManager.MousePosition;
            if (mousePos != lastMousePos)
                UpdatePosition(mousePos);

            if (!timeOfLastRaycast.OccuredEarlierThan(0.1f))
                return;
            timeOfLastRaycast = Time.realtimeSinceStartup;

            CurrentInspector.UpdateMouseInspect(mousePos);
        }

        internal void UpdatePosition(Vector2 mousePos)
        {
            lastMousePos = mousePos;

            // use the raw mouse pos for the label
            mousePosLabel.text = $"<color=grey>Mouse Position:</color> {mousePos.ToString()}";

            // constrain the mouse pos we use within certain bounds
            if (mousePos.x < 350)
                mousePos.x = 350;
            if (mousePos.x > Screen.width - 350)
                mousePos.x = Screen.width - 350;
            if (mousePos.y < Rect.rect.height)
                mousePos.y += Rect.rect.height + 10;
            else
                mousePos.y -= 10;

            // calculate and set our UI position
            var inversePos = inspectorUIBase.RootObject.transform.InverseTransformPoint(mousePos);
            UIRoot.transform.localPosition = new Vector3(inversePos.x, inversePos.y, 0);
        }

        // UI Construction

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.anchorMin = Vector2.zero;
            Rect.anchorMax = Vector2.zero;
            Rect.pivot = new Vector2(0.5f, 1);
            Rect.sizeDelta = new Vector2(700, 150);
        }

        public override void ConstructPanelContent()
        {
            // hide title bar
            this.TitleBar.SetActive(false);
            this.UIRoot.transform.SetParent(UIManager.UIRoot.transform, false);

            var inspectContent = UIFactory.CreateVerticalGroup(this.uiContent, "InspectContent", true, true, true, true, 3, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(inspectContent, flexibleWidth: 9999, flexibleHeight: 9999);

            // Title text

            var title = UIFactory.CreateLabel(inspectContent, 
                "InspectLabel",
                "<b>Mouse Inspector</b> (press <b>ESC</b> to cancel)", 
                TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(title.gameObject, flexibleWidth: 9999);

            mousePosLabel = UIFactory.CreateLabel(inspectContent, "MousePosLabel", "Mouse Position:", TextAnchor.MiddleCenter);

            objNameLabel = UIFactory.CreateLabel(inspectContent, "HitLabelObj", "No hits...", TextAnchor.MiddleLeft);
            objNameLabel.horizontalOverflow = HorizontalWrapMode.Overflow;

            objPathLabel = UIFactory.CreateLabel(inspectContent, "PathLabel", "", TextAnchor.MiddleLeft);
            objPathLabel.fontStyle = FontStyle.Italic;
            objPathLabel.horizontalOverflow = HorizontalWrapMode.Wrap;

            UIFactory.SetLayoutElement(objPathLabel.gameObject, minHeight: 75);

            UIRoot.SetActive(false);

            // Create a new canvas for this panel to live on.
            // It needs to always be shown on the main display, other panels can move displays.

            inspectorUIBase = UniversalUI.RegisterUI(UIBaseGUID, null);
            UIRoot.transform.SetParent(inspectorUIBase.RootObject.transform);
        }
    }
}

```

`src/Inspectors/MouseInspectors/MouseInspectorBase.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace UnityExplorer.Inspectors.MouseInspectors
{
    public abstract class MouseInspectorBase
    {
        public abstract void OnBeginMouseInspect();

        public abstract void UpdateMouseInspect(Vector2 mousePos);

        public abstract void OnSelectMouseInspect();

        public abstract void ClearHitData();

        public abstract void OnEndInspect();
    }
}

```

`src/Inspectors/MouseInspectors/UiInspector.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.Input;

namespace UnityExplorer.Inspectors.MouseInspectors
{
    public class UiInspector : MouseInspectorBase
    {
        public static readonly List<GameObject> LastHitObjects = new List<GameObject>();

        private static GraphicRaycaster[] graphicRaycasters;

        private static readonly List<GameObject> currentHitObjects = new List<GameObject>();

        private static readonly List<Graphic> wasDisabledGraphics = new List<Graphic>();
        private static readonly List<CanvasGroup> wasDisabledCanvasGroups = new List<CanvasGroup>();
        private static readonly List<GameObject> objectsAddedCastersTo = new List<GameObject>();

        public override void OnBeginMouseInspect()
        {
            SetupUIRaycast();
            MouseInspector.Instance.objPathLabel.text = "";
        }

        public override void ClearHitData()
        {
            currentHitObjects.Clear();
        }

        public override void OnSelectMouseInspect()
        {
            LastHitObjects.Clear();
            LastHitObjects.AddRange(currentHitObjects);
            RuntimeHelper.StartCoroutine(SetPanelActiveCoro());
        }

        IEnumerator SetPanelActiveCoro()
        {
            yield return null;
            var panel = UIManager.GetPanel<UiInspectorResultsPanel>(UIManager.Panels.UIInspectorResults);
            panel.SetActive(true);
            panel.ShowResults();
        }

        public override void UpdateMouseInspect(Vector2 mousePos)
        {
            currentHitObjects.Clear();

            var ped = new PointerEventData(null)
            {
                position = mousePos
            };

            foreach (var gr in graphicRaycasters)
            {
                if (!gr || !gr.canvas)
                    continue;
            
                var list = new List<RaycastResult>();
                RuntimeHelper.GraphicRaycast(gr, ped, list);
                if (list.Count > 0)
                {
                    foreach (var hit in list)
                    {
                        if (hit.gameObject)
                            currentHitObjects.Add(hit.gameObject);
                    }
                }
            }
            
            if (currentHitObjects.Any())
                MouseInspector.Instance.objNameLabel.text = $"Click to view UI Objects under mouse: {currentHitObjects.Count}";
            else
                MouseInspector.Instance.objNameLabel.text = $"No UI objects under mouse.";
        }

        private static void SetupUIRaycast()
        {
            foreach (var obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(Canvas)))
            {
                var canvas = obj.TryCast<Canvas>();
                if (!canvas || !canvas.enabled || !canvas.gameObject.activeInHierarchy)
                    continue;
                if (!canvas.GetComponent<GraphicRaycaster>())
                {
                    canvas.gameObject.AddComponent<GraphicRaycaster>();
                    //ExplorerCore.Log("Added raycaster to " + canvas.name);
                    objectsAddedCastersTo.Add(canvas.gameObject);
                }
            }

            // recache Graphic Raycasters each time we start
            var casters = RuntimeHelper.FindObjectsOfTypeAll(typeof(GraphicRaycaster));
            graphicRaycasters = new GraphicRaycaster[casters.Length];
            for (int i = 0; i < casters.Length; i++)
            {
                graphicRaycasters[i] = casters[i].TryCast<GraphicRaycaster>();
            }

            // enable raycastTarget on Graphics
            foreach (var obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(Graphic)))
            {
                var graphic = obj.TryCast<Graphic>();
                if (!graphic || !graphic.enabled || graphic.raycastTarget || !graphic.gameObject.activeInHierarchy)
                    continue;
                graphic.raycastTarget = true;
                //ExplorerCore.Log("Enabled raycastTarget on " + graphic.name);
                wasDisabledGraphics.Add(graphic);
            }

            // enable blocksRaycasts on CanvasGroups
            foreach (var obj in RuntimeHelper.FindObjectsOfTypeAll(typeof(CanvasGroup)))
            {
                var canvas = obj.TryCast<CanvasGroup>();
                if (!canvas || !canvas.gameObject.activeInHierarchy || canvas.blocksRaycasts)
                    continue;
                canvas.blocksRaycasts = true;
                //ExplorerCore.Log("Enabled raycasts on " + canvas.name);
                wasDisabledCanvasGroups.Add(canvas);
            }
        }

        public override void OnEndInspect()
        {
            foreach (var obj in objectsAddedCastersTo)
            {
                if (obj.GetComponent<GraphicRaycaster>() is GraphicRaycaster raycaster)
                    GameObject.Destroy(raycaster);
            }

            foreach (var graphic in wasDisabledGraphics)
                graphic.raycastTarget = false;

            foreach (var canvas in wasDisabledCanvasGroups)
                canvas.blocksRaycasts = false;

            objectsAddedCastersTo.Clear();
            wasDisabledCanvasGroups.Clear();
            wasDisabledGraphics.Clear();
        }
    }
}

```

`src/Inspectors/MouseInspectors/WorldInspector.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.Inspectors.MouseInspectors
{
    public class WorldInspector : MouseInspectorBase
    {
        private static Camera MainCamera;
        private static GameObject lastHitObject;

        public override void OnBeginMouseInspect()
        {
            MainCamera = Camera.main;

            if (!MainCamera)
            {
                ExplorerCore.LogWarning("No MainCamera found! Cannot inspect world!");
                return;
            }
        }

        public override void ClearHitData()
        {
            lastHitObject = null;
        }

        public override void OnSelectMouseInspect()
        {
            InspectorManager.Inspect(lastHitObject);
        }

        public override void UpdateMouseInspect(Vector2 mousePos)
        {
            if (!MainCamera)
                MainCamera = Camera.main;
            if (!MainCamera)
            {
                ExplorerCore.LogWarning("No Main Camera was found, unable to inspect world!");
                MouseInspector.Instance.StopInspect();
                return;
            }

            var ray = MainCamera.ScreenPointToRay(mousePos);
            Physics.Raycast(ray, out RaycastHit hit, 1000f);

            if (hit.transform)
                OnHitGameObject(hit.transform.gameObject);
            else if (lastHitObject)
                MouseInspector.Instance.ClearHitData();
        }

        internal void OnHitGameObject(GameObject obj)
        {
            if (obj != lastHitObject)
            {
                lastHitObject = obj;
                MouseInspector.Instance.objNameLabel.text = $"<b>Click to Inspect:</b> <color=cyan>{obj.name}</color>";
                MouseInspector.Instance.objPathLabel.text = $"Path: {obj.transform.GetTransformPath(true)}";
            }
        }

        public override void OnEndInspect()
        {
            // not needed
        }
    }
}

```

`src/Inspectors/ReflectionInspector.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.Inspectors
{
    [Flags]
    public enum MemberFilter
    {
        None = 0,
        Property = 1,
        Field = 2,
        Constructor = 4,
        Method = 8,
        All = Property | Field | Method | Constructor,
    }

    public class ReflectionInspector : InspectorBase, ICellPoolDataSource<CacheMemberCell>, ICacheObjectController
    {
        public CacheObjectBase ParentCacheObject { get; set; }
        public Type TargetType { get; private set; }
        public bool StaticOnly { get; internal set; }
        public bool CanWrite => true;

        public bool AutoUpdateWanted => autoUpdateToggle.isOn;

        private List<CacheMember> members = new();
        private readonly List<CacheMember> filteredMembers = new();

        private BindingFlags scopeFlagsFilter;
        private string nameFilter;

        private MemberFilter MemberFilter = MemberFilter.All;

        // Updating

        private bool refreshWanted;
        private string lastNameFilter;
        private BindingFlags lastFlagsFilter;
        private MemberFilter lastMemberFilter = MemberFilter.All;
        private float timeOfLastAutoUpdate;

        // UI

        internal GameObject mainContentHolder;
        private static int LeftGroupWidth { get; set; }
        private static int RightGroupWidth { get; set; }

        public ScrollPool<CacheMemberCell> MemberScrollPool { get; private set; }
        public int ItemCount => filteredMembers.Count;

        public UnityObjectWidget UnityWidget;

        public InputFieldRef HiddenNameText;
        public Text NameText;
        public Text AssemblyText;
        private Toggle autoUpdateToggle;

        internal string currentBaseTabText;

        private readonly Dictionary<BindingFlags, ButtonRef> scopeFilterButtons = new();
        private readonly List<Toggle> memberTypeToggles = new();
        private InputFieldRef filterInputField;

        // const

        private readonly Color disabledButtonColor = new(0.24f, 0.24f, 0.24f);
        private readonly Color enabledButtonColor = new(0.2f, 0.27f, 0.2f);

        // Setup

        public override void OnBorrowedFromPool(object target)
        {
            base.OnBorrowedFromPool(target);
            CalculateLayouts();

            SetTarget(target);

            RuntimeHelper.StartCoroutine(InitCoroutine());
        }

        private IEnumerator InitCoroutine()
        {
            yield return null;
            LayoutRebuilder.ForceRebuildLayoutImmediate(InspectorPanel.Instance.ContentRect);
        }

        public override void CloseInspector()
        {
            InspectorManager.ReleaseInspector(this);
        }

        public override void OnReturnToPool()
        {
            foreach (var member in members)
            {
                member.UnlinkFromView();
                member.ReleasePooledObjects();
            }

            members.Clear();
            filteredMembers.Clear();

            autoUpdateToggle.isOn = false;

            if (UnityWidget != null)
            {
                UnityWidget.OnReturnToPool();
                Pool.Return(UnityWidget.GetType(), UnityWidget);
                this.UnityWidget = null;
            }

            base.OnReturnToPool();
        }

        // Setting target

        private void SetTarget(object target)
        {
            string prefix;
            if (StaticOnly)
            {
                Target = null;
                TargetType = target as Type;
                prefix = "[S]";
            }
            else
            {
                TargetType = target.GetActualType();
                prefix = "[R]";
            }

            // Setup main labels and tab text
            currentBaseTabText = $"{prefix} {SignatureHighlighter.Parse(TargetType, false)}";
            Tab.TabText.text = currentBaseTabText;
            NameText.text = SignatureHighlighter.Parse(TargetType, true);
            HiddenNameText.Text = SignatureHighlighter.RemoveHighlighting(NameText.text);

            string asmText;
            if (TargetType.Assembly is AssemblyBuilder || string.IsNullOrEmpty(TargetType.Assembly.Location))
                asmText = $"{TargetType.Assembly.GetName().Name} <color=grey><i>(in memory)</i></color>";
            else
                asmText = Path.GetFileName(TargetType.Assembly.Location);
            AssemblyText.text = $"<color=grey>Assembly:</color> {asmText}";

            // Unity object helper widget

            if (!StaticOnly)
                this.UnityWidget = UnityObjectWidget.GetUnityWidget(target, TargetType, this);

            // Get cache members

            this.members = CacheMemberFactory.GetCacheMembers(TargetType, this);

            // reset filters

            this.filterInputField.Text = string.Empty;

            SetFilter(string.Empty, StaticOnly ? BindingFlags.Static : BindingFlags.Default);
            scopeFilterButtons[BindingFlags.Default].Component.gameObject.SetActive(!StaticOnly);
            scopeFilterButtons[BindingFlags.Instance].Component.gameObject.SetActive(!StaticOnly);

            foreach (var toggle in memberTypeToggles)
                toggle.isOn = true;

            refreshWanted = true;
        }

        // Updating

        public override void Update()
        {
            if (!this.IsActive)
                return;

            if (!StaticOnly && Target.IsNullOrDestroyed(false))
            {
                InspectorManager.ReleaseInspector(this);
                return;
            }

            // check filter changes or force-refresh
            if (refreshWanted || nameFilter != lastNameFilter || scopeFlagsFilter != lastFlagsFilter || lastMemberFilter != MemberFilter)
            {
                lastNameFilter = nameFilter;
                lastFlagsFilter = scopeFlagsFilter;
                lastMemberFilter = MemberFilter;

                FilterMembers();
                MemberScrollPool.Refresh(true, true);
                refreshWanted = false;
            }

            // once-per-second updates
            if (timeOfLastAutoUpdate.OccuredEarlierThan(1))
            {
                timeOfLastAutoUpdate = Time.realtimeSinceStartup;

                if (this.UnityWidget != null)
                    UnityWidget.Update();

                if (AutoUpdateWanted)
                    UpdateDisplayedMembers();
            }
        }

        public void UpdateClicked()
        {
            UpdateDisplayedMembers();
        }

        // Filtering

        public void SetFilter(string name) => SetFilter(name, scopeFlagsFilter);

        public void SetFilter(BindingFlags flags) => SetFilter(nameFilter, flags);

        public void SetFilter(string name, BindingFlags flags)
        {
            this.nameFilter = name;

            if (flags != scopeFlagsFilter)
            {
                var btn = scopeFilterButtons[scopeFlagsFilter].Component;
                RuntimeHelper.SetColorBlock(btn, disabledButtonColor, disabledButtonColor * 1.3f);

                this.scopeFlagsFilter = flags;
                btn = scopeFilterButtons[scopeFlagsFilter].Component;
                RuntimeHelper.SetColorBlock(btn, enabledButtonColor, enabledButtonColor * 1.3f);
            }
        }

        private void OnMemberTypeToggled(MemberFilter flag, bool val)
        {
            if (!val)
                MemberFilter &= ~flag;
            else
                MemberFilter |= flag;
        }

        private void FilterMembers()
        {
            filteredMembers.Clear();

            for (int i = 0; i < members.Count; i++)
            {
                var member = members[i];

                if (scopeFlagsFilter != BindingFlags.Default)
                {
                    if (scopeFlagsFilter == BindingFlags.Instance && member.IsStatic
                        || scopeFlagsFilter == BindingFlags.Static && !member.IsStatic)
                        continue;
                }

                if ((member is CacheMethod && !MemberFilter.HasFlag(MemberFilter.Method))
                    || (member is CacheField && !MemberFilter.HasFlag(MemberFilter.Field))
                    || (member is CacheProperty && !MemberFilter.HasFlag(MemberFilter.Property))
                    || (member is CacheConstructor && !MemberFilter.HasFlag(MemberFilter.Constructor)))
                    continue;

                if (!string.IsNullOrEmpty(nameFilter) && !member.NameForFiltering.ContainsIgnoreCase(nameFilter))
                    continue;

                filteredMembers.Add(member);
            }
        }

        private void UpdateDisplayedMembers()
        {
            bool shouldRefresh = false;
            foreach (var cell in MemberScrollPool.CellPool)
            {
                if (!cell.Enabled || cell.Occupant == null)
                    continue;
                var member = cell.MemberOccupant;
                if (member.ShouldAutoEvaluate)
                {
                    shouldRefresh = true;
                    member.Evaluate();
                    member.SetDataToCell(member.CellView);
                }
            }

            if (shouldRefresh)
                MemberScrollPool.Refresh(false);
        }

        // Member cells

        public void OnCellBorrowed(CacheMemberCell cell) { } // not needed

        public void SetCell(CacheMemberCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, filteredMembers, SetCellLayout);
        }

        // Cell layout (fake table alignment)

        internal void SetLayouts()
        {
            CalculateLayouts();

            foreach (var cell in MemberScrollPool.CellPool)
                SetCellLayout(cell);
        }

        private void CalculateLayouts()
        {
            LeftGroupWidth = (int)Math.Max(200, (0.4f * InspectorManager.PanelWidth) - 5);
            RightGroupWidth = (int)Math.Max(200, InspectorManager.PanelWidth - LeftGroupWidth - 65);
        }

        private void SetCellLayout(CacheObjectCell cell)
        {
            cell.NameLayout.minWidth = LeftGroupWidth;
            cell.RightGroupLayout.minWidth = RightGroupWidth;

            if (cell.Occupant?.IValue != null)
                cell.Occupant.IValue.SetLayout();
        }

        private void OnCopyClicked()
        {
            ClipboardPanel.Copy(this.Target ?? this.TargetType);
        }

        // UI Construction

        public override GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "ReflectionInspector", true, true, true, true, 5,
                new Vector4(4, 4, 4, 4), new Color(0.065f, 0.065f, 0.065f));

            // Class name, assembly

            var topRow = UIFactory.CreateHorizontalGroup(UIRoot, "TopRow", false, false, true, true, 4, default, new(1, 1, 1, 0), TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(topRow, minHeight: 25, flexibleWidth: 9999);

            var titleHolder = UIFactory.CreateUIObject("TitleHolder", topRow);
            UIFactory.SetLayoutElement(titleHolder, minHeight: 35, flexibleHeight: 0, flexibleWidth: 9999);

            NameText = UIFactory.CreateLabel(titleHolder, "VisibleTitle", "NotSet", TextAnchor.MiddleLeft);
            var namerect = NameText.GetComponent<RectTransform>();
            namerect.anchorMin = new Vector2(0, 0);
            namerect.anchorMax = new Vector2(1, 1);
            NameText.fontSize = 17;
            UIFactory.SetLayoutElement(NameText.gameObject, minHeight: 35, flexibleHeight: 0, minWidth: 300, flexibleWidth: 9999);

            HiddenNameText = UIFactory.CreateInputField(titleHolder, "Title", "not set");
            var hiddenrect = HiddenNameText.Component.gameObject.GetComponent<RectTransform>();
            hiddenrect.anchorMin = new Vector2(0, 0);
            hiddenrect.anchorMax = new Vector2(1, 1);
            HiddenNameText.Component.readOnly = true;
            HiddenNameText.Component.lineType = InputField.LineType.MultiLineNewline;
            HiddenNameText.Component.gameObject.GetComponent<Image>().color = Color.clear;
            HiddenNameText.Component.textComponent.horizontalOverflow = HorizontalWrapMode.Wrap;
            HiddenNameText.Component.textComponent.fontSize = 17;
            HiddenNameText.Component.textComponent.color = Color.clear;
            UIFactory.SetLayoutElement(HiddenNameText.Component.gameObject, minHeight: 35, flexibleHeight: 0, flexibleWidth: 9999);

            var copyButton = UIFactory.CreateButton(topRow, "CopyButton", "Copy to Clipboard", new Color(0.2f, 0.2f, 0.2f, 1));
            copyButton.ButtonText.color = Color.yellow;
            UIFactory.SetLayoutElement(copyButton.Component.gameObject, minHeight: 25, minWidth: 120, flexibleWidth: 0);
            copyButton.OnClick += OnCopyClicked;

            AssemblyText = UIFactory.CreateLabel(UIRoot, "AssemblyLabel", "not set", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(AssemblyText.gameObject, minHeight: 25, flexibleWidth: 9999);

            mainContentHolder = UIFactory.CreateVerticalGroup(UIRoot, "MemberHolder", false, false, true, true, 5, new Vector4(2, 2, 2, 2),
                new Color(0.12f, 0.12f, 0.12f));
            UIFactory.SetLayoutElement(mainContentHolder, flexibleWidth: 9999, flexibleHeight: 9999);

            ConstructFirstRow(mainContentHolder);

            ConstructSecondRow(mainContentHolder);

            // Member scroll pool

            var memberBorder = UIFactory.CreateVerticalGroup(mainContentHolder, "ScrollPoolHolder", false, false, true, true, padding: new Vector4(2, 2, 2, 2),
                bgColor: new Color(0.05f, 0.05f, 0.05f));
            UIFactory.SetLayoutElement(memberBorder, flexibleWidth: 9999, flexibleHeight: 9999);

            MemberScrollPool = UIFactory.CreateScrollPool<CacheMemberCell>(memberBorder, "MemberList", out GameObject scrollObj,
                out GameObject _, new Color(0.09f, 0.09f, 0.09f));
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            MemberScrollPool.Initialize(this);

            // For debugging scroll pool
            //InspectorPanel.Instance.UIRoot.GetComponent<Mask>().enabled = false;
            //MemberScrollPool.Viewport.GetComponent<Mask>().enabled = false;
            //MemberScrollPool.Viewport.GetComponent<Image>().color = new Color(0.12f, 0.12f, 0.12f);

            return UIRoot;
        }

        // First row

        private void ConstructFirstRow(GameObject parent)
        {
            var rowObj = UIFactory.CreateUIObject("FirstRow", parent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, true, true, true, true, 5, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            var nameLabel = UIFactory.CreateLabel(rowObj, "NameFilterLabel", "Filter names:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, minHeight: 25, minWidth: 90, flexibleWidth: 0);

            filterInputField = UIFactory.CreateInputField(rowObj, "NameFilterInput", "...");
            UIFactory.SetLayoutElement(filterInputField.UIRoot, minHeight: 25, flexibleWidth: 300);
            filterInputField.OnValueChanged += (string val) => { SetFilter(val); };

            var spacer = UIFactory.CreateUIObject("Spacer", rowObj);
            UIFactory.SetLayoutElement(spacer, minWidth: 25);

            // Update button and toggle

            var updateButton = UIFactory.CreateButton(rowObj, "UpdateButton", "Update displayed values", new Color(0.22f, 0.28f, 0.22f));
            UIFactory.SetLayoutElement(updateButton.Component.gameObject, minHeight: 25, minWidth: 175, flexibleWidth: 0);
            updateButton.OnClick += UpdateClicked;

            var toggleObj = UIFactory.CreateToggle(rowObj, "AutoUpdateToggle", out autoUpdateToggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minWidth: 125, minHeight: 25);
            autoUpdateToggle.isOn = false;
            toggleText.text = "Auto-update";
        }

        // Second row

        private void ConstructSecondRow(GameObject parent)
        {
            var rowObj = UIFactory.CreateUIObject("SecondRow", parent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(rowObj, false, false, true, true, 5, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(rowObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Scope buttons

            var scopeLabel = UIFactory.CreateLabel(rowObj, "ScopeLabel", "Scope:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(scopeLabel.gameObject, minHeight: 25, minWidth: 60, flexibleWidth: 0);
            AddScopeFilterButton(rowObj, BindingFlags.Default, true);
            AddScopeFilterButton(rowObj, BindingFlags.Instance);
            AddScopeFilterButton(rowObj, BindingFlags.Static);

            var spacer = UIFactory.CreateUIObject("Spacer", rowObj);
            UIFactory.SetLayoutElement(spacer, minWidth: 15);

            // Member type toggles

            AddMemberTypeToggle(rowObj, MemberTypes.Property, 90);
            AddMemberTypeToggle(rowObj, MemberTypes.Field, 70);
            AddMemberTypeToggle(rowObj, MemberTypes.Method, 90);
            AddMemberTypeToggle(rowObj, MemberTypes.Constructor, 110);
        }

        private void AddScopeFilterButton(GameObject parent, BindingFlags flags, bool setAsActive = false)
        {
            string lbl = flags == BindingFlags.Default ? "All" : flags.ToString();
            var color = setAsActive ? enabledButtonColor : disabledButtonColor;

            var button = UIFactory.CreateButton(parent, "Filter_" + flags, lbl, color);
            UIFactory.SetLayoutElement(button.Component.gameObject, minHeight: 25, flexibleHeight: 0, minWidth: 70, flexibleWidth: 0);
            scopeFilterButtons.Add(flags, button);

            button.OnClick += () => { SetFilter(flags); };
        }

        private void AddMemberTypeToggle(GameObject parent, MemberTypes type, int width)
        {
            var toggleObj = UIFactory.CreateToggle(parent, "Toggle_" + type, out Toggle toggle, out Text toggleText);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 25, minWidth: width);
            string color = type switch
            {
                MemberTypes.Method => SignatureHighlighter.METHOD_INSTANCE,
                MemberTypes.Field => SignatureHighlighter.FIELD_INSTANCE,
                MemberTypes.Property => SignatureHighlighter.PROP_INSTANCE,
                MemberTypes.Constructor => SignatureHighlighter.CLASS_INSTANCE,
                _ => throw new NotImplementedException()
            };
            toggleText.text = $"<color={color}>{type}</color>";

            toggle.graphic.TryCast<Image>().color = color.ToColor() * 0.65f;

            MemberFilter flag = type switch
            {
                MemberTypes.Method => MemberFilter.Method,
                MemberTypes.Property => MemberFilter.Property,
                MemberTypes.Field => MemberFilter.Field,
                MemberTypes.Constructor => MemberFilter.Constructor,
                _ => throw new NotImplementedException()
            };

            toggle.onValueChanged.AddListener((bool val) => { OnMemberTypeToggled(flag, val); });

            memberTypeToggles.Add(toggle);
        }
    }
}

```

`src/Loader/BepInEx/BepInExConfigHandler.cs`:

```cs
#if BIE
using BepInEx.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.Config;

namespace UnityExplorer.Loader.BIE
{
    public class BepInExConfigHandler : ConfigHandler
    {
        private ConfigFile Config => ExplorerBepInPlugin.Instance.Config;

        private const string CTG_NAME = "UnityExplorer";

        public override void Init()
        {
            // Not necessary
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> config)
        {
            var entry = Config.Bind(CTG_NAME, config.Name, config.Value, config.Description);

            entry.SettingChanged += (object o, EventArgs e) =>
            {
                config.Value = entry.Value;
            };
        }

        public override T GetConfigValue<T>(ConfigElement<T> element)
        {
            if (Config.TryGetEntry(CTG_NAME, element.Name, out ConfigEntry<T> configEntry))
                return configEntry.Value;
            else
                throw new Exception("Could not get config entry '" + element.Name + "'");
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            if (Config.TryGetEntry(CTG_NAME, element.Name, out ConfigEntry<T> configEntry))
                configEntry.Value = value;
            else
                ExplorerCore.Log("Could not get config entry '" + element.Name + "'");
        }

        public override void LoadConfig()
        {
            foreach (var entry in ConfigManager.ConfigElements)
            {
                var key = entry.Key;
                var def = new ConfigDefinition(CTG_NAME, key);
                if (Config.ContainsKey(def) && Config[def] is ConfigEntryBase configEntry)
                {
                    var config = entry.Value;
                    config.BoxedValue = configEntry.BoxedValue;
                }
            }
        }

        public override void SaveConfig()
        {
            // not required
        }
    }
}

#endif
```

`src/Loader/BepInEx/ExplorerBepInPlugin.cs`:

```cs
#if BIE
using BepInEx;
using BepInEx.Logging;
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityExplorer.Config;
using UniverseLib.Input;
using UnityExplorer.Loader.BIE;
#if CPP
using BepInEx.IL2CPP;
using UnhollowerRuntimeLib;
#endif

namespace UnityExplorer
{
    [BepInPlugin(ExplorerCore.GUID, "UnityExplorer", ExplorerCore.VERSION)]

    public class ExplorerBepInPlugin :
#if MONO
        BaseUnityPlugin
#else
        BasePlugin
#endif
        , IExplorerLoader
    {
        public static ExplorerBepInPlugin Instance;

        public ManualLogSource LogSource
#if MONO
            => Logger;
#else
            => Log;
#endif

        public string UnhollowedModulesFolder => Path.Combine(Paths.BepInExRootPath, "unhollowed");

        public ConfigHandler ConfigHandler => _configHandler;
        private BepInExConfigHandler _configHandler;

        public Harmony HarmonyInstance => s_harmony;
        private static readonly Harmony s_harmony = new Harmony(ExplorerCore.GUID);

        public string ExplorerFolder => Path.Combine(Paths.PluginPath, ExplorerCore.NAME);

        public Action<object> OnLogMessage => LogSource.LogMessage;
        public Action<object> OnLogWarning => LogSource.LogWarning;
        public Action<object> OnLogError => LogSource.LogError;

        private void Init()
        {
            Instance = this;
            _configHandler = new BepInExConfigHandler();
            ExplorerCore.Init(this);
        }

#if MONO // Mono
        internal void Awake()
        {
            Init();
        }

#else   // Il2Cpp
        public override void Load()
        {
            Init();
        }
#endif
    }
}
#endif
```

`src/Loader/IExplorerLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.Config;

namespace UnityExplorer
{
    public interface IExplorerLoader
    {
        string ExplorerFolder { get; }
        string UnhollowedModulesFolder { get; }

        ConfigHandler ConfigHandler { get; }

        Action<object> OnLogMessage { get; }
        Action<object> OnLogWarning { get; }
        Action<object> OnLogError { get; }
    }
}

```

`src/Loader/MelonLoader/ExplorerMelonMod.cs`:

```cs
#if ML
using System;
using System.IO;
using MelonLoader;
using UnityExplorer;
using UnityExplorer.Config;
using UnityExplorer.Loader.ML;

#if CPP
[assembly: MelonPlatformDomain(MelonPlatformDomainAttribute.CompatibleDomains.IL2CPP)]
#else
[assembly: MelonPlatformDomain(MelonPlatformDomainAttribute.CompatibleDomains.MONO)]
#endif

[assembly: MelonInfo(typeof(ExplorerMelonMod), ExplorerCore.NAME, ExplorerCore.VERSION, ExplorerCore.AUTHOR)]
[assembly: MelonGame(null, null)]
[assembly: MelonColor(ConsoleColor.DarkCyan)]

namespace UnityExplorer
{
    public class ExplorerMelonMod : MelonMod, IExplorerLoader
    {
        public static ExplorerMelonMod Instance;

        public string ExplorerFolder => Path.Combine(MelonHandler.ModsDirectory, ExplorerCore.NAME);

        public string UnhollowedModulesFolder => Path.Combine(
            Path.GetDirectoryName(MelonHandler.ModsDirectory),
            Path.Combine("MelonLoader", "Managed"));

        public ConfigHandler ConfigHandler => _configHandler;
        public MelonLoaderConfigHandler _configHandler;

        public Action<object> OnLogMessage => LoggerInstance.Msg;
        public Action<object> OnLogWarning => LoggerInstance.Warning;
        public Action<object> OnLogError   => LoggerInstance.Error;

        public override void OnApplicationStart()
        {
            Instance = this;
            _configHandler = new MelonLoaderConfigHandler();

            ExplorerCore.Init(this);
        }
    }
}
#endif
```

`src/Loader/MelonLoader/MelonLoaderConfigHandler.cs`:

```cs
#if ML
using MelonLoader;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.Config;

namespace UnityExplorer.Loader.ML
{
    public class MelonLoaderConfigHandler : ConfigHandler
    {
        internal const string CTG_NAME = "UnityExplorer";

        internal MelonPreferences_Category prefCategory;

        public override void Init()
        {
            prefCategory = MelonPreferences.CreateCategory(CTG_NAME, $"{CTG_NAME} Settings", false, true);
        }

        public override void LoadConfig()
        {
            foreach (var entry in ConfigManager.ConfigElements)
            {
                var key = entry.Key;
                if (prefCategory.GetEntry(key) is MelonPreferences_Entry)
                {
                    var config = entry.Value;
                    config.BoxedValue = config.GetLoaderConfigValue();
                }
            }
        }

        // This wrapper exists to handle the "LemonAction" delegates which ML now uses in 0.4.4+.
        // Reflection is required since the delegate type changed between 0.4.3 and 0.4.4.
        // A wrapper class is required to link the MelonPreferences_Entry and the delegate instance.
        public class EntryDelegateWrapper<T>
        {
            public MelonPreferences_Entry<T> entry;
            public ConfigElement<T> config;

            public EntryDelegateWrapper(MelonPreferences_Entry<T> entry, ConfigElement<T> config)
            {
                this.entry = entry;
                this.config = config;
                var evt = entry.GetType().GetEvent("OnValueChangedUntyped");
                evt.AddEventHandler(entry, Delegate.CreateDelegate(evt.EventHandlerType, this, GetType().GetMethod("OnChanged")));
            }

            public void OnChanged()
            {
                if ((entry.Value == null && config.Value == null) || config.Value.Equals(entry.Value))
                    return;
                config.Value = entry.Value;
            }
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> config)
        {
            var entry = prefCategory.CreateEntry(config.Name, config.Value, null, config.Description, config.IsInternal, false);
            new EntryDelegateWrapper<T>(entry, config);
        }

        public override void SetConfigValue<T>(ConfigElement<T> config, T value)
        {
            if (prefCategory.GetEntry<T>(config.Name) is MelonPreferences_Entry<T> entry)
            { 
                entry.Value = value;
                //entry.Save();
            }
        }

        public override T GetConfigValue<T>(ConfigElement<T> config)
        {
            if (prefCategory.GetEntry<T>(config.Name) is MelonPreferences_Entry<T> entry)
                return entry.Value;

            return default;
        }

        public override void OnAnyConfigChanged()
        {
        }

        public override void SaveConfig()
        {
            MelonPreferences.Save();
        }
    }
}
#endif
```

`src/Loader/Standalone/Editor/ExplorerEditorBehaviour.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

namespace UnityExplorer.Loader.Standalone
{
    public class ExplorerEditorBehaviour : MonoBehaviour
    {
        internal void Awake()
        {
            ExplorerEditorLoader.Initialize();
            DontDestroyOnLoad(this);
            this.gameObject.hideFlags = HideFlags.HideAndDontSave;
        }

        internal void OnDestroy()
        {
            OnApplicationQuit();
        }

        internal void OnApplicationQuit()
        {
            if (UI.UIManager.UIRoot)
                Destroy(UI.UIManager.UIRoot.transform.root.gameObject);
        }
    }
}
#endif
```

`src/Loader/Standalone/Editor/ExplorerEditorLoader.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;

namespace UnityExplorer.Loader.Standalone
{
    public class ExplorerEditorLoader : ExplorerStandalone
    {
        public static void Initialize()
        {
            Instance = new ExplorerEditorLoader();
            OnLog += LogHandler;
            Instance.configHandler = new StandaloneConfigHandler();

            ExplorerCore.Init(Instance);
        }

        static void LogHandler(string message, LogType logType)
        {
            switch (logType)
            {
                case LogType.Assert:    Debug.LogError(message); break;
                case LogType.Error:     Debug.LogError(message); break;
                case LogType.Exception: Debug.LogError(message); break;
                case LogType.Log:       Debug.Log(message); break;
                case LogType.Warning:   Debug.LogWarning(message); break;
            }
        }

        protected override void CheckExplorerFolder()
        {
            if (explorerFolder == null)
                explorerFolder = Path.Combine(Application.dataPath, "UnityExplorer~");
        }
    }
}
#endif
```

`src/Loader/Standalone/ExplorerStandalone.cs`:

```cs
#if STANDALONE
using HarmonyLib;
using System;
using System.IO;
using System.Reflection;
using UnityEngine;
using UnityExplorer.Config;
using UnityEngine.EventSystems;
using UniverseLib.Input;
using UnityExplorer.Loader.Standalone;
#if CPP
using UnhollowerRuntimeLib;
#endif

namespace UnityExplorer
{
	public class ExplorerStandalone : IExplorerLoader
    {
        public static ExplorerStandalone Instance { get; protected set; }

        /// <summary>
        /// Invoked whenever Explorer logs something. Subscribe to this to handle logging.
        /// </summary>
        public static event Action<string, LogType> OnLog;

        public string UnhollowedModulesFolder => unhollowedPath;
        private string unhollowedPath;

        public ConfigHandler ConfigHandler => configHandler;
        internal StandaloneConfigHandler configHandler;

        public string ExplorerFolder
        {
            get
            {
                CheckExplorerFolder();
                return explorerFolder;
            }
        }
        protected static string explorerFolder;
        
        Action<object> IExplorerLoader.OnLogMessage => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Log); };
        Action<object> IExplorerLoader.OnLogWarning => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Warning); };
        Action<object> IExplorerLoader.OnLogError   => (object log) => { OnLog?.Invoke(log?.ToString() ?? "", LogType.Error); };

        /// <summary>
        /// Call this to initialize UnityExplorer without adding a log listener or Unhollowed modules path.
        /// The default Unhollowed path "UnityExplorer\Modules\" will be used.
        /// </summary>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance() => CreateInstance(null, null);

        /// <summary>
        /// Call this to initialize UnityExplorer and add a listener for UnityExplorer's log messages, without specifying an Unhollowed modules path.
        /// The default Unhollowed path "UnityExplorer\Modules\" will be used.
        /// </summary>
        /// <param name="logListener">Your log listener to handle UnityExplorer logs.</param>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance(Action<string, LogType> logListener) => CreateInstance(logListener, null);

        /// <summary>
        /// Call this to initialize UnityExplorer with the provided log listener and Unhollowed modules path.
        /// </summary>
        /// <param name="logListener">Your log listener to handle UnityExplorer logs.</param>
        /// <param name="unhollowedModulesPath">The path of the Unhollowed modules, either relative or absolute.</param>
        /// <returns>The new (or active, if one exists) instance of ExplorerStandalone.</returns>
        public static ExplorerStandalone CreateInstance(Action<string, LogType> logListener, string unhollowedModulesPath)
        {
            if (Instance != null)
                return Instance;

            var instance = new ExplorerStandalone();
            instance.Init();
            instance.CheckExplorerFolder();

            if (logListener != null)
                OnLog += logListener;

            if (string.IsNullOrEmpty(unhollowedModulesPath) || !Directory.Exists(unhollowedModulesPath))
                instance.unhollowedPath = Path.Combine(instance.ExplorerFolder, "Modules");
            else
                instance.unhollowedPath = unhollowedModulesPath;

            return instance;
        }

        internal void Init()
        {
            Instance = this;
            configHandler = new StandaloneConfigHandler();

            ExplorerCore.Init(this);
        }

        protected virtual void CheckExplorerFolder()
        {
            if (explorerFolder == null)
            {
                explorerFolder =
                    Path.Combine(
                        Path.GetDirectoryName(
                            Uri.UnescapeDataString(new Uri(Assembly.GetExecutingAssembly().CodeBase).AbsolutePath)),
                        "UnityExplorer");

                if (!Directory.Exists(explorerFolder))
                    Directory.CreateDirectory(explorerFolder);
            }
        }
    }
}
#endif
```

`src/Loader/Standalone/StandaloneConfigHandler.cs`:

```cs
#if STANDALONE
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityExplorer.Config;
using System.IO;
using UnityEngine;
using Tomlet;
using Tomlet.Models;

namespace UnityExplorer.Loader.Standalone
{
    public class StandaloneConfigHandler : ConfigHandler
    {
        internal static string CONFIG_PATH;

        public override void Init()
        {
            CONFIG_PATH = Path.Combine(ExplorerCore.Loader.ExplorerFolder, "config.cfg");
        }

        public override void LoadConfig()
        {
            if (!TryLoadConfig())
                SaveConfig();
        }

        public override void RegisterConfigElement<T>(ConfigElement<T> element)
        {
            // Not necessary
        }

        public override void SetConfigValue<T>(ConfigElement<T> element, T value)
        {
            // Not necessary, just save.
            SaveConfig();
        }

        public override T GetConfigValue<T>(ConfigElement<T> element)
        {
            // Not necessary, just return the value.
            return element.Value;
        }

        public bool TryLoadConfig()
        {
            try
            {
                if (!File.Exists(CONFIG_PATH))
                    return false;

                var document = TomlParser.ParseFile(CONFIG_PATH);
                foreach (var key in document.Keys)
                {
                    var config = ConfigManager.ConfigElements[key];
                    config.BoxedValue = StringToConfigValue(document.GetValue(key).StringValue, config.ElementType);
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        public object StringToConfigValue(string value, Type elementType)
        {
            if (elementType == typeof(KeyCode))
                return (KeyCode)Enum.Parse(typeof(KeyCode), value);
            else if (elementType == typeof(bool))
                return bool.Parse(value);
            else if (elementType == typeof(int))
                return int.Parse(value);
            else if (elementType == typeof(float))
                return float.Parse(value);
            else if (elementType.IsEnum)
                return Enum.Parse(elementType, value);
            else
                return value;
        }

        public override void OnAnyConfigChanged()
        {
            SaveConfig();
        }

        public override void SaveConfig()
        {
            var document = TomlDocument.CreateEmpty();
            foreach (var config in ConfigManager.ConfigElements)
                document.Put(config.Key, config.Value.BoxedValue.ToString());

            if (!Directory.Exists(ExplorerCore.Loader.ExplorerFolder))
                Directory.CreateDirectory(ExplorerCore.Loader.ExplorerFolder);

            File.WriteAllText(CONFIG_PATH, document.SerializedValue);
        }
    }
}

#endif
```

`src/ObjectExplorer/ObjectSearch.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.ObjectExplorer
{
    public class ObjectSearch : UIModel
    {
        public ObjectExplorerPanel Parent { get; }

        public ObjectSearch(ObjectExplorerPanel parent)
        {
            Parent = parent;
        }

        private SearchContext context = SearchContext.UnityObject;
        private SceneFilter sceneFilter = SceneFilter.Any;
        private ChildFilter childFilter = ChildFilter.Any;
        private string desiredTypeInput;
        private string lastCheckedTypeInput;
        private bool lastTypeCanHaveGameObject;

        public ButtonListHandler<object, ButtonCell> dataHandler;
        private ScrollPool<ButtonCell> resultsScrollPool;
        private List<object> currentResults = new();

        public override GameObject UIRoot => uiRoot;
        private GameObject uiRoot;
        private GameObject sceneFilterRow;
        private GameObject childFilterRow;
        private GameObject classInputRow;
        public TypeCompleter typeAutocompleter;
        private GameObject nameInputRow;
        private InputFieldRef nameInputField;
        private Text resultsLabel;

        public List<object> GetEntries() => currentResults;

        public void DoSearch()
        {
            cachedCellTexts.Clear();

            if (context == SearchContext.Singleton)
                currentResults = SearchProvider.InstanceSearch(desiredTypeInput).ToList();
            else if (context == SearchContext.Class)
                currentResults = SearchProvider.ClassSearch(desiredTypeInput);
            else
                currentResults = SearchProvider.UnityObjectSearch(nameInputField.Text, desiredTypeInput, childFilter, sceneFilter);

            dataHandler.RefreshData();
            resultsScrollPool.Refresh(true);

            resultsLabel.text = $"{currentResults.Count} results";
        }

        public void Update()
        {
            if (context == SearchContext.UnityObject && lastCheckedTypeInput != desiredTypeInput)
            {
                lastCheckedTypeInput = desiredTypeInput;

                //var type = ReflectionUtility.GetTypeByName(desiredTypeInput);
                if (ReflectionUtility.GetTypeByName(desiredTypeInput) is Type cachedType)
                {
                    var type = cachedType;
                    lastTypeCanHaveGameObject = typeof(Component).IsAssignableFrom(type) || type == typeof(GameObject);
                    sceneFilterRow.SetActive(lastTypeCanHaveGameObject);
                    childFilterRow.SetActive(lastTypeCanHaveGameObject);
                }
                else
                {
                    sceneFilterRow.SetActive(false);
                    childFilterRow.SetActive(false);
                    lastTypeCanHaveGameObject = false;
                }
            }
        }

        // UI Callbacks

        private void OnContextDropdownChanged(int value)
        {
            context = (SearchContext)value;

            lastCheckedTypeInput = null;
            sceneFilterRow.SetActive(false);
            childFilterRow.SetActive(false);

            nameInputRow.SetActive(context == SearchContext.UnityObject);

            if (context == SearchContext.Class)
                typeAutocompleter.AllTypes = true;
            else
            {
                typeAutocompleter.BaseType = context == SearchContext.UnityObject ? typeof(UnityEngine.Object) : typeof(object);
                typeAutocompleter.AllTypes = false;
            }
            typeAutocompleter.CacheTypes();
        }

        private void OnSceneFilterDropChanged(int value) => sceneFilter = (SceneFilter)value;

        private void OnChildFilterDropChanged(int value) => childFilter = (ChildFilter)value;

        private void OnTypeInputChanged(string val)
        {
            desiredTypeInput = val;

            if (string.IsNullOrEmpty(val))
            {
                sceneFilterRow.SetActive(false);
                childFilterRow.SetActive(false);
                lastCheckedTypeInput = val;
            }
        }

        // Cache the syntax-highlighted text for each search result to reduce allocs.
        private static readonly Dictionary<int, string> cachedCellTexts = new();

        public void SetCell(ButtonCell cell, int index)
        {
            if (!cachedCellTexts.ContainsKey(index))
            {
                string text;
                if (context == SearchContext.Class)
                {
                    var type = currentResults[index] as Type;
                    text = $"{SignatureHighlighter.Parse(type, true)} <color=grey><i>({type.Assembly.GetName().Name})</i></color>";
                }
                else
                    text = ToStringUtility.ToStringWithType(currentResults[index], currentResults[index]?.GetActualType());

                cachedCellTexts.Add(index, text);
            }

            cell.Button.ButtonText.text = cachedCellTexts[index];
        }

        private void OnCellClicked(int dataIndex)
        {
            if (context == SearchContext.Class)
                InspectorManager.Inspect(currentResults[dataIndex] as Type);
            else
                InspectorManager.Inspect(currentResults[dataIndex]);
        }

        private bool ShouldDisplayCell(object arg1, string arg2) => true;

        public override void ConstructUI(GameObject parent)
        {
            uiRoot = UIFactory.CreateVerticalGroup(parent, "ObjectSearch", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(uiRoot, flexibleHeight: 9999);

            // Search context row

            var contextGroup = UIFactory.CreateHorizontalGroup(uiRoot, "SearchContextRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(contextGroup, minHeight: 25, flexibleHeight: 0);

            var contextLbl = UIFactory.CreateLabel(contextGroup, "SearchContextLabel", "Searching for:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(contextLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            var contextDropObj = UIFactory.CreateDropdown(contextGroup, "ContextDropdown", out Dropdown contextDrop, null, 14, OnContextDropdownChanged);
            foreach (var name in Enum.GetNames(typeof(SearchContext)))
                contextDrop.options.Add(new Dropdown.OptionData(name));
            UIFactory.SetLayoutElement(contextDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Class input

            classInputRow = UIFactory.CreateHorizontalGroup(uiRoot, "ClassRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(classInputRow, minHeight: 25, flexibleHeight: 0);

            var unityClassLbl = UIFactory.CreateLabel(classInputRow, "ClassLabel", "Class filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(unityClassLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            var classInputField = UIFactory.CreateInputField(classInputRow, "ClassInput", "...");
            UIFactory.SetLayoutElement(classInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            typeAutocompleter = new TypeCompleter(typeof(UnityEngine.Object), classInputField);
            classInputField.OnValueChanged += OnTypeInputChanged;

            //unityObjectClassRow.SetActive(false);

            // Child filter row

            childFilterRow = UIFactory.CreateHorizontalGroup(uiRoot, "ChildFilterRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(childFilterRow, minHeight: 25, flexibleHeight: 0);

            var childLbl = UIFactory.CreateLabel(childFilterRow, "ChildLabel", "Child filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(childLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            var childDropObj = UIFactory.CreateDropdown(childFilterRow, "ChildFilterDropdown", out Dropdown childDrop, null, 14, OnChildFilterDropChanged);
            foreach (var name in Enum.GetNames(typeof(ChildFilter)))
                childDrop.options.Add(new Dropdown.OptionData(name));
            UIFactory.SetLayoutElement(childDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            childFilterRow.SetActive(false);

            // Scene filter row

            sceneFilterRow = UIFactory.CreateHorizontalGroup(uiRoot, "SceneFilterRow", false, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(sceneFilterRow, minHeight: 25, flexibleHeight: 0);

            var sceneLbl = UIFactory.CreateLabel(sceneFilterRow, "SceneLabel", "Scene filter:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(sceneLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            var sceneDropObj = UIFactory.CreateDropdown(sceneFilterRow, "SceneFilterDropdown", out Dropdown sceneDrop, null, 14, OnSceneFilterDropChanged);
            foreach (var name in Enum.GetNames(typeof(SceneFilter)))
            {
                if (!SceneHandler.DontDestroyExists && name == "DontDestroyOnLoad")
                    continue;
                sceneDrop.options.Add(new Dropdown.OptionData(name));
            }
            UIFactory.SetLayoutElement(sceneDropObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            sceneFilterRow.SetActive(false);

            // Name filter input

            nameInputRow = UIFactory.CreateHorizontalGroup(uiRoot, "NameRow", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(nameInputRow, minHeight: 25, flexibleHeight: 0);

            var nameLbl = UIFactory.CreateLabel(nameInputRow, "NameFilterLabel", "Name contains:", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(nameLbl.gameObject, minWidth: 110, flexibleWidth: 0);

            nameInputField = UIFactory.CreateInputField(nameInputRow, "NameFilterInput", "...");
            UIFactory.SetLayoutElement(nameInputField.UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Search button

            var searchButton = UIFactory.CreateButton(uiRoot, "SearchButton", "Search");
            UIFactory.SetLayoutElement(searchButton.Component.gameObject, minHeight: 25, flexibleHeight: 0);
            searchButton.OnClick += DoSearch;

            // Results count label

            var resultsCountRow = UIFactory.CreateHorizontalGroup(uiRoot, "ResultsCountRow", true, true, true, true);
            UIFactory.SetLayoutElement(resultsCountRow, minHeight: 25, flexibleHeight: 0);

            resultsLabel = UIFactory.CreateLabel(resultsCountRow, "ResultsLabel", "0 results", TextAnchor.MiddleCenter);

            // RESULTS SCROLL POOL

            dataHandler = new ButtonListHandler<object, ButtonCell>(resultsScrollPool, GetEntries, SetCell, ShouldDisplayCell, OnCellClicked);
            resultsScrollPool = UIFactory.CreateScrollPool<ButtonCell>(uiRoot, "ResultsList", out GameObject scrollObj,
                out GameObject scrollContent);

            resultsScrollPool.Initialize(dataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
        }
    }
}

```

`src/ObjectExplorer/SceneExplorer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityExplorer.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib;
using System.Collections;
using UniverseLib.Utility;

namespace UnityExplorer.ObjectExplorer
{
    public class SceneExplorer : UIModel
    {
        public ObjectExplorerPanel Parent { get; }

        public SceneExplorer(ObjectExplorerPanel parent)
        {
            Parent = parent;

            SceneHandler.OnInspectedSceneChanged += SceneHandler_OnInspectedSceneChanged;
            SceneHandler.OnLoadedScenesUpdated += SceneHandler_OnLoadedScenesUpdated;
        }

        public override GameObject UIRoot => uiRoot;
        private GameObject uiRoot;

        /// <summary>
        /// Whether to automatically update per auto-update interval or not.
        /// </summary>
        public bool AutoUpdate = false;

        public TransformTree Tree;
        private float timeOfLastUpdate = -1f;

        private GameObject refreshRow;
        private Dropdown sceneDropdown;
        private readonly Dictionary<Scene, Dropdown.OptionData> sceneToDropdownOption = new();

        // scene loader
        private Dropdown allSceneDropdown;
        private ButtonRef loadButton;
        private ButtonRef loadAdditiveButton;

        private IEnumerable<GameObject> GetRootEntries() => SceneHandler.CurrentRootObjects;

        public void Update()
        {
            if ((AutoUpdate || !SceneHandler.InspectingAssetScene) && timeOfLastUpdate.OccuredEarlierThan(1))
            {
                timeOfLastUpdate = Time.realtimeSinceStartup;
                UpdateTree();
            }
        }

        public void UpdateTree()
        {
            SceneHandler.Update();
            Tree.RefreshData(true, false, false, false);
        }

        public void JumpToTransform(Transform transform)
        {
            if (!transform)
                return;

            UIManager.SetPanelActive(this.Parent, true);
            this.Parent.SetTab(0);

            // select the transform's scene
            var go = transform.gameObject;
            if (SceneHandler.SelectedScene != go.scene)
            {
                int idx = sceneDropdown.options.IndexOf(sceneToDropdownOption[go.scene]);
                sceneDropdown.value = idx;
            }

            // Let the TransformTree handle the rest
            Tree.JumpAndExpandToTransform(transform);
        }

        private void OnSceneSelectionDropdownChanged(int value)
        {
            if (value < 0 || SceneHandler.LoadedScenes.Count <= value)
                return;

            SceneHandler.SelectedScene = SceneHandler.LoadedScenes[value];
            SceneHandler.Update();
            Tree.RefreshData(true, true, true, false);
            OnSelectedSceneChanged(SceneHandler.SelectedScene.Value);
        }

        private void SceneHandler_OnInspectedSceneChanged(Scene scene)
        {
            if (!sceneToDropdownOption.ContainsKey(scene))
                PopulateSceneDropdown(SceneHandler.LoadedScenes);

            if (sceneToDropdownOption.ContainsKey(scene))
            {
                var opt = sceneToDropdownOption[scene];
                int idx = sceneDropdown.options.IndexOf(opt);
                if (sceneDropdown.value != idx)
                    sceneDropdown.value = idx;
                else
                    sceneDropdown.captionText.text = opt.text;
            }

            OnSelectedSceneChanged(scene);
        }

        private void OnSelectedSceneChanged(Scene scene)
        {
            if (refreshRow)
                refreshRow.SetActive(!scene.IsValid());
        }

        private void SceneHandler_OnLoadedScenesUpdated(List<Scene> loadedScenes)
        {
            PopulateSceneDropdown(loadedScenes);
        }

        private void PopulateSceneDropdown(List<Scene> loadedScenes)
        {
            sceneToDropdownOption.Clear();
            sceneDropdown.options.Clear();

            foreach (var scene in loadedScenes)
            {
                if (sceneToDropdownOption.ContainsKey(scene))
                    continue;

                string name = scene.name?.Trim();

                if (!scene.IsValid())
                    name = "HideAndDontSave";
                else if (string.IsNullOrEmpty(name))
                    name = "<untitled>";

                var option = new Dropdown.OptionData(name);
                sceneDropdown.options.Add(option);
                sceneToDropdownOption.Add(scene, option);
            }
        }

        private void OnFilterInput(string input)
        {
            if ((!string.IsNullOrEmpty(input) && !Tree.Filtering) || (string.IsNullOrEmpty(input) && Tree.Filtering))
            {
                Tree.cachedTransforms.Clear();
            }

            Tree.CurrentFilter = input;
            Tree.RefreshData(true, false, true, false);
        }

        private void TryLoadScene(LoadSceneMode mode, Dropdown allSceneDrop)
        {
            var text = allSceneDrop.captionText.text;

            if (text == DEFAULT_LOAD_TEXT)
                return;

            try
            {
                SceneManager.LoadScene(text, mode);
                allSceneDrop.value = 0;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Unable to load the Scene! {ex.ReflectionExToString()}");
            }
        }

        public override void ConstructUI(GameObject content)
        {
            uiRoot = UIFactory.CreateUIObject("SceneExplorer", content);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(uiRoot, true, true, true, true, 0, 2, 2, 2, 2);
            UIFactory.SetLayoutElement(uiRoot, flexibleHeight: 9999);

            // Tool bar (top area)

            var toolbar = UIFactory.CreateVerticalGroup(uiRoot, "Toolbar", true, true, true, true, 2, new Vector4(2, 2, 2, 2),
               new Color(0.15f, 0.15f, 0.15f));

            // Scene selector dropdown

            var dropRow = UIFactory.CreateHorizontalGroup(toolbar, "DropdownRow", true, true, true, true, 5, default, new Color(1, 1, 1, 0));
            UIFactory.SetLayoutElement(dropRow, minHeight: 25, flexibleWidth: 9999);

            var dropLabel = UIFactory.CreateLabel(dropRow, "SelectorLabel", "Scene:", TextAnchor.MiddleLeft, Color.cyan, false, 15);
            UIFactory.SetLayoutElement(dropLabel.gameObject, minHeight: 25, minWidth: 60, flexibleWidth: 0);

            var dropdownObj = UIFactory.CreateDropdown(dropRow, "SceneDropdown", out sceneDropdown, "<notset>", 13, OnSceneSelectionDropdownChanged);
            UIFactory.SetLayoutElement(dropdownObj, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            SceneHandler.Update();
            PopulateSceneDropdown(SceneHandler.LoadedScenes);
            sceneDropdown.captionText.text = sceneToDropdownOption.First().Value.text;

            // Filter row

            var filterRow = UIFactory.CreateHorizontalGroup(toolbar, "FilterGroup", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(filterRow, minHeight: 25, flexibleHeight: 0);

            //Filter input field
            var inputField = UIFactory.CreateInputField(filterRow, "FilterInput", "Search and press enter...");
            inputField.Component.targetGraphic.color = new Color(0.2f, 0.2f, 0.2f);
            RuntimeHelper.SetColorBlock(inputField.Component, new Color(0.4f, 0.4f, 0.4f), new Color(0.2f, 0.2f, 0.2f),
                new Color(0.08f, 0.08f, 0.08f));
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25);
            //inputField.OnValueChanged += OnFilterInput;
            inputField.Component.GetOnEndEdit().AddListener(OnFilterInput);

            // refresh row

            refreshRow = UIFactory.CreateHorizontalGroup(toolbar, "RefreshGroup", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(refreshRow, minHeight: 30, flexibleHeight: 0);

            var refreshButton = UIFactory.CreateButton(refreshRow, "RefreshButton", "Update");
            UIFactory.SetLayoutElement(refreshButton.Component.gameObject, minWidth: 65, flexibleWidth: 0);
            refreshButton.OnClick += UpdateTree;

            var refreshToggle = UIFactory.CreateToggle(refreshRow, "RefreshToggle", out Toggle toggle, out Text text);
            UIFactory.SetLayoutElement(refreshToggle, flexibleWidth: 9999);
            text.text = "Auto-update (1 second)";
            text.alignment = TextAnchor.MiddleLeft;
            text.color = Color.white;
            text.fontSize = 12;
            toggle.isOn = false;
            toggle.onValueChanged.AddListener((bool val) => AutoUpdate = val);

            refreshRow.SetActive(false);

            // tree labels row

            var labelsRow = UIFactory.CreateHorizontalGroup(toolbar, "LabelsRow", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(labelsRow, minHeight: 30, flexibleHeight: 0);

            var nameLabel = UIFactory.CreateLabel(labelsRow, "NameLabel", "Name", TextAnchor.MiddleLeft, color: Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, flexibleWidth: 9999, minHeight: 25);

            var indexLabel = UIFactory.CreateLabel(labelsRow, "IndexLabel", "Sibling Index", TextAnchor.MiddleLeft, fontSize: 12, color: Color.grey);
            UIFactory.SetLayoutElement(indexLabel.gameObject, minWidth: 100, flexibleWidth: 0, minHeight: 25);

            // Transform Tree

            var scrollPool = UIFactory.CreateScrollPool<TransformCell>(uiRoot, "TransformTree", out GameObject scrollObj,
                out GameObject scrollContent, new Color(0.11f, 0.11f, 0.11f));
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            UIFactory.SetLayoutElement(scrollContent, flexibleHeight: 9999);

            Tree = new TransformTree(scrollPool, GetRootEntries);
            Tree.Init();
            Tree.RefreshData(true, true, true, false);
            //scrollPool.Viewport.GetComponent<Mask>().enabled = false;
            //UIRoot.GetComponent<Mask>().enabled = false;

            // Scene Loader

            ConstructSceneLoader();

            RuntimeHelper.StartCoroutine(TempFixCoro());
        }

        // To "fix" a strange FPS drop issue with MelonLoader.
        private IEnumerator TempFixCoro()
        {
            float start = Time.realtimeSinceStartup;

            while (Time.realtimeSinceStartup - start < 2.5f)
                yield return null;

            // Select "HideAndDontSave" and then go back to first scene.
            this.sceneDropdown.value = sceneDropdown.options.Count - 1;
            this.sceneDropdown.value = 0;
        }

        private const string DEFAULT_LOAD_TEXT = "[Select a scene]";

        private void RefreshSceneLoaderOptions(string filter)
        {
            allSceneDropdown.options.Clear();
            allSceneDropdown.options.Add(new Dropdown.OptionData(DEFAULT_LOAD_TEXT));

            foreach (var scene in SceneHandler.AllSceneNames)
            {
                if (string.IsNullOrEmpty(filter) || scene.ContainsIgnoreCase(filter))
                    allSceneDropdown.options.Add(new Dropdown.OptionData(Path.GetFileNameWithoutExtension(scene)));
            }

            allSceneDropdown.RefreshShownValue();

            if (loadButton != null)
                RefreshSceneLoaderButtons();
        }

        private void RefreshSceneLoaderButtons()
        {
            var text = allSceneDropdown.captionText.text;
            if (text == DEFAULT_LOAD_TEXT)
            {
                loadButton.Component.interactable = false;
                loadAdditiveButton.Component.interactable = false;
            }
            else
            {
                loadButton.Component.interactable = true;
                loadAdditiveButton.Component.interactable = true;
            }
        }

        private void ConstructSceneLoader()
        {
            // Scene Loader
            try
            {
                if (SceneHandler.WasAbleToGetScenesInBuild)
                {
                    var sceneLoaderObj = UIFactory.CreateVerticalGroup(uiRoot, "SceneLoader", true, true, true, true);
                    UIFactory.SetLayoutElement(sceneLoaderObj, minHeight: 25);

                    // Title

                    var loaderTitle = UIFactory.CreateLabel(sceneLoaderObj, "SceneLoaderLabel", "Scene Loader", TextAnchor.MiddleLeft, Color.white, true, 14);
                    UIFactory.SetLayoutElement(loaderTitle.gameObject, minHeight: 25, flexibleHeight: 0);

                    // Search filter

                    var searchFilterObj = UIFactory.CreateInputField(sceneLoaderObj, "SearchFilterInput", "Filter scene names...");
                    UIFactory.SetLayoutElement(searchFilterObj.UIRoot, minHeight: 25, flexibleHeight: 0);
                    searchFilterObj.OnValueChanged += RefreshSceneLoaderOptions;

                    // Dropdown

                    var allSceneDropObj = UIFactory.CreateDropdown(sceneLoaderObj, "SceneLoaderDropdown", out allSceneDropdown, "", 14, null);
                    UIFactory.SetLayoutElement(allSceneDropObj, minHeight: 25, minWidth: 150, flexibleWidth: 0, flexibleHeight: 0);

                    RefreshSceneLoaderOptions(string.Empty);

                    // Button row

                    var buttonRow = UIFactory.CreateHorizontalGroup(sceneLoaderObj, "LoadButtons", true, true, true, true, 4);

                    loadButton = UIFactory.CreateButton(buttonRow, "LoadSceneButton", "Load (Single)", new Color(0.1f, 0.3f, 0.3f));
                    UIFactory.SetLayoutElement(loadButton.Component.gameObject, minHeight: 25, minWidth: 150);
                    loadButton.OnClick += () =>
                    {
                        TryLoadScene(LoadSceneMode.Single, allSceneDropdown);
                    };

                    loadAdditiveButton = UIFactory.CreateButton(buttonRow, "LoadSceneButton", "Load (Additive)", new Color(0.1f, 0.3f, 0.3f));
                    UIFactory.SetLayoutElement(loadAdditiveButton.Component.gameObject, minHeight: 25, minWidth: 150);
                    loadAdditiveButton.OnClick += () =>
                    {
                        TryLoadScene(LoadSceneMode.Additive, allSceneDropdown);
                    };

                    var disabledColor = new Color(0.24f, 0.24f, 0.24f);
                    RuntimeHelper.SetColorBlock(loadButton.Component, disabled: disabledColor);
                    RuntimeHelper.SetColorBlock(loadAdditiveButton.Component, disabled: disabledColor);

                    loadButton.Component.interactable = false;
                    loadAdditiveButton.Component.interactable = false;

                    allSceneDropdown.onValueChanged.AddListener((int val) =>
                    {
                        RefreshSceneLoaderButtons();
                    });
                }
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Could not create the Scene Loader helper! {ex.ReflectionExToString()}");
            }
        }
    }
}

```

`src/ObjectExplorer/SceneHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.SceneManagement;
using UniverseLib;

namespace UnityExplorer.ObjectExplorer
{
    public static class SceneHandler
    {
        /// <summary>The currently inspected Scene.</summary>
        public static Scene? SelectedScene
        {
            get => selectedScene;
            internal set
            {
                if (selectedScene.HasValue && selectedScene == value)
                    return;
                selectedScene = value;
                OnInspectedSceneChanged?.Invoke((Scene)selectedScene);
            }
        }
        private static Scene? selectedScene;

        /// <summary>The GameObjects in the currently inspected scene.</summary>
        public static IEnumerable<GameObject> CurrentRootObjects { get; private set; } = new GameObject[0];

        /// <summary>All currently loaded Scenes.</summary>
        public static List<Scene> LoadedScenes { get; private set; } = new();
        //private static HashSet<Scene> previousLoadedScenes;

        /// <summary>The names of all scenes in the build settings, if they could be retrieved.</summary>
        public static List<string> AllSceneNames { get; private set; } = new();

        /// <summary>Invoked when the currently inspected Scene changes. The argument is the new scene.</summary>
        public static event Action<Scene> OnInspectedSceneChanged;

        /// <summary>Invoked whenever the list of currently loaded Scenes changes. The argument contains all loaded scenes after the change.</summary>
        public static event Action<List<Scene>> OnLoadedScenesUpdated;

        /// <summary>Generally will be 2, unless DontDestroyExists == false, then this will be 1.</summary>
        internal static int DefaultSceneCount => 1 + (DontDestroyExists ? 1 : 0);

        /// <summary>Whether or not we are currently inspecting the "HideAndDontSave" asset scene.</summary>
        public static bool InspectingAssetScene => SelectedScene.HasValue && SelectedScene.Value == default;

        /// <summary>Whether or not we successfuly retrieved the names of the scenes in the build settings.</summary>
        public static bool WasAbleToGetScenesInBuild { get; private set; }

        /// <summary>Whether or not the "DontDestroyOnLoad" scene exists in this game.</summary>
        public static bool DontDestroyExists { get; private set; }

        internal static void Init()
        {
            // Check if the game has "DontDestroyOnLoad"
            DontDestroyExists = Scene.GetNameInternal(-12) == "DontDestroyOnLoad";

            // Try to get all scenes in the build settings. This may not work.
            try
            {
                Type sceneUtil = ReflectionUtility.GetTypeByName("UnityEngine.SceneManagement.SceneUtility");
                if (sceneUtil == null)
                    throw new Exception("This version of Unity does not ship with the 'SceneUtility' class, or it was not unstripped.");

                var method = sceneUtil.GetMethod("GetScenePathByBuildIndex", ReflectionUtility.FLAGS);
                int sceneCount = SceneManager.sceneCountInBuildSettings;
                for (int i = 0; i < sceneCount; i++)
                {
                    var scenePath = (string)method.Invoke(null, new object[] { i });
                    AllSceneNames.Add(scenePath);
                }

                WasAbleToGetScenesInBuild = true;
            }
            catch (Exception ex)
            {
                WasAbleToGetScenesInBuild = false;
                ExplorerCore.LogWarning($"Unable to generate list of all Scenes in the build: {ex}");
            }
        }

        internal static void Update()
        {
            // Inspected scene will exist if it's DontDestroyOnLoad or HideAndDontSave
            bool inspectedExists = 
                SelectedScene.HasValue 
                && ((DontDestroyExists && SelectedScene.Value.handle == -12) 
                    || SelectedScene.Value.handle == -1);

            LoadedScenes.Clear();

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene scene = SceneManager.GetSceneAt(i);
                if (scene == default || !scene.isLoaded || !scene.IsValid())
                    continue;

                // If we have not yet confirmed inspectedExists, check if this scene is our currently inspected one.
                if (!inspectedExists && scene == SelectedScene)
                    inspectedExists = true;

                LoadedScenes.Add(scene);
            }

            if (DontDestroyExists)
                LoadedScenes.Add(new Scene { m_Handle = -12 });
            LoadedScenes.Add(new Scene { m_Handle = -1 });

            // Default to first scene if none selected or previous selection no longer exists.
            if (!inspectedExists)
                SelectedScene = LoadedScenes.First();

            // Notify on the list changing at all
            OnLoadedScenesUpdated?.Invoke(LoadedScenes);

            // Finally, update the root objects list.
            if (SelectedScene != null && ((Scene)SelectedScene).IsValid())
                CurrentRootObjects = RuntimeHelper.GetRootGameObjects((Scene)SelectedScene);
            else
            {
                var allObjects = RuntimeHelper.FindObjectsOfTypeAll(typeof(GameObject));
                var objects = new List<GameObject>();
                foreach (var obj in allObjects)
                {
                    var go = obj.TryCast<GameObject>();
                    if (go.transform.parent == null && !go.scene.IsValid())
                        objects.Add(go);
                }
                CurrentRootObjects = objects;
            }
        }
    }
}

```

`src/ObjectExplorer/SearchProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityExplorer.Runtime;
using UniverseLib;
using UniverseLib.Input;
using UniverseLib.Utility;

namespace UnityExplorer.ObjectExplorer
{
    public enum SearchContext
    {
        UnityObject,
        Singleton,
        Class
    }

    public enum ChildFilter
    {
        Any,
        RootObject,
        HasParent
    }

    public enum SceneFilter
    {
        Any,
        ActivelyLoaded,
        DontDestroyOnLoad,
        HideAndDontSave,
    }

    public static class SearchProvider
    {
        private static bool Filter(Scene scene, SceneFilter filter)
        {
            return filter switch
            {
                SceneFilter.Any => true,
                SceneFilter.DontDestroyOnLoad => scene.handle == -12,
                SceneFilter.HideAndDontSave => scene == default,
                SceneFilter.ActivelyLoaded => scene.buildIndex != -1,
                _ => false,
            };
        }

        internal static List<object> UnityObjectSearch(string input, string customTypeInput, ChildFilter childFilter, SceneFilter sceneFilter)
        {
            var results = new List<object>();

            Type searchType = null;
            if (!string.IsNullOrEmpty(customTypeInput))
            {
                if (ReflectionUtility.GetTypeByName(customTypeInput) is Type customType)
                {
                    if (typeof(UnityEngine.Object).IsAssignableFrom(customType))
                        searchType = customType;
                    else
                        ExplorerCore.LogWarning($"Custom type '{customType.FullName}' is not assignable from UnityEngine.Object!");
                }
                else
                    ExplorerCore.LogWarning($"Could not find any type by name '{customTypeInput}'!");
            }

            if (searchType == null)
                searchType = typeof(UnityEngine.Object);

            var allObjects = RuntimeHelper.FindObjectsOfTypeAll(searchType);

            // perform filter comparers

            string nameFilter = null;
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            bool shouldFilterGOs = searchType == typeof(GameObject) || typeof(Component).IsAssignableFrom(searchType);

            foreach (var obj in allObjects)
            {
                // name check
                if (!string.IsNullOrEmpty(nameFilter) && !obj.name.ContainsIgnoreCase(nameFilter))
                    continue;

                GameObject go = null;
                var type = obj.GetActualType();

                if (type == typeof(GameObject))
                    go = obj.TryCast<GameObject>();
                else if (typeof(Component).IsAssignableFrom(type))
                    go = obj.TryCast<Component>()?.gameObject;

                if (go)
                {
                    // hide unityexplorer objects
                    if (go.transform.root.name == "UniverseLibCanvas")
                        continue;

                    if (shouldFilterGOs)
                    {
                        // scene check
                        if (sceneFilter != SceneFilter.Any)
                        {
                            if (!Filter(go.scene, sceneFilter))
                                continue;
                        }

                        if (childFilter != ChildFilter.Any)
                        {
                            if (!go)
                                continue;

                            // root object check (no parent)
                            if (childFilter == ChildFilter.HasParent && !go.transform.parent)
                                continue;
                            else if (childFilter == ChildFilter.RootObject && go.transform.parent)
                                continue;
                        }
                    }
                }

                results.Add(obj);
            }

            return results;
        }

        internal static List<object> ClassSearch(string input)
        {
            var list = new List<object>();

            var nameFilter = "";
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                foreach (var type in asm.TryGetTypes())
                {
                    if (!string.IsNullOrEmpty(nameFilter) && !type.FullName.ContainsIgnoreCase(nameFilter))
                        continue;
                    list.Add(type);
                }
            }

            return list;
        }

        internal static string[] instanceNames = new string[]
        {
            "m_instance",
            "m_Instance",
            "s_instance",
            "s_Instance",
            "_instance",
            "_Instance",
            "instance",
            "Instance",
            "<Instance>k__BackingField",
            "<instance>k__BackingField",
        };

        internal static List<object> InstanceSearch(string input)
        {
            var instances = new List<object>();

            var nameFilter = "";
            if (!string.IsNullOrEmpty(input))
                nameFilter = input;

            var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static;
            
            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Search all non-static, non-enum classes.
                foreach (var type in asm.TryGetTypes().Where(it => !(it.IsSealed && it.IsAbstract) && !it.IsEnum))
                {
                    try
                    {
                        if (!string.IsNullOrEmpty(nameFilter) && !type.FullName.ContainsIgnoreCase(nameFilter))
                            continue;
            
                        ReflectionUtility.FindSingleton(instanceNames, type, flags, instances);
                    }
                    catch { }
                }
            }
            
            return instances;
        }

    }
}

```

`src/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;
using UnityExplorer;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle(ExplorerCore.NAME)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(ExplorerCore.AUTHOR)]
[assembly: AssemblyProduct(ExplorerCore.NAME)]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b21dbde3-5d6f-4726-93ab-cc3cc68bae7d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion(ExplorerCore.VERSION)]
[assembly: AssemblyFileVersion(ExplorerCore.VERSION)]

```

`src/Runtime/Il2CppHelper.cs`:

```cs
#if CPP
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace UnityExplorer.Runtime
{
    public class Il2CppHelper : UERuntimeHelper
    {
        public override void SetupEvents()
        {
            try
            {
                Application.add_logMessageReceived(new Action<string, string, LogType>(Application_logMessageReceived));
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning("Exception setting up Unity log listener, make sure Unity libraries have been unstripped!");
                ExplorerCore.Log(ex);
            }
        }

        private void Application_logMessageReceived(string condition, string stackTrace, LogType type)
        {
            ExplorerCore.LogUnity(condition, type);
        }

        public override string[] DefaultReflectionBlacklist => defaultIl2CppBlacklist.ToArray();

        // These methods currently cause a crash in most il2cpp games,
        // even from doing "GetParameters()" on the MemberInfo.
        // Blacklisting until the issue is fixed in Unhollower.
        public static HashSet<string> defaultIl2CppBlacklist = new()
        {
            // These were deprecated a long time ago, still show up in some IL2CPP games for some reason
            "UnityEngine.MonoBehaviour.allowPrefabModeInPlayMode",
            "UnityEngine.MonoBehaviour.runInEditMode",
            "UnityEngine.Component.animation",
            "UnityEngine.Component.audio",
            "UnityEngine.Component.camera",
            "UnityEngine.Component.collider",
            "UnityEngine.Component.collider2D",
            "UnityEngine.Component.constantForce",
            "UnityEngine.Component.hingeJoint",
            "UnityEngine.Component.light",
            "UnityEngine.Component.networkView",
            "UnityEngine.Component.particleSystem",
            "UnityEngine.Component.renderer",
            "UnityEngine.Component.rigidbody",
            "UnityEngine.Component.rigidbody2D",
            "UnityEngine.Light.flare",
            // These can cause a crash in IL2CPP
            "Il2CppSystem.Type.DeclaringMethod",
            "Il2CppSystem.RuntimeType.DeclaringMethod",
            "Unity.Jobs.LowLevel.Unsafe.JobsUtility.CreateJobReflectionData",
            "Unity.Profiling.ProfilerRecorder.CopyTo",
            "Unity.Profiling.ProfilerRecorder.StartNew",
            "UnityEngine.Analytics.Analytics.RegisterEvent",
            "UnityEngine.Analytics.Analytics.SendEvent",
            "UnityEngine.Analytics.ContinuousEvent+ConfigureEventDelegate.Invoke",
            "UnityEngine.Analytics.ContinuousEvent.ConfigureEvent",
            "UnityEngine.Animations.AnimationLayerMixerPlayable.Create",
            "UnityEngine.Animations.AnimationLayerMixerPlayable.CreateHandle",
            "UnityEngine.Animations.AnimationMixerPlayable.Create",
            "UnityEngine.Animations.AnimationMixerPlayable.CreateHandle",
            "UnityEngine.AssetBundle.RecompressAssetBundleAsync",
            "UnityEngine.Audio.AudioMixerPlayable.Create",
            "UnityEngine.BoxcastCommand.ScheduleBatch",
            "UnityEngine.Camera.CalculateProjectionMatrixFromPhysicalProperties",
            "UnityEngine.Canvas.renderingDisplaySize",
            "UnityEngine.CapsulecastCommand.ScheduleBatch",
            "UnityEngine.Collider2D.Cast",
            "UnityEngine.Collider2D.Raycast",
            "UnityEngine.ComputeBuffer+BeginBufferWriteDelegate.Invoke",
            "UnityEngine.ComputeBuffer+EndBufferWriteDelegate.Invoke",
            "UnityEngine.ComputeBuffer.BeginBufferWrite",
            "UnityEngine.ComputeBuffer.EndBufferWrite",
            "UnityEngine.Cubemap+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Cubemap+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Cubemap.SetPixelDataImpl",
            "UnityEngine.Cubemap.SetPixelDataImplArray",
            "UnityEngine.CubemapArray+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.CubemapArray+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.CubemapArray.SetPixelDataImpl",
            "UnityEngine.CubemapArray.SetPixelDataImplArray",
            "UnityEngine.Experimental.Playables.MaterialEffectPlayable.Create",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure+AddInstanceDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure+AddInstance_Procedural_InjectedDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance_Procedural",
            "UnityEngine.Experimental.Rendering.RayTracingAccelerationStructure.AddInstance_Procedural_Injected",
            "UnityEngine.Experimental.Rendering.RayTracingShader+DispatchDelegate.Invoke",
            "UnityEngine.Experimental.Rendering.RayTracingShader.Dispatch",
            "UnityEngine.Experimental.Rendering.RenderPassAttachment.Clear",
            "UnityEngine.GUI.DoButtonGrid",
            "UnityEngine.GUI.Slider",
            "UnityEngine.GUI.Toolbar",
            "UnityEngine.Graphics.DrawMeshInstancedIndirect",
            "UnityEngine.Graphics.DrawMeshInstancedProcedural",
            "UnityEngine.Graphics.DrawProcedural",
            "UnityEngine.Graphics.DrawProceduralIndirect",
            "UnityEngine.Graphics.DrawProceduralIndirectNow",
            "UnityEngine.Graphics.DrawProceduralNow",
            "UnityEngine.LineRenderer+BakeMeshDelegate.Invoke",
            "UnityEngine.LineRenderer.BakeMesh",
            "UnityEngine.Mesh.GetIndices",
            "UnityEngine.Mesh.GetTriangles",
            "UnityEngine.Mesh.SetIndices",
            "UnityEngine.Mesh.SetTriangles",
            "UnityEngine.Physics2D.BoxCast",
            "UnityEngine.Physics2D.CapsuleCast",
            "UnityEngine.Physics2D.CircleCast",
            "UnityEngine.PhysicsScene.BoxCast",
            "UnityEngine.PhysicsScene.CapsuleCast",
            "UnityEngine.PhysicsScene.OverlapBox",
            "UnityEngine.PhysicsScene.OverlapCapsule",
            "UnityEngine.PhysicsScene.SphereCast",
            "UnityEngine.PhysicsScene2D.BoxCast",
            "UnityEngine.PhysicsScene2D.CapsuleCast",
            "UnityEngine.PhysicsScene2D.CircleCast",
            "UnityEngine.PhysicsScene2D.GetRayIntersection",
            "UnityEngine.PhysicsScene2D.Linecast",
            "UnityEngine.PhysicsScene2D.OverlapArea",
            "UnityEngine.PhysicsScene2D.OverlapBox",
            "UnityEngine.PhysicsScene2D.OverlapCapsule",
            "UnityEngine.PhysicsScene2D.OverlapCircle",
            "UnityEngine.PhysicsScene2D.OverlapCollider",
            "UnityEngine.PhysicsScene2D.OverlapPoint",
            "UnityEngine.PhysicsScene2D.Raycast",
            "UnityEngine.Playables.Playable.Create",
            "UnityEngine.Profiling.CustomSampler.Create",
            "UnityEngine.RaycastCommand.ScheduleBatch",
            "UnityEngine.RemoteConfigSettings+QueueConfigDelegate.Invoke",
            "UnityEngine.RemoteConfigSettings.QueueConfig",
            "UnityEngine.RenderTexture.GetTemporaryImpl",
            "UnityEngine.Rendering.AsyncGPUReadback.Request",
            "UnityEngine.Rendering.AttachmentDescriptor.ConfigureClear",
            "UnityEngine.Rendering.BatchRendererGroup+AddBatch_InjectedDelegate.Invoke",
            "UnityEngine.Rendering.BatchRendererGroup.AddBatch",
            "UnityEngine.Rendering.BatchRendererGroup.AddBatch_Injected",
            "UnityEngine.Rendering.CommandBuffer+Internal_DispatchRaysDelegate.Invoke",
            "UnityEngine.Rendering.CommandBuffer.DispatchRays",
            "UnityEngine.Rendering.CommandBuffer.DrawMeshInstancedProcedural",
            "UnityEngine.Rendering.CommandBuffer.Internal_DispatchRays",
            "UnityEngine.Rendering.CommandBuffer.ResolveAntiAliasedSurface",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginRenderPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginScopedRenderPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginScopedSubPass",
            "UnityEngine.Rendering.ScriptableRenderContext.BeginSubPass",
            "UnityEngine.Rendering.ScriptableRenderContext.SetupCameraProperties",
            "UnityEngine.Rigidbody2D.Cast",
            "UnityEngine.Scripting.GarbageCollector+CollectIncrementalDelegate.Invoke",
            "UnityEngine.Scripting.GarbageCollector.CollectIncremental",
            "UnityEngine.SpherecastCommand.ScheduleBatch",
            "UnityEngine.Texture.GetPixelDataSize",
            "UnityEngine.Texture.GetPixelDataOffset",
            "UnityEngine.Texture.GetPixelDataOffset",
            "UnityEngine.Texture2D+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture2D+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture2D.SetPixelDataImpl",
            "UnityEngine.Texture2D.SetPixelDataImplArray",
            "UnityEngine.Texture2DArray+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture2DArray+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture2DArray.SetPixelDataImpl",
            "UnityEngine.Texture2DArray.SetPixelDataImplArray",
            "UnityEngine.Texture3D+SetPixelDataImplArrayDelegate.Invoke",
            "UnityEngine.Texture3D+SetPixelDataImplDelegate.Invoke",
            "UnityEngine.Texture3D.SetPixelDataImpl",
            "UnityEngine.Texture3D.SetPixelDataImplArray",
            "UnityEngine.TrailRenderer+BakeMeshDelegate.Invoke",
            "UnityEngine.TrailRenderer.BakeMesh",
            "UnityEngine.WWW.LoadFromCacheOrDownload",
            "UnityEngine.XR.InputDevice.SendHapticImpulse",
        };
    }
}

#endif
```

`src/Runtime/MonoHelper.cs`:

```cs
#if MONO
using UnityEngine;

namespace UnityExplorer.Runtime
{
    public class MonoHelper : UERuntimeHelper
    {
        public override void SetupEvents()
        {
            Application.logMessageReceived += Application_logMessageReceived;
        }

        private void Application_logMessageReceived(string condition, string stackTrace, LogType type)
             => ExplorerCore.LogUnity(condition, type);
    }
}

#endif
```

`src/Runtime/UERuntimeHelper.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityExplorer.Config;
using UniverseLib;

namespace UnityExplorer.Runtime
{
    // Not really that necessary anymore, can eventually just be refactored away into the few classes that use this class.

    public abstract class UERuntimeHelper
    {
        public static UERuntimeHelper Instance;

        public static void Init()
        { 
#if CPP
            Instance = new Il2CppHelper();
#else
            Instance = new MonoHelper();
#endif
            Instance.SetupEvents();

            LoadBlacklistString(ConfigManager.Reflection_Signature_Blacklist.Value);
            ConfigManager.Reflection_Signature_Blacklist.OnValueChanged += (string val) =>
            {
                LoadBlacklistString(val);
            };
        }

        public abstract void SetupEvents();

        private static readonly HashSet<string> currentBlacklist = new();

        public virtual string[] DefaultReflectionBlacklist => new string[0];

        public static void LoadBlacklistString(string blacklist)
        {
            try
            {
                if (string.IsNullOrEmpty(blacklist) && !Instance.DefaultReflectionBlacklist.Any())
                    return;

                try
                {
                    var sigs = blacklist.Split(';');
                    foreach (var sig in sigs)
                    {
                        var s = sig.Trim();
                        if (string.IsNullOrEmpty(s))
                            continue;
                        if (!currentBlacklist.Contains(s))
                            currentBlacklist.Add(s);
                    }
                }
                catch (Exception ex)
                {
                    ExplorerCore.LogWarning($"Exception parsing blacklist string: {ex.ReflectionExToString()}");
                }

                foreach (var sig in Instance.DefaultReflectionBlacklist)
                {
                    if (!currentBlacklist.Contains(sig))
                        currentBlacklist.Add(sig);
                }

                Mono.CSharp.IL2CPP.Blacklist.SignatureBlacklist = currentBlacklist;
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception setting up reflection blacklist: {ex.ReflectionExToString()}");
            }
        }

        public static bool IsBlacklisted(MemberInfo member)
        {
            if (string.IsNullOrEmpty(member.DeclaringType?.Namespace))
                return false;

            var sig = $"{member.DeclaringType.FullName}.{member.Name}";

            return currentBlacklist.Contains(sig);
        }
    }
}

```

`src/Runtime/UnityCrashPrevention.cs`:

```cs
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.CacheObject;

namespace UnityExplorer.Runtime
{
    internal static class UnityCrashPrevention
    {
        internal static void Init()
        {
            try
            {
                ExplorerCore.Harmony.PatchAll(typeof(UnityCrashPrevention));
                ExplorerCore.Log("Initialized UnityCrashPrevention.");
            }
            catch //(Exception ex)
            {
                //ExplorerCore.Log($"Exception setting up Canvas crash prevention patch: {ex}");
            }
        }

        // In Unity 2020 they introduced "Canvas.renderingDisplaySize".
        // If you try to get the value on a Canvas which has a renderMode value of WorldSpace and no worldCamera set,
        // the game will Crash (I think from Unity trying to read from null ptr).
        [HarmonyPatch(typeof(Canvas), "renderingDisplaySize", MethodType.Getter)]
        [HarmonyPrefix]
        internal static void Prefix_Canvas_renderingDisplaySize(Canvas __instance)
        {
            if (__instance.renderMode == RenderMode.WorldSpace && !__instance.worldCamera)
                throw new InvalidOperationException(
                    "Canvas is set to RenderMode.WorldSpace but not worldCamera is set, cannot get renderingDisplaySize.");
        }
    }
}

```

`src/Tests/TestClass.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityExplorer.UI;
using UnityExplorer.CacheObject.IValues;
#if CPP
using UnhollowerRuntimeLib;
using UnhollowerBaseLib;
#endif

namespace UnityExplorer.Tests
{
    public class TestClass
    {
        static TestClass()
        {
            Init_Mono();
#if CPP
            Init_IL2CPP();
#endif
        }

        #region MONO

        public static object LiterallyAnything = null;

        // Test enumerables
        public static int[,,] MultiDimensionalArray = new int[45, 45, 45];
        public static List<object> ListOfInts;
        public static List<List<List<string>>> NestedList;
        public static IDictionary MixedDictionary;
        public static Hashtable Hashtable;
        public static byte[] ByteArray = new byte[16];
        public static List<short> ABigList = new(10000);

        // Test const behaviour (should be a readonly field)
        public const int ConstantInt5 = 5;

        // Testing other InteractiveValues
        public static BindingFlags EnumTest;
        public static CameraClearFlags EnumTest2;
        public static Color Color = Color.magenta;
        public static Color32 Color32 = Color.red;
        public static string ALongString = new('#', 10000);

        public static float[] AParseTest(ref List<float[,,]> arg0, ref float[,] arg1)
        {
            return new float[] { 1, 2, 3 };
        }

        public static List<object> RandomList
        {
            get
            {
                var list = new List<object>();
                int count = UnityEngine.Random.Range(0, 100);
                for (int i = 0; i < count; i++)
                    list.Add(GetRandomObject());
                return list;
            }
        }

        public int this[int index]
        {
            get => UnityEngine.Random.Range(0, int.MaxValue);
            set => ExplorerCore.Log(index);
        }

        // Test methods

        private static object GetRandomObject()
        {
            return UnityEngine.Random.Range(0, 7) switch
            {
                0 => null,
                1 => 123,
                2 => true,
                3 => "hello",
                4 => 50.5f,
                5 => CameraClearFlags.Color,
                6 => new List<string> { "one", "two" },
                _ => null,
            };
        }

        public static void TestComponent<T>() where T : Component
        {
            ExplorerCore.Log($"Test3 {typeof(T).FullName}");
        }

        public static void TestArgumentParse(string _string,
                                             int integer,
                                             Color color,
                                             CameraClearFlags flags,
                                             Vector3 vector,
                                             Quaternion quaternion,
                                             object obj,
                                             Type type,
                                             GameObject go)
        {
            ExplorerCore.Log($"_string: {_string}, integer: {integer}, color: {color.ToString()}, flags: {flags}, " +
                $"vector: {vector.ToString()}, quaternion: {quaternion.ToString()}, obj: {obj?.ToString() ?? "null"}," +
                $"type: {type?.FullName ?? "null"}, go: {go?.ToString() ?? "null"}");
        }

        private static void Init_Mono()
        {
            ExplorerCore.Log($"1: Basic list");
            ListOfInts = new List<object> { 1, 2, 3, 4, 5 };

            ExplorerCore.Log($"2: Nested list");
            NestedList = new List<List<List<string>>>
            {
                new List<List<string>> {
                    new List<string> { "1", "2", "3" },
                    new List<string> { "4", "5", "6" },
                },
                new List<List<string>>
                {
                    new List<string> { "7", "8", "9" }
                }
            };

            ExplorerCore.Log($"3: Dictionary");
            MixedDictionary = new Dictionary<object, object>
            {
                { 1, 2 },
                { "one", "two" },
                { true, false },
                { new Vector3(0,1,2), new Vector3(1,2,3) },
                { CameraClearFlags.Depth, CameraClearFlags.Color },
                { "################################################\r\n##########", null },
                { "subdict", new Dictionary<object,object> { { "key", "value" } } }
            };

            ExplorerCore.Log($"4: Hashtable");
            Hashtable = new Hashtable { { "One", 1 }, { "Two", 2 } };

            ExplorerCore.Log($"5: Big list");
            for (int i = 0; i < ABigList.Capacity; i++)
                ABigList.Add((short)UnityEngine.Random.Range(0, short.MaxValue));

            ExplorerCore.Log("Finished TestClass Init_Mono");
        }

        #endregion

#if CPP
        public static Il2CppSystem.Collections.Generic.Dictionary<string, string> IL2CPP_Dict;
        public static Il2CppSystem.Collections.Generic.HashSet<string> IL2CPP_HashSet;
        public static Il2CppSystem.Collections.Generic.List<string> IL2CPP_ListString;
        public static Il2CppSystem.Collections.Hashtable IL2CPP_HashTable;
        public static List<Il2CppSystem.Object> IL2CPP_listOfBoxedObjects;
        public static Il2CppStructArray<int> IL2CPP_structArray;
        public static Il2CppReferenceArray<Il2CppSystem.Object> IL2CPP_ReferenceArray;
        public static Il2CppSystem.Collections.IDictionary IL2CPP_IDict;
        public static Il2CppSystem.Collections.IList IL2CPP_IList;
        public static Dictionary<Il2CppSystem.Object, Il2CppSystem.Object> IL2CPP_BoxedDict;

        public static Il2CppSystem.Object IL2CPP_BoxedInt;
        public static Il2CppSystem.Int32 IL2CPP_Int;
        public static Il2CppSystem.Decimal IL2CPP_Decimal;
        public static Il2CppSystem.Object IL2CPP_DecimalBoxed;
        public static Il2CppSystem.Object IL2CPP_Vector3Boxed;
        public static string IL2CPP_systemString = "Test";
        public static Il2CppSystem.Object IL2CPP_objectString = "string boxed as cpp object";
        public static Il2CppSystem.String IL2CPP_il2cppString = "string boxed as cpp string";
        public static string nullString = null;

        private static void Init_IL2CPP()
        {
            ExplorerCore.Log($"IL2CPP 1: Il2Cpp Dictionary<string, string>");
            IL2CPP_Dict = new Il2CppSystem.Collections.Generic.Dictionary<string, string>();
            IL2CPP_Dict.Add("key1", "value1");
            IL2CPP_Dict.Add("key2", "value2");
            IL2CPP_Dict.Add("key3", "value3");

            ExplorerCore.Log($"IL2CPP 6: Il2Cpp HashSet of strings");
            IL2CPP_HashSet = new Il2CppSystem.Collections.Generic.HashSet<string>();
            IL2CPP_HashSet.Add("one");
            IL2CPP_HashSet.Add("two");

            ExplorerCore.Log($"IL2CPP 2: Il2Cpp Hashtable");
            IL2CPP_HashTable = new Il2CppSystem.Collections.Hashtable();
            IL2CPP_HashTable.Add("key1", "value1");
            IL2CPP_HashTable.Add("key2", "value2");
            IL2CPP_HashTable.Add("key3", "value3");

            ExplorerCore.Log($"IL2CPP 3: Il2Cpp IDictionary");
            var dict2 = new Il2CppSystem.Collections.Generic.Dictionary<string, string>();
            dict2.Add("key1", "value1");
            IL2CPP_IDict = dict2.TryCast<Il2CppSystem.Collections.IDictionary>();

            ExplorerCore.Log($"IL2CPP 4: Il2Cpp List of Il2Cpp Object");
            var list = new Il2CppSystem.Collections.Generic.List<Il2CppSystem.Object>(5);
            list.Add("one");
            list.Add("two");
            IL2CPP_IList = list.TryCast<Il2CppSystem.Collections.IList>();

            ExplorerCore.Log($"IL2CPP 5: Il2Cpp List of strings");
            IL2CPP_ListString = new Il2CppSystem.Collections.Generic.List<string>();
            IL2CPP_ListString.Add("hello,");
            IL2CPP_ListString.Add("world!");


            ExplorerCore.Log($"IL2CPP 7: Dictionary of Il2Cpp String and Il2Cpp Object");
            IL2CPP_BoxedDict = new();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"one"] = new Il2CppSystem.Int32 { m_value = 1 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"two"] = new Il2CppSystem.Int32 { m_value = 2 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"three"] = new Il2CppSystem.Int32 { m_value = 3 }.BoxIl2CppObject();
            IL2CPP_BoxedDict[(Il2CppSystem.String)"four"] = new Il2CppSystem.Int32 { m_value = 4 }.BoxIl2CppObject();

            ExplorerCore.Log($"IL2CPP 8: List of boxed Il2Cpp Objects");
            IL2CPP_listOfBoxedObjects = new List<Il2CppSystem.Object>();
            IL2CPP_listOfBoxedObjects.Add((Il2CppSystem.String)"boxedString");
            IL2CPP_listOfBoxedObjects.Add(new Il2CppSystem.Int32 { m_value = 5 }.BoxIl2CppObject());
            IL2CPP_listOfBoxedObjects.Add(Color.red.BoxIl2CppObject());
            // boxed enum test
            try
            {
                var cppType = Il2CppType.Of<CameraClearFlags>();
                if (cppType != null)
                {
                    var boxedEnum = Il2CppSystem.Enum.Parse(cppType, "Color");
                    IL2CPP_listOfBoxedObjects.Add(boxedEnum);
                }

                var structBox = Vector3.one.BoxIl2CppObject();
                IL2CPP_listOfBoxedObjects.Add(structBox);

            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Boxed enum test fail: {ex}");
            }

            ExplorerCore.Log($"IL2CPP 9: Il2Cpp struct array of ints");
            IL2CPP_structArray = new UnhollowerBaseLib.Il2CppStructArray<int>(5);
            IL2CPP_structArray[0] = 0;
            IL2CPP_structArray[1] = 1;
            IL2CPP_structArray[2] = 2;
            IL2CPP_structArray[3] = 3;
            IL2CPP_structArray[4] = 4;

            ExplorerCore.Log($"IL2CPP 10: Il2Cpp reference array of boxed objects");
            IL2CPP_ReferenceArray = new UnhollowerBaseLib.Il2CppReferenceArray<Il2CppSystem.Object>(3);
            IL2CPP_ReferenceArray[0] = new Il2CppSystem.Int32 { m_value = 5 }.BoxIl2CppObject();
            IL2CPP_ReferenceArray[1] = null;
            IL2CPP_ReferenceArray[2] = (Il2CppSystem.String)"whats up";

            ExplorerCore.Log($"IL2CPP 11: Misc il2cpp members");
            IL2CPP_BoxedInt = new Il2CppSystem.Int32() { m_value = 5 }.BoxIl2CppObject();
            IL2CPP_Int = new Il2CppSystem.Int32 { m_value = 420 };
            IL2CPP_Decimal = new Il2CppSystem.Decimal(1f);
            IL2CPP_DecimalBoxed = new Il2CppSystem.Decimal(1f).BoxIl2CppObject();
            IL2CPP_Vector3Boxed = Vector3.down.BoxIl2CppObject();

            ExplorerCore.Log($"Finished Init_Il2Cpp");
        }

#endif
    }
}

```

`src/UI/DisplayManager.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.Config;
using UniverseLib;
using UniverseLib.Input;

namespace UnityExplorer.UI
{
    public static class DisplayManager
    {
        public static int ActiveDisplayIndex { get; private set; }
        public static Display ActiveDisplay => Display.displays[ActiveDisplayIndex];

        public static int Width => ActiveDisplay.renderingWidth;
        public static int Height => ActiveDisplay.renderingHeight;

        public static Vector3 MousePosition => Application.isEditor
            ? InputManager.MousePosition
            : Display.RelativeMouseAt(InputManager.MousePosition);

        public static bool MouseInTargetDisplay => MousePosition.z == ActiveDisplayIndex;

        private static Camera canvasCamera;

        internal static void Init()
        {
            SetDisplay(ConfigManager.Target_Display.Value);
            ConfigManager.Target_Display.OnValueChanged += SetDisplay;
        }

        public static void SetDisplay(int display)
        {
            if (ActiveDisplayIndex == display)
                return;

            if (Display.displays.Length <= display)
            {
                ExplorerCore.LogWarning($"Cannot set display index to {display} as there are not enough monitors connected!");

                if (ConfigManager.Target_Display.Value == display)
                    ConfigManager.Target_Display.Value = 0;

                return;
            } 

            ActiveDisplayIndex = display;
            ActiveDisplay.Activate();

            UIManager.UICanvas.targetDisplay = display;

            // ensure a camera is targeting the display
            if (!Camera.main || Camera.main.targetDisplay != display)
            {
                if (!canvasCamera)
                {
                    canvasCamera = new GameObject("UnityExplorer_CanvasCamera").AddComponent<Camera>();
                    GameObject.DontDestroyOnLoad(canvasCamera.gameObject);
                    canvasCamera.hideFlags = HideFlags.HideAndDontSave;
                }
                canvasCamera.targetDisplay = display;
            }

            RuntimeHelper.StartCoroutine(FixPanels());
        }

        private static IEnumerator FixPanels()
        {
            yield return null;
            yield return null;

            foreach (var panel in UIManager.UIPanels.Values)
            {
                panel.EnsureValidSize();
                panel.EnsureValidPosition();
                panel.Dragger.OnEndResize();
            }
        }
    }
}

```

`src/UI/Notification.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.Input;
using UniverseLib.UI;

namespace UnityExplorer.UI
{
    public static class Notification
    {
        private static Text popupLabel;

        private static string _currentNotification;
        private static float _timeOfLastNotification;

        public static void Init()
        {
            ConstructUI();
        }

        public static void ShowMessage(string message)
        {
            popupLabel.text = message;
            _currentNotification = message;
            _timeOfLastNotification = Time.realtimeSinceStartup;

            popupLabel.transform.localPosition = UIManager.UIRootRect.InverseTransformPoint(DisplayManager.MousePosition) + (Vector3.up * 25);
        }

        public static void Update()
        {
            if (_currentNotification != null)
            {
                if (Time.realtimeSinceStartup - _timeOfLastNotification > 2f)
                {
                    _currentNotification = null;
                    popupLabel.text = "";
                }
            }
        }

        private static void ConstructUI()
        {

            popupLabel = UIFactory.CreateLabel(UIManager.UIRoot, "ClipboardNotification", "", TextAnchor.MiddleCenter);
            popupLabel.rectTransform.sizeDelta = new(500, 100);
            popupLabel.gameObject.AddComponent<Outline>();
            var popupGroup = popupLabel.gameObject.AddComponent<CanvasGroup>();
            popupGroup.blocksRaycasts = false;
        }
    }
}

```

`src/UI/Panels/AutoCompleteModal.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UniverseLib.Input;
using UnityExplorer.Runtime;
using UnityExplorer.UI;
using UnityExplorer.UI.Panels;
using UniverseLib.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    // Shared modal panel for "AutoComplete" suggestions.
    // A data source implements ISuggestionProvider and uses TakeOwnership and ReleaseOwnership
    // for control, and SetSuggestions to set the actual suggestion data.

    public class AutoCompleteModal : UIPanel
    {
        public static AutoCompleteModal Instance => UIManager.GetPanel<AutoCompleteModal>(UIManager.Panels.AutoCompleter);

        public override string Name => "AutoCompleter";
        public override UIManager.Panels PanelType => UIManager.Panels.AutoCompleter;
        public override int MinWidth => -1;
        public override int MinHeight => -1;

        public override bool CanDragAndResize => true;
        public override bool ShouldSaveActiveState => false;
        public override bool NavButtonWanted => false;

        public static ISuggestionProvider CurrentHandler { get; private set; }

        public static ButtonListHandler<Suggestion, ButtonCell> buttonListDataHandler;
        public static ScrollPool<ButtonCell> scrollPool;
        private static GameObject navigationTipRow;

        private static List<Suggestion> Suggestions = new();
        private static int SelectedIndex = 0;

        public static Suggestion SelectedSuggestion => Suggestions[SelectedIndex];

        public static bool Suggesting(ISuggestionProvider handler) => CurrentHandler == handler && Instance.UIRoot.activeSelf;

        public AutoCompleteModal()
        {
            OnPanelsReordered += UIPanel_OnPanelsReordered;
            OnClickedOutsidePanels += AutoCompleter_OnClickedOutsidePanels;
        }

        public void TakeOwnership(ISuggestionProvider provider)
        {
            CurrentHandler = provider;
            navigationTipRow.SetActive(provider.AllowNavigation);
        }

        public void ReleaseOwnership(ISuggestionProvider provider)
        {
            if (CurrentHandler == null)
                return;

            if (CurrentHandler == provider)
            {
                CurrentHandler = null;
                UIRoot.SetActive(false);
            }
        }

        public void SetSuggestions(IEnumerable<Suggestion> suggestions)
        {
            Suggestions = suggestions as List<Suggestion> ?? suggestions.ToList();
            SelectedIndex = 0;

            if (!Suggestions.Any())
                base.UIRoot.SetActive(false);
            else
            {
                base.UIRoot.SetActive(true);
                base.UIRoot.transform.SetAsLastSibling();
                buttonListDataHandler.RefreshData();
                scrollPool.Refresh(true, true);
            }
        }

        private static float timeOfLastNavHold = -1f;

        /// <summary>
        /// Returns true if the AutoCompleteModal used the navigation input, false if not.
        /// The navigation inputs are Control+Up/Down, and Control+Enter.
        /// </summary>
        public static bool CheckNavigation(ISuggestionProvider handler)
        {
            if (!Suggesting(handler))
                return false;

            bool up = InputManager.GetKey(KeyCode.UpArrow);
            bool down = InputManager.GetKey(KeyCode.DownArrow);

            if (up || down)
            {
                if (up)
                {
                    if (InputManager.GetKeyDown(KeyCode.UpArrow))
                    {
                        SetSelectedSuggestion(SelectedIndex - 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup + 0.3f;
                    }
                    else if (timeOfLastNavHold.OccuredEarlierThan(0.05f))
                    {
                        SetSelectedSuggestion(SelectedIndex - 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup;
                    }
                }
                else
                {
                    if (InputManager.GetKeyDown(KeyCode.DownArrow))
                    {
                        SetSelectedSuggestion(SelectedIndex + 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup + 0.3f;
                    }
                    else if (timeOfLastNavHold.OccuredEarlierThan(0.05f))
                    {
                        SetSelectedSuggestion(SelectedIndex + 1);
                        timeOfLastNavHold = Time.realtimeSinceStartup;
                    }
                }

                return true;
            }

            return !timeOfLastNavHold.OccuredEarlierThan(0.2f);
        }

        public static bool CheckEnter(ISuggestionProvider handler)
        {
            return Suggesting(handler) && InputManager.GetKeyDown(KeyCode.Return);
        }

        public static bool CheckEscape(ISuggestionProvider handler)
        {
            return Suggesting(handler) && InputManager.GetKeyDown(KeyCode.Escape);
        }

        private static void SetSelectedSuggestion(int index)
        {
            if (index < 0 || index >= Suggestions.Count)
                return;

            SelectedIndex = index;
            scrollPool.Refresh(true, false);
        }

        // Internal update

        public override void Update()
        {
            if (!UIRoot || !UIRoot.activeSelf)
                return;

            if (Suggestions.Any() && CurrentHandler != null)
            {
                if (!CurrentHandler.InputField.UIRoot.activeInHierarchy)
                    ReleaseOwnership(CurrentHandler);
                else
                    UpdatePosition();
            }
        }

        // Setting autocomplete cell buttons

        private readonly Color selectedSuggestionColor = new Color(45 / 255f, 75 / 255f, 80 / 255f);
        private readonly Color inactiveSuggestionColor = new Color(0.11f, 0.11f, 0.11f);

        private List<Suggestion> GetEntries() => Suggestions;

        private bool ShouldDisplay(Suggestion data, string filter) => true;

        private void OnCellClicked(int dataIndex)
        {
            var suggestion = Suggestions[dataIndex];
            CurrentHandler.OnSuggestionClicked(suggestion);
        }

        private bool setFirstCell;

        private void SetCell(ButtonCell cell, int index)
        {
            if (index < 0 || index >= Suggestions.Count)
            {
                cell.Disable();
                return;
            }

            var suggestion = Suggestions[index];
            cell.Button.ButtonText.text = suggestion.DisplayText;

            if (CurrentHandler.AllowNavigation && index == SelectedIndex && setFirstCell)
            {
                float diff = 0f;
                // if cell is too far down
                if (cell.Rect.MinY() > scrollPool.Viewport.MinY())
                    diff = cell.Rect.MinY() - scrollPool.Viewport.MinY();
                // if cell is too far up
                else if (cell.Rect.MaxY() < scrollPool.Viewport.MaxY())
                    diff = cell.Rect.MaxY() - scrollPool.Viewport.MaxY();

                if (diff != 0.0f)
                {
                    var pos = scrollPool.Content.anchoredPosition;
                    pos.y -= diff;
                    scrollPool.Content.anchoredPosition = pos;
                }

                RuntimeHelper.SetColorBlock(cell.Button.Component, selectedSuggestionColor);
            }
            else
                RuntimeHelper.SetColorBlock(cell.Button.Component, inactiveSuggestionColor);

            setFirstCell = true;
        }

        // Updating panel position

        private int lastCaretPosition;
        private Vector3 lastInputPosition;

        internal void UpdatePosition()
        {
            if (CurrentHandler == null)
                return;

            var input = CurrentHandler.InputField;

            if (input.Component.caretPosition == lastCaretPosition && input.UIRoot.transform.position == lastInputPosition)
                return;
            lastInputPosition = input.UIRoot.transform.position;
            lastCaretPosition = input.Component.caretPosition;

            if (CurrentHandler.AnchorToCaretPosition)
            {
                var textGen = input.Component.cachedInputTextGenerator;
                int caretIdx = Math.Max(0, Math.Min(textGen.characterCount - 1, input.Component.caretPosition));

                // normalize the caret horizontal position
                Vector3 caretPos = textGen.characters[caretIdx].cursorPos;
                // transform to world point
                caretPos = input.UIRoot.transform.TransformPoint(caretPos);
                caretPos += new Vector3(input.Transform.rect.width * 0.5f, -(input.Transform.rect.height * 0.5f), 0);

                uiRoot.transform.position = new Vector3(caretPos.x + 10, caretPos.y - 30, 0);
            }
            else
            {
                uiRoot.transform.position = input.Transform.position + new Vector3(-(input.Transform.rect.width / 2) + 10, -20, 0);
                //var textGen = input.Component.textComponent.cachedTextGenerator;
                //var pos = input.UIRoot.transform.TransformPoint(textGen.characters[0].cursorPos);
                //uiRoot.transform.position = new Vector3(pos.x + 10, pos.y - 20, 0);
            }

            this.Dragger.OnEndResize();
        }

        // Event listeners for panel

        private void AutoCompleter_OnClickedOutsidePanels()
        {
            if (!this.UIRoot || !this.UIRoot.activeInHierarchy)
                return;

            if (CurrentHandler != null)
                ReleaseOwnership(CurrentHandler);
            else
                UIRoot.SetActive(false);
        }

        private void UIPanel_OnPanelsReordered()
        {
            if (!this.UIRoot || !this.UIRoot.activeInHierarchy)
                return;

            if (this.UIRoot.transform.GetSiblingIndex() != UIManager.PanelHolder.transform.childCount - 1)
            {
                if (CurrentHandler != null)
                    ReleaseOwnership(CurrentHandler);
                else
                    UIRoot.SetActive(false);
            }
        }

        // UI Construction

        const float MIN_X = 0.42f;
        const float MAX_Y = 0.6f;

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(MIN_X, 0.4f);
            Rect.anchorMax = new Vector2(0.68f, MAX_Y);
        }

        public override void OnFinishResize(RectTransform panel)
        {
            float xDiff = panel.anchorMin.x - MIN_X;
            float yDiff = panel.anchorMax.y - MAX_Y;

            if (xDiff != 0 || yDiff != 0)
            {
                panel.anchorMin = new(MIN_X, panel.anchorMin.y - yDiff);
                panel.anchorMax = new(panel.anchorMax.x - xDiff, MAX_Y);
            }

            base.OnFinishResize(panel);
        }

        public override void ConstructPanelContent()
        {
            // hide the titlebar
            this.TitleBar.gameObject.SetActive(false);

            buttonListDataHandler = new ButtonListHandler<Suggestion, ButtonCell>(scrollPool, GetEntries, SetCell, ShouldDisplay, OnCellClicked);

            scrollPool = UIFactory.CreateScrollPool<ButtonCell>(this.uiContent, "AutoCompleter", out GameObject scrollObj,
                out GameObject scrollContent);
            scrollPool.Initialize(buttonListDataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(scrollContent, true, false, true, false);

            navigationTipRow = UIFactory.CreateHorizontalGroup(this.uiContent, "BottomRow", true, true, true, true, 0, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(navigationTipRow, minHeight: 20, flexibleWidth: 9999);
            UIFactory.CreateLabel(navigationTipRow, "HelpText", "Up/Down to select, Enter to use, Esc to close",
                TextAnchor.MiddleLeft, Color.grey, false, 13);

            UIRoot.SetActive(false);
        }
    }
}

```

`src/UI/Panels/CSConsolePanel.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.CSConsole;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;

namespace UnityExplorer.UI.Panels
{
    public class CSConsolePanel : UIPanel
    {
        public override string Name => "C# Console";
        public override UIManager.Panels PanelType => UIManager.Panels.CSConsole;
        public override int MinWidth => 750;
        public override int MinHeight => 300;

        public InputFieldScroller InputScroller { get; private set; }
        public InputFieldRef Input => InputScroller.InputField;
        public Text InputText { get; private set; }
        public Text HighlightText { get; private set; }
        public Text LineNumberText { get; private set; }

        public Dropdown HelpDropdown { get; private set; }

        // events
        public Action<string> OnInputChanged;
        public Action OnResetClicked;
        public Action OnCompileClicked;
        public Action<int> OnHelpDropdownChanged;
        public Action<bool> OnCtrlRToggled;
        public Action<bool> OnSuggestionsToggled;
        public Action<bool> OnAutoIndentToggled;
        public Action OnPanelResized;

        private void InvokeOnValueChanged(string value)
        {
            if (value.Length == UniversalUI.MAX_INPUTFIELD_CHARS)
                ExplorerCore.LogWarning($"Reached maximum InputField character length! ({UniversalUI.MAX_INPUTFIELD_CHARS})");

            OnInputChanged?.Invoke(value);
        }

        public override void Update()
        {
            base.Update();

            ConsoleController.Update();
        }

        // UI Construction

        public override void OnFinishResize(RectTransform panel)
        {
            OnPanelResized?.Invoke();
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.localPosition = Vector2.zero;
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(0.4f, 0.175f);
            Rect.anchorMax = new Vector2(0.85f, 0.925f);
        }

        public override void ConstructPanelContent()
        {
            // Tools Row

            var toolsRow = UIFactory.CreateHorizontalGroup(this.uiContent, "ToggleRow", false, false, true, true, 5, new Vector4(8, 8, 10, 5),
                default, TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(toolsRow, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            // Buttons

            var compileButton = UIFactory.CreateButton(toolsRow, "CompileButton", "Compile", new Color(0.33f, 0.5f, 0.33f));
            UIFactory.SetLayoutElement(compileButton.Component.gameObject, minHeight: 28, minWidth: 130, flexibleHeight: 0);
            compileButton.ButtonText.fontSize = 15;
            compileButton.OnClick += () => { OnCompileClicked?.Invoke(); };

            var resetButton = UIFactory.CreateButton(toolsRow, "ResetButton", "Reset", new Color(0.33f, 0.33f, 0.33f));
            UIFactory.SetLayoutElement(resetButton.Component.gameObject, minHeight: 28, minWidth: 80, flexibleHeight: 0);
            resetButton.ButtonText.fontSize = 15;
            resetButton.OnClick += () => { OnResetClicked?.Invoke(); };

            // Help dropdown

            var helpDrop = UIFactory.CreateDropdown(toolsRow, "HelpDropdown", out var dropdown, "Help", 14, null);
            UIFactory.SetLayoutElement(helpDrop, minHeight: 25, minWidth: 100);
            HelpDropdown = dropdown;
            HelpDropdown.onValueChanged.AddListener((int val) => { this.OnHelpDropdownChanged?.Invoke(val); });

            // Enable Ctrl+R toggle

            var ctrlRToggleObj = UIFactory.CreateToggle(toolsRow, "CtrlRToggle", out var CtrlRToggle, out Text ctrlRToggleText);
            UIFactory.SetLayoutElement(ctrlRToggleObj, minWidth: 150, flexibleWidth: 0, minHeight: 25);
            ctrlRToggleText.alignment = TextAnchor.UpperLeft;
            ctrlRToggleText.text = "Compile on Ctrl+R";
            CtrlRToggle.onValueChanged.AddListener((bool val) => { OnCtrlRToggled?.Invoke(val); });

            // Enable Suggestions toggle

            var suggestToggleObj = UIFactory.CreateToggle(toolsRow, "SuggestionToggle", out var SuggestionsToggle, out Text suggestToggleText);
            UIFactory.SetLayoutElement(suggestToggleObj, minWidth: 120, flexibleWidth: 0, minHeight: 25);
            suggestToggleText.alignment = TextAnchor.UpperLeft;
            suggestToggleText.text = "Suggestions";
            SuggestionsToggle.onValueChanged.AddListener((bool val) => { OnSuggestionsToggled?.Invoke(val); });

            // Enable Auto-indent toggle

            var autoIndentToggleObj = UIFactory.CreateToggle(toolsRow, "IndentToggle", out var AutoIndentToggle, out Text autoIndentToggleText);
            UIFactory.SetLayoutElement(autoIndentToggleObj, minWidth: 120, flexibleWidth: 0, minHeight: 25);
            autoIndentToggleText.alignment = TextAnchor.UpperLeft;
            autoIndentToggleText.text = "Auto-indent";
            AutoIndentToggle.onValueChanged.AddListener((bool val) => { OnAutoIndentToggled?.Invoke(val); });

            // Console Input

            var inputArea = UIFactory.CreateUIObject("InputGroup", uiContent);
            UIFactory.SetLayoutElement(inputArea, flexibleWidth: 9999, flexibleHeight: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(inputArea, false, true, true, true);
            inputArea.AddComponent<Image>().color = Color.white;
            inputArea.AddComponent<Mask>().showMaskGraphic = false;

            // line numbers

            var linesHolder = UIFactory.CreateUIObject("LinesHolder", inputArea);
            var linesRect = linesHolder.GetComponent<RectTransform>();
            linesRect.pivot = new Vector2(0, 1);
            linesRect.anchorMin = new Vector2(0, 0);
            linesRect.anchorMax = new Vector2(0, 1);
            linesRect.sizeDelta = new Vector2(0, 305000);
            linesRect.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, 0, 50);
            linesHolder.AddComponent<Image>().color = new Color(0.05f, 0.05f, 0.05f);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(linesHolder, true, true, true, true);

            LineNumberText = UIFactory.CreateLabel(linesHolder, "LineNumbers", "1", TextAnchor.UpperCenter, Color.grey, fontSize: 16);
            LineNumberText.font = UniversalUI.ConsoleFont;

            // input field

            int fontSize = 16;

            var inputObj = UIFactory.CreateScrollInputField(inputArea, "ConsoleInput", ConsoleController.STARTUP_TEXT, 
                out var inputScroller, fontSize);
            InputScroller = inputScroller;
            ConsoleController.defaultInputFieldAlpha = Input.Component.selectionColor.a;
            Input.OnValueChanged += InvokeOnValueChanged;

            // move line number text with input field
            linesRect.transform.SetParent(inputObj.transform.Find("Viewport"), false);
            inputScroller.Slider.Scrollbar.onValueChanged.AddListener((float val) => { SetLinesPosition(); });
            inputScroller.Slider.Slider.onValueChanged.AddListener((float val) => { SetLinesPosition(); });
            void SetLinesPosition()
            {
                linesRect.anchoredPosition = new Vector2(linesRect.anchoredPosition.x, inputScroller.ContentRect.anchoredPosition.y);
                //SetInputLayout();
            }

            InputText = Input.Component.textComponent;
            InputText.supportRichText = false;
            InputText.color = Color.clear;
            Input.Component.customCaretColor = true;
            Input.Component.caretColor = Color.white;
            Input.PlaceholderText.fontSize = fontSize;

            // Lexer highlight text overlay
            var highlightTextObj = UIFactory.CreateUIObject("HighlightText", InputText.gameObject);
            var highlightTextRect = highlightTextObj.GetComponent<RectTransform>();
            highlightTextRect.pivot = new Vector2(0, 1);
            highlightTextRect.anchorMin = Vector2.zero;
            highlightTextRect.anchorMax = Vector2.one;
            highlightTextRect.offsetMin = Vector2.zero;
            highlightTextRect.offsetMax = Vector2.zero;

            HighlightText = highlightTextObj.AddComponent<Text>();
            HighlightText.color = Color.white;
            HighlightText.supportRichText = true;
            HighlightText.fontSize = fontSize;

            // Set fonts
            InputText.font = UniversalUI.ConsoleFont;
            Input.PlaceholderText.font = UniversalUI.ConsoleFont;
            HighlightText.font = UniversalUI.ConsoleFont;

            RuntimeHelper.StartCoroutine(DelayedLayoutSetup());
        }

        private IEnumerator DelayedLayoutSetup()
        {
            yield return null;
            SetInputLayout();
        }

        public void SetInputLayout()
        {
            Input.Transform.offsetMin = new Vector2(52, Input.Transform.offsetMin.y);
            Input.Transform.offsetMax = new Vector2(2, Input.Transform.offsetMax.y);
        }
    }
}

```

`src/UI/Panels/ClipboardPanel.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.Config;
using UniverseLib;
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Widgets;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Panels
{
    public class ClipboardPanel : UIPanel
    {
        public static object Current { get; private set; }

        public override UIManager.Panels PanelType => UIManager.Panels.Clipboard;
        public override string Name => "Clipboard";
        public override int MinWidth => 500;
        public override int MinHeight => 95;
        public override bool CanDragAndResize => true;
        public override bool NavButtonWanted => true;
        public override bool ShouldSaveActiveState => true;
        public override bool ShowByDefault => true;

        private static Text CurrentPasteLabel;

        public static void Copy(object obj)
        {
            Current = obj;
            Notification.ShowMessage("Copied!");
            UpdateCurrentPasteInfo();
        }

        public static bool TryPaste(Type targetType, out object paste)
        {
            paste = Current;
            var pasteType = Current?.GetActualType();

            if (Current != null && !targetType.IsAssignableFrom(pasteType))
            {
                Notification.ShowMessage($"Cannot assign '{pasteType.Name}' to '{targetType.Name}'!");
                return false;
            }
            
            Notification.ShowMessage("Pasted!");
            return true;
        }

        public static void ClearClipboard()
        {
            Current = null;
            UpdateCurrentPasteInfo();
        }

        private static void UpdateCurrentPasteInfo()
        {
            CurrentPasteLabel.text = ToStringUtility.ToStringWithType(Current, typeof(object), false);
        }

        private static void InspectClipboard()
        {
            if (Current.IsNullOrDestroyed())
            {
                Notification.ShowMessage("Cannot inspect a null or destroyed object!");
                return;
            }

            InspectorManager.Inspect(Current);
        }
        
        protected internal override void DoSetDefaultPosAndAnchors()
        {
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, MinWidth);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, MinHeight);
            this.Rect.anchorMin = new Vector2(0.1f, 0.05f);
            this.Rect.anchorMax = new Vector2(0.4f, 0.15f);
        }

        public override void ConstructPanelContent()
        {
            this.UIRoot.GetComponent<Image>().color = new(0.1f, 0.1f, 0.1f);

            // Actual panel content

            var firstRow = UIFactory.CreateHorizontalGroup(uiContent, "FirstRow", false, false, true, true, 5, new(2,2,2,2), new(1,1,1,0));
            UIFactory.SetLayoutElement(firstRow, minHeight: 25, flexibleWidth: 999);

            // Title for "Current Paste:"
            var currentPasteTitle = UIFactory.CreateLabel(firstRow, "CurrentPasteTitle", "Current paste:", TextAnchor.MiddleLeft, color: Color.grey);
            UIFactory.SetLayoutElement(currentPasteTitle.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999);

            // Clear clipboard button
            var clearButton = UIFactory.CreateButton(firstRow, "ClearPasteButton", "Clear Clipboard");
            UIFactory.SetLayoutElement(clearButton.Component.gameObject, minWidth: 120, minHeight: 25, flexibleWidth: 0);
            clearButton.OnClick += () => Copy(null);

            // Current Paste info row
            var currentPasteHolder = UIFactory.CreateHorizontalGroup(uiContent, "SecondRow", false, false, true, true, 0, 
                new(2, 2, 2, 2), childAlignment: TextAnchor.UpperCenter);

            // Actual current paste info label
            CurrentPasteLabel = UIFactory.CreateLabel(currentPasteHolder, "CurrentPasteInfo", "not set", TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(CurrentPasteLabel.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 999, flexibleHeight: 999);
            UpdateCurrentPasteInfo();

            // Inspect button
            var inspectButton = UIFactory.CreateButton(currentPasteHolder, "InspectButton", "Inspect");
            UIFactory.SetLayoutElement(inspectButton.Component.gameObject, minHeight: 25, flexibleHeight: 0, minWidth: 80, flexibleWidth: 0);
            inspectButton.OnClick += InspectClipboard;
        }
    }
}

```

`src/UI/Panels/HookManagerPanel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.Hooks;
using UnityExplorer.UI.Widgets;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    public class HookManagerPanel : UIPanel
    {
        public enum Pages
        {
            CurrentHooks,
            ClassMethodSelector,
            HookSourceEditor
        }

        public override UIManager.Panels PanelType => UIManager.Panels.HookManager;

        public override string Name => "Hooks";
        public override int MinWidth => 500;
        public override int MinHeight => 600;
        public override bool ShowByDefault => false;

        public Pages CurrentPage { get; private set; } = Pages.CurrentHooks;

        private GameObject currentHooksPanel;
        public ScrollPool<HookCell> HooksScrollPool;
        private InputFieldRef classSelectorInputField;

        private GameObject addHooksPanel;
        public ScrollPool<AddHookCell> AddHooksScrollPool;
        private Text addHooksLabel;
        private InputFieldRef AddHooksMethodFilterInput;

        private GameObject editorPanel;
        public InputFieldScroller EditorInputScroller { get; private set; }
        public InputFieldRef EditorInput => EditorInputScroller.InputField;
        public Text EditorInputText { get; private set; }
        public Text EditorHighlightText { get; private set; }

        private void OnClassInputAddClicked()
        {
            HookManager.Instance.OnClassSelectedForHooks(this.classSelectorInputField.Text);
        }

        public void SetAddHooksLabelType(string typeText) => addHooksLabel.text = $"Adding hooks to: {typeText}";

        public void SetPage(Pages page)
        {
            switch (page)
            {
                case Pages.CurrentHooks:
                    currentHooksPanel.SetActive(true);
                    addHooksPanel.SetActive(false);
                    editorPanel.SetActive(false);
                    break;
                case Pages.ClassMethodSelector:
                    currentHooksPanel.SetActive(false);
                    addHooksPanel.SetActive(true);
                    editorPanel.SetActive(false);
                    break;
                case Pages.HookSourceEditor:
                    currentHooksPanel.SetActive(false);
                    addHooksPanel.SetActive(false);
                    editorPanel.SetActive(true);
                    break;
            }
        }

        public void ResetMethodFilter() => AddHooksMethodFilterInput.Text = string.Empty;

        public override void ConstructPanelContent()
        {
            // ~~~~~~~~~ Active hooks scroll pool

            currentHooksPanel = UIFactory.CreateUIObject("CurrentHooksPanel", this.uiContent);
            UIFactory.SetLayoutElement(currentHooksPanel, flexibleHeight: 9999, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(currentHooksPanel, true, true, true, true);

            var addRow = UIFactory.CreateHorizontalGroup(currentHooksPanel, "AddRow", false, true, true, true, 4,
                new Vector4(2, 2, 2, 2), new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(addRow, minHeight: 30, flexibleWidth: 9999);

            classSelectorInputField = UIFactory.CreateInputField(addRow, "ClassInput", "Enter a class to add hooks to...");
            UIFactory.SetLayoutElement(classSelectorInputField.Component.gameObject, flexibleWidth: 9999);
            new TypeCompleter(typeof(object), classSelectorInputField, true, false);

            var addButton = UIFactory.CreateButton(addRow, "AddButton", "Add Hooks");
            UIFactory.SetLayoutElement(addButton.Component.gameObject, minWidth: 100, minHeight: 25);
            addButton.OnClick += OnClassInputAddClicked;

            var hooksLabel = UIFactory.CreateLabel(currentHooksPanel, "HooksLabel", "Current Hooks", TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(hooksLabel.gameObject, minHeight: 30, flexibleWidth: 9999);

            HooksScrollPool = UIFactory.CreateScrollPool<HookCell>(currentHooksPanel, "HooksScrollPool", 
                out GameObject hooksScroll, out GameObject hooksContent);
            UIFactory.SetLayoutElement(hooksScroll, flexibleHeight: 9999);
            HooksScrollPool.Initialize(HookManager.Instance);

            // ~~~~~~~~~ Add hooks panel

            addHooksPanel = UIFactory.CreateUIObject("AddHooksPanel", this.uiContent);
            UIFactory.SetLayoutElement(addHooksPanel, flexibleHeight: 9999, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(addHooksPanel, true, true, true, true);

            addHooksLabel = UIFactory.CreateLabel(addHooksPanel, "AddLabel", "NOT SET", TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(addHooksLabel.gameObject, minHeight: 30, minWidth: 100, flexibleWidth: 9999);

            var buttonRow = UIFactory.CreateHorizontalGroup(addHooksPanel, "ButtonRow", false, false, true, true, 5);
            UIFactory.SetLayoutElement(buttonRow, minHeight: 25, flexibleWidth: 9999);

            var doneButton = UIFactory.CreateButton(buttonRow, "DoneButton", "Done", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(doneButton.Component.gameObject, minHeight: 25, flexibleWidth: 9999);
            doneButton.OnClick += HookManager.Instance.DoneAddingHooks;

            AddHooksMethodFilterInput = UIFactory.CreateInputField(addHooksPanel, "FilterInputField", "Filter method names...");
            UIFactory.SetLayoutElement(AddHooksMethodFilterInput.Component.gameObject, minHeight: 30, flexibleWidth: 9999);
            AddHooksMethodFilterInput.OnValueChanged += HookManager.Instance.OnAddHookFilterInputChanged;

            AddHooksScrollPool = UIFactory.CreateScrollPool<AddHookCell>(addHooksPanel, "MethodAddScrollPool",
                out GameObject addScrollRoot, out GameObject addContent);
            UIFactory.SetLayoutElement(addScrollRoot, flexibleHeight: 9999);
            AddHooksScrollPool.Initialize(HookManager.Instance);

            addHooksPanel.gameObject.SetActive(false);

            // ~~~~~~~~~ Hook source editor panel

            editorPanel = UIFactory.CreateUIObject("HookSourceEditor", this.uiContent);
            UIFactory.SetLayoutElement(editorPanel, flexibleHeight: 9999, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(editorPanel, true, true, true, true);

            var editorLabel = UIFactory.CreateLabel(editorPanel, 
                "EditorLabel", 
                "Edit Harmony patch source as desired. Accepted method names are Prefix, Postfix, Finalizer and Transpiler (can define multiple).\n\n" +
                "Hooks are temporary! Please copy the source into your IDE to avoid losing work if you wish to keep it!", 
                TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(editorLabel.gameObject, minHeight: 25, flexibleWidth: 9999);

            var editorButtonRow = UIFactory.CreateHorizontalGroup(editorPanel, "ButtonRow", false, false, true, true, 5);
            UIFactory.SetLayoutElement(editorButtonRow, minHeight: 25, flexibleWidth: 9999);

            var editorSaveButton = UIFactory.CreateButton(editorButtonRow, "DoneButton", "Save and Return", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(editorSaveButton.Component.gameObject, minHeight: 25, flexibleWidth: 9999);
            editorSaveButton.OnClick += HookManager.Instance.EditorInputSave;

            var editorDoneButton = UIFactory.CreateButton(editorButtonRow, "DoneButton", "Cancel and Return", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(editorDoneButton.Component.gameObject, minHeight: 25, flexibleWidth: 9999);
            editorDoneButton.OnClick += HookManager.Instance.EditorInputCancel;

            int fontSize = 16;
            var inputObj = UIFactory.CreateScrollInputField(editorPanel, "EditorInput", "", out var inputScroller, fontSize);
            EditorInputScroller = inputScroller;
            EditorInput.OnValueChanged += HookManager.Instance.OnEditorInputChanged;

            EditorInputText = EditorInput.Component.textComponent;
            EditorInputText.supportRichText = false;
            EditorInputText.color = Color.clear;
            EditorInput.Component.customCaretColor = true;
            EditorInput.Component.caretColor = Color.white;
            EditorInput.PlaceholderText.fontSize = fontSize;

            // Lexer highlight text overlay
            var highlightTextObj = UIFactory.CreateUIObject("HighlightText", EditorInputText.gameObject);
            var highlightTextRect = highlightTextObj.GetComponent<RectTransform>();
            highlightTextRect.pivot = new Vector2(0, 1);
            highlightTextRect.anchorMin = Vector2.zero;
            highlightTextRect.anchorMax = Vector2.one;
            highlightTextRect.offsetMin = Vector2.zero;
            highlightTextRect.offsetMax = Vector2.zero;

            EditorHighlightText = highlightTextObj.AddComponent<Text>();
            EditorHighlightText.color = Color.white;
            EditorHighlightText.supportRichText = true;
            EditorHighlightText.fontSize = fontSize;

            // Set fonts
            EditorInputText.font = UniversalUI.ConsoleFont;
            EditorInput.PlaceholderText.font = UniversalUI.ConsoleFont;
            EditorHighlightText.font = UniversalUI.ConsoleFont;

            editorPanel.SetActive(false);
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            this.Rect.anchorMin = new Vector2(0.5f, 0.5f);
            this.Rect.anchorMax = new Vector2(0.5f, 0.5f);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, MinWidth);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, MinHeight);
        }
    }
}

```

`src/UI/Panels/InspectorPanel.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UniverseLib.UI;

namespace UnityExplorer.UI.Panels
{
    public class InspectorPanel : UIPanel
    {
        public static InspectorPanel Instance { get; private set; }

        public InspectorPanel() { Instance = this; }

        public override string Name => "Inspector";
        public override UIManager.Panels PanelType => UIManager.Panels.Inspector;
        public override bool ShouldSaveActiveState => false;
        public override int MinWidth => 810;
        public override int MinHeight => 350;

        public GameObject NavbarHolder;
        public Dropdown MouseInspectDropdown;
        public GameObject ContentHolder;
        public RectTransform ContentRect;

        public static float CurrentPanelWidth => Instance.Rect.rect.width;
        public static float CurrentPanelHeight => Instance.Rect.rect.height;

        public override void Update()
        {
            InspectorManager.Update();
        }

        public override void OnFinishResize(RectTransform panel)
        {
            base.OnFinishResize(panel);

            InspectorManager.PanelWidth = this.Rect.rect.width;
            InspectorManager.OnPanelResized(panel.rect.width);
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.localPosition = Vector2.zero;
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(0.35f, 0.175f);
            Rect.anchorMax = new Vector2(0.8f, 0.925f);
        }

        public override void ConstructPanelContent()
        {
            var closeHolder = this.TitleBar.transform.Find("CloseHolder").gameObject;

            // Inspect under mouse dropdown on title bar

            var mouseDropdown = UIFactory.CreateDropdown(closeHolder, "MouseInspectDropdown", out MouseInspectDropdown, "Mouse Inspect", 14,
                MouseInspector.OnDropdownSelect);
            UIFactory.SetLayoutElement(mouseDropdown, minHeight: 25, minWidth: 140);
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("Mouse Inspect"));
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("World"));
            MouseInspectDropdown.options.Add(new Dropdown.OptionData("UI"));
            mouseDropdown.transform.SetSiblingIndex(0);

            // add close all button to titlebar

            var closeAllBtn = UIFactory.CreateButton(closeHolder.gameObject, "CloseAllBtn", "Close All",
                new Color(0.3f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(closeAllBtn.Component.gameObject, minHeight: 25, minWidth: 80);
            closeAllBtn.Component.transform.SetSiblingIndex(closeAllBtn.Component.transform.GetSiblingIndex() - 1);
            closeAllBtn.OnClick += InspectorManager.CloseAllTabs;

            // this.UIRoot.GetComponent<Mask>().enabled = false;

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(this.uiContent, true, true, true, true, 4, padLeft: 5, padRight: 5);

            this.NavbarHolder = UIFactory.CreateGridGroup(this.uiContent, "Navbar", new Vector2(200, 22), new Vector2(4, 4),
                new Color(0.05f, 0.05f, 0.05f));
            //UIFactory.SetLayoutElement(NavbarHolder, flexibleWidth: 9999, minHeight: 0, preferredHeight: 0, flexibleHeight: 9999);
            NavbarHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            this.ContentHolder = UIFactory.CreateVerticalGroup(this.uiContent, "ContentHolder", true, true, true, true, 0, default,
                new Color(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(ContentHolder, flexibleHeight: 9999);
            ContentRect = ContentHolder.GetComponent<RectTransform>();

            UIManager.SetPanelActive(PanelType, false);
        }
    }
}
```

`src/UI/Panels/LogPanel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Panels
{
    // TODO move the logic out of this class into a LogUtil class (also move ExplorerCore.Log into that)

    public class LogPanel : UIPanel, ICellPoolDataSource<ConsoleLogCell>
    {
        public struct LogInfo
        {
            public string message;
            public LogType type;

            public LogInfo(string message, LogType type) { this.message = message; this.type = type; }
        }

        private static readonly List<LogInfo> Logs = new List<LogInfo>();
        private static string CurrentStreamPath;

        public override string Name => "Log";
        public override UIManager.Panels PanelType => UIManager.Panels.ConsoleLog;

        public override int MinWidth => 350;
        public override int MinHeight => 75;
        public override bool ShouldSaveActiveState => true;
        public override bool ShowByDefault => true;

        public int ItemCount => Logs.Count;

        private static ScrollPool<ConsoleLogCell> logScrollPool;

        public LogPanel()
        {
            SetupIO();
        }

        private static bool DoneScrollPoolInit;

        public override void SetActive(bool active)
        {
            base.SetActive(active);

            if (active && !DoneScrollPoolInit)
            {
                LayoutRebuilder.ForceRebuildLayoutImmediate(this.Rect);
                logScrollPool.Initialize(this);
                DoneScrollPoolInit = true;
            }

            logScrollPool.Refresh(true, false);
        }

        private void SetupIO()
        {
            var fileName = $"UnityExplorer {DateTime.Now:u}.txt";
            fileName = IOUtility.EnsureValidFilename(fileName);
            var path = Path.Combine(ExplorerCore.Loader.ExplorerFolder, "Logs");
            CurrentStreamPath = IOUtility.EnsureValidFilePath(Path.Combine(path, fileName));

            // clean old log(s)
            var files = Directory.GetFiles(path);
            if (files.Length >= 10)
            {
                var sorted = files.ToList();
                // sort by 'datetime.ToString("u")' will put the oldest ones first
                sorted.Sort();
                for (int i = 0; i < files.Length - 9; i++)
                    File.Delete(files[i]);
            }

            File.WriteAllLines(CurrentStreamPath, Logs.Select(it => it.message).ToArray());
        }

        // Logging

        public static void Log(string message, LogType type)
        {
            Logs.Add(new LogInfo(message, type));

            if (CurrentStreamPath != null)
                File.AppendAllText(CurrentStreamPath, '\n' + message);

            if (logScrollPool != null)
                logScrollPool.Refresh(true, false);
        }

        private static void ClearLogs()
        {
            Logs.Clear();
            logScrollPool.Refresh(true, true);
        }

        private static void OpenLogFile()
        {
            if (File.Exists(CurrentStreamPath))
                Process.Start(CurrentStreamPath);
        }

        // Cell pool

        private static readonly Dictionary<LogType, Color> logColors = new Dictionary<LogType, Color>
        {
            { LogType.Log,       Color.white },
            { LogType.Warning,   Color.yellow },
            { LogType.Assert,    Color.yellow },
            { LogType.Error,     Color.red },
            { LogType.Exception, Color.red },
        };

        private readonly Color logEvenColor = new Color(0.34f, 0.34f, 0.34f);
        private readonly Color logOddColor = new Color(0.28f, 0.28f, 0.28f);

        public void OnCellBorrowed(ConsoleLogCell cell) { }

        public void SetCell(ConsoleLogCell cell, int index)
        {
            if (index >= Logs.Count)
            {
                cell.Disable();
                return;
            }

            // Logs are displayed in reverse order (newest at top)
            index = Logs.Count - index - 1;

            var log = Logs[index];
            cell.IndexLabel.text = $"{index}:";
            cell.Input.Text = log.message;
            cell.Input.Component.textComponent.color = logColors[log.type];

            var color = index % 2 == 0 ? logEvenColor : logOddColor;
            RuntimeHelper.SetColorBlock(cell.Input.Component, color);
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.localPosition = Vector2.zero;
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(0.5f, 0.03f);
            Rect.anchorMax = new Vector2(0.9f, 0.2f);
        }

        // UI Construction

        public override void ConstructPanelContent()
        {
            // Log scroll pool

            logScrollPool = UIFactory.CreateScrollPool<ConsoleLogCell>(this.uiContent, "Logs", out GameObject scrollObj,
                out GameObject scrollContent, new Color(0.03f, 0.03f, 0.03f));
            UIFactory.SetLayoutElement(scrollObj, flexibleWidth: 9999, flexibleHeight: 9999);

            // Buttons and toggles

            var optionsRow = UIFactory.CreateUIObject("OptionsRow", this.uiContent);
            UIFactory.SetLayoutElement(optionsRow, minHeight: 25, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(optionsRow, false, false, true, true, 5, 2, 2, 2, 2);

            var clearButton = UIFactory.CreateButton(optionsRow, "ClearButton", "Clear", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(clearButton.Component.gameObject, minHeight: 23, flexibleHeight: 0, minWidth: 60);
            clearButton.OnClick += ClearLogs;
            clearButton.Component.transform.SetSiblingIndex(1);

            var fileButton = UIFactory.CreateButton(optionsRow, "FileButton", "Open Log File", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(fileButton.Component.gameObject, minHeight: 23, flexibleHeight: 0, minWidth: 100);
            fileButton.OnClick += OpenLogFile;
            fileButton.Component.transform.SetSiblingIndex(2);

            var unityToggle = UIFactory.CreateToggle(optionsRow, "UnityLogToggle", out var toggle, out var toggleText);
            UIFactory.SetLayoutElement(unityToggle, minHeight: 25, minWidth: 150);
            toggleText.text = "Log Unity Debug?";
            toggle.isOn = ConfigManager.Log_Unity_Debug.Value;
            ConfigManager.Log_Unity_Debug.OnValueChanged += (bool val) => toggle.isOn = val;
            toggle.onValueChanged.AddListener((bool val) => ConfigManager.Log_Unity_Debug.Value = val);
        }
    }

    #region Log Cell View

    public class ConsoleLogCell : ICell
    {
        public Text IndexLabel;
        public InputFieldRef Input;

        public RectTransform Rect { get; set; }
        public GameObject UIRoot { get; set; }

        public float DefaultHeight => 25;

        public bool Enabled => UIRoot.activeInHierarchy;
        public void Enable() => UIRoot.SetActive(true);
        public void Disable() => UIRoot.SetActive(false);


        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject("LogCell", parent, new Vector2(25, 25));
            Rect = UIRoot.GetComponent<RectTransform>();
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 3);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, minWidth: 50, flexibleWidth: 9999);

            IndexLabel = UIFactory.CreateLabel(UIRoot, "IndexLabel", "i:", TextAnchor.MiddleCenter, Color.grey, false, 12);
            UIFactory.SetLayoutElement(IndexLabel.gameObject, minHeight: 25, minWidth: 30, flexibleWidth: 40);

            Input = UIFactory.CreateInputField(UIRoot, "Input", "");
            //Input.Component.gameObject.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;
            UIFactory.SetLayoutElement(Input.UIRoot, minHeight: 25, flexibleWidth: 9999);
            RuntimeHelper.SetColorBlock(Input.Component, new Color(0.1f, 0.1f, 0.1f), new Color(0.13f, 0.13f, 0.13f),
                new Color(0.07f, 0.07f, 0.07f));
            Input.Component.GetComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f);

            Input.Component.readOnly = true;
            Input.Component.textComponent.supportRichText = true;
            Input.Component.lineType = InputField.LineType.MultiLineNewline;
            Input.Component.textComponent.font = UniversalUI.ConsoleFont;
            Input.PlaceholderText.font = UniversalUI.ConsoleFont;

            return UIRoot;
        }
    }

    #endregion
}

```

`src/UI/Panels/ObjectExplorerPanel.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityExplorer.Config;
using UniverseLib.UI.Models;
using UnityExplorer.ObjectExplorer;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI;
using UniverseLib;

namespace UnityExplorer.UI.Panels
{
    public class ObjectExplorerPanel : UIPanel
    {
        public override string Name => "Object Explorer";
        public override UIManager.Panels PanelType => UIManager.Panels.ObjectExplorer;
        public override int MinWidth => 350;
        public override int MinHeight => 200;

        public SceneExplorer SceneExplorer;
        public ObjectSearch ObjectSearch;

        public override bool ShowByDefault => true;
        public override bool ShouldSaveActiveState => true;

        public int SelectedTab = 0;
        private readonly List<UIModel> tabPages = new List<UIModel>();
        private readonly List<ButtonRef> tabButtons = new List<ButtonRef>();

        public void SetTab(int tabIndex)
        {
            if (SelectedTab != -1)
                DisableTab(SelectedTab);

            var content = tabPages[tabIndex];
            content.SetActive(true);

            var button = tabButtons[tabIndex];
            RuntimeHelper.SetColorBlock(button.Component, UniversalUI.EnabledButtonColor, UniversalUI.EnabledButtonColor * 1.2f);

            SelectedTab = tabIndex;
            SaveInternalData();
        }

        private void DisableTab(int tabIndex)
        {
            tabPages[tabIndex].SetActive(false);
            RuntimeHelper.SetColorBlock(tabButtons[tabIndex].Component, UniversalUI.DisabledButtonColor, UniversalUI.DisabledButtonColor * 1.2f);
        }

        public override void Update()
        {
            if (SelectedTab == 0)
                SceneExplorer.Update();
            else
                ObjectSearch.Update();
        }

        public override string ToSaveData()
        {
            return string.Join("|", new string[] { base.ToSaveData(), SelectedTab.ToString() });
        }

        protected override void ApplySaveData(string data)
        {
            base.ApplySaveData(data);

            try
            {
                int tab = int.Parse(data.Split('|').Last());
                SelectedTab = tab;
            }
            catch
            {
                SelectedTab = 0;
            }

            SelectedTab = Math.Max(0, SelectedTab);
            SelectedTab = Math.Min(1, SelectedTab);

            SetTab(SelectedTab);
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.localPosition = Vector2.zero;
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(0.125f, 0.175f);
            Rect.anchorMax = new Vector2(0.325f, 0.925f);
        }

        public override void ConstructPanelContent()
        {
            // Tab bar
            var tabGroup = UIFactory.CreateHorizontalGroup(uiContent, "TabBar", true, true, true, true, 2, new Vector4(2, 2, 2, 2));
            UIFactory.SetLayoutElement(tabGroup, minHeight: 25, flexibleHeight: 0);

            // Scene Explorer
            SceneExplorer = new SceneExplorer(this);
            SceneExplorer.ConstructUI(uiContent);
            tabPages.Add(SceneExplorer);

            // Object search
            ObjectSearch = new ObjectSearch(this);
            ObjectSearch.ConstructUI(uiContent);
            tabPages.Add(ObjectSearch);

            // set up tabs
            AddTabButton(tabGroup, "Scene Explorer");
            AddTabButton(tabGroup, "Object Search");

            // default active state: Active
            UIManager.SetPanelActive(PanelType, true);
        }

        private void AddTabButton(GameObject tabGroup, string label)
        {
            var button = UIFactory.CreateButton(tabGroup, $"Button_{label}", label);

            int idx = tabButtons.Count;
            //button.onClick.AddListener(() => { SetTab(idx); });
            button.OnClick += () => { SetTab(idx); };

            tabButtons.Add(button);

            DisableTab(tabButtons.Count - 1);
        }
    }
}

```

`src/UI/Panels/OptionsPanel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.CacheObject;
using UnityExplorer.CacheObject.Views;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI.Widgets;
using UniverseLib.UI;
using UniverseLib.UI.Widgets.ScrollView;

namespace UnityExplorer.UI.Panels
{
    public class OptionsPanel : UIPanel, ICacheObjectController, ICellPoolDataSource<ConfigEntryCell>
    {
        public override string Name => "Options";
        public override UIManager.Panels PanelType => UIManager.Panels.Options;

        public override int MinWidth => 600;
        public override int MinHeight => 200;

        public override bool ShouldSaveActiveState => false;
        public override bool ShowByDefault => false;

        // Entry holders
        private readonly List<CacheConfigEntry> configEntries = new List<CacheConfigEntry>();

        // ICacheObjectController
        public CacheObjectBase ParentCacheObject => null;
        public object Target => null;
        public Type TargetType => null;
        public bool CanWrite => true;

        // ICellPoolDataSource
        public int ItemCount => configEntries.Count;

        public OptionsPanel()
        {
            foreach (var entry in ConfigManager.ConfigElements)
            {
                var cache = new CacheConfigEntry(entry.Value);
                cache.Owner = this;
                configEntries.Add(cache);
            }
        }

        public void OnCellBorrowed(ConfigEntryCell cell)
        {
        }

        public void SetCell(ConfigEntryCell cell, int index)
        {
            CacheObjectControllerHelper.SetCell(cell, index, this.configEntries, null);
        }

        // UI Construction

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            Rect.localPosition = Vector2.zero;
            Rect.pivot = new Vector2(0f, 1f);
            Rect.anchorMin = new Vector2(0.5f, 0.1f);
            Rect.anchorMax = new Vector2(0.5f, 0.85f);
            Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 600f);
        }

        public override void ConstructPanelContent()
        {
            // Save button

            var saveBtn = UIFactory.CreateButton(this.uiContent, "Save", "Save Options", new Color(0.2f, 0.3f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, flexibleWidth: 9999, minHeight: 30, flexibleHeight: 0);
            saveBtn.OnClick += ConfigManager.Handler.SaveConfig;

            // Config entries

            var scrollPool = UIFactory.CreateScrollPool<ConfigEntryCell>(this.uiContent, "ConfigEntries", out GameObject scrollObj,
                out GameObject scrollContent);

            scrollPool.Initialize(this);

            foreach (var config in configEntries)
                config.UpdateValueFromSource();
        }
    }
}

```

`src/UI/Panels/PanelDragger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.Input;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Panels
{
    public class PanelDragger
    {
        private enum MouseState
        {
            Down,
            Held,
            NotPressed
        }

        #region Static

        public static bool Resizing { get; private set; }
        public static bool ResizePrompting => resizeCursorObj && resizeCursorObj.activeSelf;

        public static GameObject resizeCursorObj;
        internal static bool wasAnyDragging;

        internal static List<PanelDragger> Instances = new();

        private static bool handledInstanceThisFrame;

        static PanelDragger()
        {
            UIPanel.OnPanelsReordered += OnPanelsReordered;
        }

        internal static void ForceEnd()
        {
            resizeCursorObj.SetActive(false);
            wasAnyDragging = false;
            Resizing = false;

            foreach (var instance in Instances)
            {
                instance.WasDragging = false;
                instance.WasResizing = false;
            }
        }

        public static void OnPanelsReordered()
        {
            Instances.Sort((a, b) => b.Panel.GetSiblingIndex().CompareTo(a.Panel.GetSiblingIndex()));

            // move AutoCompleter to bottom
            if (AutoCompleteModal.Instance != null)
            {
                var idx = Instances.IndexOf(AutoCompleteModal.Instance.Dragger);
                Instances.RemoveAt(idx);
                Instances.Insert(0, AutoCompleteModal.Instance.Dragger);
            }
        }

        public static void UpdateInstances()
        {
            if (!DisplayManager.MouseInTargetDisplay)
                return;

            if (!resizeCursorObj)
                CreateCursorUI();

            MouseState state;
            if (InputManager.GetMouseButtonDown(0))
                state = MouseState.Down;
            else if (InputManager.GetMouseButton(0))
                state = MouseState.Held;
            else
                state = MouseState.NotPressed;

            var mousePos = DisplayManager.MousePosition;

            handledInstanceThisFrame = false;
            foreach (var instance in Instances)
            {
                if (!instance.Panel.gameObject.activeSelf)
                    continue;

                instance.Update(state, mousePos);
                if (handledInstanceThisFrame)
                    break;
            }

            if (wasAnyDragging && state == MouseState.NotPressed)
            {
                foreach (var instance in Instances)
                    instance.WasDragging = false;
                wasAnyDragging = false;
            }
        }

        #endregion

        // Instance

        public UIPanel UIPanel { get; private set; }
        public bool AllowDragAndResize => UIPanel.CanDragAndResize;

        public RectTransform Panel { get; set; }
        public event Action<RectTransform> OnFinishResize;
        public event Action<RectTransform> OnFinishDrag;

        // Dragging
        public RectTransform DragableArea { get; set; }
        public bool WasDragging { get; set; }
        private Vector2 lastDragPosition;

        // Resizing
        private const int RESIZE_THICKNESS = 10;

        private bool WasResizing { get; set; }
        private ResizeTypes currentResizeType = ResizeTypes.NONE;
        private Vector2 lastResizePos;

        private bool WasHoveringResize => resizeCursorObj.activeInHierarchy;

        private ResizeTypes lastResizeHoverType;

        private Rect totalResizeRect;

        public PanelDragger(RectTransform dragArea, RectTransform panelToDrag, UIPanel panel)
        {
            this.UIPanel = panel;
            Instances.Add(this);
            DragableArea = dragArea;
            Panel = panelToDrag;

            UpdateResizeCache();
        }

        public void Destroy()
        {
            if (resizeCursorObj)
                GameObject.Destroy(resizeCursorObj);

            if (Instances.Contains(this))
                Instances.Remove(this);
        }

        private void Update(MouseState state, Vector3 rawMousePos)
        {
            ResizeTypes type;
            Vector3 resizePos = Panel.InverseTransformPoint(rawMousePos);
            bool inResizePos = !UIManager.NavBarRect.rect.Contains(UIManager.NavBarRect.InverseTransformPoint(rawMousePos))
                && MouseInResizeArea(resizePos);

            Vector3 dragPos = DragableArea.InverseTransformPoint(rawMousePos);
            bool inDragPos = DragableArea.rect.Contains(dragPos);

            if (WasHoveringResize && resizeCursorObj)
                UpdateHoverImagePos();

            switch (state)
            {
                case MouseState.Down:
                    if (inDragPos || inResizePos)
                        UIManager.SetPanelActive(Panel, true);

                    if (inDragPos)
                    {
                        if (AllowDragAndResize)
                            OnBeginDrag();
                        handledInstanceThisFrame = true;
                        return;
                    }
                    else if (inResizePos)
                    {
                        type = GetResizeType(resizePos);
                        if (type != ResizeTypes.NONE)
                            OnBeginResize(type);

                        handledInstanceThisFrame = true;
                    }
                    break;

                case MouseState.Held:
                    if (WasDragging)
                    {
                        OnDrag();
                        handledInstanceThisFrame = true;
                    }
                    else if (WasResizing)
                    {
                        OnResize();
                        handledInstanceThisFrame = true;
                    }
                    break;

                case MouseState.NotPressed:
                    if (AllowDragAndResize && inDragPos)
                    {
                        if (WasDragging)
                            OnEndDrag();

                        if (WasHoveringResize)
                            OnHoverResizeEnd();

                        handledInstanceThisFrame = true;
                    }
                    else if (inResizePos || WasResizing)
                    {
                        if (WasResizing)
                            OnEndResize();

                        type = GetResizeType(resizePos);
                        if (type != ResizeTypes.NONE)
                            OnHoverResize(type);
                        else if (WasHoveringResize)
                            OnHoverResizeEnd();

                        handledInstanceThisFrame = true;
                    }
                    else if (WasHoveringResize)
                        OnHoverResizeEnd();
                    break;
            }

            return;
        }

        #region DRAGGING

        public void OnBeginDrag()
        {
            wasAnyDragging = true;
            WasDragging = true;
            lastDragPosition = DisplayManager.MousePosition;
        }

        public void OnDrag()
        {
            var mousePos = DisplayManager.MousePosition;

            Vector2 diff = (Vector2)mousePos - lastDragPosition;
            lastDragPosition = mousePos;

            Panel.localPosition = Panel.localPosition + (Vector3)diff;

            UIPanel.EnsureValidPosition(Panel);
        }

        public void OnEndDrag()
        {
            WasDragging = false;

            OnFinishDrag?.Invoke(Panel);
        }

        #endregion

        #region RESIZE

        private readonly Dictionary<ResizeTypes, Rect> m_resizeMask = new()
        {
            { ResizeTypes.Top,      default },
            { ResizeTypes.Left,     default },
            { ResizeTypes.Right,    default },
            { ResizeTypes.Bottom,   default },
        };

        [Flags]
        public enum ResizeTypes : ulong
        {
            NONE = 0,
            Top = 1,
            Left = 2,
            Right = 4,
            Bottom = 8,
            TopLeft = Top | Left,
            TopRight = Top | Right,
            BottomLeft = Bottom | Left,
            BottomRight = Bottom | Right,
        }

        // private const int HALF_THICKESS = RESIZE_THICKNESS / 2;
        private const int DBL_THICKESS = RESIZE_THICKNESS * 2;

        private void UpdateResizeCache()
        {
            totalResizeRect = new Rect(Panel.rect.x - RESIZE_THICKNESS + 1,
                Panel.rect.y - RESIZE_THICKNESS + 1,
                Panel.rect.width + DBL_THICKESS - 2,
                Panel.rect.height + DBL_THICKESS - 2);

            // calculate the four cross sections to use as flags
            if (AllowDragAndResize)
            {
                m_resizeMask[ResizeTypes.Bottom] = new Rect(
                    totalResizeRect.x,
                    totalResizeRect.y,
                    totalResizeRect.width,
                    RESIZE_THICKNESS);

                m_resizeMask[ResizeTypes.Left] = new Rect(
                    totalResizeRect.x,
                    totalResizeRect.y,
                    RESIZE_THICKNESS,
                    totalResizeRect.height);

                m_resizeMask[ResizeTypes.Top] = new Rect(
                    totalResizeRect.x,
                    Panel.rect.y + Panel.rect.height - 2,
                    totalResizeRect.width,
                    RESIZE_THICKNESS);

                m_resizeMask[ResizeTypes.Right] = new Rect(
                    totalResizeRect.x + Panel.rect.width + RESIZE_THICKNESS - 2,
                    totalResizeRect.y,
                    RESIZE_THICKNESS,
                    totalResizeRect.height);
            }
        }

        private bool MouseInResizeArea(Vector2 mousePos)
        {
            return totalResizeRect.Contains(mousePos);
        }

        private ResizeTypes GetResizeType(Vector2 mousePos)
        {
            // Calculate which part of the resize area we're in, if any.
            // More readable method commented out below.

            int mask = 0;
            mask |= (int)ResizeTypes.Top * (m_resizeMask[ResizeTypes.Top].Contains(mousePos) ? 1 : 0);
            mask |= (int)ResizeTypes.Bottom * (m_resizeMask[ResizeTypes.Bottom].Contains(mousePos) ? 1 : 0);
            mask |= (int)ResizeTypes.Left * (m_resizeMask[ResizeTypes.Left].Contains(mousePos) ? 1 : 0);
            mask |= (int)ResizeTypes.Right * (m_resizeMask[ResizeTypes.Right].Contains(mousePos) ? 1 : 0);

            //if (m_resizeMask[ResizeTypes.Top].Contains(mousePos))
            //    mask |= ResizeTypes.Top;
            //else if (m_resizeMask[ResizeTypes.Bottom].Contains(mousePos))
            //    mask |= ResizeTypes.Bottom;

            //if (m_resizeMask[ResizeTypes.Left].Contains(mousePos))
            //    mask |= ResizeTypes.Left;
            //else if (m_resizeMask[ResizeTypes.Right].Contains(mousePos))
            //    mask |= ResizeTypes.Right;

            return (ResizeTypes)mask;
        }

        public void OnHoverResize(ResizeTypes resizeType)
        {
            if (WasHoveringResize && lastResizeHoverType == resizeType)
                return;

            // we are entering resize, or the resize type has changed.

            //WasHoveringResize = true;
            lastResizeHoverType = resizeType;

            resizeCursorObj.SetActive(true);
            resizeCursorObj.transform.SetAsLastSibling();

            // set the rotation for the resize icon
            float iconRotation = 0f;
            switch (resizeType)
            {
                case ResizeTypes.TopRight:
                case ResizeTypes.BottomLeft:
                    iconRotation = 45f; break;
                case ResizeTypes.Top:
                case ResizeTypes.Bottom:
                    iconRotation = 90f; break;
                case ResizeTypes.TopLeft:
                case ResizeTypes.BottomRight:
                    iconRotation = 135f; break;
            }

            Quaternion rot = resizeCursorObj.transform.rotation;
            rot.eulerAngles = new Vector3(0, 0, iconRotation);
            resizeCursorObj.transform.rotation = rot;

            UpdateHoverImagePos();
        }

        // update the resize icon position to be above the mouse
        private void UpdateHoverImagePos()
        {
            resizeCursorObj.transform.localPosition = UIManager.UIRootRect.InverseTransformPoint(DisplayManager.MousePosition);
        }

        public void OnHoverResizeEnd()
        {
            //WasHoveringResize = false;
            resizeCursorObj.SetActive(false);
        }

        public void OnBeginResize(ResizeTypes resizeType)
        {
            currentResizeType = resizeType;
            lastResizePos = DisplayManager.MousePosition;
            WasResizing = true;
            Resizing = true;
        }

        public void OnResize()
        {
            Vector3 mousePos = DisplayManager.MousePosition;
            Vector2 diff = lastResizePos - (Vector2)mousePos;

            if ((Vector2)mousePos == lastResizePos)
                return;

            if (mousePos.x < 0 || mousePos.y < 0 || mousePos.x > DisplayManager.Width || mousePos.y > DisplayManager.Height)
                return;

            lastResizePos = mousePos;

            float diffX = (float)((decimal)diff.x / DisplayManager.Width);
            float diffY = (float)((decimal)diff.y / DisplayManager.Height);

            Vector2 anchorMin = Panel.anchorMin;
            Vector2 anchorMax = Panel.anchorMax;

            if (currentResizeType.HasFlag(ResizeTypes.Left))
                anchorMin.x -= diffX;
            else if (currentResizeType.HasFlag(ResizeTypes.Right))
                anchorMax.x -= diffX;

            if (currentResizeType.HasFlag(ResizeTypes.Top))
                anchorMax.y -= diffY;
            else if (currentResizeType.HasFlag(ResizeTypes.Bottom))
                anchorMin.y -= diffY;

            var prevMin = Panel.anchorMin;
            var prevMax = Panel.anchorMax;

            Panel.anchorMin = new Vector2(anchorMin.x, anchorMin.y);
            Panel.anchorMax = new Vector2(anchorMax.x, anchorMax.y);

            if (Panel.rect.width < UIPanel.MinWidth)
            {
                Panel.anchorMin = new Vector2(prevMin.x, Panel.anchorMin.y);
                Panel.anchorMax = new Vector2(prevMax.x, Panel.anchorMax.y);
            }
            if (Panel.rect.height < UIPanel.MinHeight)
            {
                Panel.anchorMin = new Vector2(Panel.anchorMin.x, prevMin.y);
                Panel.anchorMax = new Vector2(Panel.anchorMax.x, prevMax.y);
            }
        }

        public void OnEndResize()
        {
            WasResizing = false;
            Resizing = false;
            try { OnHoverResizeEnd(); } catch { }
            UpdateResizeCache();
            OnFinishResize?.Invoke(Panel);
        }

        internal static void CreateCursorUI()
        {
            try
            {
                var text = UIFactory.CreateLabel(UIManager.UIRoot, "ResizeCursor", "â†”", TextAnchor.MiddleCenter, Color.white, true, 35);
                resizeCursorObj = text.gameObject;
                var outline = text.gameObject.AddComponent<Outline>();
                outline.effectColor = Color.black;
                outline.effectDistance = new(1, 1);

                RectTransform rect = resizeCursorObj.GetComponent<RectTransform>();
                rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 64);
                rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 64);

                resizeCursorObj.SetActive(false);
            }
            catch (Exception e)
            {
                ExplorerCore.LogWarning("Exception creating Resize Cursor UI!\r\n" + e.ToString());
            }
        }

        #endregion
    }
}
```

`src/UI/Panels/UIPanel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UniverseLib.Input;
using UnityExplorer.UI.Widgets;
using UniverseLib.UI.Models;
using UniverseLib.UI;
using UniverseLib;
using System.Collections;

namespace UnityExplorer.UI.Panels
{
    public abstract class UIPanel : UIBehaviourModel
    {
        #region STATIC

        internal static void InvokeOnPanelsReordered() => OnPanelsReordered?.Invoke();

        public static event Action OnPanelsReordered;
        public static event Action OnClickedOutsidePanels;

        internal static readonly List<UIPanel> instances = new();
        internal static readonly Dictionary<int, UIPanel> transformToPanelDict = new();

        public static void UpdateFocus()
        {
            if (PanelDragger.ResizePrompting)
                return;

            // if the user is clicking
            if (DisplayManager.MouseInTargetDisplay 
                && (InputManager.GetMouseButtonDown(0) || InputManager.GetMouseButtonDown(1)))
            {
                int count = UIManager.PanelHolder.transform.childCount;
                var mousePos = DisplayManager.MousePosition;
                bool clickedInAny = false;

                for (int i = count - 1; i >= 0; i--)
                {
                    // make sure this is a real recognized panel
                    var transform = UIManager.PanelHolder.transform.GetChild(i);
                    if (!transformToPanelDict.TryGetValue(transform.GetInstanceID(), out UIPanel panel))
                        continue;

                    // check if our mouse is clicking inside the panel
                    var pos = panel.Rect.InverseTransformPoint(mousePos);
                    if (!panel.Enabled || !panel.Rect.rect.Contains(pos))
                        continue;

                    // if this is not the top panel, reorder and invoke the onchanged event
                    if (transform.GetSiblingIndex() != count - 1)
                    {
                        transform.SetAsLastSibling();
                        OnPanelsReordered?.Invoke();
                    }
                    // panel was found, break
                    clickedInAny = true;
                    break;
                }

                if (!clickedInAny)
                    OnClickedOutsidePanels?.Invoke();
            }
        }

        #endregion

        // INSTANCE

        public UIPanel()
        {
            instances.Add(this);
        }

        public abstract UIManager.Panels PanelType { get; }
        public abstract string Name { get; }
        public abstract int MinWidth { get; }
        public abstract int MinHeight { get; }

        public virtual bool ShowByDefault => false;
        public virtual bool ShouldSaveActiveState => true;
        public virtual bool CanDragAndResize => true;
        public virtual bool NavButtonWanted => true;

        public ButtonRef NavButton { get; internal set; }
        public PanelDragger Dragger { get; internal set; }

        public override GameObject UIRoot => uiRoot;
        protected GameObject uiRoot;
        protected GameObject uiContent;
        public RectTransform Rect { get; private set; }
        public GameObject TitleBar { get; private set; }

        public virtual void OnFinishResize(RectTransform panel)
        {
            SaveInternalData();
        }

        public virtual void OnFinishDrag(RectTransform panel)
        {
            SaveInternalData();
        }

        public override void SetActive(bool active)
        {
            if (this.Enabled != active)
            {
                base.SetActive(active);

                if (!ApplyingSaveData)
                    SaveInternalData();

                if (NavButtonWanted)
                {
                    var color = active ? UniversalUI.EnabledButtonColor : UniversalUI.DisabledButtonColor;
                    RuntimeHelper.SetColorBlock(NavButton.Component, color, color * 1.2f);
                }
            }

            if (!active)
                this.Dragger.WasDragging = false;
            else
            {
                this.UIRoot.transform.SetAsLastSibling();
                InvokeOnPanelsReordered();
            }
        }

        public override void Destroy()
        {
            instances.Remove(this);
            base.Destroy();
        }

        protected internal abstract void DoSetDefaultPosAndAnchors();

        public void SetTransformDefaults()
        {
            DoSetDefaultPosAndAnchors();
        }

        public void EnsureValidSize()
        {
            if (Rect.rect.width < MinWidth)
                Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, MinWidth);
            if (Rect.rect.height < MinHeight)
                Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, MinHeight);
        }

        public void EnsureValidPosition() => EnsureValidPosition(this.Rect);

        public static void EnsureValidPosition(RectTransform panel)
        {
            var pos = panel.localPosition;

            // Prevent panel going oustide screen bounds
            var halfW = DisplayManager.Width * 0.5f;
            var halfH = DisplayManager.Height * 0.5f;

            pos.x = Math.Max(-halfW - panel.rect.width + 50, Math.Min(pos.x, halfW - 50));
            pos.y = Math.Max(-halfH + 50, Math.Min(pos.y, halfH));

            panel.localPosition = pos;
        }

        // Save Data

        public bool ApplyingSaveData { get; set; }

        public void SaveInternalData()
        {
            if (UIManager.Initializing)
                return;

            SetSaveDataToConfigValue();
        }

        private void SetSaveDataToConfigValue() => ConfigManager.GetPanelSaveData(this.PanelType).Value = this.ToSaveData();

        public virtual string ToSaveData()
        {
            try
            {
                return string.Join("|", new string[] 
                { 
                    $"{ShouldSaveActiveState && Enabled}", 
                    Rect.RectAnchorsToString(), 
                    Rect.RectPositionToString() 
                });
            }
            catch (Exception ex)
            {
                ExplorerCore.LogWarning($"Exception generating Panel save data: {ex}");
                return "";
            }
        }

        public virtual void ApplySaveData()
        {
            string data = ConfigManager.GetPanelSaveData(this.PanelType).Value;
            ApplySaveData(data);
        }

        protected virtual void ApplySaveData(string data)
        {
            if (string.IsNullOrEmpty(data))
                return;

            var split = data.Split('|');

            try
            {
                Rect.SetAnchorsFromString(split[1]);
                Rect.SetPositionFromString(split[2]);
                UIManager.SetPanelActive(this.PanelType, bool.Parse(split[0]));
            }
            catch
            {
                ExplorerCore.LogWarning("Invalid or corrupt panel save data! Restoring to default.");
                SetTransformDefaults();
                SetSaveDataToConfigValue();
            }
        }

        // UI Construction

        public abstract void ConstructPanelContent();

        public void ConstructUI()
        {
            //this.Enabled = true;

            if (NavButtonWanted)
            {
                // create navbar button

                NavButton = UIFactory.CreateButton(UIManager.NavbarTabButtonHolder, $"Button_{PanelType}", Name);
                var navBtn = NavButton.Component.gameObject;
                navBtn.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
                UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(navBtn, false, true, true, true, 0, 0, 0, 5, 5, TextAnchor.MiddleCenter);
                UIFactory.SetLayoutElement(navBtn, minWidth: 80);

                RuntimeHelper.SetColorBlock(NavButton.Component, UniversalUI.DisabledButtonColor, UniversalUI.DisabledButtonColor * 1.2f);
                NavButton.OnClick += () => { UIManager.TogglePanel(PanelType); };

                var txtObj = navBtn.transform.Find("Text").gameObject;
                txtObj.AddComponent<ContentSizeFitter>().horizontalFit = ContentSizeFitter.FitMode.PreferredSize;
            }

            // create core canvas 
            uiRoot = UIFactory.CreatePanel(Name, UIManager.PanelHolder, out uiContent);
            Rect = this.uiRoot.GetComponent<RectTransform>();
            //UIFactory.SetLayoutGroup<VerticalLayoutGroup>(this.uiRoot, false, false, true, true, 0, 2, 2, 2, 2, TextAnchor.UpperLeft);

            int id = this.uiRoot.transform.GetInstanceID();
            transformToPanelDict.Add(id, this);

            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(this.uiContent, false, false, true, true, 2, 2, 2, 2, 2, TextAnchor.UpperLeft);

            // Title bar
            TitleBar = UIFactory.CreateHorizontalGroup(uiContent, "TitleBar", false, true, true, true, 2,
                new Vector4(2, 2, 2, 2), new Color(0.06f, 0.06f, 0.06f));
            UIFactory.SetLayoutElement(TitleBar, minHeight: 25, flexibleHeight: 0);

            // Title text

            var titleTxt = UIFactory.CreateLabel(TitleBar, "TitleBar", Name, TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(titleTxt.gameObject, minWidth: 250, minHeight: 25, flexibleHeight: 0);

            // close button

            var closeHolder = UIFactory.CreateUIObject("CloseHolder", TitleBar);
            UIFactory.SetLayoutElement(closeHolder, minHeight: 25, flexibleHeight: 0, minWidth: 30, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(closeHolder, false, false, true, true, 3, childAlignment: TextAnchor.MiddleRight);
            var closeBtn = UIFactory.CreateButton(closeHolder, "CloseButton", "â€”");
            UIFactory.SetLayoutElement(closeBtn.Component.gameObject, minHeight: 25, minWidth: 25, flexibleWidth: 0);
            RuntimeHelper.SetColorBlock(closeBtn.Component, new Color(0.33f, 0.32f, 0.31f));

            closeBtn.OnClick += () =>
            {
                UIManager.SetPanelActive(this.PanelType, false);
                SaveInternalData();
            };

            if (!CanDragAndResize)
                TitleBar.SetActive(false);

            // Panel dragger

            Dragger = new PanelDragger(TitleBar.GetComponent<RectTransform>(), Rect, this);
            Dragger.OnFinishResize += OnFinishResize;
            Dragger.OnFinishDrag += OnFinishDrag;

            // content (abstract)

            ConstructPanelContent();

            UIManager.SetPanelActive(this.PanelType, true);
            UIManager.SetPanelActive(this.PanelType, false);
            UIManager.SetPanelActive(this.PanelType, ShowByDefault);

            ApplyingSaveData = true;
            SetTransformDefaults();
            // apply panel save data or revert to default
            try
            {
                ApplySaveData();
            }
            catch (Exception ex)
            {
                ExplorerCore.Log($"Exception loading panel save data: {ex}");
                SetTransformDefaults();
            }

            RuntimeHelper.StartCoroutine(LateSetupCoroutine());

            // simple listener for saving enabled state
            this.OnToggleEnabled += (bool val) =>
            {
                SaveInternalData();
            };

            ApplyingSaveData = false;
        }

        private IEnumerator LateSetupCoroutine()
        {
            yield return null;

            // ensure initialized position is valid
            EnsureValidSize();
            EnsureValidPosition(this.Rect);

            // update dragger and save data
            Dragger.OnEndResize();
        }

        public override void ConstructUI(GameObject parent) => ConstructUI();
    }

    #region WINDOW ANCHORS / POSITION HELPERS

    public static class RectSaveExtensions
    {
        // Window Anchors helpers

        internal static string RectAnchorsToString(this RectTransform rect)
        {
            if (!rect)
                throw new ArgumentNullException("rect");

            return string.Format(CultureInfo.InvariantCulture, "{0},{1},{2},{3}", new object[]
            {
                rect.anchorMin.x,
                rect.anchorMin.y,
                rect.anchorMax.x,
                rect.anchorMax.y
            });
        }

        internal static void SetAnchorsFromString(this RectTransform panel, string stringAnchors)
        {
            if (string.IsNullOrEmpty(stringAnchors))
                throw new ArgumentNullException("stringAnchors");

            if (stringAnchors.Contains(" "))
                // outdated save data, not worth recovering just reset it.
                throw new Exception("invalid save data, resetting.");

            var split = stringAnchors.Split(',');

            if (split.Length != 4)
                throw new Exception($"stringAnchors split is unexpected length: {split.Length}");

            Vector4 anchors;
            anchors.x = float.Parse(split[0], CultureInfo.InvariantCulture);
            anchors.y = float.Parse(split[1], CultureInfo.InvariantCulture);
            anchors.z = float.Parse(split[2], CultureInfo.InvariantCulture);
            anchors.w = float.Parse(split[3], CultureInfo.InvariantCulture);

            panel.anchorMin = new Vector2(anchors.x, anchors.y);
            panel.anchorMax = new Vector2(anchors.z, anchors.w);
        }

        internal static string RectPositionToString(this RectTransform rect)
        {
            if (!rect)
                throw new ArgumentNullException("rect");

            return string.Format(CultureInfo.InvariantCulture, "{0},{1}", new object[]
            {
                rect.anchoredPosition.x, rect.anchoredPosition.y
            });
        }

        internal static void SetPositionFromString(this RectTransform rect, string stringPosition)
        {
            if (string.IsNullOrEmpty(stringPosition))
                throw new ArgumentNullException(stringPosition);

            if (stringPosition.Contains(" "))
                // outdated save data, not worth recovering just reset it.
                throw new Exception("invalid save data, resetting.");

            var split = stringPosition.Split(',');

            if (split.Length != 2)
                throw new Exception($"stringPosition split is unexpected length: {split.Length}");

            Vector3 vector = rect.anchoredPosition;
            vector.x = float.Parse(split[0], CultureInfo.InvariantCulture);
            vector.y = float.Parse(split[1], CultureInfo.InvariantCulture);
            rect.anchoredPosition = vector;
        }
    }

    #endregion
}

```

`src/UI/Panels/UiInspectorResultsPanel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityExplorer.Inspectors.MouseInspectors;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ButtonList;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Panels
{
    public class UiInspectorResultsPanel : UIPanel
    {
        public override UIManager.Panels PanelType => UIManager.Panels.UIInspectorResults;

        public override string Name => "UI Inspector Results";

        public override int MinWidth => 500;
        public override int MinHeight => 500;
        public override bool CanDragAndResize => true;
        public override bool NavButtonWanted => false;
        public override bool ShouldSaveActiveState => false;
        public override bool ShowByDefault => false;

        private ButtonListHandler<GameObject, ButtonCell> dataHandler;
        private ScrollPool<ButtonCell> buttonScrollPool;

        public void ShowResults()
        {
            dataHandler.RefreshData();
            buttonScrollPool.Refresh(true, true);
        }

        private List<GameObject> GetEntries() => UiInspector.LastHitObjects;

        private bool ShouldDisplayCell(object cell, string filter) => true;

        private void OnCellClicked(int index)
        {
            if (index >= UiInspector.LastHitObjects.Count)
                return;

            InspectorManager.Inspect(UiInspector.LastHitObjects[index]);
        }

        private void SetCell(ButtonCell cell, int index)
        {
            if (index >= UiInspector.LastHitObjects.Count)
                return;

            var obj = UiInspector.LastHitObjects[index];
            cell.Button.ButtonText.text = $"<color=cyan>{obj.name}</color> ({obj.transform.GetTransformPath(true)})";
        }

        public override void ConstructPanelContent()
        {
            dataHandler = new ButtonListHandler<GameObject, ButtonCell>(buttonScrollPool, GetEntries, SetCell, ShouldDisplayCell, OnCellClicked);

            buttonScrollPool = UIFactory.CreateScrollPool<ButtonCell>(this.uiContent, "ResultsList", out GameObject scrollObj,
                out GameObject scrollContent);

            buttonScrollPool.Initialize(dataHandler);
            UIFactory.SetLayoutElement(scrollObj, flexibleHeight: 9999);
        }

        protected internal override void DoSetDefaultPosAndAnchors()
        {
            this.Rect.anchorMin = new Vector2(0.5f, 0.5f);
            this.Rect.anchorMax = new Vector2(0.5f, 0.5f);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 500f);
            this.Rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 500f);
        }
    }
}

```

`src/UI/UIManager.cs`:

```cs
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.CSConsole;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib;
using UniverseLib.Input;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI
{
    public static class UIManager
    {
        public enum Panels
        {
            ObjectExplorer,
            Inspector,
            CSConsole,
            Options,
            ConsoleLog,
            AutoCompleter,
            MouseInspector,
            UIInspectorResults,
            HookManager,
            Clipboard
        }

        public enum VerticalAnchor
        {
            Top,
            Bottom
        }

        public static VerticalAnchor NavbarAnchor = VerticalAnchor.Top;

        public static bool Initializing { get; internal set; } = true;

        internal static UIBase UiBase { get; private set; }
        public static GameObject UIRoot => UiBase?.RootObject;
        public static RectTransform UIRootRect { get; private set; }
        public static Canvas UICanvas { get; private set; }

        internal static GameObject PanelHolder { get; private set; }
        internal static readonly Dictionary<Panels, UIPanel> UIPanels = new();

        public static RectTransform NavBarRect;
        public static GameObject NavbarTabButtonHolder;
        private static readonly Vector2 NAVBAR_DIMENSIONS = new(1020f, 35f);

        private static ButtonRef closeBtn;
        private static ButtonRef pauseBtn;
        private static InputFieldRef timeInput;
        private static bool pauseButtonPausing;
        private static float lastTimeScale;

        private static int lastScreenWidth;
        private static int lastScreenHeight;

        public static bool ShowMenu
        {
            get => UiBase != null && UiBase.Enabled;
            set
            {
                if (UiBase == null || !UIRoot || UiBase.Enabled == value)
                    return;

                UniversalUI.SetUIActive(ExplorerCore.GUID, value);
                UniversalUI.SetUIActive(MouseInspector.UIBaseGUID, value);
            }
        }

        // Initialization

        internal static void InitUI()
        {
            UiBase = UniversalUI.RegisterUI(ExplorerCore.GUID, Update);

            UIRootRect = UIRoot.GetComponent<RectTransform>();
            UICanvas = UIRoot.GetComponent<Canvas>();

            DisplayManager.Init();

            Display display = DisplayManager.ActiveDisplay;
            lastScreenWidth = display.renderingWidth;
            lastScreenHeight = display.renderingHeight;

            // Create UI.
            CreatePanelHolder();
            CreateTopNavBar();
            // This could be automated with Assembly.GetTypes(),
            // but the order is important and I'd have to write something to handle the order.
            UIPanels.Add(Panels.AutoCompleter, new AutoCompleteModal());
            UIPanels.Add(Panels.ObjectExplorer, new ObjectExplorerPanel());
            UIPanels.Add(Panels.Inspector, new InspectorPanel());
            UIPanels.Add(Panels.CSConsole, new CSConsolePanel());
            UIPanels.Add(Panels.HookManager, new HookManagerPanel());
            UIPanels.Add(Panels.Clipboard, new ClipboardPanel());
            UIPanels.Add(Panels.ConsoleLog, new LogPanel());
            UIPanels.Add(Panels.Options, new OptionsPanel());
            UIPanels.Add(Panels.UIInspectorResults, new UiInspectorResultsPanel());
            UIPanels.Add(Panels.MouseInspector, new MouseInspector());

            foreach (var panel in UIPanels.Values)
                panel.ConstructUI();

            // Call some initialize methods
            Notification.Init();
            ConsoleController.Init();

            // Add this listener to prevent ScrollPool doing anything while we are resizing panels
            ScrollPool<ICell>.writingLockedListeners.Add(() => !PanelDragger.Resizing);

            // Set default menu visibility
            ShowMenu = !ConfigManager.Hide_On_Startup.Value;

            // Failsafe fix, in some games all dropdowns displayed values are blank on startup for some reason.
            foreach (var dropdown in UIRoot.GetComponentsInChildren<Dropdown>(true))
                dropdown.RefreshShownValue();

            Initializing = false;
        }

        // Main UI Update loop

        public static void Update()
        {
            if (!UIRoot)
                return;

            // If we are doing a Mouse Inspect, we don't need to update anything else.
            if (MouseInspector.Instance.TryUpdate())
                return;

            // Update Notification modal
            Notification.Update();

            // Check forceUnlockMouse toggle
            if (InputManager.GetKeyDown(ConfigManager.Force_Unlock_Toggle.Value))
                UniverseLib.Config.ConfigManager.Force_Unlock_Mouse = !UniverseLib.Config.ConfigManager.Force_Unlock_Mouse;

            // update focused panel
            UIPanel.UpdateFocus();
            PanelDragger.UpdateInstances();

            // update the timescale value
            if (!timeInput.Component.isFocused && lastTimeScale != Time.timeScale)
            {
                if (pauseButtonPausing && Time.timeScale != 0.0f)
                {
                    pauseButtonPausing = false;
                    OnPauseButtonToggled();
                }

                if (!pauseButtonPausing)
                {
                    timeInput.Text = Time.timeScale.ToString("F2");
                    lastTimeScale = Time.timeScale;
                }
            }

            // check screen dimension change
            var display = DisplayManager.ActiveDisplay;
            if (display.renderingWidth != lastScreenWidth || display.renderingHeight != lastScreenHeight)
                OnScreenDimensionsChanged();
        }

        // Panels

        public static UIPanel GetPanel(Panels panel) => UIPanels[panel];

        public static T GetPanel<T>(Panels panel) where T : UIPanel => (T)UIPanels[panel];

        public static void TogglePanel(Panels panel)
        {
            var uiPanel = GetPanel(panel);
            SetPanelActive(panel, !uiPanel.Enabled);
        }

        public static void SetPanelActive(Panels panelType, bool active)
        {
            GetPanel(panelType)
                .SetActive(active);
        }

        public static void SetPanelActive(UIPanel panel, bool active)
        {
            panel.SetActive(active);
        }

        internal static void SetPanelActive(Transform transform, bool value)
        {
            if (UIPanel.transformToPanelDict.TryGetValue(transform.GetInstanceID(), out UIPanel panel))
                panel.SetActive(value);
        }

        // navbar

        public static void SetNavBarAnchor()
        {
            switch (NavbarAnchor)
            {
                case VerticalAnchor.Top:
                    NavBarRect.anchorMin = new Vector2(0.5f, 1f);
                    NavBarRect.anchorMax = new Vector2(0.5f, 1f);
                    NavBarRect.anchoredPosition = new Vector2(NavBarRect.anchoredPosition.x, 0);
                    NavBarRect.sizeDelta = NAVBAR_DIMENSIONS;
                    break;

                case VerticalAnchor.Bottom:
                    NavBarRect.anchorMin = new Vector2(0.5f, 0f);
                    NavBarRect.anchorMax = new Vector2(0.5f, 0f);
                    NavBarRect.anchoredPosition = new Vector2(NavBarRect.anchoredPosition.x, 35);
                    NavBarRect.sizeDelta = NAVBAR_DIMENSIONS;
                    break;
            }
        }

        // listeners

        private static void OnScreenDimensionsChanged()
        {
            var display = DisplayManager.ActiveDisplay;
            lastScreenWidth = display.renderingWidth;
            lastScreenHeight = display.renderingHeight;

            foreach (var panel in UIPanels)
            {
                panel.Value.EnsureValidSize();
                UIPanel.EnsureValidPosition(panel.Value.Rect);
                panel.Value.Dragger.OnEndResize();
            }
        }

        private static void OnCloseButtonClicked()
        {
            ShowMenu = false;
        }

        private static void Master_Toggle_OnValueChanged(KeyCode val)
        {
            closeBtn.ButtonText.text = val.ToString();
        }

        // Time controls

        private static void OnTimeInputEndEdit(string val)
        {
            if (pauseButtonPausing)
                return;

            if (float.TryParse(val, out float f))
            {
                Time.timeScale = f;
                lastTimeScale = f;
            }

            timeInput.Text = Time.timeScale.ToString("F2");
        }

        private static void OnPauseButtonClicked()
        {
            pauseButtonPausing = !pauseButtonPausing;

            Time.timeScale = pauseButtonPausing ? 0f : lastTimeScale;

            OnPauseButtonToggled();
        }

        private static void OnPauseButtonToggled()
        {
            timeInput.Component.text = Time.timeScale.ToString("F2");
            timeInput.Component.readOnly = pauseButtonPausing;
            timeInput.Component.textComponent.color = pauseButtonPausing ? Color.grey : Color.white;

            Color color = pauseButtonPausing ? new Color(0.3f, 0.3f, 0.2f) : new Color(0.2f, 0.2f, 0.2f);
            RuntimeHelper.SetColorBlock(pauseBtn.Component, color, color * 1.2f, color * 0.7f);
            pauseBtn.ButtonText.text = pauseButtonPausing ? "â–º" : "||";
        }

        // UI Construction

        private static void CreatePanelHolder()
        {
            PanelHolder = new GameObject("PanelHolder");
            PanelHolder.transform.SetParent(UIRoot.transform, false);
            PanelHolder.layer = 5;
            var rect = PanelHolder.AddComponent<RectTransform>();
            rect.sizeDelta = Vector2.zero;
            rect.anchoredPosition = Vector2.zero;
            rect.pivot = new Vector2(0.5f, 0.5f);
            rect.anchorMin = Vector2.zero;
            rect.anchorMax = Vector2.one;
            PanelHolder.transform.SetAsFirstSibling();
        }

        private static void CreateTopNavBar()
        {
            var navbarPanel = UIFactory.CreateUIObject("MainNavbar", UIRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(navbarPanel, false, false, true, true, 5, 4, 4, 4, 4, TextAnchor.MiddleCenter);
            navbarPanel.AddComponent<Image>().color = new Color(0.1f, 0.1f, 0.1f);
            NavBarRect = navbarPanel.GetComponent<RectTransform>();
            NavBarRect.pivot = new Vector2(0.5f, 1f);

            NavbarAnchor = ConfigManager.Main_Navbar_Anchor.Value;
            SetNavBarAnchor();
            ConfigManager.Main_Navbar_Anchor.OnValueChanged += (VerticalAnchor val) =>
            {
                NavbarAnchor = val;
                SetNavBarAnchor();
            };

            // UnityExplorer title

            string titleTxt = $"{ExplorerCore.NAME} <i><color=grey>{ExplorerCore.VERSION}</color></i>";
            var title = UIFactory.CreateLabel(navbarPanel, "Title", titleTxt, TextAnchor.MiddleLeft, default, true, 17);
            UIFactory.SetLayoutElement(title.gameObject, minWidth: 170, flexibleWidth: 0);

            // panel tabs

            NavbarTabButtonHolder = UIFactory.CreateUIObject("NavTabButtonHolder", navbarPanel);
            UIFactory.SetLayoutElement(NavbarTabButtonHolder, minHeight: 25, flexibleHeight: 999, flexibleWidth: 999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(NavbarTabButtonHolder, false, true, true, true, 4, 2, 2, 2, 2);

            // Time controls

            var timeLabel = UIFactory.CreateLabel(navbarPanel, "TimeLabel", "Time:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(timeLabel.gameObject, minHeight: 25, minWidth: 50);

            timeInput = UIFactory.CreateInputField(navbarPanel, "TimeInput", "timeScale");
            UIFactory.SetLayoutElement(timeInput.Component.gameObject, minHeight: 25, minWidth: 40);
            timeInput.Component.GetOnEndEdit().AddListener(OnTimeInputEndEdit);

            timeInput.Text = string.Empty;
            timeInput.Text = Time.timeScale.ToString();

            pauseBtn = UIFactory.CreateButton(navbarPanel, "PauseButton", "||", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(pauseBtn.Component.gameObject, minHeight: 25, minWidth: 25);
            pauseBtn.OnClick += OnPauseButtonClicked;

            // Hide menu button

            closeBtn = UIFactory.CreateButton(navbarPanel, "CloseButton", ConfigManager.Master_Toggle.Value.ToString());
            UIFactory.SetLayoutElement(closeBtn.Component.gameObject, minHeight: 25, minWidth: 80, flexibleWidth: 0);
            RuntimeHelper.SetColorBlock(closeBtn.Component, new Color(0.63f, 0.32f, 0.31f),
                new Color(0.81f, 0.25f, 0.2f), new Color(0.6f, 0.18f, 0.16f));

            ConfigManager.Master_Toggle.OnValueChanged += Master_Toggle_OnValueChanged;
            closeBtn.OnClick += OnCloseButtonClicked;
        }
    }
}

```

`src/UI/Widgets/AutoComplete/EnumCompleter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using UnityExplorer.CacheObject.IValues;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public class EnumCompleter : ISuggestionProvider
    {
        public bool Enabled
        {
            get => _enabled;
            set
            {
                _enabled = value;
                if (!_enabled)
                    AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
        }
        private bool _enabled = true;

        public event Action<Suggestion> SuggestionClicked;

        public Type EnumType { get; set; }

        public InputFieldRef InputField { get; }
        public bool AnchorToCaretPosition => false;

        private readonly List<Suggestion> suggestions = new List<Suggestion>();
        private readonly HashSet<string> suggestedValues = new HashSet<string>();

        private OrderedDictionary enumValues;

        internal string chosenSuggestion;

        bool ISuggestionProvider.AllowNavigation => false;

        public EnumCompleter(Type enumType, InputFieldRef inputField)
        {
            EnumType = enumType;
            InputField = inputField;

            inputField.OnValueChanged += OnInputFieldChanged;

            if (EnumType != null)
                CacheEnumValues();
        }

        public void CacheEnumValues()
        {
            enumValues = InteractiveEnum.GetEnumValues(EnumType);
        }

        private string GetLastSplitInput(string fullInput)
        {
            string ret = fullInput;
            
            int lastSplit = fullInput.LastIndexOf(',');
            if (lastSplit >= 0)
            {
                lastSplit++;
                if (lastSplit == fullInput.Length)
                    ret = "";
                else
                    ret = fullInput.Substring(lastSplit);
            }

            return ret;
        }

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            chosenSuggestion = suggestion.UnderlyingValue;

            string lastInput = GetLastSplitInput(InputField.Text);

            if (lastInput != suggestion.UnderlyingValue)
            {
                string valueToSet = InputField.Text;

                if (valueToSet.Length > 0)
                    valueToSet = valueToSet.Substring(0, InputField.Text.Length - lastInput.Length);

                valueToSet += suggestion.UnderlyingValue;

                InputField.Text = valueToSet;

                //InputField.Text += suggestion.UnderlyingValue.Substring(lastInput.Length);
            }

            SuggestionClicked?.Invoke(suggestion);

            suggestions.Clear();
            AutoCompleteModal.Instance.SetSuggestions(suggestions);
        }

        public void HelperButtonClicked()
        {
            GetSuggestions("");
            AutoCompleteModal.Instance.TakeOwnership(this);
            AutoCompleteModal.Instance.SetSuggestions(suggestions);
        }

        private void OnInputFieldChanged(string value)
        {
            if (!Enabled)
                return;

            if (string.IsNullOrEmpty(value) || GetLastSplitInput(value) == chosenSuggestion)
            {
                chosenSuggestion = null;
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
            else
            {
                GetSuggestions(value);

                AutoCompleteModal.Instance.TakeOwnership(this);
                AutoCompleteModal.Instance.SetSuggestions(suggestions);
            }
        }

        private void GetSuggestions(string value)
        {
            suggestions.Clear();
            suggestedValues.Clear();

            if (EnumType == null)
            {
                ExplorerCore.LogWarning("Autocompleter Base enum type is null!");
                return;
            }

            value = GetLastSplitInput(value);

            for (int i = 0; i < this.enumValues.Count; i++)
            {
                var enumValue = (CachedEnumValue)enumValues[i];
                if (enumValue.Name.ContainsIgnoreCase(value))
                    AddSuggestion(enumValue.Name);
            }
        }

        internal static readonly Dictionary<string, string> sharedValueToLabel = new Dictionary<string, string>(4096);

        void AddSuggestion(string value)
        {
            if (suggestedValues.Contains(value))
                return;
            suggestedValues.Add(value);

            if (!sharedValueToLabel.ContainsKey(value))
                sharedValueToLabel.Add(value, $"<color={SignatureHighlighter.CONST}>{value}</color>");

            suggestions.Add(new Suggestion(sharedValueToLabel[value], value));
        }
    }
}

```

`src/UI/Widgets/AutoComplete/ISuggestionProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UniverseLib.UI;
using UniverseLib.UI.Models;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public interface ISuggestionProvider
    {
        InputFieldRef InputField { get; }
        bool AnchorToCaretPosition { get; }

        bool AllowNavigation { get; }

        void OnSuggestionClicked(Suggestion suggestion);
    }
}

```

`src/UI/Widgets/AutoComplete/Suggestion.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public struct Suggestion
    {
        public readonly string DisplayText;
        public readonly string UnderlyingValue;

        public Suggestion(string displayText, string underlyingValue)
        {
            DisplayText = displayText;
            UnderlyingValue = underlyingValue;
        }
    }
}

```

`src/UI/Widgets/AutoComplete/TypeCompleter.cs`:

```cs
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets.AutoComplete
{
    public class TypeCompleter : ISuggestionProvider
    {
        public bool Enabled
        {
            get => _enabled;
            set
            {
                _enabled = value;
                if (!_enabled)
                    AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
        }
        private bool _enabled = true;

        public event Action<Suggestion> SuggestionClicked;

        public Type BaseType { get; set; }
        public Type[] GenericConstraints { get; set; }
        public bool AllTypes { get; set; }

        private readonly bool allowAbstract;
        private readonly bool allowEnum;

        public InputFieldRef InputField { get; }
        public bool AnchorToCaretPosition => false;

        private readonly List<Suggestion> suggestions = new();
        private readonly HashSet<string> suggestedNames = new();

        private HashSet<Type> allowedTypes;

        private string chosenSuggestion;

        bool ISuggestionProvider.AllowNavigation => false;

        public TypeCompleter(Type baseType, InputFieldRef inputField) : this(baseType, inputField, true, true) { }

        public TypeCompleter(Type baseType, InputFieldRef inputField, bool allowAbstract, bool allowEnum)
        {
            BaseType = baseType;
            InputField = inputField;

            this.allowAbstract = allowAbstract;
            this.allowEnum = allowEnum;

            inputField.OnValueChanged += OnInputFieldChanged;

            if (BaseType != null)
                CacheTypes();
        }

        public void CacheTypes()
        {
            if (!AllTypes)
                allowedTypes = ReflectionUtility.GetImplementationsOf(BaseType, allowAbstract, allowEnum, false);
            else
            {
                allowedTypes = new();
                foreach (var entry in ReflectionUtility.AllTypes)
                {
                    // skip <PrivateImplementationDetails> and <AnonymousClass> classes
                    var type = entry.Value;
                    if (type.FullName.Contains("PrivateImplementationDetails")
                             || type.FullName.Contains("DisplayClass")
                             || type.FullName.Contains('<'))
                    {
                        continue;
                    }
                    allowedTypes.Add(type);
                }
            }
        }

        public void OnSuggestionClicked(Suggestion suggestion)
        {
            InputField.Text = suggestion.UnderlyingValue;
            SuggestionClicked?.Invoke(suggestion);

            suggestions.Clear();
            AutoCompleteModal.Instance.SetSuggestions(suggestions);
            chosenSuggestion = suggestion.UnderlyingValue;
        }

        private void OnInputFieldChanged(string value)
        {
            if (!Enabled)
                return;

            if (string.IsNullOrEmpty(value) || value == chosenSuggestion)
            {
                chosenSuggestion = null;
                AutoCompleteModal.Instance.ReleaseOwnership(this);
            }
            else
            {
                GetSuggestions(value);

                AutoCompleteModal.Instance.TakeOwnership(this);
                AutoCompleteModal.Instance.SetSuggestions(suggestions);
            }
        }

        private void GetSuggestions(string value)
        {
            suggestions.Clear();
            suggestedNames.Clear();

            if (BaseType == null)
            {
                ExplorerCore.LogWarning("Autocompleter Base type is null!");
                return;
            }

            // Check for exact match first
            if (ReflectionUtility.GetTypeByName(value) is Type t && allowedTypes.Contains(t))
                AddSuggestion(t);

            foreach (var entry in allowedTypes)
            {
                if (entry.FullName.ContainsIgnoreCase(value))
                    AddSuggestion(entry);
            }
        }

        internal static readonly Dictionary<string, string> sharedTypeToLabel = new();

        void AddSuggestion(Type type)
        {
            if (suggestedNames.Contains(type.FullName))
                return;
            suggestedNames.Add(type.FullName);

            if (!sharedTypeToLabel.ContainsKey(type.FullName))
                sharedTypeToLabel.Add(type.FullName, SignatureHighlighter.Parse(type, true));

            suggestions.Add(new Suggestion(sharedTypeToLabel[type.FullName], type.FullName));
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/BaseArgumentHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public abstract class BaseArgumentHandler : IPooledObject
    {
        protected EvaluateWidget evaluator;

        internal Text argNameLabel;
        internal InputFieldRef inputField;
        internal TypeCompleter typeCompleter;

        // IPooledObject
        public float DefaultHeight => 25f;
        public GameObject UIRoot { get; set; }

        public abstract void CreateSpecialContent();

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject("ArgRow", parent);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 50, flexibleWidth: 9999);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5);
            UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            argNameLabel = UIFactory.CreateLabel(UIRoot, "ArgLabel", "not set", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(argNameLabel.gameObject, minWidth: 40, flexibleWidth: 90, minHeight: 25, flexibleHeight: 50);
            argNameLabel.horizontalOverflow = HorizontalWrapMode.Wrap;

            inputField = UIFactory.CreateInputField(UIRoot, "InputField", "...");
            UIFactory.SetLayoutElement(inputField.UIRoot, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            inputField.Component.lineType = InputField.LineType.MultiLineNewline;
            inputField.UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            typeCompleter = new TypeCompleter(typeof(object), this.inputField);
            typeCompleter.Enabled = false;

            CreateSpecialContent();

            return UIRoot;
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/EvaluateWidget.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.UI;
using UniverseLib.UI.Models;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib.UI;
using UniverseLib;
using UnityExplorer.CacheObject;
using UniverseLib.UI.ObjectPool;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class EvaluateWidget : IPooledObject
    {
        public CacheMember Owner { get; set; }

        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1f;

        private ParameterInfo[] parameters;
        internal GameObject parametersHolder;
        private ParameterHandler[] paramHandlers;

        private Type[] genericArguments;
        internal GameObject genericArgumentsHolder;
        private GenericArgumentHandler[] genericHandlers;

        public void OnBorrowedFromPool(CacheMember owner)
        {
            this.Owner = owner;

            parameters = owner.Arguments;
            paramHandlers = new ParameterHandler[parameters.Length];

            genericArguments = owner.GenericArguments;
            genericHandlers = new GenericArgumentHandler[genericArguments.Length];

            SetArgRows();

            this.UIRoot.SetActive(true);
        }

        public void OnReturnToPool()
        {
            foreach (var widget in paramHandlers)
            {
                widget.OnReturned();
                Pool<ParameterHandler>.Return(widget);
            }
            paramHandlers = null;

            foreach (var widget in genericHandlers)
            {
                widget.OnReturned();
                Pool<GenericArgumentHandler>.Return(widget);
            }
            genericHandlers = null;

            this.Owner = null;
        }

        public Type[] TryParseGenericArguments()
        {
            Type[] outArgs = new Type[genericArguments.Length];

            for (int i = 0; i < genericArguments.Length; i++)
                outArgs[i] = genericHandlers[i].Evaluate();

            return outArgs;
        }

        public object[] TryParseArguments()
        {
            if (!parameters.Any())
                return ArgumentUtility.EmptyArgs;

            object[] outArgs = new object[parameters.Length];

            for (int i = 0; i < parameters.Length; i++)
                outArgs[i] = paramHandlers[i].Evaluate();

            return outArgs;
        }

        private void SetArgRows()
        {
            if (genericArguments.Any())
            {
                genericArgumentsHolder.SetActive(true);
                SetGenericRows();
            }
            else
                genericArgumentsHolder.SetActive(false);

            if (parameters.Any())
            {
                parametersHolder.SetActive(true);
                SetNormalArgRows();
            }
            else
                parametersHolder.SetActive(false);
        }

        private void SetGenericRows()
        {
            for (int i = 0; i < genericArguments.Length; i++)
            {
                var type = genericArguments[i];

                var holder = genericHandlers[i] = Pool<GenericArgumentHandler>.Borrow();
                holder.UIRoot.transform.SetParent(this.genericArgumentsHolder.transform, false);
                holder.OnBorrowed(this, type);
            }
        }

        private void SetNormalArgRows()
        {
            for (int i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];

                var holder = paramHandlers[i] = Pool<ParameterHandler>.Borrow();
                holder.UIRoot.transform.SetParent(this.parametersHolder.transform, false);
                holder.OnBorrowed(this, param);
            }
        }


        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateVerticalGroup(parent, "EvaluateWidget", false, false, true, true, 3, new Vector4(2, 2, 2, 2),
                new Color(0.15f, 0.15f, 0.15f));
            UIFactory.SetLayoutElement(UIRoot, minWidth: 50, flexibleWidth: 9999, minHeight: 50, flexibleHeight: 800);
            //UIRoot.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // generic args
            this.genericArgumentsHolder = UIFactory.CreateUIObject("GenericHolder", UIRoot);
            UIFactory.SetLayoutElement(genericArgumentsHolder, flexibleWidth: 1000);
            var genericsTitle = UIFactory.CreateLabel(genericArgumentsHolder, "GenericsTitle", "Generic Arguments", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(genericsTitle.gameObject, minHeight: 25, flexibleWidth: 1000);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(genericArgumentsHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(genericArgumentsHolder, minHeight: 25, flexibleHeight: 750, minWidth: 50, flexibleWidth: 9999);
            //genericArgHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // args
            this.parametersHolder = UIFactory.CreateUIObject("ArgHolder", UIRoot);
            UIFactory.SetLayoutElement(parametersHolder, flexibleWidth: 1000);
            var argsTitle = UIFactory.CreateLabel(parametersHolder, "ArgsTitle", "Arguments", TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(argsTitle.gameObject, minHeight: 25, flexibleWidth: 1000);
            UIFactory.SetLayoutGroup<VerticalLayoutGroup>(parametersHolder, false, false, true, true, 3);
            UIFactory.SetLayoutElement(parametersHolder, minHeight: 25, flexibleHeight: 750, minWidth: 50, flexibleWidth: 9999);
            //argHolder.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            // evaluate button
            var evalButton = UIFactory.CreateButton(UIRoot, "EvaluateButton", "Evaluate", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(evalButton.Component.gameObject, minHeight: 25, minWidth: 150, flexibleWidth: 0);
            evalButton.OnClick += () =>
            {
                Owner.EvaluateAndSetCell();
            };

            return UIRoot;
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/GenericArgumentHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UniverseLib;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class GenericArgumentHandler : BaseArgumentHandler
    {
        private Type genericType;

        public void OnBorrowed(EvaluateWidget evaluator, Type genericConstraint)
        {
            this.evaluator = evaluator;
            this.genericType = genericConstraint;

            typeCompleter.Enabled = true;
            typeCompleter.BaseType = genericType;
            typeCompleter.CacheTypes();

            var constraints = genericType.GetGenericParameterConstraints();
            typeCompleter.GenericConstraints = constraints;

            var sb = new StringBuilder($"<color={SignatureHighlighter.CONST}>{genericType.Name}</color>");

            for (int j = 0; j < constraints.Length; j++)
            {
                if (j == 0) sb.Append(' ').Append('(');
                else sb.Append(',').Append(' ');

                sb.Append(SignatureHighlighter.Parse(constraints[j], false));

                if (j + 1 == constraints.Length)
                    sb.Append(')');
            }

            argNameLabel.text = sb.ToString();
        }

        public void OnReturned()
        {
            this.evaluator = null;
            this.genericType = null;

            this.typeCompleter.Enabled = false;

            this.inputField.Text = "";
        }

        public Type Evaluate()
        {
            return ReflectionUtility.GetTypeByName(this.inputField.Text)
                    ?? throw new Exception($"Could not find any type by name '{this.inputField.Text}'!");
        }

        public override void CreateSpecialContent()
        {
        }
    }
}

```

`src/UI/Widgets/EvaluateWidget/ParameterHandler.cs`:

```cs
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.CacheObject.IValues;
using UnityExplorer.UI.Panels;
using UnityExplorer.UI.Widgets.AutoComplete;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class ParameterHandler : BaseArgumentHandler
    {
        private ParameterInfo paramInfo;
        private Type paramType;

        internal EnumCompleter enumCompleter;
        private ButtonRef enumHelperButton;

        private bool usingBasicLabel;
        private object basicValue;
        private GameObject basicLabelHolder;
        private Text basicLabel;
        private ButtonRef pasteButton;

        public void OnBorrowed(EvaluateWidget evaluator, ParameterInfo paramInfo)
        {
            this.evaluator = evaluator;
            this.paramInfo = paramInfo;

            this.paramType = paramInfo.ParameterType;
            if (paramType.IsByRef)
                paramType = paramType.GetElementType();

            this.argNameLabel.text = 
                $"{SignatureHighlighter.Parse(paramType, false)} <color={SignatureHighlighter.LOCAL_ARG}>{paramInfo.Name}</color>";

            if (ParseUtility.CanParse(paramType) || typeof(Type).IsAssignableFrom(paramType))
            {
                usingBasicLabel = false;

                this.inputField.Component.gameObject.SetActive(true);
                this.basicLabelHolder.SetActive(false);
                this.typeCompleter.Enabled = typeof(Type).IsAssignableFrom(paramType);
                this.enumCompleter.Enabled = paramType.IsEnum;
                this.enumHelperButton.Component.gameObject.SetActive(paramType.IsEnum);

                if (!typeCompleter.Enabled)
                {
                    if (paramType == typeof(string))
                        inputField.PlaceholderText.text = "...";
                    else
                        inputField.PlaceholderText.text = $"eg. {ParseUtility.GetExampleInput(paramType)}";
                }
                else
                {
                    inputField.PlaceholderText.text = "Enter a Type name...";
                    this.typeCompleter.BaseType = typeof(object);
                    this.typeCompleter.CacheTypes();
                }

                if (enumCompleter.Enabled)
                {
                    enumCompleter.EnumType = paramType;
                    enumCompleter.CacheEnumValues();
                }
            }
            else
            {
                // non-parsable, and not a Type
                usingBasicLabel = true;

                this.inputField.Component.gameObject.SetActive(false);
                this.basicLabelHolder.SetActive(true);
                this.typeCompleter.Enabled = false;
                this.enumCompleter.Enabled = false;
                this.enumHelperButton.Component.gameObject.SetActive(false);

                SetDisplayedValueFromPaste();
            }
        }

        public void OnReturned()
        {
            this.evaluator = null;
            this.paramInfo = null;

            this.enumCompleter.Enabled = false;
            this.typeCompleter.Enabled = false;

            this.inputField.Text = "";

            this.usingBasicLabel = false;
            this.basicValue = null;
        }

        public object Evaluate()
        {
            if (usingBasicLabel)
                return basicValue;

            var input = this.inputField.Text;

            if (typeof(Type).IsAssignableFrom(paramType))
                return ReflectionUtility.GetTypeByName(input);

            if (paramType == typeof(string))
                return input;

            if (string.IsNullOrEmpty(input))
            {
                if (paramInfo.IsOptional)
                    return paramInfo.DefaultValue;
                else
                    return null;
            }

            if (!ParseUtility.TryParse(input, paramType, out object parsed, out Exception ex))
            {
                ExplorerCore.LogWarning($"Cannot parse argument '{paramInfo.Name}' ({paramInfo.ParameterType.Name})" +
                    $"{(ex == null ? "" : $", {ex.GetType().Name}: {ex.Message}")}");
                return null;
            }
            else
                return parsed;
        }

        private void OnPasteClicked()
        {
            if (ClipboardPanel.TryPaste(this.paramType, out object paste))
            {
                basicValue = paste;
                SetDisplayedValueFromPaste();
            }
        }

        private void SetDisplayedValueFromPaste()
        {
            if (usingBasicLabel)
                basicLabel.text = ToStringUtility.ToStringWithType(basicValue, paramType, false);
            else
            {
                if (typeof(Type).IsAssignableFrom(paramType))
                    inputField.Text = (basicValue as Type).FullDescription();
                else
                    inputField.Text = ParseUtility.ToStringForInput(basicValue, paramType);
            }
        }

        public override void CreateSpecialContent()
        {
            enumCompleter = new(paramType, this.inputField)
            {
                Enabled = false
            };

            enumHelperButton = UIFactory.CreateButton(UIRoot, "EnumHelper", "â–¼");
            UIFactory.SetLayoutElement(enumHelperButton.Component.gameObject, minWidth: 25, minHeight: 25, flexibleWidth: 0, flexibleHeight: 0);
            enumHelperButton.OnClick += enumCompleter.HelperButtonClicked;

            basicLabelHolder = UIFactory.CreateHorizontalGroup(UIRoot, "BasicLabelHolder", true, true, true, true, bgColor: new(0.1f, 0.1f, 0.1f));
            UIFactory.SetLayoutElement(basicLabelHolder, minHeight: 25, flexibleHeight: 50, minWidth: 100, flexibleWidth: 1000);
            basicLabel = UIFactory.CreateLabel(basicLabelHolder, "BasicLabel", "null", TextAnchor.MiddleLeft);
            basicLabel.gameObject.AddComponent<ContentSizeFitter>().verticalFit = ContentSizeFitter.FitMode.PreferredSize;

            pasteButton = UIFactory.CreateButton(UIRoot, "PasteButton", "Paste", new Color(0.13f, 0.13f, 0.13f, 1f));
            UIFactory.SetLayoutElement(pasteButton.Component.gameObject, minHeight: 25, minWidth: 28, flexibleWidth: 0);
            pasteButton.ButtonText.color = Color.green;
            pasteButton.ButtonText.fontSize = 10;
            pasteButton.OnClick += OnPasteClicked;
        }
    }
}

```

`src/UI/Widgets/TransformTree/CachedTransform.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace UnityExplorer.UI.Widgets
{
    public class CachedTransform
    {
        public TransformTree Tree { get; }
        public Transform Value { get; private set; }
        public int InstanceID { get; private set; }
        public CachedTransform Parent { get; internal set; }

        public int Depth { get; internal set; }
        public int ChildCount { get; internal set; }
        public string Name { get; internal set; }
        public bool Enabled { get; internal set; }
        public int SiblingIndex { get; internal set; }

        public bool Expanded => Tree.IsTransformExpanded(InstanceID);

        public CachedTransform(TransformTree tree, Transform transform, int depth, CachedTransform parent = null)
        {
            Tree = tree;
            Value = transform;
            Parent = parent;
            InstanceID = transform.GetInstanceID();
            SiblingIndex = transform.GetSiblingIndex();
            Update(transform, depth);
        }

        public bool Update(Transform transform, int depth)
        {
            bool changed = false;

            if (Value != transform
                || depth != Depth
                || ChildCount != transform.childCount
                || Name != transform.name
                || Enabled != transform.gameObject.activeSelf
                || SiblingIndex != transform.GetSiblingIndex())
            {
                changed = true;

                Value = transform;
                Depth = depth;
                ChildCount = transform.childCount;
                Name = transform.name;
                Enabled = transform.gameObject.activeSelf;
                SiblingIndex = transform.GetSiblingIndex();
            }

            return changed;
        }
    }
}

```

`src/UI/Widgets/TransformTree/TransformCell.cs`:

```cs
using HarmonyLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Widgets;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.Widgets;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class TransformCell : ICell
    {
        public float DefaultHeight => 25f;

        public bool Enabled => enabled;
        private bool enabled;

        public Action<CachedTransform> OnExpandToggled;
        public Action<CachedTransform> OnEnableToggled;
        public Action<GameObject> OnGameObjectClicked;

        public CachedTransform cachedTransform;
        public int cellIndex;

        public GameObject UIRoot { get; set; }
        public RectTransform Rect { get; set; }

        public ButtonRef ExpandButton;
        public ButtonRef NameButton;
        public Toggle EnabledToggle;
        public InputFieldRef SiblingIndex;

        public LayoutElement spacer;

        public void Enable()
        {
            enabled = true;
            UIRoot.SetActive(true);
        }

        public void Disable()
        {
            enabled = false;
            UIRoot.SetActive(false);
        }

        public void ConfigureCell(CachedTransform cached, int cellIndex)
        {
            if (cached == null)
            {
                ExplorerCore.LogWarning("Setting TransformTree cell but the CachedTransform is null!");
                return;
            }

            if (!Enabled)
                Enable();

            this.cellIndex = cellIndex;
            cachedTransform = cached;

            spacer.minWidth = cached.Depth * 15;

            if (cached.Value)
            {
                string name = cached.Value.name?.Trim();
                if (string.IsNullOrEmpty(name))
                    name = "<i><color=grey>untitled</color></i>";
                NameButton.ButtonText.text = name;
                NameButton.ButtonText.color = cached.Value.gameObject.activeSelf ? Color.white : Color.grey;

                EnabledToggle.Set(cached.Value.gameObject.activeSelf, false);

                if (!cached.Value.parent)
                    SiblingIndex.GameObject.SetActive(false);
                else
                {
                    SiblingIndex.GameObject.SetActive(true);
                    if (!SiblingIndex.Component.isFocused)
                        SiblingIndex.Text = cached.Value.GetSiblingIndex().ToString();
                }

                int childCount = cached.Value.childCount;
                if (childCount > 0)
                {
                    NameButton.ButtonText.text = $"<color=grey>[{childCount}]</color> {NameButton.ButtonText.text}";

                    ExpandButton.Component.interactable = true;
                    ExpandButton.ButtonText.text = cached.Expanded ? "â–¼" : "â–º";
                    ExpandButton.ButtonText.color = cached.Expanded ? new Color(0.5f, 0.5f, 0.5f) : new Color(0.3f, 0.3f, 0.3f);
                }
                else
                {
                    ExpandButton.Component.interactable = false;
                    ExpandButton.ButtonText.text = "â–ª";
                    ExpandButton.ButtonText.color = new Color(0.3f, 0.3f, 0.3f);
                }
            }
            else
            {
                NameButton.ButtonText.text = $"[Destroyed]";
                NameButton.ButtonText.color = Color.red;

                SiblingIndex.GameObject.SetActive(false);
            }
        }

        public void OnMainButtonClicked()
        {
            if (cachedTransform.Value)
                OnGameObjectClicked?.Invoke(cachedTransform.Value.gameObject);
            else
                ExplorerCore.LogWarning("The object was destroyed!");
        }

        public void OnExpandClicked()
        {
            OnExpandToggled?.Invoke(cachedTransform);
        }

        private void OnEnableClicked(bool value)
        {
            OnEnableToggled?.Invoke(cachedTransform);
        }

        private void OnSiblingIndexEndEdit(string input)
        {
            if (this.cachedTransform == null || !this.cachedTransform.Value)
                return;

            if (int.TryParse(input.Trim(), out int index))
                this.cachedTransform.Value.SetSiblingIndex(index);
            
            this.SiblingIndex.Text = this.cachedTransform.Value.GetSiblingIndex().ToString();
        }

        public GameObject CreateContent(GameObject parent)
        {
            UIRoot = UIFactory.CreateUIObject("TransformCell", parent);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 2, childAlignment: TextAnchor.MiddleCenter);
            Rect = UIRoot.GetComponent<RectTransform>();
            Rect.anchorMin = new Vector2(0, 1);
            Rect.anchorMax = new Vector2(0, 1);
            Rect.pivot = new Vector2(0.5f, 1);
            Rect.sizeDelta = new Vector2(25, 25);
            UIFactory.SetLayoutElement(UIRoot, minWidth: 100, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 0);

            GameObject spacerObj = UIFactory.CreateUIObject("Spacer", UIRoot, new Vector2(0, 0));
            UIFactory.SetLayoutElement(spacerObj, minWidth: 0, flexibleWidth: 0, minHeight: 0, flexibleHeight: 0);
            this.spacer = spacerObj.GetComponent<LayoutElement>();

            // Expand arrow

            ExpandButton = UIFactory.CreateButton(this.UIRoot, "ExpandButton", "â–º");
            UIFactory.SetLayoutElement(ExpandButton.Component.gameObject, minWidth: 15, flexibleWidth: 0, minHeight: 25, flexibleHeight: 0);

            // Enabled toggle

            GameObject toggleObj = UIFactory.CreateToggle(UIRoot, "BehaviourToggle", out EnabledToggle, out Text behavText, default, 17, 17);
            UIFactory.SetLayoutElement(toggleObj, minHeight: 17, flexibleHeight: 0, minWidth: 17);
            EnabledToggle.onValueChanged.AddListener(OnEnableClicked);

            // Name button

            GameObject nameBtnHolder = UIFactory.CreateHorizontalGroup(this.UIRoot, "NameButtonHolder", 
                false, false, true, true, childAlignment: TextAnchor.MiddleLeft);
            UIFactory.SetLayoutElement(nameBtnHolder, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 0);
            nameBtnHolder.AddComponent<Mask>().showMaskGraphic = false;

            NameButton = UIFactory.CreateButton(nameBtnHolder, "NameButton", "Name", null);
            UIFactory.SetLayoutElement(NameButton.Component.gameObject, flexibleWidth: 9999, minHeight: 25, flexibleHeight: 0);
            Text nameLabel = NameButton.Component.GetComponentInChildren<Text>();
            nameLabel.horizontalOverflow = HorizontalWrapMode.Overflow;
            nameLabel.alignment = TextAnchor.MiddleLeft;

            // Sibling index input

            SiblingIndex = UIFactory.CreateInputField(this.UIRoot, "SiblingIndexInput", string.Empty);
            SiblingIndex.Component.textComponent.fontSize = 11;
            SiblingIndex.Component.textComponent.alignment = TextAnchor.MiddleRight;
            Image siblingImage = SiblingIndex.GameObject.GetComponent<Image>();
            siblingImage.color = new(0f, 0f, 0f, 0.25f);
            UIFactory.SetLayoutElement(SiblingIndex.GameObject, 35, 20, 0, 0);
            SiblingIndex.Component.GetOnEndEdit().AddListener(OnSiblingIndexEndEdit);

            // Setup selectables

            Color normal = new(0.11f, 0.11f, 0.11f);
            Color highlight = new(0.25f, 0.25f, 0.25f);
            Color pressed = new(0.05f, 0.05f, 0.05f);
            Color disabled = new(1, 1, 1, 0);
            RuntimeHelper.SetColorBlock(ExpandButton.Component, normal, highlight, pressed, disabled);
            RuntimeHelper.SetColorBlock(NameButton.Component, normal, highlight, pressed, disabled);

            NameButton.OnClick += OnMainButtonClicked;
            ExpandButton.OnClick += OnExpandClicked;

            UIRoot.SetActive(false);

            return this.UIRoot;
        }
    }
}

```

`src/UI/Widgets/TransformTree/TransformTree.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using UnityEngine;
using UniverseLib;
using UniverseLib.UI.Widgets.ScrollView;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class TransformTree : ICellPoolDataSource<TransformCell>
    {
        public Func<IEnumerable<GameObject>> GetRootEntriesMethod;
        public Action<GameObject> OnClickOverrideHandler;

        public ScrollPool<TransformCell> ScrollPool;

        // IMPORTANT CAVEAT WITH OrderedDictionary:
        // While the performance is mostly good, there are two methods we should NEVER use:
        // - Remove(object)
        // - set_Item[object]
        // These two methods have extremely bad performance due to using IndexOfKey(), which iterates the whole dictionary.
        // Currently we do not use either of these methods, so everything should be constant time hash lookups.
        // We DO make use of get_Item[object], get_Item[index], Add, Insert and RemoveAt, which OrderedDictionary perfectly meets our needs for.
        /// <summary>
        /// Key: UnityEngine.Transform instance ID<br/>
        /// Value: CachedTransform
        /// </summary>
        internal readonly OrderedDictionary cachedTransforms = new();

        // for keeping track of which actual transforms are expanded or not, outside of the cache data.
        private readonly HashSet<int> expandedInstanceIDs = new();
        private readonly HashSet<int> autoExpandedIDs = new();

        // state for Traverse parse
        private readonly HashSet<int> visited = new();
        private bool needRefreshUI;
        private int displayIndex;
        int prevDisplayIndex;

        private Coroutine refreshCoroutine;
        private readonly Stopwatch traversedThisFrame = new();

        // ScrollPool item count. PrevDisplayIndex is the highest index + 1 from our last traverse.
        public int ItemCount => prevDisplayIndex;

        // Search filter
        public bool Filtering => !string.IsNullOrEmpty(currentFilter);
        private bool wasFiltering;

        public string CurrentFilter
        {
            get => currentFilter;
            set
            {
                currentFilter = value ?? "";
                if (!wasFiltering && Filtering)
                    wasFiltering = true;
                else if (wasFiltering && !Filtering)
                {
                    wasFiltering = false;
                    autoExpandedIDs.Clear();
                }
            }
        }
        private string currentFilter;

        public TransformTree(ScrollPool<TransformCell> scrollPool, Func<IEnumerable<GameObject>> getRootEntriesMethod)
        {
            ScrollPool = scrollPool;
            GetRootEntriesMethod = getRootEntriesMethod;
        }

        // Initialize and reset

        // Must be called externally from owner of this TransformTree
        public void Init()
        {
            ScrollPool.Initialize(this);
        }

        // Called to completely reset the tree, ie. switching inspected GameObject
        public void Rebuild()
        {
            autoExpandedIDs.Clear();
            expandedInstanceIDs.Clear();

            RefreshData(true, true, true, false);
        }

        // Called to completely wipe our data (ie, GameObject inspector returning to pool)
        public void Clear()
        {
            this.cachedTransforms.Clear();
            displayIndex = 0;
            autoExpandedIDs.Clear();
            expandedInstanceIDs.Clear();
            this.ScrollPool.Refresh(true, true);
            if (refreshCoroutine != null)
            {
                RuntimeHelper.StopCoroutine(refreshCoroutine);
                refreshCoroutine = null;
            }
        }

        // Checks if the given Instance ID is expanded or not
        public bool IsTransformExpanded(int instanceID)
        {
            return Filtering ? autoExpandedIDs.Contains(instanceID)
                             : expandedInstanceIDs.Contains(instanceID);
        }

        // Jumps to a specific Transform in the tree and highlights it.
        public void JumpAndExpandToTransform(Transform transform)
        {
            // make sure all parents of the object are expanded
            var parent = transform.parent;
            while (parent)
            {
                int pid = parent.GetInstanceID();
                if (!expandedInstanceIDs.Contains(pid))
                    expandedInstanceIDs.Add(pid);

                parent = parent.parent;
            }

            // Refresh cached transforms (no UI rebuild yet).
            // Stop existing coroutine and do it oneshot.
            RefreshData(false, false, true, true);

            int transformID = transform.GetInstanceID();

            // find the index of our transform in the list and jump to it
            int idx;
            for (idx = 0; idx < cachedTransforms.Count; idx++)
            {
                var cache = (CachedTransform)cachedTransforms[idx];
                if (cache.InstanceID == transformID)
                    break;
            }

            ScrollPool.JumpToIndex(idx, OnCellJumpedTo);
        }

        private void OnCellJumpedTo(TransformCell cell)
        {
            RuntimeHelper.StartCoroutine(HighlightCellCoroutine(cell));
        }

        private IEnumerator HighlightCellCoroutine(TransformCell cell)
        {
            var button = cell.NameButton.Component;
            button.StartColorTween(new Color(0.2f, 0.3f, 0.2f), false);

            float start = Time.realtimeSinceStartup;
            while (Time.realtimeSinceStartup - start < 1.5f)
                yield return null;

            button.OnDeselect(null);
        }

        // Perform a Traverse and optionally refresh the ScrollPool as well.
        // If oneShot, then this happens instantly with no yield.
        public void RefreshData(bool andRefreshUI, bool jumpToTop, bool stopExistingCoroutine, bool oneShot)
        {
            if (refreshCoroutine != null)
            {
                if (stopExistingCoroutine)
                {
                    RuntimeHelper.StopCoroutine(refreshCoroutine);
                    refreshCoroutine = null;
                }
                else
                    return;
            }

            visited.Clear();
            displayIndex = 0;
            needRefreshUI = false;
            traversedThisFrame.Reset();
            traversedThisFrame.Start();

            IEnumerable<GameObject> rootObjects = GetRootEntriesMethod.Invoke();

            refreshCoroutine = RuntimeHelper.StartCoroutine(RefreshCoroutine(rootObjects, andRefreshUI, jumpToTop, oneShot));
        }

        // Coroutine for batched updates, max 2000 gameobjects per frame so FPS doesn't get tanked when there is like 100k gameobjects.
        // if "oneShot", then this will NOT be batched (if we need an immediate full update).
        IEnumerator RefreshCoroutine(IEnumerable<GameObject> rootObjects, bool andRefreshUI, bool jumpToTop, bool oneShot)
        {
            foreach (var gameObj in rootObjects)
            {
                if (gameObj)
                {
                    var enumerator = Traverse(gameObj.transform, null, 0, oneShot);
                    while (enumerator.MoveNext())
                    {
                        if (!oneShot)
                            yield return enumerator.Current;
                    }
                }
            }

            // Prune displayed transforms that we didnt visit in that traverse
            for (int i = cachedTransforms.Count - 1; i >= 0; i--)
            {
                var cached = (CachedTransform)cachedTransforms[i];
                if (!visited.Contains(cached.InstanceID))
                {
                    cachedTransforms.RemoveAt(i);
                    needRefreshUI = true;
                }
            }

            if (andRefreshUI && needRefreshUI)
                ScrollPool.Refresh(true, jumpToTop);

            prevDisplayIndex = displayIndex;
            refreshCoroutine = null;
        }   

        // Recursive method to check a Transform and its children (if expanded).
        // Parent and depth can be null/default.
        private IEnumerator Traverse(Transform transform, CachedTransform parent, int depth, bool oneShot)
        {
            // Let's only tank 2ms of each frame (60->53fps)
            if (traversedThisFrame.ElapsedMilliseconds > 2)
            {
                yield return null;
                traversedThisFrame.Reset();
                traversedThisFrame.Start();
            }

            int instanceID = transform.GetInstanceID();

            if (visited.Contains(instanceID))
                yield break;

            if (Filtering)
            {
                if (!FilterHierarchy(transform))
                    yield break;

                visited.Add(instanceID);

                if (!autoExpandedIDs.Contains(instanceID))
                    autoExpandedIDs.Add(instanceID);
            }
            else
                visited.Add(instanceID);

            CachedTransform cached;
            if (cachedTransforms.Contains(instanceID))
            {
                cached = (CachedTransform)cachedTransforms[(object)instanceID];
                int prevSiblingIdx = cached.SiblingIndex;
                if (cached.Update(transform, depth))
                {
                    needRefreshUI = true;

                    // If the sibling index changed, we need to shuffle it in our cached transforms list.
                    if (prevSiblingIdx != cached.SiblingIndex)
                    {
                        cachedTransforms.Remove(instanceID);
                        if (cachedTransforms.Count <= displayIndex)
                            cachedTransforms.Add(instanceID, cached);
                        else
                            cachedTransforms.Insert(displayIndex, instanceID, cached);
                    }
                }
            }
            else
            {
                needRefreshUI = true;
                cached = new CachedTransform(this, transform, depth, parent);
                if (cachedTransforms.Count <= displayIndex)
                    cachedTransforms.Add(instanceID, cached);
                else
                    cachedTransforms.Insert(displayIndex, instanceID, cached);
            }

            displayIndex++;

            if (IsTransformExpanded(instanceID) && cached.Value.childCount > 0)
            {
                for (int i = 0; i < transform.childCount; i++)
                {
                    var enumerator = Traverse(transform.GetChild(i), cached, depth + 1, oneShot);
                    while (enumerator.MoveNext())
                    {
                        if (!oneShot)
                            yield return enumerator.Current;
                    }
                }
            }
        }

        private bool FilterHierarchy(Transform obj)
        {
            if (obj.name.ContainsIgnoreCase(currentFilter))
                return true;

            if (obj.childCount <= 0)
                return false;

            for (int i = 0; i < obj.childCount; i++)
                if (FilterHierarchy(obj.GetChild(i)))
                    return true;

            return false;
        }

        public void SetCell(TransformCell cell, int index)
        {
            if (index < cachedTransforms.Count)
            {
                cell.ConfigureCell((CachedTransform)cachedTransforms[index], index);
                if (Filtering)
                {
                    if (cell.cachedTransform.Name.ContainsIgnoreCase(currentFilter))
                        cell.NameButton.ButtonText.color = Color.green;
                }
            }
            else
                cell.Disable();
        }

        public void OnCellBorrowed(TransformCell cell)
        {
            cell.OnExpandToggled += OnCellExpandToggled;
            cell.OnGameObjectClicked += OnGameObjectClicked;
            cell.OnEnableToggled += OnCellEnableToggled;
        }

        private void OnGameObjectClicked(GameObject obj)
        {
            if (OnClickOverrideHandler != null)
                OnClickOverrideHandler.Invoke(obj);
            else
                InspectorManager.Inspect(obj);
        }

        public void OnCellExpandToggled(CachedTransform cache)
        {
            var instanceID = cache.InstanceID;
            if (expandedInstanceIDs.Contains(instanceID))
                expandedInstanceIDs.Remove(instanceID);
            else
                expandedInstanceIDs.Add(instanceID);

            RefreshData(true, false, true, true);
        }

        public void OnCellEnableToggled(CachedTransform cache)
        {
            cache.Value.gameObject.SetActive(!cache.Value.gameObject.activeSelf);

            RefreshData(true, false, true, true);
        }
    }
}

```

`src/UI/Widgets/UnityObjects/AudioClipWidget.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class AudioClipWidget : UnityObjectWidget
    {
        static GameObject AudioPlayerObject;
        static AudioSource Source;
        static AudioClipWidget CurrentlyPlaying;
        static Coroutine CurrentlyPlayingCoroutine;
        static readonly string zeroLengthString = GetLengthString(0f);

        public AudioClip RefAudioClip;
        private string fullLengthText;

        private ButtonRef toggleButton;
        private bool audioPlayerWanted;

        private GameObject audioPlayerRoot;
        private ButtonRef playStopButton;
        private Text progressLabel;
        private GameObject saveObjectRow;
        private InputFieldRef savePathInput;
        private GameObject cantSaveRow;

        public override void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            base.OnBorrowed(target, targetType, inspector);

            this.audioPlayerRoot.transform.SetParent(inspector.UIRoot.transform);
            this.audioPlayerRoot.transform.SetSiblingIndex(inspector.UIRoot.transform.childCount - 2);

            RefAudioClip = target.TryCast<AudioClip>();
            this.fullLengthText = GetLengthString(RefAudioClip.length);

            if (RefAudioClip.loadType == AudioClipLoadType.DecompressOnLoad)
            {
                cantSaveRow.SetActive(false);
                saveObjectRow.SetActive(true);
                SetDefaultSavePath();
            }
            else
            {
                cantSaveRow.SetActive(true);
                saveObjectRow.SetActive(false);
            }

            ResetProgressLabel();
        }

        public override void OnReturnToPool()
        {
            RefAudioClip = null;

            if (audioPlayerWanted)
                ToggleAudioWidget();

            if (CurrentlyPlaying == this)
                StopClip();

            this.audioPlayerRoot.transform.SetParent(Pool<AudioClipWidget>.Instance.InactiveHolder.transform);

            base.OnReturnToPool();
        }

        private void ToggleAudioWidget()
        {
            if (audioPlayerWanted)
            {
                audioPlayerWanted = false;

                toggleButton.ButtonText.text = "Show Player";
                audioPlayerRoot.SetActive(false);
            }
            else
            {
                audioPlayerWanted = true;

                toggleButton.ButtonText.text = "Hide Player";
                audioPlayerRoot.SetActive(true);
            }
        }

        void SetDefaultSavePath()
        {
            string name = RefAudioClip.name;
            if (string.IsNullOrEmpty(name))
                name = "untitled";
            savePathInput.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, $"{name}.wav");
        }

        static string GetLengthString(float seconds)
        {
            TimeSpan ts = TimeSpan.FromSeconds(seconds);

            StringBuilder sb = new();

            if (ts.Hours > 0)
                sb.Append($"{ts.Hours}:");

            sb.Append($"{ts.Minutes:00}:");
            sb.Append($"{ts.Seconds:00}:");
            sb.Append($"{ts.Milliseconds:000}");

            return sb.ToString();
        }

        private void ResetProgressLabel()
        {
            this.progressLabel.text = $"{zeroLengthString} / {fullLengthText}";
        }

        private void OnPlayStopClicked()
        {
            SetupAudioPlayer();

            if (CurrentlyPlaying == this)
            {
                // we are playing a clip. stop it.
                StopClip();
            }
            else
            {
                // If something else is playing a clip, stop that.
                if (CurrentlyPlaying != null)
                    CurrentlyPlaying.StopClip();

                // we want to start playing a clip.
                CurrentlyPlayingCoroutine = RuntimeHelper.StartCoroutine(PlayClipCoroutine());
            }
        }

        static void SetupAudioPlayer()
        {
            if (AudioPlayerObject)
                return;

            AudioPlayerObject = new GameObject("UnityExplorer.AudioPlayer");
            UnityEngine.Object.DontDestroyOnLoad(AudioPlayerObject);
            AudioPlayerObject.hideFlags = HideFlags.HideAndDontSave;
            AudioPlayerObject.transform.position = new(int.MinValue, int.MinValue); // move it as far away as possible
#if CPP
            Source = AudioPlayerObject.AddComponent(UnhollowerRuntimeLib.Il2CppType.Of<AudioSource>()).TryCast<AudioSource>();
#else
            Source = AudioPlayerObject.AddComponent<AudioSource>();
#endif
            AudioPlayerObject.AddComponent<AudioListener>();
        }

        private IEnumerator PlayClipCoroutine()
        {
            playStopButton.ButtonText.text = "Stop Clip";
            CurrentlyPlaying = this;
            Source.clip = this.RefAudioClip;
            Source.Play();

            while (Source.isPlaying)
            {
                progressLabel.text = $"{GetLengthString(Source.time)} / {fullLengthText}";
                yield return null;
            }

            CurrentlyPlayingCoroutine = null;
            StopClip();
        }

        private void StopClip()
        {
            if (CurrentlyPlayingCoroutine != null)
                RuntimeHelper.StopCoroutine(CurrentlyPlayingCoroutine);

            Source.Stop();
            CurrentlyPlaying = null;
            CurrentlyPlayingCoroutine = null;
            playStopButton.ButtonText.text = "Play Clip";

            ResetProgressLabel();
        }

        public void OnSaveClipClicked()
        {
            if (!RefAudioClip)
            {
                ExplorerCore.LogWarning("AudioClip is null, maybe it was destroyed?");
                return;
            }

            if (string.IsNullOrEmpty(savePathInput.Text))
            {
                ExplorerCore.LogWarning("Save path cannot be empty!");
                return;
            }

            string path = savePathInput.Text;
            if (!path.EndsWith(".wav", StringComparison.InvariantCultureIgnoreCase))
                path += ".wav";

            path = IOUtility.EnsureValidFilePath(path);

            if (File.Exists(path))
                File.Delete(path);

            SavWav.Save(RefAudioClip, path);
        }

        public override GameObject CreateContent(GameObject uiRoot)
        {
            GameObject ret = base.CreateContent(uiRoot);

            // Toggle Button

            toggleButton = UIFactory.CreateButton(UIRoot, "AudioWidgetToggleButton", "Show Player", new Color(0.2f, 0.3f, 0.2f));
            toggleButton.Transform.SetSiblingIndex(0);
            UIFactory.SetLayoutElement(toggleButton.Component.gameObject, minHeight: 25, minWidth: 170);
            toggleButton.OnClick += ToggleAudioWidget;

            // Actual widget

            audioPlayerRoot = UIFactory.CreateVerticalGroup(uiRoot, "AudioWidget", false, false, true, true, spacing: 5);
            UIFactory.SetLayoutElement(audioPlayerRoot, flexibleWidth: 9999, flexibleHeight: 50);
            audioPlayerRoot.SetActive(false);

            // Player 

            GameObject playerRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "PlayerWidget", false, false, true, true,
                spacing: 5, padding: new() { x = 3f, w = 3f, y = 3f, z = 3f });

            playStopButton = UIFactory.CreateButton(playerRow, "PlayerButton", "Play", normalColor: new(0.2f, 0.4f, 0.2f));
            playStopButton.OnClick += OnPlayStopClicked;
            UIFactory.SetLayoutElement(playStopButton.GameObject, minWidth: 60, minHeight: 25);

            progressLabel = UIFactory.CreateLabel(playerRow, "ProgressLabel", "0 / 0");
            UIFactory.SetLayoutElement(progressLabel.gameObject, flexibleWidth: 9999, minHeight: 25);

            ResetProgressLabel();

            // Save helper

            saveObjectRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "SaveRow", false, false, true, true, 2, new Vector4(2, 2, 2, 2),
                new Color(0.1f, 0.1f, 0.1f));

            ButtonRef saveBtn = UIFactory.CreateButton(saveObjectRow, "SaveButton", "Save .WAV", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveBtn.OnClick += OnSaveClipClicked;

            savePathInput = UIFactory.CreateInputField(saveObjectRow, "SaveInput", "...");
            UIFactory.SetLayoutElement(savePathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);

            // cant save label
            cantSaveRow = UIFactory.CreateHorizontalGroup(audioPlayerRoot, "CantSaveRow", true, true, true, true);
            UIFactory.SetLayoutElement(cantSaveRow, minHeight: 25, flexibleWidth: 9999);
            UIFactory.CreateLabel(
                cantSaveRow,
                "CantSaveLabel",
                "Cannot save this AudioClip as the data is compressed or streamed. Try a tool such as AssetRipper to unpack it.",
                color: Color.grey);

            return ret;
        }
    }

#region SavWav

    //	Copyright (c) 2012 Calvin Rien
    //        http://the.darktable.com
    //
    //	This software is provided 'as-is', without any express or implied warranty. In
    //	no event will the authors be held liable for any damages arising from the use
    //	of this software.
    //
    //	Permission is granted to anyone to use this software for any purpose,
    //	including commercial applications, and to alter it and redistribute it freely,
    //	subject to the following restrictions:
    //
    //	1. The origin of this software must not be misrepresented; you must not claim
    //	that you wrote the original software. If you use this software in a product,
    //	an acknowledgment in the product documentation would be appreciated but is not
    //	required.
    //
    //	2. Altered source versions must be plainly marked as such, and must not be
    //	misrepresented as being the original software.
    //
    //	3. This notice may not be removed or altered from any source distribution.
    //
    //  =============================================================================
    //
    //  derived from Gregorio Zanon's script
    //  http://forum.unity3d.com/threads/119295-Writing-AudioListener.GetOutputData-to-wav-problem?p=806734&viewfull=1#post806734

    public static class SavWav
    {
        public const int HEADER_SIZE = 44;
        public const float RESCALE_FACTOR = 32767; // to convert float to Int16

        public static void Save(AudioClip clip, string filepath)
        {
            using FileStream fileStream = CreateEmpty(filepath);

            ConvertAndWrite(fileStream, clip);
            WriteHeader(fileStream, clip);
        }

        static FileStream CreateEmpty(string filepath)
        {
            FileStream fileStream = new(filepath, FileMode.Create);
            byte emptyByte = default;

            for (int i = 0; i < HEADER_SIZE; i++) //preparing the header
                fileStream.WriteByte(emptyByte);

            return fileStream;
        }

        static void ConvertAndWrite(FileStream fileStream, AudioClip clip)
        {
#if CPP
            UnhollowerBaseLib.Il2CppStructArray<float> samples = new float[clip.samples * clip.channels];
            AudioClip.GetData(clip, samples, clip.samples, 0);
#else
            float[] samples = new float[clip.samples * clip.channels];
            clip.GetData(samples, 0);
#endif

            int len = samples.Length;

            // converting in 2 float[] steps to Int16[], then Int16[] to Byte[]
            short[] intData = new short[len];

            // bytesData array is twice the size of dataSource array because a float converted in Int16 is 2 bytes.
            byte[] bytesData = new byte[len * 2];

            for (int i = 0; i < len; i++)
            {
                intData[i] = (short)(samples[i] * RESCALE_FACTOR);
                byte[] byteArr = BitConverter.GetBytes(intData[i]);
                byteArr.CopyTo(bytesData, i * 2);
            }

            fileStream.Write(bytesData, 0, bytesData.Length);
        }

        static void WriteHeader(FileStream stream, AudioClip clip)
        {
            int hz = clip.frequency;
            int channels = clip.channels;
            int samples = clip.samples;

            stream.Seek(0, SeekOrigin.Begin);

            byte[] riff = Encoding.UTF8.GetBytes("RIFF");
            stream.Write(riff, 0, 4);

            byte[] chunkSize = BitConverter.GetBytes(stream.Length - 8);
            stream.Write(chunkSize, 0, 4);

            byte[] wave = Encoding.ASCII.GetBytes("WAVE");
            stream.Write(wave, 0, 4);

            byte[] fmt = Encoding.ASCII.GetBytes("fmt ");
            stream.Write(fmt, 0, 4);

            byte[] subChunk1 = BitConverter.GetBytes(16);
            stream.Write(subChunk1, 0, 4);

            byte[] audioFormat = BitConverter.GetBytes(1);
            stream.Write(audioFormat, 0, 2);

            byte[] numChannels = BitConverter.GetBytes(channels);
            stream.Write(numChannels, 0, 2);

            byte[] sampleRate = BitConverter.GetBytes(hz);
            stream.Write(sampleRate, 0, 4);

            byte[] byteRate = BitConverter.GetBytes(hz * channels * 2); // sampleRate * bytesPerSample*number of channels, here 44100*2*2
            stream.Write(byteRate, 0, 4);

            ushort blockAlign = (ushort)(channels * 2);
            stream.Write(BitConverter.GetBytes(blockAlign), 0, 2);

            ushort bps = 16;
            byte[] bitsPerSample = BitConverter.GetBytes(bps);
            stream.Write(bitsPerSample, 0, 2);

            byte[] datastring = Encoding.UTF8.GetBytes("data");
            stream.Write(datastring, 0, 4);

            byte[] subChunk2 = BitConverter.GetBytes(samples * channels * 2);
            stream.Write(subChunk2, 0, 4);

            stream.Seek(0, SeekOrigin.Begin);
        }

#endregion
    }
}
```

`src/UI/Widgets/UnityObjects/Texture2DWidget.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Config;
using UnityExplorer.Inspectors;
using UnityExplorer.UI.Panels;
using UniverseLib;
using UniverseLib.Runtime;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;
using UniverseLib.Utility;

namespace UnityExplorer.UI.Widgets
{
    public class Texture2DWidget : UnityObjectWidget
    {
        private Texture2D TextureRef;
        private float realWidth;
        private float realHeight;

        private bool textureViewerWanted;
        private ButtonRef toggleButton;

        private GameObject textureViewerRoot;
        private InputFieldRef savePathInput;
        private Image image;
        private LayoutElement imageLayout;

        public override void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            base.OnBorrowed(target, targetType, inspector);

            TextureRef = target.TryCast<Texture2D>();

            realWidth = TextureRef.width;
            realHeight = TextureRef.height;

            if (this.textureViewerRoot)
                this.textureViewerRoot.transform.SetParent(inspector.UIRoot.transform);

            InspectorPanel.Instance.Dragger.OnFinishResize += OnInspectorFinishResize;
        }

        public override void OnReturnToPool()
        {
            InspectorPanel.Instance.Dragger.OnFinishResize -= OnInspectorFinishResize;

            TextureRef = null;

            if (image.sprite)
                GameObject.Destroy(image.sprite);

            if (textureViewerWanted)
                ToggleTextureViewer();

            if (this.textureViewerRoot)
                this.textureViewerRoot.transform.SetParent(Pool<Texture2DWidget>.Instance.InactiveHolder.transform);

            base.OnReturnToPool();
        }

        private void ToggleTextureViewer()
        {
            if (textureViewerWanted)
            {
                // disable
                textureViewerWanted = false;
                textureViewerRoot.SetActive(false);
                toggleButton.ButtonText.text = "View Texture";

                ParentInspector.mainContentHolder.SetActive(true);
            }
            else
            {
                // enable
                if (!image.sprite)
                    SetupTextureViewer();

                SetImageSize();

                textureViewerWanted = true;
                textureViewerRoot.SetActive(true);
                toggleButton.ButtonText.text = "Hide Texture";

                ParentInspector.mainContentHolder.gameObject.SetActive(false);
            }
        }

        private void SetupTextureViewer()
        {
            if (!this.TextureRef)
                return;

            string name = TextureRef.name;
            if (string.IsNullOrEmpty(name))
                name = "untitled";
            savePathInput.Text = Path.Combine(ConfigManager.Default_Output_Path.Value, $"{name}.png");

            Sprite sprite = TextureHelper.CreateSprite(TextureRef);
            image.sprite = sprite;
        }

        private void OnInspectorFinishResize(RectTransform _)
        {
            SetImageSize();
        }

        private void SetImageSize()
        {
            if (!imageLayout)
                return;

            RuntimeHelper.StartCoroutine(SetImageSizeCoro());
        }

        IEnumerator SetImageSizeCoro()
        {
            // let unity rebuild layout etc
            yield return null;

            RectTransform imageRect = InspectorPanel.Instance.Rect;

            float rectWidth = imageRect.rect.width - 25;
            float rectHeight = imageRect.rect.height - 196;

            // If our image is smaller than the viewport, just use 100% scaling
            if (realWidth < rectWidth && realHeight < rectHeight)
            {
                imageLayout.minWidth = realWidth;
                imageLayout.minHeight = realHeight;
            }
            else // we will need to scale down the image to fit
            {
                // get the ratio of our viewport dimensions to width and height
                float viewWidthRatio = (float)((decimal)rectWidth / (decimal)realWidth);
                float viewHeightRatio = (float)((decimal)rectHeight / (decimal)realHeight);

                // if width needs to be scaled more than height
                if (viewWidthRatio < viewHeightRatio)
                {
                    imageLayout.minWidth = realWidth * viewWidthRatio;
                    imageLayout.minHeight = realHeight * viewWidthRatio;
                }
                else // if height needs to be scaled more than width
                {
                    imageLayout.minWidth = realWidth * viewHeightRatio;
                    imageLayout.minHeight = realHeight * viewHeightRatio;
                }
            }
        }

        private void OnSaveTextureClicked()
        {
            if (!TextureRef)
            {
                ExplorerCore.LogWarning("Texture is null, maybe it was destroyed?");
                return;
            }

            if (string.IsNullOrEmpty(savePathInput.Text))
            {
                ExplorerCore.LogWarning("Save path cannot be empty!");
                return;
            }

            string path = savePathInput.Text;
            if (!path.EndsWith(".png", StringComparison.InvariantCultureIgnoreCase))
                path += ".png";

            path = IOUtility.EnsureValidFilePath(path);

            if (File.Exists(path))
                File.Delete(path);

            Texture2D tex = TextureRef;
            if (!TextureHelper.IsReadable(tex))
                tex = TextureHelper.ForceReadTexture(tex);

            byte[] data = TextureHelper.EncodeToPNG(tex);
            File.WriteAllBytes(path, data);

            if (tex != TextureRef)
            {
                // cleanup temp texture if we had to force-read it.
                GameObject.Destroy(tex);
            }
        }

        public override GameObject CreateContent(GameObject uiRoot)
        {
            GameObject ret = base.CreateContent(uiRoot);

            // Button

            toggleButton = UIFactory.CreateButton(UIRoot, "TextureButton", "View Texture", new Color(0.2f, 0.3f, 0.2f));
            toggleButton.Transform.SetSiblingIndex(0);
            UIFactory.SetLayoutElement(toggleButton.Component.gameObject, minHeight: 25, minWidth: 150);
            toggleButton.OnClick += ToggleTextureViewer;

            // Texture viewer

            textureViewerRoot = UIFactory.CreateVerticalGroup(uiRoot, "TextureViewer", false, false, true, true, 2, new Vector4(5, 5, 5, 5),
                new Color(0.1f, 0.1f, 0.1f), childAlignment: TextAnchor.UpperLeft);
            UIFactory.SetLayoutElement(textureViewerRoot, flexibleWidth: 9999, flexibleHeight: 9999);

            // Save helper

            GameObject saveRowObj = UIFactory.CreateHorizontalGroup(textureViewerRoot, "SaveRow", false, false, true, true, 2, new Vector4(2, 2, 2, 2),
                new Color(0.1f, 0.1f, 0.1f));

            ButtonRef saveBtn = UIFactory.CreateButton(saveRowObj, "SaveButton", "Save .PNG", new Color(0.2f, 0.25f, 0.2f));
            UIFactory.SetLayoutElement(saveBtn.Component.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            saveBtn.OnClick += OnSaveTextureClicked;

            savePathInput = UIFactory.CreateInputField(saveRowObj, "SaveInput", "...");
            UIFactory.SetLayoutElement(savePathInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 9999);

            // Actual texture viewer

            GameObject imageViewport = UIFactory.CreateVerticalGroup(textureViewerRoot, "ImageViewport", false, false, true, true, 
                bgColor: new(1,1,1,0), childAlignment: TextAnchor.MiddleCenter);
            UIFactory.SetLayoutElement(imageViewport, flexibleWidth: 9999, flexibleHeight: 9999);

            GameObject imageHolder = UIFactory.CreateUIObject("ImageHolder", imageViewport);
            imageLayout = UIFactory.SetLayoutElement(imageHolder, 1, 1, 0, 0);

            var actualImageObj = UIFactory.CreateUIObject("ActualImage", imageHolder);
            var actualRect = actualImageObj.GetComponent<RectTransform>();
            actualRect.anchorMin = new(0, 0);
            actualRect.anchorMax = new(1, 1);
            image = actualImageObj.AddComponent<Image>();

            textureViewerRoot.SetActive(false);

            return ret;
        }
    }
}

```

`src/UI/Widgets/UnityObjects/UnityObjectWidget.cs`:

```cs
using System;
using UnityEngine;
using UnityEngine.UI;
using UnityExplorer.Inspectors;
using UniverseLib;
using UniverseLib.UI;
using UniverseLib.UI.Models;
using UniverseLib.UI.ObjectPool;

namespace UnityExplorer.UI.Widgets
{
    public class UnityObjectWidget : IPooledObject
    {
        public UnityEngine.Object UnityObjectRef;
        public Component ComponentRef;
        public ReflectionInspector ParentInspector;

        protected ButtonRef gameObjectButton;
        protected InputFieldRef nameInput;
        protected InputFieldRef instanceIdInput;

        // IPooledObject
        public GameObject UIRoot { get; set; }
        public float DefaultHeight => -1;

        public static UnityObjectWidget GetUnityWidget(object target, Type targetType, ReflectionInspector inspector)
        {
            if (!typeof(UnityEngine.Object).IsAssignableFrom(targetType))
                return null;

            UnityObjectWidget widget = target switch
            {
                Texture2D => Pool<Texture2DWidget>.Borrow(),
                AudioClip => Pool<AudioClipWidget>.Borrow(),
                _ => Pool<UnityObjectWidget>.Borrow()
            };

            widget.OnBorrowed(target, targetType, inspector);

            return widget;
        }

        public virtual void OnBorrowed(object target, Type targetType, ReflectionInspector inspector)
        {
            this.ParentInspector = inspector ?? throw new ArgumentNullException(nameof(inspector));

            if (!this.UIRoot)
                CreateContent(inspector.UIRoot);
            else
                this.UIRoot.transform.SetParent(inspector.UIRoot.transform);

            this.UIRoot.transform.SetSiblingIndex(inspector.UIRoot.transform.childCount - 2);

            UnityObjectRef = target.TryCast<UnityEngine.Object>();
            UIRoot.SetActive(true);

            nameInput.Text = UnityObjectRef.name;
            instanceIdInput.Text = UnityObjectRef.GetInstanceID().ToString();

            if (typeof(Component).IsAssignableFrom(targetType))
            {
                ComponentRef = (Component)target.TryCast(typeof(Component));
                gameObjectButton.Component.gameObject.SetActive(true);
            }
            else
                gameObjectButton.Component.gameObject.SetActive(false);
        }

        public virtual void OnReturnToPool()
        {
            UnityObjectRef = null;
            ComponentRef = null;
            ParentInspector = null;
        }

        // Update

        public virtual void Update()
        {
            if (this.UnityObjectRef)
            {
                nameInput.Text = UnityObjectRef.name;
                ParentInspector.Tab.TabText.text = $"{ParentInspector.currentBaseTabText} \"{UnityObjectRef.name}\"";
            }
        }

        // UI Listeners

        private void OnGameObjectButtonClicked()
        {
            if (!ComponentRef)
            {
                ExplorerCore.LogWarning("Component reference is null or destroyed!");
                return;
            }

            InspectorManager.Inspect(ComponentRef.gameObject);
        }

        // UI construction

        public virtual GameObject CreateContent(GameObject uiRoot)
        {
            UIRoot = UIFactory.CreateUIObject("UnityObjectRow", uiRoot);
            UIFactory.SetLayoutGroup<HorizontalLayoutGroup>(UIRoot, false, false, true, true, 5);
            UIFactory.SetLayoutElement(UIRoot, minHeight: 25, flexibleHeight: 0, flexibleWidth: 9999);

            var nameLabel = UIFactory.CreateLabel(UIRoot, "NameLabel", "Name:", TextAnchor.MiddleLeft, Color.grey);
            UIFactory.SetLayoutElement(nameLabel.gameObject, minHeight: 25, minWidth: 45, flexibleWidth: 0);

            nameInput = UIFactory.CreateInputField(UIRoot, "NameInput", "untitled");
            UIFactory.SetLayoutElement(nameInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 1000);
            nameInput.Component.readOnly = true;

            gameObjectButton = UIFactory.CreateButton(UIRoot, "GameObjectButton", "Inspect GameObject", new Color(0.2f, 0.2f, 0.2f));
            UIFactory.SetLayoutElement(gameObjectButton.Component.gameObject, minHeight: 25, minWidth: 160);
            gameObjectButton.OnClick += OnGameObjectButtonClicked;

            var instanceLabel = UIFactory.CreateLabel(UIRoot, "InstanceLabel", "Instance ID:", TextAnchor.MiddleRight, Color.grey);
            UIFactory.SetLayoutElement(instanceLabel.gameObject, minHeight: 25, minWidth: 100, flexibleWidth: 0);

            instanceIdInput = UIFactory.CreateInputField(UIRoot, "InstanceIDInput", "ERROR");
            UIFactory.SetLayoutElement(instanceIdInput.UIRoot, minHeight: 25, minWidth: 100, flexibleWidth: 0);
            instanceIdInput.Component.readOnly = true;

            UIRoot.SetActive(false);

            return UIRoot;
        }
    }
}

```

`src/UnityExplorer.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Release_ML_Cpp</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}</ProjectGuid>
    <OutputType>Library</OutputType>
    <LangVersion>9.0</LangVersion>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile />
    <DefineConstants>
    </DefineConstants>
    <IsCpp>false</IsCpp>
    <IsBepInEx>false</IsBepInEx>
    <IsMelonLoader>false</IsMelonLoader>
    <IsStandalone>false</IsStandalone>
    <DebugSymbols>false</DebugSymbols>
    <DebugType>none</DebugType>
    <Optimize>false</Optimize>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <PlatformTarget>x64</PlatformTarget>
    <Prefer32Bit>false</Prefer32Bit>
    <RootNamespace>UnityExplorer</RootNamespace>
    <NuGetPackageImportStamp>
    </NuGetPackageImportStamp>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <!-- CONFIGURATIONS -->
  <!-- ML IL2CPP -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release_ML_Cpp|AnyCPU' ">
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.MelonLoader.Il2Cpp\</OutputPath>
    <DefineConstants>CPP,ML</DefineConstants>
    <AssemblyName>UnityExplorer.ML.IL2CPP</AssemblyName>
    <IsCpp>true</IsCpp>
    <IsMelonLoader>true</IsMelonLoader>
  </PropertyGroup>
  <!-- ML MONO -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release_ML_Mono|AnyCPU' ">
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.MelonLoader.Mono\</OutputPath>
    <DefineConstants>MONO,ML</DefineConstants>
    <AssemblyName>UnityExplorer.ML.Mono</AssemblyName>
    <Prefer32Bit>false</Prefer32Bit>
    <IsCpp>false</IsCpp>
    <IsMelonLoader>true</IsMelonLoader>
  </PropertyGroup>
  <!-- BEPINEX IL2CPP -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release_BIE_Cpp|AnyCPU' ">
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.BepInEx.Il2Cpp\</OutputPath>
    <DefineConstants>CPP,BIE,BIE6</DefineConstants>
    <AssemblyName>UnityExplorer.BIE.IL2CPP</AssemblyName>
    <IsCpp>true</IsCpp>
    <IsBepInEx>true</IsBepInEx>
  </PropertyGroup>
  <!-- BEPINEX 6 MONO -->
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release_BIE6_Mono|AnyCPU' ">
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.BepInEx6.Mono\</OutputPath>
    <DefineConstants>MONO,BIE,BIE6</DefineConstants>
    <AssemblyName>UnityExplorer.BIE6.Mono</AssemblyName>
    <IsCpp>false</IsCpp>
    <IsBepInEx>true</IsBepInEx>
  </PropertyGroup>
  <!-- BEPINEX 5 MONO -->
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release_BIE5_Mono|AnyCPU'">
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.BepInEx5.Mono\</OutputPath>
    <DefineConstants>MONO,BIE,BIE5</DefineConstants>
    <AssemblyName>UnityExplorer.BIE5.Mono</AssemblyName>
    <IsCpp>false</IsCpp>
    <IsBepInEx>true</IsBepInEx>
  </PropertyGroup>
  <!-- STANDALONE IL2CPP -->
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release_STANDALONE_Mono|AnyCPU'">
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.Standalone.Mono\</OutputPath>
    <DefineConstants>MONO,STANDALONE</DefineConstants>
    <AssemblyName>UnityExplorer.STANDALONE.Mono</AssemblyName>
    <IsCpp>false</IsCpp>
    <IsStandalone>true</IsStandalone>
  </PropertyGroup>
  <!-- STANDALONE MONO -->
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release_STANDALONE_Cpp|AnyCPU'">
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <OutputPath>..\Release\UnityExplorer.Standalone.Il2Cpp\</OutputPath>
    <DefineConstants>CPP,STANDALONE</DefineConstants>
    <AssemblyName>UnityExplorer.STANDALONE.IL2CPP</AssemblyName>
    <IsCpp>true</IsCpp>
    <IsStandalone>true</IsStandalone>
  </PropertyGroup>
  <!-- Global refs, Mono and Il2Cpp -->
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="System.Data" />
    <Reference Include="System.Xml" />
    <Reference Include="mcs">
      <HintPath>..\lib\mcs-unity\mcs\bin\Release\mcs.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- Non-MelonLoader (it includes Tomlet) -->
  <ItemGroup Condition="'$(IsMelonLoader)'=='false'">
    <Reference Include="Tomlet, Version=3.1.3.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\Samboy063.Tomlet.3.1.3\lib\net35\Tomlet.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- MelonLoader refs -->
  <ItemGroup Condition="'$(IsMelonLoader)'=='true'">
    <Reference Include="MelonLoader">
      <HintPath>..\lib\MelonLoader\MelonLoader.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- BepInEx universal refs -->
  <ItemGroup Condition="'$(IsBepInEx)'=='true'">
    <Reference Include="0Harmony">
      <HintPath>packages\HarmonyX.2.5.2\lib\net35\0Harmony.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- BepInEx 5 Mono refs -->
  <ItemGroup Condition="'$(IsBepInEx)|$(IsCpp)|$(Configuration)'=='true|false|Release_BIE5_Mono'">
    <Reference Include="BepInEx">
      <HintPath>..\lib\BepInEx.5\BepInEx.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- BepInEx 6 Mono refs -->
  <ItemGroup Condition="'$(IsBepInEx)|$(IsCpp)|$(Configuration)'=='true|false|Release_BIE6_Mono'">
    <Reference Include="BepInEx">
      <HintPath>..\lib\BepInEx.6.Mono\BepInEx.Core.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="BepInEx.Unity">
      <HintPath>..\lib\BepInEx.6.Mono\BepInEx.Unity.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- BepInEx Il2Cpp refs -->
  <ItemGroup Condition="'$(IsBepInEx)|$(IsCpp)'=='true|true'">
    <Reference Include="BepInEx">
      <HintPath>..\lib\BepInEx.6.IL2CPP\BepInEx.Core.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="BepInEx.IL2CPP">
      <HintPath>..\lib\BepInEx.6.IL2CPP\BepInEx.IL2CPP.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- Standalone refs -->
  <ItemGroup Condition="'$(IsStandalone)'=='true'">
    <Reference Include="0Harmony">
      <HintPath>packages\HarmonyX.2.5.2\lib\net35\0Harmony.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <!-- Mono refs -->
  <ItemGroup Condition="'$(IsCpp)'=='false'">
    <Reference Include="UnityEngine">
      <HintPath>..\lib\mono\UnityEngine.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.UI">
      <HintPath>..\lib\mono\UnityEngine.UI.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UniverseLib.Mono">
      <HintPath>packages\UniverseLib.1.2.17\lib\net35\UniverseLib.Mono.dll</HintPath>
    </Reference>
  </ItemGroup>
  <!-- Il2Cpp refs -->
  <ItemGroup Condition="'$(IsCpp)'=='true'">
    <Reference Include="UniverseLib.IL2CPP">
      <HintPath>packages\UniverseLib.1.2.17\lib\net472\UniverseLib.IL2CPP.dll</HintPath>
    </Reference>
    <Reference Include="UnhollowerBaseLib, Version=0.4.22.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\Il2CppAssemblyUnhollower.BaseLib.0.4.22\lib\net472\UnhollowerBaseLib.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Il2Cppmscorlib">
      <HintPath>..\lib\unhollowed\Il2Cppmscorlib.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="Il2CppSystem.Core">
      <HintPath>..\lib\unhollowed\Il2CppSystem.Core.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine">
      <HintPath>..\lib\unhollowed\UnityEngine.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.AudioModule">
      <HintPath>..\lib\unhollowed\UnityEngine.AudioModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.CoreModule">
      <HintPath>..\lib\unhollowed\UnityEngine.CoreModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.PhysicsModule">
      <HintPath>..\lib\unhollowed\UnityEngine.PhysicsModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.TextRenderingModule">
      <HintPath>..\lib\unhollowed\UnityEngine.TextRenderingModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.UI">
      <HintPath>..\lib\unhollowed\UnityEngine.UI.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.UIModule">
      <HintPath>..\lib\unhollowed\UnityEngine.UIModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
    <Reference Include="UnityEngine.IMGUIModule">
      <HintPath>..\lib\unhollowed\UnityEngine.IMGUIModule.dll</HintPath>
      <Private>False</Private>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CacheObject\CacheConstructor.cs" />
    <Compile Include="CacheObject\CacheMemberFactory.cs" />
    <Compile Include="Hooks\HookCell.cs" />
    <Compile Include="Hooks\HookInstance.cs" />
    <Compile Include="Hooks\HookManager.cs" />
    <Compile Include="Config\InternalConfigHandler.cs" />
    <Compile Include="CacheObject\CacheConfigEntry.cs" />
    <Compile Include="CacheObject\Views\CacheConfigCell.cs" />
    <Compile Include="CSConsole\CSAutoCompleter.cs" />
    <Compile Include="CSConsole\LexerBuilder.cs" />
    <Compile Include="CSConsole\Lexers\CommentLexer.cs" />
    <Compile Include="CSConsole\Lexers\KeywordLexer.cs" />
    <Compile Include="CSConsole\Lexers\Lexer.cs" />
    <Compile Include="CSConsole\Lexers\NumberLexer.cs" />
    <Compile Include="CSConsole\Lexers\StringLexer.cs" />
    <Compile Include="CSConsole\Lexers\SymbolLexer.cs" />
    <Compile Include="CSConsole\ScriptEvaluator.cs" />
    <Compile Include="CSConsole\ScriptInteraction.cs" />
    <Compile Include="ExplorerBehaviour.cs" />
    <Compile Include="Hooks\AddHookCell.cs" />
    <Compile Include="Inspectors\GameObjectWidgets\ComponentCell.cs" />
    <Compile Include="Inspectors\GameObjectWidgets\ComponentList.cs" />
    <Compile Include="Inspectors\GameObjectWidgets\GameObjectControls.cs" />
    <Compile Include="Inspectors\MouseInspector.cs" />
    <Compile Include="CSConsole\ConsoleController.cs" />
    <Compile Include="CacheObject\CacheField.cs" />
    <Compile Include="CacheObject\CacheKeyValuePair.cs" />
    <Compile Include="CacheObject\CacheListEntry.cs" />
    <Compile Include="CacheObject\CacheMember.cs" />
    <Compile Include="CacheObject\CacheMethod.cs" />
    <Compile Include="CacheObject\CacheObjectBase.cs" />
    <Compile Include="CacheObject\CacheProperty.cs" />
    <Compile Include="CacheObject\Views\CacheKeyValuePairCell.cs" />
    <Compile Include="CacheObject\Views\CacheListEntryCell.cs" />
    <Compile Include="CacheObject\Views\CacheMemberCell.cs" />
    <Compile Include="CacheObject\Views\CacheObjectCell.cs" />
    <Compile Include="Loader\Standalone\Editor\ExplorerEditorBehaviour.cs" />
    <Compile Include="Loader\Standalone\Editor\ExplorerEditorLoader.cs" />
    <Compile Include="Runtime\UnityCrashPrevention.cs" />
    <Compile Include="UI\DisplayManager.cs" />
    <Compile Include="UI\Notification.cs" />
    <Compile Include="UI\Panels\ClipboardPanel.cs" />
    <Compile Include="UI\Widgets\AutoComplete\EnumCompleter.cs" />
    <Compile Include="UI\Widgets\EvaluateWidget\EvaluateWidget.cs" />
    <Compile Include="Inspectors\GameObjectInspector.cs" />
    <Compile Include="CacheObject\ICacheObjectController.cs" />
    <Compile Include="Inspectors\InspectorManager.cs" />
    <Compile Include="Inspectors\InspectorTab.cs" />
    <Compile Include="Inspectors\InspectorBase.cs" />
    <Compile Include="CacheObject\IValues\InteractiveColor.cs" />
    <Compile Include="CacheObject\IValues\InteractiveDictionary.cs" />
    <Compile Include="CacheObject\IValues\InteractiveEnum.cs" />
    <Compile Include="CacheObject\IValues\InteractiveList.cs" />
    <Compile Include="CacheObject\IValues\InteractiveString.cs" />
    <Compile Include="CacheObject\IValues\InteractiveValue.cs" />
    <Compile Include="Inspectors\MouseInspectors\MouseInspectorBase.cs" />
    <Compile Include="Inspectors\MouseInspectors\UiInspector.cs" />
    <Compile Include="Inspectors\MouseInspectors\WorldInspector.cs" />
    <Compile Include="Inspectors\ReflectionInspector.cs" />
    <Compile Include="CacheObject\IValues\InteractiveValueStruct.cs" />
    <Compile Include="UI\Panels\HookManagerPanel.cs" />
    <Compile Include="UI\Panels\UIInspectorResultsPanel.cs" />
    <Compile Include="UI\Panels\LogPanel.cs" />
    <Compile Include="UI\Panels\CSConsolePanel.cs" />
    <Compile Include="UI\Panels\OptionsPanel.cs" />
    <Compile Include="UI\Widgets\AutoComplete\ISuggestionProvider.cs" />
    <Compile Include="UI\Widgets\AutoComplete\Suggestion.cs" />
    <Compile Include="Config\ConfigElement.cs" />
    <Compile Include="Config\ConfigHandler.cs" />
    <Compile Include="Config\ConfigManager.cs" />
    <Compile Include="Config\IConfigElement.cs" />
    <Compile Include="Runtime\Il2CppHelper.cs" />
    <Compile Include="Runtime\MonoHelper.cs" />
    <Compile Include="Runtime\UERuntimeHelper.cs" />
    <Compile Include="ObjectExplorer\SceneHandler.cs" />
    <Compile Include="ObjectExplorer\SearchProvider.cs" />
    <Compile Include="Tests\TestClass.cs" />
    <Compile Include="ExplorerCore.cs" />
    <Compile Include="Loader\BepInEx\BepInExConfigHandler.cs" />
    <Compile Include="Loader\BepInEx\ExplorerBepInPlugin.cs" />
    <Compile Include="Loader\IExplorerLoader.cs" />
    <Compile Include="Loader\MelonLoader\ExplorerMelonMod.cs" />
    <Compile Include="Loader\MelonLoader\MelonLoaderConfigHandler.cs" />
    <Compile Include="Loader\Standalone\ExplorerStandalone.cs" />
    <Compile Include="Loader\Standalone\StandaloneConfigHandler.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="UI\Panels\UIPanel.cs" />
    <Compile Include="UI\Panels\InspectorPanel.cs" />
    <Compile Include="UI\Panels\ObjectExplorerPanel.cs" />
    <Compile Include="UI\UIManager.cs" />
    <Compile Include="UI\Panels\PanelDragger.cs" />
    <Compile Include="UI\Panels\AutoCompleteModal.cs" />
    <Compile Include="UI\Widgets\AutoComplete\TypeCompleter.cs" />
    <Compile Include="ObjectExplorer\ObjectSearch.cs" />
    <Compile Include="ObjectExplorer\SceneExplorer.cs" />
    <Compile Include="UI\Widgets\EvaluateWidget\BaseArgumentHandler.cs" />
    <Compile Include="UI\Widgets\EvaluateWidget\GenericArgumentHandler.cs" />
    <Compile Include="UI\Widgets\EvaluateWidget\ParameterHandler.cs" />
    <Compile Include="UI\Widgets\TransformTree\CachedTransform.cs" />
    <Compile Include="UI\Widgets\TransformTree\TransformCell.cs" />
    <Compile Include="UI\Widgets\TransformTree\TransformTree.cs" />
    <Compile Include="UI\Widgets\UnityObjects\AudioClipWidget.cs" />
    <Compile Include="UI\Widgets\UnityObjects\Texture2DWidget.cs" />
    <Compile Include="UI\Widgets\UnityObjects\UnityObjectWidget.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="ILRepack.targets" />
    <None Include="nuget.config" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Analyzer Include="packages\UniverseLib.Analyzers.1.0.3\analyzers\dotnet\cs\UniverseLib.Analyzers.dll" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
  <Import Project="packages\ILRepack.Lib.MSBuild.Task.2.0.18.2\build\ILRepack.Lib.MSBuild.Task.targets" Condition="Exists('packages\ILRepack.Lib.MSBuild.Task.2.0.18.2\build\ILRepack.Lib.MSBuild.Task.targets')" />
  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
    <PropertyGroup>
      <ErrorText>This project references NuGet package(s) that are missing on this computer. Use NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
    </PropertyGroup>
    <Error Condition="!Exists('packages\ILRepack.Lib.MSBuild.Task.2.0.18.2\build\ILRepack.Lib.MSBuild.Task.targets')" Text="$([System.String]::Format('$(ErrorText)', 'packages\ILRepack.Lib.MSBuild.Task.2.0.18.2\build\ILRepack.Lib.MSBuild.Task.targets'))" />
  </Target>
</Project>
```

`src/UnityExplorer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30128.74
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "mcs", "..\lib\mcs-unity\mcs\mcs.csproj", "{E4989E4C-0875-4528-9031-08E2C0E70103}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnityExplorer", "UnityExplorer.csproj", "{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release_BIE_Cpp|Any CPU = Release_BIE_Cpp|Any CPU
		Release_BIE5_Mono|Any CPU = Release_BIE5_Mono|Any CPU
		Release_BIE6_Mono|Any CPU = Release_BIE6_Mono|Any CPU
		Release_ML_Cpp|Any CPU = Release_ML_Cpp|Any CPU
		Release_ML_Mono|Any CPU = Release_ML_Mono|Any CPU
		Release_STANDALONE_Cpp|Any CPU = Release_STANDALONE_Cpp|Any CPU
		Release_STANDALONE_Mono|Any CPU = Release_STANDALONE_Mono|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE_Cpp|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE_Cpp|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE5_Mono|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE5_Mono|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE6_Mono|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_BIE6_Mono|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_ML_Cpp|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_ML_Cpp|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_ML_Mono|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_ML_Mono|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_STANDALONE_Cpp|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_STANDALONE_Cpp|Any CPU.Build.0 = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_STANDALONE_Mono|Any CPU.ActiveCfg = Release|Any CPU
		{E4989E4C-0875-4528-9031-08E2C0E70103}.Release_STANDALONE_Mono|Any CPU.Build.0 = Release|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_Cpp|Any CPU.ActiveCfg = Release_BIE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE_Cpp|Any CPU.Build.0 = Release_BIE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE5_Mono|Any CPU.ActiveCfg = Release_BIE5_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE5_Mono|Any CPU.Build.0 = Release_BIE5_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE6_Mono|Any CPU.ActiveCfg = Release_BIE6_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_BIE6_Mono|Any CPU.Build.0 = Release_BIE6_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp|Any CPU.ActiveCfg = Release_ML_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Cpp|Any CPU.Build.0 = Release_ML_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Mono|Any CPU.ActiveCfg = Release_ML_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_ML_Mono|Any CPU.Build.0 = Release_ML_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Cpp|Any CPU.ActiveCfg = Release_STANDALONE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Cpp|Any CPU.Build.0 = Release_STANDALONE_Cpp|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Mono|Any CPU.ActiveCfg = Release_STANDALONE_Mono|Any CPU
		{B21DBDE3-5D6F-4726-93AB-CC3CC68BAE7D}.Release_STANDALONE_Mono|Any CPU.Build.0 = Release_STANDALONE_Mono|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DD5C0A5D-03F1-4CC3-8B4D-E10834908C5A}
	EndGlobalSection
EndGlobal

```

`src/nuget.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <config>
        <add key="dependencyVersion" value="Lowest" />
    </config>

    <packageRestore>
        <!-- Allow NuGet to download missing packages -->
        <add key="enabled" value="True" />

        <!-- Automatically check for missing packages during build in Visual Studio -->
        <add key="automatic" value="True" />
    </packageRestore>

    <packageSources>
        <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
        <add key="BepInEx" value="https://nuget.bepinex.dev/v3/index.json" />
    </packageSources>
</configuration>

```

`src/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="HarmonyX" version="2.5.2" targetFramework="net35" />
  <package id="Iced" version="1.15.0" targetFramework="net472" />
  <package id="Il2CppAssemblyUnhollower.BaseLib" version="0.4.22" targetFramework="net472" />
  <package id="ILRepack.Lib.MSBuild.Task" version="2.0.18.2" targetFramework="net35" />
  <package id="Mono.Cecil" version="0.10.4" targetFramework="net35" />
  <package id="Samboy063.Tomlet" version="3.1.3" targetFramework="net472" />
  <package id="UniverseLib" version="1.2.17" targetFramework="net35" />
  <package id="UniverseLib.Analyzers" version="1.0.3" targetFramework="net35" developmentDependency="true" />
</packages>
```