Project Path: arc_gmh5225_revert-mapper_ksttxh82

Source Tree:

```txt
arc_gmh5225_revert-mapper_ksttxh82
├── README.md
├── entry.cpp
├── revert-mapper.vcxproj
├── revert-mapper.vcxproj.filters
└── utils
    ├── lsass.hpp
    ├── mapper.hpp
    └── remote_process.hpp

```

`README.md`:

```md
# revert-mapper
DLL Mapper to map x64 DLLs in WoW64 (Windows on Windows64) processes from a remote process. Finds imports by remotely traversing the export table of loaded DLLs in the target process.
```

`entry.cpp`:

```cpp
#include "utils/mapper.hpp"
#include "utils/remote_process.hpp"
#include "utils/lsass.hpp"

#include <fstream>

void initialize(void* DLL_Param, void* injection_flag) {
	using namespace mapper;

	DLL_PARAM* pdllParam = reinterpret_cast<DLL_PARAM*>(DLL_Param);
	int* injectionflag = reinterpret_cast<int*>(injection_flag);

	auto handle = lsass::steal_handle(lsass::find_pid_by_name(pdllParam->TargetProcessName));

	if (!handle) {
		*injectionflag = false;
		return;
	}

	remote::detail::process = handle;
	auto addy = remote::find_remote_export("kernel32.dll", "VirtualUnlock");

	// cleanup
	VirtualFree((void*)pdllParam->pTargetDllBuffer, 0, MEM_RELEASE);
	
	remote::detail::process = INVALID_HANDLE_VALUE;
	*injectionflag = true;
	return;
}

long __stdcall DllMain(HMODULE module, std::uint32_t reason, void* lp)
{
	if (reason == DLL_PROCESS_ATTACH)
		initialize(lp, module);

	return true;
}
```

`revert-mapper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e8a7196b-8847-4323-b07c-c9be2d9a59a4}</ProjectGuid>
    <RootNamespace>revertmapper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils\lsass.hpp" />
    <ClInclude Include="utils\mapper.hpp" />
    <ClInclude Include="utils\remote_process.hpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`revert-mapper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="utils\mapper.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils\lsass.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils\remote_process.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="README.md" />
  </ItemGroup>
</Project>
```

`utils/lsass.hpp`:

```hpp
#pragma once

#pragma comment (lib, "ntdll.lib")
#pragma comment(lib, "Wtsapi32.lib")

#include <TlHelp32.h>
#include <WtsApi32.h>

#ifndef LSASS_H
namespace mapper::lsass {

	namespace detail {

		constexpr auto SYSTEMHANDLEINFORMATION = 16;

		typedef struct _SYSTEM_HANDLE {
			ULONG ProcessId;
			UCHAR ObjectTypeNumber;
			UCHAR Flags;
			USHORT Handle;
			PVOID Object;
			ACCESS_MASK GrantedAccess;
		} SYSTEM_HANDLE, * PSYSTEM_HANDLE;

		typedef struct _SYSTEM_HANDLE_INFORMATION {
			ULONG HandleCount; // Or NumberOfHandles if you prefer
			SYSTEM_HANDLE Handles[1];
		} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

		typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
			DWORD UniqueProcessId;
			WORD HandleType;
			USHORT HandleValue;
			PVOID Object;
			ACCESS_MASK GrantedAccess;
		} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

		typedef struct _OBJECT_TYPE_INFORMATION {
			UNICODE_STRING TypeName;
			ULONG TotalNumberOfObjects;
			ULONG TotalNumberOfHandles;
			ULONG TotalPagedPoolUsage;
			ULONG TotalNonPagedPoolUsage;
			ULONG TotalNamePoolUsage;
			ULONG TotalHandleTableUsage;
			ULONG HighWaterNumberOfObjects;
			ULONG HighWaterNumberOfHandles;
			ULONG HighWaterPagedPoolUsage;
			ULONG HighWaterNonPagedPoolUsage;
			ULONG HighWaterNamePoolUsage;
			ULONG HighWaterHandleTableUsage;
			ULONG InvalidAttributes;
			GENERIC_MAPPING GenericMapping;
			ULONG ValidAccessMask;
			BOOLEAN SecurityRequired;
			BOOLEAN MaintainHandleCount;
			UCHAR TypeIndex;
			CHAR ReservedByte;
			ULONG PoolType;
			ULONG DefaultPagedPoolCharge;
			ULONG DefaultNonPagedPoolCharge;
		} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

		EXTERN_C NTSTATUS NTAPI NtDuplicateObject(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, BOOLEAN, ULONG);
	}

	// speaks for itself
	auto find_pid_by_name(const std::string& name) -> std::size_t {
		auto hn = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

		if (!hn)
			return 0;

		PROCESSENTRY32 pe = { 0 };
		pe.dwSize = sizeof PROCESSENTRY32;

		if (Process32First(hn, &pe))
		{
			do
			{
				if (std::strstr(pe.szExeFile, name.c_str()) != nullptr)
				{
					CloseHandle(hn);
					return pe.th32ProcessID;
				}
			} while (Process32Next(hn, &pe));
		}

		return 0;
	}

	VOID message_box(LPCSTR Text, LPCSTR Title)
	{
		DWORD response;

		WTSSendMessageA(WTS_CURRENT_SERVER_HANDLE,       // hServer
			WTSGetActiveConsoleSessionId(),  // ID for the console seesion (1)
			const_cast<LPSTR>(Title),        // MessageBox Caption
			strlen(Title),                   // 
			const_cast<LPSTR>(Text),         // MessageBox Text
			strlen(Text),                    // 
			MB_OK,                           // Buttons, etc
			10,                              // Timeout period in seconds
			&response,                       // What button was clicked (if bWait == TRUE)
			TRUE);                          // bWait - Blocks until user click
	}

	// steal a handle from ()
	auto steal_handle(const std::size_t targetProcessId) -> HANDLE {
		NTSTATUS status;
		ULONG handleInfoSize = 0x10000;

		auto handleInfo = reinterpret_cast<detail::PSYSTEM_HANDLE_INFORMATION>(malloc(handleInfoSize));

		while ((status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)detail::SYSTEMHANDLEINFORMATION, handleInfo, handleInfoSize, nullptr)) == STATUS_INFO_LENGTH_MISMATCH)
			handleInfo = reinterpret_cast<detail::PSYSTEM_HANDLE_INFORMATION>(realloc(handleInfo, handleInfoSize *= 2));

		if (!NT_SUCCESS(status))
		{
			message_box("Error: Handle Not Found", "Error!");
		}

		for (auto i = 0; i < handleInfo->HandleCount; i++)
		{
			auto handle = handleInfo->Handles[i];

			const auto process = reinterpret_cast<HANDLE>(handle.Handle);
			if (handle.ProcessId == GetCurrentProcessId() && GetProcessId(process) == targetProcessId)
				return process;
		}

		free(handleInfo);

		return nullptr;
	}

}

#define LSASS_H
#endif
```

`utils/mapper.hpp`:

```hpp
#pragma once

#ifndef MAPPER_H
#define MAPPER_H

#include <Windows.h>
#include <winternl.h>
#include <string>
#include <cstdint>
#include <ntstatus.h>
#include <Psapi.h>
#include <vector>

#include "remote_process.hpp"

#define RELOC_FLAG32(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(RelInfo) ((RelInfo >> 0x0C) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

namespace mapper {

	struct DLL_PARAM {
		std::uint64_t pTargetDllBuffer;
		std::uint64_t addressOfHookFunction;
		char TargetProcessName[32];
	};

	auto map_into_remote(std::intptr_t buffer) -> bool {
		if (!buffer)
			return false;

		auto dos = reinterpret_cast<PIMAGE_DOS_HEADER>(buffer);
		auto nt = reinterpret_cast<PIMAGE_NT_HEADERS>(buffer + dos->e_lfanew);

		// simple access
		auto file = &nt->FileHeader;
		auto optional = &nt->OptionalHeader;

		auto remote_buffer = remote::alloc_virtual_memory(nt->OptionalHeader.SizeOfImage);

		auto section_header = IMAGE_FIRST_SECTION(nt);

		// write headers
		if (!remote::write(remote_buffer, (void*)buffer, optional->SizeOfHeaders))
		{
			remote::free(remote_buffer);
			return false;
		}

		// fix imports
		std::uint8_t* location_delta = (std::uint8_t*)(remote_buffer - optional->ImageBase);
		if (location_delta)
		{
			if (!optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
				return 0;

			auto* pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(buffer + optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
			while (pRelocData->VirtualAddress)
			{
				UINT AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				WORD* pRelativeInfo = reinterpret_cast<WORD*>(pRelocData + 1);
				for (UINT i = 0; i != AmountOfEntries; ++i, ++pRelativeInfo)
				{
					if (RELOC_FLAG(*pRelativeInfo))
					{
						UINT_PTR* pPatch = reinterpret_cast<UINT_PTR*>(buffer + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
						*pPatch += reinterpret_cast<UINT_PTR>(location_delta);
					}
				}
				pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(pRelocData) + pRelocData->SizeOfBlock);
			}
		}

		// these are all in x64 mem space
		auto possible_imports = { "ntdll.dll", "wow64.dll", "wow64win.dll", "wow64cpu.dll" };

		// fixing imprts
		if (optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
		{
			auto* pImportDescr = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(buffer + optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
			while (pImportDescr->Name)
			{
				char* szMod = reinterpret_cast<char*>(buffer + pImportDescr->Name);

				HINSTANCE hDll = LoadLibraryA(szMod);

				ULONG_PTR* pThunkRef = reinterpret_cast<ULONG_PTR*>(buffer + pImportDescr->OriginalFirstThunk);
				ULONG_PTR* pFuncRef = reinterpret_cast<ULONG_PTR*>(buffer + pImportDescr->FirstThunk);

				if (!pThunkRef)
					pThunkRef = pFuncRef;

				for (; *pThunkRef; ++pThunkRef, ++pFuncRef)
				{
					if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef))
						*pFuncRef = reinterpret_cast<ULONG_PTR>(GetProcAddress(hDll, reinterpret_cast<char*>(*pThunkRef & 0xFFFF)));
					else
					{
						auto* pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(buffer + (*pThunkRef));
						*pFuncRef = reinterpret_cast<ULONG_PTR>(GetProcAddress(hDll, pImport->Name));
					}
				}

				++pImportDescr;
			}
		}

		// free libraries we loaded because we don't want to leave dangled 
		// stuff around, note that these DLLs are NEVER in lsass so if they
		// were to check this could hbe dangerous
		for (const auto& imp : possible_imports)
			if (std::strcmp(imp, "ntdll.dll") != 0)
				FreeLibrary(GetModuleHandle(imp));

		// write sections 
		for (size_t i = 0; i < file->NumberOfSections; ++i, ++section_header)
		{
			if (section_header->SizeOfRawData)
			{
				if (!remote::write(remote_buffer + section_header->VirtualAddress, (void*)(buffer + section_header->PointerToRawData), section_header->SizeOfRawData))
				{
					remote::free(remote_buffer);
					return false;
				}
			}
		}

		/*
		if (optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
		{
			auto* pTLS = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(remote_buffer + optional->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
			auto* pCallback = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(pTLS->AddressOfCallBacks);
			for (; pCallback && *pCallback; ++pCallback)
				(*pCallback)(base, DLL_PROCESS_ATTACH, nullptr);
		}
		*/
		auto hthread = CreateRemoteThreadEx(remote::detail::process, 0, 0, (LPTHREAD_START_ROUTINE)(remote_buffer + optional->AddressOfEntryPoint), (void*)remote_buffer, 0, 0, 0);
		NtClose(hthread);
	}
}

#endif
```

`utils/remote_process.hpp`:

```hpp
#pragma once

#ifndef REMOTE_PROCESS_H
#define REMOTE_PROCESS_H

#include "mapper.hpp"
#include "lsass.hpp"
#include <codecvt>
#include <algorithm>

#include <fstream>
#include <map>

namespace mapper::remote{

	namespace detail {
		inline auto process = INVALID_HANDLE_VALUE;

		typedef struct _PROCESS_BASIC_INFORMATION64 {
			ULONGLONG Reserved1;
			ULONGLONG PebBaseAddress;
			ULONGLONG Reserved2[2];
			ULONGLONG UniqueProcessId;
			ULONGLONG Reserved3;
		} PROCESS_BASIC_INFORMATION64;

		struct s_remote_module {
			char name[256];
			std::uintptr_t base;

			friend auto operator<(const s_remote_module& a, const s_remote_module& b) -> const bool {
				return a.base < b.base;
			}
		};

		inline std::vector<s_remote_module> _module_cache;
		inline std::map<s_remote_module, std::vector< std::pair<std::string, std::uint64_t>>> _remote_export_cache;
	}

	auto set_target(HANDLE handle) -> void {
		detail::process = handle;
	}

	auto check_process_handle() -> bool {
		return detail::process != INVALID_HANDLE_VALUE;
	}

	auto read_pbi(detail::PROCESS_BASIC_INFORMATION64& info) -> void {
		if (!check_process_handle()) {
			info.UniqueProcessId = -1;
			return;
		}

		auto status = NtQueryInformationProcess(detail::process, ProcessBasicInformation, &info, sizeof info, NULL);

		if (!NT_SUCCESS(status)) {
			info.UniqueProcessId = -1;
			return;
		}

		// success, lol!
	}

	auto rpm(std::uint64_t address, std::uint8_t* buffer, std::size_t len) -> bool {
		static auto ntdll = GetModuleHandle("ntdll.dll");

		if (!ntdll)
			return false;

		static auto rpm_proc = GetProcAddress(ntdll, "NtReadVirtualMemory");

		if (!rpm_proc)
			return false;

		return NT_SUCCESS(reinterpret_cast<NTSTATUS(NTAPI*)(HANDLE,
			PVOID,
			PVOID,
			ULONG,
			PULONG)>(rpm_proc)(detail::process, (void*)address, buffer, len, nullptr));
	}

	auto read_peb_buffer() -> std::vector<std::uint8_t> {
		detail::PROCESS_BASIC_INFORMATION64 pbi = { 0 };
		read_pbi(pbi);

		if (pbi.UniqueProcessId == -1)
			return std::vector<std::uint8_t>{};

		std::vector<std::uint8_t> res = std::vector<std::uint8_t>(sizeof PEB);
		std::fill(std::begin(res), std::end(res), 0);

		if (!rpm(pbi.PebBaseAddress, &res[0], sizeof PEB))
			return std::vector<std::uint8_t>{};

		return res;
	}

	template <typename T>
	auto read(std::uint64_t address, std::size_t len = sizeof T) -> std::vector<std::uint8_t> {

		std::vector<std::uint8_t> buffer = std::vector<std::uint8_t>(len);
		std::fill(std::begin(buffer), std::end(buffer), 0);

		if (!rpm(address, &buffer[0], len))
			return std::vector<std::uint8_t>{};

		return buffer;

	}

	template <typename T>
	auto read_type(std::uint64_t address, std::size_t len = sizeof T) -> T {
		T buffer{ 0 };

		if (!rpm(address, (std::uint8_t*)&buffer, len))
			return T{ 0 };

		return buffer;
	}

	// Names of modules 
	std::string convert_unicode_to_utf8(std::vector<uint8_t>& raw_bytes)
	{
		std::vector<uint16_t> unicode(raw_bytes.size() >> 1, 0);
		memcpy(unicode.data(), raw_bytes.data(), raw_bytes.size());

		std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;

		const std::wstring wide_string(unicode.begin(), unicode.end());
		const std::string utf8_string = converter.to_bytes(wide_string);

		return utf8_string;
	}

	auto free(std::intptr_t address) {
		return VirtualFreeEx(detail::process, (void*)address, 0, MEM_RELEASE);
	}

	auto write(std::intptr_t address, void* buffer, std::size_t size) {
		return WriteProcessMemory(detail::process, (void*)address, buffer, size, nullptr);
	}

	auto get_module_cache() -> std::vector<detail::s_remote_module> {
		if (detail::_module_cache.size() > 0)
			return detail::_module_cache;

		return std::vector<detail::s_remote_module>{0};
	}

	// Had to write this specifically in char or else the STL didn't want to use it in std::transform calls, for what reason I don't know
	// but ig it has something to do with type forcing.
	char to_lower(char in)
	{
		return std::tolower(in);
	}

	// TODO: CACHE THIS
	auto find_remote_export(std::string mod, std::string name, bool x86 = true) {
		// check if we have it cached
		auto _cache = get_module_cache();

		if (!_cache.size() > 0)
			_cache = get_remote_modules(); // else just get it and populate the cache

		// check size again
		if (!_cache.size() > 0)
			return (std::uintptr_t)0;

		// check if we have a handle
		if (!check_process_handle())
			return (std::uintptr_t)0;

		std::vector<detail::s_remote_module> cache;

		// copy cache
		std::copy_if(std::begin(_cache), std::end(_cache), std::back_inserter(cache), 
			[&](detail::s_remote_module mod) -> auto { 
			return x86 ? mod.base <= (std::numeric_limits<std::uint32_t>::max)() : mod.base >= (std::numeric_limits<std::uint32_t>::max)(); 
		});

		// lower names for simplicity sake
		std::transform(std::begin(cache), std::end(cache), std::begin(cache), [&](detail::s_remote_module mod) -> auto {
			std::transform(std::begin(mod.name), std::end(mod.name), std::begin(mod.name), to_lower);
			return mod;
		});

		// lower fn name
		std::transform(std::begin(name), std::end(name), std::begin(name), to_lower);

		// find temp module
		auto rm_module = std::find_if(std::begin(cache), std::end(cache), [&](detail::s_remote_module remote) -> bool { return std::strstr(remote.name, mod.c_str()); });

		if (rm_module == std::end(cache))
			return (std::uintptr_t)0;
		
		std::vector<std::uint8_t> temp = read<IMAGE_DOS_HEADER>(rm_module->base);
		auto dos = reinterpret_cast<PIMAGE_DOS_HEADER>(temp.data());
		
		// Do the thing.
		const auto do_the_thing = [&](IMAGE_DATA_DIRECTORY* edirp) -> std::uintptr_t {

			// if this moulde hasn't been cached before
			if (detail::_remote_export_cache.find(*rm_module) == std::end(detail::_remote_export_cache)) {
				auto addy_to_img_export_descriptor = rm_module->base + edirp->VirtualAddress;

				auto _ied = read_type<IMAGE_EXPORT_DIRECTORY>(addy_to_img_export_descriptor);
				auto ied = &_ied;

				auto table_length = sizeof DWORD * ied->NumberOfFunctions;

				auto address_table_buffer = read<DWORD>(rm_module->base + ied->AddressOfFunctions, table_length);
				auto address_table = reinterpret_cast<DWORD*>(address_table_buffer.data());

				auto name_table_buffer = read<DWORD>(rm_module->base + ied->AddressOfNames, table_length);
				auto name_table = reinterpret_cast<DWORD*>(name_table_buffer.data());

				auto ordinal_table_buffer = read<WORD>(rm_module->base + ied->AddressOfNameOrdinals, sizeof WORD * ied->NumberOfFunctions);
				auto ordinal_table = reinterpret_cast<WORD*>(ordinal_table_buffer.data());

				for (unsigned int i = 0; i < ied->NumberOfFunctions; ++i)
				{
					auto name_address = (rm_module->base + name_table[i]);
					auto name_buffer = read<char>(name_address, (sizeof std::uint8_t) * 64);
					char* fn_name = (char*)name_buffer.data();

					auto to_normal = std::string(fn_name);
					std::transform(std::begin(to_normal), std::end(to_normal), std::begin(to_normal), to_lower);

					auto relative_offset = address_table[ordinal_table[i]];
					auto exported_address = ((std::uint64_t)rm_module->base + relative_offset);

					detail::_remote_export_cache[*rm_module].push_back(std::make_pair(to_normal, exported_address));

					name_buffer.clear();
				}
			}

			
			auto entry = detail::_remote_export_cache.find(*rm_module);
			// it's cached now, check if it exists and look up the function
			if (entry != std::end(detail::_remote_export_cache))
			{
				auto res = std::find_if(std::begin(entry->second), std::end(entry->second), [&](std::pair<std::string, std::uint64_t> p) -> bool {
					return std::strstr(p.first.c_str(), name.c_str());
				});

				if (res != std::end(entry->second))
					return res->second;

				return 0;
			}
			else return 0;
		};

		/*
			As far as I know there's no easy way to switch typedefs depending on a runtime variable,
			so do it the hard way for now
		
		*/
		if (x86) {
			temp = read<IMAGE_NT_HEADERS32>(rm_module->base + dos->e_lfanew);
			auto nt = (PIMAGE_NT_HEADERS32)(temp.data());

			DWORD old_prot;
			VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, PAGE_READWRITE, &old_prot);

			auto edirp = &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

			std::uintptr_t addy;
			if (addy = do_the_thing(edirp))
			{
				VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, old_prot, &old_prot);
				return addy;
			}
			
			VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, old_prot, &old_prot);
		}
		else {
			temp = read<IMAGE_NT_HEADERS>(rm_module->base + dos->e_lfanew);
			auto nt = (PIMAGE_NT_HEADERS)(temp.data());

			DWORD old_prot;
			VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, PAGE_READWRITE, &old_prot);

			auto edirp = &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
			
			std::uintptr_t addy;
			if (addy = do_the_thing(edirp))
			{
				VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, old_prot, &old_prot);
				return addy;
			}

			VirtualProtectEx(remote::detail::process, (void*)rm_module->base, nt->OptionalHeader.SizeOfHeaders, old_prot, &old_prot);
		}

		return (std::uintptr_t)0;
	}

	// alloc memory for our DLL in x64 memory space
	auto alloc_virtual_memory(std::size_t size) -> std::intptr_t {

		int tries = 0;

		auto address = VirtualAllocEx(detail::process, (void*)(std::numeric_limits<std::uint32_t>::max)(), size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

		tries++;

		if (!((std::intptr_t)address > (std::numeric_limits<std::uint32_t>::max)()))
		{
			do {
				address = (void*)((std::intptr_t)(std::numeric_limits<std::uint32_t>::max)() + 0x1000 * tries);
				tries++;

				address = VirtualAllocEx(detail::process, address, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

				if ((std::intptr_t)address > (std::numeric_limits<std::uint32_t>::max)())
					return (std::intptr_t)address;

				VirtualFreeEx(detail::process, address, 0, MEM_RELEASE);

			} while (tries < 10);
		}
		else {
			return (std::intptr_t)address;
		}

		return false;
	}

	std::vector<detail::s_remote_module> get_remote_modules() {
		if (!check_process_handle())
			return std::vector<detail::s_remote_module>{0};

		HMODULE hMods[1024];
		DWORD cbNeeded;
		unsigned int i;

		std::vector<detail::s_remote_module> res;

		if (EnumProcessModulesEx(detail::process, hMods, sizeof hMods, &cbNeeded, LIST_MODULES_ALL))
		{
			for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++)
			{
				TCHAR szModName[MAX_PATH];

				// Get the full path to the module's file.
				if (GetModuleFileNameEx(detail::process, hMods[i], szModName,
					sizeof(szModName) / sizeof(TCHAR)))
				{
					// Print the module name and handle value.
					detail::s_remote_module mod{0};
					sprintf_s(mod.name, "%s", szModName);
					mod.base = (std::uint64_t)hMods[i];

					res.push_back(mod);
				}
			}
		}

		detail::_module_cache = res;
		return res;
	}
}

#endif
```