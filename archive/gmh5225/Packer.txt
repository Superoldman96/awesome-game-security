Project Path: arc_gmh5225_Packer_3qcis5il

Source Tree:

```txt
arc_gmh5225_Packer_3qcis5il
├── Packer
│   ├── InputInfo.cpp
│   ├── InputInfo.h
│   ├── LoadIng.cpp
│   ├── LoadIng.h
│   ├── Packer.aps
│   ├── Packer.cpp
│   ├── Packer.h
│   ├── Packer.rc
│   ├── Packer.vcxproj
│   ├── Packer.vcxproj.filters
│   ├── Packer.vcxproj.user
│   ├── PackerDlg.cpp
│   ├── PackerDlg.h
│   ├── PictureEx.cpp
│   ├── PictureEx.h
│   ├── Stub.dll
│   ├── Task.cpp
│   ├── Task.h
│   ├── aplib.h
│   ├── aplib.lib
│   ├── info.h
│   ├── res
│   │   ├── Packer.ico
│   │   ├── Packer.rc2
│   │   ├── icon1.ico
│   │   └── timg.gif
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── targetver.h
│   ├── util.cpp
│   └── util.h
├── Packer.sln
├── README.md
├── ScreenShot
│   ├── 1.PNG
│   ├── 1.jpg
│   ├── 2.PNG
│   ├── 2.jpg
│   ├── 3.PNG
│   ├── 3.jpg
│   ├── 4.PNG
│   ├── 4.jpg
│   └── 5.PNG
└── Stub
    ├── Stub.vcxproj
    ├── Stub.vcxproj.filters
    ├── Stub.vcxproj.user
    ├── aplib.h
    ├── aplib.lib
    ├── dllmain.cpp
    ├── info.h
    ├── msvcrt.lib
    ├── stdafx.cpp
    ├── stdafx.h
    └── targetver.h

```

`Packer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Packer", "Packer\Packer.vcxproj", "{68DB45A6-D30C-4515-9C74-39514C4CB54E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Stub", "Stub\Stub.vcxproj", "{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Debug|x64.ActiveCfg = Debug|x64
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Debug|x64.Build.0 = Debug|x64
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Debug|x86.ActiveCfg = Debug|Win32
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Debug|x86.Build.0 = Debug|Win32
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Release|x64.ActiveCfg = Release|x64
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Release|x64.Build.0 = Release|x64
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Release|x86.ActiveCfg = Release|Win32
		{68DB45A6-D30C-4515-9C74-39514C4CB54E}.Release|x86.Build.0 = Release|Win32
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Debug|x64.ActiveCfg = Debug|x64
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Debug|x64.Build.0 = Debug|x64
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Debug|x86.ActiveCfg = Debug|Win32
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Debug|x86.Build.0 = Debug|Win32
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Release|x64.ActiveCfg = Release|x64
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Release|x64.Build.0 = Release|x64
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Release|x86.ActiveCfg = Release|Win32
		{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Packer/InputInfo.cpp`:

```cpp
// InputInfo.cpp : 实现文件
//

#include "stdafx.h"
#include "Packer.h"
#include "InputInfo.h"
#include "afxdialogex.h"
#include "string"
#include "info.h"
// InputInfo 对话框

IMPLEMENT_DYNAMIC(InputInfo, CDialogEx)

InputInfo::InputInfo(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_DIALOG2, pParent)
{

}

InputInfo::~InputInfo()
{
}

void InputInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(InputInfo, CDialogEx)
	ON_BN_CLICKED(IDOK, &InputInfo::OnBnClickedOk)
END_MESSAGE_MAP()


// InputInfo 消息处理程序


void InputInfo::OnBnClickedOk()
{
	char buf[512];
	GetDlgItemTextA(IDC_PASSWORD, buf, 512);
	gApplet.info.strPassword.clear();
	if (strlen(buf) > 15)
	{
		MessageBox("密码长度不能超过14位", "提示", MB_ICONWARNING);
		return;
	}
	if (gApplet.info.setTime)
		SetDate();
	if (gApplet.info.setPassword)
		gApplet.info.strPassword = buf;
	OnOK();

}

void InputInfo::SetDate()
{
	CDateTimeCtrl *tCdateTimeCtrlDate = (CDateTimeCtrl *)GetDlgItem(IDC_DATETIMEPICKER_DATE);
	CTime time;
	tCdateTimeCtrlDate->GetTime(time);
	gApplet.info.time.year = time.GetYear();
	gApplet.info.time.month = time.GetMonth();
	gApplet.info.time.day = time.GetDay();
	CDateTimeCtrl *tCdateTimeCtrlTime = (CDateTimeCtrl *)GetDlgItem(IDC_DATETIMEPICKER_TIME);
	tCdateTimeCtrlTime->GetTime(time);
	gApplet.info.time.hour = time.GetHour();
	gApplet.info.time.minute = time.GetMinute();
	gApplet.info.time.second = time.GetSecond();
}


BOOL InputInfo::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	if (!gApplet.info.setTime)
	{
		SetDisable(IDC_DATETIMEPICKER_DATE);
		SetDisable(IDC_DATETIMEPICKER_TIME);
	}
	if (!gApplet.info.setPassword)
	{
		SetDisable(IDC_PASSWORD);
	}

	// TODO:  在此添加额外的初始化

	return TRUE;  // return TRUE unless you set the focus to a control
				  // 异常: OCX 属性页应返回 FALSE
}

void InputInfo::SetDisable(DWORD dwId)
{
	GetDlgItem(dwId)->EnableWindow(FALSE);
}

```

`Packer/InputInfo.h`:

```h
#pragma once


// InputInfo 对话框

class InputInfo : public CDialogEx
{
	DECLARE_DYNAMIC(InputInfo)

public:
	InputInfo(CWnd* pParent = NULL);   // 标准构造函数
	virtual ~InputInfo();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG2 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnBnClickedOk();
	void SetDate();
	virtual BOOL OnInitDialog();
	void SetDisable(DWORD dwId);
};

```

`Packer/LoadIng.cpp`:

```cpp
// LoadIng.cpp : 实现文件
//

#include "stdafx.h"
#include "Packer.h"
#include "LoadIng.h"
#include "afxdialogex.h"
#include "Task.h"
#include "util.h"

LoadIng*currentDlg;
// LoadIng 对话框

IMPLEMENT_DYNAMIC(LoadIng, CDialogEx)

LoadIng::LoadIng(CWnd* pParent)
	: CDialogEx(IDD_DIALOG1, pParent)
{

}

LoadIng::~LoadIng()
{
	if (m_loadPic.IsPlaying())
		m_loadPic.Stop();
}


void LoadIng::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LOADINGPIC, m_loadPic);
}


BEGIN_MESSAGE_MAP(LoadIng, CDialogEx)
END_MESSAGE_MAP()


// LoadIng 消息处理程序


void ThreadFunc1(void *arglist)
{
	Task *task = new Task();
	replaceStringA(gApplet.filePath);
	gApplet.success = false;
	task->Start(gApplet.filePath.c_str());
	currentDlg->ShowWindow(SW_HIDE);
	if (gApplet.success)
		MessageBoxW(gApplet.loadingHwnd, L"加壳成功", L"Packer", 0);
	SendMessageA(gApplet.loadingHwnd, WM_CLOSE, 0, 0);
	gApplet.loadingHwnd = NULL;
	currentDlg = nullptr;
	delete task;
	_endthread();
}

BOOL LoadIng::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	currentDlg = this;
	// TODO:  在此添加额外的初始化
	gApplet.loadingHwnd = this->m_hWnd;
	if (m_loadPic.Load(MAKEINTRESOURCE(IDR_GIF1), _T("Gif")))
	{
		m_loadPic.CenterWindow();
		m_loadPic.Draw();
	}
	_beginthread(ThreadFunc1, NULL, NULL);
	return TRUE;  // return TRUE unless you set the focus to a control
				  // 异常: OCX 属性页应返回 FALSE
}

```

`Packer/LoadIng.h`:

```h
#pragma once
#include "PictureEx.h"
#include "afxwin.h"

// LoadIng 对话框

class LoadIng : public CDialogEx
{
	DECLARE_DYNAMIC(LoadIng)

public:
	LoadIng( CWnd* pParent = NULL);   // 标准构造函数
	virtual ~LoadIng();

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_DIALOG1 };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

	DECLARE_MESSAGE_MAP()
public:
	virtual BOOL OnInitDialog();
	CPictureEx m_loadPic;
	bool m_isSetPassword;
	bool m_isSetTimeOut;
};

```

`Packer/Packer.cpp`:

```cpp

// Packer.cpp : 定义应用程序的类行为。
//

#include "stdafx.h"
#include "Packer.h"
#include "PackerDlg.h"
GlobalApplet gApplet;
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CPackerApp

BEGIN_MESSAGE_MAP(CPackerApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CPackerApp 构造

CPackerApp::CPackerApp()
{
	// 支持重新启动管理器
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: 在此处添加构造代码，
	// 将所有重要的初始化放置在 InitInstance 中
}


// 唯一的一个 CPackerApp 对象

CPackerApp theApp;


// CPackerApp 初始化

BOOL CPackerApp::InitInstance()
{
	// 如果一个运行在 Windows XP 上的应用程序清单指定要
	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
	//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// 将它设置为包括所有要在应用程序中使用的
	// 公共控件类。
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	AfxEnableControlContainer();

	// 创建 shell 管理器，以防对话框包含
	// 任何 shell 树视图控件或 shell 列表视图控件。
	CShellManager *pShellManager = new CShellManager;

	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// 标准初始化
	// 如果未使用这些功能并希望减小
	// 最终可执行文件的大小，则应移除下列
	// 不需要的特定初始化例程
	// 更改用于存储设置的注册表项
	// TODO: 应适当修改该字符串，
	// 例如修改为公司或组织名
	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

	CPackerDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: 在此放置处理何时用
		//  “确定”来关闭对话框的代码
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: 在此放置处理何时用
		//  “取消”来关闭对话框的代码
	}
	else if (nResponse == -1)
	{
		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");
		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");
	}

	// 删除上面创建的 shell 管理器。
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

#ifndef _AFXDLL
	ControlBarCleanUp();
#endif

	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
	//  而不是启动应用程序的消息泵。
	return FALSE;
}


```

`Packer/Packer.h`:

```h

// Packer.h : PROJECT_NAME 应用程序的主头文件
//

#pragma once

#ifndef __AFXWIN_H__
	#error "在包含此文件之前包含“stdafx.h”以生成 PCH 文件"
#endif

#include "resource.h"		// 主符号


// CPackerApp: 
// 有关此类的实现，请参阅 Packer.cpp
//

class CPackerApp : public CWinApp
{
public:
	CPackerApp();

// 重写
public:
	virtual BOOL InitInstance();

// 实现

	DECLARE_MESSAGE_MAP()
};

extern CPackerApp theApp;
```

`Packer/Packer.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)\r\n"
    "LANGUAGE 4, 2\r\n"
    "#include ""res\\Packer.rc2""  // 非 Microsoft Visual C++ 编辑的资源\r\n"
    "#include ""l.CHS\\afxres.rc""      // 标准组件\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""l.CHS\\afxribbon.rc""   // MFC 功能区和控制条资源\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\Packer.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 170, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "关于 Packer"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,14,14,20,20
    LTEXT           "Packer，1.0 版 Author LoveQuietly",IDC_STATIC,42,14,114,8,SS_NOPREFIX
    LTEXT           "Copyright (C) 2017",IDC_STATIC,42,26,114,8
    DEFPUSHBUTTON   "确定",IDOK,113,41,50,14,WS_GROUP
END

IDD_PACKER_DIALOG DIALOGEX 0, 0, 281, 76
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_ACCEPTFILES | WS_EX_APPWINDOW
CAPTION "Packer"
FONT 9, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "确定",IDOK,70,51,50,14
    PUSHBUTTON      "取消",IDCANCEL,137,51,50,14
    EDITTEXT        IDC_FILENAME,57,18,151,14,ES_AUTOHSCROLL | ES_READONLY
    PUSHBUTTON      ". . .",IDC_BUTTON1,210,18,23,14
    CONTROL         "添加密码",IDC_ADD_PASSWORD,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,72,37,46,10
    CONTROL         "设置过期",IDC_ADD_TIMEOUT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,134,37,46,10
END

IDD_LOADINGDIALOG DIALOGEX 0, 0, 159, 152
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Packing"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    CTEXT           "Static",IDC_LOADINGPIC,0,0,19,8,SS_CENTERIMAGE
END

IDD_INPUTDIALOG DIALOGEX 0, 0, 199, 111
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "信息"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "确定",IDOK,49,77,50,14
    PUSHBUTTON      "取消",IDCANCEL,121,77,50,14
    LTEXT           "密码",IDC_STATIC,26,22,18,8
    EDITTEXT        IDC_PASSWORD,49,19,121,14,ES_PASSWORD | ES_AUTOHSCROLL
    CONTROL         "",IDC_DATETIMEPICKER_TIME,"SysDateTimePick32",DTS_RIGHTALIGN | DTS_UPDOWN | WS_TABSTOP | 0x8,120,46,49,15
    CONTROL         "",IDC_DATETIMEPICKER_DATE,"SysDateTimePick32",DTS_RIGHTALIGN | WS_TABSTOP,49,46,65,15
    LTEXT           "日期",IDC_STATIC,22,50,18,8
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "080404B0"
        BEGIN
            VALUE "CompanyName", "TODO: <公司名>"
            VALUE "FileDescription", "Packer"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "Packer.exe"
            VALUE "LegalCopyright", "TODO:  (C) <公司名>。  保留所有权利。"
            VALUE "OriginalFilename", "Packer.exe"
            VALUE "ProductName", "TODO: <产品名>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x804, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 163
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_PACKER_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 274
        TOPMARGIN, 7
        BOTTOMMARGIN, 72
    END

    IDD_LOADINGDIALOG, DIALOG
    BEGIN
        BOTTOMMARGIN, 151
    END

    IDD_INPUTDIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 192
        TOPMARGIN, 7
        BOTTOMMARGIN, 105
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_PACKER_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_LOADINGDIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_INPUTDIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_ABOUTBOX AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// GIF
//

IDR_GIF1                GIF                     "res\\timg.gif"


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "关于 Packer(&A)..."
END

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE 4, 2
#include "res\Packer.rc2"  // 非 Microsoft Visual C++ 编辑的资源
#include "l.CHS\afxres.rc"      // 标准组件
#if !defined(_AFXDLL)
#include "l.CHS\afxribbon.rc"   // MFC 功能区和控制条资源
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Packer/Packer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{68DB45A6-D30C-4515-9C74-39514C4CB54E}</ProjectGuid>
    <RootNamespace>Packer</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Dynamic</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalOptions>/SAFESEH:NO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0804</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="aplib.h" />
    <ClInclude Include="info.h" />
    <ClInclude Include="InputInfo.h" />
    <ClInclude Include="LoadIng.h" />
    <ClInclude Include="Packer.h" />
    <ClInclude Include="PackerDlg.h" />
    <ClInclude Include="PictureEx.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="Task.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="InputInfo.cpp" />
    <ClCompile Include="LoadIng.cpp" />
    <ClCompile Include="Packer.cpp" />
    <ClCompile Include="PackerDlg.cpp" />
    <ClCompile Include="PictureEx.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Task.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Packer.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\Packer.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\Packer.ico" />
    <Image Include="res\timg.gif" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="Packer.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`Packer/Packer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Packer.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="info.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="aplib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Task.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="PictureEx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="LoadIng.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="InputInfo.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="PackerDlg.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Packer.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="PackerDlg.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Task.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="LoadIng.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="PictureEx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="InputInfo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Packer.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\Packer.rc2">
      <Filter>资源文件</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\Packer.ico">
      <Filter>资源文件</Filter>
    </Image>
    <Image Include="res\timg.gif">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Packer/Packer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Packer/PackerDlg.cpp`:

```cpp

// PackerDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "Packer.h"
#include "PackerDlg.h"
#include "afxdialogex.h"
#include "util.h"
#include "vector"
#include "aplib.h"
#include "Task.h"
#include "info.h"
#include "Loading.h"
#include "InputInfo.h"
#pragma comment(lib, "aplib.lib")
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
#pragma warning(disable: 4996)

// 用于应用程序“关于”菜单项的 CAboutDlg 对话框

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

	// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持

// 实现
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()


// CPackerDlg 对话框
CPackerDlg::CPackerDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_PACKER_DIALOG, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CPackerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_FILENAME, m_FileName);
}

BEGIN_MESSAGE_MAP(CPackerDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDOK, &CPackerDlg::OnBnClickedOk)
	ON_WM_DROPFILES()
	ON_BN_CLICKED(IDC_BUTTON1, &CPackerDlg::OnBnClickedButton1)
END_MESSAGE_MAP()


// CPackerDlg 消息处理程序
BOOL CPackerDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// 将“关于...”菜单项添加到系统菜单中。

	// IDM_ABOUTBOX 必须在系统命令范围内。
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
	//  执行此操作
	SetIcon(m_hIcon, TRUE);			// 设置大图标
	SetIcon(m_hIcon, FALSE);		// 设置小图标

	return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE
}

void CPackerDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

void CPackerDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // 用于绘制的设备上下文

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// 使图标在工作区矩形中居中
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// 绘制图标
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CPackerDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}


void CPackerDlg::OnBnClickedOk()
{
	// TODO: 在此添加控件通知处理程序代码
	if (gApplet.filePath.empty())
	{
		MessageBoxA("路径不能为空","Packer",MB_ICONWARNING);
		return;
	}

	setInfo();
	if (gApplet.info.setTime|| gApplet.info.setPassword)
	{
		InputInfo input;
		if (input.DoModal() != IDOK)
		{
			return;
		}
	}
	LoadIng load;
	load.DoModal();
}


void CPackerDlg::OnDropFiles(HDROP hDropInfo)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	int DropCount = DragQueryFile(hDropInfo, -1, NULL, 0);//取得被拖动文件的数目  
	if (DropCount > 1)
	{
		MessageBox("目前只支持一个文件拖拽","提示",0);
		DragFinish(hDropInfo);
		return;
	}
	CHAR wsStr[MAX_PATH];
	DragQueryFileA(hDropInfo, 0, wsStr, MAX_PATH);
	std::string wsFileKind=wsStr;
	wsFileKind=wsFileKind.substr(wsFileKind.length()-3,3);
	if (stricmp(wsFileKind.c_str(),"exe")!=0)
	{
		MessageBox("只支持拖拽EXE文件","提示" , 0);
		DragFinish(hDropInfo);
		return;
	}
	DragFinish(hDropInfo);
	SetDlgItemTextA(IDC_FILENAME,wsStr);
	gApplet.filePath = wsStr;
	CDialogEx::OnDropFiles(hDropInfo);
}


void CPackerDlg::OnBnClickedButton1()
{
	// TODO: 在此添加控件通知处理程序代码
	TCHAR szFilter[] = _T("可执行文件(*.exe)|*.exe|所有文件(*.*)|*.*||");
	CFileDialog fileDialog(TRUE,_T("exe"),NULL,0,szFilter,this);
	CString csFileName;
	if (IDOK == fileDialog.DoModal())
	{
		csFileName = fileDialog.GetPathName();
		std::string wsFileKind=csFileName.GetBuffer();
		wsFileKind=wsFileKind.substr(wsFileKind.length() - 3, 3);
		if (stricmp(wsFileKind.c_str(), "exe") != 0)
		{
			MessageBox("只支持EXE文件", "提示", 0);
			return;
		}
		SetDlgItemTextA(IDC_FILENAME, csFileName.GetBuffer());
		gApplet.filePath = csFileName.GetBuffer();
	}
}

void CPackerDlg::setInfo()
{
	CButton *cBtnPassword = (CButton*)GetDlgItem(IDC_ADD_PASSWORD);
	CButton *cBtnTimeout = (CButton*)GetDlgItem(IDC_ADD_TIMEOUT);
	if (cBtnPassword->GetCheck())
	{
		gApplet.info.setPassword = true;
	}
	else
	{
		gApplet.info.setPassword = false;
	}
	if (cBtnTimeout->GetCheck())
	{
		gApplet.info.setTime = true;
	}
	else
	{
		gApplet.info.setTime = false;
	}
}

```

`Packer/PackerDlg.h`:

```h

// PackerDlg.h : 头文件
//

#pragma once
#include "vector"
#include "info.h"
#include "afxcmn.h"
#include "afxwin.h"

// CPackerDlg 对话框
class CPackerDlg : public CDialogEx
{
// 构造
public:
	CPackerDlg(CWnd* pParent = NULL);	// 标准构造函数

// 对话框数据
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_PACKER_DIALOG };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 支持


// 实现
protected:
	HICON m_hIcon;

	// 生成的消息映射函数
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
	CProgressCtrl m_progress;
	afx_msg void OnBnClickedOk();
	afx_msg void OnDropFiles(HDROP hDropInfo);
	CEdit m_FileName;

	afx_msg void OnBnClickedButton1();
	void setInfo();
private:

};

```

`Packer/PictureEx.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////
// PictureEx.cpp: implementation of the CPictureEx class.
//
// Picture displaying control with support for the following formats:
// GIF (including animated GIF87a and GIF89a), JPEG, BMP, WMF, ICO, CUR
// 
// Written by Oleg Bykov (oleg_bykoff@rsdn.ru)
// Copyright (c) 2001
//
// To use CPictureEx, follow these steps:
//   - place a static control on your dialog (either a text or a bitmap)
//   - change its identifier to something else (e.g. IDC_MYPIC)
//   - associate a CStatic with it using ClassWizard
//   - in your dialog's header file replace CStatic with CPictureEx
//     (don't forget to #include "PictureEx.h" and add 
//     PictureEx.h and PictureEx.cpp to your project)
//   - call one of the overloaded CPictureEx::Load() functions somewhere
//     (OnInitDialog is a good place to start)
//   - if the preceding Load() succeeded call Draw()
//  
// You can also add the control by defining a member variable of type 
// CPictureEx, calling CPictureEx::Create (derived from CStatic), then 
// CPictureEx::Load and CPictureEx::Draw.
//
// By default, the control initializes its background to COLOR_3DFACE
// (see CPictureEx::PrepareDC()). You can change the background by
// calling CPictureEx::SetBkColor(COLORREF) after CPictureEx::Load().
//
// I decided to leave in the class the functions to write separate frames from 
// animated GIF to disk. If you want to use them, uncomment #define GIF_TRACING 
// and an appropriate section in CPictureEx::Load(HGLOBAL, DWORD). These functions 
// won't be compiled and linked to your project unless you uncomment #define GIF_TRACING,
// so you don't have to worry.
// 
// Warning: this code hasn't been subject to a heavy testing, so
// use it on your own risk. The author accepts no liability for the 
// possible damage caused by this code.
//
// Version 1.0  7 Aug 2001
//              Initial release
//
// Version 1.1  6 Sept 2001
//              ATL version of the class
//
// Version 1.2  14 Oct 2001
//              - Fixed a problem with loading GIFs from resources
//                in MFC-version of the class for multi-modules apps.
//                Thanks to Ruben Avila-Carretero for finding this out.
//
//              - Got rid of waitable timer in ThreadAnimation()
//                Now CPictureEx[Wnd] works in Win95 too.
//                Thanks to Alex Egiazarov and Wayne King for the idea.
//
//              - Fixed a visual glitch of using SetBkColor.
//                Thanks to Kwangjin Lee for finding this out.
//
// Version 1.3  10 Nov 2001
//              - Fixed a DC leak. One DC leaked per each UnLoad()
//                (forgot to put a ReleaseDC() in the end of 
//                CPictureExWnd::PrepareDC() function).
//
//              - Now it is possible to set a clipping rectangle using
//                CPictureEx[Wnd]::SetPaintRect(const LPRECT) function.
//                The LPRECT parameter tells the class what portion of
//                a picture should it display. If the clipping rect is 
//                not set, the whole picture is shown.
//                Thanks to Fabrice Rodriguez for the idea.
//
//              - Added support for Stop/Draw. Now you can Stop() an
//                animated GIF, then Draw() it again, it will continue
//                animation from the frame it was stopped on. You can 
//                also know if a GIF is currently playing with the 
//                IsPlaying() function.
//             
//              - Got rid of math.h and made m_bExitThread volatile. 
//                Thanks to Piotr Sawicki for the suggestion.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PictureEx.h"
#include <process.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Nested structures member functions
//////////////////////////////////////////////////////////////////////

inline int CPictureEx::TGIFControlExt::GetPackedValue(enum ControlExtValues Value)
{
	int nRet = (int)m_cPacked;
	switch (Value)
	{
	case GCX_PACKED_DISPOSAL:
		nRet = (nRet & 28) >> 2;
		break;

	case GCX_PACKED_USERINPUT:
		nRet = (nRet & 2) >> 1;
		break;

	case GCX_PACKED_TRANSPCOLOR:
		nRet &= 1;
		break;
	};

	return nRet;
}

inline int CPictureEx::TGIFLSDescriptor::GetPackedValue(enum LSDPackedValues Value)
{
	int nRet = (int)m_cPacked;

	switch (Value)
	{
	case LSD_PACKED_GLOBALCT:
		nRet = nRet >> 7;
		break;

	case LSD_PACKED_CRESOLUTION:
		nRet = ((nRet & 0x70) >> 4) + 1;
		break;

	case LSD_PACKED_SORT:
		nRet = (nRet & 8) >> 3;
		break;

	case LSD_PACKED_GLOBALCTSIZE:
		nRet &= 7;
		break;
	};

	return nRet;
}

inline int CPictureEx::TGIFImageDescriptor::GetPackedValue(enum IDPackedValues Value)
{
	int nRet = (int)m_cPacked;

	switch (Value)
	{
	case ID_PACKED_LOCALCT:
		nRet >>= 7;
		break;

	case ID_PACKED_INTERLACE:
		nRet = ((nRet & 0x40) >> 6);
		break;

	case ID_PACKED_SORT:
		nRet = (nRet & 0x20) >> 5;
		break;

	case ID_PACKED_LOCALCTSIZE:
		nRet &= 7;
		break;
	};

	return nRet;
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPictureEx::CPictureEx()
{
	// check structures size
	ASSERT(sizeof(TGIFImageDescriptor) == 10);
	ASSERT(sizeof(TGIFAppExtension)    == 14);
	ASSERT(sizeof(TGIFPlainTextExt)    == 15);
	ASSERT(sizeof(TGIFLSDescriptor)    ==  7);
	ASSERT(sizeof(TGIFControlExt)	   ==  8);
	ASSERT(sizeof(TGIFCommentExt)	   ==  2);
	ASSERT(sizeof(TGIFHeader)		   ==  6);

	m_pGIFLSDescriptor = NULL;
	m_pGIFHeader	   = NULL;
	m_pPicture		   = NULL;
	m_pRawData		   = NULL;
	m_hThread		   = NULL;
	m_hBitmap          = NULL;
	m_hMemDC		   = NULL;

	m_hDispMemDC       = NULL;
	m_hDispMemBM       = NULL;
	m_hDispOldBM       = NULL;

	m_bIsInitialized   = FALSE;
	m_bExitThread	   = FALSE;
	m_bIsPlaying       = FALSE;
	m_bIsGIF		   = FALSE;
	m_clrBackground    = RGB(255,255,255); // white by default
	m_nGlobalCTSize    = 0;
	m_nCurrOffset	   = 0;
	m_nCurrFrame	   = 0;
	m_nDataSize		   = 0;
	m_PictureSize.cx = m_PictureSize.cy = 0;
	SetRect(&m_PaintRect,0,0,0,0);

	m_hExitEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
}

CPictureEx::~CPictureEx()
{
	UnLoad();
	CloseHandle(m_hExitEvent);
}

BEGIN_MESSAGE_MAP(CPictureEx, CStatic)
	//{{AFX_MSG_MAP(CPictureEx)
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CPictureEx::Load(HGLOBAL hGlobal, DWORD dwSize)
{
	IStream *pStream = NULL;
	UnLoad();

	if (!(m_pRawData = reinterpret_cast<unsigned char*> (GlobalLock(hGlobal))) )
	{
		TRACE(_T("Load: Error locking memory\n"));
		return FALSE;
	};

	m_nDataSize = dwSize;
	m_pGIFHeader = reinterpret_cast<TGIFHeader *> (m_pRawData);

	if ((memcmp(&m_pGIFHeader->m_cSignature,"GIF",3) != 0) &&
		((memcmp(&m_pGIFHeader->m_cVersion,"87a",3) != 0) ||
		 (memcmp(&m_pGIFHeader->m_cVersion,"89a",3) != 0)) )
	{
	// it's neither GIF87a nor GIF89a
	// do the default processing

		// clear GIF variables
		m_pRawData = NULL;
		GlobalUnlock(hGlobal);

		// don't delete memory on object's release
		if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)
			return FALSE;

		if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
			reinterpret_cast<LPVOID *>(&m_pPicture)) != S_OK)
		{
			pStream->Release();
			return FALSE;
		};
		pStream->Release();

		// store picture's size

		long hmWidth;
		long hmHeight;
		m_pPicture->get_Width(&hmWidth);
		m_pPicture->get_Height(&hmHeight);

		HDC hDC = ::GetDC(m_hWnd);
		m_PictureSize.cx = MulDiv(hmWidth, GetDeviceCaps(hDC,LOGPIXELSX), 2540);
		m_PictureSize.cy = MulDiv(hmHeight, GetDeviceCaps(hDC,LOGPIXELSY), 2540);
		::ReleaseDC(m_hWnd,hDC);
	}
	else
	{
		// it's a GIF
		m_bIsGIF = TRUE;
		m_pGIFLSDescriptor = reinterpret_cast<TGIFLSDescriptor *>
			(m_pRawData + sizeof(TGIFHeader));
		if (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT) == 1)
		{
			// calculate the globat color table size
			m_nGlobalCTSize = static_cast<int>
				(3* (1 << (m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE)+1)));
			// get the background color if GCT is present
			unsigned char *pBkClr = m_pRawData + sizeof(TGIFHeader) + 
				sizeof(TGIFLSDescriptor) + 3*m_pGIFLSDescriptor->m_cBkIndex;
			m_clrBackground = RGB(pBkClr[0],pBkClr[1],pBkClr[2]);
		};

		// store the picture's size
		m_PictureSize.cx = m_pGIFLSDescriptor->m_wWidth;
		m_PictureSize.cy = m_pGIFLSDescriptor->m_wHeight;

		// determine frame count for this picture
		UINT nFrameCount=0;
		ResetDataPointer();
		while (SkipNextGraphicBlock())
			nFrameCount++;

#ifdef GIF_TRACING
		TRACE(
			_T(" -= GIF encountered\n"
			   "Logical Screen dimensions = %dx%d\n"
			   "Global color table = %d\n"
			   "Color depth = %d\n"
			   "Sort flag = %d\n"
			   "Size of Global Color Table = %d\n"
			   "Background color index = %d\n"
			   "Pixel aspect ratio = %d\n"
			   "Frame count = %d\n"
			   "Background color = %06Xh\n\n"
			  ),
			m_pGIFLSDescriptor->m_wWidth,
			m_pGIFLSDescriptor->m_wHeight,
			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCT),
			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_CRESOLUTION),
			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_SORT),
			m_pGIFLSDescriptor->GetPackedValue(LSD_PACKED_GLOBALCTSIZE),
			m_pGIFLSDescriptor->m_cBkIndex,
			m_pGIFLSDescriptor->m_cPixelAspect,
			nFrameCount,
			m_clrBackground
			);
		EnumGIFBlocks();
#endif

		if (nFrameCount == 0) // it's an empty GIF!
		{
			m_pRawData = NULL;
			GlobalUnlock(hGlobal);
			return FALSE;
		};

		// now check the frame count
		// if there's only one frame, no need to animate this GIF
		// therefore, treat it like any other pic

		if (nFrameCount == 1)
		{
			// clear GIF variables
			m_pRawData = NULL;
			GlobalUnlock(hGlobal);

			// don't delete memory on object's release
			if (CreateStreamOnHGlobal(hGlobal,FALSE,&pStream) != S_OK)
				return FALSE;

			if (OleLoadPicture(pStream,dwSize,FALSE,IID_IPicture,
				(LPVOID *)&m_pPicture) != S_OK)
			{
				pStream->Release();
				return FALSE;
			};

			pStream->Release();
		}
		else
		{
		// if, on the contrary, there are several frames
		// then store separate frames in an array

			TFrame frame;
			UINT nBlockLen;
			HGLOBAL hFrameData;
			UINT nCurFrame = 0;

			ResetDataPointer();
			while (hFrameData = GetNextGraphicBlock(&nBlockLen,
				&frame.m_nDelay, &frame.m_frameSize,
				&frame.m_frameOffset, &frame.m_nDisposal) )
			{
				#ifdef GIF_TRACING
				//////////////////////////////////////////////
				// uncomment the following strings if you want 
				// to write separate frames on disk
				//
				//	CString szName;
				//	szName.Format(_T("%.4d.gif"),nCurFrame);
				//	WriteDataOnDisk(szName,hFrameData,nBlockLen);
				//	nCurFrame++;
				#endif // GIF_TRACING

				IStream *pStream = NULL;

				// delete memory on object's release
				if (CreateStreamOnHGlobal(hFrameData,TRUE,&pStream) != S_OK)
				{
					GlobalFree(hFrameData);
					continue;
				};

				if (OleLoadPicture(pStream,nBlockLen,FALSE,
					IID_IPicture,
					reinterpret_cast<LPVOID *>(&frame.m_pPicture)) != S_OK)
				{
					pStream->Release();
					continue;
				};
				pStream->Release();
			
				// everything went well, add this frame
				m_arrFrames.push_back(frame);
			};

			// clean after ourselves
			m_pRawData = NULL;
			GlobalUnlock(hGlobal);

			if (m_arrFrames.empty()) // couldn't load any frames
				return FALSE;
		};
	}; // if (!IsGIF...

	return PrepareDC(m_PictureSize.cx,m_PictureSize.cy);
}

void CPictureEx::UnLoad()
{
	Stop();
	if (m_pPicture)
	{
		m_pPicture->Release();
		m_pPicture = NULL;
	};
	
	std::vector<TFrame>::iterator it;
	for (it=m_arrFrames.begin();it<m_arrFrames.end();it++)
		(*it).m_pPicture->Release();
	m_arrFrames.clear();

	if (m_hMemDC)
	{
		SelectObject(m_hMemDC,m_hOldBitmap);
		::DeleteDC(m_hMemDC);
		::DeleteObject(m_hBitmap);
		m_hMemDC  = NULL;
		m_hBitmap = NULL;
	};

	if (m_hDispMemDC)
	{
		SelectObject(m_hDispMemDC,m_hDispOldBM);
		::DeleteDC(m_hDispMemDC);
		::DeleteObject(m_hDispMemBM);
		m_hDispMemDC  = NULL;
		m_hDispMemBM = NULL;
	};

	SetRect(&m_PaintRect,0,0,0,0);
	m_pGIFLSDescriptor = NULL;
	m_pGIFHeader	   = NULL;
	m_pRawData		   = NULL;
	m_hThread		   = NULL;
	m_bIsInitialized   = FALSE;
	m_bExitThread	   = FALSE;
	m_bIsGIF		   = FALSE;
	m_clrBackground    = RGB(255,255,255); // white by default
	m_nGlobalCTSize	   = 0;
	m_nCurrOffset	   = 0;
	m_nCurrFrame	   = 0;
	m_nDataSize		   = 0;
}

BOOL CPictureEx::Draw()
{
	if (!m_bIsInitialized)
	{
		TRACE(_T("Call one of the CPictureEx::Load() member functions before calling Draw()\n"));
		return FALSE;
	};

	if (IsAnimatedGIF())
	{
	// the picture needs animation
	// we'll start the thread that will handle it for us
	
		unsigned int nDummy;
		m_hThread = (HANDLE) _beginthreadex(NULL,0,_ThreadAnimation,this,
			CREATE_SUSPENDED,&nDummy);
		if (!m_hThread)
		{
			TRACE(_T("Draw: Couldn't start a GIF animation thread\n"));
			return FALSE;
		} 
		else 
			ResumeThread(m_hThread);
	} 
	else
	{
		if (m_pPicture)
		{
			long hmWidth;
			long hmHeight;
			m_pPicture->get_Width(&hmWidth);
			m_pPicture->get_Height(&hmHeight);
			if (m_pPicture->Render(m_hMemDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy, 
				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)
			{
				Invalidate(FALSE);
				return TRUE;
			};
		};
	};

	return FALSE;	
}

SIZE CPictureEx::GetSize() const
{
	return m_PictureSize;
}

BOOL CPictureEx::Load(LPCTSTR szFileName)
{
	ASSERT(szFileName);
	
	CFile file;
	HGLOBAL hGlobal;
	DWORD dwSize;

	if (!file.Open(szFileName,
				CFile::modeRead | 
				CFile::shareDenyWrite) )
	{
		TRACE(_T("Load (file): Error opening file %s\n"),szFileName);
		return FALSE;
	};

	dwSize = file.GetLength();
	hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);
	if (!hGlobal)
	{
		TRACE(_T("Load (file): Error allocating memory\n"));
		return FALSE;
	};
	
	char *pData = reinterpret_cast<char*>(GlobalLock(hGlobal));
	if (!pData)
	{
		TRACE(_T("Load (file): Error locking memory\n"));
		GlobalFree(hGlobal);
		return FALSE;
	};

	TRY
	{
		file.Read(pData,dwSize);
	}
	CATCH(CFileException, e);                                          
	{
		TRACE(_T("Load (file): An exception occured while reading the file %s\n"),
			szFileName);
		GlobalFree(hGlobal);
		e->Delete();
		file.Close();
		return FALSE;
	}
	END_CATCH
	GlobalUnlock(hGlobal);
	file.Close();

	BOOL bRetValue = Load(hGlobal,dwSize);
	GlobalFree(hGlobal);
	return bRetValue;
}

BOOL CPictureEx::Load(LPCTSTR szResourceName, LPCTSTR szResourceType)
{
	ASSERT(szResourceName);
	ASSERT(szResourceType);

	HRSRC hPicture = FindResource(AfxGetResourceHandle(),szResourceName,szResourceType);
	HGLOBAL hResData;
	if (!hPicture || !(hResData = LoadResource(AfxGetResourceHandle(),hPicture)))
	{
		TRACE(_T("Load (resource): Error loading resource %s\n"),szResourceName);
		return FALSE;
	};
	DWORD dwSize = SizeofResource(AfxGetResourceHandle(),hPicture);

	// hResData is not the real HGLOBAL (we can't lock it)
	// let's make it real

	HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,dwSize);
	if (!hGlobal)
	{
		TRACE(_T("Load (resource): Error allocating memory\n"));
		FreeResource(hResData);
		return FALSE;
	};
	
	char *pDest = reinterpret_cast<char *> (GlobalLock(hGlobal));
	char *pSrc = reinterpret_cast<char *> (LockResource(hResData));
	if (!pSrc || !pDest)
	{
		TRACE(_T("Load (resource): Error locking memory\n"));
		GlobalFree(hGlobal);
		FreeResource(hResData);
		return FALSE;
	};
	CopyMemory(pDest,pSrc,dwSize);
	FreeResource(hResData);
	GlobalUnlock(hGlobal);

	BOOL bRetValue = Load(hGlobal,dwSize);
	GlobalFree(hGlobal);
	return bRetValue;
}

void CPictureEx::ResetDataPointer()
{
	// skip header and logical screen descriptor
	m_nCurrOffset = 
		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;
}

BOOL CPictureEx::SkipNextGraphicBlock()
{
	if (!m_pRawData) return FALSE;

	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data

	enum GIFBlockTypes nBlock;

	nBlock = GetNextBlock();

	while ((nBlock != BLOCK_CONTROLEXT) &&
		   (nBlock != BLOCK_IMAGE) &&
		   (nBlock != BLOCK_PLAINTEXT) &&
		   (nBlock != BLOCK_UNKNOWN) &&
		   (nBlock != BLOCK_TRAILER) )
	{
		if (!SkipNextBlock()) return NULL;
		nBlock = GetNextBlock();
	};

	if ((nBlock == BLOCK_UNKNOWN) ||
		(nBlock == BLOCK_TRAILER))
		return FALSE;

	// it's either a control ext.block, an image or a plain text

	if (GetNextBlockLen() <= 0) return FALSE;

	if (nBlock == BLOCK_CONTROLEXT)
	{
		if (!SkipNextBlock()) return FALSE;
		nBlock = GetNextBlock();

		// skip everything until we meet an image block or a plain-text block
		while ((nBlock != BLOCK_IMAGE) &&
			   (nBlock != BLOCK_PLAINTEXT) &&
			   (nBlock != BLOCK_UNKNOWN) &&
			   (nBlock != BLOCK_TRAILER) )
		{
			if (!SkipNextBlock()) return NULL;
			nBlock = GetNextBlock();
		};

		if ((nBlock == BLOCK_UNKNOWN) ||
			(nBlock == BLOCK_TRAILER))
			return FALSE;
	};

	// skip the found data block (image or plain-text)
	if (!SkipNextBlock()) return FALSE;

	return TRUE;
}

UINT CPictureEx::GetSubBlocksLen(UINT nStartingOffset) const
{
	UINT nRet = 0;
	UINT nCurOffset = nStartingOffset;
	
	while (m_pRawData[nCurOffset] != 0)
	{
		nRet += m_pRawData[nCurOffset]+1;
		nCurOffset += m_pRawData[nCurOffset]+1;
	};

	return nRet+1;
}

enum CPictureEx::GIFBlockTypes CPictureEx::GetNextBlock() const
{
	switch(m_pRawData[m_nCurrOffset])
	{
	case 0x21:
	// extension block
		switch(m_pRawData[m_nCurrOffset+1])
		{
		case 0x01:
		// plain text extension
			return BLOCK_PLAINTEXT;
			break;

		case 0xF9:
		// graphic control extension
			return BLOCK_CONTROLEXT;
			break;

		case 0xFE:
		// comment extension
			return BLOCK_COMMEXT;
			break;

		case 0xFF:
		// application extension
			return BLOCK_APPEXT;
			break;
		};
		break;
	
	case 0x3B:
	// trailer
		return BLOCK_TRAILER;
		break;

	case 0x2C:
	// image data
		return BLOCK_IMAGE;
		break;
	};

	return BLOCK_UNKNOWN;
}

BOOL CPictureEx::SkipNextBlock()
{
	if (!m_pRawData) return FALSE;

	int nLen = GetNextBlockLen();
	if ((nLen <= 0) || ((m_nCurrOffset+nLen) > m_nDataSize))
		return FALSE;

	m_nCurrOffset += nLen;
	return TRUE;
}

int CPictureEx::GetNextBlockLen() const
{
	GIFBlockTypes nBlock = GetNextBlock();

	int nTmp;

	switch(nBlock)
	{
	case BLOCK_UNKNOWN:
		return -1;
		break;

	case BLOCK_TRAILER:
		return 1;
		break;

	case BLOCK_APPEXT:
		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFAppExtension));
		if (nTmp > 0)
			return sizeof(TGIFAppExtension)+nTmp;
		break;

	case BLOCK_COMMEXT:
		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFCommentExt));
		if (nTmp > 0)
			return sizeof(TGIFCommentExt)+nTmp;
		break;

	case BLOCK_CONTROLEXT:
		return sizeof(TGIFControlExt);
		break;

	case BLOCK_PLAINTEXT:
		nTmp = GetSubBlocksLen(m_nCurrOffset+sizeof(TGIFPlainTextExt));
		if (nTmp > 0)
			return sizeof(TGIFPlainTextExt)+nTmp;
		break;

	case BLOCK_IMAGE:
		TGIFImageDescriptor *pIDescr = 
			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);
		int nLCTSize = (int)
			(pIDescr->GetPackedValue(ID_PACKED_LOCALCT)*3*
			(1 << (pIDescr->GetPackedValue(ID_PACKED_LOCALCTSIZE)+1)));

		int nTmp = GetSubBlocksLen(m_nCurrOffset+
			sizeof(TGIFImageDescriptor) + nLCTSize + 1);
		if (nTmp > 0)
			return sizeof(TGIFImageDescriptor) + nLCTSize + 1 + nTmp;
		break;
	};

	return 0;
}

UINT WINAPI CPictureEx::_ThreadAnimation(LPVOID pParam)
{
	ASSERT(pParam);
	CPictureEx *pPic = reinterpret_cast<CPictureEx *> (pParam);

	pPic->m_bIsPlaying = TRUE;
	pPic->ThreadAnimation();
	pPic->m_bIsPlaying = FALSE;

	// this thread has finished its work so we close the handle
	CloseHandle(pPic->m_hThread); 
	// and init the handle to zero (so that Stop() doesn't Wait on it)
	pPic->m_hThread = 0;
	return 0;
}

void CPictureEx::ThreadAnimation()
{
	// first, restore background (for stop/draw support)
	// disposal method #2
	if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)
	{
		HBRUSH hBrush = CreateSolidBrush(m_clrBackground);
		if (hBrush)
		{
			RECT rect = {
				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
				m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,
				m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };
			FillRect(m_hMemDC,&rect,hBrush);
			DeleteObject(hBrush);
		};
	} 
	else
		// disposal method #3
		if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )
		{
			// put it back
			BitBlt(m_hMemDC,
				m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
				m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
				m_arrFrames[m_nCurrFrame].m_frameSize.cx,
				m_arrFrames[m_nCurrFrame].m_frameSize.cy,
				m_hDispMemDC,0,0, SRCCOPY);
			// init variables
			SelectObject(m_hDispMemDC,m_hDispOldBM);
			DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;
			DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;
		};

	while (!m_bExitThread)
	{
		if (m_arrFrames[m_nCurrFrame].m_pPicture)
		{
		///////////////////////////////////////////////////////
		// Before rendering a frame we should take care of what's 
		// behind that frame. TFrame::m_nDisposal will be our guide:
		//   0 - no disposal specified (do nothing)
		//   1 - do not dispose (again, do nothing)
		//   2 - restore to background color (m_clrBackground)
		//   3 - restore to previous

			//////// disposal method #3
			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 3)
			{
				// prepare a memory DC and store the background in it
				m_hDispMemDC = CreateCompatibleDC(m_hMemDC);
				m_hDispMemBM = CreateCompatibleBitmap(m_hMemDC,
							m_arrFrames[m_nCurrFrame].m_frameSize.cx,
							m_arrFrames[m_nCurrFrame].m_frameSize.cy);
				
				if (m_hDispMemDC && m_hDispMemBM)
				{
					m_hDispOldBM = reinterpret_cast<HBITMAP> (SelectObject(m_hDispMemDC,m_hDispMemBM));
					BitBlt(m_hDispMemDC,0,0,
						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
						m_hMemDC,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
						SRCCOPY);
				};
			};
			///////////////////////

			long hmWidth;
			long hmHeight;
			m_arrFrames[m_nCurrFrame].m_pPicture->get_Width(&hmWidth);
			m_arrFrames[m_nCurrFrame].m_pPicture->get_Height(&hmHeight);

			if (m_arrFrames[m_nCurrFrame].m_pPicture->Render(m_hMemDC, 
				m_arrFrames[m_nCurrFrame].m_frameOffset.cx, 
				m_arrFrames[m_nCurrFrame].m_frameOffset.cy, 
				m_arrFrames[m_nCurrFrame].m_frameSize.cx, 
				m_arrFrames[m_nCurrFrame].m_frameSize.cy, 
				0, hmHeight, hmWidth, -hmHeight, NULL) == S_OK)
			{
				Invalidate(FALSE);
			};
			
			if (m_bExitThread) break;

			// if the delay time is too short (like in old GIFs), wait for 100ms
			if (m_arrFrames[m_nCurrFrame].m_nDelay < 5) 
				WaitForSingleObject(m_hExitEvent, 100);
			else
				WaitForSingleObject(m_hExitEvent, 10*m_arrFrames[m_nCurrFrame].m_nDelay);

			if (m_bExitThread) break;

			// disposal method #2
			if (m_arrFrames[m_nCurrFrame].m_nDisposal == 2)
			{
				HBRUSH hBrush = CreateSolidBrush(m_clrBackground);
				if (hBrush)
				{
					RECT rect = {
						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cx + m_arrFrames[m_nCurrFrame].m_frameSize.cx,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cy + m_arrFrames[m_nCurrFrame].m_frameSize.cy };
					FillRect(m_hMemDC,&rect,hBrush);
					DeleteObject(hBrush);
				};
			} 
			else
				if (m_hDispMemDC && (m_arrFrames[m_nCurrFrame].m_nDisposal == 3) )
				{
					// put it back
					BitBlt(m_hMemDC,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cx,
						m_arrFrames[m_nCurrFrame].m_frameOffset.cy,
						m_arrFrames[m_nCurrFrame].m_frameSize.cx,
						m_arrFrames[m_nCurrFrame].m_frameSize.cy,
						m_hDispMemDC,0,0, SRCCOPY);
					// init variables
					SelectObject(m_hDispMemDC,m_hDispOldBM);
					DeleteDC(m_hDispMemDC); m_hDispMemDC = NULL;
					DeleteObject(m_hDispMemBM); m_hDispMemBM = NULL;
				};
		};
		m_nCurrFrame++;
		if (m_nCurrFrame == m_arrFrames.size())
		{
			m_nCurrFrame
				= 0; 
		// init the screen for the first frame,
			HBRUSH hBrush = CreateSolidBrush(m_clrBackground);
			if (hBrush)
			{
				RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};
				FillRect(m_hMemDC,&rect,hBrush);
				DeleteObject(hBrush);
			};
		};
	};
}

void CPictureEx::Stop()
{
	m_bIsPlaying = FALSE;
	m_bExitThread = TRUE;
	SetEvent(m_hExitEvent);
	if (m_hThread)
	{
		// we'll wait for 5 seconds then continue execution
		WaitForSingleObject(m_hThread,5000);
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}

	// make it possible to Draw() again
	ResetEvent(m_hExitEvent);
	m_bExitThread = FALSE;
}

HGLOBAL CPictureEx::GetNextGraphicBlock(UINT *pBlockLen, 
	UINT *pDelay, SIZE *pBlockSize, SIZE *pBlockOffset, 
	UINT *pDisposal)
{
	if (!m_pRawData) return NULL;

	// GIF header + LSDescriptor [+ GCT] [+ Control block] + Data

	*pDisposal = 0;
	enum GIFBlockTypes nBlock;
	nBlock = GetNextBlock();

	while (
		(nBlock != BLOCK_CONTROLEXT) &&
		(nBlock != BLOCK_IMAGE) &&
		(nBlock != BLOCK_PLAINTEXT) &&
		(nBlock != BLOCK_UNKNOWN) &&
		(nBlock != BLOCK_TRAILER)
		)
	{
		if (!SkipNextBlock()) return NULL;
		nBlock = GetNextBlock();
	};

	if ((nBlock == BLOCK_UNKNOWN) ||
		(nBlock == BLOCK_TRAILER))
		return NULL;

	// it's either a control ext.block, an image or a plain text

	int nStart = m_nCurrOffset;
	int nBlockLen = GetNextBlockLen();

	if (nBlockLen <= 0) return NULL;

	if (nBlock == BLOCK_CONTROLEXT)
	{
		// get the following data
		TGIFControlExt *pControl = 
			reinterpret_cast<TGIFControlExt *> (&m_pRawData[m_nCurrOffset]);
		// store delay time
		*pDelay = pControl->m_wDelayTime;
		// store disposal method
		*pDisposal = pControl->GetPackedValue(GCX_PACKED_DISPOSAL);

		if (!SkipNextBlock()) return NULL;
		nBlock = GetNextBlock();
		
		// skip everything until we find data to display 
		// (image block or plain-text block)
		
		while (
			(nBlock != BLOCK_IMAGE) &&
			(nBlock != BLOCK_PLAINTEXT) &&
			(nBlock != BLOCK_UNKNOWN) &&
			(nBlock != BLOCK_TRAILER)
			)
		{
			if (!SkipNextBlock()) return NULL;
			nBlock = GetNextBlock();
			nBlockLen += GetNextBlockLen();
		};

		if ((nBlock == BLOCK_UNKNOWN) || (nBlock == BLOCK_TRAILER))
			return NULL;
		nBlockLen += GetNextBlockLen();
	}
	else
		*pDelay = -1; // to indicate that there was no delay value

	if (nBlock == BLOCK_IMAGE)
	{
		// store size and offsets
		TGIFImageDescriptor *pImage = 
			reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);
		pBlockSize->cx = pImage->m_wWidth;
		pBlockSize->cy = pImage->m_wHeight;
		pBlockOffset->cx = pImage->m_wLeftPos;
		pBlockOffset->cy = pImage->m_wTopPos;
	};

	if (!SkipNextBlock()) return NULL;

	HGLOBAL hGlobal = GlobalAlloc(GMEM_FIXED,
		sizeof(TGIFHeader) +
		sizeof(TGIFLSDescriptor) +
		m_nGlobalCTSize +
		nBlockLen + 
		1);  // for the trailer

	if (!hGlobal) return NULL;

	int nOffset = 0; 

	// GMEM_FIXED means we get a pointer
	unsigned char *pGlobal = reinterpret_cast<unsigned char *> (hGlobal);

	CopyMemory(pGlobal,m_pRawData, 
		sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize);
	nOffset += sizeof(TGIFHeader)+sizeof(TGIFLSDescriptor)+m_nGlobalCTSize;

	CopyMemory(pGlobal + nOffset,&m_pRawData[nStart], nBlockLen);
	nOffset += nBlockLen;

	pGlobal[nOffset] = 0x3B; // trailer
	nOffset++;

	*pBlockLen = nOffset;

	return hGlobal;
}

BOOL CPictureEx::IsGIF() const
{
	return m_bIsGIF;
}

BOOL CPictureEx::IsAnimatedGIF() const
{
	return (m_bIsGIF && (m_arrFrames.size() > 1));
}

BOOL CPictureEx::IsPlaying() const
{
	return m_bIsPlaying;
}

int CPictureEx::GetFrameCount() const
{
	if (!IsAnimatedGIF())
		return 0;

	return m_arrFrames.size();
}

COLORREF CPictureEx::GetBkColor() const
{
	return m_clrBackground;
}

void CPictureEx::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	LONG nPaintWidth = m_PaintRect.right-m_PaintRect.left;

	if (nPaintWidth > 0)
	{
		LONG nPaintHeight = m_PaintRect.bottom - m_PaintRect.top;
		::BitBlt(dc.m_hDC, 0, 0, nPaintWidth, nPaintHeight,	
			m_hMemDC, m_PaintRect.left, m_PaintRect.top, SRCCOPY);
	}
	else
	{
		::BitBlt(dc.m_hDC, 0, 0, m_PictureSize.cx, m_PictureSize.cy,
			m_hMemDC, 0, 0, SRCCOPY);
	};
}

BOOL CPictureEx::PrepareDC(int nWidth, int nHeight)
{
	SetWindowPos(NULL,0,0,nWidth,nHeight,SWP_NOMOVE | SWP_NOZORDER);

	HDC hWinDC = ::GetDC(m_hWnd);
	if (!hWinDC) return FALSE;
	
	m_hMemDC = CreateCompatibleDC(hWinDC);
	if (!m_hMemDC) 
	{
		::ReleaseDC(m_hWnd,hWinDC);
		return FALSE;
	};

	m_hBitmap  = CreateCompatibleBitmap(hWinDC,nWidth,nHeight);
	if (!m_hBitmap) 
	{
		::ReleaseDC(m_hWnd,hWinDC);
		::DeleteDC(m_hMemDC);
		return FALSE;
	};

	m_hOldBitmap = reinterpret_cast<HBITMAP> 
						(SelectObject(m_hMemDC,m_hBitmap));
	
	// fill the background
	m_clrBackground = GetSysColor(COLOR_3DFACE);
	RECT rect = {0,0,nWidth,nHeight};
	FillRect(m_hMemDC,&rect,(HBRUSH)(COLOR_WINDOW));

	::ReleaseDC(m_hWnd,hWinDC);
	m_bIsInitialized = TRUE;
	return TRUE;
}

void CPictureEx::OnDestroy() 
{
	Stop();	
	CStatic::OnDestroy();
}

void CPictureEx::SetBkColor(COLORREF clr)
{
	if (!m_bIsInitialized) return;

	m_clrBackground = clr;

	HBRUSH hBrush = CreateSolidBrush(clr);
	if (hBrush)
	{
		RECT rect = {0,0,m_PictureSize.cx,m_PictureSize.cy};
		FillRect(m_hMemDC,&rect,hBrush);
		DeleteObject(hBrush);
	};
}

#ifdef GIF_TRACING
void CPictureEx::WriteDataOnDisk(CString szFileName, HGLOBAL hData, DWORD dwSize)
{
	CFile file;

	if (!file.Open(szFileName,
			CFile::modeCreate |
			CFile::modeWrite |
			CFile::shareDenyNone))
	{
		TRACE(_T("WriteData: Error creating file %s\n"),szFileName);
		return;
	};

	char *pData = reinterpret_cast<char *> (GlobalLock(hData));
	if (!pData)
	{
		TRACE(_T("WriteData: Error locking memory\n"));
		return;
	};

	TRY
	{
		file.Write(pData,dwSize);
	}
	CATCH(CFileException, e);                                          
	{
		TRACE(_T("WriteData: An exception occured while writing to the file %s\n"),
			szFileName);
		e->Delete();
		GlobalUnlock(hData);
		file.Close();
		return;
	}
	END_CATCH
	
	GlobalUnlock(hData);
	file.Close();
}

void CPictureEx::EnumGIFBlocks()
{
	enum GIFBlockTypes nBlock;

	ResetDataPointer();
	while(m_nCurrOffset < m_nDataSize)
	{
		nBlock = GetNextBlock();
		switch(nBlock)
		{
		case BLOCK_UNKNOWN:
			TRACE(_T("- Unknown block\n"));
			return;
			break;

		case BLOCK_TRAILER:
			TRACE(_T("- Trailer block\n"));
			break;

		case BLOCK_APPEXT:
			TRACE(_T("- Application extension block\n"));
			break;

		case BLOCK_COMMEXT:
			TRACE(_T("- Comment extension block\n"));
			break;

		case BLOCK_CONTROLEXT:
			{
			TGIFControlExt *pControl = 
				reinterpret_cast<TGIFControlExt *> (&m_pRawData[m_nCurrOffset]);
			TRACE(_T("- Graphic control extension block (delay %d, disposal %d)\n"),
					pControl->m_wDelayTime, pControl->GetPackedValue(GCX_PACKED_DISPOSAL));
			};
			break;

		case BLOCK_PLAINTEXT:
			TRACE(_T("- Plain text extension block\n"));
			break;

		case BLOCK_IMAGE:
			TGIFImageDescriptor *pIDescr = 
				reinterpret_cast<TGIFImageDescriptor *> (&m_pRawData[m_nCurrOffset]);
			TRACE(_T("- Image data block (%dx%d  %d,%d)\n"),
					pIDescr->m_wWidth,
					pIDescr->m_wHeight,
					pIDescr->m_wLeftPos,
					pIDescr->m_wTopPos);
			break;
		};

		SkipNextBlock();	
	};

	TRACE(_T("\n"));
}
#endif // GIF_TRACING

BOOL CPictureEx::SetPaintRect(const RECT *lpRect)
{
	return CopyRect(&m_PaintRect, lpRect);
}

BOOL CPictureEx::GetPaintRect(RECT *lpRect)
{
	return CopyRect(lpRect, &m_PaintRect);
}

```

`Packer/PictureEx.h`:

```h
//////////////////////////////////////////////////////////////////////
// PictureEx.cpp: implementation of the CPictureEx class.
//
// Picture displaying control with support for the following formats:
// GIF (including animated GIF87a and GIF89a), JPEG, BMP, WMF, ICO, CUR
// 
// Written by Oleg Bykov (oleg_bykoff@rsdn.ru)
// Copyright (c) 2001
//
// To use CPictureEx, follow these steps:
//   - place a static control on your dialog (either a text or a bitmap)
//   - change its identifier to something else (e.g. IDC_MYPIC)
//   - associate a CStatic with it using ClassWizard
//   - in your dialog's header file replace CStatic with CPictureEx
//     (don't forget to #include "PictureEx.h" and add 
//     PictureEx.h and PictureEx.cpp to your project)
//   - call one of the overloaded CPictureEx::Load() functions somewhere
//     (OnInitDialog is a good place to start)
//   - if the preceding Load() succeeded call Draw()
//  
// You can also add the control by defining a member variable of type 
// CPictureEx, calling CPictureEx::Create (derived from CStatic), then 
// CPictureEx::Load and CPictureEx::Draw.
//
// By default, the control initializes its background to COLOR_3DFACE
// (see CPictureEx::PrepareDC()). You can change the background by
// calling CPictureEx::SetBkColor(COLORREF) after CPictureEx::Load().
//
// I decided to leave in the class the functions to write separate frames from 
// animated GIF to disk. If you want to use them, uncomment #define GIF_TRACING 
// and an appropriate section in CPictureEx::Load(HGLOBAL, DWORD). These functions 
// won't be compiled and linked to your project unless you uncomment #define GIF_TRACING,
// so you don't have to worry.
// 
// Warning: this code hasn't been subject to a heavy testing, so
// use it on your own risk. The author accepts no liability for the 
// possible damage caused by this code.
//
// Version 1.0  7 Aug 2001
//              Initial release
//
// Version 1.1  6 Sept 2001
//              ATL version of the class
//
// Version 1.2  14 Oct 2001
//              - Fixed a problem with loading GIFs from resources
//                in MFC-version of the class for multi-modules apps.
//                Thanks to Ruben Avila-Carretero for finding this out.
//
//              - Got rid of waitable timer in ThreadAnimation()
//                Now CPictureEx[Wnd] works in Win95 too.
//                Thanks to Alex Egiazarov and Wayne King for the idea.
//
//              - Fixed a visual glitch of using SetBkColor.
//                Thanks to Kwangjin Lee for finding this out.
//
// Version 1.3  10 Nov 2001
//              - Fixed a DC leak. One DC leaked per each UnLoad()
//                (forgot to put a ReleaseDC() in the end of 
//                CPictureExWnd::PrepareDC() function).
//
//              - Now it is possible to set a clipping rectangle using
//                CPictureEx[Wnd]::SetPaintRect(const LPRECT) function.
//                The LPRECT parameter tells the class what portion of
//                a picture should it display. If the clipping rect is 
//                not set, the whole picture is shown.
//                Thanks to Fabrice Rodriguez for the idea.
//
//              - Added support for Stop/Draw. Now you can Stop() an
//                animated GIF, then Draw() it again, it will continue
//                animation from the frame it was stopped on. You can 
//                also know if a GIF is currently playing with the 
//                IsPlaying() function.
//             
//              - Got rid of math.h and made m_bExitThread volatile. 
//                Thanks to Piotr Sawicki for the suggestion.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PICTUREEX_H__0EFE5DE0_7B68_4DB7_8B34_5DC634948438__INCLUDED_)
#define AFX_PICTUREEX_H__0EFE5DE0_7B68_4DB7_8B34_5DC634948438__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vector>

//#define GIF_TRACING  // uncomment it if you want detailed TRACEs

class CPictureEx : public CStatic
{
public:

struct TFrame    // structure that keeps a single frame info
{
	IPicture *m_pPicture;  // pointer to the interface used for drawing
	SIZE     m_frameSize;
	SIZE     m_frameOffset;
	UINT     m_nDelay;     // delay (in 1/100s of a second)
	UINT     m_nDisposal;  // disposal method
};

#pragma pack(1)   // turn byte alignment on

enum GIFBlockTypes
{
	BLOCK_UNKNOWN,
	BLOCK_APPEXT,
	BLOCK_COMMEXT,
	BLOCK_CONTROLEXT,
	BLOCK_PLAINTEXT,
	BLOCK_IMAGE,
	BLOCK_TRAILER
};

enum ControlExtValues // graphic control extension packed field values
{
	GCX_PACKED_DISPOSAL,  // disposal method
	GCX_PACKED_USERINPUT,
	GCX_PACKED_TRANSPCOLOR
};

enum LSDPackedValues  // logical screen descriptor packed field values
{
	LSD_PACKED_GLOBALCT,
	LSD_PACKED_CRESOLUTION,
	LSD_PACKED_SORT,
	LSD_PACKED_GLOBALCTSIZE
};

enum IDPackedValues   // image descriptor packed field values
{
	ID_PACKED_LOCALCT,
	ID_PACKED_INTERLACE,
	ID_PACKED_SORT,
	ID_PACKED_LOCALCTSIZE
};

struct TGIFHeader       // GIF header  
{
	char m_cSignature[3]; // Signature - Identifies the GIF Data Stream
						  // This field contains the fixed value 'GIF'
	char m_cVersion[3];	// Version number. May be one of the following:
						// "87a" or "89a"
};

struct TGIFLSDescriptor // Logical Screen Descriptor
{
	WORD m_wWidth;	// 2 bytes. Logical screen width
	WORD m_wHeight; // 2 bytes. Logical screen height

	unsigned char m_cPacked;      // packed field	

	unsigned char m_cBkIndex;     // 1 byte. Background color index
	unsigned char m_cPixelAspect; // 1 byte. Pixel aspect ratio
	inline int GetPackedValue(enum LSDPackedValues Value);
};

struct TGIFAppExtension // application extension block
{
	unsigned char m_cExtIntroducer; // extension introducer (0x21)
	unsigned char m_cExtLabel; // app. extension label (0xFF)
	unsigned char m_cBlockSize; // fixed value of 11
	char m_cAppIdentifier[8];   // application identifier
	char m_cAppAuth[3];  // application authentication code
};

struct TGIFControlExt // graphic control extension block
{
	unsigned char m_cExtIntroducer; // extension introducer (0x21)
	unsigned char m_cControlLabel;  // control extension label (0xF9)
	unsigned char m_cBlockSize; // fixed value of 4
	unsigned char m_cPacked;    // packed field
	WORD m_wDelayTime;	// delay time
	unsigned char m_cTColorIndex; // transparent color index
	unsigned char m_cBlockTerm;   // block terminator (0x00)
public:
	inline int GetPackedValue(enum ControlExtValues Value);
};

struct TGIFCommentExt  // comment extension block
{
	unsigned char m_cExtIntroducer; // extension introducer (0x21)
	unsigned char m_cCommentLabel;  // comment extension label (0xFE)
};

struct TGIFPlainTextExt // plain text extension block
{
	unsigned char m_cExtIntroducer;  // extension introducer (0x21)
	unsigned char m_cPlainTextLabel; // text extension label (0x01)
	unsigned char m_cBlockSize; // fixed value of 12
	WORD m_wLeftPos;    // text grid left position
	WORD m_wTopPos;     // text grid top position
	WORD m_wGridWidth;  // text grid width
	WORD m_wGridHeight; // text grid height
	unsigned char m_cCellWidth;  // character cell width
	unsigned char m_cCellHeight; // character cell height
	unsigned char m_cFgColor; // text foreground color index
	unsigned char m_cBkColor; // text background color index
};

struct TGIFImageDescriptor // image descriptor block
{
	unsigned char m_cImageSeparator; // image separator byte (0x2C)
	WORD m_wLeftPos; // image left position
	WORD m_wTopPos;  // image top position
	WORD m_wWidth;   // image width
	WORD m_wHeight;  // image height
	unsigned char m_cPacked; // packed field
	inline int GetPackedValue(enum IDPackedValues Value);
};

#pragma pack() // turn byte alignment off

public:
	BOOL GetPaintRect(RECT *lpRect);
	BOOL SetPaintRect(const RECT *lpRect);
	CPictureEx();
	virtual ~CPictureEx();
	void Stop();   // stops animation
	void UnLoad(); // stops animation plus releases all resources

	BOOL IsGIF() const;
	BOOL IsPlaying() const;
	BOOL IsAnimatedGIF() const;
	SIZE GetSize() const;
	int GetFrameCount() const;
	COLORREF GetBkColor() const;
	void SetBkColor(COLORREF clr);

	// draws the picture (starts an animation thread if needed)
	// if an animation was previously stopped by Stop(),
	// continues it from the last displayed frame
	BOOL Draw();

	// loads a picture from a file
	// i.e. Load(_T("mypic.gif"));
	BOOL Load(LPCTSTR szFileName);

	// loads a picture from a global memory block (allocated by GlobalAlloc)
	// Warning: this function DOES NOT free the global memory, pointed to by hGlobal
	BOOL Load(HGLOBAL hGlobal, DWORD dwSize);

	// loads a picture from a program resource
	// i.e. Load(MAKEINTRESOURCE(IDR_MYPIC),_T("GIFTYPE"));
	BOOL Load(LPCTSTR szResourceName,LPCTSTR szResourceType);

protected:

#ifdef GIF_TRACING
	void EnumGIFBlocks();
	void WriteDataOnDisk(CString szFileName, HGLOBAL hData, DWORD dwSize);
#endif // GIF_TRACING

	RECT m_PaintRect;
	SIZE m_PictureSize;
	COLORREF m_clrBackground;
	UINT m_nCurrFrame;
	UINT m_nDataSize;
	UINT m_nCurrOffset;
	UINT m_nGlobalCTSize;
	BOOL m_bIsGIF;
	BOOL m_bIsPlaying;
	volatile BOOL m_bExitThread;
	BOOL m_bIsInitialized;
	HDC m_hMemDC;

	HDC m_hDispMemDC;
	HBITMAP m_hDispMemBM;
	HBITMAP m_hDispOldBM;

	HBITMAP m_hBitmap;
	HBITMAP m_hOldBitmap;
	HANDLE m_hThread;
	HANDLE m_hExitEvent;
	IPicture * m_pPicture;
	TGIFHeader * m_pGIFHeader;
	unsigned char * m_pRawData;
	TGIFLSDescriptor * m_pGIFLSDescriptor;
	std::vector<TFrame> m_arrFrames;

	void ThreadAnimation();
	static UINT WINAPI _ThreadAnimation(LPVOID pParam);

	int GetNextBlockLen() const;
	BOOL SkipNextBlock();
	BOOL SkipNextGraphicBlock();
	BOOL PrepareDC(int nWidth, int nHeight);
	void ResetDataPointer();
	enum GIFBlockTypes GetNextBlock() const;
	UINT GetSubBlocksLen(UINT nStartingOffset) const;
	HGLOBAL GetNextGraphicBlock(UINT *pBlockLen, UINT *pDelay, 
		SIZE *pBlockSize, SIZE *pBlockOffset, UINT *pDisposal);

	// Generated message map functions
	//{{AFX_MSG(CPictureEx)
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_PICTUREEX_H__0EFE5DE0_7B68_4DB7_8B34_5DC634948438__INCLUDED_)

```

`Packer/Task.cpp`:

```cpp

// PackerDlg.cpp : 实现文件
//

#include "stdafx.h"
#include "Packer.h"
#include "Task.h"
#include "afxdialogex.h"
#include "util.h"
#include "vector"
#include "aplib.h"
#pragma comment(lib, "aplib.lib")
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

GlogalExternVar *g_GlobalExternVar;

Task::Task()
{
	m_lpPressData = NULL;
	m_TargetPeTag.m_FileMapTag.m_lpFileData = NULL;
	m_PressPeTag.m_FileMapTag.m_lpFileData = NULL;
	m_ShellPeTag.m_FileMapTag.m_lpFileData = NULL;
}

Task::~Task()
{
	for (auto temp = m_TargetSecVector.begin(); temp != m_TargetSecVector.end(); temp++)
	{
		if (*temp != NULL)
		{
			delete[](*temp)->m_lpSecData;
			(*temp)->m_lpSecData = NULL;
		}
		delete *temp;
	}
	for (auto temp = m_ShellSecVector.begin(); temp != m_ShellSecVector.end(); temp++)
	{
		if (*temp != NULL)
		{
			delete[](*temp)->m_lpSecData;
			(*temp)->m_lpSecData = NULL;
		}
		delete *temp;
	}

	for (auto temp = m_PressSecVector.begin(); temp != m_PressSecVector.end(); temp++)
	{
		if (*temp != NULL)
		{
			delete[](*temp)->m_lpSecData;
			(*temp)->m_lpSecData = NULL;
		}
		delete *temp;
	}
	if (m_lpPressData != NULL)
		delete[]m_lpPressData;
	if (m_TargetPeTag.m_FileMapTag.m_lpFileData != NULL)
		delete[]m_TargetPeTag.m_FileMapTag.m_lpFileData;
	if (m_PressPeTag.m_FileMapTag.m_lpFileData != NULL)
		delete[]m_PressPeTag.m_FileMapTag.m_lpFileData;
	if (m_ShellPeTag.m_FileMapTag.m_lpFileData != NULL)
		delete[]m_ShellPeTag.m_FileMapTag.m_lpFileData;
}

void Task::SetPEStruct(char *fileBuf, PEstruct &peStruct)
{
	peStruct.m_lpDosHeader = GET_DOS_HEADER(fileBuf);
	peStruct.m_lpNtHeader = GET_NT_HEADER(fileBuf);
	peStruct.m_lpSecHeader = GET_SECTION_HEADER(peStruct.m_lpNtHeader);
}

DWORD Task::RVA2FA(char* lpFileBuffer, int RVA)
{
	PEstruct thePEStruct;
	thePEStruct.m_lpDosHeader = (IMAGE_DOS_HEADER*)lpFileBuffer;
	thePEStruct.m_lpNtHeader = (IMAGE_NT_HEADERS*)(thePEStruct.m_lpDosHeader->e_lfanew + (DWORD)lpFileBuffer);

	int nSecCount = thePEStruct.m_lpNtHeader->FileHeader.NumberOfSections;
	int nOptionalHeaderSize = thePEStruct.m_lpNtHeader->FileHeader.SizeOfOptionalHeader;
	//节区偏移等于doshead + stub + sizeof(Signature) + sizeof(IMAGE_FILE_HEADER) + nOptionalHeaderSize
	int nSecOffset = thePEStruct.m_lpDosHeader->e_lfanew + \
		sizeof(thePEStruct.m_lpNtHeader->Signature) + \
		sizeof(IMAGE_FILE_HEADER) + \
		nOptionalHeaderSize;

	int VirtualAddress = 0;
	int VirtualSize = 0;
	int leftsize = 0;
	int nSectionAlign = thePEStruct.m_lpNtHeader->OptionalHeader.SectionAlignment;
	thePEStruct.m_lpSecHeader = (IMAGE_SECTION_HEADER*)(nSecOffset + lpFileBuffer);
	for (int n = 0; nSecCount > 0; nSecCount--)
	{
		VirtualAddress = thePEStruct.m_lpSecHeader->VirtualAddress;
		VirtualSize = thePEStruct.m_lpSecHeader->Misc.VirtualSize;
		int leftsize = VirtualSize % nSectionAlign;
		if (leftsize != 0)
		{
			leftsize = nSectionAlign - leftsize;
		}
		VirtualSize += leftsize;
		if (RVA < VirtualAddress + VirtualSize)
		{
			break;
		}
		thePEStruct.m_lpSecHeader++;
	}
	if (nSecCount == 0)
	{
		return 0;
	}
	DWORD FA = RVA - VirtualAddress + thePEStruct.m_lpSecHeader->PointerToRawData;
	if (FA > thePEStruct.m_lpSecHeader->PointerToRawData + thePEStruct.m_lpSecHeader->SizeOfRawData)
	{
		return 0;
	}
	return FA;
}

PVOID Task::GetExpVarAddr(const char * strVarName)
{
	PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, (m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)));

	// 2、循环读取导出表输出项的输出函数，并依次与szVarName做比对，如果相同，则取出相对应的函数地址
	for (DWORD i = 0; i < lpExport->NumberOfNames; i++)
	{
		PDWORD pNameAddr = (PDWORD)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, lpExport->AddressOfNames));
		PCHAR strTempName = (PCHAR)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, pNameAddr[i]));
		if (!strcmp(strVarName, strTempName))
		{
			PDWORD pFunAddr = (PDWORD)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, lpExport->AddressOfFunctions));
			return (PVOID)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, pFunAddr[i]));
		}
	}
	return 0;
}

void Task::StoreSectionInfo(char *bufFile, std::vector<MySecInfo*>&vec)
{
	IMAGE_NT_HEADERS* pImageNtHeader = GET_NT_HEADER(bufFile);
	PIMAGE_SECTION_HEADER pImageSectionHeader = GET_SECTION_HEADER(pImageNtHeader);
	DWORD nCount = pImageNtHeader->FileHeader.NumberOfSections;
	for (int i = 0; i < nCount; i++)
	{
		MySecInfo *lpSecInfo = new MySecInfo;
		lpSecInfo->m_SecHeader = *pImageSectionHeader;
		lpSecInfo->m_lpSecData = new char[pImageSectionHeader->SizeOfRawData];
		memcpy(lpSecInfo->m_lpSecData, pImageSectionHeader->PointerToRawData + bufFile, pImageSectionHeader->SizeOfRawData);
		vec.push_back(lpSecInfo);
		pImageSectionHeader++;
	}
}

DWORD Task::Align(DWORD dwAlign, DWORD dwValue)
{
	DWORD dwLeft = 0;

	if (dwValue % dwAlign != 0)
	{
		dwLeft = dwAlign - dwValue % dwAlign;
	}
	return dwValue + dwLeft;
}

MySecInfo* Task::GetSecInfoByRVA(DWORD dwRVA, DWORD dwAlign, std::vector<MySecInfo*>&vec)
{
	std::vector<MySecInfo*>::iterator it = vec.begin();
	while (it != vec.end())
	{
		if (dwRVA < Align(dwAlign, (*it)->m_SecHeader.Misc.VirtualSize) + (*it)->m_SecHeader.VirtualAddress
			&& dwRVA >= (*it)->m_SecHeader.VirtualAddress)
		{
			return (*it);
		}
		it++;
	}
	return NULL;
}

DWORD Task::GetTargetImageSize(std::vector<MySecInfo*>&vec)
{
	DWORD dwImageSize = 0;
	std::vector<MySecInfo*>::iterator it = vec.begin();
	while (it != vec.end())
	{
		dwImageSize += Align(m_TargetPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, (*it)->m_SecHeader.Misc.VirtualSize);
		it++;
	}
	dwImageSize += Align(m_TargetPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, m_TargetPeTag.m_lpNtHeader->OptionalHeader.SizeOfHeaders);
	return dwImageSize;
}

DWORD Task::GetPressSize(std::vector<MySecInfo*>&vec)
{
	DWORD dwPressSize = 0;
	std::vector<MySecInfo*>::iterator it = vec.begin();
	while (it != vec.end())
	{
		//去除不能压缩的区段(资源)
		if ((*it)->m_isNeedPress == true)
		{
			dwPressSize += (*it)->m_SecHeader.SizeOfRawData;
		}
		it++;
	}
	return dwPressSize;
}

void Task::CopyPressData(char* lpDest, char *lpSrc, std::vector<MySecInfo*>&vec)
{
	DWORD dwCurPos = 0;
	std::vector<MySecInfo*>::iterator it = vec.begin();
	while (it != vec.end())
	{
		if ((*it)->m_isNeedPress == true)
		{
			memcpy(lpDest + dwCurPos, lpSrc + (*it)->m_SecHeader.PointerToRawData,
				(*it)->m_SecHeader.SizeOfRawData);
			dwCurPos += (*it)->m_SecHeader.SizeOfRawData;
		}
		it++;
	}
}
int Task::CompressData(LPVOID lpSoure, LPVOID* lpOutDest, DWORD dwLength)
{
	byte* workmem = NULL;
	byte* lpDest = NULL;

	if ((lpDest = (byte *)malloc(aP_max_packed_size(dwLength))) == NULL ||
		(workmem = (byte *)malloc(aP_workmem_size(dwLength))) == NULL)
	{
		AfxMessageBox("ERR: not enough memory\n");
		return 1;
	}
	int nOutSize = aPsafe_pack(lpSoure, lpDest, dwLength, workmem, ProgressCallBack, NULL);
	if (nOutSize == APLIB_ERROR)
	{
		AfxMessageBox("\nERR: an error occured while compressing\n");
		return -1;
	}
	*lpOutDest = lpDest;
	if (workmem != NULL)
	{
		free(workmem);
	}
	return nOutSize;
}

void Task::AddSec(char* lpSecName, DWORD dwFileSize, LPVOID lpFileData)
{
	PEstruct PeStruct;
	PeStruct.m_lpDosHeader = (IMAGE_DOS_HEADER*)lpFileData;
	PeStruct.m_lpNtHeader = (IMAGE_NT_HEADERS*)((DWORD)lpFileData + PeStruct.m_lpDosHeader->e_lfanew);
	PeStruct.m_lpSecHeader = (IMAGE_SECTION_HEADER*)((DWORD)lpFileData + PeStruct.m_lpDosHeader->e_lfanew + 4 + sizeof(IMAGE_FILE_HEADER)
		+ PeStruct.m_lpNtHeader->FileHeader.SizeOfOptionalHeader);
	DWORD dwRVA = Align(PeStruct.m_lpNtHeader->OptionalHeader.SectionAlignment, PeStruct.m_lpNtHeader->OptionalHeader.SizeOfHeaders);
	DWORD dwFASize = PeStruct.m_lpNtHeader->OptionalHeader.SizeOfHeaders;
	DWORD nSecCount = PeStruct.m_lpNtHeader->FileHeader.NumberOfSections;
	DWORD i = 0;
	while (i < nSecCount)
	{

		DWORD dwVirtualSize = Align(PeStruct.m_lpNtHeader->OptionalHeader.SectionAlignment, PeStruct.m_lpSecHeader->Misc.VirtualSize);
		dwRVA += dwVirtualSize;
		dwFASize += Align(PeStruct.m_lpNtHeader->OptionalHeader.FileAlignment, PeStruct.m_lpSecHeader->SizeOfRawData);
		PeStruct.m_lpSecHeader++;
		i++;
	}

	IMAGE_SECTION_HEADER secheader = { 0 };
	strcpy((char*)secheader.Name, lpSecName);
	secheader.PointerToRawData = dwFASize;
	secheader.SizeOfRawData = Align(PeStruct.m_lpNtHeader->OptionalHeader.FileAlignment, dwFileSize);
	secheader.VirtualAddress = dwRVA;
	if (nSecCount == 0)
	{
		secheader.Misc.VirtualSize = GetTargetImageSize(m_TargetSecVector);
	}
	else
	{
		secheader.Misc.VirtualSize = Align(PeStruct.m_lpNtHeader->OptionalHeader.SectionAlignment, dwFileSize);;
	}
	secheader.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

	PeStruct.m_lpNtHeader->FileHeader.NumberOfSections++;
	*PeStruct.m_lpSecHeader = secheader;

}


void Task::Start(const char *path)
{
	bool isPE = CreateFileMapStruct(path, m_TargetPeTag.m_FileMapTag);
	if (!isPE)
		return;

	char buf[512];
	GetCurrentDirectoryA(512, buf);
	std::string currentPath = buf;
	currentPath += "\\Stub.dll";
	replaceStringA(currentPath);
	CreateFileMapStruct(currentPath.c_str(), m_ShellPeTag.m_FileMapTag);

	SetPEStruct(m_TargetPeTag.m_FileMapTag.m_lpFileData, m_TargetPeTag);

	SetPEStruct(m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellPeTag);

	StoreSectionInfo(m_TargetPeTag.m_FileMapTag.m_lpFileData, m_TargetSecVector);
	StoreSectionInfo(m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellSecVector);
	Pack(path);
	gApplet.success = true;
}

void Task::GetResRVA(char* lpFileData, DWORD& dwRVA, DWORD& dwSize)
{
	PEstruct PeStruct;
	PeStruct.m_lpDosHeader = (IMAGE_DOS_HEADER*)lpFileData;
	PeStruct.m_lpNtHeader = (IMAGE_NT_HEADERS*)((DWORD)lpFileData + PeStruct.m_lpDosHeader->e_lfanew);
	PeStruct.m_lpSecHeader = (IMAGE_SECTION_HEADER*)((DWORD)lpFileData + PeStruct.m_lpDosHeader->e_lfanew + 4 + sizeof(IMAGE_FILE_HEADER)
		+ PeStruct.m_lpNtHeader->FileHeader.SizeOfOptionalHeader);
	DWORD dwVASize = PeStruct.m_lpSecHeader->VirtualAddress;
	DWORD dwFASize = PeStruct.m_lpSecHeader->PointerToRawData;
	DWORD nSecCount = PeStruct.m_lpNtHeader->FileHeader.NumberOfSections;
	DWORD i = 0;
	while (i < nSecCount)
	{
		if (strcmp((char*)PeStruct.m_lpSecHeader->Name, ".rsrc") == 0)
		{
			dwRVA = PeStruct.m_lpSecHeader->VirtualAddress;
			dwSize = PeStruct.m_lpSecHeader->Misc.VirtualSize;
			return;
		}
		PeStruct.m_lpSecHeader++;
		i++;
	}
	dwRVA = 0;
	dwSize = 0;
}

void Task::FixRsrc(MySecInfo *lpResSecInfo)
{
	//修正资源表
	DWORD dwResRVA;
	DWORD dwSize;
	if (lpResSecInfo != NULL)
	{
		GetResRVA(m_PressPeTag.m_FileMapTag.m_lpFileData, dwResRVA, dwSize);
		DWORD dwResFA = RVA2FA(m_PressPeTag.m_FileMapTag.m_lpFileData, dwResRVA);
		IMAGE_RESOURCE_DIRECTORY* lpIMAGE_RESOURCE_DIRECTORY = (IMAGE_RESOURCE_DIRECTORY*)(m_PressPeTag.m_FileMapTag.m_lpFileData + dwResFA);
		WORD nCount = lpIMAGE_RESOURCE_DIRECTORY->NumberOfIdEntries + lpIMAGE_RESOURCE_DIRECTORY->NumberOfNamedEntries;
		IMAGE_RESOURCE_DIRECTORY_ENTRY* lpRESOURCE_DIRECTORY = (struct _IMAGE_RESOURCE_DIRECTORY_ENTRY *)(lpIMAGE_RESOURCE_DIRECTORY + 1);
		int n = sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY);
		for (int i = 0; i < nCount; i++)
		{
			if (lpRESOURCE_DIRECTORY->DataIsDirectory == 1)
			{
				//第二层目录
				DWORD RESOURCEAdder = lpRESOURCE_DIRECTORY->OffsetToDirectory + (DWORD)lpIMAGE_RESOURCE_DIRECTORY;
				IMAGE_RESOURCE_DIRECTORY* lpSecond = (IMAGE_RESOURCE_DIRECTORY*)RESOURCEAdder;
				IMAGE_RESOURCE_DIRECTORY_ENTRY* lpSecond2 = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(lpSecond + 1);
				for (int l = 0; l < lpSecond->NumberOfNamedEntries; l++)
				{
					//第三层数据
					IMAGE_RESOURCE_DIRECTORY* lpThrid = (IMAGE_RESOURCE_DIRECTORY*)(lpSecond2->OffsetToDirectory + (DWORD)lpIMAGE_RESOURCE_DIRECTORY);
					IMAGE_RESOURCE_DIRECTORY_ENTRY* lpThridEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(lpThrid + 1);
					for (int k = 0; k < lpThrid->NumberOfIdEntries; k++)
					{
						DWORD* lpDwAddress = (DWORD*)(lpThridEntry->OffsetToData + (DWORD)lpIMAGE_RESOURCE_DIRECTORY);
						//修改偏移 = 基址 + 差值
						*lpDwAddress = dwResRVA + *lpDwAddress - lpResSecInfo->m_SecHeader.VirtualAddress;
						lpThridEntry++;
					}
					lpSecond2++;
				}
				for (int j = 0; j < lpSecond->NumberOfIdEntries; j++)
				{
					//第三层数据
					IMAGE_RESOURCE_DIRECTORY* lpThrid = (IMAGE_RESOURCE_DIRECTORY*)(lpSecond2->OffsetToDirectory + (DWORD)lpIMAGE_RESOURCE_DIRECTORY);
					IMAGE_RESOURCE_DIRECTORY_ENTRY* lpThridEntry = (IMAGE_RESOURCE_DIRECTORY_ENTRY*)(lpThrid + 1);
					for (int k = 0; k < lpThrid->NumberOfIdEntries; k++)
					{
						DWORD* lpDwAddress = (DWORD*)(lpThridEntry->OffsetToData + (DWORD)lpIMAGE_RESOURCE_DIRECTORY);
						//修改偏移 = 基址 + 差值
						*lpDwAddress = dwResRVA + *lpDwAddress - lpResSecInfo->m_SecHeader.VirtualAddress;
						lpThridEntry++;
					}
					lpSecond2++;
				}

			}
			lpRESOURCE_DIRECTORY++;
		}
	}
}

MySecInfo * GetSecInfoByName(const char *name, std::vector<MySecInfo*>&vec)
{
	for (int i = 0; i < vec.size(); i++)
	{
		if (strcmp(name, (char*)vec[i]->m_SecHeader.Name) == 0)
		{
			return vec[i];
		}
	}
	return NULL;
}

void Task::SetPressDataDir()
{
	m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = GetSecInfoByName(".reloc", m_PressSecVector)->m_SecHeader.VirtualAddress;
	m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;


	if (GetSecInfoByName(".rsrc", m_PressSecVector) != NULL)
	{
		m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = GetSecInfoByName(".rsrc", m_PressSecVector)->m_SecHeader.VirtualAddress;
		m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = GetSecInfoByName(".rsrc", m_PressSecVector)->m_SecHeader.SizeOfRawData;
	}

	MySecInfo *secInfo = GetSecInfoByRVA(m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, m_ShellSecVector);

	DWORD dwTLSSize = m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size;
	DWORD dwOffset = m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress - secInfo->m_SecHeader.VirtualAddress;
	m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = dwOffset + GetSecInfoByName(".Shell", m_PressSecVector)->m_SecHeader.VirtualAddress;
	m_PressPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = dwTLSSize;

}

void Task::ClearDataDir(char* lpFileData)
{
	PEstruct peStruct;
	peStruct.m_lpDosHeader = (IMAGE_DOS_HEADER*)lpFileData;
	peStruct.m_lpNtHeader = (IMAGE_NT_HEADERS*)(lpFileData + peStruct.m_lpDosHeader->e_lfanew);
	DWORD dwDataDirCount = peStruct.m_lpNtHeader->OptionalHeader.NumberOfRvaAndSizes;
	for (int i = 0; i < dwDataDirCount; i++)
	{
		peStruct.m_lpNtHeader->OptionalHeader.DataDirectory[i].VirtualAddress = 0;
		peStruct.m_lpNtHeader->OptionalHeader.DataDirectory[i].Size = 0;
	}
}

void Task::fixStubRelocation()
{
	DWORD dwDllRelocRVA = m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
	DWORD dwDllRelocFA = RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, dwDllRelocRVA);
	PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress));
	m_PressPeTag.m_lpSecHeader = GET_SECTION_HEADER(GET_NT_HEADER(m_PressPeTag.m_FileMapTag.m_lpFileData));
	MySecInfo *lpShellRelocSection = m_ShellSecVector[4];
	DWORD j = 0;
	while (pReloc->SizeOfBlock &&pReloc->VirtualAddress)
	{
		PTYPEOFFSET pTypeOffset = (PTYPEOFFSET)(pReloc + 1);
		DWORD dwNumber = (pReloc->SizeOfBlock - 8) / 2;
		for (int i = 0; i < dwNumber; i++)
		{
			if (*(PWORD)(&pTypeOffset[i]) == 0)
			{
				break;
			}
			DWORD dwRVA = pTypeOffset[i].offset + pReloc->VirtualAddress;
			DWORD dwAddressOfReloc = *(PDWORD)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, dwRVA));


			MySecInfo*info = GetSecInfoByRVA(dwAddressOfReloc - m_ShellPeTag.m_lpNtHeader->OptionalHeader.ImageBase, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, m_ShellSecVector);
			if (strcmp((char*)info->m_SecHeader.Name, ".text") == 0)
			{
				DWORD result = *(PDWORD)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, dwRVA)) =
					dwAddressOfReloc - m_ShellPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_TargetPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_PressPeTag.m_lpSecHeader[1].VirtualAddress - info->m_SecHeader.VirtualAddress;
			}
			else if (strcmp((char*)info->m_SecHeader.Name, ".tls") == 0)
			{
				DWORD result = *(PDWORD)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, dwRVA)) =
					dwAddressOfReloc - m_ShellPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_TargetPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_PressPeTag.m_lpSecHeader[2].VirtualAddress - info->m_SecHeader.VirtualAddress;
			}
			else
			{
				DWORD result = *(PDWORD)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA(m_ShellPeTag.m_FileMapTag.m_lpFileData, dwRVA)) =
					dwAddressOfReloc - m_ShellPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_TargetPeTag.m_lpNtHeader->OptionalHeader.ImageBase + m_PressPeTag.m_lpSecHeader[3].VirtualAddress - info->m_SecHeader.VirtualAddress;
			}
		}

		MySecInfo *info = GetSecInfoByRVA(pReloc->VirtualAddress, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, m_ShellSecVector);
		if (info == NULL)
		{
			pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc->SizeOfBlock);
			return;
		}

		if (strcmp((char*)info->m_SecHeader.Name, ".text") == 0)
		{
			DWORD dwOffset = pReloc->VirtualAddress - info->m_SecHeader.VirtualAddress;
			pReloc->VirtualAddress = m_PressPeTag.m_lpSecHeader[1].VirtualAddress + dwOffset;
		}
		else if (strcmp((char*)info->m_SecHeader.Name, ".tls") == 0)
		{
			DWORD dwOffset = pReloc->VirtualAddress - info->m_SecHeader.VirtualAddress;
			pReloc->VirtualAddress = m_PressPeTag.m_lpSecHeader[2].VirtualAddress + dwOffset;
		}
		else
		{
			DWORD dwOffset = pReloc->VirtualAddress - info->m_SecHeader.VirtualAddress;
			pReloc->VirtualAddress = m_PressPeTag.m_lpSecHeader[3].VirtualAddress + dwOffset;

		}
		pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc->SizeOfBlock);
	}

}

void Task::Pack(const std::string &path)
{
	//获取目标区段对齐值和文件对齐值
	DWORD dwTargetSectionAlignment = m_TargetPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment;
	DWORD dwTargetFileAlignment = m_TargetPeTag.m_lpNtHeader->OptionalHeader.FileAlignment;

	//资源数据
	DWORD dwResRVA = m_TargetPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;
	MySecInfo* lpResSecInfo = NULL;

	//导出变量
	g_GlobalExternVar = (GlogalExternVar*)GetExpVarAddr("g_globalVar");

	//设置密码和日期
	SetDateAndPassword();

	if (dwResRVA != 0)
	{
		lpResSecInfo = GetSecInfoByRVA(dwResRVA, m_TargetPeTag.m_lpNtHeader->OptionalHeader.SectionAlignment, m_TargetSecVector);
		lpResSecInfo->m_isNeedPress = false;
	}
	//映射文件大小
	DWORD dwTargetImageSize = GetTargetImageSize(m_TargetSecVector);
	//需要压缩的区块大小
	DWORD dwPressSize = GetPressSize(m_TargetSecVector);
	//将原始压缩了的区块数据复制到目标内存中
	DWORD dwAfterPressSize = CopyToDestMemory(dwPressSize);
	DWORD dwResFileSize = 0;
	//对其资源块
	if (lpResSecInfo != NULL)
	{
		dwResFileSize = Align(dwTargetFileAlignment, lpResSecInfo->m_SecHeader.SizeOfRawData);
	}
	//文件大小
	DWORD dwFileSize = m_TargetPeTag.m_lpNtHeader->OptionalHeader.SizeOfHeaders +
		Align(dwTargetFileAlignment, dwAfterPressSize) + Align(dwTargetFileAlignment, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode) +
		dwResFileSize + Align(dwTargetFileAlignment, m_ShellSecVector[1]->m_SecHeader.SizeOfRawData) + Align(dwTargetFileAlignment, m_ShellSecVector[2]->m_SecHeader.SizeOfRawData + m_ShellSecVector[4]->m_SecHeader.SizeOfRawData);
	m_dwPressSize = dwFileSize;


	m_PressPeTag.m_FileMapTag.m_lpFileData = new char[dwFileSize];
	RtlZeroMemory(m_PressPeTag.m_FileMapTag.m_lpFileData, dwFileSize);
	//复制文件头
	memcpy(m_PressPeTag.m_FileMapTag.m_lpFileData, m_TargetPeTag.m_FileMapTag.m_lpFileData, m_TargetPeTag.m_lpNtHeader->OptionalHeader.SizeOfHeaders);

	m_PressPeTag.m_lpNtHeader = GET_NT_HEADER(m_PressPeTag.m_FileMapTag.m_lpFileData);
	m_PressPeTag.m_lpDosHeader = GET_DOS_HEADER(m_PressPeTag.m_FileMapTag.m_lpFileData);

	DWORD dwResSize = 0;
	if (lpResSecInfo != 0)
	{
		dwResSize = Align(dwTargetSectionAlignment, lpResSecInfo->m_SecHeader.SizeOfRawData);
	}

	//内存映像大小
	DWORD dwImageSize = Align(dwTargetSectionAlignment, m_PressPeTag.m_lpNtHeader->OptionalHeader.SizeOfHeaders) +
		dwTargetImageSize +
		Align(dwTargetSectionAlignment, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode) +
		dwResSize +
		//代码段
		Align(dwTargetSectionAlignment, m_ShellSecVector[1]->m_SecHeader.SizeOfRawData) +
		//tls段
		Align(dwTargetSectionAlignment, m_ShellSecVector[2]->m_SecHeader.SizeOfRawData) +
		Align(dwTargetSectionAlignment, m_ShellSecVector[4]->m_SecHeader.SizeOfRawData);

	m_PressPeTag.m_lpNtHeader->OptionalHeader.SizeOfImage = dwImageSize;
	m_PressPeTag.m_lpNtHeader->FileHeader.NumberOfSections = 0;
	//添加需要添加的区段
	AddTargetSection(lpResSecInfo, dwAfterPressSize);

	//修复Stub重定位
	fixStubRelocation();
	//记录需要重新复制的地方
	DWORD dwShell = 0;
	//将Stub 复制到最终内存中
	CopyToTargetFile(dwAfterPressSize, lpResSecInfo, dwTargetFileAlignment, dwShell);
	StoreSectionInfo(m_PressPeTag.m_FileMapTag.m_lpFileData, m_PressSecVector);

	ClearDataDir(m_PressPeTag.m_FileMapTag.m_lpFileData);

	SetPressDataDir();

	//设置入口点
	m_PressPeTag.m_lpNtHeader->OptionalHeader.AddressOfEntryPoint
		= m_ShellPeTag.m_lpNtHeader->OptionalHeader.AddressOfEntryPoint - m_ShellPeTag.m_lpNtHeader->OptionalHeader.BaseOfCode + m_PressSecVector[1]->m_SecHeader.VirtualAddress;

	//修复资源块
	FixRsrc(lpResSecInfo);
	SetGlobalVar(dwPressSize);

	//重新复制Shell段
	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwShell),
		(LPVOID)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellPeTag.m_lpNtHeader->OptionalHeader.BaseOfCode)),
		m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode);

	std::string sFileName = path.substr(0, path.length() - 4);
	sFileName += "_Pack.exe";
	SaveFile(sFileName.c_str());
	
}
typedef struct _PEB
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG ImageUsesLargePages : 1;
	ULONG IsProtectedProcess : 1;
	ULONG IsLegacyProcess : 1;
	ULONG IsImageDynamicallyRelocated : 1;
	ULONG SpareBits : 4;
	PVOID Mutant;
	PVOID ImageBaseAddress;
} PEB, *PPEB;
void Task::SetDateAndPassword()
{
	if (gApplet.info.setPassword)
	{
		g_GlobalExternVar->mPassword.isSetPassword = true;
		strcpy(g_GlobalExternVar->mPassword.password, gApplet.info.strPassword.c_str());
	}
	else
		g_GlobalExternVar->mPassword.isSetPassword = false;
	if (gApplet.info.setTime)
	{
		memcpy(&g_GlobalExternVar->mTime, &gApplet.info.time, sizeof(MTime));
		g_GlobalExternVar->mTime.setTime = true;
	}
	else
		g_GlobalExternVar->mTime.setTime = false;
}

void Task::SetGlobalVar(DWORD dwPressSize)
{
	g_GlobalExternVar->dwOrignalOEP = m_TargetPeTag.m_lpNtHeader->OptionalHeader.AddressOfEntryPoint;
	g_GlobalExternVar->dwRelocationRva = m_TargetPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
	g_GlobalExternVar->dwPressSize = dwPressSize;
	g_GlobalExternVar->dwIATVirtualAddress = m_TargetPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	g_GlobalExternVar->dwOrignalImageBase = m_TargetPeTag.m_lpNtHeader->OptionalHeader.ImageBase;
	g_GlobalExternVar->dwTLSVirtualAddress = m_TargetPeTag.m_lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
	RtlZeroMemory(g_GlobalExternVar->mSectionNodeArray, sizeof(g_GlobalExternVar->mSectionNodeArray));
	int tempi = 0;
	for (int i = 0; i < m_TargetSecVector.size(); i++)
	{
		if (m_TargetSecVector[i]->m_isNeedPress)
		{
			g_GlobalExternVar->mSectionNodeArray[tempi].SectionRva = m_TargetSecVector[i]->m_SecHeader.VirtualAddress;
			g_GlobalExternVar->mSectionNodeArray[tempi].SizeOfRawData = m_TargetSecVector[i]->m_SecHeader.SizeOfRawData;
			tempi++;
		}
	}
}

void Task::SaveFile(const char * name)
{
	FILE *lpPressFilefd = fopen(name, "wb");
	fwrite(m_PressPeTag.m_FileMapTag.m_lpFileData, sizeof(char), m_dwPressSize, lpPressFilefd);
	fclose(lpPressFilefd);
}

void Task::CopyToTargetFile(DWORD dwAfterPressSize, MySecInfo * lpResSecInfo, DWORD dwTargetFileAlignment, DWORD & dwShell)
{
	DWORD dwCurPos = m_PressPeTag.m_lpNtHeader->OptionalHeader.SizeOfHeaders;
	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos),
		m_lpPressData,
		dwAfterPressSize);

	//拷贝.Shell区段
	dwCurPos += Align(dwTargetFileAlignment, dwAfterPressSize);
	dwShell = dwCurPos;

	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos),
		(LPVOID)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellPeTag.m_lpNtHeader->OptionalHeader.BaseOfCode)),
		m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode);

	//拷贝Stub tls CRT 
	dwCurPos += Align(dwTargetFileAlignment, m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode);
	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos), (LPVOID)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellSecVector[1]->m_SecHeader.VirtualAddress)), m_ShellSecVector[1]->m_SecHeader.SizeOfRawData);

	dwCurPos += Align(dwTargetFileAlignment, m_ShellSecVector[1]->m_SecHeader.SizeOfRawData);
	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos), (LPVOID)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellSecVector[2]->m_SecHeader.VirtualAddress)), m_ShellSecVector[2]->m_SecHeader.SizeOfRawData);
	dwCurPos += Align(dwTargetFileAlignment, m_ShellSecVector[2]->m_SecHeader.SizeOfRawData);

	memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos), (LPVOID)((DWORD)m_ShellPeTag.m_FileMapTag.m_lpFileData + RVA2FA((char*)m_ShellPeTag.m_FileMapTag.m_lpFileData, m_ShellSecVector[4]->m_SecHeader.VirtualAddress)), m_ShellSecVector[4]->m_SecHeader.SizeOfRawData);
	dwCurPos += Align(dwTargetFileAlignment, m_ShellSecVector[4]->m_SecHeader.SizeOfRawData);

	//拷贝.rsrc区段
	if (lpResSecInfo != NULL)
	{
		memcpy((m_PressPeTag.m_FileMapTag.m_lpFileData + dwCurPos),
			(m_TargetPeTag.m_FileMapTag.m_lpFileData + lpResSecInfo->m_SecHeader.PointerToRawData),
			lpResSecInfo->m_SecHeader.SizeOfRawData);
		dwCurPos += Align(dwTargetFileAlignment, lpResSecInfo->m_SecHeader.SizeOfRawData);
	}
}

void Task::AddTargetSection(MySecInfo * lpResSecInfo, DWORD dwAfterPressSize)
{
	AddSec(".OldDat", dwAfterPressSize, m_PressPeTag.m_FileMapTag.m_lpFileData);
	AddSec(".Shell", m_ShellPeTag.m_lpNtHeader->OptionalHeader.SizeOfCode, m_PressPeTag.m_FileMapTag.m_lpFileData);
	AddSec((char*)m_ShellSecVector[1]->m_SecHeader.Name, m_ShellSecVector[1]->m_SecHeader.SizeOfRawData, m_PressPeTag.m_FileMapTag.m_lpFileData);
	AddSec((char*)m_ShellSecVector[2]->m_SecHeader.Name, m_ShellSecVector[2]->m_SecHeader.SizeOfRawData, m_PressPeTag.m_FileMapTag.m_lpFileData);
	//reloc
	AddSec((char*)m_ShellSecVector[4]->m_SecHeader.Name, m_ShellSecVector[4]->m_SecHeader.SizeOfRawData, m_PressPeTag.m_FileMapTag.m_lpFileData);
	if (lpResSecInfo != NULL)
	{
		AddSec(".rsrc", lpResSecInfo->m_SecHeader.SizeOfRawData, m_PressPeTag.m_FileMapTag.m_lpFileData);
	}
}

DWORD Task::CopyToDestMemory(DWORD dwPressSize)
{
	char *lpDestData = new char[dwPressSize];

	RtlZeroMemory(lpDestData, dwPressSize);

	CopyPressData(lpDestData, m_TargetPeTag.m_FileMapTag.m_lpFileData, m_TargetSecVector);

	DWORD dwAfterPressSize = CompressData(lpDestData, &m_lpPressData, dwPressSize);

	if (dwAfterPressSize == APLIB_ERROR)
	{
		return 0;
	}
	if (lpDestData != NULL)
	{
		delete lpDestData;
		lpDestData = NULL;
	}
	return dwAfterPressSize;
}

```

`Packer/Task.h`:

```h
#pragma once

// PackerDlg.h : 头文件
//


#include "vector"
#include "info.h"
#include "afxcmn.h"

// Task 对话框
class Task 
{
	// 构造
public:
	Task();	// 标准构造函数
	~Task();
protected:
	
protected:
	void SetPEStruct(char *fileBuf, PEstruct &peStruct);
	DWORD RVA2FA(char * lpFileBuffer, int RVA);
	PVOID GetExpVarAddr(const char * strVarName);
	void StoreSectionInfo(char *bufFile, std::vector<MySecInfo*>&vec);
	DWORD Align(DWORD dwAlign, DWORD dwValue);
	MySecInfo * GetSecInfoByRVA(DWORD dwRVA, DWORD dwAlign, std::vector<MySecInfo*>& vec);
	DWORD GetTargetImageSize(std::vector<MySecInfo*>& vec);
	DWORD GetPressSize(std::vector<MySecInfo*>& vec);
	void CopyPressData(char * lpDest, char * lpSrc, std::vector<MySecInfo*>& vec);
	int CompressData(LPVOID lpSoure, LPVOID * lpOutDest, DWORD dwLength);
	void AddSec(char * lpSecName, DWORD dwFileSize, LPVOID lpFileData);
	
	void GetResRVA(char * lpFileData, DWORD & dwRVA, DWORD & dwSize);
	void FixRsrc(MySecInfo * lpResSecInfo);
	void SetPressDataDir();
	void ClearDataDir(char * lpFileData);
	void fixStubRelocation();
	
	
	
	void SetGlobalVar(DWORD dwPressSize);
	void SaveFile(const char *name);
	void CopyToTargetFile(DWORD dwAfterPressSize, MySecInfo * lpResSecInfo, DWORD dwTargetFileAlignment, DWORD & dwShell);
	void AddTargetSection(MySecInfo * lpResSecInfo, DWORD dwAfterPressSize);
	DWORD CopyToDestMemory(DWORD dwFileSize);

	static UINT ThreadCallBack(void *param);
public:
	void Start(const char * path);
	void Pack(const std::string &path);
	void SetDateAndPassword();
	LPVOID m_lpPressData;
	DWORD m_dwPressSize;
	std::vector<MySecInfo*> m_TargetSecVector;
	std::vector<MySecInfo*> m_ShellSecVector;
	std::vector<MySecInfo*> m_PressSecVector;
	PEstruct m_TargetPeTag; //被压缩的PE
	PEstruct m_ShellPeTag; //dll写的shell
	PEstruct m_PressPeTag; //生成的PE
	
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	HWND m_hwnd;
};

```

`Packer/aplib.h`:

```h
/*
 * aPLib compression library  -  the smaller the better :)
 *
 * MS COFF format header file
 *
 * Copyright (c) 1998-2005 by Joergen Ibsen / Jibz
 * All Rights Reserved
 *
 * http://www.ibsensoftware.com/
 */

#ifndef APLIB_H_INCLUDED
#define APLIB_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifndef APLIB_ERROR
# define APLIB_ERROR (-1)
#endif

unsigned int __cdecl aP_pack(const void *source,
                             void *destination,
                             unsigned int length,
                             void *workmem,
                             int (__cdecl *callback)(unsigned int, unsigned int, unsigned int, void *),
                             void *cbparam);

unsigned int __cdecl aP_workmem_size(unsigned int inputsize);

unsigned int __cdecl aP_max_packed_size(unsigned int inputsize);

unsigned int __cdecl aP_depack_asm(const void *source, void *destination);

unsigned int __cdecl aP_depack_asm_fast(const void *source, void *destination);

unsigned int __cdecl aP_depack_asm_safe(const void *source,
                                        unsigned int srclen,
                                        void *destination,
                                        unsigned int dstlen);

unsigned int __cdecl aP_crc32(const void *source, unsigned int length);

unsigned int __cdecl aPsafe_pack(const void *source,
                                 void *destination,
                                 unsigned int length,
                                 void *workmem,
                                 int (__cdecl *callback)(unsigned int, unsigned int, unsigned int, void *),
                                 void *cbparam);

unsigned int __cdecl aPsafe_check(const void *source);

unsigned int __cdecl aPsafe_get_orig_size(const void *source);

unsigned int __cdecl aPsafe_depack(const void *source,
                                   unsigned int srclen,
                                   void *destination,
                                   unsigned int dstlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* APLIB_H_INCLUDED */

```

`Packer/info.h`:

```h
#pragma once
#include "windows.h"
#include "stdio.h"
#include "string"
#define GET_DOS_HEADER(x) ((PIMAGE_DOS_HEADER)(x))
#define GET_NT_HEADER(x) ((PIMAGE_NT_HEADERS)((DWORD)GET_DOS_HEADER(x)->e_lfanew + (DWORD)(x)))
#define GET_SECTION_HEADER(x) IMAGE_FIRST_SECTION(x)

struct FileMapStruct
{
public:
	FileMapStruct()
	{
		m_lpFileData = NULL;
		m_hFile = NULL;
		length = 0;
	}
public:
	DWORD length;
	char* m_lpFileData;
	FILE* m_hFile;
};


struct PEstruct
{
public:
	PEstruct()
	{
		m_lpDosHeader = NULL;
		m_lpNtHeader = NULL;
		m_lpSecHeader = NULL;
		m_lpBaseReloc = NULL;
		m_lpImport = NULL;
		m_lpThunkData = NULL;
		m_ImprotName = NULL;
	}
public:
	IMAGE_DOS_HEADER* m_lpDosHeader;
	IMAGE_NT_HEADERS* m_lpNtHeader;
	IMAGE_SECTION_HEADER* m_lpSecHeader;
	IMAGE_BASE_RELOCATION* m_lpBaseReloc;
	IMAGE_IMPORT_DESCRIPTOR* m_lpImport;
	IMAGE_THUNK_DATA* m_lpThunkData;
	IMAGE_IMPORT_BY_NAME* m_ImprotName;
	FileMapStruct m_FileMapTag;
};

struct MySecInfo
{
public:
	MySecInfo()
	{
		RtlZeroMemory(&m_SecHeader, sizeof(m_SecHeader));
		m_lpSecData = NULL;
		m_isNeedPress = true;
	}
	~MySecInfo()
	{
	}
public:
	IMAGE_SECTION_HEADER m_SecHeader;
	char* m_lpSecData;
	bool m_isNeedPress;
};

typedef struct _SectionNode
{
	//解压区段
	DWORD SizeOfRawData;
	DWORD SectionRva;
}SectionNode;

typedef struct _Password
{
	bool isSetPassword;
	char password[15];
}Password;

typedef struct _MTime
{
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	bool setTime;
}MTime;

typedef struct _Info
{
	bool setPassword;
	std::string strPassword;
	bool setTime;
	MTime time;
}Info;
typedef struct _GlogalExternVar
{
	SectionNode mSectionNodeArray[16];
	//加壳的导入表地址
	DWORD dwIATVirtualAddress;
	//加壳的tls数据大小
	DWORD dwTLSSize;
	//加壳的tls虚拟地址 rva
	DWORD dwTLSVirtualAddress;
	//加壳的原始oep
	DWORD dwOrignalOEP;
	//重定位rva
	DWORD dwRelocationRva;

	DWORD dwBaseOfCode;

	DWORD dwOrignalImageBase;
	DWORD dwPressSize;

	Password mPassword;
	MTime mTime;
}GlogalExternVar;


typedef struct _TYPEOFFSET
{
	WORD offset : 12;			//偏移值
	WORD Type : 4;			//重定位属性(方式)
}TYPEOFFSET, *PTYPEOFFSET;

typedef struct _GlobalApplet
{
	//选择的文件
	std::string filePath;
	//设置密码相关属性
	Info info;
	//加载界面的窗口句柄
	HWND loadingHwnd;
	//是否加壳成功
	bool success;
}GlobalApplet;

//保存全局信息
extern GlobalApplet gApplet;


```

`Packer/res/Packer.rc2`:

```rc2
//
// Packer.RC2 - Microsoft Visual C++ 不会直接编辑的资源
//

#ifdef APSTUDIO_INVOKED
#error 此文件不能用 Microsoft Visual C++ 编辑
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// 在此处添加手动编辑的资源...

/////////////////////////////////////////////////////////////////////////////

```

`Packer/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 Packer.rc 使用
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_PACKER_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_DIALOG1                     130
#define IDD_LOADINGDIALOG               130
#define IDR_GIF1                        133
#define IDR_GIF2                        135
#define IDB_BITMAP1                     136
#define IDR_GIF3                        137
#define IDD_DIALOG2                     138
#define IDD_INPUTDIALOG                 138
#define IDC_PROGRESS1                   1000
#define IDC_FILENAME                    1001
#define IDC_BUTTON1                     1002
#define IDC_LOADINGPIC                  1003
#define IDC_ADD_PASSWORD                1005
#define IDC_ADD_TIMEOUT                 1006
#define IDC_PASSWORD                    1008
#define IDC_DATETIMEPICKER_TIME         1009
#define IDC_DATETIMEPICKER_DATE         1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Packer/stdafx.cpp`:

```cpp

// stdafx.cpp : 只包括标准包含文件的源文件
// Packer.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"



```

`Packer/stdafx.h`:

```h

// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // 从 Windows 头中排除极少使用的资料
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // 某些 CString 构造函数将是显式的

// 关闭 MFC 对某些常见但经常可放心忽略的警告消息的隐藏
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC 核心组件和标准组件
#include <afxext.h>         // MFC 扩展


#include <afxdisp.h>        // MFC 自动化类



#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC 对 Internet Explorer 4 公共控件的支持
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC 对 Windows 公共控件的支持
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // 功能区和控件条的 MFC 支持









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`Packer/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```

`Packer/util.cpp`:

```cpp
#include "windows.h"
#include "stdafx.h"
#include "util.h"
#include "string"

//生成内存文件 不使用win32
bool CreateFileMapStruct(const  char*path,FileMapStruct & fileMapStruct)
{
	fileMapStruct.m_hFile = fopen(path,"rb+");
	if (fileMapStruct.m_hFile == NULL)
	{
		MessageBoxA(NULL,"文件打开失败!","提示",MB_ICONERROR);
		return false;
	}
	fseek(fileMapStruct.m_hFile,0,SEEK_END);
	fileMapStruct.length = ftell(fileMapStruct.m_hFile);
	fseek(fileMapStruct.m_hFile, 0, SEEK_SET);
 	char *fileBuf = (char*)new char[fileMapStruct.length];
	fread(fileBuf,sizeof(char),fileMapStruct.length, fileMapStruct.m_hFile);
	fileMapStruct.m_lpFileData = fileBuf;
	fclose(fileMapStruct.m_hFile);
	return isPEEXE32(fileBuf);
}

bool isPEEXE32(const char *fileData)
{
	if (GET_DOS_HEADER(fileData)->e_magic != 0x5a4d)
	{
		AfxMessageBox("不是一个有效的PE文件");
		return false;
	}
	if (GET_NT_HEADER(fileData)->Signature != 0x4550)
	{
		AfxMessageBox("不是一个有效的PE文件");
		return false;
	}
	if (GET_NT_HEADER(fileData)->OptionalHeader.Magic != 0x10b)
	{
		AfxMessageBox("只支持32位exe程序加壳");
		return false;
	}
	return true;
}

int __cdecl ProgressCallBack(unsigned int insize, unsigned int inpos, unsigned int outpos, void * cbparam)
{
	//SendMessageA(g_hwnd, WM_UPDATE,inpos,insize);
	return 1;
}

void replaceStringA(std::string & path)
{
	int pos;
	while ((pos = path.find("\\"))!=std::string::npos)
	{
		path[pos]='/';
	}
}

```

`Packer/util.h`:

```h
#pragma once
#include "info.h"
#include "string"
bool CreateFileMapStruct(const  char*path, FileMapStruct & fileMapStruct);
bool isPEEXE32(const char *fileData);
void replaceStringA(std::string & path);
 int __cdecl ProgressCallBack(unsigned int insize, unsigned int inpos, unsigned int outpos, void *cbparam);
```

`README.md`:

```md
这里是PE文件加壳程序。
===

<br>
1:目前支持源程序16个区段的压缩。对于超过16个的区段可以修改数据结构实现。
<br>
2:不支持加过其他壳的程序加壳，目前只支持exe文件。
<br>
3:支持Windows10下执行，对于重定位进行了处理，可以支持随机地址的执行。
<br>

编译流程：
-------
将Packer和Stub都设置成x86 release下编译即可
<br>

文件运行截图:
-------
<br>
![image](https://github.com/longqun/Packer/raw/master/ScreenShot/5.PNG)

程序处理流程:
-------
1读取加壳文件，外壳DLL
<br>
2:选择加壳文件需要压缩的地方，对于资源段选择不压缩，其他区段都进行压缩。
<br>
3:重新构造区段表，分别有这么几个区段 .OldDat(原始压缩的数据) .Shell(外壳DLL代码) .tls(用来支持加壳tls程序) .CRT(用来支持加壳tls程序) .reloc(外壳DLL重定位信息) .rcsc(资源如果有的话)
<br>
4:利用aPLib进行压缩，将压缩之后的数据复制到目标文件.OldDat区段缓冲区。
<br>
5:对于外壳DLL进行重定位，资源数据修复
<br>
6:设置导出变量的数据，在外壳DLL中将使用到的变量
<br>
7:写入文件
<br>

原始区段信息
<br>
![image](https://github.com/longqun/Packer/raw/master/ScreenShot/1.jpg)
<br>
原始目录
<br>
![image](https://github.com/longqun/Packer/raw/master/ScreenShot/2.jpg)
<br>
加壳后的区段信息
<br>
![image](https://github.com/longqun/Packer/raw/master/ScreenShot/3.jpg)
<br>
加壳之后的目录表
<br>
![image](https://github.com/longqun/Packer/raw/master/ScreenShot/4.jpg)
```

`Stub/Stub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{C296FD25-9FED-404A-9784-D0CA4F5FC1E8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Stub</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;STUB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;STUB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>Disabled</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;STUB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions> /SAFESEH:NO %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>kernel32.lib</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;STUB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="aplib.h" />
    <ClInclude Include="info.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Stub/Stub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="aplib.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="info.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Stub/Stub.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Stub/aplib.h`:

```h
/*
 * aPLib compression library  -  the smaller the better :)
 *
 * MS COFF format header file
 *
 * Copyright (c) 1998-2005 by Joergen Ibsen / Jibz
 * All Rights Reserved
 *
 * http://www.ibsensoftware.com/
 */

#ifndef APLIB_H_INCLUDED
#define APLIB_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifndef APLIB_ERROR
# define APLIB_ERROR (-1)
#endif

unsigned int __cdecl aP_pack(const void *source,
                             void *destination,
                             unsigned int length,
                             void *workmem,
                             int (__cdecl *callback)(unsigned int, unsigned int, unsigned int, void *),
                             void *cbparam);

unsigned int __cdecl aP_workmem_size(unsigned int inputsize);

unsigned int __cdecl aP_max_packed_size(unsigned int inputsize);

unsigned int __cdecl aP_depack_asm(const void *source, void *destination);

unsigned int __cdecl aP_depack_asm_fast(const void *source, void *destination);

unsigned int __cdecl aP_depack_asm_safe(const void *source,
                                        unsigned int srclen,
                                        void *destination,
                                        unsigned int dstlen);

unsigned int __cdecl aP_crc32(const void *source, unsigned int length);

unsigned int __cdecl aPsafe_pack(const void *source,
                                 void *destination,
                                 unsigned int length,
                                 void *workmem,
                                 int (__cdecl *callback)(unsigned int, unsigned int, unsigned int, void *),
                                 void *cbparam);

unsigned int __cdecl aPsafe_check(const void *source);

unsigned int __cdecl aPsafe_get_orig_size(const void *source);

unsigned int __cdecl aPsafe_depack(const void *source,
                                   unsigned int srclen,
                                   void *destination,
                                   unsigned int dstlen);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* APLIB_H_INCLUDED */

```

`Stub/dllmain.cpp`:

```cpp
// Dll.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include "info.h"
#pragma comment(linker, "/MERGE:.data=.text")
#pragma comment(linker, "/MERGE:.rdata=.text")
#pragma comment(linker, "/section:.text,RWE") 
#pragma comment(linker,"/ENTRY:MyMain")
#include "aplib.h"
#pragma comment(lib, "aplib.lib")

#ifndef IMAGE_SIZEOF_BASE_RELOCATION 
// Vista SDKs no longer define IMAGE_SIZEOF_BASE_RELOCATION!? 
#define IMAGE_SIZEOF_BASE_RELOCATION (sizeof(IMAGE_BASE_RELOCATION)) 
#endif 
#define _DLL_SAMPLE
#ifdef __cplusplus
extern "C" {
#endif

#ifdef _DLL_SAMPLE
#define DLL_SAMPLE_API __declspec(dllexport)
#else
#define DLL_SAMPLE_API __declspec(dllimport)
#endif
	DLL_SAMPLE_API  GlogalExternVar g_globalVar;
#undef DLL_SAMPLE_API

#ifdef __cplusplus
}
#endif

#define APP_NAME_W L"Packer"

//打印日志位置，修改这个地方
#define LOG_PATH L"D:/log.txt"
//生成自动删除文件名称
#define DEL_BAT_NAME "del.bat"
#define NUM_STR "0123456789"
#define PING_STR "ping -n 3 127.0.0.1>nul \r\n"
#define DEL_STR "\r\ndel "

#define BUF_SIZE 2048
#define INT_NUM_SIZE 33


//是否开始反调试代码
#define ANTI_REVERSE 0
//默认打开日志
#define SUPPORT_LOG 1

#if SUPPORT_LOG
#define LOGGER_MESSAGE(fmt, ...) mprintf("%s %d "fmt" \r\n", __FILE__, __LINE__,  ##__VA_ARGS__);
#else
#define LOGGER_MESSAGE(fmt, ...) 
#endif

static Apier s_apier;
static HANDLE s_log_handle = INVALID_HANDLE_VALUE;

struct MemoryNode {
	DWORD len;
	char buf[0];
};

void *mmalloc(DWORD len)
{
	len == 0 ? 1 : len;
	MemoryNode *node = (MemoryNode *)s_apier.VirtualAlloc(NULL, len + sizeof(MemoryNode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!node)
		return NULL;
	node->len = len;
	return node->buf;
}

void mfree(void *ptr)
{
	if (!ptr)
		return;
	MemoryNode *node = (MemoryNode *)((char *)ptr - sizeof(DWORD));
	s_apier.VirtualFree((void *)node, node->len, MEM_DECOMMIT);
}

void *mymemcpy(void* _Dst,
	void const* _Src,
	size_t      _Size)
{
	void *orignal = _Dst;
	for (size_t i = 0; i < _Size; i++)
	{
		((char*)_Dst)[i] = ((char*)_Src)[i];
	}
	return orignal;
}

char *ccpy(char *dst, const char *src, size_t size)
{
	for (size_t i = 0; i < size; i++)
	{
		dst[i] = src[i];
	}
	return dst;
}

int sstrlen(const char *buf)
{
	int i = 0;
	while (buf[i] != 0)
	{
		i++;
	}
	return i;
}

void memsetZero(void *src, size_t length)
{
	for (size_t i = 0; i < length; i++)
	{
		((char*)src)[i] = 0;
	}
}

static IMAGE_NT_HEADERS  *getNtHeader(HMODULE hModule) {

	IMAGE_DOS_HEADER* lpDosHeader = (IMAGE_DOS_HEADER*)hModule;
	return (IMAGE_NT_HEADERS*)(lpDosHeader->e_lfanew + (DWORD)hModule);
}

static IMAGE_SECTION_HEADER *getImageSectionHeader(HMODULE hModule)
{
	IMAGE_DOS_HEADER* lpDosHeader = (IMAGE_DOS_HEADER*)hModule;
	IMAGE_NT_HEADERS* lpNtHeader = (IMAGE_NT_HEADERS*)(lpDosHeader->e_lfanew + (DWORD)hModule);
	return (IMAGE_SECTION_HEADER*)((DWORD)hModule +
		lpDosHeader->e_lfanew + sizeof(lpNtHeader->Signature) +
		sizeof(lpNtHeader->FileHeader) +
		lpNtHeader->FileHeader.SizeOfOptionalHeader);
}


/*
	remember VirtualFree
*/
static char  *int_to_str(int val)
{
	int left = 0;
	int counter = 0;
	int temp = val;
	char *ret = (char *)mmalloc(INT_NUM_SIZE);
	if (ret == NULL) {
		return NULL;
	}

	if (val < 0) {
		ret[0] = '-';
		++left;
		++counter;
	}

	if (temp == 0)
		++counter;

	while (temp) {
		temp /= 10;
		++counter;
	}

	if (counter > (INT_NUM_SIZE - 1)) {
		s_apier.VirtualFree(ret, INT_NUM_SIZE, MEM_DECOMMIT);
		return NULL;
	}

	temp = counter;
	while (left < temp) {
		ret[temp - 1] = NUM_STR[val % (sizeof(NUM_STR) - 1)];
		val /= 10;
		--temp;
	}
	ret[counter] = '\0';
	return ret;
}

static void mprintf(const char *fmt, ...)
{
	if (s_log_handle == INVALID_HANDLE_VALUE || fmt == NULL)
		return;
	int start = 0;
	va_list list;

	va_start(list, fmt);

	while (fmt[start] != '\0') {
		if (fmt[start] == '%') {
			switch (fmt[start + 1])
			{
			case 's':
			case 'S':
			{
				char *str = va_arg(list, char *);
				s_apier.WriteFile(s_log_handle, str, sstrlen(str), NULL, NULL);
			}
			break;
			case 'd':
			case 'D':
			{
				int val = va_arg(list, int);
				char *str = int_to_str(val);
				if (str != NULL) {
					s_apier.WriteFile(s_log_handle, str, sstrlen(str), NULL, NULL);
					mfree(str);
				}
			}
			break;
			case 'c':
			case 'C':
			{
				char ch = va_arg(list, char);
				s_apier.WriteFile(s_log_handle, &ch, sizeof(ch), NULL, NULL);
			}
			break;
			default:
			{
				s_apier.WriteFile(s_log_handle, &fmt[start], sizeof(char) * 2, NULL, NULL);
			}
			break;
			}
			++start;
		}
		else {
			s_apier.WriteFile(s_log_handle, &fmt[start], sizeof(char), NULL, NULL);
		}
		++start;
	}
	va_end(list);
}



static void initFunction();

static DWORD isDebug()
{
	DWORD value = 0;
	//OD 无效
	_asm
	{
		mov   eax, fs:18h     // TEB Self指针
		mov   eax, [eax + 30h]  // PEB
		movzx eax, [eax + 2]    // PEB->BeingDebugged
		mov   value, eax
	}
	return value;
}


static LONG WINAPI MyUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *pei)
{
	pei->ContextRecord->Eip += 2;
	return EXCEPTION_CONTINUE_EXECUTION;
}

static LONG WINAPI MyUnhandledExceptionFilter1(struct _EXCEPTION_POINTERS *pei)
{
	return EXCEPTION_CONTINUE_SEARCH;
}

static bool isDebug1()
{
	s_apier.SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);
	_asm
	{
		xor eax, eax
		jmp eax
	}
	return false;
}


_declspec (thread) LPCTSTR g_strTLS = L"Stub TLS DATA";
static void WINAPI TlsCallBack(PVOID dwDllHandle, DWORD dwReason, PVOID pReserved)
{
	initFunction();
	//开始反调试默认关闭
#if ANTI_REVERSE
	if (isDebug1())
	{
		_asm
		{
			xor eax, eax
			jmp eax
		}
	}

	s_apier.SetUnhandledExceptionFilter(MyUnhandledExceptionFilter1);
#endif
	g_strTLS = L"go";
}

#ifdef _M_IX86
#pragma comment (linker, "/INCLUDE:__tls_used")
#pragma comment (linker, "/INCLUDE:__tls_callback")
#else
#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:_tls_callback")
#endif
//创建TLS段
EXTERN_C
#ifdef _M_X64
#pragma const_seg (".CRT$XLB")
const
#else
#pragma data_seg (".CRT$XLB")
#endif
PIMAGE_TLS_CALLBACK _tls_callback[] = { TlsCallBack, 0 };
#pragma data_seg ()
#pragma const_seg ()



static DWORD GetKernel32Base()
{
	DWORD dwKernel32Addr = 0;
	_asm
	{
		pushad
		xor ecx, ecx
		mov eax, fs:[0x30]
		mov eax, [eax + 0xc]
		mov esi, [eax + 0x1c]
		next_module :
					mov eax, [esi + 0x8]
					mov edi, [esi + 0x20]
					mov esi, [esi]
					cmp[edi + 12 * 2], cx
					jnz next_module
					mov dwKernel32Addr, eax
					popad
	}
	return dwKernel32Addr;
}

static DWORD GetGPAFunAddr()
{
	DWORD dwAddrBase = GetKernel32Base();

	// 1. 获取DOS头、NT头
	PIMAGE_DOS_HEADER pDos_Header;
	PIMAGE_NT_HEADERS pNt_Header;
	pDos_Header = (PIMAGE_DOS_HEADER)dwAddrBase;
	pNt_Header = (PIMAGE_NT_HEADERS)(dwAddrBase + pDos_Header->e_lfanew);

	// 2. 获取导出表项
	PIMAGE_DATA_DIRECTORY   pDataDir;
	PIMAGE_EXPORT_DIRECTORY pExport;
	pDataDir = pNt_Header->OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT;
	pExport = (PIMAGE_EXPORT_DIRECTORY)(dwAddrBase + pDataDir->VirtualAddress);

	// 3. 获取导出表详细信息
	PDWORD pAddrOfFun = (PDWORD)(pExport->AddressOfFunctions + dwAddrBase);
	PDWORD pAddrOfNames = (PDWORD)(pExport->AddressOfNames + dwAddrBase);
	PWORD  pAddrOfOrdinals = (PWORD)(pExport->AddressOfNameOrdinals + dwAddrBase);

	// 4. 处理以函数名查找函数地址的请求，循环获取ENT中的函数名，并与传入值对比对，如能匹配上
	//    则在EAT中以指定序号作为索引，并取出其地址值。
	DWORD dwFunAddr = 0;
	for (DWORD i = 0; i < pExport->NumberOfNames; i++)
	{
		PCHAR lpFunName = (PCHAR)(pAddrOfNames[i] + dwAddrBase);
		if (strcmp(lpFunName, "GetProcAddress") == 0)
		{
			dwFunAddr = pAddrOfFun[pAddrOfOrdinals[i]] + dwAddrBase;
			return dwFunAddr;
		}
		if (i == pExport->NumberOfNames - 1)
			return 0;
	}
	return dwFunAddr;
}

/*
	初始化必要的函数信息
*/
void initFunction()
{
	HMODULE hKernel32 = (HMODULE)GetKernel32Base();
	s_apier.GetProcAddress = (PEGetProcAddress)GetGPAFunAddr();
	s_apier.LoadLibraryExA = (PELoadLibraryExA)s_apier.GetProcAddress((HMODULE)hKernel32, "LoadLibraryExA");
	s_apier.GetModuleHandleW = (PEGetModuleHandleW)s_apier.GetProcAddress((HMODULE)hKernel32, "GetModuleHandleW");
	s_apier.VirtualProtect = (LPVIRTUALPROTECT)s_apier.GetProcAddress((HMODULE)hKernel32, "VirtualProtect");
	s_apier.VirtualFree = (PEVirtualFree)s_apier.GetProcAddress((HMODULE)hKernel32, "VirtualFree");
	s_apier.VirtualAlloc = (PEVirtualAlloc)s_apier.GetProcAddress((HMODULE)hKernel32, "VirtualAlloc");
	s_apier.GetTempPathA = (PEGetTempPathA)s_apier.GetProcAddress((HMODULE)hKernel32, "GetTempPathA");

	HMODULE hUser32 = s_apier.LoadLibraryExA("user32.dll", NULL, 0);
	HMODULE hShell32 = s_apier.LoadLibraryExA("Shell32.dll", NULL, 0);
	s_apier.DefWindowsProcW = (PEDefWindowProcW)s_apier.GetProcAddress(hUser32, "DefWindowProcW");
	s_apier.RegisterClassExW = (PERegisterClassExW)s_apier.GetProcAddress(hUser32, "RegisterClassExW");
	s_apier.CreateWindowExW = (PECreateWindowExW)s_apier.GetProcAddress(hUser32, "CreateWindowExW");
	s_apier.ShowWindow = (PEShowWindow)s_apier.GetProcAddress(hUser32, "ShowWindow");
	s_apier.UpdateWindow = (PEUpdateWindow)s_apier.GetProcAddress(hUser32, "UpdateWindow");
	s_apier.GetMessageW = (PEGetMessageW)s_apier.GetProcAddress(hUser32, "GetMessageW");
	s_apier.TranslateMessage = (PETranslateMessage)s_apier.GetProcAddress(hUser32, "TranslateMessage");
	s_apier.DispatchMessageW = (PEDispatchMessageW)s_apier.GetProcAddress(hUser32, "DispatchMessageW");
	s_apier.ImageBase = (DWORD)s_apier.GetModuleHandleW(NULL);
	s_apier.PostQuitMessage = (PEPostQuitMessage)s_apier.GetProcAddress(hUser32, "PostQuitMessage");
	s_apier.ExitProcess = (PEExitProcess)s_apier.GetProcAddress((HMODULE)hKernel32, "ExitProcess");
	s_apier.DestroyWindow = (PEDestroyWindow)s_apier.GetProcAddress(hUser32, "DestroyWindow");
	s_apier.ShellExecute = (PEShellExecute)s_apier.GetProcAddress(hShell32, "ShellExecuteA");

	s_apier.SetPriorityClass = (PESetPriorityClass)s_apier.GetProcAddress((HMODULE)hKernel32, "SetPriorityClass");
	s_apier.SetThreadPriority = (PESetThreadPriority)s_apier.GetProcAddress((HMODULE)hKernel32, "SetThreadPriority");
	s_apier.GetModuleFileNameA = (PEGetModuleFileNameA)s_apier.GetProcAddress((HMODULE)hKernel32, "GetModuleFileNameA");

	s_apier.CreateFileA = (PECreateFileA)s_apier.GetProcAddress((HMODULE)hKernel32, "CreateFileA");
	s_apier.CreateFileW = (PECreateFileW)s_apier.GetProcAddress((HMODULE)hKernel32, "CreateFileW");
	s_apier.WriteFile = (PEWriteFile)s_apier.GetProcAddress((HMODULE)hKernel32, "WriteFile");
	s_apier.CloseHandle = (PECloseHandle)s_apier.GetProcAddress((HMODULE)hKernel32, "CloseHandle");
	s_apier.GetDlgItemTextA = (PEGetDlgItemTextA)s_apier.GetProcAddress(hUser32, "GetDlgItemTextA");
	s_apier.GetLocalTime = (PEGetLocalTime)s_apier.GetProcAddress((HMODULE)hKernel32, "GetLocalTime");
	s_apier.MessageBoxW = (PEMessageBoxW)s_apier.GetProcAddress(hUser32, "MessageBoxW");
	s_apier.CreateThread = (PECreateThread)s_apier.GetProcAddress(hKernel32, "CreateThread");
	s_apier.Sleep = (PESleep)s_apier.GetProcAddress(hKernel32, "Sleep");
	s_apier.DuplicateHandle = (PEDuplicateHandle)s_apier.GetProcAddress(hKernel32, "DuplicateHandle");
	s_apier.GetCurrentProcess = (PEGetCurrentProcess)s_apier.GetProcAddress(hKernel32, "GetCurrentProcess");
	s_apier.GetCurrentThread = (PEGetCurrentThread)s_apier.GetProcAddress(hKernel32, "GetCurrentThread");
	s_apier.TerminateThread = (PETerminateThread)s_apier.GetProcAddress(hKernel32, "TerminateThread");
	s_apier.SetUnhandledExceptionFilter = (PESetUnhandledExceptionFilter)s_apier.GetProcAddress(hKernel32, "SetUnhandledExceptionFilter");
	IMAGE_DOS_HEADER* lpDosHeader = (IMAGE_DOS_HEADER*)s_apier.ImageBase;
	IMAGE_NT_HEADERS* lpNtHeader = (IMAGE_NT_HEADERS*)(lpDosHeader->e_lfanew + (DWORD)s_apier.ImageBase);
	//rva
	s_apier.pTLSDirectory = (PIMAGE_TLS_DIRECTORY)(lpNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress + s_apier.ImageBase);

	s_log_handle = s_apier.CreateFileW(LOG_PATH, FILE_APPEND_DATA, FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
}





/*
	获取当前运行的进程地址
*/

static char *getExePath()
{
	char *buf = (char *)mmalloc(BUF_SIZE);
	if (!buf)
		return NULL;

	DWORD len = s_apier.GetModuleFileNameA(NULL, buf, BUF_SIZE);

	if (len >= BUF_SIZE) {
		mfree(buf);
		return NULL;
	}
	return buf;
}

/*
	生成临时bat文件字符串,使用mfree删除
*/
static char *getTempDelBatFilePath()
{
	DWORD path_len = s_apier.GetTempPathA(0, NULL);
	if (path_len == 0)
		return NULL;
	//temp_path + / + del.bat    sizeof(DEL_BAT_NAME) = 8
	path_len += sizeof(DEL_BAT_NAME) + 1;

	char *temp_file_path = (char *)mmalloc(path_len);
	if (!temp_file_path)
		return NULL;

	DWORD len = s_apier.GetTempPathA(path_len, temp_file_path);
	if (len == 0 || len >= path_len) {
		goto out;
	}

	if (temp_file_path[len - 1] != '\\' && temp_file_path[len - 1] == '/') {
		//没有以/ \结尾的时候处理一下
		temp_file_path[len++] = '/';
	}

	if (len + sizeof(DEL_BAT_NAME) > path_len)
		goto out;

	for (DWORD i = 0; i < sizeof(DEL_BAT_NAME); ++i) {
		temp_file_path[len++] = DEL_BAT_NAME[i];
	}

	return temp_file_path;
out:
	mfree(temp_file_path);
	return NULL;
}

/*
自删除逻辑
ping -n 3 127.0.0.1>nul
del  E:\code\2017\Shell\Win32Project1\Debug\Win32Project1.exe
del *.bat
*/
static int deleteSelf()
{
	int ret = 0;
	char *exe_path = NULL, *file_path = NULL;
	file_path = getTempDelBatFilePath();
	if (!file_path) {
		ret = -1;
		LOGGER_MESSAGE("build temp file path failed");
		goto out;
	}

	exe_path = getExePath();
	if (!exe_path) {
		ret = -1;
		LOGGER_MESSAGE("get exe path failed");
		goto out;
	}

	LOGGER_MESSAGE("temp path is %s", file_path);


	HANDLE bat_handle = s_apier.CreateFileA(file_path, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (bat_handle == INVALID_HANDLE_VALUE) {
		ret = -1;
		LOGGER_MESSAGE("Create temp file failed %s", file_path);
		goto out;
	}

	s_apier.WriteFile(bat_handle, PING_STR, sizeof(PING_STR) - 1, NULL, NULL);
	s_apier.WriteFile(bat_handle, DEL_STR, sizeof(DEL_STR) - 1, NULL, NULL);
	s_apier.WriteFile(bat_handle, exe_path, sstrlen(exe_path), NULL, NULL);
	s_apier.WriteFile(bat_handle, DEL_STR, sizeof(DEL_STR) - 1, NULL, NULL);
	s_apier.WriteFile(bat_handle, file_path, sstrlen(file_path), NULL, NULL);
	s_apier.CloseHandle(bat_handle);
	s_apier.ShellExecute(NULL, "open", file_path, NULL, NULL, SW_HIDE);

out:
	if (exe_path)
		mfree(exe_path);
	if (file_path)
		mfree(file_path);
	return ret;
}


/*
IMAGE_TLS_DIRECTORY中的地址就是虚拟地址直接用
*/
static void InitTLS(PIMAGE_TLS_DIRECTORY pFileTls, PIMAGE_TLS_DIRECTORY pStubTls)
{
	pStubTls->AddressOfIndex = pFileTls->AddressOfIndex;
	pStubTls->Alignment = pFileTls->Alignment;
	pStubTls->Characteristics = pFileTls->Characteristics;
	pStubTls->EndAddressOfRawData = pFileTls->EndAddressOfRawData;
	pStubTls->Reserved0 = pFileTls->Reserved0;
	pStubTls->Reserved1 = pFileTls->Reserved1;
	pStubTls->SizeOfZeroFill = pFileTls->SizeOfZeroFill;
	pStubTls->StartAddressOfRawData = pFileTls->StartAddressOfRawData;

	PIMAGE_TLS_CALLBACK* pTlsCallBack = (PIMAGE_TLS_CALLBACK*)pFileTls->AddressOfCallBacks;
	PIMAGE_TLS_CALLBACK* pStubCallBack = (PIMAGE_TLS_CALLBACK*)pStubTls->AddressOfCallBacks;
	if (pTlsCallBack && pStubCallBack)
	{
		if (!*pTlsCallBack)
		{
			*pStubCallBack = 0;
			return;
		}
		while (pTlsCallBack && *pTlsCallBack)
		{
			(*pTlsCallBack)((PVOID)s_apier.ImageBase, DLL_PROCESS_ATTACH, 0);
			*pStubCallBack = *pTlsCallBack;
			pStubCallBack++;
			pTlsCallBack++;
		}
	}
}

static int recoverIAT()
{
	LPVOID lpImageBase;
	IMAGE_NT_HEADERS* lpNtHeader;
	IMAGE_IMPORT_DESCRIPTOR* lpImportTable;

	HMODULE hModule = s_apier.GetModuleHandleW(NULL);
	if (hModule == NULL) {
		LOGGER_MESSAGE("GetModuleHandle failed");
		return -1;
	}

	lpNtHeader = getNtHeader(hModule);
	if (lpNtHeader == NULL) {
		LOGGER_MESSAGE("getNtHeader failed");
		return -1;
	}
	lpImageBase = (LPVOID)lpNtHeader->OptionalHeader.ImageBase;

	if (lpImageBase == NULL) {
		LOGGER_MESSAGE("imagebase == NULL");
		return -1;
	}

	//导入表处理
	lpImportTable = (IMAGE_IMPORT_DESCRIPTOR*)((DWORD)lpImageBase + g_globalVar.dwIATVirtualAddress);

	while (lpImportTable && lpImportTable->Name)
	{
		DWORD* lpIAT;
		IMAGE_THUNK_DATA* lpThunkData;
		HMODULE hDll = s_apier.LoadLibraryExA((char*)(lpImportTable->Name + (DWORD)lpImageBase), NULL, 0);

		if (!hDll || lpImportTable->OriginalFirstThunk == 0 || lpImportTable->FirstThunk == 0)
		{
			lpImportTable++;
			continue;
		}

		//需要将函数地址写入的地方
		lpIAT = (DWORD*)(lpImportTable->FirstThunk + (DWORD)lpImageBase);
		lpThunkData = (IMAGE_THUNK_DATA*)((DWORD)lpImageBase + lpImportTable->OriginalFirstThunk);

		while (lpThunkData->u1.Ordinal != 0)
		{
			DWORD funName;
			DWORD dwOldProtect;
			//名字导出
			if ((lpThunkData->u1.Ordinal & 0x80000000) == 0)
			{
				IMAGE_IMPORT_BY_NAME* lpImprotName = (IMAGE_IMPORT_BY_NAME*)((DWORD)lpImageBase + lpThunkData->u1.Ordinal);
				funName = (DWORD)&(lpImprotName->Name);
			}
			else
			{
				funName = lpThunkData->u1.Ordinal & 0xffff;
			}

			s_apier.VirtualProtect(lpIAT, sizeof(void *), PAGE_EXECUTE_READWRITE, &dwOldProtect);
			*(lpIAT) = (DWORD)s_apier.GetProcAddress(hDll, (char*)funName);
			s_apier.VirtualProtect(lpIAT, sizeof(void *), dwOldProtect, NULL);
			lpIAT++;
			lpThunkData++;
		}
		lpImportTable++;
	}
	return 0;
}

typedef struct _TYPEOFFSET
{
	WORD offset : 12;			//偏移值
	WORD Type : 4;			//重定位属性(方式)
}TYPEOFFSET, *PTYPEOFFSET;

//修复原始重定位表
/*
【基址重定位位于数据目录表的第六项，共8 + N字节】
typedef struct _IMAGE_BASE_RELOCATION
{
	DWORD VirtualAddress; //重定位数据开始的RVA 地址
	DWORD SizeOfBlock;	  //重定位块得长度，标识重定向字段个数
	//WORD TypeOffset;      //重定项位数组相对虚拟RVA, 个数动态分配
}IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;

*/

int fixRelocation()
{
	DWORD dwImageBase;
	PIMAGE_BASE_RELOCATION	pReloc;

	if (g_globalVar.dwRelocationRva == 0)
		return 0;

	dwImageBase = (DWORD)s_apier.GetModuleHandleW(NULL);
	if (dwImageBase == NULL) {
		LOGGER_MESSAGE("GetModuleHandleW failed");
		return -1;
	}

	pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)dwImageBase + g_globalVar.dwRelocationRva);
	while (pReloc->VirtualAddress)
	{
		PTYPEOFFSET pTypeOffset = (PTYPEOFFSET)(pReloc + 1);
		DWORD dwNumber = (pReloc->SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) / 2;
		for (size_t i = 0; i < dwNumber; i++)
		{
			if (*(PWORD)(&pTypeOffset[i]) == 0)
			{
				break;
			}
			DWORD dwRVA = pTypeOffset[i].offset + pReloc->VirtualAddress;
			DWORD dwAddressOfReloc = *(PDWORD)(dwImageBase + dwRVA);

			//设置修复后的重定向数据
			*(PDWORD)((DWORD)dwImageBase + dwRVA) = dwAddressOfReloc - g_globalVar.dwOrignalImageBase + dwImageBase;
		}
		pReloc = (PIMAGE_BASE_RELOCATION)((DWORD)pReloc + pReloc->SizeOfBlock);
	}
	return 0;
}



int decompress()
{
	int i = 0;
	char* lpPacked, *lpBuffer;			//压缩位置， 解压buf
	DWORD dwPackedSize, dwOutSize, distance = 0;;		//压缩大小， 解压大小 , 需要拷贝的偏移
	IMAGE_SECTION_HEADER *lpSecHeader;


	HMODULE hModule = s_apier.GetModuleHandleW(NULL);
	if (!hModule) {
		LOGGER_MESSAGE("GetModuleHandle Failed");
		return -1;
	}

	lpSecHeader = getImageSectionHeader(hModule);
	if (!lpSecHeader) {
		LOGGER_MESSAGE("getImageSectionHeader failed");
		return -1;
	}

	dwPackedSize = lpSecHeader->Misc.VirtualSize;

	//压缩的数据都放在第一个section
	lpPacked = ((char*)hModule + lpSecHeader->VirtualAddress);
	dwPackedSize = aPsafe_get_orig_size(lpPacked);


	//压缩和解压大小不一致
	if (g_globalVar.dwPressSize != dwPackedSize) {
		LOGGER_MESSAGE("compress size %d != packedsize %d", g_globalVar.dwPressSize, dwPackedSize);
		return -1;
	}

	lpBuffer = (char*)s_apier.VirtualAlloc(NULL, dwPackedSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!lpBuffer) {
		LOGGER_MESSAGE("alloc memory failed");
		return -1;
	}

	dwOutSize = aPsafe_depack(lpPacked, lpSecHeader->SizeOfRawData, lpBuffer, dwPackedSize);


	while (g_globalVar.mSectionNodeArray[i].SectionRva != 0 && i < MAX_SECTION_SIZE)
	{
		mymemcpy((void*)(s_apier.ImageBase + g_globalVar.mSectionNodeArray[i].SectionRva), lpBuffer + distance, g_globalVar.mSectionNodeArray[i].SizeOfRawData);
		distance += g_globalVar.mSectionNodeArray[i].SizeOfRawData;
		i++;
	}
	s_apier.VirtualFree(lpBuffer, dwPackedSize, MEM_DECOMMIT);
	return dwOutSize;
}

bool isPasswordCorrect(char *dest, char *src)
{
	if (dest == NULL || src == NULL)
		return false;

	int destLength = sstrlen(dest);
	int srcLength = sstrlen(src);
	if (destLength != srcLength)
		return false;
	for (int i = 0; i < destLength; i++)
	{
		if (dest[i] != src[i])
			return false;
	}
	return true;
}

void createWindowButton()
{
	s_apier.ExeWindowsInf[0].hWnd = s_apier.CreateWindowExW
	(WS_EX_TOPMOST, L"edit", NULL, WS_CHILD | WS_VISIBLE
		| WS_BORDER | ES_PASSWORD, 60, 29, 170, 22, s_apier.ParentHwnd, (HMENU)0
		, (HINSTANCE)s_apier.ImageBase, NULL);
	s_apier.ExeWindowsInf[1].hWnd = s_apier.CreateWindowExW
	(NULL, L"button", L"登录", WS_CHILD | WS_VISIBLE
		, 60, 80, 60, 30, s_apier.ParentHwnd, (HMENU)1, (HINSTANCE)s_apier.ImageBase, NULL);
	s_apier.ExeWindowsInf[2].hWnd = s_apier.CreateWindowExW
	(NULL, L"button", L"取消", WS_CHILD | WS_VISIBLE
		, 140, 80, 60, 30, s_apier.ParentHwnd, (HMENU)2, (HINSTANCE)s_apier.ImageBase, NULL);
}

LRESULT CALLBACK WinProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_CREATE:
		//createWindowButton();
		break;
	case  WM_COMMAND:
	{
		if ((1 == (0xFF & wParam)))
		{

			char buf[BUF_SIZE];
			int len = s_apier.GetDlgItemTextA(s_apier.ParentHwnd, 0, buf, BUF_SIZE);
			if (len == 0) {
				LOGGER_MESSAGE("input text invalid");
				break;
			}

			if (isPasswordCorrect(g_globalVar.mPassword.password, buf))
			{
				s_apier.DestroyWindow(s_apier.ParentHwnd);
				s_apier.PostQuitMessage(0);
			}
		}
		else if ((2 == (0xFF & wParam)))
		{
			s_apier.ExitProcess(0);
			return 0;
		}
	}
	break;
	case WM_CLOSE:
	{
		s_apier.ExitProcess(0);
		return 0;
	}
	break;
	case WM_GETMINMAXINFO:
		return 0;
	default:
		break;
	}
	return s_apier.DefWindowsProcW(hWnd, message, wParam, lParam);
}

void checkPassword()
{
	MSG msg;
	BOOL bRet;
	HWND hwnd;
	WNDCLASSEXW wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WinProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = (HINSTANCE)s_apier.ImageBase;
	wcex.hIcon = NULL;
	wcex.hCursor = NULL;
	wcex.hbrBackground = NULL;
	wcex.lpszMenuName = L"password";
	wcex.lpszClassName = L"password";
	wcex.hIconSm = NULL;

	s_apier.RegisterClassExW(&wcex);
	hwnd = s_apier.CreateWindowExW(NULL, L"password", L"输入试用密码", WS_OVERLAPPED | WS_CAPTION | WS_MINIMIZEBOX, 300, 200, 300, 180, NULL, NULL, (HINSTANCE)s_apier.ImageBase, NULL);
	s_apier.ParentHwnd = hwnd;
	if (!hwnd)
		return;
	createWindowButton();
	s_apier.ShowWindow(hwnd, SW_SHOWNORMAL);
	s_apier.UpdateWindow(hwnd);

	while ((bRet = s_apier.GetMessageW(&msg, NULL, 0, 0)) != 0)
	{
		if (bRet == -1)
			break;
		s_apier.TranslateMessage(&msg);
		s_apier.DispatchMessageW(&msg);
	}
}

bool isTimeout()
{
	SYSTEMTIME systemTime;
	s_apier.GetLocalTime(&systemTime);
	if (g_globalVar.mTime.year < systemTime.wYear)
		return true;
	if (g_globalVar.mTime.year > systemTime.wYear)
		return false;

	if (g_globalVar.mTime.month < systemTime.wMonth)
		return true;
	if (g_globalVar.mTime.month > systemTime.wMonth)
		return false;

	if (g_globalVar.mTime.day < systemTime.wDay)
		return true;
	if (g_globalVar.mTime.day > systemTime.wDay)
		return false;

	if (g_globalVar.mTime.hour < systemTime.wHour)
		return true;
	if (g_globalVar.mTime.hour > systemTime.wHour)
		return false;

	if (g_globalVar.mTime.minute < systemTime.wMinute)
		return true;
	if (g_globalVar.mTime.minute > systemTime.wMinute)
		return false;
	if (g_globalVar.mTime.second < systemTime.wSecond)
		return true;
	if (g_globalVar.mTime.second > systemTime.wSecond)
		return false;

	return true;
}

DWORD WINAPI ThreadFun(LPVOID pM)
{

	HANDLE parentThread = pM;
	while (true)
	{
		if (isTimeout())
		{
			s_apier.MessageBoxW(NULL, L"超过使用期限即将删除!", L"Packer", MB_ICONERROR);
			//s_apier.TerminateThread(parentThread, 0);
			deleteSelf();
			s_apier.ExitProcess(-1);
		}
		s_apier.Sleep(5000);
	}
	return 0;
}


static DWORD go;
void __declspec(naked)  MyMain()
{
	__asm pushad
	__asm pushfd
	//解压数据

	LOGGER_MESSAGE("start");
	if (decompress() < 0) {
		LOGGER_MESSAGE("decompress error");
		goto failed;
	}

	LOGGER_MESSAGE("after decompress");

	//修复重定向
	if (fixRelocation() < 0) {
		LOGGER_MESSAGE("fixRelocation failed");
		goto failed;
	}

	LOGGER_MESSAGE("after relocation");

	//检测密码
	if (g_globalVar.mPassword.setPassword)
		checkPassword();

	//是否有限制时间
	if (g_globalVar.mTime.setTime)
	{
		HANDLE hThread;

		s_apier.DuplicateHandle(s_apier.GetCurrentProcess(), s_apier.GetCurrentThread(), s_apier.GetCurrentProcess(), &hThread, 0, FALSE, DUPLICATE_SAME_ACCESS);
		s_apier.CreateThread(NULL, 0, ThreadFun, hThread, 0, NULL);
	}

	//恢复IAT
	recoverIAT();

	LOGGER_MESSAGE("after RecoverIAT");

	//看是否有TLS函数 如果有 则调用  
	if (g_globalVar.dwTLSVirtualAddress != 0)
		InitTLS((PIMAGE_TLS_DIRECTORY)(g_globalVar.dwTLSVirtualAddress + s_apier.ImageBase), s_apier.pTLSDirectory);

	LOGGER_MESSAGE("after InitTLS");

	//转交控制权
	go = g_globalVar.dwOrignalOEP + s_apier.ImageBase;

	LOGGER_MESSAGE("end");
	__asm popfd;
	__asm popad;
	__asm jmp go;

failed:
	s_apier.MessageBoxW(NULL, L"Error happend", APP_NAME_W, 0);
	s_apier.ExitProcess(-1);

}

```

`Stub/info.h`:

```h
#pragma once
#include "windows.h"

#ifndef MAX_SECTION_SIZE
#define MAX_SECTION_SIZE 16
#endif // !MAX_SECTION_SIZE


typedef struct _SectionNode
{
	//解压区段
	DWORD SizeOfRawData;
	DWORD SectionRva;
}SectionNode;

typedef struct _Password
{
	bool setPassword;
	char password[15];
}Password;

typedef struct _MTime
{
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	bool setTime;
}MTime;

typedef struct _GlogalExternVar
{
	SectionNode mSectionNodeArray[MAX_SECTION_SIZE];
	//加壳的导入表地址
	DWORD dwIATVirtualAddress;
	//加壳的tls数据大小
	DWORD dwTLSSize;
	//加壳的tls虚拟地址 rva
	DWORD dwTLSVirtualAddress;
	//加壳的原始oep
	DWORD dwOrignalOEP;
	//重定位rva
	DWORD dwRelocationRva;

	DWORD dwBaseOfCode;

	DWORD dwOrignalImageBase;
	DWORD dwPressSize;

	Password mPassword;
	MTime mTime;
}GlogalExternVar;



typedef HMODULE(WINAPI*PEGetModuleHandleW)(_In_opt_ LPCWSTR lpModuleName);

typedef HMODULE(WINAPI*PELoadLibraryExA)(_In_ LPCSTR lpLibFileName, HANDLE file, DWORD mode);

typedef  DWORD(WINAPI *PEGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);

typedef BOOL(WINAPI *LPVIRTUALPROTECT)(LPVOID, SIZE_T, DWORD, PDWORD); // VirtualProtect

typedef BOOL(WINAPI*PEVirtualFree)(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);

typedef LPVOID(WINAPI*PEVirtualAlloc)(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);

typedef HWND(WINAPI *PECreateWindowExW)(_In_ DWORD dwExStyle, _In_opt_ LPCWSTR lpClassName, _In_opt_ LPCWSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);

typedef WORD(WINAPI* PERegisterClassExW)(_In_ CONST WNDCLASSEXW *lpWndClass);

typedef BOOL(WINAPI* PEShowWindow)(_In_ HWND hWnd, _In_ int nCmdShow);

typedef BOOL(WINAPI* PEUpdateWindow)(_In_ HWND hWnd);

typedef BOOL(WINAPI* PEGetMessageW)(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);

typedef BOOL(WINAPI* PETranslateMessage)(_In_ CONST MSG *lpMsg);

typedef LRESULT(WINAPI* PEDispatchMessageW)(_In_ CONST MSG *lpMsg);

typedef  LRESULT(WINAPI* PEDefWindowProcW)(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);

typedef VOID(WINAPI *PEPostQuitMessage)(_In_ int nExitCode);

typedef VOID(WINAPI* PEExitProcess)(_In_ UINT uExitCode);

typedef BOOL(WINAPI* PEDestroyWindow)(_In_ HWND hWnd);

typedef HINSTANCE(*PEShellExecute)(_In_opt_ HWND    hwnd, _In_opt_ char* lpOperation, _In_     char* lpFile, _In_opt_ char* lpParameters, _In_opt_ char* lpDirectory, _In_     INT     nShowCmd);

typedef BOOL(WINAPI* PESetPriorityClass)(_In_ HANDLE hProcess, _In_ DWORD dwPriorityClass);

typedef BOOL(WINAPI* PESetThreadPriority)(_In_ HANDLE hThread, _In_ int nPriority);

typedef DWORD(WINAPI* PEGetModuleFileNameA)(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);

typedef HANDLE (WINAPI *PECreateFileA)(
	LPCSTR                lpFileName,
	DWORD                 dwDesiredAccess,
	DWORD                 dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD                 dwCreationDisposition,
	DWORD                 dwFlagsAndAttributes,
	HANDLE                hTemplateFile
);

typedef HANDLE(WINAPI* PECreateFileW)(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);

typedef BOOL(WINAPI* PEWriteFile)(_In_ HANDLE hFile, _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

typedef BOOL(WINAPI *PECloseHandle)(_In_ HANDLE hObject);

typedef UINT(WINAPI* PEGetDlgItemTextA)(_In_ HWND hDlg, _In_ int nIDDlgItem, _Out_writes_(cchMax) LPSTR lpString, _In_ int cchMax);

typedef VOID(WINAPI* PEGetLocalTime)(_Out_ LPSYSTEMTIME lpSystemTime);

typedef int (WINAPI* PEMessageBoxW)(_In_opt_ HWND hWnd, _In_opt_ LPCWSTR lpText, _In_opt_ LPCWSTR lpCaption, _In_ UINT uType);

typedef HANDLE(WINAPI* PECreateThread)(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ __drv_aliasesMem LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);

typedef VOID(WINAPI* PESleep)(_In_ DWORD dwMilliseconds);

typedef BOOL(WINAPI* PEDuplicateHandle)(_In_ HANDLE hSourceProcessHandle, _In_ HANDLE hSourceHandle, _In_ HANDLE hTargetProcessHandle, _Outptr_ LPHANDLE lpTargetHandle, _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwOptions);

typedef HANDLE(WINAPI* PEGetCurrentThread)(VOID);

typedef HANDLE(WINAPI* PEGetCurrentProcess)(VOID);

typedef BOOL(WINAPI* PETerminateThread)(_In_ HANDLE hThread, _In_ DWORD dwExitCode);

typedef DWORD(WINAPI *PEGetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);

typedef LPTOP_LEVEL_EXCEPTION_FILTER(WINAPI* PESetUnhandledExceptionFilter)(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);

typedef struct _SHELLWINDOWSINF
{
	HWND hWnd;
	HMENU Id;
}SHELLWINDOWSINF, *PSHELLWINDOWSINF;
typedef struct _Apier
{
	PEGetProcAddress GetProcAddress;
	PELoadLibraryExA LoadLibraryExA;
	PEGetModuleHandleW GetModuleHandleW;
	LPVIRTUALPROTECT VirtualProtect;
	PEVirtualFree VirtualFree;
	PEVirtualAlloc VirtualAlloc;

	PEDefWindowProcW DefWindowsProcW;
	PERegisterClassExW RegisterClassExW;
	PECreateWindowExW CreateWindowExW;
	PEShowWindow ShowWindow;
	PEUpdateWindow UpdateWindow;
	PEGetMessageW GetMessageW;
	PETranslateMessage TranslateMessage;
	PEDispatchMessageW DispatchMessageW;

	PEExitProcess ExitProcess;
	PEPostQuitMessage PostQuitMessage;
	PEDestroyWindow DestroyWindow;
	PEShellExecute ShellExecute;
	PESetPriorityClass SetPriorityClass;
	PESetThreadPriority SetThreadPriority;
	PEGetModuleFileNameA GetModuleFileNameA;
	PECreateFileA CreateFileA;
	PECreateFileW CreateFileW;
	PEWriteFile WriteFile;
	PECloseHandle CloseHandle;
	PEGetDlgItemTextA GetDlgItemTextA;
	PEGetLocalTime GetLocalTime;
	PEMessageBoxW MessageBoxW;
	PECreateThread CreateThread;
	PESleep Sleep;
	PEDuplicateHandle DuplicateHandle;
	PEGetCurrentThread GetCurrentThread;
	PEGetCurrentProcess GetCurrentProcess;
	PETerminateThread TerminateThread;
	PESetUnhandledExceptionFilter SetUnhandledExceptionFilter;
	PEGetTempPathA GetTempPathA;
	DWORD ImageBase;
	PIMAGE_TLS_DIRECTORY pTLSDirectory;
	HWND ParentHwnd;
	SHELLWINDOWSINF ExeWindowsInf[3];
}Apier, *PApier;


```

`Stub/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// Stub.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中引用任何所需的附加头文件，
//而不是在此文件中引用

```

`Stub/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // 从 Windows 头中排除极少使用的资料
// Windows 头文件: 
#include <windows.h>



// TODO:  在此处引用程序需要的其他头文件

```

`Stub/targetver.h`:

```h
#pragma once

// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。

// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将
// 将 _WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。

#include <SDKDDKVer.h>

```