Project Path: arc_gmh5225_vmdevirt-vtil_t11l72tm

Source Tree:

```txt
arc_gmh5225_vmdevirt-vtil_t11l72tm
├── CMakeLists.txt
├── cmake.toml
├── cmkr.cmake
├── deps
│   ├── CMakeLists.txt
│   ├── VTIL-Core
│   ├── asmjit
│   ├── cmake.toml
│   └── vmemu
├── include
│   ├── cli-parser.hpp
│   ├── vm-lifter.hpp
│   ├── vmdevirt-vtil.hpp
│   ├── vtil-compile.hpp
│   └── zyreg_to_register_desc.hpp
└── src
    ├── lifters.cpp
    ├── vm-lifter.cpp
    ├── vmdevirt-vtil.cpp
    └── vtil-compile.cpp

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

# Regenerate CMakeLists.txt automatically in the root project
set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif()

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

set(ASMJIT_STATIC true)

project(vmdevirt-vtil)

# deps
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/deps")
else()
	set(CMAKE_FOLDER deps)
endif()
add_subdirectory(deps)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Target vmdevirt-vtil
set(CMKR_TARGET vmdevirt-vtil)
set(vmdevirt-vtil_SOURCES "")

list(APPEND vmdevirt-vtil_SOURCES
	"src/lifters.cpp"
	"src/vm-lifter.cpp"
	"src/vmdevirt-vtil.cpp"
	"src/vtil-compile.cpp"
	"include/cli-parser.hpp"
	"include/vm-lifter.hpp"
	"include/vmdevirt-vtil.hpp"
	"include/vtil-compile.hpp"
	"include/zyreg_to_register_desc.hpp"
)

list(APPEND vmdevirt-vtil_SOURCES
	cmake.toml
)

set(CMKR_SOURCES ${vmdevirt-vtil_SOURCES})
add_executable(vmdevirt-vtil)

if(vmdevirt-vtil_SOURCES)
	target_sources(vmdevirt-vtil PRIVATE ${vmdevirt-vtil_SOURCES})
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT vmdevirt-vtil)
endif()

source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${vmdevirt-vtil_SOURCES})

target_compile_features(vmdevirt-vtil PRIVATE
	cxx_std_20
)

target_include_directories(vmdevirt-vtil PRIVATE
	include
	includes
	"deps/VTIL-Core/VTIL/includes"
)

target_link_libraries(vmdevirt-vtil PRIVATE
	vmemu
	VTIL
	asmjit::asmjit
)

unset(CMKR_TARGET)
unset(CMKR_SOURCES)


```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[project]
name = "vmdevirt-vtil"
cmake-before = """
set(ASMJIT_STATIC true)
"""

[subdir.deps]

# TODO: define a target for each of your executables/libraries like this:
#[target.myexecutable]
#type = "executable" # static, shared
#sources = ["src/vmdevirt-vtil/*.cpp", "include/vmdevirt-vtil/*.hpp"]
#include-directories = ["include"]
#compile-features = ["cxx_std_11"]
#link-libraries = ["target-or-library"]

[target.vmdevirt-vtil]
type = "executable"
sources = ["src/**.cpp", "include/**.hpp"]
include-directories = ["include", "includes", "deps/VTIL-Core/VTIL/includes"]
compile-features = ["cxx_std_20"]
link-libraries = [
    "vmemu",
    "VTIL",
    "asmjit::asmjit"
]
```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.14" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`deps/CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# vmemu
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/vmemu")
else()
	set(CMAKE_FOLDER vmemu)
endif()
add_subdirectory(vmemu)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# VTIL-Core
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/VTIL-Core")
else()
	set(CMAKE_FOLDER VTIL-Core)
endif()
add_subdirectory(VTIL-Core)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# asmjit
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/asmjit")
else()
	set(CMAKE_FOLDER asmjit)
endif()
add_subdirectory(asmjit)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})


```

`deps/cmake.toml`:

```toml
[subdir.vmemu]
[subdir.VTIL-Core]
[subdir.asmjit]
```

`include/cli-parser.hpp`:

```hpp
/**
 * License: Apache 2.0 with LLVM Exception or GPL v3
 *
 * Author: Jesse Laning
 */
#ifndef ARGPARSE_H
#define ARGPARSE_H
#include <algorithm>
#include <cctype>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <locale>
#include <map>
#include <numeric>
#include <sstream>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>
namespace argparse {
    namespace detail {
        static inline bool _not_space(int ch) { return !std::isspace(ch); }
        static inline void _ltrim(std::string& s, bool (*f)(int) = _not_space) {
            s.erase(s.begin(), std::find_if(s.begin(), s.end(), f));
        }
        static inline void _rtrim(std::string& s, bool (*f)(int) = _not_space) {
            s.erase(std::find_if(s.rbegin(), s.rend(), f).base(), s.end());
        }
        static inline void _trim(std::string& s, bool (*f)(int) = _not_space) {
            _ltrim(s, f);
            _rtrim(s, f);
        }
        static inline std::string _ltrim_copy(std::string s,
            bool (*f)(int) = _not_space) {
            _ltrim(s, f);
            return s;
        }
        static inline std::string _rtrim_copy(std::string s,
            bool (*f)(int) = _not_space) {
            _rtrim(s, f);
            return s;
        }
        static inline std::string _trim_copy(std::string s,
            bool (*f)(int) = _not_space) {
            _trim(s, f);
            return s;
        }
        template <typename InputIt>
        static inline std::string _join(InputIt begin, InputIt end,
            const std::string& separator = " ") {
            std::ostringstream ss;
            if (begin != end) {
                ss << *begin++;
            }
            while (begin != end) {
                ss << separator;
                ss << *begin++;
            }
            return ss.str();
        }
        static inline bool _is_number(const std::string& arg) {
            std::istringstream iss(arg);
            float f;
            iss >> std::noskipws >> f;
            return iss.eof() && !iss.fail();
        }
        static inline int _find_equal(const std::string& s) {
            for (size_t i = 0; i < s.length(); ++i) {
                // if find graph symbol before equal, end search
                // i.e. don't accept --asd)f=0 arguments
                // but allow --asd_f and --asd-f arguments
                if (std::ispunct(static_cast<int>(s[i]))) {
                    if (s[i] == '=') {
                        return static_cast<int>(i);
                    }
                    else if (s[i] == '_' || s[i] == '-') {
                        continue;
                    }
                    return -1;
                }
            }
            return -1;
        }
        static inline size_t _find_name_end(const std::string& s) {
            size_t i;
            for (i = 0; i < s.length(); ++i) {
                if (std::ispunct(static_cast<int>(s[i]))) {
                    break;
                }
            }
            return i;
        }
        namespace is_vector_impl {
            template <typename T>
            struct is_vector : std::false_type {};
            template <typename... Args>
            struct is_vector<std::vector<Args...>> : std::true_type {};
        }  // namespace is_vector_impl
        // type trait to utilize the implementation type traits as well as decay the
        // type
        template <typename T>
        struct is_vector {
            static constexpr bool const value =
                is_vector_impl::is_vector<typename std::decay<T>::type>::value;
        };
    }  // namespace detail
    class argument_parser_t {
    private:
    public:
        class Argument;
        class Result {
        public:
            Result() {}
            Result(std::string err) noexcept : _error(true), _what(err) {}
            operator bool() const { return _error; }
            friend std::ostream& operator<<(std::ostream& os, const Result& dt);
            const std::string& what() const { return _what; }
        private:
            bool _error{ false };
            std::string _what{};
        };
        class Argument {
        public:
            enum Position : int { LAST = -1, DONT_CARE = -2 };
            enum Count : int { ANY = -1 };
            Argument& name(const std::string& name) {
                _names.push_back(name);
                return *this;
            }
            Argument& names(std::vector<std::string> names) {
                _names.insert(_names.end(), names.begin(), names.end());
                return *this;
            }
            Argument& description(const std::string& description) {
                _desc = description;
                return *this;
            }
            Argument& required(bool req) {
                _required = req;
                return *this;
            }
            Argument& position(int position) {
                if (position != Position::LAST) {
                    // position + 1 because technically argument zero is the name of the
                    // executable
                    _position = position + 1;
                }
                else {
                    _position = position;
                }
                return *this;
            }
            Argument& count(int count) {
                _count = count;
                return *this;
            }
            bool found() const { return _found; }
            template <typename T>
            typename std::enable_if<detail::is_vector<T>::value, T>::type get() {
                T t = T();
                typename T::value_type vt;
                for (auto& s : _values) {
                    std::istringstream in(s);
                    in >> vt;
                    t.push_back(vt);
                }
                return t;
            }
            template <typename T>
            typename std::enable_if<!detail::is_vector<T>::value, T>::type get() {
                std::istringstream in(get<std::string>());
                T t = T();
                in >> t >> std::ws;
                return t;
            }
        private:
            Argument(const std::string& name, const std::string& desc,
                bool required = false)
                : _desc(desc), _required(required) {
                _names.push_back(name);
            }
            Argument() {}
            friend class argument_parser_t;
            int _position{ Position::DONT_CARE };
            int _count{ Count::ANY };
            std::vector<std::string> _names{};
            std::string _desc{};
            bool _found{ false };
            bool _required{ false };
            int _index{ -1 };
            std::vector<std::string> _values{};
        };
        argument_parser_t(std::string bin, std::string desc)
            : _bin(bin), _desc(desc) {}
        Argument& add_argument() {
            _arguments.push_back({});
            _arguments.back()._index = static_cast<int>(_arguments.size()) - 1;
            return _arguments.back();
        }
        Argument& add_argument(const std::string& name, const std::string& long_name,
            const std::string& desc, const bool required = false) {
            _arguments.push_back(Argument(name, desc, required));
            _arguments.back()._names.push_back(long_name);
            _arguments.back()._index = static_cast<int>(_arguments.size()) - 1;
            return _arguments.back();
        }
        Argument& add_argument(const std::string& name, const std::string& desc,
            const bool required = false) {
            _arguments.push_back(Argument(name, desc, required));
            _arguments.back()._index = static_cast<int>(_arguments.size()) - 1;
            return _arguments.back();
        }
        void print_help(size_t count = 0, size_t page = 0) {
            if (page * count > _arguments.size()) {
                return;
            }
            if (page == 0) {
                std::cout << "Usage: " << _bin;
                if (_positional_arguments.empty()) {
                    std::cout << " [options...]" << std::endl;
                }
                else {
                    int current = 1;
                    for (auto& v : _positional_arguments) {
                        if (v.first != Argument::Position::LAST) {
                            for (; current < v.first; current++) {
                                std::cout << " [" << current << "]";
                            }
                            std::cout
                                << " ["
                                << detail::_ltrim_copy(
                                    _arguments[static_cast<size_t>(v.second)]._names[0],
                                    [](int c) -> bool { return c != static_cast<int>('-'); })
                                << "]";
                        }
                    }
                    auto it = _positional_arguments.find(Argument::Position::LAST);
                    if (it == _positional_arguments.end()) {
                        std::cout << " [options...]";
                    }
                    else {
                        std::cout
                            << " [options...] ["
                            << detail::_ltrim_copy(
                                _arguments[static_cast<size_t>(it->second)]._names[0],
                                [](int c) -> bool { return c != static_cast<int>('-'); })
                            << "]";
                    }
                    std::cout << std::endl;
                }
                std::cout << "Options:" << std::endl;
            }
            if (count == 0) {
                page = 0;
                count = _arguments.size();
            }
            for (size_t i = page * count;
                i < std::min<size_t>(page * count + count, _arguments.size()); i++) {
                Argument& a = _arguments[i];
                std::string name = a._names[0];
                for (size_t n = 1; n < a._names.size(); ++n) {
                    name.append(", " + a._names[n]);
                }
                std::cout << "    " << std::setw(23) << std::left << name << std::setw(23)
                    << a._desc;
                if (a._required) {
                    std::cout << " (Required)";
                }
                std::cout << std::endl;
            }
        }
        Result parse(int argc, const char* argv[]) {
            Result err;
            if (argc > 1) {
                // build name map
                for (auto& a : _arguments) {
                    for (auto& n : a._names) {
                        std::string name = detail::_ltrim_copy(
                            n, [](int c) -> bool { return c != static_cast<int>('-'); });
                        if (_name_map.find(name) != _name_map.end()) {
                            return Result("Duplicate of argument name: " + n);
                        }
                        _name_map[name] = a._index;
                    }
                    if (a._position >= 0 || a._position == Argument::Position::LAST) {
                        _positional_arguments[a._position] = a._index;
                    }
                }
                if (err) {
                    return err;
                }
                // parse
                std::string current_arg;
                size_t arg_len;
                for (int argv_index = 1; argv_index < argc; ++argv_index) {
                    current_arg = std::string(argv[argv_index]);
                    arg_len = current_arg.length();
                    if (arg_len == 0) {
                        continue;
                    }
                    if (_help_enabled && (current_arg == "-h" || current_arg == "--help")) {
                        _arguments[static_cast<size_t>(_name_map["help"])]._found = true;
                    }
                    else if (argv_index == argc - 1 &&
                        _positional_arguments.find(Argument::Position::LAST) !=
                        _positional_arguments.end()) {
                        err = _end_argument();
                        Result b = err;
                        err = _add_value(current_arg, Argument::Position::LAST);
                        if (b) {
                            return b;
                        }
                        if (err) {
                            return err;
                        }
                    }
                    else if (arg_len >= 2 &&
                        !detail::_is_number(current_arg)) {  // ignores the case if
                                                             // the arg is just a -
               // look for -a (short) or --arg (long) args
                        if (current_arg[0] == '-') {
                            err = _end_argument();
                            if (err) {
                                return err;
                            }
                            // look for --arg (long) args
                            if (current_arg[1] == '-') {
                                err = _begin_argument(current_arg.substr(2), true, argv_index);
                                if (err) {
                                    return err;
                                }
                            }
                            else {  // short args
                                err = _begin_argument(current_arg.substr(1), false, argv_index);
                                if (err) {
                                    return err;
                                }
                            }
                        }
                        else {  // argument value
                            err = _add_value(current_arg, argv_index);
                            if (err) {
                                return err;
                            }
                        }
                    }
                    else {  // argument value
                        err = _add_value(current_arg, argv_index);
                        if (err) {
                            return err;
                        }
                    }
                }
            }
            if (_help_enabled && exists("help")) {
                return Result();
            }
            err = _end_argument();
            if (err) {
                return err;
            }
            for (auto& p : _positional_arguments) {
                Argument& a = _arguments[static_cast<size_t>(p.second)];
                if (a._values.size() > 0 && a._values[0][0] == '-') {
                    std::string name = detail::_ltrim_copy(a._values[0], [](int c) -> bool {
                        return c != static_cast<int>('-');
                        });
                    if (_name_map.find(name) != _name_map.end()) {
                        if (a._position == Argument::Position::LAST) {
                            return Result(
                                "Poisitional argument expected at the end, but argument " +
                                a._values[0] + " found instead");
                        }
                        else {
                            return Result("Poisitional argument expected in position " +
                                std::to_string(a._position) + ", but argument " +
                                a._values[0] + " found instead");
                        }
                    }
                }
            }
            for (auto& a : _arguments) {
                if (a._required && !a._found) {
                    return Result("Required argument not found: " + a._names[0]);
                }
                if (a._position >= 0 && argc >= a._position && !a._found) {
                    return Result("Argument " + a._names[0] + " expected in position " +
                        std::to_string(a._position));
                }
            }
            return Result();
        }
        void enable_help() {
            add_argument("-h", "--help", "Shows this page", false);
            _help_enabled = true;
        }
        bool exists(const std::string& name) const {
            std::string n = detail::_ltrim_copy(
                name, [](int c) -> bool { return c != static_cast<int>('-'); });
            auto it = _name_map.find(n);
            if (it != _name_map.end()) {
                return _arguments[static_cast<size_t>(it->second)]._found;
            }
            return false;
        }
        template <typename T>
        T get(const std::string& name) {
            auto t = _name_map.find(name);
            if (t != _name_map.end()) {
                return _arguments[static_cast<size_t>(t->second)].get<T>();
            }
            return T();
        }
    private:
        Result _begin_argument(const std::string& arg, bool longarg, int position) {
            auto it = _positional_arguments.find(position);
            if (it != _positional_arguments.end()) {
                Result err = _end_argument();
                Argument& a = _arguments[static_cast<size_t>(it->second)];
                a._values.push_back((longarg ? "--" : "-") + arg);
                a._found = true;
                return err;
            }
            if (_current != -1) {
                return Result("Current argument left open");
            }
            size_t name_end = detail::_find_name_end(arg);
            std::string arg_name = arg.substr(0, name_end);
            if (longarg) {
                int equal_pos = detail::_find_equal(arg);
                auto nmf = _name_map.find(arg_name);
                if (nmf == _name_map.end()) {
                    return Result("Unrecognized command line option '" + arg_name + "'");
                }
                _current = nmf->second;
                _arguments[static_cast<size_t>(nmf->second)]._found = true;
                if (equal_pos == 0 ||
                    (equal_pos < 0 &&
                        arg_name.length() < arg.length())) {  // malformed argument
                    return Result("Malformed argument: " + arg);
                }
                else if (equal_pos > 0) {
                    std::string arg_value = arg.substr(name_end + 1);
                    _add_value(arg_value, position);
                }
            }
            else {
                Result r;
                if (arg_name.length() == 1) {
                    return _begin_argument(arg, true, position);
                }
                else {
                    for (char& c : arg_name) {
                        r = _begin_argument(std::string(1, c), true, position);
                        if (r) {
                            return r;
                        }
                        r = _end_argument();
                        if (r) {
                            return r;
                        }
                    }
                }
            }
            return Result();
        }
        Result _add_value(const std::string& value, int location) {
            if (_current >= 0) {
                Result err;
                Argument& a = _arguments[static_cast<size_t>(_current)];
                if (a._count >= 0 && static_cast<int>(a._values.size()) >= a._count) {
                    err = _end_argument();
                    if (err) {
                        return err;
                    }
                    goto unnamed;
                }
                a._values.push_back(value);
                if (a._count >= 0 && static_cast<int>(a._values.size()) >= a._count) {
                    err = _end_argument();
                    if (err) {
                        return err;
                    }
                }
                return Result();
            }
            else {
            unnamed:
                auto it = _positional_arguments.find(location);
                if (it != _positional_arguments.end()) {
                    Argument& a = _arguments[static_cast<size_t>(it->second)];
                    a._values.push_back(value);
                    a._found = true;
                }
                // TODO
                return Result();
            }
        }
        Result _end_argument() {
            if (_current >= 0) {
                Argument& a = _arguments[static_cast<size_t>(_current)];
                _current = -1;
                if (static_cast<int>(a._values.size()) < a._count) {
                    return Result("Too few arguments given for " + a._names[0]);
                }
                if (a._count >= 0) {
                    if (static_cast<int>(a._values.size()) > a._count) {
                        return Result("Too many arguments given for " + a._names[0]);
                    }
                }
            }
            return Result();
        }
        bool _help_enabled{ false };
        int _current{ -1 };
        std::string _bin{};
        std::string _desc{};
        std::vector<Argument> _arguments{};
        std::map<int, int> _positional_arguments{};
        std::map<std::string, int> _name_map{};
    };
    std::ostream& operator<<(std::ostream& os, const argument_parser_t::Result& r) {
        os << r.what();
        return os;
    }
    template <>
    inline std::string argument_parser_t::Argument::get<std::string>() {
        return detail::_join(_values.begin(), _values.end());
    }
    template <>
    inline std::vector<std::string>
        argument_parser_t::Argument::get<std::vector<std::string>>() {
        return _values;
    }
}  // namespace argparse
#endif
```

`include/vm-lifter.hpp`:

```hpp
#pragma once
#include <zyreg_to_register_desc.hpp> //It is very important this be included before vtil/vtil so that the cast can be visible to vtil
#include <vtil\vtil>
#include <zyreg_to_register_desc.hpp>
#include <vmemu_t.hpp>
#include <vector>

namespace vm
{
typedef void(fn_lifter)(vm::instrs::vinstr_t);
class lifter_t
{  
  static constexpr vtil::register_desc FLAG_CF = vtil::REG_FLAGS.select( 1, 0 );
  static constexpr vtil::register_desc FLAG_PF = vtil::REG_FLAGS.select( 1, 2 );
  static constexpr vtil::register_desc FLAG_AF = vtil::REG_FLAGS.select( 1, 4 );
  static constexpr vtil::register_desc FLAG_ZF = vtil::REG_FLAGS.select( 1, 6 );
  static constexpr vtil::register_desc FLAG_SF = vtil::REG_FLAGS.select( 1, 7 );
  static constexpr vtil::register_desc FLAG_DF = vtil::REG_FLAGS.select( 1, 10 );
  static constexpr vtil::register_desc FLAG_OF = vtil::REG_FLAGS.select( 1, 11 );

  public:
  lifter_t(const vm::instrs::vrtn_t* const routine, const vm::vmctx_t* const ctx);
  bool lift();
  const vtil::routine* get_routine();  
  private:
  const std::uintptr_t img_base; //The original non-relocated base
  const std::uintptr_t load_delta;
  const std::array<ZydisRegister, 16> vmentry_pushes;
  const vm::instrs::vrtn_t* const vmp_routine;
  vtil::routine* vtil_routine;
  vtil::basic_block* current_block;
  bool lift_handler(vm::instrs::vinstr_t v_instr);
  fn_lifter lifter_add, lifter_and, lifter_imul, lifter_jmp, lifter_lconst, lifter_lcr0, 
    lifter_lreg, lifter_lvsp, lifter_nand, lifter_nop, lifter_nor, lifter_or, 
    lifter_read, lifter_shl, lifter_shld, lifter_shr, lifter_shrd, lifter_sreg, 
    lifter_svsp, lifter_vmexit, lifter_write, lifter_writedr7;
};
}
```

`include/vmdevirt-vtil.hpp`:

```hpp
#pragma once
#include <cli-parser.hpp>
#include <fstream>
#include <iostream>
#include <thread>
#include <vmemu_t.hpp>
#include <vmlocate.hpp>
#include <vm-lifter.hpp>
```

`include/vtil-compile.hpp`:

```hpp
#pragma once

bool compile(vtil::routine* rtn, std::vector<uint8_t>& out);
```

`include/zyreg_to_register_desc.hpp`:

```hpp
#pragma once
#include <vtil\vtil>
#include <Zydis\Zydis.h>

//The index is a zyreg, the value at that index is a capreg
static constexpr x86_reg zyreg_to_capreg_map[]
{
    X86_REG_INVALID,

    // General purpose registers  8-bit
    X86_REG_AL,
    X86_REG_CL,
    X86_REG_DL,
    X86_REG_BL,
    X86_REG_AH,
    X86_REG_CH,
    X86_REG_DH,
    X86_REG_BH,
    X86_REG_SPL,
    X86_REG_BPL,
    X86_REG_SIL,
    X86_REG_DIL,
    X86_REG_R8B,
    X86_REG_R9B,
    X86_REG_R10B,
    X86_REG_R11B,
    X86_REG_R12B,
    X86_REG_R13B,
    X86_REG_R14B,
    X86_REG_R15B,
    // General purpose registers 16-bit
    X86_REG_AX,
    X86_REG_CX,
    X86_REG_DX,
    X86_REG_BX,
    X86_REG_SP,
    X86_REG_BP,
    X86_REG_SI,
    X86_REG_DI,
    X86_REG_R8W,
    X86_REG_R9W,
    X86_REG_R10W,
    X86_REG_R11W,
    X86_REG_R12W,
    X86_REG_R13W,
    X86_REG_R14W,
    X86_REG_R15W,
    // General purpose registers 32-bit
    X86_REG_EAX,
    X86_REG_ECX,
    X86_REG_EDX,
    X86_REG_EBX,
    X86_REG_ESP,
    X86_REG_EBP,
    X86_REG_ESI,
    X86_REG_EDI,
    X86_REG_R8D,
    X86_REG_R9D,
    X86_REG_R10D,
    X86_REG_R11D,
    X86_REG_R12D,
    X86_REG_R13D,
    X86_REG_R14D,
    X86_REG_R15D,
    // General purpose registers 64-bit
    X86_REG_RAX,
    X86_REG_RCX,
    X86_REG_RDX,
    X86_REG_RBX,
    X86_REG_RSP,
    X86_REG_RBP,
    X86_REG_RSI,
    X86_REG_RDI,
    X86_REG_R8,
    X86_REG_R9,
    X86_REG_R10,
    X86_REG_R11,
    X86_REG_R12,
    X86_REG_R13,
    X86_REG_R14,
    X86_REG_R15,
    // Floating point legacy registers
    X86_REG_ST0,
    X86_REG_ST1,
    X86_REG_ST2,
    X86_REG_ST3,
    X86_REG_ST4,
    X86_REG_ST5,
    X86_REG_ST6,
    X86_REG_ST7,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    // Floating point multimedia registers
    X86_REG_MM0,
    X86_REG_MM1,
    X86_REG_MM2,
    X86_REG_MM3,
    X86_REG_MM4,
    X86_REG_MM5,
    X86_REG_MM6,
    X86_REG_MM7,
    // Floating point vector registers 128-bit
    X86_REG_XMM0,
    X86_REG_XMM1,
    X86_REG_XMM2,
    X86_REG_XMM3,
    X86_REG_XMM4,
    X86_REG_XMM5,
    X86_REG_XMM6,
    X86_REG_XMM7,
    X86_REG_XMM8,
    X86_REG_XMM9,
    X86_REG_XMM10,
    X86_REG_XMM11,
    X86_REG_XMM12,
    X86_REG_XMM13,
    X86_REG_XMM14,
    X86_REG_XMM15,
    X86_REG_XMM16,
    X86_REG_XMM17,
    X86_REG_XMM18,
    X86_REG_XMM19,
    X86_REG_XMM20,
    X86_REG_XMM21,
    X86_REG_XMM22,
    X86_REG_XMM23,
    X86_REG_XMM24,
    X86_REG_XMM25,
    X86_REG_XMM26,
    X86_REG_XMM27,
    X86_REG_XMM28,
    X86_REG_XMM29,
    X86_REG_XMM30,
    X86_REG_XMM31,
    // Floating point vector registers 256-bit
    X86_REG_YMM0,
    X86_REG_YMM1,
    X86_REG_YMM2,
    X86_REG_YMM3,
    X86_REG_YMM4,
    X86_REG_YMM5,
    X86_REG_YMM6,
    X86_REG_YMM7,
    X86_REG_YMM8,
    X86_REG_YMM9,
    X86_REG_YMM10,
    X86_REG_YMM11,
    X86_REG_YMM12,
    X86_REG_YMM13,
    X86_REG_YMM14,
    X86_REG_YMM15,
    X86_REG_YMM16,
    X86_REG_YMM17,
    X86_REG_YMM18,
    X86_REG_YMM19,
    X86_REG_YMM20,
    X86_REG_YMM21,
    X86_REG_YMM22,
    X86_REG_YMM23,
    X86_REG_YMM24,
    X86_REG_YMM25,
    X86_REG_YMM26,
    X86_REG_YMM27,
    X86_REG_YMM28,
    X86_REG_YMM29,
    X86_REG_YMM30,
    X86_REG_YMM31,
    // Floating point vector registers 512-bit
    X86_REG_ZMM0,
    X86_REG_ZMM1,
    X86_REG_ZMM2,
    X86_REG_ZMM3,
    X86_REG_ZMM4,
    X86_REG_ZMM5,
    X86_REG_ZMM6,
    X86_REG_ZMM7,
    X86_REG_ZMM8,
    X86_REG_ZMM9,
    X86_REG_ZMM10,
    X86_REG_ZMM11,
    X86_REG_ZMM12,
    X86_REG_ZMM13,
    X86_REG_ZMM14,
    X86_REG_ZMM15,
    X86_REG_ZMM16,
    X86_REG_ZMM17,
    X86_REG_ZMM18,
    X86_REG_ZMM19,
    X86_REG_ZMM20,
    X86_REG_ZMM21,
    X86_REG_ZMM22,
    X86_REG_ZMM23,
    X86_REG_ZMM24,
    X86_REG_ZMM25,
    X86_REG_ZMM26,
    X86_REG_ZMM27,
    X86_REG_ZMM28,
    X86_REG_ZMM29,
    X86_REG_ZMM30,
    X86_REG_ZMM31,
    // Flags registers
    X86_REG_EFLAGS,
    X86_REG_EFLAGS,
    X86_REG_EFLAGS,
    // Instruction-pointer registers
    X86_REG_IP,
    X86_REG_EIP,
    X86_REG_RIP,
    // Segment registers
    X86_REG_ES,
    X86_REG_CS,
    X86_REG_SS,
    X86_REG_DS,
    X86_REG_FS,
    X86_REG_GS,
    // Table registers
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    // Test registers
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    // Control registers
    X86_REG_CR0,
    X86_REG_CR1,
    X86_REG_CR2,
    X86_REG_CR3,
    X86_REG_CR4,
    X86_REG_CR5,
    X86_REG_CR6,
    X86_REG_CR7,
    X86_REG_CR8,
    X86_REG_CR9,
    X86_REG_CR10,
    X86_REG_CR11,
    X86_REG_CR12,
    X86_REG_CR13,
    X86_REG_CR14,
    X86_REG_CR15,
    // Debug registers
    X86_REG_DR0,
    X86_REG_DR1,
    X86_REG_DR2,
    X86_REG_DR3,
    X86_REG_DR4,
    X86_REG_DR5,
    X86_REG_DR6,
    X86_REG_DR7,
    X86_REG_DR8,
    X86_REG_DR9,
    X86_REG_DR10,
    X86_REG_DR11,
    X86_REG_DR12,
    X86_REG_DR13,
    X86_REG_DR14,
    X86_REG_DR15,
    // Mask registers
    X86_REG_K0,
    X86_REG_K1,
    X86_REG_K2,
    X86_REG_K3,
    X86_REG_K4,
    X86_REG_K5,
    X86_REG_K6,
    X86_REG_K7,
    // Bound registers
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID,
    // Uncategorized
    X86_REG_INVALID,
    X86_REG_INVALID,
    X86_REG_INVALID
};

// Implement a way to get size from register in a constexpr way. no constexpr map so this is very slow :( 
// but hopefully evaluated at compile time
constexpr x86_reg zyreg_to_capreg(ZydisRegister reg)
{
  fassert(reg <= ZYDIS_REGISTER_MAX_VALUE);
  return zyreg_to_capreg_map[reg];
}

namespace vtil {
  template<>
  struct register_cast<ZydisRegister>
  {
    constexpr register_desc operator()(ZydisRegister zyreg)
    {
      //Why not use the work that was already done instead of defining a new vtil arch for zydis
      register_cast<x86_reg> cast;
      return cast(zyreg_to_capreg(zyreg));
    }
  };
}
```

`src/lifters.cpp`:

```cpp
#include <vm-lifter.hpp>

// A lot of stuff in this file is copied from novmp
static constexpr vtil::register_desc make_virtual_register( uint8_t context_offset, uint8_t size )
{
	fassert( ( ( context_offset & 7 ) + ( size / 8) ) <= 8 && size && (size % 8) == 0 );

	return {
		vtil::register_virtual,
		( size_t ) context_offset / 8,
		size,
		( context_offset % 8 ) * 8
	};
}

void vm::lifter_t::lifter_add(vm::instrs::vinstr_t instr) {
  auto [add_tmp_0, add_tmp_1, add_tmp_2] = current_block->tmp( instr.stack_size,
                                                               instr.stack_size,
                                                               instr.stack_size );
  auto [add_fl_0, add_fl_1, add_fl_2, add_fl_3] = current_block->tmp( 1, 1, 1, 1 );

  current_block
    // add_tmp_0 := [rsp]
    // add_tmp_1 := [rsp+*]
    ->pop( add_tmp_0 )
    ->pop( add_tmp_1 )

    // add_tmp_1 += add_tmp_0
    ->mov( add_tmp_2, add_tmp_1 )
    ->add( add_tmp_1, add_tmp_0 )

    // Update flags.
    // SF = r < 0
    ->tl( FLAG_SF, add_tmp_1, 0 )
    // ZF = r == 0
    ->te( FLAG_ZF, add_tmp_1, 0 )
    // CF = r < a
    ->tul( FLAG_CF, add_tmp_1, add_tmp_2 )
    // add_fl_0 = (a < 0) == (b < 0)
    ->tl( add_fl_2, add_tmp_2, 0 )
    ->tl( add_fl_3, add_tmp_0, 0 )
    ->te( add_fl_0, add_fl_2, add_fl_3 )
    // add_fl_1 = (a < 0) != (r < 0)
    ->tl( add_fl_2, add_tmp_2, 0 )
    ->tl( add_fl_3, add_tmp_1, 0 )
    ->tne( add_fl_1, add_fl_2, add_fl_3 )
    // OF = add_fl_0 & add_fl_1
    ->mov( FLAG_OF, add_fl_0 )
    ->band( FLAG_OF, add_fl_1 )

    // [rsp] := flags
    // [rsp+8] := add_tmp_1
    ->push( add_tmp_1 )
    ->pushf();
};
void vm::lifter_t::lifter_and(vm::instrs::vinstr_t instr)
{
  auto [and_tmp_0, and_tmp_1, and_tmp_2] = current_block->tmp(64, instr.stack_size, instr.stack_size);
  current_block
    ->pop(and_tmp_0)
    ->pop(and_tmp_1)
    ->ldd(and_tmp_2, and_tmp_0, 0)
    ->band(and_tmp_2, and_tmp_1)
    ->str(and_tmp_0, 0, and_tmp_2)

    ->mov(FLAG_OF, 0)
    ->mov(FLAG_CF, 0)
    ->te(FLAG_ZF, and_tmp_2, 0)
    ->tl(FLAG_SF, and_tmp_2, 0)
    ->pushf();
};
void vm::lifter_t::lifter_imul(vm::instrs::vinstr_t instr)
{
  std::printf("This lifter is not implemented\n");    
  exit(-1);
};
void vm::lifter_t::lifter_jmp(vm::instrs::vinstr_t instr)
{
  auto tmp = current_block->tmp(64);
  current_block
    ->pop(tmp)
    ->jmp(tmp);
};
void vm::lifter_t::lifter_lconst(vm::instrs::vinstr_t instr)
{
  auto tmp = current_block->tmp(instr.imm.size);
  current_block
    ->mov(tmp, vtil::make_imm(instr.imm.val))
    ->push(tmp); 
};
void vm::lifter_t::lifter_lcr0(vm::instrs::vinstr_t instr)
{
  current_block->push(ZYDIS_REGISTER_CR0);
};
void vm::lifter_t::lifter_lreg(vm::instrs::vinstr_t instr)
{
  current_block->push(make_virtual_register(instr.imm.val, instr.stack_size));
};
void vm::lifter_t::lifter_sreg(vm::instrs::vinstr_t instr)
{
  current_block->pop(make_virtual_register(instr.imm.val, instr.stack_size));
}
void vm::lifter_t::lifter_lvsp(vm::instrs::vinstr_t instr)
{
  current_block->push(vtil::REG_SP);  
};
void vm::lifter_t::lifter_nand(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2, fl0, fl1] = current_block->tmp(instr.stack_size, instr.stack_size, instr.stack_size, 1, 1);
  current_block
    ->pop(tmp1)
    ->pop(tmp0)
    ->bnot(tmp0)
    ->bnot(tmp1)
    ->mov(tmp2, tmp0)
    ->bor(tmp0, tmp1)

    ->mov(FLAG_OF, 0)
    ->mov(FLAG_CF, 0)
    ->te(FLAG_ZF, tmp2, 0)
    ->tl(FLAG_SF, tmp0, 0)
    ->pushf();
};
void vm::lifter_t::lifter_nop(vm::instrs::vinstr_t instr) 
{
  current_block->nop();
};
void vm::lifter_t::lifter_nor(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2, fl0, fl1] = current_block->tmp(instr.stack_size, instr.stack_size, instr.stack_size, 1, 1);
  current_block
    ->pop(tmp1)
    ->pop(tmp0)
    ->bnot(tmp0)
    ->bnot(tmp1)
    ->mov(tmp2, tmp0)
    ->band(tmp0, tmp1)

    ->mov(FLAG_OF, 0)
    ->mov(FLAG_CF, 0)
    ->te(FLAG_ZF, tmp2, 0)
    ->tl(FLAG_SF, tmp0, 0)
    ->pushf();
};
void vm::lifter_t::lifter_or(vm::instrs::vinstr_t instr)
{
  auto [and_tmp_0, and_tmp_1, and_tmp_2] = current_block->tmp(64, instr.stack_size, instr.stack_size);
  current_block
    ->pop(and_tmp_0)
    ->pop(and_tmp_1)
    ->ldd(and_tmp_2, and_tmp_0, 0)
    ->bor(and_tmp_2, and_tmp_1)
    ->str(and_tmp_0, 0, and_tmp_2)

    ->mov(FLAG_OF, 0)
    ->mov(FLAG_CF, 0)
    ->te(FLAG_ZF, and_tmp_2, 0)
    ->tl(FLAG_SF, and_tmp_2, 0)
    ->pushf();
};
void vm::lifter_t::lifter_read(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1] = current_block->tmp(64, instr.stack_size);
  current_block
    ->pop(tmp0)
    ->ldd(tmp1, tmp0, 0)
    ->push(tmp1);
};
void vm::lifter_t::lifter_shl(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2] = current_block->tmp(instr.stack_size, instr.stack_size, 8);
  auto cf = tmp2.select(1, tmp2.bit_count - 1); // Set to most significant bit 
  auto ofx = tmp0.select(1, tmp0.bit_count - 1);
  current_block
    ->pop(tmp0)
    ->pop(tmp1)
    
    ->mov(tmp2, tmp1)
    ->bshl(tmp0, tmp1)
    
    ->tl(FLAG_SF, tmp0, 0)
    ->te(FLAG_SF, tmp0, 0)
    ->mov(FLAG_OF, ofx)
    ->mov(FLAG_CF, cf)
    ->bxor(FLAG_OF, cf)

    ->push(tmp0)
    ->pushf();
};

void vm::lifter_t::lifter_shr(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2] = current_block->tmp(instr.stack_size, instr.stack_size, 8);
  auto cf = tmp2.select(1, tmp2.bit_count - 1); // Set to most significant bit 
  auto ofx = tmp0.select(1, tmp0.bit_count - 1);
  current_block
    ->pop(tmp0)
    ->pop(tmp1)
    
    ->mov(tmp2, tmp1)
    ->bshr(tmp0, tmp1)
    
    ->tl(FLAG_SF, tmp0, 0)
    ->te(FLAG_SF, tmp0, 0)
    ->mov(FLAG_OF, ofx)
    ->mov(FLAG_CF, cf)
    ->bxor(FLAG_OF, cf)

    ->push(tmp0)
    ->pushf();
};

void vm::lifter_t::lifter_shrd(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2, tmp3] = current_block->tmp(instr.stack_size, instr.stack_size, 8, 8);
  current_block
    ->pop(tmp0)
    ->pop(tmp1)
    ->pop(tmp2)

    ->bshr(tmp0, tmp2)

    // find out how many bits to shift the shiftin value by
    ->mov(tmp3, vtil::make_imm<uint8_t>(instr.stack_size))
    ->sub(tmp3, tmp2)
    
    ->bshl(tmp1, tmp3)
    ->bor(tmp0, tmp1)
    
    ->te(FLAG_ZF, tmp0, 0)
    ->tl(FLAG_SF, tmp0, 0)
    ->mov(FLAG_OF, vtil::UNDEFINED)
    ->mov(FLAG_CF, vtil::UNDEFINED)

    ->push(tmp0)
    ->pushf();
}

void vm::lifter_t::lifter_shld(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1, tmp2, tmp3] = current_block->tmp(instr.stack_size, instr.stack_size, 8, 8);
  current_block
    ->pop(tmp0)
    ->pop(tmp1)
    ->pop(tmp2)

    ->bshl(tmp0, tmp2)

    // find out how many bits to shift the shiftin value by
    ->mov(tmp3, vtil::make_imm<uint8_t>(instr.stack_size))
    ->sub(tmp3, tmp2)
    
    ->bshr(tmp1, tmp3)
    ->bor(tmp0, tmp1)
    
    ->te(FLAG_ZF, tmp0, 0)
    ->tl(FLAG_SF, tmp0, 0)
    ->mov(FLAG_OF, vtil::UNDEFINED)
    ->mov(FLAG_CF, vtil::UNDEFINED)

    ->push(tmp0)
    ->pushf();
}

void vm::lifter_t::lifter_svsp(vm::instrs::vinstr_t instr)
{
  auto tmp = current_block->tmp(64);
  current_block
    ->ldd(tmp, vtil::REG_SP, 0)
    ->mov(vtil::REG_SP, tmp);
}

void vm::lifter_t::lifter_write(vm::instrs::vinstr_t instr)
{
  auto [tmp0, tmp1] = current_block->tmp(64, instr.stack_size);
  current_block
    ->pop(tmp0)
    ->pop(tmp1)
    ->str(tmp0, 0, tmp1); 
}

void vm::lifter_t::lifter_writedr7(vm::instrs::vinstr_t instr)
{
  auto tmp = current_block->tmp(64);
  current_block
    ->pop(tmp)
    ->mov(X86_REG_DR7, tmp);
}

void vm::lifter_t::lifter_vmexit(vm::instrs::vinstr_t instr)
{
  for (auto it = vmentry_pushes.rbegin(); it != vmentry_pushes.rend(); it++)
    current_block->pop(*it);
  auto tmp = current_block->tmp(64);
  current_block
    ->pop(tmp)
    ->vexit(tmp);
};
```

`src/vm-lifter.cpp`:

```cpp
#include <vm-lifter.hpp>

namespace vm
{
  lifter_t::lifter_t(const vm::instrs::vrtn_t* const routine, const vm::vmctx_t* const ctx) : 
    vmp_routine(routine), vmentry_pushes(ctx->get_vmentry_push_order()), img_base(ctx->m_image_base), 
    load_delta(ctx->m_image_load_delta) {};
  const vtil::routine* lifter_t::get_routine()
  {
    return vtil_routine;
  }

  bool lifter_t::lift()
  {
    //The rva of first block is the first instruction after the vmenter
    current_block = vtil::basic_block::begin(vmp_routine->m_blks[0].m_vip.rva);
    //VMENTER pushes all gp registers and RFLAGS to the stack which is inherited by the virtual stack.
    for (auto zyreg : vmentry_pushes)
    {
      current_block->push(zyreg);
    }
    //Load delta is pushed to the stack
    current_block->push(vtil::make_imm<uint64_t>(0));
    vtil_routine = current_block->owner;
    //Lift the handlers basically
    for (const auto& blk : vmp_routine->m_blks)
    {
      if (&blk != &vmp_routine->m_blks[0])
        current_block = current_block->fork(blk.m_vip.img_based);
      for (const auto& instr : blk.m_vinstrs)
      {
        if(!lift_handler(instr)) {
          std::printf("[!] unrecognized instruction encountered\n");
          return false;
        }
      }
    }
    return true;
  }

  bool lifter_t::lift_handler(vm::instrs::vinstr_t v_instr)
  {
    // I really should have found a less bloated way to implement this
    switch (v_instr.mnemonic)
    {
      case vm::instrs::mnemonic_t::add:
        lifter_add(v_instr);
        break;
      case vm::instrs::mnemonic_t::_and:
        lifter_and(v_instr);
        break;
      case vm::instrs::mnemonic_t::imul:
        lifter_imul(v_instr);
        break;
      case vm::instrs::mnemonic_t::jmp:
        lifter_jmp(v_instr);
        break;
      case vm::instrs::mnemonic_t::lconst:
        lifter_lconst(v_instr);
        break;
      case vm::instrs::mnemonic_t::lcr0:
        lifter_lcr0(v_instr);
        break;
      case vm::instrs::mnemonic_t::lreg:
        lifter_lreg(v_instr);
        break;
      case vm::instrs::mnemonic_t::lvsp:
        lifter_lvsp(v_instr);
        break;
      case vm::instrs::mnemonic_t::nand:
        lifter_nand(v_instr);
        break;
      case vm::instrs::mnemonic_t::nop:
        lifter_nop(v_instr);
        break;
      case vm::instrs::mnemonic_t::nor:
        lifter_nor(v_instr);
        break;
      case vm::instrs::mnemonic_t::_or:
        lifter_or(v_instr);
        break;
      case vm::instrs::mnemonic_t::read:
        lifter_read(v_instr);
        break;
      case vm::instrs::mnemonic_t::shl:
        lifter_shl(v_instr);
        break;
      case vm::instrs::mnemonic_t::shr:
        lifter_shr(v_instr);
        break;
      case vm::instrs::mnemonic_t::shld:
        lifter_shld(v_instr);
        break;
      case vm::instrs::mnemonic_t::shrd:
        lifter_shrd(v_instr);
        break;
      case vm::instrs::mnemonic_t::sreg:
        lifter_sreg(v_instr);
        break;
      case vm::instrs::mnemonic_t::svsp:
        lifter_svsp(v_instr);
        break;
      case vm::instrs::mnemonic_t::vmexit:
        lifter_vmexit(v_instr);
        break;
      case vm::instrs::mnemonic_t::write:
        lifter_write(v_instr);
        break;
      case vm::instrs::mnemonic_t::writedr7:
        lifter_writedr7(v_instr);
        break;
      default:
        return false;
    }
    return true;
  }
}
```

`src/vmdevirt-vtil.cpp`:

```cpp
#include <vmdevirt-vtil.hpp>
#include <vtil-compile.hpp>

int __cdecl main(int argc, const char *argv[])
{
  argparse::argument_parser_t parser("VMProtect 3 Static Devirtualization",
                                     "vmdevirt");
  for (int i = 0; i < argc; i++)
  {
    std::cout << argv[i] << '\n';
  }

  parser.add_argument()
      .name("--vmentry")
      .description("relative virtual address to a vm entry...")
      .required(false);
  parser.add_argument()
      .name("--bin")
      .description("path to unpacked virtualized binary...")
      .required(true);
  parser.add_argument().name("--out").description("output file name...");
  vm::utils::init();
  parser.enable_help();
  auto result = parser.parse(argc, argv);
  if (result || parser.exists("help"))
  {
    parser.print_help();
    return -1;
  }
  std::cout << parser.get<std::string>("bin") << '\n';
  std::vector<std::uint8_t> module_data, tmp, unpacked_bin;
  if (!vm::utils::open_binary_file(parser.get<std::string>("bin"),
                                   module_data))
  {
    std::printf("[!] failed to open binary file...\n");
    return -1;
  }
  auto img = reinterpret_cast<win::image_t<> *>(module_data.data());
  auto image_size = img->get_nt_headers()->optional_header.size_image;
  const auto image_base = img->get_nt_headers()->optional_header.image_base;
  // page align the vector allocation so that unicorn-engine is happy girl...
  tmp.resize(image_size + PAGE_4KB);
  const std::uintptr_t module_base =
      reinterpret_cast<std::uintptr_t>(tmp.data()) +
      (PAGE_4KB - (reinterpret_cast<std::uintptr_t>(tmp.data()) & 0xFFFull));
  std::memcpy((void *)module_base, module_data.data(), 0x1000);
  std::for_each(img->get_nt_headers()->get_sections(),
                img->get_nt_headers()->get_sections() +
                    img->get_nt_headers()->file_header.num_sections,
                [&](const auto &section_header)
                {
                  std::memcpy(
                      (void *)(module_base + section_header.virtual_address),
                      module_data.data() + section_header.ptr_raw_data,
                      section_header.size_raw_data);
                });
  auto win_img = reinterpret_cast<win::image_t<> *>(module_base);
  auto basereloc_dir =
      win_img->get_directory(win::directory_id::directory_entry_basereloc);
  auto reloc_dir = reinterpret_cast<win::reloc_directory_t *>(
      basereloc_dir->rva + module_base);
  win::reloc_block_t *reloc_block = &reloc_dir->first_block;
  // apply relocations to all sections...
  while (reloc_block->base_rva && reloc_block->size_block)
  {
    std::for_each(reloc_block->begin(), reloc_block->end(),
                  [&](win::reloc_entry_t &entry)
                  {
                    switch (entry.type)
                    {
                    case win::reloc_type_id::rel_based_dir64:
                    {
                      auto reloc_at = reinterpret_cast<std::uintptr_t *>(
                          entry.offset + reloc_block->base_rva + module_base);
                      *reloc_at = module_base + ((*reloc_at) - image_base);
                      break;
                    }
                    default:
                      break;
                    }
                  });
    reloc_block = reloc_block->next();
  }
  std::printf("> image base = %p, image size = %p, module base = %p\n",
              image_base, image_size, module_base);
  if (!image_base || !image_size || !module_base)
  {
    std::printf("[!] failed to open binary on disk...\n");
    return -1;
  }
  std::vector<std::uintptr_t> vm_entry_rvas;
  auto vmentry_paramter = parser.get<std::string>("vmentry");
  if (!vmentry_paramter.empty())
    vm_entry_rvas.emplace_back(std::strtoull(parser.get<std::string>("vmentry").c_str(), nullptr, 16));
  else
  {
    auto vm_entries =  vm::locate::get_vm_entries(module_base, image_size);
    std::for_each(vm_entries.begin(), vm_entries.end(),
                                      [&](const vm::locate::vm_enter_t& vmenter) {
                                        static int vmenter_count = 0;
                                        std::printf("[%.4d]  Discovered vmenter at rva: %p\n", 
                                                    ++vmenter_count, vmenter.rva);
                                        vm_entry_rvas.emplace_back(vmenter.rva);
                                      });
  }
  std::filesystem::path routines_folder(parser.get<std::string>("bin"));
  routines_folder = routines_folder.remove_filename() / "vms";
  std::filesystem::path bin_name = std::filesystem::path(parser.get<std::string>("bin")).filename();
  std::filesystem::remove_all(routines_folder);
  std::filesystem::create_directory(routines_folder);
  
  //module_data still contains the raw binary loaded from disk
  //TODO: Handle the rare edge case that there isn't room for another section header
  win::section_header_t* new_header_addr = 
    img->get_nt_headers()->get_sections() + img->get_nt_headers()->file_header.num_sections;
  img->get_nt_headers()->file_header.num_sections += 1;
  memset(new_header_addr, 0, sizeof(win::section_header_t));
  new_header_addr->virtual_address = 0x29420000;
  new_header_addr->name = { 'v', 't', 'i', 'l', '_', 'a', 's', 'm' };
  uint32_t section_alignment = img->get_nt_headers()->optional_header.section_alignment;
  uint32_t file_alignment = img->get_nt_headers()->optional_header.file_alignment;
  uint32_t old_size = module_data.size();
  old_size = (old_size + file_alignment) & ~static_cast<size_t>(file_alignment - 1);
  new_header_addr->ptr_raw_data = old_size;
  
  for (int i = 0; i < img->get_nt_headers()->file_header.num_sections; ++i)
  {
    for (int j = 0; j < 8; ++j)
    {
      std::cout << img->get_nt_headers()->get_section(i)->name.short_name[j];
    }
    std::cout << "\n";
  }
  
  std::vector<uint8_t> assembly;
  assembly.reserve(100'000'000);
  for (const auto& vm_entry_rva : vm_entry_rvas)
  {
    static int index = 0;
    vm::vmctx_t vmctx(module_base, image_base, image_size, vm_entry_rva);
    if (!vmctx.init())
    {
      std::printf(
          "[!] failed to init vmctx... this can be for many reasons..."
          " try validating your vm entry rva... make sure the binary is "
          "unpacked and is"
          "protected with VMProtect 3...\n");
      return -1;
    }
    vm::emu_t emu(&vmctx);
    if (!emu.init())
    {
      std::printf(
          "[!] failed to init vm::emu_t... read above in the console for the "
          "reason...\n");
      return -1;
    }
    vm::instrs::vrtn_t virt_rtn;
    if (!emu.emulate(vm_entry_rva, virt_rtn))
    {
      std::printf(
          "[!] failed to emulate virtualized routine... read above in the "
          "console for the reason...\n");
    }
    std::printf("> traced %d virtual code blocks... \n", virt_rtn.m_blks.size());
    
    vm::lifter_t lifter(&virt_rtn, &vmctx);
    if (!lifter.lift())
    {
      std::printf(
            "[!] failed to lift virtual routine to VTIL... read above in "
            "the console for the reason...\n");
      return -1;
    }

    // Replace VMENTER with a jmp to the compiled asm
    // Find file offset for virtual address
    auto* vm_entry_section = std::find_if(img->get_nt_headers()->get_sections(), 
      img->get_nt_headers()->get_sections() + img->get_nt_headers()->file_header.num_sections - 1,
      [vm_entry_rva](const win::section_header_t& scn)
      {
        if (vm_entry_rva >= scn.virtual_address && vm_entry_rva < scn.virtual_address + scn.virtual_size)
          return true;
        else return false;
      }
    );
    if (vm_entry_section == img->get_nt_headers()->get_sections() + img->get_nt_headers()->file_header.num_sections - 1)
    {
      std::printf("[!] couldn't find file offset for RVA %.8X\n", vm_entry_rva);
      return -1;
    }
    uint32_t vm_entry_file_offset = 
      vm_entry_rva - vm_entry_section->virtual_address + vm_entry_section->ptr_raw_data;
    // change 10-byte PUSH XXXXXXXX CALL XXXXXXXX with CALL [devirtualized]
    memset(module_data.data() + vm_entry_file_offset, 0x90, 10);
    module_data[vm_entry_file_offset] = 0xe8;
    uint32_t relative_offset = (new_header_addr->virtual_address - vm_entry_rva) +
      assembly.size() - 5;
    *reinterpret_cast<uint32_t*>(&module_data[vm_entry_file_offset + 1]) = relative_offset;
    
    std::stringstream hex_rva;
    hex_rva << std::hex << vm_entry_rva;
    auto save_to = routines_folder / (bin_name.string() + "-" + hex_rva.str() + "-premature" + ".vtil");
    vtil::save_routine(lifter.get_routine(), save_to);
    save_to = routines_folder / (bin_name.string() + "-" + hex_rva.str() + "-optimized" + ".vtil");
    vtil::routine* optimized = lifter.get_routine()->clone();
    vtil::optimizer::apply_all_profiled(optimized);
    vtil::save_routine(optimized, save_to);
    compile(optimized, assembly);
    
    save_to = routines_folder / (bin_name.string() + "-" + hex_rva.str() + ".txt");
    std::ofstream virtual_assembly(save_to);
    for (auto it = virt_rtn.m_blks.begin(); it != virt_rtn.m_blks.end(); ++it)
    {
      virtual_assembly << "BLOCK_" << it - virt_rtn.m_blks.begin() << ":\n";
      for (auto instr : it->m_vinstrs)
      {
        virtual_assembly << "SIZE:\t"<< std::dec  << +instr.stack_size << " " << vm::instrs::get_profile(instr.mnemonic)->name;
        if (instr.imm.has_imm)
          virtual_assembly << "\t" << std::hex << +instr.imm.val;
        virtual_assembly << "\n";
      }
      virtual_assembly << '\n';
    }
  }
  new_header_addr->virtual_size = ((assembly.size() & 
    ~static_cast<size_t>(section_alignment)) + section_alignment);
  new_header_addr->size_raw_data = (assembly.size() & ~static_cast<size_t>(file_alignment - 1)) + file_alignment;
  module_data.resize(((old_size + assembly.size()) & ~static_cast<size_t>(file_alignment - 1)) + file_alignment);
  memcpy(module_data.data() + old_size, assembly.data(), assembly.size());
  auto decompiled_bin_name = std::filesystem::path(parser.get<std::string>("bin")).remove_filename() /
    (std::filesystem::path(bin_name).replace_extension("").string() + "-devirtualized" + bin_name.extension().string());
  std::filesystem::remove(decompiled_bin_name);
  std::ofstream decompiled_bin_file(decompiled_bin_name, std::ios::binary);
  
  decompiled_bin_file.write(reinterpret_cast<const char*>(module_data.data()), module_data.size());
}
```

`src/vtil-compile.cpp`:

```cpp
// Copyright © 2021 Keegan Saunders
//
// Permission to use, copy, modify, and/or distribute this software for
// any purpose with or without fee is hereby granted.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
// OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//

#include <asmjit/x86.h>
#include <asmjit/x86/x86operand.h>
#include <set>
#include <unordered_map>
#include <vtil/arch>
#include <vtil/vtil>
#include <vtil-compile.hpp>

static void compile(vtil::basic_block* basic_block, struct routine_state* state);

using namespace asmjit;
namespace ins
{
using namespace vtil::ins;
};

struct routine_state
{
	std::unordered_map<vtil::vip_t, Label> label_map;
	std::set<vtil::vip_t> is_compiled;
	std::unordered_map<vtil::operand::register_t, x86::Gp> reg_map;
	x86::Gp flags_reg;
	x86::Compiler& cc;
	Imm base_address;

	routine_state(x86::Compiler& cc, uint64_t base)
		: cc(cc)
		, base_address(base)
	{
	}

	Label get_label(vtil::vip_t address)
	{
		if (label_map.count(address))
		{
			return label_map.at(address);
		}
		else
		{
			// TODO: Create a namedLabel
			//
			Label label = cc.newLabel();
			label_map.insert({ address, label });
			return label;
		}
	}

	x86::Gp reg_for_size(vtil::operand const& operand)
	{
		switch (operand.bit_count())
		{
		// TODO: Handle sized register access
		//
		case 1:
		case 8:
		case 16:
		case 32:
		case 64:
			return cc.newGpq();
		default:
			unreachable();
		}
	}

	x86::Gp tmp_imm(vtil::operand const& reg)
	{
		x86::Gp tmp = reg_for_size(reg);
		cc.mov(tmp, reg.imm().ival);
		return tmp;
	}

	x86::Gp get_reg(vtil::operand::register_t const& operand)
	{
		using vtil::logger::log;

		// TODO: Handle bit selectors on registers

		log("get_reg: %s\n", operand.to_string());
		if (operand.is_physical())
		{
			log("\tis_physical\n");
			// Transform the VTIL register into an AsmJit one.
			//
			// TODO: This shouldnt be a separate condition, but just
			// in the same switch
			//
			if (operand.is_stack_pointer())
			{
				log("\t\tis_stack_pointer\n");
				// TODO: this might cause problems, the stack
				// of the program and of VTIL are shared
				//
				return x86::rsp;
			}
			else if (operand.is_flags())
			{
				log("\t\tis_flags: %d\n", flags_reg.isValid());
				if (!flags_reg.isValid())
				{
					flags_reg = cc.newGpq();
				}

				return flags_reg;
			}
			else
			{
				log("\t\tmachine_register: %s\n", vtil::amd64::name(operand.combined_id));
				switch (operand.combined_id)
				{
				case X86_REG_R8:
					return x86::r8;
				case X86_REG_R9:
					return x86::r9;
				case X86_REG_R10:
					return x86::r10;
				case X86_REG_R11:
					return x86::r11;
				case X86_REG_R12:
					return x86::r12;
				case X86_REG_R13:
					return x86::r13;
				case X86_REG_R14:
					return x86::r14;
				case X86_REG_R15:
					return x86::r15;
				case X86_REG_RSI:
					return x86::rsi;
				case X86_REG_RBP:
					return x86::rbp;
				case X86_REG_RDI:
					return x86::rdi;
				case X86_REG_RAX:
					return x86::rax;
				case X86_REG_RBX:
					return x86::rbx;
				case X86_REG_RCX:
					return x86::rcx;
				case X86_REG_RDX:
					return x86::rdx;
				default:
					abort();
				}
			}
		}
		else
		{
			log("\tis_virtual\n");

			if (operand.is_image_base())
			{
				log("\t\tis_image_base\n");
				// TODO: This obviously won't work for different
				// base addresses
				//
				x86::Gp base_reg = reg_for_size(operand);
				cc.mov(base_reg, base_address);				
				return base_reg;
			}
			else if (operand.is_flags())
			{
				log("\t\tis_flags\n");
				abort();
			}
			// Grab the register from the map, or create and insert otherwise.
			//
			else if (reg_map.count(operand))
			{
				return reg_map[operand];
			}
			else
			{
				x86::Gp reg = reg_for_size(operand);
				reg_map[operand] = reg;
				return reg;
			}
		}
	}
};

using fn_instruction_compiler_t = std::function<void(const vtil::il_iterator&, routine_state*)>;
static const std::map<vtil::instruction_desc, fn_instruction_compiler_t> handler_table = {
	{
		ins::ldd,
		[](const vtil::il_iterator& instr, routine_state* state) {
			auto dest = instr->operands[0].reg();
			auto src = instr->operands[1].reg();
			auto offset = instr->operands[2].imm();

			// FIXME: Figure out how to determine if the offset is signed or not
			//
			state->cc.mov(state->get_reg(dest), x86::ptr(state->get_reg(src), offset.ival));
		},
	},
	{
		ins::str,
		[](const vtil::il_iterator& instr, routine_state* state) {
			auto base = instr->operands[0].reg();
			auto offset = instr->operands[1].imm();
			auto v = instr->operands[2];

			// FIXME: There is an issue here where it cannot deduce the size
			// of the move?
			//

			auto reg_base = state->get_reg(base);
			x86::Mem dest;
			switch (v.bit_count())
			{
			case 8:
				dest = x86::ptr_8(reg_base, offset.ival);
				break;
			case 16:
				dest = x86::ptr_16(reg_base, offset.ival);
				break;
			case 32:
				dest = x86::ptr_32(reg_base, offset.ival);
				break;
			case 64:
				dest = x86::ptr_64(reg_base, offset.ival);
				break;
			default:
				unreachable();
			}

			if (v.is_immediate())
			{
				state->cc.mov(dest, v.imm().ival);
			}
			else
			{
				state->cc.mov(dest, state->get_reg(v.reg()));
			}
		},
	},
	{
		ins::mov,
		[](const vtil::il_iterator& instr, routine_state* state) {
			auto dest = instr->operands[0].reg();
			auto src = instr->operands[1];

			if (src.is_immediate())
			{
				state->cc.mov(state->get_reg(dest), src.imm().ival);
			}
			else
			{
				state->cc.mov(state->get_reg(dest), state->get_reg(src.reg()));
			}
		},
	},
	{
		ins::sub,
		[](const vtil::il_iterator& instr, routine_state* state) {
			auto dest = instr->operands[0].reg();
			auto src = instr->operands[1];

			if (src.is_immediate())
			{
				x86::Gp tmp = state->reg_for_size(src);
				state->cc.mov(tmp, src.imm().ival);
				state->cc.sub(state->get_reg(dest), tmp);

				// AsmJit shits its pants when I use this, so we move to a temporary
				// instead. TODO: Investigate
				// state->cc.sub( state->get_reg( dest ), src.imm().ival );
				//
			}
			else
			{
				state->cc.sub(state->get_reg(dest), state->get_reg(src.reg()));
			}
		},
	},
	{
		ins::add,
		[](const vtil::il_iterator& instr, routine_state* state) {
			auto lhs = instr->operands[0].reg();
			auto rhs = instr->operands[1];

			if (rhs.is_immediate())
			{
				x86::Gp tmp = state->reg_for_size(rhs);
				state->cc.mov(tmp, rhs.imm().ival);
				state->cc.add(state->get_reg(lhs), tmp);

				// See note on sub
				//
			}
			else
			{
				state->cc.add(state->get_reg(lhs), state->get_reg(rhs.reg()));
			}
		},
	},
	{
		ins::js,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto cond = it->operands[0].reg();
			auto dst_1 = it->operands[1];
			auto dst_2 = it->operands[2];

			fassert(dst_1.is_immediate() && dst_2.is_immediate());

			// TODO: We should check if the block is compiled in order to avoid the
			// jump here, but I think the optimizer removes this?
			//
			state->cc.test(state->get_reg(cond), state->get_reg(cond));

			state->cc.jnz(state->get_label(dst_1.imm().uval));
			state->cc.jmp(state->get_label(dst_2.imm().uval));

			for (vtil::basic_block* destination : it.block->next)
			{
				if (!state->is_compiled.count(destination->entry_vip))
					compile(destination, state);
			}
		},
	},
	{
		ins::jmp,
		[](const vtil::il_iterator& it, routine_state* state) {
			vtil::debug::dump(*it);
			if (it->operands[0].is_register())
			{
				const vtil::operand::register_t cond = it->operands[0].reg();

				for (vtil::basic_block* destination : it.block->next)
				{
					state->cc.cmp(state->get_reg(cond), destination->entry_vip);
					state->cc.je(state->get_label(destination->entry_vip));

					if (!state->is_compiled.count(destination->entry_vip))
						compile(destination, state);
				}
			}
			else
			{
				fassert(it->operands[0].is_immediate());

				auto dest = it.block->next[0]->entry_vip;

				state->cc.jmp(state->get_label(dest));

				if (!state->is_compiled.count(dest))
					compile(it.block->next[0], state);
			}
		},
	},
	{
		ins::vexit,
		[](const vtil::il_iterator& it, routine_state* state) {
			// TODO: Call out into handler
			//
			state->cc.ret();
		},
	},
	{
		ins::vxcall,
		[](const vtil::il_iterator& it, routine_state* state) {
			// TODO: This should be a call, but you need to create
			// a call, etc. for the register allocator
			// if ( it->operands[ 0 ].is_immediate() )
			// {
			//     state->cc.jmp( it->operands[ 0 ].imm().uval );
			// }
			// else
			// {
			//     state->cc.jmp( state->get_reg( it->operands[ 0 ].reg() ) );
			// }
			//

			auto dest = it.block->next[0]->entry_vip;

			// Jump to next block.
			//
			state->cc.jmp(state->get_label(dest));

			if (!state->is_compiled.count(dest))
				compile(it.block->next[0], state);
		},
	},
	{
		ins::bshl,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto dest = it->operands[0].reg();
			auto shift = it->operands[1];

			if (shift.is_immediate())
			{
				state->cc.shl(state->get_reg(dest), shift.imm().ival);
			}
			else
			{
				state->cc.shl(state->get_reg(dest), state->get_reg(shift.reg()));
			}
		},
	},
	{
		ins::bshr,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto dest = it->operands[0].reg();
			auto shift = it->operands[1];

			if (shift.is_immediate())
			{
				state->cc.shr(state->get_reg(dest), shift.imm().ival);
			}
			else
			{
				state->cc.shr(state->get_reg(dest), state->get_reg(shift.reg()));
			}
		},
	},
	{
		ins::band,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto dest = it->operands[0].reg();
			auto bit = it->operands[1];

			if (bit.is_immediate())
			{
				state->cc.and_(state->get_reg(dest), state->tmp_imm(bit));
			}
			else
			{
				state->cc.and_(state->get_reg(dest), state->get_reg(bit.reg()));
			}
		},
	},
	{
		ins::bor,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto lhs = it->operands[0].reg();
			auto rhs = it->operands[1];

			if (rhs.is_immediate())
			{
				if (rhs.imm().bit_count > 32 || rhs.imm().ival > 0x7FFFFFFF)
				{
					auto temp_reg = state->cc.newGpq();
					state->cc.mov(temp_reg, rhs.imm().ival);
					state->cc.or_(state->get_reg(lhs), temp_reg);
				}					
				else
					state->cc.or_(state->get_reg(lhs), rhs.imm().ival);
			}
			else
			{
				state->cc.or_(state->get_reg(lhs), state->get_reg(rhs.reg()));
			}
		},
	},
	{
		ins::bxor,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto lhs = it->operands[0].reg();
			auto rhs = it->operands[1];

			if (rhs.is_immediate())
			{
				state->cc.xor_(state->get_reg(lhs), rhs.imm().ival);
			}
			else
			{
				state->cc.xor_(state->get_reg(lhs), state->get_reg(rhs.reg()));
			}
		},
	},
	{
		ins::bnot,
		[](const vtil::il_iterator& it, routine_state* state) {
			state->cc.not_(state->get_reg(it->operands[0].reg()));
		},
	},
	{
		ins::neg,
		[](const vtil::il_iterator& it, routine_state* state) {
			state->cc.neg(state->get_reg(it->operands[0].reg()));
		},
	},
	{
		ins::vemit,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto data = it->operands[0].imm().uval;
			// TODO: Are we guarenteed that the registers used by these
			// embedded instructions are actually live at the point these are executed?
			//
			state->cc.embedUInt8((uint8_t)data);
		},
	},
#define MAP_CONDITIONAL(instrT, opcode, ropcode)                                    \
	{                                                                               \
		ins::instrT, [](const vtil::il_iterator& instr, routine_state* state) {     \
			vtil::logger::log("1_is_imm: %d\n", instr->operands[0].is_immediate()); \
			vtil::logger::log("2_is_imm: %d\n", instr->operands[1].is_immediate()); \
			vtil::logger::log("3_is_imm: %d\n", instr->operands[2].is_immediate()); \
			if (instr->operands[1].is_immediate())                                  \
			{                                                                       \
				x86::Gp tmp = state->reg_for_size(instr->operands[1]);              \
				state->cc.mov(tmp, instr->operands[1].imm().ival);                   \
				state->cc.cmp(state->get_reg(instr->operands[2].reg()), tmp);       \
				state->cc.ropcode(state->get_reg(instr->operands[0].reg()));        \
			}                                                                       \
			else                                                                    \
			{                                                                       \
				if (instr->operands[2].is_immediate())                              \
				{                                                                   \
					x86::Gp tmp = state->reg_for_size(instr->operands[2]);          \
					state->cc.mov(tmp, instr->operands[2].imm().ival);               \
					state->cc.cmp(state->get_reg(instr->operands[1].reg()), tmp);   \
				}                                                                   \
				else                                                                \
				{                                                                   \
					state->cc.cmp(state->get_reg(instr->operands[1].reg()),         \
						state->get_reg(instr->operands[2].reg()));                  \
				}                                                                   \
				state->cc.ropcode(state->get_reg(instr->operands[0].reg()));        \
			}                                                                       \
		},                                                                          \
	}
	MAP_CONDITIONAL(tg, setg, setle),
	MAP_CONDITIONAL(tge, setge, setl),
	MAP_CONDITIONAL(te, sete, setne),
	MAP_CONDITIONAL(tne, setne, sete),
	MAP_CONDITIONAL(tle, setle, setg),
	MAP_CONDITIONAL(tl, setl, setge),
	MAP_CONDITIONAL(tug, seta, setbe),
	MAP_CONDITIONAL(tuge, setae, setb),
	MAP_CONDITIONAL(tule, setbe, seta),
	MAP_CONDITIONAL(tul, setb, setae),
#undef MAP_CONDITIONAL
	{
		ins::ifs,
		[](const vtil::il_iterator& it, routine_state* state) {
			auto dest = it->operands[0].reg();
			auto cc = it->operands[1];
			auto res = it->operands[2];

			state->cc.xor_(state->get_reg(dest), state->get_reg(dest));
			// TODO: CC can be an immediate, how does that work?
			//
			state->cc.test(state->get_reg(cc.reg()), state->get_reg(cc.reg()));

			if (res.is_immediate())
			{
				x86::Gp tmp = state->reg_for_size(res);
				state->cc.mov(tmp, res.imm().ival);
				state->cc.cmovnz(state->get_reg(dest), tmp);
			}
			else
			{
				state->cc.cmovnz(state->get_reg(dest), state->get_reg(res.reg()));
			}
		},
	},
	{ ins::vpinr, [](const vtil::il_iterator& it, routine_state* state)
		{
		} },
	{ ins::vpinw, [](const vtil::il_iterator& it, routine_state* state)
		{
		} },
	{ ins::vpinrm, [](const vtil::il_iterator& it, routine_state* state)
		{
		} },
	{ ins::vpinwm, [](const vtil::il_iterator& it, routine_state* state)
		{
		} },
};

static void compile(vtil::basic_block* basic_block, routine_state* state)
{
	Label L_entry = state->get_label(basic_block->entry_vip);
	state->cc.bind(L_entry);
	state->is_compiled.insert(basic_block->entry_vip);

	for (auto it = basic_block->begin(); !it.is_end(); it++)
	{
		vtil::debug::dump(*it);
		auto handler = handler_table.find(*it->base);
		if (handler == handler_table.end())
		{
			vtil::logger::log("\n[!] ERROR: Unrecognized instruction '%s'\n\n", it->base->name);
			exit(1);
		}
		handler->second(it, state);
	}
}

class DemoErrorHandler : public ErrorHandler
{
public:
	void handleError(Error err, const char* message, BaseEmitter* origin) override
	{
		std::cerr << "AsmJit error: " << message << "\n";
	}
};

bool compile(vtil::routine* rtn, std::vector<uint8_t>& out)
{
	JitRuntime rt;
	FileLogger logger(stdout);
	DemoErrorHandler err;
	CodeHolder code;

	code.init(rt.environment());
	x86::Compiler cc(&code);

	cc.addFunc(FuncSignatureT<void>());
	
	routine_state state(cc, 0x1'4000'0000);
	compile(rtn->entry_point, &state);

	cc.endFunc();
	cc.finalize();

	CodeBuffer& buffer = code.sectionById(0)->buffer();
	out.insert(out.end(), buffer.data(), buffer.data() + buffer.size());
	return true;
}
```