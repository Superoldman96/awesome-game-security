Project Path: arc_gmh5225_VanguardTrace_liwz8ahg

Source Tree:

```txt
arc_gmh5225_VanguardTrace_liwz8ahg
├── LICENSE
├── README.md
├── VanguardTrace
│   ├── Hooks.cpp
│   ├── Hooks.hpp
│   ├── Include.hpp
│   ├── Main.cpp
│   ├── Native.cpp
│   ├── Native.hpp
│   ├── Signature Scan.cpp
│   ├── Signature Scan.hpp
│   ├── Vanguard.cpp
│   ├── Vanguard.hpp
│   ├── VanguardTrace.vcxproj
│   ├── VanguardTrace.vcxproj.filters
│   └── VanguardTrace.vcxproj.user
├── VanguardTrace.sln
└── hook.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 armvirus

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# VanguardTrace

### Decrypting and Intercepting Encrypted Imports of Vanguard's Kernel Driver

Welcome to VanguardTrace, a tool designed to decrypt and intercept encrypted imports within Vanguard's Kernel Driver.

## Overview

I began my exploration of vgk.sys and its import protection mechanisms. One strategy that immediately occurred to me for gaining insight was to employ a patchguard bypass. By hooking potential imports and capturing their return addresses, I could trace back to where vgk.sys calls these imports. This approach led me directly to their decryption algorithm. With a clear understanding of this algorithm, I proceeded to rewrite it for readability and created the complementary encryption function. Additionally, I developed functions to determine the starting offset of the imports encryption "table" using a simple signature scan, and to retrieve the offset of specific imports of interest.

## Features

- **Decryption**: Decrypt encrypted imports within Vanguard's Kernel Driver.
- **Interception**: Intercept and manipulate encrypted imports.
- **Pointer Encryption**: Encrypt pointers with their encryption routine to assist with intercepting.
- **Automatic Import Table Location**: Automatically locate the start of the encrypted import table using a signature scan.
- **Offset Identification**: Identify the offset of the desired import for easy manipulation/hooking.

## Example Usage

![CiCheckSignedFile](./hook.png)

## License

This project is licensed under the [MIT License](LICENSE).

```

`VanguardTrace.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32901.215
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VanguardTrace", "VanguardTrace\VanguardTrace.vcxproj", "{1E272B48-82A2-4222-97C4-BC6D4FA1CBF6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1E272B48-82A2-4222-97C4-BC6D4FA1CBF6}.Release|x64.ActiveCfg = Release|x64
		{1E272B48-82A2-4222-97C4-BC6D4FA1CBF6}.Release|x64.Build.0 = Release|x64
		{1E272B48-82A2-4222-97C4-BC6D4FA1CBF6}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FF68B84B-D997-4FA3-8258-A9B5E5967AFF}
	EndGlobalSection
EndGlobal

```

`VanguardTrace/Hooks.cpp`:

```cpp
#include "Include.hpp"

namespace Hooks
{
    NTSTATUS CiCheckSignedFileHookVgk(void* Buf1, size_t Size, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64* a7, __int64* a8)
    {
        auto ret = CiCheckSignedFileOg(Buf1, Size, a3, a4, a5, a6, a7, a8);

        DebugPrint("[%p] CiCheckSignedFile Called with Buf %p\n", _ReturnAddress(), Buf1);

        return ret == STATUS_INVALID_IMAGE_HASH ? STATUS_SUCCESS : ret;
    }

    NTSTATUS ZwDeviceIoControlFileHook(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)
    {
        DebugPrint("ZwDeviceIoControlFile Called From 0x%p\n", _ReturnAddress());
        DebugPrint("     - IoControlCode: 0x%p\n", IoControlCode);

        return ZwDeviceIoControlFile(FileHandle, Event, ApcRoutine, ApcContext, IoStatusBlock, IoControlCode, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength);
    }

}
```

`VanguardTrace/Hooks.hpp`:

```hpp
#pragma once

namespace Hooks
{
    inline NTSTATUS(*CiCheckSignedFileOg)(void* Buf1, size_t Size, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64* a7, __int64* a8);

	NTSTATUS CiCheckSignedFileHookVgk(void* Buf1, size_t Size, unsigned int a3, __int64 a4, unsigned int a5, __int64 a6, __int64* a7, __int64* a8);
    NTSTATUS ZwDeviceIoControlFileHook(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
}
```

`VanguardTrace/Include.hpp`:

```hpp
#pragma once

#include <ntifs.h>
#include <windef.h>

#include <ntimage.h>
#include <cstdint>
#include <cstddef>

#include "Native.hpp"
#include "Signature Scan.hpp"
#include "Vanguard.hpp"
#include "Hooks.hpp"

#define RVA(Instr, InstrSize) ((ULONG64)Instr + InstrSize + *(LONG*)((ULONG64)Instr + (InstrSize - sizeof(LONG))))
#define DebugPrint(fmt, ...) DbgPrintEx(0, 0, "[VanguardStackTrace] " fmt, ##__VA_ARGS__)
```

`VanguardTrace/Main.cpp`:

```cpp
#include "Include.hpp"

NTSTATUS DriverEntry(const PDRIVER_OBJECT driverObject, const PUNICODE_STRING registryPath)
{
    DebugPrint("Vanguard Trace Hook Initiating...\n");

    std::uintptr_t moduleBase = 0;
    std::size_t moduleSize = 0;

    if (Native::getKernelModuleByName("vgk.sys", &moduleBase, &moduleSize))
        return STATUS_NOT_FOUND;

    std::uint32_t startOffset = Vanguard::getImportStartOffset(moduleBase, moduleSize); // 0x816a0;

    DebugPrint("Found startOffset @ 0x%x", startOffset);

    std::uint32_t ExCreateCallbackOffset = Vanguard::findImportOffset(moduleBase, "ntoskrnl.exe", "ExCreateCallback", startOffset);

    DebugPrint("Found ExCreateCallbackOffset @ 0x%x", ExCreateCallbackOffset);

    std::uint32_t CiCheckSignedFileOffset = Vanguard::findImportOffset(moduleBase, "CI.dll", "CiCheckSignedFile", startOffset);

    DebugPrint("Found CiCheckSignedFileOffset @ 0x%x", CiCheckSignedFileOffset);

    *reinterpret_cast<std::uintptr_t*>(&Hooks::CiCheckSignedFileOg) = Vanguard::DecryptVGKImportFunction(moduleBase, CiCheckSignedFileOffset);

    Vanguard::HookVgkImportFunction(moduleBase, CiCheckSignedFileOffset, reinterpret_cast<std::uintptr_t>(&Hooks::CiCheckSignedFileHookVgk));

    return STATUS_SUCCESS;
}
```

`VanguardTrace/Native.cpp`:

```cpp
#include "Include.hpp"

namespace Native
{
	NTSTATUS getKernelModuleByName(const char* moduleName, std::uintptr_t* moduleStart, std::size_t* moduleSize)
	{
		if (!moduleStart || !moduleSize)
			return STATUS_INVALID_PARAMETER;

		std::size_t size{};
		ZwQuerySystemInformation(0xB, nullptr, size, reinterpret_cast<PULONG>(&size));

		const auto listHeader = ExAllocatePool(NonPagedPool, size);
		if (!listHeader)
			return STATUS_MEMORY_NOT_ALLOCATED;

		if (const auto status = ZwQuerySystemInformation(0xB, listHeader, size, reinterpret_cast<PULONG>(&size)))
			return status;

		auto currentModule = reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Module;
		for (std::size_t i{}; i < reinterpret_cast<PSYSTEM_MODULE_INFORMATION>(listHeader)->Count; ++i, ++currentModule)
		{
			const auto currentModuleName = reinterpret_cast<const char*>(currentModule->FullPathName + currentModule->OffsetToFileName);
			//DebugPrint("currentModuleName %s\n", currentModuleName);
			if (!strcmp(moduleName, currentModuleName))
			{
				*moduleStart = reinterpret_cast<std::uintptr_t>(currentModule->ImageBase);
				*moduleSize = currentModule->ImageSize;
				return STATUS_SUCCESS;
			}
		}

		return STATUS_NOT_FOUND;
	}
}
```

`VanguardTrace/Native.hpp`:

```hpp
#pragma once

extern "C" 
{
	NTSTATUS NTAPI ZwQuerySystemInformation(ULONG SystemInformationClass, PVOID SystemInformation,
		ULONG SystemInformationLength, PULONG ReturnLength);

	extern "C" NTKERNELAPI
		PVOID
		NTAPI
		RtlFindExportedRoutineByName(
			_In_ PVOID ImageBase,
			_In_ PCCH RoutineNam
		);
}

namespace Native 
{
	NTSTATUS getKernelModuleByName(const char *moduleName, std::uintptr_t *moduleStart, std::size_t *moduleSize);
}

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;
```

`VanguardTrace/Signature Scan.cpp`:

```cpp
#include "Include.hpp"

namespace Scanner
{
	BOOLEAN CheckMask(PCHAR base, PCHAR pattern, PCHAR mask)
	{
		for (; *mask; ++base, ++pattern, ++mask)
		{
			if (*mask == 'x' && *base != *pattern)
			{
				return FALSE;
			}
		}

		return TRUE;
	}

	PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask)
	{
		length -= (DWORD)strlen(mask);

		for (DWORD i = 0; i <= length; ++i)
		{
			PVOID addr = &base[i];
			if (CheckMask((PCHAR)addr, pattern, mask))
			{
				return addr;
			}
		}

		return 0;
	}

	PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask)
	{
		PVOID match = 0;

		PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
		PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);

		for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
		{
			PIMAGE_SECTION_HEADER section = &sections[i];

			if (memcmp(section->Name, ".text", 5) == 0)
			{
				match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
				if (match)
				{
					break;
				}
			}
		}

		return match;
	}

	PVOID FindPatternImageExec(PCHAR base, PCHAR pattern, PCHAR mask)
	{
		PVOID match = 0;

		PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
		PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);

		for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i)
		{
			PIMAGE_SECTION_HEADER section = &sections[i];

			if (*(PINT)section->Name == 'EGAP' || memcmp(section->Name, ".text", 5) == 0)
			{
				match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
				if (match)
				{
					break;
				}
			}
		}

		return match;
	}
}

```

`VanguardTrace/Signature Scan.hpp`:

```hpp
#pragma once

namespace Scanner 
{
	PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask);
	PVOID FindPatternImageExec(PCHAR base, PCHAR pattern, PCHAR mask);
	PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask);
}
```

`VanguardTrace/Vanguard.cpp`:

```cpp
#include "Include.hpp"

namespace Vanguard
{
    void HookVgkImportFunction(std::uintptr_t VanguardBase, std::uintptr_t ImportOffset, std::uintptr_t originalFunctionPtr)
    {
        if (!VanguardBase || !ImportOffset || !originalFunctionPtr)
            return;

        KeyOffsets offsets = {
            ImportOffset,
            ImportOffset + 0x8,
            ImportOffset + 0x18,
            ImportOffset + 0x20
        };

        // Retrieve the original values from the offsets
        uintptr_t& wordAtKey1 = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.wordOffset);
        uintptr_t& functionXor = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.qwordPtrOffset + 8 * HIBYTE(wordAtKey1));
        uintptr_t& byteCount = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.byteCountOffset);
        unsigned char byteCountValue = static_cast<unsigned char>(byteCount);

        // Reverse the XOR operations for the byteCount part
        if (HIBYTE(byteCount) > 0) {
            uintptr_t valueAtKey3 = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.qwordOffset);
            for (size_t i = 8 - HIBYTE(byteCount); i < 8; ++i) {
                reinterpret_cast<uint8_t*>(&originalFunctionPtr)[i] ^= reinterpret_cast<uint8_t*>(valueAtKey3)[i];
            }
        }

        // Reverse the XOR operations for the main encryption loop
        for (int8_t i = byteCountValue - 1; i >= 0; --i) {
            uintptr_t xorValue = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.qwordOffset + 8 * (i & 0xFF));
            originalFunctionPtr ^= xorValue;
        }

        // Overwrite the original function pointer with the encrypted value
        functionXor = originalFunctionPtr;
    }

    std::uintptr_t DecryptVGKImportFunction(std::uintptr_t VanguardBase, std::uintptr_t ImportOffset)
    {
        if (!VanguardBase || !ImportOffset)
            return 0;

        KeyOffsets offsets = {
        ImportOffset,
        ImportOffset + 0x8,
        ImportOffset + 0x18,
        ImportOffset + 0x20
        };

        uintptr_t wordAtKey1 = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.wordOffset);
        if (!wordAtKey1)
            return 0;

        uintptr_t functionXor = *reinterpret_cast<__int64*>(VanguardBase + offsets.qwordPtrOffset + 8 * HIBYTE(wordAtKey1));
        if (!functionXor)
            return 0;

        uintptr_t byteCount = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.byteCountOffset);
        if (byteCount != 1)
            return 0;

        unsigned char byteCountValue = static_cast<unsigned char>(byteCount);

        for (uint8_t i = 0; i < byteCountValue; ++i) {
            uintptr_t xorValue = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.qwordOffset + 8 * (i & 0xFF));
            functionXor ^= xorValue;
        }

        if (HIBYTE(byteCount) > 0)
        {
            uintptr_t valueAtKey3 = *reinterpret_cast<uintptr_t*>(VanguardBase + offsets.qwordOffset);

            for (size_t i = 8 - HIBYTE(byteCount); i < 8; ++i) {
                reinterpret_cast<uint8_t*>(&functionXor)[i] ^= reinterpret_cast<uint8_t*>(valueAtKey3)[i];
            }
        }

        return functionXor;
    }

    std::uint32_t getImportStartOffset(std::uintptr_t VanguardBase, std::size_t VanguardSize)
    {
        if (!VanguardBase || !VanguardSize)
            return 0;

        // [actual address in first opcode] 66 0F AB D3 44 38 1D ? ? ? ?
        // 66 C7 05 ? ? ? ? ? ? 48 63 D5 
        // 4C 8D 05 ? ? ? ? 48 0F B7 CA

        std::uintptr_t leaStartOffset = reinterpret_cast<std::uintptr_t>(Scanner::FindPattern(reinterpret_cast<char*>(VanguardBase), VanguardSize, "\x8A\x15\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x48\x98", "xx????x????xx"));
        if (!leaStartOffset || !MmIsAddressValid(reinterpret_cast<void*>(leaStartOffset)))
            return 0;

        std::uintptr_t startOffset = RVA(leaStartOffset, 6);
        if (!startOffset || !MmIsAddressValid(reinterpret_cast<void*>(startOffset)))
            return 0;

        std::uint32_t randomOffset = startOffset - VanguardBase - 1;

        std::uint32_t firstImport = 0;
        for (int i = 0;; i++)
        {
            std::uint32_t Offset = randomOffset - i * 0x28;
            std::uintptr_t DecryptedRoutine = Vanguard::DecryptVGKImportFunction(VanguardBase, Offset);
            if (!DecryptedRoutine || !MmIsAddressValid(reinterpret_cast<void*>(DecryptedRoutine)))
                break;

            firstImport = Offset;
        }

        return firstImport;
    }

    std::uint32_t findImportOffset(std::uintptr_t VanguardBase, const char* ImportModule, const char* ImportName, std::uint32_t startOffset)
    {
        if (!VanguardBase || !startOffset)
            return 0;

        std::uintptr_t importModuleBase{};
        std::size_t importModuleSize{};

        if (!NT_SUCCESS(Native::getKernelModuleByName(ImportModule, &importModuleBase, &importModuleSize)))
            return 0;

        std::uintptr_t importAddress = reinterpret_cast<std::uintptr_t>(RtlFindExportedRoutineByName(reinterpret_cast<void*>(importModuleBase), ImportName));
        if (!importAddress)
            return 0;

        for (int i = 0; ; i++)
        {
            std::uint32_t Offset = startOffset + i * 0x28;
            std::uintptr_t DecryptedRoutine = Vanguard::DecryptVGKImportFunction(VanguardBase, Offset);
            if (!DecryptedRoutine || !MmIsAddressValid(reinterpret_cast<void*>(DecryptedRoutine)))
                break;

            if (importAddress == DecryptedRoutine)
                return Offset;      
        }
          
        return 0;
    }
}
```

`VanguardTrace/Vanguard.hpp`:

```hpp
#pragma once

struct KeyOffsets {
    __int64 wordOffset;  // Previously key1
    __int64 qwordPtrOffset; // Previously key2
    __int64 qwordOffset; // Previously key3
    __int64 byteCountOffset; // Previously key4
};

namespace Vanguard
{
    void HookVgkImportFunction(std::uintptr_t VanguardBase, std::uintptr_t ImportOffset, std::uintptr_t originalFunctionPtr);
    std::uintptr_t DecryptVGKImportFunction(std::uintptr_t VanguardBase, std::uintptr_t ImportOffset);
    std::uint32_t findImportOffset(std::uintptr_t VanguardBase, const char* ImportModule, const char* ImportName, std::uint32_t startOffset);
    std::uint32_t getImportStartOffset(std::uintptr_t VanguardBase, std::size_t VanguardSize);
}
```

`VanguardTrace/VanguardTrace.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1E272B48-82A2-4222-97C4-BC6D4FA1CBF6}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>VanguardTrace</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
    <ProjectName>VanguardTrace</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <IncludePath>$(VC_IncludePath);$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)Output\</OutDir>
    <IntDir>$(SolutionDir)VanguardTrace\Bin\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnableModules>true</EnableModules>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <TreatWarningAsError>false</TreatWarningAsError>
      <EnableModules>true</EnableModules>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ProgramDataBaseFileName />
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <Profile>false</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Hooks.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Native.cpp" />
    <ClCompile Include="Signature Scan.cpp" />
    <ClCompile Include="Vanguard.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hooks.hpp" />
    <ClInclude Include="Include.hpp" />
    <ClInclude Include="Native.hpp" />
    <ClInclude Include="Signature Scan.hpp" />
    <ClInclude Include="Vanguard.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`VanguardTrace/VanguardTrace.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Native.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Signature Scan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Vanguard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Native.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Include.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Signature Scan.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vanguard.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hooks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`VanguardTrace/VanguardTrace.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```