Project Path: arc_gmh5225_pdbr_7mvxhbf4

Source Tree:

```txt
arc_gmh5225_pdbr_7mvxhbf4
├── Dockerfile
├── LICENSE
├── Makefile
├── README.md
├── images
│   ├── image1.png
│   ├── image10.png
│   ├── image11.png
│   ├── image12.png
│   ├── image13.png
│   ├── image14.png
│   ├── image2.png
│   ├── image3.png
│   ├── image4.png
│   ├── image5.png
│   ├── image6.png
│   ├── image7.png
│   └── image9.png
├── noxfile.py
├── pdbr
│   ├── __init__.py
│   ├── __main__.py
│   ├── _cm.py
│   ├── _console_layout.py
│   ├── _pdbr.py
│   ├── cli.py
│   ├── helpers.py
│   ├── middlewares
│   │   ├── __init__.py
│   │   ├── django.py
│   │   └── starlette.py
│   ├── runner.py
│   └── utils.py
├── poetry.lock
├── pyproject.toml
├── runtests.py
├── scripts
│   ├── lint
│   └── test
├── setup.cfg
└── tests
    ├── __init__.py
    ├── conftest.py
    ├── test_api.py
    ├── test_config.py
    ├── test_magic.py
    ├── test_pdbr.py
    └── tests_django
        ├── __init__.py
        ├── test_settings.py
        ├── tests.py
        └── urls.py

```

`Dockerfile`:

```
FROM python:3.7.9

ENV PYTHONUNBUFFERED=0

RUN pip install pip \
 && pip install nox \
 && pip install pre-commit

WORKDIR /pdbr
COPY . .

RUN pre-commit run --all-files
RUN nox --sessions test django_test

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Can Sarıgöl

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
lint:
	sh scripts/lint

test:
	sh scripts/test

celery:
	celery -A tasks worker --loglevel=info

build:
	docker build -t pdbr .

act:
	act -r -j test --container-architecture linux/amd64

```

`README.md`:

```md
# pdbr

[![PyPI version](https://badge.fury.io/py/pdbr.svg)](https://pypi.org/project/pdbr/) [![Python Version](https://img.shields.io/pypi/pyversions/pdbr.svg)](https://pypi.org/project/pdbr/) [![](https://github.com/cansarigol/pdbr/workflows/Test/badge.svg)](https://github.com/cansarigol/pdbr/actions?query=workflow%3ATest) [![pre-commit.ci status](https://results.pre-commit.ci/badge/github/cansarigol/pdbr/master.svg)](https://results.pre-commit.ci/latest/github/cansarigol/pdbr/master)


`pdbr` is intended to make the PDB results more colorful. it uses [Rich](https://github.com/willmcgugan/rich) library to carry out that.


## Installing

Install with `pip` or your favorite PyPi package manager.

```
pip install pdbr
```


## Breakpoint

In order to use ```breakpoint()```, set **PYTHONBREAKPOINT** with "pdbr.set_trace"

```python
import os

os.environ["PYTHONBREAKPOINT"] = "pdbr.set_trace"
```

or just import pdbr

```python
import pdbr
```

## New commands
### (i)nspect / inspectall | ia
[rich.inspect](https://rich.readthedocs.io/en/latest/introduction.html?s=03#rich-inspector)
### search | src
Search a phrase in the current frame.
In order to repeat the last one, type **/** character as arg.
### sql
Display value in sql format. Don't forget to install [sqlparse](https://github.com/andialbrecht/sqlparse) package.
![](/images/image13.png)

It can be used for Django model queries as follows.
```
>>> sql str(Users.objects.all().query)
```
![](/images/image14.png)
### (syn)tax
[ val,lexer ] Display [lexer](https://pygments.org/docs/lexers/).
### (v)ars
Get the local variables list as table.
### varstree | vt
Get the local variables list as tree.

![](/images/image5.png)

## Config
Config is specified in **setup.cfg** and can be local or global. Local config (current working directory) has precedence over global (default) one. Global config must be located at `$XDG_CONFIG_HOME/pdbr/setup.cfg`.

### Style
In order to use Rich's traceback, style, and theme:

```
[pdbr]
style = yellow
use_traceback = True
theme = friendly
```

Also custom `Console` object can be assigned to the `set_trace`.
```python
import pdbr

from rich.console import Console
from rich.style import Style
from rich.theme import Theme

custom_theme = Theme({
    "info": "dim cyan",
    "warning": "magenta",
    "danger": "bold red",
})
custom_style = Style(
    color="magenta",
    bgcolor="yellow",
    italic=True,
)
console = Console(theme=custom_theme, style=custom_style)

pdbr.set_trace(console=console)
```
### History
**store_history** setting is used to keep and reload history, even the prompt is closed and opened again:
```
[pdbr]
...
store_history=.pdbr_history
```

By default, history is stored globally in `~/.pdbr_history`.

### Context
The **context** setting is used to specify the number of lines of source code context to show when displaying stacktrace information.
```
[pdbr]
...
context=10
```
This setting is only available when using `pdbr` with `IPython`.

## Celery
In order to use **Celery** remote debugger with pdbr, use ```celery_set_trace``` as below sample. For more information see the [Celery user guide](https://docs.celeryproject.org/en/stable/userguide/debugging.html).

```python
from celery import Celery

app = Celery('tasks', broker='pyamqp://guest@localhost//')

@app.task
def add(x, y):

    import pdbr; pdbr.celery_set_trace()

    return x + y

```
#### Telnet
Instead of using `telnet` or `nc`, in terms of using pdbr style, `pdbr_telnet` command can be used.
![](/images/image6.png)

Also in order to activate history and be able to use arrow keys, install and use [rlwrap](https://github.com/hanslub42/rlwrap) package.

```
rlwrap -H '~/.pdbr_history' pdbr_telnet localhost 6899
```

## IPython

`pdbr` integrates with [IPython](https://ipython.readthedocs.io/).

This makes [`%magics`](https://ipython.readthedocs.io/en/stable/interactive/magics.html) available, for example:

```python
(Pdbr) %timeit range(100)
104 ns ± 2.05 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)
```

To enable `IPython` features, install it separately, or like below:

```
pip install pdbr[ipython]
```

## pytest
In order to use `pdbr` with pytest `--pdb` flag, add `addopts` setting in your pytest.ini.

```
[pytest]
addopts: --pdbcls=pdbr:RichPdb
```

## sys.excepthook
The `sys.excepthook` is a Python system hook that provides a way to customize the behavior when an unhandled exception occurs. Since `pdbr` use  automatic traceback handler feature of `rich`, formatting exception print is not necessary if `pdbr` module is already imported.

In order to use post-mortem or perform other debugging features of `pdbr`,  override `sys.excepthook` with a function that will act as your custom excepthook:
```python
import sys
import pdbr

def custom_excepthook(exc_type, exc_value, exc_traceback):
    pdbr.post_mortem(exc_traceback, exc_value)

    # [Optional] call the original excepthook as well
    sys.__excepthook__(exc_type, exc_value, exc_traceback)

sys.excepthook = custom_excepthook
```
Now, whenever an unhandled exception occurs, `pdbr` will be triggered, allowing you to debug the issue interactively.

## Context Decorator
`pdbr_context` and `apdbr_context` (`asyncio` corresponding) can be used as **with statement** or **decorator**. It calls `post_mortem` if `traceback` is not none.

```python
from pdbr import apdbr_context, pdbr_context

@pdbr_context()
def foo():
    ...

def bar():
    with pdbr_context():
        ...


@apdbr_context()
async def foo():
    ...

async def bar():
    async with apdbr_context():
        ...
```

![](/images/image12.png)
## Django DiscoverRunner
To being activated the pdb in Django test, change `TEST_RUNNER` like below. Unlike Django (since you are not allowed to use for smaller versions than 3), pdbr runner can be used for version 1.8 and subsequent versions.

```
TEST_RUNNER = "pdbr.runner.PdbrDiscoverRunner"
```
![](/images/image10.png)
## Middlewares
### Starlette
```python
from fastapi import FastAPI
from pdbr.middlewares.starlette import PdbrMiddleware

app = FastAPI()

app.add_middleware(PdbrMiddleware, debug=True)


@app.get("/")
async def main():
    1 / 0
    return {"message": "Hello World"}
```
### Django
In order to catch the problematic codes with post mortem, place the middleware class.

```
MIDDLEWARE = (
    ...
    "pdbr.middlewares.django.PdbrMiddleware",
)
```
![](/images/image11.png)
## Shell
Running `pdbr` command in terminal starts an `IPython` terminal app instance. Unlike default `TerminalInteractiveShell`, the new shell uses pdbr as debugger class instead of `ipdb`.
#### %debug magic sample
![](/images/image9.png)
### As a Script
If `pdbr` command is used with an argument, it is invoked as a script and [debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands) can be used with it.
```python
# equivalent code: `python -m pdbr -c 'b 5' my_test.py`
pdbr -c 'b 5' my_test.py

>>> Breakpoint 1 at /my_test.py:5
> /my_test.py(3)<module>()
      1
      2
----> 3 def test():
      4         foo = "foo"
1     5         bar = "bar"

(Pdbr)

```
### Terminal
#### Django shell sample
![](/images/image7.png)

## Vscode user snippet

To create or edit your own snippets, select **User Snippets** under **File > Preferences** (**Code > Preferences** on macOS), and then select **python.json**.

Place the below snippet in json file for **pdbr**.

```
{
  ...
  "pdbr": {
        "prefix": "pdbr",
        "body": "import pdbr; pdbr.set_trace()",
        "description": "Code snippet for pdbr debug"
    },
}
```

For **Celery** debug.

```
{
  ...
  "rdbr": {
        "prefix": "rdbr",
        "body": "import pdbr; pdbr.celery_set_trace()",
        "description": "Code snippet for Celery pdbr debug"
    },
}
```

## Samples
![](/images/image1.png)

![](/images/image3.png)

![](/images/image4.png)

### Traceback
![](/images/image2.png)

```

`noxfile.py`:

```py
import nox

nox.options.stop_on_first_error = True


@nox.session
def test(session, reuse_venv=True):
    session.install(
        ".",
        "pytest",
        "pytest-cov",
        "rich",
        "prompt_toolkit",
        "IPython",
    )
    session.run(
        "pytest",
        "--cov-report",
        "term-missing",
        "--cov=pdbr",
        "--capture=no",
        "--disable-warnings",
        "tests",
    )


@nox.session
@nox.parametrize("django", ["3.2", "4.2"])
def django_test(session, django, reuse_venv=True):
    session.install(f"django=={django}", "rich", "pytest")
    session.run("python", "runtests.py")

```

`pdbr/__init__.py`:

```py
from pdbr.__main__ import RichPdb, celery_set_trace, pm, post_mortem, run, set_trace
from pdbr._cm import apdbr_context, pdbr_context

__all__ = [
    "set_trace",
    "run",
    "pm",
    "post_mortem",
    "celery_set_trace",
    "RichPdb",
    "pdbr_context",
    "apdbr_context",
]

```

`pdbr/__main__.py`:

```py
import os
import pdb
import sys

from .utils import _pdbr_cls, _rdbr_cls

os.environ["PYTHONBREAKPOINT"] = "pdbr.set_trace"

RichPdb = _pdbr_cls(return_instance=False, show_layouts=False)


def set_trace(*, console=None, header=None, context=None, show_layouts=False):
    pdb_cls = _pdbr_cls(console=console, context=context, show_layouts=show_layouts)
    if header is not None:
        pdb_cls.message(header)
    pdb_cls.set_trace(sys._getframe().f_back)


def run(statement, globals=None, locals=None):
    RichPdb().run(statement, globals, locals)


def post_mortem(traceback=None, value=None):
    _, sys_value, sys_traceback = sys.exc_info()
    value = value or sys_value
    traceback = traceback or sys_traceback

    if traceback is None:
        raise ValueError(
            "A valid traceback must be passed if no exception is being handled"
        )

    p = RichPdb()
    p.reset()
    if value:
        p.error(value)
    p.interaction(None, traceback)


def pm():
    post_mortem(sys.last_traceback)


def celery_set_trace(frame=None):
    pdb_cls = _rdbr_cls()
    if frame is None:
        frame = sys._getframe().f_back
    return pdb_cls.set_trace(frame)


def main():
    pdb.Pdb = RichPdb
    pdb.main()


if __name__ == "__main__":
    main()

```

`pdbr/_cm.py`:

```py
from contextlib import ContextDecorator
from functools import wraps

from pdbr.__main__ import post_mortem


class pdbr_context(ContextDecorator):
    def __init__(self, suppress_exc=True, debug=True):
        self.suppress_exc = suppress_exc
        self.debug = debug

    def __enter__(self):
        return self

    def __exit__(self, _, exc_value, exc_traceback):
        if exc_traceback and self.debug:
            post_mortem(exc_traceback, exc_value)
            return self.suppress_exc
        return False


class AsyncContextDecorator(ContextDecorator):
    def __call__(self, func):
        @wraps(func)
        async def inner(*args, **kwds):
            async with self._recreate_cm():
                return await func(*args, **kwds)

        return inner


class apdbr_context(AsyncContextDecorator):
    def __init__(self, suppress_exc=True, debug=True):
        self.suppress_exc = suppress_exc
        self.debug = debug

    async def __aenter__(self):
        return self

    async def __aexit__(self, _, exc_value, exc_traceback):
        if exc_traceback and self.debug:
            post_mortem(exc_traceback, exc_value)
            return self.suppress_exc
        return False

```

`pdbr/_console_layout.py`:

```py
from rich.containers import Lines
from rich.errors import NotRenderableError
from rich.layout import Layout
from rich.panel import Panel


class ConsoleLayoutMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class ConsoleLayout(metaclass=ConsoleLayoutMeta):
    def __init__(self, console):
        self.console = console
        self.layout = self._prep_layout()

    def _prep_layout(self):
        layout = Layout()
        right_body = Layout(name="right_body", ratio=1)

        layout.split(
            Layout(name="left_body", ratio=2),
            right_body,
            splitter="row",
        )

        right_body.split(
            Layout(name="up_footer", ratio=2), Layout(name="bottom_footer", ratio=1)
        )
        return layout

    def print(self, message, code, stack_trace, vars, **kwargs):
        try:
            self.layout["left_body"].update(code)
            self.layout["up_footer"].update(Panel(vars, title="Locals"))

            self.layout["bottom_footer"].update(
                Panel(Lines(stack_trace), title="Stack", style="white on blue")
            )

            self.console.print(self.layout, **kwargs)
            self.console.print(message, **kwargs)
        except NotRenderableError:
            self.console.print(message, **kwargs)

```

`pdbr/_pdbr.py`:

```py
import inspect
import io
import re
from pathlib import Path
from pdb import Pdb

from rich import box, markup
from rich._inspect import Inspect
from rich.console import Console
from rich.panel import Panel
from rich.pretty import pprint
from rich.syntax import DEFAULT_THEME, Syntax
from rich.table import Table
from rich.text import Text
from rich.theme import Theme
from rich.tree import Tree

from pdbr._console_layout import ConsoleLayout

try:
    from IPython.terminal.interactiveshell import TerminalInteractiveShell

    TerminalInteractiveShell.simple_prompt = False
except ImportError:
    pass

WITHOUT_LAYOUT_COMMANDS = (
    "where",
    "w",
)
ANSI_ESCAPE = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")


class AsciiStdout(io.TextIOWrapper):
    pass


def rich_pdb_klass(
    base, is_celery=False, console=None, context=None, show_layouts=True
):
    class RichPdb(base):
        _style = None
        _theme = None
        _history_file = None
        _ipython_history_file = None
        _latest_search_arg = ""

        def __init__(
            self,
            completekey="tab",
            stdin=None,
            stdout=None,
            skip=None,
            nosigint=False,
            readrc=True,
        ):
            init_kwargs = (
                {"out": stdout}
                if is_celery
                else {
                    "completekey": completekey,
                    "stdin": stdin,
                    "stdout": stdout,
                    "skip": skip,
                    "nosigint": nosigint,
                    "readrc": readrc,
                }
            )
            if console is not None:
                self._console = console
            if context is not None:
                if base == Pdb:
                    raise ValueError("Context can only be used with IPython")
                init_kwargs["context"] = context
            super().__init__(**init_kwargs)

            self.prompt = "(Pdbr) "

        def pt_init(self, pt_session_options=None):
            from prompt_toolkit.history import FileHistory

            if self._ipython_history_file:
                history_file = FileHistory(self._ipython_history_file)
                self.shell.debugger_history = history_file
                # In order to fix the error for ipython 8.x
                self.debugger_history = history_file

            func = super().pt_init
            func_args = inspect.getfullargspec(super().pt_init).args
            if "pt_session_options" in func_args:
                func(pt_session_options)
            else:
                func()

        @property
        def console(self):
            if not hasattr(self, "_console"):
                self._console = Console(
                    file=(
                        AsciiStdout(buffer=self.stdout.buffer, encoding="ascii")
                        if is_celery
                        else self.stdout
                    ),
                    theme=Theme(
                        {"info": "dim cyan", "warning": "magenta", "danger": "bold red"}
                    ),
                    style=self._style,
                    force_terminal=True,
                    force_interactive=True,
                )
            return self._console

        def do_help(self, arg):
            super().do_help(arg)
            if not arg:
                self._print(
                    Panel(
                        "Visit "
                        "[bold][link=https://github.com/cansarigol/pdbr]"
                        "https://github.com/cansarigol/pdbr[/link][/]"
                        " for more!"
                    ),
                    style="warning",
                    print_layout=False,
                )

        do_help.__doc__ = base.do_help.__doc__
        do_h = do_help

        def _get_syntax_for_list(self, line_range=None):
            if not line_range:
                first = max(1, self.curframe.f_lineno - 5)
                line_range = first, first + 10
            filename = self.curframe.f_code.co_filename
            highlight_lines = {self.curframe.f_lineno}

            return Syntax.from_path(
                filename,
                line_numbers=True,
                theme=self._theme or DEFAULT_THEME,
                line_range=line_range,
                highlight_lines=highlight_lines,
            )

        def _get_variables(self):
            try:
                return [
                    (k, str(v), str(type(v)))
                    for k, v in self.curframe.f_locals.items()
                    if not k.startswith("__") and k != "pdbr"
                ]
            except AttributeError:
                return []

        def do_l(self, arg):
            """l
            List 11 lines source code for the current file.
            """
            try:
                self._print(self._get_syntax_for_list(), print_layout=False)
            except BaseException:
                self.error("could not get source code")

        def do_longlist(self, arg):
            """longlist | ll
            List the whole source code for the current function or frame.
            """
            try:
                lines, lineno = self._getsourcelines(self.curframe)
                last = lineno + len(lines)
                self._print(
                    self._get_syntax_for_list((lineno, last)), print_layout=False
                )
            except BaseException:
                self.error("could not get source code")

        do_ll = do_longlist

        def do_source(self, arg):
            """source expression
            Try to get source code for the given object and display it.
            """
            try:
                obj = self._getval(arg)
                lines, lineno = self._getsourcelines(obj)
                last = lineno + len(lines)
                self._print(
                    self._get_syntax_for_list((lineno, last)), print_layout=False
                )
            except BaseException as err:
                self.error(err)

        def do_search(self, arg):
            """search | src
            Search a phrase in the current frame.
            In order to repeat the last one, type `/` character as arg.
            """
            if not arg or (arg == "/" and not self._latest_search_arg):
                self.error("Search failed: arg is missing")
                return

            if arg == "/":
                arg = self._latest_search_arg
            else:
                self._latest_search_arg = arg

            lines, lineno = self._getsourcelines(self.curframe)
            indexes = [index for index, line in enumerate(lines, lineno) if arg in line]

            if len(indexes) > 0:
                bigger_indexes = [
                    index for index in indexes if index > self.curframe.f_lineno
                ]
                next_line = bigger_indexes[0] if bigger_indexes else indexes[0]
                return super().do_jump(next_line)
            else:
                self.error(f"Search failed: '{arg}' not found")

        do_src = do_search

        def _getsourcelines(self, obj):
            lines, lineno = inspect.getsourcelines(obj)
            lineno = max(1, lineno)
            return lines, lineno

        def get_varstable(self):
            variables = self._get_variables()
            if not variables:
                return
            table = Table(title="List of local variables", box=box.MINIMAL)

            table.add_column("Variable", style="cyan")
            table.add_column("Value", style="magenta")
            table.add_column("Type", style="green")
            [
                table.add_row(variable, value, _type)
                for variable, value, _type in variables
            ]
            return table

        def do_v(self, arg):
            """v(ars)
            List of local variables
            """
            self._print(self.get_varstable(), print_layout=False)

        def get_varstree(self):
            variables = self._get_variables()
            if not variables:
                return
            tree_key = ""
            type_tree = None
            tree = Tree("Variables")

            for variable, value, _type in sorted(
                variables, key=lambda item: (item[2], item[0])
            ):
                if tree_key != _type:
                    if tree_key != "":
                        tree.add(type_tree, style="bold green")
                    type_tree = Tree(_type)
                    tree_key = _type
                type_tree.add(f"{variable}: {value}", style="magenta")
            if type_tree:
                tree.add(type_tree, style="bold green")
            return tree

        def do_varstree(self, arg):
            """varstree | vt
            List of local variables in Rich.Tree
            """
            self._print(self.get_varstree(), print_layout=False)

        do_vt = do_varstree

        def do_inspect(self, arg, all=False):
            """(i)nspect
            Display the data / methods / docs for any Python object.
            """
            try:
                self._print(
                    Inspect(self._getval(arg), methods=True, all=all),
                    print_layout=False,
                )
            except BaseException:
                pass

        def do_inspectall(self, arg):
            """inspectall | ia
            Inspect with all to see all attributes.
            """
            self.do_inspect(arg, all=True)

        do_i = do_inspect
        do_ia = do_inspectall

        def do_pp(self, arg):
            """pp expression
            Rich pretty print.
            """
            try:
                pprint(self._getval(arg), console=self.console)
            except BaseException:
                pass

        def do_syntax(self, arg):
            """syn(tax)[ val,lexer ]
            Display lexer. https://pygments.org/docs/lexers/
            """
            try:
                val, lexer = arg.split(",")
                val = val.strip()
                lexer = lexer.strip()
                val = Syntax(
                    self._getval(val),
                    self._getval(lexer),
                    theme=self._theme or DEFAULT_THEME,
                )
                self._print(val)
            except BaseException:
                pass

        do_syn = do_syntax

        def do_sql(self, arg):
            """sql
            Display value in sql format.
            """
            try:
                import sqlparse

                val = sqlparse.format(
                    self._getval(arg), reindent=True, keyword_case="upper"
                )
                self._print(val)
            except ModuleNotFoundError as error:
                raise type(error)("Install sqlparse to see sql format.") from error

        def displayhook(self, obj):
            if obj is not None:
                self._print(obj if isinstance(obj, (dict, list)) else repr(obj))

        def error(self, msg):
            self._print(msg, prefix="***", style="danger", print_layout=False)

        def _format_stack_entry(self, frame_lineno):
            stack_entry = Pdb.format_stack_entry(self, frame_lineno, "\n")
            return stack_entry.replace(str(Path.cwd().absolute()), "")

        def stack_trace(self):
            stacks = []
            try:
                for frame_lineno in self.stack:
                    frame, _ = frame_lineno
                    if frame is self.curframe:
                        prefix = "-> "
                    else:
                        prefix = "  "

                    stack_entry = self._format_stack_entry(frame_lineno)
                    first_line, _ = stack_entry.splitlines()
                    text_body = Text(stack_entry)
                    text_prefix = Text(prefix)
                    text_body.stylize("bold", len(first_line), len(stack_entry))
                    text_prefix.stylize("bold")
                    stacks.append(Text.assemble(text_prefix, text_body))
            except KeyboardInterrupt:
                pass
            return reversed(stacks)

        def message(self, msg):
            self._print(msg)

        def precmd(self, line):
            if line.endswith("??"):
                line = "pinfo2 " + line[:-2]
            elif line.endswith("?"):
                line = "pinfo " + line[:-1]

            return super().precmd(line)

        def onecmd(self, line: str) -> bool:
            """
            Invokes 'run_magic()' if the line starts with a '%'.
            The loop stops of this function returns True.
            (unless an overridden 'postcmd()' behaves differently)
            """
            try:
                line = line.strip()
                if line.startswith("%"):
                    if line.startswith("%%"):
                        self.error(
                            "Cell magics (multiline) are not yet supported. "
                            "Use a single '%' instead."
                        )
                        return False
                    self.run_magic(line[1:])
                    return False
                return super().onecmd(line)

            except Exception as e:
                self.error(f"{type(e).__qualname__} in onecmd({line!r}): {e}")
                return False

        def _print(self, val, prefix=None, style=None, print_layout=True):
            if val == "--Return--":
                return

            if isinstance(val, str) and ("[0m" in val or "[/" in val):
                val = markup.render(val)

            kwargs = {"style": str(style)} if style else {}
            args = (prefix, val) if prefix else (val,)
            if (
                show_layouts
                and print_layout
                and self.lastcmd not in WITHOUT_LAYOUT_COMMANDS
            ):
                self._print_layout(*args, **kwargs)
            else:
                self.console.print(*args, **kwargs)

        def _print_layout(self, val, **kwargs):
            ConsoleLayout(self.console).print(
                val,
                code=self._get_syntax_for_list(),
                stack_trace=self.stack_trace(**kwargs),
                vars=self.get_varstree(),
                **kwargs,
            )

        def print_stack_entry(self, frame_lineno, prompt_prefix="\n-> ", context=None):
            def print_syntax(*args):
                # Remove color format.
                self._print(
                    Syntax(
                        ANSI_ESCAPE.sub("", self.format_stack_entry(*args)),
                        "python",
                        theme=self._theme or DEFAULT_THEME,
                    ),
                    print_layout=False,
                )

            if is_celery:
                Pdb.print_stack_entry(self, frame_lineno, prompt_prefix)
            elif base == Pdb:
                print_syntax(frame_lineno, prompt_prefix)
            else:
                print_syntax(frame_lineno, "", context)

                # vds: >>
                frame, lineno = frame_lineno
                filename = frame.f_code.co_filename
                self.shell.hooks.synchronize_with_editor(filename, lineno, 0)
                # vds: <<

        def run_magic(self, line) -> str:
            """
            Parses the line and runs the appropriate magic function.
            Assumes that the line is without a leading '%'.
            """
            magic_name, arg, line = self.parseline(line)
            if hasattr(self, f"do_{magic_name}"):
                # We want to use do_{magic_name} methods if defined.
                # This is indeed the case with do_pdef, do_pdoc etc,
                # which are defined by our base class (IPython.core.debugger.Pdb).
                result = getattr(self, f"do_{magic_name}")(arg)
            else:
                magic_fn = self.shell.find_line_magic(magic_name)
                if not magic_fn:
                    self.error(f"Line Magic %{magic_name} not found")
                    return ""
                if magic_name in ("time", "timeit"):
                    result = magic_fn(
                        arg,
                        local_ns={**self.curframe_locals, **self.curframe.f_globals},
                    )
                else:
                    result = magic_fn(arg)
            if result:
                result = str(result)
                self._print(result)
            return ""

    return RichPdb

```

`pdbr/cli.py`:

```py
import sys
from telnetlib import Telnet

from rich.file_proxy import FileProxy

from pdbr.helpers import run_ipython_shell


def shell():
    import getopt

    _, args = getopt.getopt(sys.argv[1:], "mhc:", ["command="])

    if not args:
        run_ipython_shell()
    else:
        from pdbr.__main__ import main

        main()


def telnet():
    from pdbr.__main__ import RichPdb

    pdb_cls = RichPdb()
    if len(sys.argv) < 3:
        pdb_cls.error("Usage : pdbr_telnet hostname port")
        sys.exit()

    class MyTelnet(Telnet):
        def fill_rawq(self):
            """
            exactly the same with Telnet.fill_rawq,
            buffer size is just changed from 50 to 1024.
            """
            if self.irawq >= len(self.rawq):
                self.rawq = b""
                self.irawq = 0
            buf = self.sock.recv(1024)
            self.msg("recv %r", buf)
            self.eof = not buf
            self.rawq = self.rawq + buf

    console = pdb_cls.console
    sys.stdout = FileProxy(console, sys.stdout)
    sys.stderr = FileProxy(console, sys.stderr)
    try:
        host = sys.argv[1]
        port = int(sys.argv[2])
        with MyTelnet(host, port) as tn:
            tn.interact()
    except BaseException as e:
        pdb_cls.error(e)
        sys.exit()

```

`pdbr/helpers.py`:

```py
import sys

from pdbr.__main__ import RichPdb


def run_ipython_shell():
    try:
        from IPython.terminal.interactiveshell import TerminalInteractiveShell
        from IPython.terminal.ipapp import TerminalIPythonApp
        from prompt_toolkit.history import FileHistory
        from traitlets import Type

        TerminalInteractiveShell.simple_prompt = False
    except ModuleNotFoundError as error:
        raise type(error)(
            "In order to use pdbr shell, install IPython with pdbr[ipython]"
        ) from error

    class PdbrTerminalInteractiveShell(TerminalInteractiveShell):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)

            if RichPdb._ipython_history_file:
                self.debugger_history = FileHistory(RichPdb._ipython_history_file)

        @property
        def debugger_cls(self):
            return RichPdb

    class PdbrTerminalIPythonApp(TerminalIPythonApp):
        interactive_shell_class = Type(
            klass=object,  # use default_value otherwise which only allow subclasses.
            default_value=PdbrTerminalInteractiveShell,
            help=(
                "Class to use to instantiate the TerminalInteractiveShell object. "
                "Useful for custom Frontends"
            ),
        ).tag(config=True)

    app = PdbrTerminalIPythonApp.instance()
    app.initialize()
    sys.exit(app.start())

```

`pdbr/middlewares/django.py`:

```py
import sys

from django.conf import settings
from django.core.exceptions import MiddlewareNotUsed

from pdbr.__main__ import post_mortem


class PdbrMiddleware:
    def __init__(self, get_response):
        if not settings.DEBUG:
            raise MiddlewareNotUsed()
        self.get_response = get_response

    def __call__(self, request):
        return self.get_response(request)

    def process_exception(self, request, exception):  # noqa: F841
        post_mortem(sys.exc_info()[2])

```

`pdbr/middlewares/starlette.py`:

```py
from starlette.middleware.errors import ServerErrorMiddleware

from pdbr._cm import apdbr_context


class PdbrMiddleware(ServerErrorMiddleware):
    async def __call__(self, scope, receive, send) -> None:
        async with apdbr_context(suppress_exc=False, debug=self.debug):
            await super().__call__(scope, receive, send)

```

`pdbr/runner.py`:

```py
import unittest

from django.test.runner import DebugSQLTextTestResult, DiscoverRunner

from pdbr.__main__ import RichPdb, post_mortem


class PDBRDebugResult(unittest.TextTestResult):
    _pdbr = RichPdb()

    def addError(self, test, err):
        super().addError(test, err)
        self._print(test, err)

    def addFailure(self, test, err):
        super().addFailure(test, err)
        self._print(test, err)

    def _print(self, test, err):
        self.buffer = False
        self._pdbr.message(f"\n{test}")
        self._pdbr.error("%s: %s", err[0].__name__, err[1])
        post_mortem(err[2])


class PdbrDiscoverRunner(DiscoverRunner):
    def get_resultclass(self):
        if self.debug_sql:
            return DebugSQLTextTestResult
        return PDBRDebugResult

```

`pdbr/utils.py`:

```py
import atexit
import configparser
import os
from pathlib import Path

from pdbr._pdbr import rich_pdb_klass

try:
    import readline
except ImportError:
    try:
        from pyreadline3 import Readline

        readline = Readline()
    except ModuleNotFoundError:
        readline = None
except AttributeError:
    readline = None


def set_history_file(history_file):
    """
    This is just for Pdb,
    For Ipython, look at RichPdb.pt_init
    """
    if readline is None:
        return
    try:
        readline.read_history_file(history_file)
        readline.set_history_length(1000)
    except FileNotFoundError:
        pass
    except OSError:
        pass

    atexit.register(readline.write_history_file, history_file)


def set_traceback(theme):
    from rich.traceback import install

    install(theme=theme)


def read_config():
    style = None
    theme = None
    store_history = ".pdbr_history"
    context = None

    config = configparser.ConfigParser()
    config.sections()

    setup_filename = "setup.cfg"
    xdg_config_home = Path(os.getenv("XDG_CONFIG_HOME", Path.home() / ".config"))
    global_config_path = xdg_config_home / "pdbr" / setup_filename
    cwd_config_path = Path.cwd() / setup_filename
    config_path = cwd_config_path.exists() and cwd_config_path or global_config_path

    config.read(config_path)
    if "pdbr" in config:
        if "style" in config["pdbr"]:
            style = config["pdbr"]["style"]

        if "theme" in config["pdbr"]:
            theme = config["pdbr"]["theme"]

        if "use_traceback" in config["pdbr"]:
            if config["pdbr"]["use_traceback"].lower() == "true":
                set_traceback(theme)
        else:
            set_traceback(theme)

        if "store_history" in config["pdbr"]:
            store_history = config["pdbr"]["store_history"]

        if "context" in config["pdbr"]:
            context = config["pdbr"]["context"]

    history_file = str(Path.home() / store_history)
    set_history_file(history_file)
    ipython_history_file = f"{history_file}_ipython"

    return style, theme, history_file, ipython_history_file, context


def debugger_cls(
    klass=None, console=None, context=None, is_celery=False, show_layouts=True
):
    if klass is None:
        try:
            from IPython.terminal.debugger import TerminalPdb

            klass = TerminalPdb
        except ImportError:
            from pdb import Pdb

            klass = Pdb

    style, theme, history_file, ipython_history_file, context = read_config()
    RichPdb = rich_pdb_klass(
        klass,
        console=console,
        context=context,
        is_celery=is_celery,
        show_layouts=show_layouts,
    )
    RichPdb._style = style
    RichPdb._theme = theme
    RichPdb._history_file = history_file
    RichPdb._ipython_history_file = ipython_history_file

    return RichPdb


def _pdbr_cls(console=None, context=None, return_instance=True, show_layouts=True):
    klass = debugger_cls(console=console, context=context, show_layouts=show_layouts)
    if return_instance:
        return klass()
    return klass


def _rdbr_cls(return_instance=True):
    try:
        from celery.contrib import rdb

        rdb.BANNER = """\
{self.ident}: Type `pdbr_telnet {self.host} {self.port}` to connect

{self.ident}: Waiting for client...
"""
    except ModuleNotFoundError as error:
        raise type(error)("In order to install celery, use pdbr[celery]") from error

    klass = debugger_cls(klass=rdb.Rdb, is_celery=True, show_layouts=False)
    if return_instance:
        return klass()
    return klass

```

`poetry.lock`:

```lock
# This file is automatically @generated by Poetry 1.8.5 and should not be changed by hand.

[[package]]
name = "appnope"
version = "0.1.3"
description = "Disable App Nap on macOS >= 10.9"
optional = true
python-versions = "*"
files = [
    {file = "appnope-0.1.3-py2.py3-none-any.whl", hash = "sha256:265a455292d0bd8a72453494fa24df5a11eb18373a60c7c0430889f22548605e"},
    {file = "appnope-0.1.3.tar.gz", hash = "sha256:02bd91c4de869fbb1e1c50aafc4098827a7a54ab2f39d9dcba6c9547ed920e24"},
]

[[package]]
name = "argcomplete"
version = "1.10.3"
description = "Bash tab completion for argparse"
optional = false
python-versions = "*"
files = [
    {file = "argcomplete-1.10.3-py2.py3-none-any.whl", hash = "sha256:d8ea63ebaec7f59e56e7b2a386b1d1c7f1a7ae87902c9ee17d377eaa557f06fa"},
    {file = "argcomplete-1.10.3.tar.gz", hash = "sha256:a37f522cf3b6a34abddfedb61c4546f60023b3799b22d1cd971eacdc0861530a"},
]

[package.extras]
test = ["coverage", "flake8", "pexpect", "wheel"]

[[package]]
name = "backcall"
version = "0.2.0"
description = "Specifications for callback functions passed in to an API"
optional = true
python-versions = "*"
files = [
    {file = "backcall-0.2.0-py2.py3-none-any.whl", hash = "sha256:fbbce6a29f263178a1f7915c1940bde0ec2b2a967566fe1c65c1dfb7422bd255"},
    {file = "backcall-0.2.0.tar.gz", hash = "sha256:5cbdbf27be5e7cfadb448baf0aa95508f91f2bbc6c6437cd9cd06e2a4c215e1e"},
]

[[package]]
name = "colorama"
version = "0.4.6"
description = "Cross-platform colored terminal text."
optional = false
python-versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,!=3.5.*,!=3.6.*,>=2.7"
files = [
    {file = "colorama-0.4.6-py2.py3-none-any.whl", hash = "sha256:4f1d9991f5acc0ca119f9d443620b77f9d6b33703e51011c16baf57afb285fc6"},
    {file = "colorama-0.4.6.tar.gz", hash = "sha256:08695f5cb7ed6e0531a20572697297273c47b8cae5a63ffc6d6ed5c201be6e44"},
]

[[package]]
name = "colorlog"
version = "6.7.0"
description = "Add colours to the output of Python's logging module."
optional = false
python-versions = ">=3.6"
files = [
    {file = "colorlog-6.7.0-py2.py3-none-any.whl", hash = "sha256:0d33ca236784a1ba3ff9c532d4964126d8a2c44f1f0cb1d2b0728196f512f662"},
    {file = "colorlog-6.7.0.tar.gz", hash = "sha256:bd94bd21c1e13fac7bd3153f4bc3a7dc0eb0974b8bc2fdf1a989e474f6e582e5"},
]

[package.dependencies]
colorama = {version = "*", markers = "sys_platform == \"win32\""}

[package.extras]
development = ["black", "flake8", "mypy", "pytest", "types-colorama"]

[[package]]
name = "decorator"
version = "5.1.1"
description = "Decorators for Humans"
optional = true
python-versions = ">=3.5"
files = [
    {file = "decorator-5.1.1-py3-none-any.whl", hash = "sha256:b8c3f85900b9dc423225913c5aace94729fe1fa9763b38939a95226f02d37186"},
    {file = "decorator-5.1.1.tar.gz", hash = "sha256:637996211036b6385ef91435e4fae22989472f9d571faba8927ba8253acbc330"},
]

[[package]]
name = "distlib"
version = "0.3.7"
description = "Distribution utilities"
optional = false
python-versions = "*"
files = [
    {file = "distlib-0.3.7-py2.py3-none-any.whl", hash = "sha256:2e24928bc811348f0feb63014e97aaae3037f2cf48712d51ae61df7fd6075057"},
    {file = "distlib-0.3.7.tar.gz", hash = "sha256:9dafe54b34a028eafd95039d5e5d4851a13734540f1331060d31c9916e7147a8"},
]

[[package]]
name = "filelock"
version = "3.12.2"
description = "A platform independent file lock."
optional = false
python-versions = ">=3.7"
files = [
    {file = "filelock-3.12.2-py3-none-any.whl", hash = "sha256:cbb791cdea2a72f23da6ac5b5269ab0a0d161e9ef0100e653b69049a7706d1ec"},
    {file = "filelock-3.12.2.tar.gz", hash = "sha256:002740518d8aa59a26b0c76e10fb8c6e15eae825d34b6fdf670333fd7b938d81"},
]

[package.extras]
docs = ["furo (>=2023.5.20)", "sphinx (>=7.0.1)", "sphinx-autodoc-typehints (>=1.23,!=1.23.4)"]
testing = ["covdefaults (>=2.3)", "coverage (>=7.2.7)", "diff-cover (>=7.5)", "pytest (>=7.3.1)", "pytest-cov (>=4.1)", "pytest-mock (>=3.10)", "pytest-timeout (>=2.1)"]

[[package]]
name = "importlib-metadata"
version = "6.7.0"
description = "Read metadata from Python packages"
optional = false
python-versions = ">=3.7"
files = [
    {file = "importlib_metadata-6.7.0-py3-none-any.whl", hash = "sha256:cb52082e659e97afc5dac71e79de97d8681de3aa07ff18578330904a9d18e5b5"},
    {file = "importlib_metadata-6.7.0.tar.gz", hash = "sha256:1aaf550d4f73e5d6783e7acb77aec43d49da8017410afae93822cc9cca98c4d4"},
]

[package.dependencies]
typing-extensions = {version = ">=3.6.4", markers = "python_version < \"3.8\""}
zipp = ">=0.5"

[package.extras]
docs = ["furo", "jaraco.packaging (>=9)", "jaraco.tidelift (>=1.4)", "rst.linker (>=1.9)", "sphinx (>=3.5)", "sphinx-lint"]
perf = ["ipython"]
testing = ["flufl.flake8", "importlib-resources (>=1.3)", "packaging", "pyfakefs", "pytest (>=6)", "pytest-black (>=0.3.7)", "pytest-checkdocs (>=2.4)", "pytest-cov", "pytest-enabler (>=1.3)", "pytest-mypy (>=0.9.1)", "pytest-perf (>=0.9.2)", "pytest-ruff"]

[[package]]
name = "ipython"
version = "7.34.0"
description = "IPython: Productive Interactive Computing"
optional = true
python-versions = ">=3.7"
files = [
    {file = "ipython-7.34.0-py3-none-any.whl", hash = "sha256:c175d2440a1caff76116eb719d40538fbb316e214eda85c5515c303aacbfb23e"},
    {file = "ipython-7.34.0.tar.gz", hash = "sha256:af3bdb46aa292bce5615b1b2ebc76c2080c5f77f54bda2ec72461317273e7cd6"},
]

[package.dependencies]
appnope = {version = "*", markers = "sys_platform == \"darwin\""}
backcall = "*"
colorama = {version = "*", markers = "sys_platform == \"win32\""}
decorator = "*"
jedi = ">=0.16"
matplotlib-inline = "*"
pexpect = {version = ">4.3", markers = "sys_platform != \"win32\""}
pickleshare = "*"
prompt-toolkit = ">=2.0.0,<3.0.0 || >3.0.0,<3.0.1 || >3.0.1,<3.1.0"
pygments = "*"
setuptools = ">=18.5"
traitlets = ">=4.2"

[package.extras]
all = ["Sphinx (>=1.3)", "ipykernel", "ipyparallel", "ipywidgets", "nbconvert", "nbformat", "nose (>=0.10.1)", "notebook", "numpy (>=1.17)", "pygments", "qtconsole", "requests", "testpath"]
doc = ["Sphinx (>=1.3)"]
kernel = ["ipykernel"]
nbconvert = ["nbconvert"]
nbformat = ["nbformat"]
notebook = ["ipywidgets", "notebook"]
parallel = ["ipyparallel"]
qtconsole = ["qtconsole"]
test = ["ipykernel", "nbformat", "nose (>=0.10.1)", "numpy (>=1.17)", "pygments", "requests", "testpath"]

[[package]]
name = "jedi"
version = "0.19.1"
description = "An autocompletion tool for Python that can be used for text editors."
optional = true
python-versions = ">=3.6"
files = [
    {file = "jedi-0.19.1-py2.py3-none-any.whl", hash = "sha256:e983c654fe5c02867aef4cdfce5a2fbb4a50adc0af145f70504238f18ef5e7e0"},
    {file = "jedi-0.19.1.tar.gz", hash = "sha256:cf0496f3651bc65d7174ac1b7d043eff454892c708a87d1b683e57b569927ffd"},
]

[package.dependencies]
parso = ">=0.8.3,<0.9.0"

[package.extras]
docs = ["Jinja2 (==2.11.3)", "MarkupSafe (==1.1.1)", "Pygments (==2.8.1)", "alabaster (==0.7.12)", "babel (==2.9.1)", "chardet (==4.0.0)", "commonmark (==0.8.1)", "docutils (==0.17.1)", "future (==0.18.2)", "idna (==2.10)", "imagesize (==1.2.0)", "mock (==1.0.1)", "packaging (==20.9)", "pyparsing (==2.4.7)", "pytz (==2021.1)", "readthedocs-sphinx-ext (==2.1.4)", "recommonmark (==0.5.0)", "requests (==2.25.1)", "six (==1.15.0)", "snowballstemmer (==2.1.0)", "sphinx (==1.8.5)", "sphinx-rtd-theme (==0.4.3)", "sphinxcontrib-serializinghtml (==1.1.4)", "sphinxcontrib-websupport (==1.2.4)", "urllib3 (==1.26.4)"]
qa = ["flake8 (==5.0.4)", "mypy (==0.971)", "types-setuptools (==67.2.0.1)"]
testing = ["Django", "attrs", "colorama", "docopt", "pytest (<7.0.0)"]

[[package]]
name = "markdown-it-py"
version = "2.2.0"
description = "Python port of markdown-it. Markdown parsing, done right!"
optional = false
python-versions = ">=3.7"
files = [
    {file = "markdown-it-py-2.2.0.tar.gz", hash = "sha256:7c9a5e412688bc771c67432cbfebcdd686c93ce6484913dccf06cb5a0bea35a1"},
    {file = "markdown_it_py-2.2.0-py3-none-any.whl", hash = "sha256:5a35f8d1870171d9acc47b99612dc146129b631baf04970128b568f190d0cc30"},
]

[package.dependencies]
mdurl = ">=0.1,<1.0"
typing_extensions = {version = ">=3.7.4", markers = "python_version < \"3.8\""}

[package.extras]
benchmarking = ["psutil", "pytest", "pytest-benchmark"]
code-style = ["pre-commit (>=3.0,<4.0)"]
compare = ["commonmark (>=0.9,<1.0)", "markdown (>=3.4,<4.0)", "mistletoe (>=1.0,<2.0)", "mistune (>=2.0,<3.0)", "panflute (>=2.3,<3.0)"]
linkify = ["linkify-it-py (>=1,<3)"]
plugins = ["mdit-py-plugins"]
profiling = ["gprof2dot"]
rtd = ["attrs", "myst-parser", "pyyaml", "sphinx", "sphinx-copybutton", "sphinx-design", "sphinx_book_theme"]
testing = ["coverage", "pytest", "pytest-cov", "pytest-regressions"]

[[package]]
name = "matplotlib-inline"
version = "0.1.6"
description = "Inline Matplotlib backend for Jupyter"
optional = true
python-versions = ">=3.5"
files = [
    {file = "matplotlib-inline-0.1.6.tar.gz", hash = "sha256:f887e5f10ba98e8d2b150ddcf4702c1e5f8b3a20005eb0f74bfdbd360ee6f304"},
    {file = "matplotlib_inline-0.1.6-py3-none-any.whl", hash = "sha256:f1f41aab5328aa5aaea9b16d083b128102f8712542f819fe7e6a420ff581b311"},
]

[package.dependencies]
traitlets = "*"

[[package]]
name = "mdurl"
version = "0.1.2"
description = "Markdown URL utilities"
optional = false
python-versions = ">=3.7"
files = [
    {file = "mdurl-0.1.2-py3-none-any.whl", hash = "sha256:84008a41e51615a49fc9966191ff91509e3c40b939176e643fd50a5c2196b8f8"},
    {file = "mdurl-0.1.2.tar.gz", hash = "sha256:bb413d29f5eea38f31dd4754dd7377d4465116fb207585f97bf925588687c1ba"},
]

[[package]]
name = "nox"
version = "2024.4.15"
description = "Flexible test automation."
optional = false
python-versions = ">=3.7"
files = [
    {file = "nox-2024.4.15-py3-none-any.whl", hash = "sha256:6492236efa15a460ecb98e7b67562a28b70da006ab0be164e8821177577c0565"},
    {file = "nox-2024.4.15.tar.gz", hash = "sha256:ecf6700199cdfa9e5ea0a41ff5e6ef4641d09508eda6edb89d9987864115817f"},
]

[package.dependencies]
argcomplete = ">=1.9.4,<4.0"
colorlog = ">=2.6.1,<7.0.0"
importlib-metadata = {version = "*", markers = "python_version < \"3.8\""}
packaging = ">=20.9"
tomli = {version = ">=1", markers = "python_version < \"3.11\""}
typing-extensions = {version = ">=3.7.4", markers = "python_version < \"3.8\""}
virtualenv = ">=20.14.1"

[package.extras]
tox-to-nox = ["jinja2", "tox"]
uv = ["uv (>=0.1.6)"]

[[package]]
name = "packaging"
version = "23.2"
description = "Core utilities for Python packages"
optional = false
python-versions = ">=3.7"
files = [
    {file = "packaging-23.2-py3-none-any.whl", hash = "sha256:8c491190033a9af7e1d931d0b5dacc2ef47509b34dd0de67ed209b5203fc88c7"},
    {file = "packaging-23.2.tar.gz", hash = "sha256:048fb0e9405036518eaaf48a55953c750c11e1a1b68e0dd1a9d62ed0c092cfc5"},
]

[[package]]
name = "parso"
version = "0.8.3"
description = "A Python Parser"
optional = true
python-versions = ">=3.6"
files = [
    {file = "parso-0.8.3-py2.py3-none-any.whl", hash = "sha256:c001d4636cd3aecdaf33cbb40aebb59b094be2a74c556778ef5576c175e19e75"},
    {file = "parso-0.8.3.tar.gz", hash = "sha256:8c07be290bb59f03588915921e29e8a50002acaf2cdc5fa0e0114f91709fafa0"},
]

[package.extras]
qa = ["flake8 (==3.8.3)", "mypy (==0.782)"]
testing = ["docopt", "pytest (<6.0.0)"]

[[package]]
name = "pexpect"
version = "4.8.0"
description = "Pexpect allows easy control of interactive console applications."
optional = true
python-versions = "*"
files = [
    {file = "pexpect-4.8.0-py2.py3-none-any.whl", hash = "sha256:0b48a55dcb3c05f3329815901ea4fc1537514d6ba867a152b581d69ae3710937"},
    {file = "pexpect-4.8.0.tar.gz", hash = "sha256:fc65a43959d153d0114afe13997d439c22823a27cefceb5ff35c2178c6784c0c"},
]

[package.dependencies]
ptyprocess = ">=0.5"

[[package]]
name = "pickleshare"
version = "0.7.5"
description = "Tiny 'shelve'-like database with concurrency support"
optional = true
python-versions = "*"
files = [
    {file = "pickleshare-0.7.5-py2.py3-none-any.whl", hash = "sha256:9649af414d74d4df115d5d718f82acb59c9d418196b7b4290ed47a12ce62df56"},
    {file = "pickleshare-0.7.5.tar.gz", hash = "sha256:87683d47965c1da65cdacaf31c8441d12b8044cdec9aca500cd78fc2c683afca"},
]

[[package]]
name = "platformdirs"
version = "3.11.0"
description = "A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\"."
optional = false
python-versions = ">=3.7"
files = [
    {file = "platformdirs-3.11.0-py3-none-any.whl", hash = "sha256:e9d171d00af68be50e9202731309c4e658fd8bc76f55c11c7dd760d023bda68e"},
    {file = "platformdirs-3.11.0.tar.gz", hash = "sha256:cf8ee52a3afdb965072dcc652433e0c7e3e40cf5ea1477cd4b3b1d2eb75495b3"},
]

[package.dependencies]
typing-extensions = {version = ">=4.7.1", markers = "python_version < \"3.8\""}

[package.extras]
docs = ["furo (>=2023.7.26)", "proselint (>=0.13)", "sphinx (>=7.1.1)", "sphinx-autodoc-typehints (>=1.24)"]
test = ["appdirs (==1.4.4)", "covdefaults (>=2.3)", "pytest (>=7.4)", "pytest-cov (>=4.1)", "pytest-mock (>=3.11.1)"]

[[package]]
name = "prompt-toolkit"
version = "3.0.39"
description = "Library for building powerful interactive command lines in Python"
optional = true
python-versions = ">=3.7.0"
files = [
    {file = "prompt_toolkit-3.0.39-py3-none-any.whl", hash = "sha256:9dffbe1d8acf91e3de75f3b544e4842382fc06c6babe903ac9acb74dc6e08d88"},
    {file = "prompt_toolkit-3.0.39.tar.gz", hash = "sha256:04505ade687dc26dc4284b1ad19a83be2f2afe83e7a828ace0c72f3a1df72aac"},
]

[package.dependencies]
wcwidth = "*"

[[package]]
name = "ptyprocess"
version = "0.7.0"
description = "Run a subprocess in a pseudo terminal"
optional = true
python-versions = "*"
files = [
    {file = "ptyprocess-0.7.0-py2.py3-none-any.whl", hash = "sha256:4b41f3967fce3af57cc7e94b888626c18bf37a083e3651ca8feeb66d492fef35"},
    {file = "ptyprocess-0.7.0.tar.gz", hash = "sha256:5c5d0a3b48ceee0b48485e0c26037c0acd7d29765ca3fbb5cb3831d347423220"},
]

[[package]]
name = "pygments"
version = "2.16.1"
description = "Pygments is a syntax highlighting package written in Python."
optional = false
python-versions = ">=3.7"
files = [
    {file = "Pygments-2.16.1-py3-none-any.whl", hash = "sha256:13fc09fa63bc8d8671a6d247e1eb303c4b343eaee81d861f3404db2935653692"},
    {file = "Pygments-2.16.1.tar.gz", hash = "sha256:1daff0494820c69bc8941e407aa20f577374ee88364ee10a98fdbe0aece96e29"},
]

[package.extras]
plugins = ["importlib-metadata"]

[[package]]
name = "pyreadline3"
version = "3.4.1"
description = "A python implementation of GNU readline."
optional = false
python-versions = "*"
files = [
    {file = "pyreadline3-3.4.1-py3-none-any.whl", hash = "sha256:b0efb6516fd4fb07b45949053826a62fa4cb353db5be2bbb4a7aa1fdd1e345fb"},
    {file = "pyreadline3-3.4.1.tar.gz", hash = "sha256:6f3d1f7b8a31ba32b73917cefc1f28cc660562f39aea8646d30bd6eff21f7bae"},
]

[[package]]
name = "rich"
version = "13.6.0"
description = "Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal"
optional = false
python-versions = ">=3.7.0"
files = [
    {file = "rich-13.6.0-py3-none-any.whl", hash = "sha256:2b38e2fe9ca72c9a00170a1a2d20c63c790d0e10ef1fe35eba76e1e7b1d7d245"},
    {file = "rich-13.6.0.tar.gz", hash = "sha256:5c14d22737e6d5084ef4771b62d5d4363165b403455a30a1c8ca39dc7b644bef"},
]

[package.dependencies]
markdown-it-py = ">=2.2.0"
pygments = ">=2.13.0,<3.0.0"
typing-extensions = {version = ">=4.0.0,<5.0", markers = "python_version < \"3.9\""}

[package.extras]
jupyter = ["ipywidgets (>=7.5.1,<9)"]

[[package]]
name = "ruff"
version = "0.6.5"
description = "An extremely fast Python linter and code formatter, written in Rust."
optional = false
python-versions = ">=3.7"
files = [
    {file = "ruff-0.6.5-py3-none-linux_armv6l.whl", hash = "sha256:7e4e308f16e07c95fc7753fc1aaac690a323b2bb9f4ec5e844a97bb7fbebd748"},
    {file = "ruff-0.6.5-py3-none-macosx_10_12_x86_64.whl", hash = "sha256:932cd69eefe4daf8c7d92bd6689f7e8182571cb934ea720af218929da7bd7d69"},
    {file = "ruff-0.6.5-py3-none-macosx_11_0_arm64.whl", hash = "sha256:3a8d42d11fff8d3143ff4da41742a98f8f233bf8890e9fe23077826818f8d680"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_aarch64.manylinux2014_aarch64.whl", hash = "sha256:a50af6e828ee692fb10ff2dfe53f05caecf077f4210fae9677e06a808275754f"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_armv7l.manylinux2014_armv7l.whl", hash = "sha256:794ada3400a0d0b89e3015f1a7e01f4c97320ac665b7bc3ade24b50b54cb2972"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_i686.manylinux2014_i686.whl", hash = "sha256:381413ec47f71ce1d1c614f7779d88886f406f1fd53d289c77e4e533dc6ea200"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_ppc64.manylinux2014_ppc64.whl", hash = "sha256:52e75a82bbc9b42e63c08d22ad0ac525117e72aee9729a069d7c4f235fc4d276"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_ppc64le.manylinux2014_ppc64le.whl", hash = "sha256:09c72a833fd3551135ceddcba5ebdb68ff89225d30758027280968c9acdc7810"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_s390x.manylinux2014_s390x.whl", hash = "sha256:800c50371bdcb99b3c1551d5691e14d16d6f07063a518770254227f7f6e8c178"},
    {file = "ruff-0.6.5-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl", hash = "sha256:8e25ddd9cd63ba1f3bd51c1f09903904a6adf8429df34f17d728a8fa11174253"},
    {file = "ruff-0.6.5-py3-none-musllinux_1_2_aarch64.whl", hash = "sha256:7291e64d7129f24d1b0c947ec3ec4c0076e958d1475c61202497c6aced35dd19"},
    {file = "ruff-0.6.5-py3-none-musllinux_1_2_armv7l.whl", hash = "sha256:9ad7dfbd138d09d9a7e6931e6a7e797651ce29becd688be8a0d4d5f8177b4b0c"},
    {file = "ruff-0.6.5-py3-none-musllinux_1_2_i686.whl", hash = "sha256:005256d977021790cc52aa23d78f06bb5090dc0bfbd42de46d49c201533982ae"},
    {file = "ruff-0.6.5-py3-none-musllinux_1_2_x86_64.whl", hash = "sha256:482c1e6bfeb615eafc5899127b805d28e387bd87db38b2c0c41d271f5e58d8cc"},
    {file = "ruff-0.6.5-py3-none-win32.whl", hash = "sha256:cf4d3fa53644137f6a4a27a2b397381d16454a1566ae5335855c187fbf67e4f5"},
    {file = "ruff-0.6.5-py3-none-win_amd64.whl", hash = "sha256:3e42a57b58e3612051a636bc1ac4e6b838679530235520e8f095f7c44f706ff9"},
    {file = "ruff-0.6.5-py3-none-win_arm64.whl", hash = "sha256:51935067740773afdf97493ba9b8231279e9beef0f2a8079188c4776c25688e0"},
    {file = "ruff-0.6.5.tar.gz", hash = "sha256:4d32d87fab433c0cf285c3683dd4dae63be05fd7a1d65b3f5bf7cdd05a6b96fb"},
]

[[package]]
name = "setuptools"
version = "68.0.0"
description = "Easily download, build, install, upgrade, and uninstall Python packages"
optional = true
python-versions = ">=3.7"
files = [
    {file = "setuptools-68.0.0-py3-none-any.whl", hash = "sha256:11e52c67415a381d10d6b462ced9cfb97066179f0e871399e006c4ab101fc85f"},
    {file = "setuptools-68.0.0.tar.gz", hash = "sha256:baf1fdb41c6da4cd2eae722e135500da913332ab3f2f5c7d33af9b492acb5235"},
]

[package.extras]
docs = ["furo", "jaraco.packaging (>=9)", "jaraco.tidelift (>=1.4)", "pygments-github-lexers (==0.0.5)", "rst.linker (>=1.9)", "sphinx (>=3.5)", "sphinx-favicon", "sphinx-hoverxref (<2)", "sphinx-inline-tabs", "sphinx-lint", "sphinx-notfound-page (==0.8.3)", "sphinx-reredirects", "sphinxcontrib-towncrier"]
testing = ["build[virtualenv]", "filelock (>=3.4.0)", "flake8-2020", "ini2toml[lite] (>=0.9)", "jaraco.envs (>=2.2)", "jaraco.path (>=3.2.0)", "pip (>=19.1)", "pip-run (>=8.8)", "pytest (>=6)", "pytest-black (>=0.3.7)", "pytest-checkdocs (>=2.4)", "pytest-cov", "pytest-enabler (>=1.3)", "pytest-mypy (>=0.9.1)", "pytest-perf", "pytest-ruff", "pytest-timeout", "pytest-xdist", "tomli-w (>=1.0.0)", "virtualenv (>=13.0.0)", "wheel"]
testing-integration = ["build[virtualenv]", "filelock (>=3.4.0)", "jaraco.envs (>=2.2)", "jaraco.path (>=3.2.0)", "pytest", "pytest-enabler", "pytest-xdist", "tomli", "virtualenv (>=13.0.0)", "wheel"]

[[package]]
name = "tomli"
version = "2.0.1"
description = "A lil' TOML parser"
optional = false
python-versions = ">=3.7"
files = [
    {file = "tomli-2.0.1-py3-none-any.whl", hash = "sha256:939de3e7a6161af0c887ef91b7d41a53e7c5a1ca976325f429cb46ea9bc30ecc"},
    {file = "tomli-2.0.1.tar.gz", hash = "sha256:de526c12914f0c550d15924c62d72abc48d6fe7364aa87328337a31007fe8a4f"},
]

[[package]]
name = "traitlets"
version = "5.9.0"
description = "Traitlets Python configuration system"
optional = true
python-versions = ">=3.7"
files = [
    {file = "traitlets-5.9.0-py3-none-any.whl", hash = "sha256:9e6ec080259b9a5940c797d58b613b5e31441c2257b87c2e795c5228ae80d2d8"},
    {file = "traitlets-5.9.0.tar.gz", hash = "sha256:f6cde21a9c68cf756af02035f72d5a723bf607e862e7be33ece505abf4a3bad9"},
]

[package.extras]
docs = ["myst-parser", "pydata-sphinx-theme", "sphinx"]
test = ["argcomplete (>=2.0)", "pre-commit", "pytest", "pytest-mock"]

[[package]]
name = "typing-extensions"
version = "4.7.1"
description = "Backported and Experimental Type Hints for Python 3.7+"
optional = false
python-versions = ">=3.7"
files = [
    {file = "typing_extensions-4.7.1-py3-none-any.whl", hash = "sha256:440d5dd3af93b060174bf433bccd69b0babc3b15b1a8dca43789fd7f61514b36"},
    {file = "typing_extensions-4.7.1.tar.gz", hash = "sha256:b75ddc264f0ba5615db7ba217daeb99701ad295353c45f9e95963337ceeeffb2"},
]

[[package]]
name = "virtualenv"
version = "20.26.6"
description = "Virtual Python Environment builder"
optional = false
python-versions = ">=3.7"
files = [
    {file = "virtualenv-20.26.6-py3-none-any.whl", hash = "sha256:7345cc5b25405607a624d8418154577459c3e0277f5466dd79c49d5e492995f2"},
    {file = "virtualenv-20.26.6.tar.gz", hash = "sha256:280aede09a2a5c317e409a00102e7077c6432c5a38f0ef938e643805a7ad2c48"},
]

[package.dependencies]
distlib = ">=0.3.7,<1"
filelock = ">=3.12.2,<4"
importlib-metadata = {version = ">=6.6", markers = "python_version < \"3.8\""}
platformdirs = ">=3.9.1,<5"

[package.extras]
docs = ["furo (>=2023.7.26)", "proselint (>=0.13)", "sphinx (>=7.1.2,!=7.3)", "sphinx-argparse (>=0.4)", "sphinxcontrib-towncrier (>=0.2.1a0)", "towncrier (>=23.6)"]
test = ["covdefaults (>=2.3)", "coverage (>=7.2.7)", "coverage-enable-subprocess (>=1)", "flaky (>=3.7)", "packaging (>=23.1)", "pytest (>=7.4)", "pytest-env (>=0.8.2)", "pytest-freezer (>=0.4.8)", "pytest-mock (>=3.11.1)", "pytest-randomly (>=3.12)", "pytest-timeout (>=2.1)", "setuptools (>=68)", "time-machine (>=2.10)"]

[[package]]
name = "wcwidth"
version = "0.2.8"
description = "Measures the displayed width of unicode strings in a terminal"
optional = true
python-versions = "*"
files = [
    {file = "wcwidth-0.2.8-py2.py3-none-any.whl", hash = "sha256:77f719e01648ed600dfa5402c347481c0992263b81a027344f3e1ba25493a704"},
    {file = "wcwidth-0.2.8.tar.gz", hash = "sha256:8705c569999ffbb4f6a87c6d1b80f324bd6db952f5eb0b95bc07517f4c1813d4"},
]

[[package]]
name = "zipp"
version = "3.15.0"
description = "Backport of pathlib-compatible object wrapper for zip files"
optional = false
python-versions = ">=3.7"
files = [
    {file = "zipp-3.15.0-py3-none-any.whl", hash = "sha256:48904fc76a60e542af151aded95726c1a5c34ed43ab4134b597665c86d7ad556"},
    {file = "zipp-3.15.0.tar.gz", hash = "sha256:112929ad649da941c23de50f356a2b5570c954b65150642bccdd66bf194d224b"},
]

[package.extras]
docs = ["furo", "jaraco.packaging (>=9)", "jaraco.tidelift (>=1.4)", "rst.linker (>=1.9)", "sphinx (>=3.5)", "sphinx-lint"]
testing = ["big-O", "flake8 (<5)", "jaraco.functools", "jaraco.itertools", "more-itertools", "pytest (>=6)", "pytest-black (>=0.3.7)", "pytest-checkdocs (>=2.4)", "pytest-cov", "pytest-enabler (>=1.3)", "pytest-flake8", "pytest-mypy (>=0.9.1)"]

[extras]
ipython = ["ipython"]

[metadata]
lock-version = "2.0"
python-versions = "^3.7.9"
content-hash = "aea003781ed7a7f294bc338647247121603041d48c775a6dfd91cefe3b706ae5"

```

`pyproject.toml`:

```toml
[tool.poetry]
name = "pdbr"
version = "0.9.0"
description = "Pdb with Rich library."
authors = ["Can Sarigol <ertugrulsarigol@gmail.com>"]
packages = [
    { include = "pdbr" }
]
readme = "README.md"
homepage = "https://github.com/cansarigol/pdbr"
repository = "https://github.com/cansarigol/pdbr"
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: MacOS",
    "Operating System :: POSIX :: Linux",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
]

[tool.poetry.dependencies]
python = "^3.7.9"
rich = "*"
ipython = {version = "*", optional = true}
pyreadline3 = {version = "^3.4.1", markers = "sys_platform == 'win32'"}

[tool.poetry.extras]
ipython = ["ipython"]

[tool.poetry.scripts]
pdbr = 'pdbr.cli:shell'
pdbr_telnet = 'pdbr.cli:telnet'

[tool.poetry.group.dev.dependencies]
ruff = "^0.6.5"
nox = "^2024.4.15"

[build-system]
requires = ["poetry>=1.0.0", "setuptools"]
build-backend = "poetry.masonry.api"

[tool.vulture]
make_whitelist = true
min_confidence = 80
paths = ["pdbr", "tests"]
sort_by_size = true
verbose = false

[project]
name = "pdbr"
version = "0.9.0"

[tool.setuptools]
py-modules = []

[tool.ruff]
line-length = 88

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "PIE", # flake8-pie
    "ERA", # eradicate
]

```

`runtests.py`:

```py
import os
import sys

import django
from django.conf import settings
from django.test.utils import get_runner

if __name__ == "__main__":
    os.environ["DJANGO_SETTINGS_MODULE"] = "tests.tests_django.test_settings"
    django.setup()
    TestRunner = get_runner(settings)
    test_runner = TestRunner()
    failures = test_runner.run_tests(["tests"])
    sys.exit(bool(failures))

```

`scripts/lint`:

```
#!/bin/sh -e

export SOURCE_FILES="pdbr tests noxfile.py"

ruff check $SOURCE_FILES --fix
black $SOURCE_FILES

```

`scripts/test`:

```
#!/bin/sh -e
pre-commit run --all-files

poetry run nox --sessions test django_test

```

`setup.cfg`:

```cfg
[tool:pytest]
addopts = --capture=no --disable-warnings

[pdbr]
use_traceback= True
style=dim
store_history=.pdbr_history

```

`tests/conftest.py`:

```py
"""
Add '--skip-slow' cmdline option to skip tests that are marked with @pytest.mark.slow.
"""

import pytest


def pytest_addoption(parser):
    parser.addoption(
        "--skip-slow", action="store_true", default=False, help="Skip slow tests"
    )


def pytest_collection_modifyitems(config, items):
    if not config.getoption("--skip-slow"):
        return
    skip_slow = pytest.mark.skip(reason="Specified --skip-slow")
    for item in items:
        if "slow" in item.keywords:
            item.add_marker(skip_slow)

```

`tests/test_api.py`:

```py
import pdbr


def test_api_attr():
    assert pdbr.__all__ == [
        "set_trace",
        "run",
        "pm",
        "post_mortem",
        "celery_set_trace",
        "RichPdb",
        "pdbr_context",
        "apdbr_context",
    ]

```

`tests/test_config.py`:

```py
import os
from pathlib import Path
from tempfile import TemporaryDirectory

import pytest

from pdbr.utils import read_config

root_dir = Path(__file__).parents[1]


@pytest.fixture
def dummy_global_config():
    XDG_CONFIG_HOME = Path.home() / ".config"
    pdbr_dir = XDG_CONFIG_HOME / "pdbr"
    pdbr_dir.mkdir(exist_ok=True, parents=True)
    setup_file = pdbr_dir / "setup.cfg"
    backup_file = pdbr_dir / (setup_file.stem + ".cfg.bak")

    if setup_file.exists():
        setup_file.rename(backup_file)

    with open(setup_file, "wt") as f:
        f.writelines(["[pdbr]\n", "theme = ansi_light"])

    yield setup_file

    setup_file.unlink()

    if backup_file.exists():
        backup_file.rename(setup_file)


def test_global_config(dummy_global_config):
    assert dummy_global_config.exists()

    tmpdir = TemporaryDirectory()
    os.chdir(tmpdir.name)

    # Second element of tuple is theme
    assert read_config()[1] == "ansi_light"
    os.chdir(root_dir)


def test_local_config():
    tmpdir = TemporaryDirectory()
    os.chdir(tmpdir.name)
    setup_file = Path(tmpdir.name) / "setup.cfg"

    with open(setup_file, "wt") as f:
        f.writelines(["[pdbr]\n", "theme = ansi_dark"])

    assert read_config()[1] == "ansi_dark"
    os.chdir(root_dir)


def test_read_config():
    pdbr_history = str(Path.home() / ".pdbr_history")
    pdbr_history_ipython = str(Path.home() / ".pdbr_history_ipython")

    assert read_config() == (
        "dim",
        None,
        pdbr_history,
        pdbr_history_ipython,
    )

```

`tests/test_magic.py`:

```py
import inspect
import re
import sys
from pathlib import Path

import pytest
from rich.console import Console
from rich.theme import Theme

from pdbr._pdbr import rich_pdb_klass

NUMBER_RE = r"[\d.e+_,-]+"  # Matches 1e+03, 1.0e-03, 1_000, 1,000

TAG_RE = re.compile(r"\x1b[\[\]]+[\dDClhJt;?]+m?")


def untag(s):
    """Not perfect, but does the job.
    >>> untag('\x1b[0mfoo\x1b[0m\x1b[0;34m(\x1b[0m\x1b[0marg\x1b[0m\x1b[0;34m)\x1b[0m'
    >>>       '\x1b[0;34m\x1b[0m\x1b[0;34m\x1b[0m\x1b[0m')
    'foo(arg)'
    """
    s = s.replace("\x07", "")
    s = s.replace("\x1b[?2004l", "")
    return TAG_RE.sub("", s)


def unquote(s):
    """
    >>> unquote('"foo"')
    'foo'
    >>> unquote('"foo"bar')
    '"foo"bar'
    """
    for quote in ('"', "'"):
        if s.startswith(quote) and s.endswith(quote):
            return s[1:-1]
    return s


TMP_FILE_CONTENT = '''def foo(arg):
    """Foo docstring"""
    pass
    '''


def import_tmp_file(rpdb, tmp_path: Path, file_content=TMP_FILE_CONTENT) -> Path:
    """Creates a temporary file, writes `file_content` to it and makes pdbr import it"""
    tmp_file = tmp_path / "foo.py"
    tmp_file.write_text(file_content)

    rpdb.onecmd(f'import sys; sys.path.append("{tmp_file.parent.absolute()}")')
    rpdb.onecmd(f"from {tmp_file.stem} import foo")
    return tmp_file


@pytest.fixture
def pdbr_child_process(tmp_path):
    """
    Spawn a pdbr prompt in a child process.
    """
    from pexpect import spawn

    file = tmp_path / "foo.py"
    file.write_text("import pdbr;breakpoint()")

    child = spawn(
        str(Path(sys.executable)),
        [str(file)],
        encoding="utf-8",
    )
    child.expect("breakpoint")
    child.timeout = 10
    return child


@pytest.fixture
def RichIPdb():
    """
    In contrast to the normal RichPdb in test_pdbr.py which inherits from
    built-in pdb.Pdb, this one inherits from IPython's TerminalPdb, which holds
    a 'shell' attribute that is a IPython TerminalInteractiveShell.
    This is required for the magic commands to work (and happens automatically
    when the user runs pdbr when IPython is importable).
    """
    from IPython.terminal.debugger import TerminalPdb

    currentframe = inspect.currentframe()

    def rich_ipdb_klass(*args, **kwargs):
        ripdb = rich_pdb_klass(TerminalPdb, show_layouts=False)(*args, **kwargs)
        # Set frame and stack related self-attributes
        ripdb.botframe = currentframe.f_back
        ripdb.setup(currentframe.f_back, None)
        # Set the console's file to stdout so that we can capture the output
        _console = Console(
            file=kwargs.get("stdout", sys.stdout),
            theme=Theme(
                {"info": "dim cyan", "warning": "magenta", "danger": "bold red"}
            ),
        )
        ripdb._console = _console
        return ripdb

    return rich_ipdb_klass


@pytest.mark.skipif(sys.platform.startswith("win"), reason="pexpect")
@pytest.mark.slow
class TestPdbrChildProcess:
    def test_time(self, pdbr_child_process):
        pdbr_child_process.sendline("from time import sleep")
        pdbr_child_process.sendline("%time sleep(0.1)")
        pdbr_child_process.expect(re.compile("CPU times: .+"))
        pdbr_child_process.expect("Wall time: .+")

    def test_timeit(self, pdbr_child_process):
        pdbr_child_process.sendline("%timeit -n 1 -r 1 pass")
        pdbr_child_process.expect_exact("std. dev. of 1 run, 1 loop each)")


@pytest.mark.skipif(sys.platform.startswith("win"), reason="pexpect")
class TestPdbrMagic:
    def test_onecmd_time_line_magic(self, capsys, RichIPdb):
        RichIPdb().onecmd("%time pass")
        captured = capsys.readouterr()
        output = captured.out
        assert re.search(
            f"CPU times: user {NUMBER_RE} [mµn]s, "
            f"sys: {NUMBER_RE} [mµn]s, "
            f"total: {NUMBER_RE} [mµn]s\n"
            f"Wall time: {NUMBER_RE} [mµn]s",
            output,
        )

    def test_onecmd_unsupported_cell_magic(self, capsys, RichIPdb):
        RichIPdb().onecmd("%%time pass")
        captured = capsys.readouterr()
        output = captured.out
        error = (
            "Cell magics (multiline) are not yet supported. Use a single '%' instead."
        )
        assert output == "*** " + error + "\n"
        cmd = "%%time"
        stop = RichIPdb().onecmd(cmd)
        captured_output = capsys.readouterr().out
        assert not stop
        RichIPdb().error(error)
        cell_magics_error = capsys.readouterr().out
        assert cell_magics_error == captured_output

    def test_onecmd_lsmagic_line_magic(self, capsys, RichIPdb):
        RichIPdb().onecmd("%lsmagic")
        captured = capsys.readouterr()
        output = captured.out

        assert re.search(
            "Available line magics:\n%alias +%alias_magic +%autoawait.*%%writefile",
            output,
            re.DOTALL,
        )

    def test_no_zombie_lastcmd(self, capsys, RichIPdb):
        rpdb = RichIPdb(stdout=sys.stdout)
        rpdb.onecmd("print('SHOULD_NOT_BE_IN_%pwd_OUTPUT')")
        captured = capsys.readouterr()
        assert captured.out.endswith(
            "SHOULD_NOT_BE_IN_%pwd_OUTPUT\n"
        )  # Starts with colors and prompt
        rpdb.onecmd("%pwd")
        captured = capsys.readouterr()
        assert captured.out.endswith(Path.cwd().absolute().as_posix() + "\n")
        assert "SHOULD_NOT_BE_IN_%pwd_OUTPUT" not in captured.out

    def test_IPython_Pdb_magics_implementation(self, tmp_path, capsys, RichIPdb):
        """
        We test do_{magic} methods that are concretely implemented by
        IPython.core.debugger.Pdb, and don't default to IPython's
        'InteractiveShell.run_line_magic()' like the other magics.
        """
        from IPython.utils.text import dedent

        rpdb = RichIPdb(stdout=sys.stdout)
        tmp_file = import_tmp_file(rpdb, tmp_path)

        # pdef
        rpdb.do_pdef("foo")
        do_pdef_foo_output = capsys.readouterr().out
        untagged = untag(do_pdef_foo_output).strip()
        assert untagged.endswith("foo(arg)"), untagged
        rpdb.onecmd("%pdef foo")
        magic_pdef_foo_output = capsys.readouterr().out
        untagged = untag(magic_pdef_foo_output).strip()
        assert untagged.endswith("foo(arg)"), untagged

        # pdoc
        rpdb.onecmd("%pdoc foo")
        magic_pdef_foo_output = capsys.readouterr().out
        untagged = untag(magic_pdef_foo_output).strip()
        expected_docstring = dedent(
            """Class docstring:
            Foo docstring
        Call docstring:
            Call self as a function."""
        )
        assert untagged == expected_docstring, untagged

        # pfile
        rpdb.onecmd("%pfile foo")
        magic_pfile_foo_output = capsys.readouterr().out
        untagged = untag(magic_pfile_foo_output).strip()
        tmp_file_content = Path(tmp_file).read_text().strip()
        assert untagged == tmp_file_content

        # pinfo
        rpdb.onecmd("%pinfo foo")
        magic_pinfo_foo_output = capsys.readouterr().out
        untagged = untag(magic_pinfo_foo_output).strip()
        expected_pinfo = dedent(
            f"""Signature: foo(arg)
        Docstring: Foo docstring
        File:      {tmp_file.absolute()}
        Type:      function"""
        )
        assert untagged == expected_pinfo, untagged

        # pinfo2
        rpdb.onecmd("%pinfo2 foo")
        magic_pinfo2_foo_output = capsys.readouterr().out
        untagged = untag(magic_pinfo2_foo_output).strip()
        expected_pinfo2 = re.compile(
            dedent(
                rf"""Signature: foo\(arg\)
        Source:\s*
        %s
        File:      {tmp_file.absolute()}
        Type:      function"""
            )
            % re.escape(tmp_file_content)
        )
        assert expected_pinfo2.fullmatch(untagged), untagged

        # psource
        rpdb.onecmd("%psource foo")
        magic_psource_foo_output = capsys.readouterr().out
        untagged = untag(magic_psource_foo_output).strip()
        expected_psource = 'def foo(arg):\n    """Foo docstring"""\n    pass'
        assert untagged == expected_psource, untagged

    def test_expr_questionmark_pinfo(self, tmp_path, capsys, RichIPdb):
        from IPython.utils.text import dedent

        rpdb = RichIPdb(stdout=sys.stdout)
        tmp_file = import_tmp_file(rpdb, tmp_path)
        # pinfo
        rpdb.onecmd(rpdb.precmd("foo?"))
        magic_foo_qmark_output = capsys.readouterr().out
        untagged = untag(magic_foo_qmark_output).strip()

        expected_pinfo_path = (
            f"/private/var/folders/.*/{tmp_file.name}"
            if sys.platform == "darwin"
            else f"/tmp/.*/{tmp_file.name}"
        )
        expected_pinfo = re.compile(
            dedent(
                rf""".*Signature: foo\(arg\)
        Docstring: Foo docstring
        File:      {expected_pinfo_path}
        Type:      function"""
            )
        )
        assert expected_pinfo.fullmatch(untagged), f"untagged = {untagged!r}"

        # pinfo2
        rpdb.onecmd(rpdb.precmd("foo??"))
        magic_foo_qmark2_output = capsys.readouterr().out
        rpdb.onecmd(rpdb.precmd("%pinfo2 foo"))
        magic_pinfo2_foo_output = capsys.readouterr().out
        assert magic_pinfo2_foo_output == magic_foo_qmark2_output

    def test_filesystem_magics(self, capsys, RichIPdb):
        cwd = Path.cwd().absolute().as_posix()
        rpdb = RichIPdb(stdout=sys.stdout)
        rpdb.onecmd("%pwd")
        pwd_output = capsys.readouterr().out.strip()
        assert pwd_output == cwd
        rpdb.onecmd("import os; os.getcwd()")
        pwd_output = unquote(capsys.readouterr().out.strip())
        assert pwd_output == cwd

        new_dir = str(Path.cwd().absolute().parent)
        rpdb.onecmd(f"%cd {new_dir}")
        cd_output = untag(capsys.readouterr().out.strip())
        assert cd_output.endswith(new_dir)
        rpdb.onecmd("%pwd")
        pwd_output = capsys.readouterr().out.strip()
        assert pwd_output == new_dir
        rpdb.onecmd("import os; os.getcwd()")
        pwd_output = unquote(capsys.readouterr().out.strip())
        assert pwd_output == new_dir

```

`tests/test_pdbr.py`:

```py
import inspect
import pdb

import pytest

from pdbr._pdbr import rich_pdb_klass


@pytest.fixture
def RichPdb(*args, **kwargs):
    currentframe = inspect.currentframe()

    def wrapper():
        rpdb = rich_pdb_klass(pdb.Pdb, show_layouts=False)(*args, **kwargs)
        # Set frame and stack related self-attributes
        rpdb.botframe = currentframe.f_back
        rpdb.setup(currentframe.f_back, None)
        return rpdb

    return wrapper


def test_prompt(RichPdb):
    assert RichPdb().prompt == "(Pdbr) "


def test_print(capsys, RichPdb):
    RichPdb()._print("msg")
    captured = capsys.readouterr()
    assert captured.out == "msg\n"


def test_print_error(capsys, RichPdb):
    RichPdb().error("error")
    captured = capsys.readouterr()
    assert captured.out == "\x1b[1;31m*** error\x1b[0m\n"


def test_print_with_style(capsys, RichPdb):
    RichPdb()._print("msg", style="yellow")
    captured = capsys.readouterr()
    assert captured.out == "\x1b[33mmsg\x1b[0m\n"


def test_print_without_escape_tag(capsys, RichPdb):
    RichPdb()._print("[blue]msg[/]")
    captured = capsys.readouterr()
    assert captured.out == "\x1b[34mmsg\x1b[0m\n"


def test_print_array(capsys, RichPdb):
    RichPdb()._print("[[8]]")
    captured = capsys.readouterr()
    assert (
        captured.out == "\x1b[1m[\x1b[0m\x1b[1m[\x1b[0m\x1b[1;36m8"
        "\x1b[0m\x1b[1m]\x1b[0m\x1b[1m]\x1b[0m\n"
    )


def test_onecmd(capsys, RichPdb):
    rpdb = RichPdb()
    cmd = 'print("msg")'
    stop = rpdb.onecmd(cmd)
    captured = capsys.readouterr()
    assert not stop
    assert captured.out == "msg\n"

```

`tests/tests_django/test_settings.py`:

```py
from pathlib import Path

BASE_DIR = Path(__file__).absolute().parents[1]

SECRET_KEY = "fake-key"
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": str(BASE_DIR / "db.sqlite3"),
    }
}

INSTALLED_APPS = ("tests.tests_django",)

TEST_RUNNER = "pdbr.runner.PdbrDiscoverRunner"

ROOT_URLCONF = "tests.tests_django.urls"

MIDDLEWARE = ["pdbr.middlewares.django.PdbrMiddleware"]

```

`tests/tests_django/tests.py`:

```py
from django.test import TestCase


class DjangoTest(TestCase):
    def test_runner(self):
        self.assertEqual("foo", "foo")

    def test_middleware(self):
        response = self.client.get("")
        self.assertEqual(response.status_code, 200)

```

`tests/tests_django/urls.py`:

```py
from django.http import HttpResponse
from django.urls import path

urlpatterns = [
    path("", lambda request: HttpResponse()),
]

```