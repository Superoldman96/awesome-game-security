Project Path: arc_gmh5225_zeroimport_2x7xxcup

Source Tree:

```txt
arc_gmh5225_zeroimport_2x7xxcup
├── LICENSE
├── README.md
├── zeroimport.cpp
└── zeroimport.h

```

`LICENSE`:

```
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>

```

`README.md`:

```md
# ZeroImport for Windows Kernel Drivers
ZeroImport is a lightweight and easy to use C++ library for Windows Kernel Drivers. It allows you to hide any import in your kernel driver by importing at runtime.

## Use Example
First **initialize ZeroImport** at the very beginning of your driver (DriverEntry).
```cpp
// if you don't have access to a driver object
if (!zeroimport::init())
{
   // error handling (normally zeroimport::init() should never fail!)
}

// if you have access to a driver object, this version of init is recommended
if (!zeroimport::init(pDriverObject))
{
   // error handling (normally zeroimport::init() should never fail!)
}
```

The following example shows how you could for example call `MmIsAddressValid` without statically importing the function in your driver. This can be, of course, applied to any imported function you want to call.
```cpp
PVOID Address = 0;

// import and cache MmIsAddressValid at runtime and then call it
if (ZR_IMP_CACHED(MmIsAddressValid)(Address))
{
   // ...
}

// import (without caching) MmIsAddressValid at runtime and then call it
if (ZR_IMP_NOT_CACHED(MmIsAddressValid)(Address))
{
   // ...
}

// using the default shorter macro
if (ZR_IMP(MmIsAddressValid)(Address))
{
   // ...
}
```
It's important to note that ZeroImport can import any type of exported symbol, not just functions. For example variables such as `PsLoadedModuleList` or `PsInitialSystemProcess`.
```cpp
LIST_ENTRY PsLoadedModuleList; // We need to define PsLoadedModuleList manually so that ZeroImport knows the type of import
PLIST_ENTRY pPsLoadedModuleList = ZR_IMP(PsLoadedModuleList);
// ...

PEPROCESS InitialProcess = *ZR_IMP(PsInitialSystemProcess); // PsInitialSystemProcess is already defined in ntddk.h
if (!InitialProcess)
// ...
```

## Support
- **All Windows versions** should be supported (literally all)
- **C++11** and higher

## Use Purposes
- **Difficult Static Analysis** of your driver
- Avoids **unwanted IAT (Import Address Table) Hooks** inside your driver placed by other loaded drivers

## [Proof of Concept](https://imgur.com/a/hkE4z3v)
This shows the difference between the simple source-code and compiled pseudocode (decompiled in IDA Pro).
As you can see, `PsGetProcessId` and `PsInitialSystemProcess` are not imported although I am using them in the example driver.

However ZeroImport needs to import just one function: `MmGetSystemRoutineAddress` to get `PsLoadedModuleList` and loop through the loaded system drivers and find ntoskrnl's base which is why you will always have at least one import in your driver. This isn't a big issue though because it doesn't defeat any of ZeroImport's [use purposes](#use-purposes).

## How it Works
Most if not all imports you will ever need in a kernelmode driver on Windows are inside `ntoskrnl.exe` so ZeroImport just searches ntoskrnl.exe's exported symbols at runtime and finds the right symbol by its name through hash-comparing. The names of the symbols that we want to import inside our code are hashed at compile-time for faster runtime and better security (see `zeroimport::detail::HashString()`).

The best part about ZeroImport is that it doesn't produce any strings in the compiled binary (driver), even at runtime it doesn't use or leave any string in memory. And thanks to the simple cashing system, the performance of your driver will be barely affected by this library.

## Credits
Inspired by [lazy-importer](https://github.com/JustasMasiulis/lazy_importer) which does the same thing but only for usermode applications.

```

`zeroimport.cpp`:

```cpp
#include "pch.h" // if you are using pre-compiled headers
#include "zeroimport.h"



namespace zeroimport
{
	bool init()
	{
		return init(detail::GetPsLoadedModuleList());
	}

	bool init(PLIST_ENTRY pModuleEntryList)
	{
		using namespace detail;

		PLDR_DATA_TABLE_ENTRY NtoskrnlEntry = GetSystemModuleEntry(pModuleEntryList, L"ntoskrnl.exe");
		if (!NtoskrnlEntry || !NtoskrnlEntry->DllBase)
			return false;

		NtoskrnlBase = (uintptr_t)NtoskrnlEntry->DllBase;

		IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)(NtoskrnlBase + *(LONG*)(NtoskrnlBase + 0x3C));

		uintptr_t ExportDirRVA = pNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		if (!ExportDirRVA)
			return false;

		NtoskrnlExportDir = NtoskrnlBase + ExportDirRVA;

		return true;
	}

	bool init(PDRIVER_OBJECT pDriverObject)
	{
		auto pModuleEntry = (detail::PLDR_DATA_TABLE_ENTRY)pDriverObject->DriverSection;
		return init(pModuleEntry->InLoadOrderModuleList.Flink);
	}

	namespace detail
	{
		uintptr_t NtoskrnlBase = 0;
		uintptr_t NtoskrnlExportDir = 0;

		PLIST_ENTRY GetPsLoadedModuleList()
		{
			auto RtlInitUnicodeString = [](PUNICODE_STRING DestinationString, PCWSTR SourceString)->void
			{
				DestinationString->Buffer = (wchar_t*)SourceString;

				WORD StrLen = 0;
				while (SourceString[StrLen])
					StrLen++;

				DestinationString->Length = StrLen * sizeof(wchar_t);
				DestinationString->MaximumLength = ++StrLen * sizeof(wchar_t);
			};

			static PLIST_ENTRY pModuleList = 0;
			if (!pModuleList)
			{
				UNICODE_STRING UnicodeBuf;
				RtlInitUnicodeString(&UnicodeBuf, L"PsLoadedModuleList");

				pModuleList = (PLIST_ENTRY)MmGetSystemRoutineAddress(&UnicodeBuf);
			}

			return pModuleList;
		}

		PLDR_DATA_TABLE_ENTRY GetSystemModuleEntry(PLIST_ENTRY pModuleEntryList, const wchar_t* ModuleName)
		{
			if (!ModuleName || !ModuleName[0])
				return 0;

			auto wcscimp = [](const wchar_t* str1, const wchar_t* str2)->bool
			{
				for (; *str1 || *str2; str1++, str2++)
				{
					wchar_t c1 = *str1;
					c1 += ('a' - 'A') * (c1 >= 'A' && c1 <= 'Z'); // make lowercase

					wchar_t c2 = *str2;
					c2 += ('a' - 'A') * (c2 >= 'A' && c2 <= 'Z'); // make lowercase

					if (c1 != c2)
						return false;
				}

				return true;
			};

			for (PLIST_ENTRY pEntry = pModuleEntryList; pEntry != pModuleEntryList->Blink; pEntry = pEntry->Flink)
			{
				PLDR_DATA_TABLE_ENTRY ModuleEntry = CONTAINING_RECORD(pEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
				if (!ModuleEntry->BaseDllName.Buffer)
					continue;

				if (wcscimp(ModuleEntry->BaseDllName.Buffer, ModuleName))
					return ModuleEntry;
			}

			return 0;
		}
	}
}

```

`zeroimport.h`:

```h
/*
https://github.com/1hAck-0/zeroimport
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>
*/
#if _MSC_VER >= 1200
#pragma once
#endif

#ifndef ZERO_IMPORT_H
#define ZERO_IMPORT_H

#include <ntdef.h> // type definitions
#include <wdm.h> // function prototypes (needed for MmGetSystemRoutineAddress)



#define ZR_IMP_ENABLE_FORCEINLINE true

// change this to generate unique hashes!
#define ZR_IMP_UNIQUE_KEY 0x738CE813D989
// the key is not randomly generated at compile by using macros such as __TIME__,
// because it breaks the hashing algorithm for whatever reason,
// try it for yourself

#define ZR_IMP_PTR_NOT_CACHED(imp) (zeroimport::detail::GetNtoskrnlExport(zeroimport::detail::HashString(imp)))
#define ZR_IMP_PTR_CACHED(imp) (zeroimport::detail::GetNtoskrnlExport<zeroimport::detail::HashString(imp)>())

#define ZR_IMP_NOT_CACHED(imp) ((decltype(&imp))ZR_IMP_PTR_NOT_CACHED(#imp))
#define ZR_IMP_CACHED(imp) ((decltype(&imp))ZR_IMP_PTR_CACHED(#imp))

// default zeroimport macro
#define ZR_IMP ZR_IMP_CACHED



#if ZR_IMP_ENABLE_FORCEINLINE
#define ZR_IMP_FORCEINLINE __forceinline
#else
#define ZR_IMP_FORCEINLINE inline
#endif

namespace zeroimport
{
	bool init(PLIST_ENTRY pModuleEntryList);
	bool init(PDRIVER_OBJECT pDriverObject);
	bool init();

	namespace detail
	{
		extern uintptr_t NtoskrnlBase;
		extern uintptr_t NtoskrnlExportDir;

		typename typedef uintptr_t HashType;
		ZR_IMP_FORCEINLINE constexpr auto HashString(const char* Str)
		{
			HashType Hash = ZR_IMP_UNIQUE_KEY;

			for (size_t i = 0; Str[i]; i++)
			{
				HashType c = Str[i];

				Hash ^= (c * c) << ((i + 1) % 8);
				Hash *= i + 1;
			}

			return Hash;
		}


		// PE header structures
		typedef struct _IMAGE_FILE_HEADER {
			WORD  Machine;
			WORD  NumberOfSections;
			DWORD TimeDateStamp;
			DWORD PointerToSymbolTable;
			DWORD NumberOfSymbols;
			WORD  SizeOfOptionalHeader;
			WORD  Characteristics;
		} IMAGE_FILE_HEADER, * PIMAGE_FILE_HEADER;

		typedef struct _IMAGE_DATA_DIRECTORY {
			DWORD   VirtualAddress;
			DWORD   Size;
		} IMAGE_DATA_DIRECTORY, * PIMAGE_DATA_DIRECTORY;

		typedef struct _IMAGE_OPTIONAL_HEADER {
			WORD        Magic;
			BYTE        MajorLinkerVersion;
			BYTE        MinorLinkerVersion;
			DWORD       SizeOfCode;
			DWORD       SizeOfInitializedData;
			DWORD       SizeOfUninitializedData;
			DWORD       AddressOfEntryPoint;
			DWORD       BaseOfCode;
			ULONGLONG   ImageBase;
			DWORD       SectionAlignment;
			DWORD       FileAlignment;
			WORD        MajorOperatingSystemVersion;
			WORD        MinorOperatingSystemVersion;
			WORD        MajorImageVersion;
			WORD        MinorImageVersion;
			WORD        MajorSubsystemVersion;
			WORD        MinorSubsystemVersion;
			DWORD       Win32VersionValue;
			DWORD       SizeOfImage;
			DWORD       SizeOfHeaders;
			DWORD       CheckSum;
			WORD        Subsystem;
			WORD        DllCharacteristics;
			ULONGLONG   SizeOfStackReserve;
			ULONGLONG   SizeOfStackCommit;
			ULONGLONG   SizeOfHeapReserve;
			ULONGLONG   SizeOfHeapCommit;
			DWORD       LoaderFlags;
			DWORD       NumberOfRvaAndSizes;
			IMAGE_DATA_DIRECTORY DataDirectory[16];
		} IMAGE_OPTIONAL_HEADER, * PIMAGE_OPTIONAL_HEADER;

		typedef struct _IMAGE_NT_HEADERS {
			DWORD                   Signature;
			IMAGE_FILE_HEADER       FileHeader;
			IMAGE_OPTIONAL_HEADER OptionalHeader;
		} IMAGE_NT_HEADERS, * PIMAGE_NT_HEADERS;

		typedef struct _IMAGE_EXPORT_DIRECTORY {
			DWORD   Characteristics;
			DWORD   TimeDateStamp;
			WORD    MajorVersion;
			WORD    MinorVersion;
			DWORD   Name;
			DWORD   Base;
			DWORD   NumberOfFunctions;
			DWORD   NumberOfNames;
			DWORD   AddressOfFunctions;     // RVA from base of image
			DWORD   AddressOfNames;         // RVA from base of image
			DWORD   AddressOfNameOrdinals;  // RVA from base of image
		} IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory


		ZR_IMP_FORCEINLINE PVOID GetNtoskrnlExport(HashType Hash)
		{
			IMAGE_EXPORT_DIRECTORY* ExportDir = (IMAGE_EXPORT_DIRECTORY*)NtoskrnlExportDir;

			DWORD* NameRVAs = (DWORD*)(NtoskrnlBase + ExportDir->AddressOfNames);
			for (DWORD i = 0; i < ExportDir->NumberOfNames; i++)
			{
				if (HashString((char*)(NtoskrnlBase + NameRVAs[i])) != Hash)
					continue;

				WORD* Ordinals = (WORD*)(NtoskrnlBase + ExportDir->AddressOfNameOrdinals);
				DWORD* FunctionRVAs = (DWORD*)(NtoskrnlBase + ExportDir->AddressOfFunctions);

				return (PVOID)(NtoskrnlBase + FunctionRVAs[Ordinals[i]]);
			}

			return 0;
		}

		template<HashType Hash>
		ZR_IMP_FORCEINLINE PVOID GetNtoskrnlExport()
		{
			static PVOID pCached = 0;
			if (!pCached)
				pCached = GetNtoskrnlExport(Hash);

			return pCached;
		}


		// module entry (needed for ntoskrnl.exe base)
		typedef struct _LDR_DATA_TABLE_ENTRY
		{
			LIST_ENTRY InLoadOrderModuleList;
			LIST_ENTRY InMemoryOrderModuleList;
			LIST_ENTRY InInitializationOrderModuleList;
			PVOID DllBase;
			PVOID EntryPoint;
			ULONG SizeOfImage;
			UNICODE_STRING FullDllName;
			UNICODE_STRING BaseDllName;
			ULONG Flags;
			WORD LoadCount;
			WORD TlsIndex;
			LIST_ENTRY HashLinks;
			PVOID SectionPointer;
			ULONG CheckSum;
			ULONG TimeDateStamp;
		} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;
		PLIST_ENTRY GetPsLoadedModuleList();
		PLDR_DATA_TABLE_ENTRY GetSystemModuleEntry(PLIST_ENTRY pModuleEntryList, const wchar_t* ModuleName);
	}
}

#endif // ZERO_IMPORT_H

```