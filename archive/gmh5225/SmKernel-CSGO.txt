Project Path: arc_gmh5225_SmKernel-CSGO_sq74ikmy

Source Tree:

```txt
arc_gmh5225_SmKernel-CSGO_sq74ikmy
├── README.md
├── SmKernel-CSGO.sln
├── SmKernel_Client
│   ├── CFunctions.cpp
│   ├── CFunctions.h
│   ├── Definitions.h
│   ├── IKernelInterface.cpp
│   ├── IKernelInterface.h
│   ├── Main.cpp
│   ├── Offsets.h
│   ├── SmKernel_Client.vcxproj
│   └── SmKernel_Client.vcxproj.filters
└── SmKernel_SYS
    ├── CMemory.cpp
    ├── CMemory.h
    ├── CSharedMemory.cpp
    ├── CSharedMemory.h
    ├── Definitions.h
    ├── Driver.cpp
    ├── Globals.h
    ├── SmKernel_SYS.vcxproj
    └── SmKernel_SYS.vcxproj.filters

```

`README.md`:

```md
# SmKernel-CSGO

### SmKernel-CSGO is a educational project that's show how a driver can be used to hack games.

<p>SmKernel use a kernel driver that's make a shared memory communication. Driver have simple cheat functions like get module base and Read/Write in memory.</p>

<p>This project is maded in my free time and i make this very fast so this probably has some bugs.</p>
<p>The project is simpel, i just add a simple triggerbot, just for poc.</p>

# Can VAC detect this cheat ?
<p>Problaly no, because vac don't have a kernel driver that's can detect this feautures.</p>
<p>To make sure it's undetectable you can add obCallBacks to the usermode app, but I don't think it's necessary for such a weak anticheat.</p>

# Can kernel anticheats detect this cheat ?
<p>Yes, because I didn't build this driver with security as a priority.</p>
<p>So a kernel anticheat can easily detect this</p>


# Compiling
- Download visual studio 2019
- Install Windows Driver Kit (WDK)
- Download the project
- Open solution and compile for x64

# How to start
- Put computer on test mode
```bcdedit /set testsigning on```
- Restart your computer
- Create a service for driver ```sc create smk type=kernel binpath="path to driver"```
- Start the service ```sc start smk```

### Note: It's not a safe mode to load a cheat driver, look for methods to manual map your driver with a vulnerable driver

```

`SmKernel-CSGO.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32413.511
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SMK_SYS", "SmKernel_SYS\SmKernel_SYS.vcxproj", "{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SMK_CLIENT", "SmKernel_Client\SmKernel_Client.vcxproj", "{C709148C-21F9-46AD-A801-AF29078FFCB3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM.ActiveCfg = Debug|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM.Build.0 = Debug|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM.Deploy.0 = Debug|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM64.Build.0 = Debug|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x64.ActiveCfg = Debug|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x64.Build.0 = Debug|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x64.Deploy.0 = Debug|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x86.ActiveCfg = Debug|Win32
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x86.Build.0 = Debug|Win32
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Debug|x86.Deploy.0 = Debug|Win32
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM.ActiveCfg = Release|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM.Build.0 = Release|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM.Deploy.0 = Release|ARM
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM64.ActiveCfg = Release|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM64.Build.0 = Release|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|ARM64.Deploy.0 = Release|ARM64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x64.ActiveCfg = Release|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x64.Build.0 = Release|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x64.Deploy.0 = Release|x64
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x86.ActiveCfg = Release|Win32
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x86.Build.0 = Release|Win32
		{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}.Release|x86.Deploy.0 = Release|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|ARM.ActiveCfg = Debug|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|ARM64.ActiveCfg = Debug|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|x64.ActiveCfg = Debug|x64
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|x64.Build.0 = Debug|x64
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|x86.ActiveCfg = Debug|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Debug|x86.Build.0 = Debug|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|ARM.ActiveCfg = Release|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|ARM64.ActiveCfg = Release|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|x64.ActiveCfg = Release|x64
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|x64.Build.0 = Release|x64
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|x86.ActiveCfg = Release|Win32
		{C709148C-21F9-46AD-A801-AF29078FFCB3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {56F2D9AE-C1FC-4D8C-A328-F497F5A60F4D}
	EndGlobalSection
EndGlobal

```

`SmKernel_Client/CFunctions.cpp`:

```cpp
#include "CFunctions.h"

IKernelInterface::CMemory* Mem;

uintptr_t CFunctions::GetLocalPlayer(void)
{
    return Mem->Read<uintptr_t>(BaseAddress + dwLocalPlayer);
}

uintptr_t CFunctions::GetPlayer(int index)
{
    return Mem->Read<uintptr_t>(BaseAddress + dwEntityList + index * 0x10);
}

int CFunctions::GetTeam(uintptr_t player)
{
    return Mem->Read<int>(player + m_iTeamNum);
}

int CFunctions::GetCrosshairID(uintptr_t player)
{
    return Mem->Read<int>(player + m_iCrosshairId);
}

void CFunctions::TriggerBot(int delay, int key)
{
    if (this->GetCrosshairID(this->GetLocalPlayer()) > 0 &&
        this->GetCrosshairID(this->GetLocalPlayer()) < 32 &&
        this->GetTeam(this->GetLocalPlayer()) != this->GetTeam(this->GetPlayer(this->GetCrosshairID(this->GetLocalPlayer()) - 1))) 
    {
        // Use mouse_event is not good pratice but i'm lazy
        // TODO: implement shot
        mouse_event(MOUSEEVENTF_LEFTDOWN, NULL, NULL, 0, 0);
        mouse_event(MOUSEEVENTF_LEFTUP, NULL, NULL, 0, 0);
        Sleep(100);
    }

    // NOTE: This "this" is not necessary but is good pratice
}

```

`SmKernel_Client/CFunctions.h`:

```h
#include "Offsets.h"
#include "IKernelInterface.h"

using namespace hazedumper;
using namespace hazedumper::signatures;
using namespace hazedumper::netvars;

class CFunctions {
private:
	uintptr_t GetLocalPlayer(void);
	uintptr_t GetPlayer(int index);
	int GetTeam(uintptr_t player);
	int GetCrosshairID(uintptr_t player);
public:
	void TriggerBot(int delay, int key);
};
```

`SmKernel_Client/Definitions.h`:

```h
#pragma once
#include <tchar.h>
#include <windows.h>
#include <iostream>
#include <accctrl.h>
#include <aclapi.h>
#define Log(x) printf(x)

static ULONG PID;
static ULONG64 BaseAddress = NULL;
static HANDLE hMapFileW;
static HANDLE hMapFileR;
static HANDLE g_hMutex;

static HANDLE SharedEventDataArv;
static HANDLE SharedEventTrigger;
static HANDLE SharedEventReady2Read;

static DWORD dwRes;
static SECURITY_ATTRIBUTES sa;
static PSECURITY_DESCRIPTOR pSD = NULL;
static SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
static PACL pAcl = NULL;
static PSID pEveryoneSID = NULL;
static EXPLICIT_ACCESS ea[1];


typedef struct _KM_READ_REQUEST
{
	ULONG ProcessId;
	UINT_PTR SourceAddress;
	ULONGLONG Size;
	void* Output;

} KM_READ_REQUEST;


typedef struct _KM_WRITE_REQUEST
{
	ULONG ProcessId;
	ULONG ProcessidOfSource;
	UINT_PTR SourceAddress;
	UINT_PTR TargetAddress;
	ULONGLONG Size;
} KM_WRITE_REQUEST;


typedef struct _GET_USERMODULE_IN_PROCESS
{
	ULONG pid;
	ULONG64 BaseAddress;
} GET_USERMODULE_IN_PROCESS;




```

`SmKernel_Client/IKernelInterface.cpp`:

```cpp
#include "IKernelInterface.h"
#include <TlHelp32.h>

DWORD_PTR IKernelInterface::CMemory::FindProcessId(const std::string& processName) {
	// TODO: Implemente this function ok kernel
	PROCESSENTRY32 processInfo;
	processInfo.dwSize = sizeof(processInfo);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	Process32First(processesSnapshot, &processInfo);
	if (!processName.compare(processInfo.szExeFile)) {
		CloseHandle(processesSnapshot);
		return processInfo.th32ProcessID;
	}

	while (Process32Next(processesSnapshot, &processInfo)) {
		if (!processName.compare(processInfo.szExeFile)) {
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}
	}

	CloseHandle(processesSnapshot);
	return 0;
}

bool IKernelInterface::CMemory::WriteVirtualMemory(UINT_PTR WriteAddress, UINT_PTR SourceAddress, SIZE_T WriteSize) {
	auto WriteMemoryMsg = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
	char str[8];
	// str to driver read
	strcpy_s(str, "Write");
	// Coping to memory
	RtlCopyMemory(WriteMemoryMsg, str, strlen(str) + 1);

	UnmapViewOfFile(WriteMemoryMsg);

	WaitForSingleObject(SharedEventDataArv, INFINITE);

	KM_WRITE_REQUEST* SentStruct = (KM_WRITE_REQUEST*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(KM_WRITE_REQUEST));

	if (!SentStruct) {
		Log("Error MapViewOfFile!\r\n");
		return false;
	}
	// Setting up instructions
	KM_WRITE_REQUEST  WriteRequest;
	WriteRequest.ProcessId = PID;
	WriteRequest.ProcessidOfSource = GetCurrentProcessId();
	WriteRequest.TargetAddress = WriteAddress;
	WriteRequest.SourceAddress = SourceAddress;
	WriteRequest.Size = WriteSize;

	KM_WRITE_REQUEST* ptr = &WriteRequest;
	if (0 == memcpy(SentStruct, ptr, sizeof(KM_WRITE_REQUEST))) {
		Log("Error copying memory with (memcpy) to struct\n");
		return false;
	}

	// success
	Log("%p\n", SentStruct);
	UnmapViewOfFile(SentStruct);

	// Wait for kernel signal before exit
	WaitForSingleObject(SharedEventTrigger, INFINITE);
	ResetEvent(SharedEventTrigger);
	return true;
}

ULONG64 IKernelInterface::CMemory::GetModuleBase(ULONG pid) {
	auto MapViewMsg = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
	if (!MapViewMsg) {
	Log("MapViewMsg Failed. Func - Request ");
		return false;
	}
	char Msg[8];
	strcpy_s(Msg, "getBase");

	// Copy Memory Over To Map
	RtlCopyMemory(MapViewMsg, Msg, strlen(Msg) + 1);
	UnmapViewOfFile(MapViewMsg);

	WaitForSingleObject(SharedEventDataArv, INFINITE);

	GET_USERMODULE_IN_PROCESS* SentStruct = (GET_USERMODULE_IN_PROCESS*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(GET_USERMODULE_IN_PROCESS));
	
	if (!SentStruct) {
		Log("Error MapViewOfFile(SentStruct)\n");
		return 0;
	}


	GET_USERMODULE_IN_PROCESS requestbase;

	requestbase.pid = pid;

	GET_USERMODULE_IN_PROCESS* ptr = &requestbase;
	if (0 == memcpy(SentStruct, ptr, sizeof(GET_USERMODULE_IN_PROCESS))) {
		Log("Error copying memory with (memcpy) to struct\n");
		return 0;
	}
	Log("PID : %u \n", requestbase.pid);

	UnmapViewOfFile(SentStruct);


	WaitForSingleObject(SharedEventReady2Read, INFINITE);

	GET_USERMODULE_IN_PROCESS* GetBaseStruct = (GET_USERMODULE_IN_PROCESS*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, sizeof(GET_USERMODULE_IN_PROCESS));
	if (!GetBaseStruct) {
		Log("OpenFileMappingA(getbase_struct) fail! Error: %u\n", GetLastError());
		return 0;
	}
	ULONG64 base = NULL;

	base = GetBaseStruct->BaseAddress;

	Log("Base address of dummy program : %p \n", GetBaseStruct->BaseAddress);
	Log("Base  : %p \n", base);

	UnmapViewOfFile(GetBaseStruct);

	return base;
}

void IKernelInterface::CMemory::GetPidAndModuleBase(void) {
	PID = FindProcessId("csgo.exe");
	std::cout << "PID IS : " << PID << std::endl;

	// get base address
	BaseAddress = GetModuleBase(PID);
	std::cout << "base address is : " << std::hex << BaseAddress << std::endl;
}

void IKernelInterface::CSharedMemory::CreateSecuritydescriptor(void) {
	if (!AllocateAndInitializeSid(
		&SIDAuthWorld,   //PSID_IDENTIFIER_AUTHORITY
		1,               //nSubAuthorityCount
		SECURITY_WORLD_RID,     //nSubAuthority0
		0, 0, 0, 0, 0, 0, 0,    //Not used subAuthorities.
		&pEveryoneSID))         //Callback argument that recieves pointer to the allocated and initialized SID structure
	{
		Log("AllocateAndInitializeSid() Error.\n", GetLastError());
		system("pause");
	}


	//Filling in EXPLICIT_ACCESS structure. Everyone's group members will have all the permissions on event.
	ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
	ea[0].grfAccessPermissions = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;
	ea[0].grfAccessMode = SET_ACCESS;
	ea[0].grfInheritance = NO_INHERITANCE;
	ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
	//ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
	ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
	ea[0].Trustee.ptstrName = (LPTSTR)pEveryoneSID;

	//Creation of new ACL that contains the new ACE.
	dwRes = SetEntriesInAcl(1, ea, NULL, &pAcl);
	if (dwRes != ERROR_SUCCESS) {
		Log("SetEntriesInAcl() Error.\n", GetLastError());
		system("pause");
	}
	pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
	if (pSD == NULL) {
		Log("LocalAlloc() Error.\n", GetLastError());
		system("pause");
	}
	if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
		Log("InitializeSecurityDescriptor() Error.\n", GetLastError());
		system("pause");
	}
	//Adding ACL to Security Descriptor.
	if (!SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE)) {
		Log("SetSecurityDescriptorDacl() Error.\n", GetLastError());
		system("pause");
	}
	//Initialize Security Attributes structure.
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = pSD;
	sa.bInheritHandle = FALSE;
}

void IKernelInterface::CSharedMemory::Create(void) {
	SharedEventDataArv = CreateEventA(&sa, TRUE, FALSE, "GlobalsDataArrived");
	if (!SharedEventDataArv) {
		Log("SharedEventDataArv CreateEventA fail! Error: %u\n", GetLastError());
		system("pause");
	}
	Log("CreateEventA SUCESS (SharedEvent->(DataArrived)) ! \n");

	SharedEventTrigger = CreateEventA(&sa, TRUE, FALSE, "Global\\trigger");
	if (!SharedEventTrigger) {
		Log("SharedEventTrigger CreateEventA fail! Error: %u\n", GetLastError());
		system("pause");
	}
	Log("CreateEventA SUCESS (SharedEvent->(trigger)) ! \n");

	SharedEventReady2Read = CreateEventA(&sa, TRUE, FALSE, "Global\\ReadyRead");
	if (!SharedEventReady2Read) {
		Log("SharedEventReady2Read CreateEventA fail! Error: %u\n", GetLastError());
		system("pause");
	}
	Log("CreateEventA SUCESS (SharedEvent->(ready2read)) ! \n");
}

bool IKernelInterface::CSharedMemory::Open(void) {
	hMapFileW = OpenFileMappingA(FILE_MAP_WRITE, FALSE, "Global\\SharedMem");
	if (!hMapFileW || hMapFileW == INVALID_HANDLE_VALUE) {
		Log("OpenFileMappingA(write) fail! Error: %u\n", GetLastError());
		return false;
	}
	hMapFileR = OpenFileMappingA(FILE_MAP_READ, FALSE, "Global\\SharedMem");
	if (!hMapFileR || hMapFileR == INVALID_HANDLE_VALUE) {
		Log("OpenFileMappingA(read) fail! Error: %u\n", GetLastError());
		return false;
	}
	Log("Shared memory opened\n");
	return true;
}

void IKernelInterface::CSharedMemory::Stop(void) {
	auto StopMsg = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);

	char stopmms[8];
	strcpy_s(stopmms, "Stop");


	RtlCopyMemory(StopMsg, stopmms, strlen(stopmms) + 1);

	Log("message has been sent to kernel [Stop]! \n");


	FlushViewOfFile(StopMsg, 4096);
	UnmapViewOfFile(StopMsg);
}

```

`SmKernel_Client/IKernelInterface.h`:

```h
#pragma once
#include "Definitions.h"

// Driver Interface
namespace IKernelInterface {

	class CMemory {
	public:
		DWORD_PTR FindProcessId(const std::string& processName);

		template<typename T>
		bool Write(UINT_PTR WriteAddress, const T& value);

		bool WriteVirtualMemory(UINT_PTR WriteAddress, UINT_PTR SourceAddress, SIZE_T WriteSize);
		template <typename type>
		type Read(UINT_PTR ReadAddress);

		ULONG64 GetModuleBase(ULONG pid);

		void GetPidAndModuleBase(void);
	};

	class CSharedMemory {
	public:
		void CreateSecuritydescriptor(void);
		void Create(void);
		bool Open(void);
		void Stop(void);
	};
}

template<typename T>
inline bool IKernelInterface::CMemory::Write(UINT_PTR WriteAddress, const T& value)
{
	return WriteVirtualMemoryRaw(WriteAddress, (UINT_PTR)&value, sizeof(T));
}

template<typename type>
inline type IKernelInterface::CMemory::Read(UINT_PTR ReadAddress)
{
	auto ReadMemory = (char*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, 4096);
	char str[8];
	strcpy_s(str, "Read");
	RtlCopyMemory(ReadMemory, str, strlen(str) + 1);

	UnmapViewOfFile(ReadMemory);

	WaitForSingleObject(SharedEventDataArv, INFINITE);


	KM_READ_REQUEST* SentStruct = (KM_READ_REQUEST*)MapViewOfFile(hMapFileW, FILE_MAP_WRITE, 0, 0, sizeof(KM_READ_REQUEST));

	if (!SentStruct) {
		Log("Error MapViewOfFile(Sent_struct)\n");
		return false;
	}

	KM_READ_REQUEST ReadRequest{};

	// just to clairfy this is like doing for ex : int response; its an empty var
	type response{};

	ReadRequest.ProcessId = PID;
	ReadRequest.SourceAddress = ReadAddress;
	ReadRequest.Size = sizeof(type);
	ReadRequest.Output = &response;


	KM_READ_REQUEST* ptr = &ReadRequest;
	if (0 == memcpy(SentStruct, ptr, sizeof(KM_READ_REQUEST))) {
		Log("Error copying memory with (memcpy) to struct\n");
		return -1;
	}	
	Log("Struct pointer : %p PID : %u ReadAddress : %p Output : %p Size : %x \n", SentStruct, ReadRequest.ProcessId, ReadRequest.SourceAddress, ReadRequest.Output, ReadRequest.Size);
	UnmapViewOfFile(SentStruct);

	WaitForSingleObject(SharedEventReady2Read, INFINITE);

	KM_READ_REQUEST* ReadStruct = (KM_READ_REQUEST*)MapViewOfFile(hMapFileR, FILE_MAP_READ, 0, 0, sizeof(KM_READ_REQUEST));
	if (!ReadStruct) {
		Log("OpenFileMappingA(Read_struct) fail! Error: %u\n", GetLastError());
		return -1;
	}

	Log("Data Read_struct : %p\n", Read_struct);
	Log("Data Read_struct->Output : %p\n", Read_struct->Output);
	Log("Data value : %u \n", Read_struct->Output);

	type ReturnVal = ((type)ReadStruct->Output);

	UnmapViewOfFile(ReadStruct);
	WaitForSingleObject(SharedEventTrigger, INFINITE);
	ResetEvent(SharedEventTrigger);
	return ReturnVal;
}

```

`SmKernel_Client/Main.cpp`:

```cpp
#include "CFunctions.h"

CFunctions functions;
IKernelInterface::CSharedMemory* SharedMemory;
IKernelInterface::CMemory* Memory;

int _tmain(void)
{
	int nCode = 0;

	Memory->GetPidAndModuleBase();

	SharedMemory->CreateSecuritydescriptor();
	
	SharedMemory->Create();

	nCode = SharedMemory->Open();
	if (!nCode) {
		Log("Fail to open shared memory!");
		return nCode;
	}
	Sleep(1000);

	system("cls");
	Log("Started, press f4 to stop");

	// TODO: Make a thread 
	while (!GetAsyncKeyState(VK_F4)) {
		functions.TriggerBot(60, VK_RBUTTON);
		Sleep(25);
	}
	SharedMemory->Stop();

	return nCode;
}
```

`SmKernel_Client/Offsets.h`:

```h
#pragma once
#include <cstdint>
#include <cstddef>

// 2022-05-10 07:30:43.637268 UTC

namespace hazedumper {
	constexpr ::std::int64_t timestamp = 1652167843;
	namespace netvars {
		constexpr ::std::ptrdiff_t cs_gamerules_data = 0x0;
		constexpr ::std::ptrdiff_t m_ArmorValue = 0x117CC;
		constexpr ::std::ptrdiff_t m_Collision = 0x320;
		constexpr ::std::ptrdiff_t m_CollisionGroup = 0x474;
		constexpr ::std::ptrdiff_t m_Local = 0x2FCC;
		constexpr ::std::ptrdiff_t m_MoveType = 0x25C;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x31D4;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidLow = 0x31D0;
		constexpr ::std::ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1328;
		constexpr ::std::ptrdiff_t m_SurvivalRules = 0xD00;
		constexpr ::std::ptrdiff_t m_aimPunchAngle = 0x303C;
		constexpr ::std::ptrdiff_t m_aimPunchAngleVel = 0x3048;
		constexpr ::std::ptrdiff_t m_angEyeAnglesX = 0x117D0;
		constexpr ::std::ptrdiff_t m_angEyeAnglesY = 0x117D4;
		constexpr ::std::ptrdiff_t m_bBombDefused = 0x29C0;
		constexpr ::std::ptrdiff_t m_bBombPlanted = 0x9A5;
		constexpr ::std::ptrdiff_t m_bBombTicking = 0x2990;
		constexpr ::std::ptrdiff_t m_bFreezePeriod = 0x20;
		constexpr ::std::ptrdiff_t m_bGunGameImmunity = 0x9990;
		constexpr ::std::ptrdiff_t m_bHasDefuser = 0x117DC;
		constexpr ::std::ptrdiff_t m_bHasHelmet = 0x117C0;
		constexpr ::std::ptrdiff_t m_bInReload = 0x32B5;
		constexpr ::std::ptrdiff_t m_bIsDefusing = 0x997C;
		constexpr ::std::ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
		constexpr ::std::ptrdiff_t m_bIsScoped = 0x9974;
		constexpr ::std::ptrdiff_t m_bIsValveDS = 0x7C;
		constexpr ::std::ptrdiff_t m_bSpotted = 0x93D;
		constexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;
		constexpr ::std::ptrdiff_t m_bStartedArming = 0x3400;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMax = 0x9D9;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMin = 0x9D8;
		constexpr ::std::ptrdiff_t m_bUseCustomBloomScale = 0x9DA;
		constexpr ::std::ptrdiff_t m_clrRender = 0x70;
		constexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;
		constexpr ::std::ptrdiff_t m_fAccuracyPenalty = 0x3340;
		constexpr ::std::ptrdiff_t m_fFlags = 0x104;
		constexpr ::std::ptrdiff_t m_flC4Blow = 0x29A0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMax = 0x9E0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMin = 0x9DC;
		constexpr ::std::ptrdiff_t m_flCustomBloomScale = 0x9E4;
		constexpr ::std::ptrdiff_t m_flDefuseCountDown = 0x29BC;
		constexpr ::std::ptrdiff_t m_flDefuseLength = 0x29B8;
		constexpr ::std::ptrdiff_t m_flFallbackWear = 0x31E0;
		constexpr ::std::ptrdiff_t m_flFlashDuration = 0x10470;
		constexpr ::std::ptrdiff_t m_flFlashMaxAlpha = 0x1046C;
		constexpr ::std::ptrdiff_t m_flLastBoneSetupTime = 0x2928;
		constexpr ::std::ptrdiff_t m_flLowerBodyYawTarget = 0x9ADC;
		constexpr ::std::ptrdiff_t m_flNextAttack = 0x2D80;
		constexpr ::std::ptrdiff_t m_flNextPrimaryAttack = 0x3248;
		constexpr ::std::ptrdiff_t m_flSimulationTime = 0x268;
		constexpr ::std::ptrdiff_t m_flTimerLength = 0x29A4;
		constexpr ::std::ptrdiff_t m_hActiveWeapon = 0x2F08;
		constexpr ::std::ptrdiff_t m_hBombDefuser = 0x29C4;
		constexpr ::std::ptrdiff_t m_hMyWeapons = 0x2E08;
		constexpr ::std::ptrdiff_t m_hObserverTarget = 0x339C;
		constexpr ::std::ptrdiff_t m_hOwner = 0x29DC;
		constexpr ::std::ptrdiff_t m_hOwnerEntity = 0x14C;
		constexpr ::std::ptrdiff_t m_hViewModel = 0x3308;
		constexpr ::std::ptrdiff_t m_iAccountID = 0x2FD8;
		constexpr ::std::ptrdiff_t m_iClip1 = 0x3274;
		constexpr ::std::ptrdiff_t m_iCompetitiveRanking = 0x1A84;
		constexpr ::std::ptrdiff_t m_iCompetitiveWins = 0x1B88;
		constexpr ::std::ptrdiff_t m_iCrosshairId = 0x11838;
		constexpr ::std::ptrdiff_t m_iDefaultFOV = 0x333C;
		constexpr ::std::ptrdiff_t m_iEntityQuality = 0x2FBC;
		constexpr ::std::ptrdiff_t m_iFOV = 0x31F4;
		constexpr ::std::ptrdiff_t m_iFOVStart = 0x31F8;
		constexpr ::std::ptrdiff_t m_iGlowIndex = 0x10488;
		constexpr ::std::ptrdiff_t m_iHealth = 0x100;
		constexpr ::std::ptrdiff_t m_iItemDefinitionIndex = 0x2FBA;
		constexpr ::std::ptrdiff_t m_iItemIDHigh = 0x2FD0;
		constexpr ::std::ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
		constexpr ::std::ptrdiff_t m_iObserverMode = 0x3388;
		constexpr ::std::ptrdiff_t m_iShotsFired = 0x103E0;
		constexpr ::std::ptrdiff_t m_iState = 0x3268;
		constexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;
		constexpr ::std::ptrdiff_t m_lifeState = 0x25F;
		constexpr ::std::ptrdiff_t m_nBombSite = 0x2994;
		constexpr ::std::ptrdiff_t m_nFallbackPaintKit = 0x31D8;
		constexpr ::std::ptrdiff_t m_nFallbackSeed = 0x31DC;
		constexpr ::std::ptrdiff_t m_nFallbackStatTrak = 0x31E4;
		constexpr ::std::ptrdiff_t m_nForceBone = 0x268C;
		constexpr ::std::ptrdiff_t m_nTickBase = 0x3440;
		constexpr ::std::ptrdiff_t m_nViewModelIndex = 0x29D0;
		constexpr ::std::ptrdiff_t m_rgflCoordinateFrame = 0x444;
		constexpr ::std::ptrdiff_t m_szCustomName = 0x304C;
		constexpr ::std::ptrdiff_t m_szLastPlaceName = 0x35C4;
		constexpr ::std::ptrdiff_t m_thirdPersonViewAngles = 0x31E8;
		constexpr ::std::ptrdiff_t m_vecOrigin = 0x138;
		constexpr ::std::ptrdiff_t m_vecVelocity = 0x114;
		constexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;
		constexpr ::std::ptrdiff_t m_viewPunchAngle = 0x3030;
		constexpr ::std::ptrdiff_t m_zoomLevel = 0x33E0;
	} // namespace netvars
	namespace signatures {
		constexpr ::std::ptrdiff_t anim_overlays = 0x2990;
		constexpr ::std::ptrdiff_t clientstate_choked_commands = 0x4D30;
		constexpr ::std::ptrdiff_t clientstate_delta_ticks = 0x174;
		constexpr ::std::ptrdiff_t clientstate_last_outgoing_command = 0x4D2C;
		constexpr ::std::ptrdiff_t clientstate_net_channel = 0x9C;
		constexpr ::std::ptrdiff_t convar_name_hash_table = 0x2F0F8;
		constexpr ::std::ptrdiff_t dwClientState = 0x58CFC4;
		constexpr ::std::ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
		constexpr ::std::ptrdiff_t dwClientState_IsHLTV = 0x4D48;
		constexpr ::std::ptrdiff_t dwClientState_Map = 0x28C;
		constexpr ::std::ptrdiff_t dwClientState_MapDirectory = 0x188;
		constexpr ::std::ptrdiff_t dwClientState_MaxPlayer = 0x388;
		constexpr ::std::ptrdiff_t dwClientState_PlayerInfo = 0x52C0;
		constexpr ::std::ptrdiff_t dwClientState_State = 0x108;
		constexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D90;
		constexpr ::std::ptrdiff_t dwEntityList = 0x4DD346C;
		constexpr ::std::ptrdiff_t dwForceAttack = 0x3203920;
		constexpr ::std::ptrdiff_t dwForceAttack2 = 0x320392C;
		constexpr ::std::ptrdiff_t dwForceBackward = 0x320395C;
		constexpr ::std::ptrdiff_t dwForceForward = 0x3203950;
		constexpr ::std::ptrdiff_t dwForceJump = 0x527D380;
		constexpr ::std::ptrdiff_t dwForceLeft = 0x3203968;
		constexpr ::std::ptrdiff_t dwForceRight = 0x3203974;
		constexpr ::std::ptrdiff_t dwGameDir = 0x62B900;
		constexpr ::std::ptrdiff_t dwGameRulesProxy = 0x52F0BAC;
		constexpr ::std::ptrdiff_t dwGetAllClasses = 0xDE177C;
		constexpr ::std::ptrdiff_t dwGlobalVars = 0x58CCC8;
		constexpr ::std::ptrdiff_t dwGlowObjectManager = 0x531C078;
		constexpr ::std::ptrdiff_t dwInput = 0x5224A40;
		constexpr ::std::ptrdiff_t dwInterfaceLinkList = 0x969514;
		constexpr ::std::ptrdiff_t dwLocalPlayer = 0xDB75DC;
		constexpr ::std::ptrdiff_t dwMouseEnable = 0xDBD2E8;
		constexpr ::std::ptrdiff_t dwMouseEnablePtr = 0xDBD2B8;
		constexpr ::std::ptrdiff_t dwPlayerResource = 0x3201CD0;
		constexpr ::std::ptrdiff_t dwRadarBase = 0x52081E4;
		constexpr ::std::ptrdiff_t dwSensitivity = 0xDBD184;
		constexpr ::std::ptrdiff_t dwSensitivityPtr = 0xDBD158;
		constexpr ::std::ptrdiff_t dwSetClanTag = 0x8A3E0;
		constexpr ::std::ptrdiff_t dwViewMatrix = 0x4DC4D84;
		constexpr ::std::ptrdiff_t dwWeaponTable = 0x5225504;
		constexpr ::std::ptrdiff_t dwWeaponTableIndex = 0x326C;
		constexpr ::std::ptrdiff_t dwYawPtr = 0xDBCF48;
		constexpr ::std::ptrdiff_t dwZoomSensitivityRatioPtr = 0xDC31B0;
		constexpr ::std::ptrdiff_t dwbSendPackets = 0xD9722;
		constexpr ::std::ptrdiff_t dwppDirect3DDevice9 = 0xA5050;
		constexpr ::std::ptrdiff_t find_hud_element = 0x2D905200;
		constexpr ::std::ptrdiff_t force_update_spectator_glow = 0x3BB8FA;
		constexpr ::std::ptrdiff_t interface_engine_cvar = 0x3E9EC;
		constexpr ::std::ptrdiff_t is_c4_owner = 0x3C8970;
		constexpr ::std::ptrdiff_t m_bDormant = 0xED;
		constexpr ::std::ptrdiff_t m_flSpawnTime = 0x103C0;
		constexpr ::std::ptrdiff_t m_pStudioHdr = 0x2950;
		constexpr ::std::ptrdiff_t m_pitchClassPtr = 0x5208480;
		constexpr ::std::ptrdiff_t m_yawClassPtr = 0xDBCF48;
		constexpr ::std::ptrdiff_t model_ambient_min = 0x59003C;
		constexpr ::std::ptrdiff_t set_abs_angles = 0x1E5570;
		constexpr ::std::ptrdiff_t set_abs_origin = 0x1E53B0;
	} // namespace signatures
} // namespace hazedumper
```

`SmKernel_Client/SmKernel_Client.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c709148c-21f9-46ad-a801-af29078ffcb3}</ProjectGuid>
    <RootNamespace>SmKernelClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>SMK_CLIENT</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CFunctions.cpp" />
    <ClCompile Include="IKernelInterface.cpp" />
    <ClCompile Include="Main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CFunctions.h" />
    <ClInclude Include="Definitions.h" />
    <ClInclude Include="IKernelInterface.h" />
    <ClInclude Include="Offsets.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SmKernel_Client/SmKernel_Client.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IKernelInterface.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="IKernelInterface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`SmKernel_SYS/CMemory.cpp`:

```cpp
#include "CMemory.h"
#include "Globals.h"


NTSTATUS CMemory::Read(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size) {
	PSIZE_T Bytes;
	NTSTATUS ntStatus = STATUS_SUCCESS;

	KAPC_STATE state;
	KeStackAttachProcess((PKPROCESS)Process, &state);
	Log("[SmKernel]Calling MmCopyVirtualMemory... \n");
	MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, Process, TargetAddress, Size, KernelMode, (PSIZE_T)&Bytes);
	KeUnstackDetachProcess(&state);

	if (!NT_SUCCESS(ntStatus)) {
		Log("[SmKernel]Error Code... %x\n", status);
		Log("[SmKernel]__MmCopyVirtualMemory Error || Process : %p || SourceAddress : %p || PsGetCurrentProcess() : %p || TargetAddress : %p || Size : %x  Bytes : %x \n", Process, SourceAddress, PsGetCurrentProcess, TargetAddress, Size, Bytes);
		return ntStatus;
	}
	else {
		Log("[SmKernel]MmCopyVirtualMemory Success! %x\n", status);
		Log("[SmKernel]Bytes Read : %u \n", Bytes);
	}
}

NTSTATUS CMemory::Write(PEPROCESS ProcessOfTarget, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size, KM_WRITE_REQUEST* pdata) {
	PSIZE_T Bytes;
	NTSTATUS ntStaus = STATUS_SUCCESS;

	Log("[SmKernel]ProcessidOfSource : %u \n", pdata->ProcessidOfSource);

	PEPROCESS ProcessOfSource;
	ntStaus = PsLookupProcessByProcessId((HANDLE)pdata->ProcessidOfSource, &ProcessOfSource);
	if (NT_SUCCESS(ntStaus)) {
		Log("[SmKernel]PsLookupProcessByProcessId has success ProcessOfSource address : %p \n", ProcessOfSource);
	}
	else {
		ntStaus = STATUS_ACCESS_DENIED;
		ObDereferenceObject(ProcessOfSource);
		Log("[SmKernel]PsLookupProcessByProcessId Failed Error code : %p \n", ntStaus);
		return ntStaus;
	}

	KAPC_STATE state;
	KeStackAttachProcess((PKPROCESS)ProcessOfSource, &state);
	Log("[SmKernel]Calling MmCopyVirtualMemory withtin the source context. \n");
	ntStaus = MmCopyVirtualMemory(PsGetCurrentProcess(), SourceAddress, ProcessOfTarget, TargetAddress, Size, KernelMode, (PSIZE_T)&Bytes);
	KeUnstackDetachProcess(&state);


	if (!NT_SUCCESS(ntStaus)) {
		Log("[SmKernel]Error Code... %x\n", ntStaus);
		Log("[SmKernel]MmCopyVirtualMemory_Error =  PsGetCurrentProcess : %p SourceAddress : %p ProcessOfTarget : %p TargetAddress :  %p Size : %x Bytes : %x \n", PsGetCurrentProcess(), SourceAddress, ProcessOfTarget, TargetAddress, Size, Bytes);
	}
	else {
		Log("[SmKernel]MmCopyVirtualMemory Success! %x\n", status);
		Log("[SmKernel]Bytes : %x \n", Bytes);
	}
}

NTSTATUS CMemory::GetPid(void) {
	ULONG CallBackLength = 0;
	PSYSTEM_PROCESS_INFO PSI = NULL;
	PSYSTEM_PROCESS_INFO pCurrent = NULL;
	PVOID BufferPid = NULL;
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

	// Names
	PCWSTR ProcName = L"csgo.exe";
	UNICODE_STRING uImageName;
	RtlInitUnicodeString(&uImageName, ProcName);

	if (!NT_SUCCESS(ZwQuerySystemInformation(SystemProcessInformation, NULL, NULL, &CallBackLength))) {
		BufferPid = ExAllocatePoolWithTag(NonPagedPool, CallBackLength, 0x616b7963); // aykc 
		if (!BufferPid) {
			Log("[SmKernel]Failed To Allocate Buffer Notify Routine");
			return ntStatus;
		}

		PSI = (PSYSTEM_PROCESS_INFO)BufferPid;
		ntStatus = ZwQuerySystemInformation(SystemProcessInformation, PSI, CallBackLength, NULL);
		if (!NT_SUCCESS(ntStatus)) {
			Log("[SmKernel]Failed To Get Query System Process Information List: %p", ntStatus);
			ExFreePoolWithTag(BufferPid, 0x616b7963);
			return ntStatus = STATUS_INFO_LENGTH_MISMATCH;
		}

		do {
			if (PSI->NextEntryOffset == 0)
				break;

			if (RtlEqualUnicodeString(&uImageName, &PSI->ImageName, FALSE)) {
				DbgPrintEx(0, 0, "PID %d | NAME %ws", PSI->ProcessId, PSI->ImageName.Buffer);
				gGamePid = (ULONG)PSI->ProcessId;
				ntStatus = STATUS_SUCCESS;
				break;
			}

			PSI = (PSYSTEM_PROCESS_INFO)((unsigned char*)PSI + PSI->NextEntryOffset);
		} while (PSI->NextEntryOffset);

		// Free Allocated Memory
		ExFreePoolWithTag(BufferPid, 0x616b7963);
	}

	return ntStatus;
}

DWORD CMemory::GetModuleBasex64(PEPROCESS Process, UNICODE_STRING ModuleName) {
	PPEB pPeb = PsGetProcessPeb(proc);

	if (!pPeb) {
		Log("[SmKernel]Error pPeb not found \n");
		return 0; 
	}

	KAPC_STATE state;

	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;

	if (!pLdr) {
		DbgPrintEx(0, 0, "Error pLdr not found \n");
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}



	// loop the linked list
	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->ModuleListLoadOrder.Flink;
		list != &pLdr->ModuleListLoadOrder; list = (PLIST_ENTRY)list->Flink) {
		PLDR_DATA_TABLE_ENTRY pEntry =
			CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &module_name, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}
	DbgPrintEx(0, 0, "Error exiting funcion nothing was found found \n");
	KeUnstackDetachProcess(&state);

	return 0;
}

NTSTATUS CMemory::GetImageBase(PEPROCESS Process) {
	KAPC_STATE State;

	KeStackAttachProcess(Process, &State);
	gBaseAddress = (DWORD64)(DWORD64*)PsGetProcessSectionBaseAddress(Process);
	KeUnstackDetachProcess(&State);

	Log("[SmKernel]Image Found:%p\n", gBaseAddress);

	return STATUS_SUCCESS;
}

NTSTATUS CMemory::GetGameHandle() {
	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	if (gGamePid) {
		ntStatus = PsLookupProcessByProcessId((HANDLE)gGamePid, &gGameProcess);
		if (!NT_SUCCESS(ntStatus)) {
			Log("[SmKernel]PsLookupProcessByProcessId Failed (game PID): %p\n", ntStatus);
			return ntStatus;
		}
	}
	return ntStatus;
}

```

`SmKernel_SYS/CMemory.h`:

```h
#pragma once
#include "CSharedMemory.h"

class CMemory {
public:
	static NTSTATUS Read(PEPROCESS Process, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size);
	static NTSTATUS Write(PEPROCESS ProcessOfTarget, PVOID SourceAddress, PVOID TargetAddress, SIZE_T Size, KM_WRITE_REQUEST* pdata);
	static NTSTATUS GetPid(void);
	static NTSTATUS GetImageBase(PEPROCESS Process);
	static NTSTATUS GetGameHandle();
	static DWORD GetModuleBasex64(PEPROCESS Process, UNICODE_STRING ModuleName);
};


```

`SmKernel_SYS/CSharedMemory.cpp`:

```cpp
#include "CSharedMemory.h"

NTSTATUS CSharedMemory::Create(void)
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ntStatus = RtlCreateSecurityDescriptor(&SecDescriptor, SECURITY_DESCRIPTOR_REVISION);

    if (!NT_SUCCESS(ntStatus)) {
        Log("[SmKernel]RtlCreateSecurityDescriptor failed : %p\n", ntStatus);
        return ntStatus;
    }
    // Get length
    DaclLength = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) * 3 + RtlLengthSid(SeExports->SeLocalSystemSid) + RtlLengthSid(SeExports->SeAliasAdminsSid) +
        RtlLengthSid(SeExports->SeWorldSid);


    // Allocate memory
    Dacl = (PACL)ExAllocatePoolWithTag(PagedPool, DaclLength, 'smkC');

    if (Dacl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
        Log("[SmKernel]RExAllocatePoolWithTag  failed  : %p\n", ntStatus);
    }
    ntStatus = RtlCreateAcl(Dacl, DaclLength, ACL_REVISION);

    if (!NT_SUCCESS(ntStatus)) {
        ExFreePool(Dacl);
        Log("[SmKernel]RtlCreateAcl  failed  : %p\n", ntStatus);
        return ntStatus;
    }
    ntStatus = RtlAddAccessAllowedAce(Dacl, ACL_REVISION, FILE_ALL_ACCESS, SeExports->SeWorldSid);

    if (!NT_SUCCESS(ntStatus)) {
        ExFreePool(Dacl);
        Log("[SmKernel]RtlAddAccessAllowedAce SeWorldSid failed  : %p\n", ntStatus);
        return ntStatus;
    }

	ntStatus = RtlAddAccessAllowedAce(Dacl,
		ACL_REVISION,
		FILE_ALL_ACCESS,
		SeExports->SeAliasAdminsSid);

	if (!NT_SUCCESS(ntStatus)) {
		ExFreePool(Dacl);
		Log("[SmKernel]RtlAddAccessAllowedAce SeAliasAdminsSid failed  : %p\n", ntStatus);
		return ntStatus;
	}

	ntStatus = RtlAddAccessAllowedAce(Dacl,
		ACL_REVISION,
		FILE_ALL_ACCESS,
		SeExports->SeLocalSystemSid);

	if (!NT_SUCCESS(ntStatus)) {
		ExFreePool(Dacl);
		Log("[SmKernel]RtlAddAccessAllowedAce SeLocalSystemSid failed  : %p\n", ntStatus);
		return ntStatus;
	}

	ntStatus = RtlSetDaclSecurityDescriptor(&SecDescriptor,
		TRUE,
		Dacl,
		FALSE);

	if (!NT_SUCCESS(ntStatus)) {
		ExFreePool(Dacl);
		Log("[SmKernel]RtlSetDaclSecurityDescriptor failed  : %p\n", ntStatus);
		return ntStatus;
	}

	OBJECT_ATTRIBUTES objAttr;
	UNICODE_STRING sectionName;
	RtlInitUnicodeString(&sectionName, SharedSectionName);
	InitializeObjectAttributes(&objAttr, &sectionName, OBJ_CASE_INSENSITIVE, NULL, &SecDescriptor);

	if (!NT_SUCCESS(ntStatus)) {
		Log("[SmKernel]Last thing  has failed : %p\n", ntStatus);
	}

	LARGE_INTEGER lMaxSize = { 0 };
	lMaxSize.HighPart = 0;
	lMaxSize.LowPart = 1024 * 10;
	ntStatus = ZwCreateSection(&sectionHandle, SECTION_ALL_ACCESS, &objAttr, &lMaxSize, PAGE_READWRITE, SEC_COMMIT, NULL); 
	if (!NT_SUCCESS(ntStatus)) {
		Log("[SmKernel]ZwCreateSection failed: %p\n", ntStatus);
		return ntStatus;
	}
	
	SIZE_T ulViewSize = 1024 * 10; 
	ntStatus = ZwMapViewOfSection(sectionHandle, NtCurrentProcess(), &SharedSection, 0, ulViewSize, NULL, &ulViewSize, ViewShare, 0, PAGE_READWRITE | PAGE_NOCACHE);
	if (!NT_SUCCESS(ntStatus)) {
		Log("[SmKernel]ZwMapViewOfSection fail! Status: %p\n", ntStatus);
		ZwClose(sectionHandle);
		return ntStatus;
	}

	Log("[SmKernel]CreateSharedMemory called finished \n");

	ExFreePool(Dacl); 

	return ntStatus;
}

void CSharedMemory::Read(void)
{
	if (sectionHandle)
		return;

	if (SharedSection)
		ZwUnmapViewOfSection(NtCurrentProcess(), SharedSection);

	SIZE_T ulViewSize = 1024 * 10;
	NTSTATUS ntStatus = ZwMapViewOfSection(sectionHandle, NtCurrentProcess(), &SharedSection, 0, ulViewSize, NULL, &ulViewSize, ViewShare, 0, PAGE_READWRITE | PAGE_NOCACHE);
	if (ntStatus != STATUS_SUCCESS) {
		Log("[SmKernel]ZwMapViewOfSection fail! Status: %p\n", ntStatus);
		ZwClose(sectionHandle);
		return;
	}
}
```

`SmKernel_SYS/CSharedMemory.h`:

```h
#pragma once
#include "Definitions.h"
class CSharedMemory {
public:
	static NTSTATUS Create(void);
	static void Read(void);
};


```

`SmKernel_SYS/Definitions.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#define _DEBUG

#ifdef _DEBUG
#define Log(x) DbgPrintEx(0, 0, x);
#else
#define Log(x)
#endif // _DEBUG

#define ABSOLUTE(wait) (wait)

#define RELATIVE(wait) (-(wait))

#define NANOSECONDS(nanos) \
(((signed __int64)(nanos)) / 100L)

#define MICROSECONDS(micros) \
(((signed __int64)(micros)) * NANOSECONDS(1000L))

#define MILLISECONDS(milli) \
(((signed __int64)(milli)) * MICROSECONDS(1000L))

#define SECONDS(seconds) \
(((signed __int64)(seconds)) * MILLISECONDS(1000L))

const WCHAR SharedSectionName[] = L"\\BaseNamedObjects\\ShKernel"; //Allocate buffer for name of shared memory


static PVOID	pSharedSection = NULL;
static PVOID	pSectionObj = NULL;
static HANDLE	hSection = NULL;

static SECURITY_DESCRIPTOR SecDescriptor;
static HANDLE sectionHandle;
static PVOID	SharedSection = NULL;
static PVOID	Sharedoutputvar = NULL;
static ULONG DaclLength;
static PACL Dacl; // this is the problem i guess PACL


// trigger loop
static HANDLE  SharedEventHandle_trigger = NULL;
static PKEVENT SharedEvent_trigger = NULL;
static UNICODE_STRING EventName_trigger;


// ReadyRead
static HANDLE  SharedEventHandle_ReadyRead = NULL;
static PKEVENT SharedEvent_ReadyRead = NULL;
static UNICODE_STRING EventName_ReadyRead;

// data arrived
static HANDLE  SharedEventHandle_dt = NULL;
static PKEVENT SharedEvent_dt = NULL;
static  UNICODE_STRING EventName_dt;


typedef struct _KM_READ_REQUEST
{
	ULONG ProcessId;
	UINT_PTR SourceAddress;
	ULONGLONG Size;
	void* Output;

} KM_READ_REQUEST;

// write struct
typedef struct _KM_WRITE_REQUEST
{
	ULONG ProcessId;
	ULONG ProcessidOfSource;
	UINT_PTR SourceAddress;
	UINT_PTR TargetAddress;
	ULONGLONG Size;

} KM_WRITE_REQUEST;

// get module struct
typedef struct _GET_USERMODULE_IN_PROCESS
{
	ULONG pid;
	ULONG64 BaseAddress;
} GET_USERMODULE_IN_PROCESS;



EXTERN_C NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);



EXTERN_C
NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
	IN HANDLE ProcessId,
	OUT PEPROCESS* Process
);


EXTERN_C
NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

EXTERN_C
NTKERNELAPI
PVOID 
PsGetProcessSectionBaseAddress(
	__in PEPROCESS Process
);


EXTERN_C NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);


typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void); // not exported



typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

EXTERN_C
NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
	IN  HANDLE ProcessHandle,
	IN  PROCESSINFOCLASS ProcessInformationClass,
	OUT PVOID ProcessInformation,
	IN  ULONG ProcessInformationLength,
	IN  PULONG ReturnLength
);

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG                   NextEntryOffset;
	ULONG                   NumberOfThreads;
	LARGE_INTEGER           Reserved[3];
	LARGE_INTEGER           CreateTime;
	LARGE_INTEGER           UserTime;
	LARGE_INTEGER           KernelTime;
	UNICODE_STRING          ImageName;
	ULONG                   BasePriority;
	HANDLE                  ProcessId;
	HANDLE                  InheritedFromProcessId;
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	UCHAR Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _PEB
{
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;
```

`SmKernel_SYS/Driver.cpp`:

```cpp
#include "CMemory.h"
#include "Globals.h"

NTSTATUS Init(void)  {
	NTSTATUS ntStatus = STATUS_SUCCESS;

	RtlInitUnicodeString(&EventName_dt, L"\\BaseNamedObjects\\DataArrived");
	SharedEvent_dt = IoCreateNotificationEvent(&EventName_dt, &SharedEventHandle_dt);
	if (SharedEvent_dt == NULL) {
		Log("[SmKernel]Error! \n", ntStatus);
		return STATUS_UNSUCCESSFUL;
	}

	RtlInitUnicodeString(&EventName_trigger, L"\\BaseNamedObjects\\trigger");
	SharedEvent_trigger = IoCreateNotificationEvent(&EventName_trigger, &SharedEventHandle_trigger);
	if (SharedEvent_trigger == NULL) {
		Log("[SmKernel]Error! \n", ntStatus);
		return STATUS_UNSUCCESSFUL;
	}


	RtlInitUnicodeString(&EventName_ReadyRead, L"\\BaseNamedObjects\\ReadyRead");
	SharedEvent_ReadyRead = IoCreateNotificationEvent(&EventName_ReadyRead, &SharedEventHandle_ReadyRead);
	if (SharedEvent_ReadyRead == NULL) {
		Log("[SmKernel]Error! \n", ntStatus);
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS DriverLoop(void) {
	while (true) {
		Log("[SmKernel]Waitting for command...")
		CSharedMemory::Read();
		if (strcmp((PCHAR)SharedSection, "Stop") == 0) {
			Log("[SmKernel]Stoping...\n");
			break;
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Write") == 0) {
			Log("[SmKernel]Writing memory loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			CSharedMemory::Read();


			KM_WRITE_REQUEST* WriteInput = (KM_WRITE_REQUEST*)SharedSection;
			PEPROCESS Process;
			NTSTATUS ntStatus = STATUS_SUCCESS;

			ntStatus = PsLookupProcessByProcessId((HANDLE)WriteInput->ProcessId, &Process);
			if (NT_SUCCESS(ntStatus)) {
				Log("[SmKernel]PsLookupProcessByProcessId has success! : %p \n", ntStatus);
				Log("[SmKernel]Writing memory.\n");
				CMemory::Write(Process, (PVOID)WriteInput->SourceAddress, (PVOID)WriteInput->TargetAddress, WriteInput->Size, WriteInput);
			}
			else {
				ntStatus = STATUS_ACCESS_DENIED;
				ObDereferenceObject(Process);
				Log("[SmKernel]PsLookupProcessByProcessId Failed Error code : %p \n", ntStatus);
				return ntStatus;
			}

			KeResetEvent(SharedEvent_dt);
			KeSetEvent(SharedEvent_trigger, 0, FALSE);
			break;
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "Read") == 0) {
			Log("[SmKernel]Read memory loop is running\n");

			KeSetEvent(SharedEvent_dt, 0, FALSE);


			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			CSharedMemory::Read();


			KM_READ_REQUEST* ReadInput = (KM_READ_REQUEST*)SharedSection;
			void* ReadOutput = NULL;
			PEPROCESS Process;
			NTSTATUS Status = STATUS_SUCCESS;

			Log("[SmKernel]ReadInput : %p PID : %u SourceAddress : %p ReadOutput : %p Size : %x \n", ReadInput, ReadInput->ProcessId, ReadInput->SourceAddress, ReadOutput, ReadInput->Size);
			Log("[SmKernel](Before mmcopyvirtualmemory) ReadOutput : %p \n", ReadOutput);

			Status = PsLookupProcessByProcessId((PVOID)ReadInput->ProcessId, &Process);
			if (NT_SUCCESS(Status)) {
				Log("[SmKernel]PsLookupProcessByProcessId has success! : %p \n", Status);
				Log("[SmKernel]ReadKernelMemory will be called now !.\n");
				CMemory::Read(Process, (PVOID)ReadInput->SourceAddress, &ReadOutput, ReadInput->Size);
			}
			else {
				Status = STATUS_ACCESS_DENIED;
				ObDereferenceObject(Process);
				Log("[SmKernel]PsLookupProcessByProcessId Failed Error code : %p \n", Status);
				return Status;
			}

			ReadInput->Output = ReadOutput;

			CSharedMemory::Read();
			if (0 == memcpy(SharedSection, ReadInput, sizeof(KM_READ_REQUEST))) {
				Log("[SmKernel]memcpy failed \n");
			}


			KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
			KeSetEvent(SharedEvent_trigger, 0, FALSE);
			break;
		}

		while (!(PCHAR)SharedSection == NULL && strcmp((PCHAR)SharedSection, "getBase") == 0) {
			KeSetEvent(SharedEvent_dt, 0, FALSE);

			LARGE_INTEGER Timeout;
			Timeout.QuadPart = RELATIVE(SECONDS(1));
			KeDelayExecutionThread(KernelMode, FALSE, &Timeout);
			CSharedMemory::Read();


			GET_USERMODULE_IN_PROCESS* GetBase = (GET_USERMODULE_IN_PROCESS*)SharedSection;

			NTSTATUS ntStatus = STATUS_SUCCESS;
			PEPROCESS TargetProcess;
			ntStatus = PsLookupProcessByProcessId((HANDLE)GetBase->pid, &TargetProcess);
			if (!NT_SUCCESS(ntStatus)) {
				Log("[SmKernel]PsLookupProcessByProcessId failed\n");
			}
			Log("[SmKernel]PsLookupProcessByProcessId Success!\n");

			UNICODE_STRING DLLName;
			RtlInitUnicodeString(&DLLName, L"client.dll");
			GetBase->BaseAddress = CMemory::GetModuleBasex64(TargetProcess, DLLName);


			Log("[SmKernel]GetBase->BaseAddress is : %p \n", GetBase->BaseAddress);

			CSharedMemory::Read();

			if (0 == memcpy(SharedSection, GetBase, sizeof(GET_USERMODULE_IN_PROCESS))) {
				Log("[SmKernel]memcpy failed \n");
			}

			KeSetEvent(SharedEvent_ReadyRead, 0, FALSE);
			KeResetEvent(SharedEvent_dt);
			KeResetEvent(SharedEvent_ReadyRead);
		}
	}
}

void DriverUnload(PDRIVER_OBJECT pDriverObject) {
	Log("[SmKernel]Driver Unloaded!");

	if (SharedSection)
		ZwUnmapViewOfSection(NtCurrentProcess(), SharedSection);

	if (sectionHandle)
		ZwClose(sectionHandle);

	Log("[SmKernel]DriverUnload complete!");
}

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPath)  {
	NTSTATUS ntStatus = STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(pRegistryPath);


	Log("[SmKernel]Driver loaded !!\n");

	pDriverObject->DriverUnload = DriverUnload;

	CSharedMemory::Create();

	Init();

	DriverLoop();

	Log("[SmKernel]Driver entry completed!\n");

	return STATUS_SUCCESS;
}

```

`SmKernel_SYS/Globals.h`:

```h
#include "Definitions.h"

static ULONG		gGamePid = 0;
static DWORD64		gKernelBase = NULL;
static DWORD64		gBaseAddress = NULL;
static PEPROCESS	gGameProcess = NULL;
```

`SmKernel_SYS/SmKernel_SYS.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{72E13FEA-C568-4D02-AEB7-BFECDE71E89B}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>SmKernel_SYS</RootNamespace>
    <ProjectName>SMK_SYS</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CMemory.cpp" />
    <ClCompile Include="CSharedMemory.cpp" />
    <ClCompile Include="Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CMemory.h" />
    <ClInclude Include="CSharedMemory.h" />
    <ClInclude Include="Definitions.h" />
    <ClInclude Include="Globals.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SmKernel_SYS/SmKernel_SYS.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CSharedMemory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CMemory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Definitions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CSharedMemory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CMemory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```