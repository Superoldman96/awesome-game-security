Project Path: arc_gmh5225_dwex_dlpepz_a

Source Tree:

```txt
arc_gmh5225_dwex_dlpepz_a
├── README.md
├── docs
│   └── expressions.md
├── dwex
│   ├── __init__.py
│   ├── __main__.py
│   ├── cookie.py
│   ├── crash.py
│   ├── details.py
│   ├── die.py
│   ├── dwarfone.py
│   ├── dwarfutil.py
│   ├── exprutil.py
│   ├── formats.py
│   ├── locals.py
│   ├── locs.py
│   ├── patch.py
│   ├── ranges.py
│   ├── scriptdlg.py
│   ├── tree.py
│   └── ui.py
├── dwex.psp
├── dwex.py
├── make.cmd
├── msi
│   └── make.cmd
├── refresh.cmd
├── setup.cfg
├── setup.py
└── test
    ├── intest.py
    └── testall.py

```

`README.md`:

```md
DWARF Explorer
==============

A cross-platform GUI utility for visualizing the DWARF
debugging information in executable files, built on top of [pyelftools](https://github.com/eliben/pyelftools) and [filebytes](https://github.com/sashs/filebytes). Runs on Windows, MacOS X, and Linux. Supports parsing the following file types for DWARF data:
 - ELF (Linux, Android)
 - Mach-O (MacOS X, iOS)
 - PE (Windows, Cygwin)
 - WASM (aka WebAssembly)

This project came from my desire to see and navigate the DWARF tree of compiled Android and iOS binaries. Seeing the DIEs is easy enough with utilities like `readelf` or `dwarfdump`. However, chasing inter-DIE references back and forth is not straightforward with those.

The utility might be of use for anyone who is building DWARF parsers for one or another reason, especially if their preferred parsing library is `pyelftools`.

Note that regular Windows executables (EXE/DLL files) are PE files but don't, as a rule, contain DWARF information. The Microsoft toolchains (Visual Studio and the like) produce debugging information in Microsoft's own format, Program Database (PDB). There are, though, a couple of toolchains that produce PE files with DWARF debug info in them - notably GCC under Cygwin. DWARF Explorer is compatible with those.

The pyelftools library that dwex is based on supports DWARF versions 2-5, and so does dwex. DWARFv5 support might be unstable. DWARF v1 is supported experimentally, in ELF files only.

Requirements and Dependencies
------------
 - Python 3.6.1+
 - PyQt6
 - filebytes 0.10.1+
 - pyelftools 0.30+

Installation
-------------

If necessary, install [the latest Python](https://www.python.org/downloads/) in the way that's appropriate for your OS. Run `pip install dwex` from the command line, under `sudo` or elevated command line if necessary.

On Windows, if `pip` and/or Python is not in PATH, use `c:\Python39\python -m pip install dwex`, substituting your own path to Python 3.

Alternatively, get the dwex source tree from Github, and run `python setup.py install` in the root folder of the package. In this scenario, you'd have to install the dependencies separately - with `pip install pyqt6 filebytes pyelftools`.

On Linux, sometimes the `python` command defaults to Python 2 while Python 3 is installed side by side. In this case, use `python3` and `pip3`, respectively. Use `python -V` to check.

Once you install it, there will be a `dwex` command. On Windows, there will be a `dwex.exe` in the `Scripts` folder under the Python folder, and also a start menu item "DWARF Explorer". On Linux, there
will be a "DWARF Explorer" in the app menu (tested under GNOME).

In January 2022, the utility was migrated from PyQt5 to PyQt6, and the major version was bumped to 2. That cut off support for Python 3.5. The 1.x version that is compatible with Python 3.5 is still out in the repository, and pip should resolve it. 
If it does not, install by running `pip install "dwex<2"`.

Usage
-----

Click Open in the File menu, choose your executable, and eyeball the DWARF tree. Alternatively, drag and drop an executable onto the main window. You can open by dropping a dSYM bundle folder, too.

On the most basic level, the debug information in a compiled file is an array of *compilation units* (CUs). Each CU contains a tree of data items called *Debugging Information Entries* (DIEs). Each DIE has a title called *tag*, and contains a name-value dictionary called *attributes*. Each CU has exactly one root DIE, and the rest of the DIEs are in its subtree.

The UI of DWARF Explorer was meant for eyeballing that data structure:

![dwex](https://user-images.githubusercontent.com/5807738/77756810-510ad300-7006-11ea-8d97-b7c109d050b1.png)

The left hand tree displays the DIEs, with CU root DIEs on the top level. Expand the tree and click on DIEs to see their attributes. DIE attributes that have a substructure or point at larger data structures are clickable.

DIEs generally correspond to source level entities in the program - variables, functions, classes, members, methods, etc. The DIE tag tells you which one is it. The exact way the compiler builds a DIE tree to describe the program varies between source languages, compiler versions, target platforms and architectures. The official home of the DWARF spec is at [dwarfstd.org](http://dwarfstd.org/), but there's considerable leeway for implementations to improvise upon. On top of that, the DWARF spec contains explicit extension points for compiler vendors to tap into.

DIE attribute values are relatively small scalars - integers, strings, sometimes short byte arrays. However, they sometimes refer at larger data structures. Physically, it's an integer, but logically, it's a pointer to some data elsewhere. Also, DIE attribute values may contain references to other DIEs - for example, a DIE for a variable would contain a reference to a DIE that describes its datatype. DIE attributes that contain references to other DIEs are rendered in blue; the link can be followed by a double-click or a Ctrl+Enter. To come back to the original DIE, use Navigate/Back, the Back mouse button, or an appropriate keyboard shortcut (Alt-Left on Windows and Linux, Ctrl-[ on Mac).

In DWARF, tag and attribute names are prefixed with `DW_TAG_` and `DW_AT_`, respectively. DWARF Explorer elides those by default to reduce visual clutter. Use `View/DWARF prefix` in the menu to bring them back.

Disclaimer
----------

This project is unrelated to [ragundo/DwarfExplorer](https://github.com/ragundo/DwarfExplorer). That one deals with a different kind of dwarves. Although, interestingly enough, they also use the Qt library for their GUI.

Prior art
---------

There is also a GUI DWARF visualizer at [simark/dwarftree](https://github.com/simark/dwarftree). Also based on pyelftools,
with gtk based UI. It's been inactive since 2015. I didn't know about it when I started.

```

`docs/expressions.md`:

```md
# About Python expressions in DWEX

The "search by condition" and "highlight by condition" features of DWEX invite the user
to provide a Python expression to search or highlight the DIEs in the tree.
The expression has to be written in the Python 3, and **it should evaluate to some kind of an object**. Python distinguishes between expressions and statements. The `return` in the expression is not allowed - that would make it a statement. The result of the expression will be interpreted as a boolean according to the Python rules - if it evaluates to `True`, the respective DIE will be found or highlighted. If the expression raises an error, that is interpreted as a `False`, and the respective DIE won't be found or highlighted.

# Expression execution environment

During search or checking for highlighting, the exression is evaluated against every DIE in the tree. During execution, the expression receives a set of current DIE's properties to examine as global scope variables.

The `tag` object contains the DIE tag's name as a string, with the `DW_TAG_` prefix removed (regardless of the "DWARF Prefix" setting), in lowercase, e. g. `variable` or `subprogram`.

Each DIE attribute is provided as a separate object, their names being attribute names with the `DW_AT_` prefix removed (regardless of the "DWARF Prefix" setting), in lowercase, e. g. `name` or `type`,
and their values are attribute values, somewhat translated by pyelftools for usability. DIE attribute values that are logically strings are stored as `bytes` objects, not as proper Python strings. One may use `.decode('utf-8')` to convert them to strings, or compare them to `bytes` literals, e. g. `b'foo'`. Enum-type attributes such as `DW_AT_language` are provided as `int`s.

For deeper examination, DWEX also provides a dictionary of all attributes in an object called `attr`,
and the DIE itself as the `die` object. You can use `die` to get to the parent/child/sibling DIEs, you can get to the containing CU and to other CUs. This guide is not meant to be a complete reference, especially considering that it's someone else's API; refer to the [pyelftools](https:/github.com/eliben/pyelftools/) docs and/or sources for more.
 
The expression can use Python's built-ins in the default global scope, but can't import modules.
```

`dwex.py`:

```py
# For running interactively from the sources
from dwex.__main__ import main
main()
```

`dwex/__main__.py`:

```py
import sys, os
from PyQt6.QtCore import Qt, QModelIndex, QSettings, QUrl, QEvent
from PyQt6.QtGui import QFontMetrics, QDesktopServices, QWindow
from PyQt6.QtWidgets import *
from .die import DIETableModel
from .formats import read_dwarf, get_debug_sections, FormatError
from .dwarfutil import has_code_location, ip_in_range
from .tree import DWARFTreeModel, cu_sort_key
from .scriptdlg import ScriptDlg, make_execution_environment
from .ui import setup_ui
from .locals import LocalsDlg

# Sync with version in setup.py
version = (3, 23)

# TODO:
# On MacOS, start without a main window, instead show the Open dialog

#-----------------------------------------------------------------
# The one and only main window class
# Pretty much DWARF unaware, all the DWARF visualization logic is in tree.py and die.py
#-----------------------------------------------------------------

# "Opened, could not parse"
class DWARFParseError(Exception):
    def __init__(self, exc, di):
        Exception.__init__(self, "DWARF parsing error: " + format(exc))
        self.dwarfinfo = di

class TheWindow(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        self.in_tree_nav = False
        self.font_metrics = QFontMetrics(QApplication.font())

        self.load_settings()
        setup_ui(self)
        self.setAcceptDrops(True)

        # The data model placeholders - to be populated once we read a file
        self.tree_model = None # Recreated between files
        self.die_model = None # Reused between DIEs

        self.findcondition = None
        self.findcucondition = None

        self.show()

        # Command line: if can't open, print the error to console
        # On Mac/Linux, the user will see it. On Windows, they won't.
        if len(sys.argv) > 1:
            try:
                if self.open_file(sys.argv[1]) is None:
                    print("The file contains no DWARF information, or it is in an unsupported format.")
            except Exception as exc:
                print(format(exc))

    def load_settings(self):
        self.sett = QSettings('Seva', 'DWARFExplorer')
        self.prefix = self.sett.value('General/Prefix', False, type=bool)
        self.lowlevel = self.sett.value('General/LowLevel', False, type=bool)
        self.hex = self.sett.value('General/Hex', False, type=bool)
        self.sortcus = self.sett.value('General/SortCUs', True, type=bool)
        self.sortdies = self.sett.value('General/SortDIEs', False, type=bool)
        self.dwarfregnames = self.sett.value('General/DWARFRegNames', False, type=bool)
        self.mru = []
        for i in range(0, 10):
            f = self.sett.value("General/MRU%d" % i, False)
            if f:
                arch = self.sett.value("General/MRUArch%d" % i, None)
                fa = (f,) if arch is None else (f,arch) 
                self.mru.append(fa)        

    ###################################################################
    # Done with init, now file stuff
    ###################################################################

    # Callback for the Mach-O fat binary opening logic
    # Taking a cue from Hopper or IDA, we parse only one slice at a time
    def resolve_arch(self, arches):
        r = QInputDialog.getItem(self, 'Mach-O Fat Binary', 'Choose an architecture:', arches, 0, False, Qt.WindowType.Dialog)
        return arches.index(r[0]) if r[1] else None
    
    # Can throw an exception
    # Returns None if it doesn't seem to contain DWARF
    # False if the user cancelled
    # True if the DWARF tree was loaded
    def open_file(self, filename, arch = None):
        self.start_wait()
        try:
            di = read_dwarf(filename, self.resolve_arch if arch is None else lambda arches: arches.index(arch))
            if not di: # Covers both False and None
                return di
            
            # Some degree of graceful handling of wrong format
            try:
                # Some cached top level stuff
                # Notably, iter_CUs doesn't cache
                di._ranges = None # Loaded on first use
                di._aranges = None
                def decorate_cu(cu, i):
                    cu._i = i
                    cu._lineprogram = None
                    cu._exprparser = None
                    return cu
                di._unsorted_CUs = [decorate_cu(cu, i) for (i, cu) in enumerate(di.iter_CUs())] # We'll need them first thing, might as well load here
                if not len(di._unsorted_CUs):
                    return None # Weird, but saw it once - debug sections present, but no CUs
                # For quick CU search by offset within the info section, regardless of sorting
                di._CU_offsets = [cu.cu_offset for cu in di._unsorted_CUs]
                di._CUs = list(di._unsorted_CUs)

                if self.sortcus:
                    di._CUs.sort(key = cu_sort_key)
                    for (i, cu) in enumerate(di._CUs):
                        cu._i = i
                di._locparser = None # Created on first use

                self.dwarfinfo = di
                self.filename = filename
                self.tree_model = DWARFTreeModel(di, self.prefix, self.sortcus, self.sortdies)
                self.the_tree.setModel(self.tree_model)
                self.the_tree.selectionModel().currentChanged.connect(self.on_tree_selection)
                s = os.path.basename(filename)
                if arch is not None:
                    s += ' (' + arch + ')'
                self.setWindowTitle("DWARF Explorer - " + s)
                self.savesection_menuitem.setEnabled(True)
                self.back_menuitem.setEnabled(False)
                self.back_tbitem.setEnabled(False)
                self.forward_menuitem.setEnabled(False)
                self.forward_tbitem.setEnabled(False)
                self.followref_menuitem.setEnabled(False)
                self.followref_tbitem.setEnabled(False)
                self.highlightcode_menuitem.setEnabled(True)
                self.highlightsubstring_menuitem.setEnabled(True)
                self.highlightcondition_menuitem.setEnabled(True)
                self.highlightnothing_menuitem.setEnabled(True)
                self.copy_menuitem.setEnabled(False)
                self.copy_tbitem.setEnabled(False)
                self.copyline_menuitem.setEnabled(False)
                self.copytable_menuitem.setEnabled(False)
                self.findbycondition_menuitem.setEnabled(True)
                self.find_menuitem.setEnabled(True)
                self.find_tbitem.setEnabled(True)
                self.findip_menuitem.setEnabled(True)
                self.byoffset_menuitem.setEnabled(True)
                self.byoffset_tbitem.setEnabled(True)
                self.localsat_menuitem.setEnabled(True)
                self.on_highlight_nothing()
                # Navigation stack - empty
                self.navhistory = []
                self.navpos = -1
                self.save_filename_in_mru(filename, di._fat_arch if '_fat_arch' in dir(di) and di._fat_arch else None)
                LocalsDlg.reset(di)
                from .crash import set_binary_desc
                set_binary_desc(("ELF", "MachO", "PE", "WASM")[di._format] + " " + di.config.machine_arch)
                return True
            except AssertionError as ass: # Covers exeptions during parsing
                raise DWARFParseError(ass, di)
        finally:
            self.end_wait()

    def save_mru(self):
        for i, fa in enumerate(self.mru):
            self.sett.setValue("General/MRU%d" % i, fa[0])    
            if len(fa) > 1:
                self.sett.setValue("General/MRUArch%d" % i, fa[1])
            else:
                self.sett.remove("General/MRUArch%d" % i)
        for i in range(len(self.mru), 10):
            self.sett.remove("General/MRU%d" % i)
            self.sett.remove("General/MRUArch%d" % i)

    # Open a file, display an error if failure
    def open_file_interactive(self, filename, arch = None):
        try:
            if self.open_file(filename, arch) is None:
                if os.path.isdir(filename):
                    s = "The directory (bundle) could not be resolved to a DWARF containing file, or the file contains no DWARF information. Try navigating inside and open the executable file directly."
                else:
                    s = "The file contains no DWARF information, or it is in an unsupported format."
                QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", s,
                    QMessageBox.StandardButton.Ok, self).show()
        except FormatError as ferr:
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer",
                str(ferr), QMessageBox.StandardButton.Ok, self).show()
        except DWARFParseError as dperr:
            mb = QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                "Error parsing the DWARF information in this file. Would you like to save the debug section contents for manual analysis?",
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self)
            mb.setEscapeButton(QMessageBox.StandardButton.No)
            r = mb.exec()
            if r == QMessageBox.StandardButton.Yes:
                self.save_sections(filename, dperr.dwarfinfo)
        except Exception as exc:
            QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                "Error opening the file:\n\n" + format(exc),
                QMessageBox.StandardButton.Ok, self).show()
            
    def save_sections(self, filename, di):
        dir = QFileDialog.getExistingDirectory(self, "Choose a save location", os.path.dirname(filename))
        if dir:
            sections = get_debug_sections(di)
            basename = os.path.basename(filename)
            overwrite_all = False
            for (name, section) in sections.items():
                try:
                    section_file = os.path.join(dir, basename + '.' + name)
                    skip = False
                    if os.path.exists(section_file) and not overwrite_all:
                        mb = QMessageBox(QMessageBox.Icon.Question, "DWARF Explorer",
                            "File %s exists, overwrite?" % section_file,
                            QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.YesAll|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel, self)
                        mb.setEscapeButton(QMessageBox.StandardButton.Cancel)
                        r = mb.exec()
                        if r == QMessageBox.StandardButton.Cancel:
                            return
                        elif r == QMessageBox.StandardButton.YesAll:
                            overwrite_all = True
                        elif r == QMessageBox.StandardButton.No:
                            skip = True
                    if not skip:
                        with open(section_file, 'wb') as f:
                            f.write(section.stream.getbuffer())
                except:
                    pass

    # TODO: list the extensions for the open file dialog?
    def on_open(self):
        dir = os.path.dirname(self.mru[0][0]) if len(self.mru) > 0 else ''
        filename = QFileDialog.getOpenFileName(self, None, dir)
        if filename[0]:
            self.open_file_interactive(os.path.normpath(filename[0]))

    def populate_mru_menu(self):
        class MRUHandler(object):
            def __init__(self, fa, win):
                object.__init__(self)
                self.fa = fa
                self.win = win
            def __call__(self):
                fa = self.fa
                if os.path.exists(self.fa[0]):
                    self.win.open_file_interactive(*fa)
                else:
                    mb =  QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                        "The file or bundle %s does not exist or is not accessible. Shall we remove it from the recent file menu?" % (fa[0],),
                        QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self.win)
                    mb.setEscapeButton(QMessageBox.StandardButton.No)
                    r = mb.exec()
                    if r == QMessageBox.StandardButton.Yes:
                        self.win.delete_from_mru(fa)

        for i, fa in enumerate(self.mru):
            s = fa[0]
            if len(fa) > 1:
                s += ' (' + fa[1] + ')'
            self.mru_menu.addAction(s).triggered.connect(MRUHandler(fa, self))

    def save_filename_in_mru(self, filename, arch = None):
        mru_record = (filename,) if arch is None else (filename, arch)
        try:
            i = self.mru.index(mru_record)
        except ValueError:
            i = -1
        if i != 0:
            if i > 0:
                self.mru.pop(i)
            self.mru.insert(0, mru_record)
            if len(self.mru) > 10:
                self.mru = self.mru[0:10]
            self.save_mru()
            self.mru_menu.setEnabled(True)
            self.mru_menu.clear()
            self.populate_mru_menu()

    def delete_from_mru(self, mru_record):
        try:
            self.mru.remove(mru_record) # ValueError if not found
            self.save_mru()
            self.mru_menu.setEnabled(len(self.mru) > 0)
            self.mru_menu.clear()
            self.populate_mru_menu()
        except ValueError:
            pass

    # File drag/drop handling - equivalent to open
    def dragEnterEvent(self, evt):
        if evt.mimeData() and evt.mimeData().hasUrls() and len(evt.mimeData().urls()) == 1:
            evt.accept()

    def dropEvent(self, evt):
        self.open_file_interactive(os.path.normpath(evt.mimeData().urls()[0].toLocalFile()))

    # Save sections as
    def on_savesection(self):
        di = self.dwarfinfo
        # Maps display name to field name in DWARFInfo
        sections = get_debug_sections(di)
        
        names = sections.keys()
        r = QInputDialog.getItem(self, 'Save a Section', 'Choose a section:', names, 0, False, Qt.WindowType.Dialog)
        if r[1]:
            section_name = r[0]
            r = QFileDialog.getSaveFileName(self, "Save a section", self.filename + '.' + section_name)
            if r[0]:
                try:
                    section = sections[section_name]
                    with open(r[0], 'wb') as f:
                        # Assumes the section is a BytesIO - implementation dependent
                        f.write(section.stream.getbuffer())
                except Exception as exc:
                    QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer",
                        "Error saving the section data:\n\n" + format(exc),
                        QMessageBox.StandardButton.Ok, self).show()

    #############################################################
    # Done with file stuff, now tree navigation
    #############################################################     

    # Index is a tree index - the DIE is the data object within
    def display_die(self, index):
        die = index.internalPointer()
        die_table = self.die_table
        if not self.die_model:
            self.die_model = DIETableModel(die, self.prefix, self.lowlevel, self.hex, self.dwarfregnames)
            die_table.setModel(self.die_model)
            die_table.selectionModel().currentChanged.connect(self.on_attribute_selection)
        else:
            self.die_model.display_DIE(die)
        self.die_table.resizeColumnsToContents()
        self.details_table.setModel(None)
        self.followref_menuitem.setEnabled(False)
        self.followref_tbitem.setEnabled(False)
        self.cuproperties_menuitem.setEnabled(True)
        self.die_table.setCurrentIndex(QModelIndex()) # Will cause on_attribute_selection

        #TODO: resize the attribute table vertically dynamically
        #attr_count = self.die_model.rowCount(None)
        #die_table.resize(die_table.size().width(),
        #    die_table.rowViewportPosition(attr_count-1) + 
        #        die_table.rowHeight(attr_count-1) +
        #        die_table.horizontalHeader().size().height() + 1 + attr_count)
        #self.rpane_layout.update()

    # Invoked for tree clicks and keyboard navigation, ref follow, back-forward
    def on_tree_selection(self, index, prev = None):
        if not self.in_tree_nav: # Short out the history population logic for back-forward clicks
            navitem = self.tree_model.get_navitem(index)
            if navitem: # Weird, should never happen - yet #1473
                self.navhistory[0:self.navpos] = [navitem]
                self.navpos = 0
                self.back_menuitem.setEnabled(len(self.navhistory) > 1)
                self.back_tbitem.setEnabled(len(self.navhistory) > 1)
                self.forward_menuitem.setEnabled(False)
                self.forward_tbitem.setEnabled(False)
        self.display_die(index) # Will clear the selection in the attribute table

    # Selection changed in the DIE table - either user or program
    def on_attribute_selection(self, index, prev = None):
        if index.isValid():
            details_model = self.die_model.get_attribute_details(index)
            self.details_table.setModel(details_model)
            if details_model is not None:
                self.details_table.resizeColumnsToContents()
                self.details_warning.setVisible(details_model.warning is not None)
                if details_model.warning is not None:
                    self.details_warning.setText(details_model.warning)
            else:
                self.details_warning.setVisible(False)
            self.followref_menuitem.setEnabled(self.die_model.ref_target(index) is not None)
            self.followref_tbitem.setEnabled(self.die_model.ref_target(index) is not None)
            self.copy_menuitem.setEnabled(True)
            self.copy_tbitem.setEnabled(True)
            self.copyline_menuitem.setEnabled(True)
            self.copytable_menuitem.setEnabled(True)
        else: # Selected nothing
            self.details_table.setModel(None)
            self.copy_menuitem.setEnabled(False)
            self.copy_tbitem.setEnabled(False)
            self.copyline_menuitem.setEnabled(False)
            self.copytable_menuitem.setEnabled(False)            
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)


    def on_attribute_dclick(self, index):
        self.followref(index)

    # For both back and forward, delta=1 for back, -1 for forward
    # Checked because back-forward buttons can't be disabled
    def on_nav(self, delta):
        if self.tree_model: # Maybe fix for #1461? Short out nav if no file loaded
            np = self.navpos + delta
            if np < 0 or np >= len(self.navhistory):
                return
            self.navpos = np
            navitem = self.navhistory[np]
            tree_index = self.tree_model.index_for_navitem(navitem)
            self.in_tree_nav = True
            self.the_tree.setCurrentIndex(tree_index) # Causes on_tree_selection internally
            self.in_tree_nav = False
            self.back_menuitem.setEnabled(np < len(self.navhistory) - 1)
            self.back_tbitem.setEnabled(np < len(self.navhistory) - 1)
            self.forward_menuitem.setEnabled(np > 0)
            self.forward_tbitem.setEnabled(np > 0)

    def followref(self, index = None):
        self.start_wait() # TODO: only show the wait cursor if it's indeed time consuming
        if index is None:
            index = self.die_table.currentIndex()
        navitem = self.die_model.ref_target(index)  # Retrieve the ref target from the DIE model...
        if navitem:
            target_tree_index = self.tree_model.index_for_navitem(navitem) # ...and feed it to the tree model.
            if target_tree_index:
                self.the_tree.setCurrentIndex(target_tree_index) # Calls on_tree_selection internally
        self.end_wait()

    # Called for double-click on a reference type attribute, and via the menu
    def on_followref(self):
        self.followref()

    # Back-forward mouse buttons are shortcuts for back/forward navigation
    # Qt docs claim capturing is not necessary
    #def mouseReleaseEvent(self, evt):
    #    QMainWindow.mouseReleaseEvent(self, evt)
    #    b = evt.button()
    #    if b == Qt.MouseButton.BackButton:
    #        self.on_nav(1)
    #    elif b == Qt.MouseButton.ForwardButton:
    #        self.on_nav(-1)
        

    ##########################################################################
    # Find/Find next stuff
    ##########################################################################

    def findbytext(self, die, s):
        for k in die.attributes.keys():
            attr = die.attributes[k]
            v = attr.value
            f = attr.form
            all = "\n".join((str(v), str(k), f, hex(v) if isinstance(v, int) else '')).lower()
            if all.find(s) >= 0:
                return True
        return False

    # Exception means false
    def eval_user_condition(self, cond, die):
        try:
            env = make_execution_environment(die)
        except Exception as exc: # Our error
            from .crash import report_crash
            from inspect import currentframe
            report_crash(exc, exc.__traceback__, version, currentframe())
            return False
        try:
            return eval(cond, env)
        except Exception as exc: # Error in condition or it assumes a different DIE structure 
            print("Error in user condition: %s" % format(exc))
            return False

    def on_find(self):
        r = QInputDialog.getText(self, 'Find', 'Find what:')
        if r[1] and r[0]:
            s = r[0].lower()
            self.findcondition = lambda die: self.findbytext(die, s)
            self.findcucondision = None
            self.findnext_menuitem.setEnabled(True)
            self.on_findnext()

    def on_findip(self):
        start_address = hex(self.dwarfinfo._start_address) if not self.dwarfinfo._start_address is None else "its preferred address"
        r = QInputDialog.getText(self, "Find code address", "Code address (hex), assuming the module is loaded at %s:" % start_address)
        if r[1] and r[0]:
            try:
                ip = r[0]
                if r[0].startswith("0x"):
                    ip = ip[2:]
                ip = int(ip, 16)
                self.findcondition = lambda die: ip_in_range(die, ip)
                self.findcucondition = lambda cu: ip_in_range(cu.get_top_DIE(), ip)
                self.findnext_menuitem.setEnabled(True)
                self.on_findnext()            
            except ValueError:
                pass

    def on_byoffset(self):
        r = QInputDialog.getText(self, "Find DIE by offset", "DIE offset (hex), relative to the section start:")
        if r[1] and r[0]:
            try:
                offset = int(r[0], 16)
                index = self.tree_model.find_offset(offset)
                if index:
                    self.the_tree.setCurrentIndex(index)
                else:
                    QMessageBox(QMessageBox.Icon.Warning, "DwARF Explorer", "The specified offset was not found. It could be beyond the section size, or fall into a CU header area.",
                        QMessageBox.StandardButton.Ok, self)
            except ValueError:
                pass

    def sample_die(self):
        return self.the_tree.currentIndex().internalPointer() or self.dwarfinfo._CUs[0].get_top_DIE()

    def on_findbycondition(self):
        dlg = ScriptDlg(self, self.sample_die())
        if dlg.exec() == QDialog.DialogCode.Accepted:
            cond = dlg.cond
            self.findcondition = lambda die: self.eval_user_condition(cond, die)
            self.findcucondition = None
            self.findnext_menuitem.setEnabled(True)
            self.on_findnext()

    def on_findnext(self):
        index = self.tree_model.find(self.the_tree.currentIndex(), self.findcondition, self.findcucondition)
        if index:
            self.the_tree.setCurrentIndex(index)

    ##########################################################################
    ##########################################################################

    def on_about(self):
        QMessageBox(QMessageBox.Icon.Information, "About...", "DWARF Explorer v." + '.'.join(str(v) for v in version) + "\n\nSeva Alekseyev, 2020-2023\nsevaa@sprynet.com\n\ngithub.com/sevaa/dwex",
            QMessageBox.StandardButton.Ok, self).show()

    def on_updatecheck(self):
        from urllib.request import urlopen
        import json
        try:
            self.start_wait()
            resp = urlopen('https://api.github.com/repos/sevaa/dwex/releases')
            if resp.getcode() == 200:
                releases = resp.read()
                self.end_wait()
                releases = json.loads(releases)
                if len(releases) > 0:
                    max_ver = max(tuple(int(v) for v in r['tag_name'].split('.')) for r in releases)
                    max_tag = '.'.join(str(i) for i in max_ver)
                    if max_ver > version:
                        s = "DWARF Explorer v." + max_tag + " is out. Use \"pip install --upgrade dwex\" to update."
                    else: 
                        s = "You have the latest version."
                    QMessageBox(QMessageBox.Icon.Information, "DWARF Explorer", s, QMessageBox.StandardButton.Ok, self).show()
        except:
            self.end_wait()

    def on_exit(self):
        self.destroy()
        QApplication.quit()

    # Checkmark toggling is handled by the framework
    def on_view_prefix(self, checked):
        self.prefix = checked
        self.sett.setValue('General/Prefix', self.prefix)
        if self.tree_model:
            self.tree_model.set_prefix(checked)

        if self.die_model:
            self.die_model.set_prefix(checked)
            self.refresh_details()

    # Checkmark toggling is handled by the framework
    def on_view_lowlevel(self, checked):   
        self.lowlevel = checked
        self.sett.setValue('General/LowLevel', self.lowlevel)
        if self.die_model:
            new_sel = self.die_model.set_lowlevel(checked, self.die_table.currentIndex())
            if new_sel:
                self.die_table.setCurrentIndex(new_sel)

    def on_view_hex(self, checked):        
        self.hex = checked
        self.sett.setValue('General/Hex', self.hex)
        if self.die_model:
            self.die_model.set_hex(checked)
            self.refresh_details()

    def on_view_regnames(self, checked):        
        self.dwarfregnames = checked
        self.sett.setValue('General/DWARFRegNames', self.dwarfregnames)
        if self.die_model:
            self.die_model.set_regnames(checked)
            self.refresh_details()            

    def on_sortcus(self, checked):
        self.sortcus = checked
        self.sett.setValue('General/SortCUs', self.sortcus)
        if self.tree_model:
            sel = self.the_tree.currentIndex()
            sel = self.tree_model.set_sortcus(checked, sel) # This will reload the tree
            if sel:
                self.the_tree.setCurrentIndex(sel)

    def on_sortdies(self, checked):
        self.sortdies = checked
        self.sett.setValue('General/SortDIEs', self.sortdies)
        if self.tree_model:
            #Throw away everything we had cached so far
            sel = self.tree_model.set_sortdies(checked)
            #This invalidates the navigation
            self.back_menuitem.setEnabled(False)
            self.back_tbitem.setEnabled(False)
            self.forward_menuitem.setEnabled(False)
            self.forward_tbitem.setEnabled(False)
            self.followref_menuitem.setEnabled(False)
            self.followref_tbitem.setEnabled(False)
            # Navigation stack - empty
            self.navhistory = []
            self.navpos = -1
            if sel:
                self.the_tree.setCurrentIndex(sel)

    # Tree highlighting business

    def manage_hlnavigation(self, b = None):
        if b is None:
            b = self.tree_model.has_any_highlights()
        self.prevhl_menuitem.setEnabled(b)
        self.nexthl_menuitem.setEnabled(b)
        self.prevhl_tbitem.setEnabled(b)
        self.nexthl_tbitem.setEnabled(b)

    def highlight_off(self, key):
        self.tree_model.remove_highlight(key)
        self.manage_hlnavigation()

    def on_highlight_code(self):
        if self.tree_model.has_highlight(1):
            self.highlight_off(1)
        else:
            self.tree_model.add_highlight(1, has_code_location)        
            self.manage_hlnavigation(True)

    def on_highlight_substring(self):
        if self.tree_model.has_highlight(2):
            self.highlight_off(2)
        else:
            r = QInputDialog.getText(self, 'Highlight', 'Highlight DIEs with substring:')
            if r[1] and r[0]:
                s = r[0].lower()
                self.tree_model.add_highlight(2, lambda die:self.findbytext(die, s))
                self.manage_hlnavigation(True)
            else:
                self.highlightsubstring_menuitem.setChecked(False)

    def on_highlight_condition(self):
        if self.tree_model.has_highlight(3):
            self.highlight_off(3)
        else:
            dlg = ScriptDlg(self, self.sample_die())
            if dlg.exec() == QDialog.DialogCode.Accepted:
                cond = dlg.cond
                self.tree_model.add_highlight(3, lambda die: self.eval_user_condition(cond, die))
                self.manage_hlnavigation(True)
            else:
                self.highlightcondition_menuitem.setChecked(False)
            # Accepted with blank or bogus expression is not supported

    def on_highlight_nothing(self):
        self.highlightcode_menuitem.setChecked(False)
        self.highlightsubstring_menuitem.setChecked(False)
        self.highlightcondition_menuitem.setChecked(False)
        self.manage_hlnavigation(False)
        self.tree_model.clear_highlight()

    def on_nexthl(self):
        index = self.tree_model.find(self.the_tree.currentIndex(), self.tree_model.is_highlighted, False)
        if index:
            self.the_tree.setCurrentIndex(index)

    def on_prevhl(self):
        index = self.tree_model.find_back(self.the_tree.currentIndex(), self.tree_model.is_highlighted, False)
        if index:
            self.the_tree.setCurrentIndex(index)

    def on_cuproperties(self):
        die = self.the_tree.currentIndex().internalPointer()
        if die:
            cu = die.cu
            ver = cu['version']
            if ver > 1:
                props = (ver, cu['unit_length'], cu['debug_abbrev_offset'], cu['address_size'])
                s = "DWARF version:\t%d\nLength:\t%d\nAbbrev table offset: 0x%x\nAddress size:\t%d" % props
            else:
                props = (ver, cu['address_size'])
                s = "DWARF version:\t%d\nAddress size:\t%d" % props
            t = "CU at 0x%x" % cu.cu_offset
            QMessageBox(QMessageBox.Icon.Information, t, s, QMessageBox.StandardButton.Ok, self).show()

    def on_copy(self, v):
        cb = QApplication.clipboard()
        cb.clear()
        cb.setText(v)

    def on_copyvalue(self):
        t = self.details_table if self.details_table.hasFocus() else self.die_table
        m = t.model()
        self.on_copy(m.data(t.currentIndex(), Qt.ItemDataRole.DisplayRole) or "")

    def on_copyline(self):
        t = self.details_table if self.details_table.hasFocus() else self.die_table
        m = t.model()
        row = t.currentIndex().row()
        line = "\t".join(m.data(m.index(row, c, QModelIndex()), Qt.ItemDataRole.DisplayRole) or ""
            for c in range(0, m.columnCount(QModelIndex())))
        self.on_copy(line)

    def on_copytable(self):
        t = self.details_table if self.details_table.hasFocus() else self.die_table
        m = t.model()
        table_text = "\n".join(
                "\t".join(m.data(m.index(r, c, QModelIndex()), Qt.ItemDataRole.DisplayRole)  or ""
                for c in range(0, m.columnCount(QModelIndex())))
            for r in range(0, m.rowCount(QModelIndex())))
        self.on_copy(table_text)

    def on_localsat(self):
        dlg = LocalsDlg(self, self.dwarfinfo, self.prefix, self.dwarfregnames, self.hex)
        if dlg.exec() == QDialog.DialogCode.Accepted and dlg.selected_die:
             self.the_tree.setCurrentIndex(self.tree_model.index_for_die(dlg.selected_die))

    # If the details pane has data - reload that
    def refresh_details(self):
        index = self.die_table.currentIndex()
        if index.isValid():
            details_model = self.die_model.get_attribute_details(index)
            if details_model:
                self.details_table.setModel(details_model)
                self.details_table.resizeColumnsToContents()
        self.die_table.resizeColumnsToContents()

    def on_issue(self):
        QDesktopServices.openUrl(QUrl('https://github.com/sevaa/dwex/issues/new'))

    def on_homepage(self):
        QDesktopServices.openUrl(QUrl('https://github.com/sevaa/dwex'))

    # Doesn't quite work for the delay on tree expansion :( TODO: timer checks before lighting up this
    def start_wait(self):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)

    def end_wait(self):
        QApplication.restoreOverrideCursor()

def on_exception(exctype, exc, tb):
    if isinstance(exc, MemoryError):
        app = QApplication.instance()
        app.win.destroy()
        app.win = None
        QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer", "Out of memory. DWARF Explorer will now close. Sorry.",
            QMessageBox.StandardButton.Ok, None).show()
        sys.exit(1)
    elif isinstance(exc, Exception):
        from .crash import report_crash
        report_crash(exc, exc.__traceback__, version)
        sys.excepthook = on_exception.prev_exchook
        sys.exit(1)
    elif on_exception.prev_exchook:
        on_exception.prev_exchook(exctype, exc, tb)

class TheApp(QApplication):
    def __init__(self):
        QApplication.__init__(self, [])

    def notify(self, o, evt):
        if evt.type() == QEvent.Type.MouseButtonPress and isinstance(o, QWindow) and hasattr(evt, "button"):
            b = evt.button()
            if b == Qt.MouseButton.BackButton:
                self.win.on_nav(1)
            elif b == Qt.MouseButton.ForwardButton:
                self.win.on_nav(-1)
        return QApplication.notify(self, o, evt)
    
    def start(self):
        self.win = TheWindow()
        self.exec()

def main():
    under_debugger = sys.gettrace() # Lame way to detect a debugger
    if not under_debugger: 
        on_exception.prev_exchook = sys.excepthook
        sys.excepthook = on_exception

    from .patch import monkeypatch
    monkeypatch()

    TheApp().start()
            

# For running via "python -m dwex"
# Running this file directly won't work, it relies on being in a module
if __name__ == "__main__":
    main()
```

`dwex/cookie.py`:

```py
cookie=False 

```

`dwex/crash.py`:

```py
import hashlib, urllib, random, string, traceback, sys, os, platform
from urllib.request import urlopen
# No dependencies on the rest of the app, and keep it that way

_binary_desc = None

def set_binary_desc(s):
    global _binary_desc
    _binary_desc = s

def submit_report(subj, body):
    try:
        secret = "jkaweliop3jka;lswmn12"
        chars = string.ascii_letters + string.digits
        id = ''.join(random.choice(chars) for x in range(50))
        h = hashlib.sha1()
        h.update((id + secret).encode('utf-8'))
        reqdata = {'to': "support@yarxi.ru",
		        'from': "\"DWEX\"<support@yarxi.ru>",
		        'subj': subj,
		        'body': body,
		        'id': id,
		        'hash': h.digest().hex()}
        reqdata = urllib.parse.urlencode(reqdata).encode('utf-8')
        urlopen('http://yarxi.ru/mobile/mail.php', reqdata).info()
    except Exception as exc:
        pass

def get_crash_die(locals):
    if "self" in locals and hasattr(locals['self'], 'die'):
        return locals['self'].die
    elif "die" in locals:
        return locals['die']
    else:
        return False

def get_crash_die_context(locals, ctxt = None):
    s = ''
    try:
        crash_die = get_crash_die(locals)
        if not crash_die and ctxt:
            crash_die = get_crash_die(ctxt)
        if crash_die:
            top = crash_die.cu.get_top_DIE()
            if top:
                if 'DW_AT_language' in top.attributes:
                    s += "Source language: 0x%x\n" % (top.attributes['DW_AT_language'].value,)
                if 'DW_AT_producer' in top.attributes:
                    s += "Producer: %s\n" % (top.attributes['DW_AT_producer'].value.decode('utf-8', errors='ignore'),)
    except:
        pass
    return s

def make_exc_report(exc, tb, version, catchpoint, ctxt=None):
    global _binary_desc
    tracebacks = []
    while tb.tb_next:
        tracebacks.insert(0, tb) # Innermost in the beginning of the list
        tb = tb.tb_next
    ss = traceback.extract_tb(tb)
    innermost_stack = traceback.extract_stack(tb.tb_frame)
    crashpoint = ss[0]
    locals = tb.tb_frame.f_locals

    report = type(exc).__name__ + ' at ' + os.path.basename(crashpoint.filename) + ':' + str(crashpoint.lineno) + "\n"
    if catchpoint:
        from inspect import getframeinfo
        fi = getframeinfo(catchpoint)
        report += "Caught %s@%s:%d\n" % (fi.function, os.path.basename(fi.filename), fi.lineno)
    report += "DWEX " + '.'.join(str(v) for v in version) + "\n"
    report += "Python " + sys.version + "\n"
    report += "System: " + platform.platform() + "\n"
    if _binary_desc:
        report += "Binary: " + _binary_desc + "\n"
    try:
        from .cookie import cookie
    except ImportError:
        cookie = False
    if cookie:
        report += "Cookie: " + cookie + "\n"
    report += get_crash_die_context(locals, ctxt=ctxt)
    report += "".join(traceback.format_exception_only(type(exc), exc)) + "\n"

    report += "PyStack_v3:\n"
    def module_prefix(se):
        p = os.path.dirname(se.filename).split(os.path.sep)
        if 'elftools' in p:
            return 'pyelftools/'
        elif 'dwex' in p:
            return 'dwex/'
        return ''
    def make_stackline(se):
        return se.name + '@' + module_prefix(se) + os.path.basename(se.filename) + ':' + str(se.lineno) + "\n"
    def make_stack_dump(stack):
        return [make_stackline(se) for se in stack[::-1]]
    def make_traceback_dump(tb):
        return "-\n"+"".join(make_stack_dump(traceback.extract_stack(tb.tb_frame)))

    report += "".join(make_stack_dump(innermost_stack))
    # More tracebacks
    report += "".join(make_traceback_dump(tb) for tb in tracebacks[1:])
    report += "\n"

    report += "PyLocals:\n" + ''.join(k + ": " + str(locals[k]) + "\n" for k in locals).replace("\n\n","\n")

    if ctxt:
        report += "\nPyContext:\n" + ''.join(k + ": " + str(ctxt[k]) + "\n" for k in ctxt).replace("\n\n","\n")

    return report

def report_crash(exc, tb, version, catchpoint = None, ctxt=None):
    try:
        subj = '[python][dwex][pyexception]'
        if not catchpoint:
            subj += '[crash]'
        submit_report(subj, make_exc_report(exc, tb, version, catchpoint, ctxt=ctxt))
    except Exception:
        pass

if __name__ == "__main__":
    try:
        def bar():
            i=0
            a=1
            a /=i

        def foo():
            bar()

        foo()
    except Exception as exc:
        from inspect import currentframe
        report_crash(exc, exc.__traceback__, (0, 50), currentframe())

```

`dwex/details.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel
from PyQt6.QtGui import QFont

_fixed_font = None

class GenericTableModel(QAbstractTableModel):
    def __init__(self, headers, values, warning = None, get_tooltip = None):
        QAbstractTableModel.__init__(self)
        self.headers = headers
        self.values = tuple(values)
        self.warning = warning
        self.get_tooltip = get_tooltip

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]

    def rowCount(self, parent):
        return len(self.values)

    def columnCount(self, parent):
        return len(self.headers)

    def data(self, index, role):
        if role == Qt.ItemDataRole.DisplayRole:
            return self.values[index.row()][index.column()]
        elif role == Qt.ItemDataRole.ToolTipRole:
            if self.get_tooltip:
                return self.get_tooltip(index.row(), index.column())

class FixedWidthTableModel(GenericTableModel):
    def __init__(self, headers, values):
        GenericTableModel.__init__(self, headers, values)

    def data(self, index, role):
        if role == Qt.ItemDataRole.FontRole:
            global _fixed_font
            if not _fixed_font:
                _fixed_font = QFont("Monospace")
                _fixed_font.setStyleHint(QFont.StyleHint.TypeWriter)
            return _fixed_font
        else:
            return GenericTableModel.data(self, index, role)
```

`dwex/die.py`:

```py
from bisect import bisect_right
from PyQt6.QtCore import Qt, QAbstractTableModel, QModelIndex
from PyQt6.QtGui import QBrush
from elftools.dwarf.locationlists import LocationParser, LocationExpr
from elftools.dwarf.dwarf_expr import DWARFExprParser
from elftools.dwarf.descriptions import _DESCR_DW_LANG, _DESCR_DW_ATE, _DESCR_DW_ACCESS, _DESCR_DW_INL, _DESCR_DW_CC
from elftools.common.exceptions import ELFParseError

from dwex.exprutil import ExprFormatter
from .dwarfone import DWARFExprParserV1
from .dwarfutil import *
from .details import GenericTableModel, FixedWidthTableModel

MAX_INLINE_BYTEARRAY_LEN = 32

def is_long_blob(attr):
    val = attr.value
    return ((isinstance(val, bytes) and attr.form not in ('DW_FORM_strp', 'DW_FORM_string')) or is_int_list(val)) and len(val) > MAX_INLINE_BYTEARRAY_LEN

#------------------------------------------------
# DIE formatter
#------------------------------------------------

_blue_brush = QBrush(Qt.GlobalColor.blue)
_ltgrey_brush = QBrush(Qt.GlobalColor.lightGray)

_ll_headers = ("Attribute", "Offset", "Form", "Raw", "Value")
_noll_headers = ("Attribute", "Form", "Value")
_meta_desc = ('DIE offset', 'DIE size', 'Abbrev code', 'Has children') # Anything else?
_meta_count = 4 # Extra rows if low level detail showing is set

class DIETableModel(QAbstractTableModel):
    def __init__(self, die, prefix, lowlevel, hex, regnames):
        QAbstractTableModel.__init__(self)
        self.prefix = prefix
        self.lowlevel = lowlevel
        self.hex = hex
        self.regnames = regnames
        self.die = die
        self.attributes = die.attributes
        self.keys = list(die.attributes.keys())
        self.headers = _ll_headers if self.lowlevel else _noll_headers
        self.meta_count = _meta_count if lowlevel else 0
        self.expr_formatter = ExprFormatter(regnames, prefix, die.dwarfinfo.config.machine_arch, die.cu['version'], hex)

    from .ranges import show_ranges
    from .locs import parse_location, show_location 

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]

    def rowCount(self, parent):
        return len(self.keys) + self.meta_count

    def columnCount(self, parent):
        return len(self.headers)

    def data(self, index, role):
        row = index.row()
        return self.attr_data(index, role) if row >= self.meta_count else self.meta_data(index, role)
    
    # End of Qt callbacks

    # Flavors of data() - attribute and metadata

    def attr_data(self, index, role):
        irow = index.row()
        meta_count = self.meta_count
        self_keys_len = len(self.keys)
        self_die_keys_len = len(self.die.attributes.keys())

        if irow >= meta_count + self_keys_len: # Shorting out 1530
            return None
                
        row = index.row() - self.meta_count
        key = self.keys[row]
        attr = self.attributes[key]
        if role == Qt.ItemDataRole.DisplayRole:
            col = index.column()
            if col == 0:
                # Unknown keys come across as ints
                return key if self.prefix or not str(key).startswith('DW_AT_') else key[6:]
            elif col == 1:
                return hex(attr.offset) if self.lowlevel else self.format_form(attr.form)
            elif col == 2:
                return self.format_form(attr.form) if self.lowlevel else self.format_value(attr)
            elif col == 3:
                return self.format_raw(attr) if self.lowlevel else self.format_value(attr)
            elif col == 4:
                return self.format_value(attr)
        elif role == Qt.ItemDataRole.ToolTipRole:
            if attr.form in ('DW_FORM_ref', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                return "Double-click to follow"
            elif attr.form in ('DW_FORM_ref_sig8', 'DW_FORM_ref_sup4', 'DW_FORM_ref_sup8'):
                return "Unsupported reference format"
            elif is_long_blob(attr):
                return "Click to see it all"
        elif role == Qt.ItemDataRole.ForegroundRole:
            if attr.form in ('DW_FORM_ref', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                return _blue_brush
        elif role == Qt.ItemDataRole.BackgroundRole:
            if self.lowlevel and index.column() == 3 and attr.raw_value == attr.value:
                return _ltgrey_brush                

    # Data for the metadata lines - ones that are not attributes
    def meta_data(self, index, role):
        row = index.row()
        if role == Qt.ItemDataRole.DisplayRole:
            col = index.column()
            if col == 0:
                return _meta_desc[row]
            elif col == (4 if self.lowlevel else 2):
                if row == 0:
                    return hex(self.die.offset)
                if row == 1: # Should this be always hex? Not sure...
                    return hex(self.die.size) if self.hex else str(self.die.size)
                elif row == 2: # Hex makes no sense here
                    return str(self.die.abbrev_code)                    
                elif row == 3:
                    return str(self.die.has_children)
        elif role == Qt.ItemDataRole.BackgroundRole:
            return _ltgrey_brush

    # Expr is an expression blob
    # Returns a list of strings for ops
    # Format: op arg, arg...
    def dump_expr(self, expr):
        if self.die.cu._exprparser is None:
            self.die.cu._exprparser = DWARFExprParser(self.die.cu.structs) if self.die.cu['version'] > 1 else DWARFExprParserV1(self.die.cu.structs)

        # Challenge: for nested expressions, args is a list with a list of commands
        # For those, the format is: op {op arg, arg; op arg, arg}
        # Can't just check for iterable, str is iterable too
        return [self.expr_formatter.format_op(*op) for op in self.die.cu._exprparser.parse_expr(expr)]

    # Big DIE attribute value interpreter for the top right table
    def format_value(self, attr):
        try:
            die = self.die
            cu = self.die.cu
            header = self.die.cu.header
            dwarf_version = self.die.cu.header.version

            key = attr.name
            val = attr.value
            form = attr.form
            if form == 'DW_FORM_addr' and isinstance(val, int):
                return hex(val)
            elif form == 'DW_FORM_flag_present':
                return 'True'
            elif form in ('DW_FORM_ref0', 'DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8', 'DW_FORM_ref_addr'):
                return "Ref: 0x%x" % val # There are several other reference forms in the spec
            elif form == 'DW_FORM_flag':
                return str(bool(val))
            elif LocationParser.attribute_has_location(attr, self.die.cu['version']):
                ll = self.parse_location(attr)
                if ll is None:
                    return "(parse error - please report at github.com/sevaa/dwex)"
                elif isinstance(ll, LocationExpr):
                    return '; '.join(self.dump_expr(ll.loc_expr))
                else:
                    return "Loc list: 0x%x" % attr.value
            elif key == 'DW_AT_language':
                return "%d %s" % (val, _DESCR_DW_LANG[val]) if val in _DESCR_DW_LANG else val
            elif key == 'DW_AT_encoding':
                return "%d %s" % (val, _DESCR_DW_ATE[val]) if val in _DESCR_DW_ATE else val
            elif key == 'DW_AT_accessibility':
                return "%d %s" % (val, _DESCR_DW_ACCESS[val]) if val in _DESCR_DW_ACCESS else val
            elif key == 'DW_AT_inline':
                return "%d %s" % (val, _DESCR_DW_INL[val]) if val in _DESCR_DW_INL else val
            elif key == 'DW_AT_calling_convention':
                return "%d %s" % (val, _DESCR_DW_CC[val]) if val in _DESCR_DW_CC else val
            elif key in ('DW_AT_decl_file', 'DW_AT_call_file'):
                cu = self.die.cu
                if cu._lineprogram is None:
                    cu._lineprogram = self.die.dwarfinfo.line_program_for_CU(cu)
                if cu._lineprogram:
                    if cu._lineprogram.header.version >= 5:
                        filename = cu._lineprogram.header.file_entry[val].name.decode('utf-8', errors='ignore') if cu._lineprogram and val >= 0 and val < len(cu._lineprogram.header.file_entry) else '(N/A)'
                    else:
                        if val == 0:
                            filename = safe_DIE_name(cu.get_top_DIE(), 'N/A')
                        else:
                            filename = cu._lineprogram.header.file_entry[val-1].name.decode('utf-8', errors='ignore') if cu._lineprogram and val > 0 and val <= len(cu._lineprogram.header.file_entry) else '(N/A)'
                    return "%d: %s" % (val,  filename)
                else: # Lineprogram not found in the top DIE - how's that possible?
                    return "%d (no lineprogram found)" % (val,)
            elif key == 'DW_AT_stmt_list':
                return 'LNP at 0x%x' % val
            elif key in ('DW_AT_upper_bound', 'DW_AT_lower_bound') and is_block(form):
                return '; '.join(self.dump_expr(val))
            elif isinstance(val, bytes):
                if form in ('DW_FORM_strp', 'DW_FORM_string', 'DW_FORM_line_strp', 'DW_FORM_strp_sup',
                    'DW_FORM_strx', 'DW_FORM_strx1', 'DW_FORM_strx2', 'DW_FORM_strx3', 'DW_FORM_strx4'):
                    return val.decode('utf-8', errors='ignore')
                elif val == b'': # What's a good value for a blank blob?
                    return '[]'
                elif len(val) > MAX_INLINE_BYTEARRAY_LEN:
                    return ' '.join("%02x" % b for b in val[0:MAX_INLINE_BYTEARRAY_LEN]) + ("...(%s bytes)" % (('0x%x' if self.hex else '%d') % len(val)))
                else:
                    return ' '.join("%02x" % b for b in val) # Something like "01 ff 33 55"
            elif isinstance(val, list): # block1 comes across as this
                if val == []:
                    return '[]'
                elif isinstance(val[0], int): # Assuming it's a byte array diguised as int array
                    if len(val) > MAX_INLINE_BYTEARRAY_LEN:
                        return ' '.join("%02x" % b for b in val[0:MAX_INLINE_BYTEARRAY_LEN]) + ("...(%s bytes)" % (('0x%x' if self.hex else '%d') % len(val)))
                    else:
                        return ' '.join("%02x" % b for b in val)
                else: # List of something else
                    return str(val)
            else:
                return hex(val) if self.hex and isinstance(val, int) else str(val)
        except ELFParseError as exc:
            from .__main__ import version
            from .crash import report_crash
            from inspect import currentframe
            tb = exc.__traceback__
            di = die.cu.dwarfinfo
            loc_section = di.debug_loclists_sec if dwarf_version >= 5 else di.debug_loc_sec
            loc_sec_len = len(loc_section.stream.getbuffer()) if loc_section else None
            ctxt = {'attr': attr,
                       'die': die,
                       'cu_header': header,
                       'dwarf_version': dwarf_version,
                       'sec_size': loc_sec_len}
            report_crash(exc, tb, version, currentframe(), ctxt)
            return "(parse error - please report at github.com/sevaa/dwex)"

    def format_form(self, form):
        return form if self.prefix or not str(form).startswith('DW_FORM_') else form[8:]

    def format_raw(self, attr):
        val = attr.raw_value
        if val == attr.value:
            return "(same)"
        elif isinstance(val, int):
            return hex(val) if self.hex else str(val)
        elif isinstance(val, bytes) or (isinstance(val, list) and len(val) > 0 and isinstance(val[0], int)):
            return ' '.join("%02x" % b for b in val) if len(val) > 0 else '[]'
        else:
            return str(val)

    def display_DIE(self, die):
        rows_was = len(self.keys) + self.meta_count
        self.die = die
        self.attributes = die.attributes
        self.keys = list(die.attributes.keys())
        # Should not be ever possible, but this code is here
        self.expr_formatter.set_arch(die.dwarfinfo.config.machine_arch)
        self.expr_formatter.dwarf_version = die.cu['version']
        rows_now = self.meta_count + len(self.keys)
        if rows_was < rows_now:
            self.rowsInserted.emit(QModelIndex(), rows_was, rows_now-1)
        elif rows_was > rows_now:
            self.rowsRemoved.emit(QModelIndex(), rows_now, rows_was-1)
        self.dataChanged.emit(self.createIndex(0, 0), self.createIndex(rows_now - 1, len(self.headers)-1))

    def set_prefix(self, prefix):
        if prefix != self.prefix:
            self.prefix = prefix
            self.expr_formatter.prefix = prefix
            self.refresh_values()

    # Index is the current selected index
    # Returns the new selected index, if there was one
    def set_lowlevel(self, lowlevel, index):
        if lowlevel != self.lowlevel:
            self.lowlevel = lowlevel
            self.headers = _ll_headers if self.lowlevel else _noll_headers
            new_index = None
            if lowlevel:
                self.beginInsertColumns(QModelIndex(), 2, 3)
                self.endInsertColumns()
                self.meta_count = _meta_count
                self.rowsInserted.emit(QModelIndex(), 0, self.meta_count - 1)
                if index.isValid(): # Shift the selection two down
                    new_index = self.createIndex(index.row() + self.meta_count, 0)
            else:
                meta_count_was = self.meta_count # Allows for meta_count to be dependent on DIE
                self.beginRemoveColumns(QModelIndex(), 2, 3)
                self.endRemoveColumns()
                self.meta_count = 0
                self.rowsRemoved.emit(QModelIndex(), 0, meta_count_was - 1)
                if index.isValid() and index.row() >= meta_count_was: # Shift the selection down
                    new_index = self.createIndex(index.row() - meta_count_was, 0)
                else:
                    new_index = QModelIndex() # Select none
        return new_index

    # Force a reload of values on the whole table without row/column count change
    def refresh_values(self):
        self.dataChanged.emit(self.createIndex(0, 0), self.createIndex(self.meta_count + len(self.keys)-1, len(self.headers)-1))

    def set_hex(self, hex):
        if hex != self.hex:
            self.hex = hex
            self.refresh_values()

    def set_regnames(self, regnames):
        if regnames != self.regnames:
            self.regnames = regnames
            self.expr_formatter.regnames = regnames
            self.refresh_values()

    # Returns a table model for the attribute details table
    # For attributes that refer to larger data structures (ranges, locations), makes sense to spell it out into a table
    # Row is metadata unaware
    def get_attribute_details(self, index):
        row = index.row()
        if row >= self.meta_count:
            row -= self.meta_count
            key = self.keys[row]
            attr = self.attributes[key]
            form = attr.form
            if key == "DW_AT_ranges":
                return self.show_ranges(attr)
            elif LocationParser.attribute_has_location(attr, self.die.cu['version']):
                return self.show_location(attr)
            elif key == 'DW_AT_stmt_list':
                if self.die.cu._lineprogram is None:
                    self.die.cu._lineprogram = self.die.dwarfinfo.line_program_for_CU(self.die.cu)
                lpe = self.die.cu._lineprogram.get_entries()
                files = self.die.cu._lineprogram.header.file_entry
                ver5 = self.die.cu._lineprogram.header.version >= 5
                def_file = safe_DIE_name(self.die.cu.get_top_DIE(), 'N/A')
                def format_state(state):
                    filename = 'N/A'
                    if ver5:
                        if state.file >= 0 and state.file < len(files):
                            filename = files[state.file].name.decode('utf-8', errors='ignore')
                    else:
                        if state.file == 0:
                            filename = def_file
                        elif state.file >= 1 and state.file <= len(files):
                            filename = files[state.file-1].name.decode('utf-8', errors='ignore')
                    return (hex(state.address),
                        filename,
                        state.line,
                        'Y' if state.is_stmt  else '',
                        'Y' if state.basic_block else '',
                        'Y' if state.end_sequence else '',
                        'Y' if state.prologue_end else '',
                        'Y' if state.epilogue_begin else '')
                states = [format_state(e.state) for e in lpe if e.state]
                # TODO: low level flavor with extra details
                # TODO: commands vs states
                return GenericTableModel(('Address', 'File', 'Line', 'Stmt', 'Basic block', 'End seq', 'End prologue', 'Begin epilogue'), states)
            elif key in ('DW_AT_upper_bound', 'DW_AT_lower_bound') and is_block(form):
                return GenericTableModel(("Command",), [(o,) for o in self.dump_expr(attr.value)])
            elif is_long_blob(attr):
                val = attr.value
                def format_line(off):
                    offs = ("0x%x" if self.hex else "%d") % off
                    return (offs, ' '.join("%02x" % b for b in val[off:off+MAX_INLINE_BYTEARRAY_LEN]))
                lines = [format_line(off) for off in range(0, len(val), MAX_INLINE_BYTEARRAY_LEN)]
                return FixedWidthTableModel(('Offset (%s)' % ('hex' if self.hex else 'dec'), 'Bytes'), lines)
        return None

    # Returns (cu, die_offset) or None if not a navigable
    def ref_target(self, index):
        try:  # Any chance for "not found"? Probably bug #1450, #1450
            row = index.row()
            if row >= self.meta_count:
                attr_name = self.keys[row - self.meta_count]
                attr = self.attributes[attr_name]
                val = attr.value
                form = attr.form
                if form in ('DW_FORM_ref1', 'DW_FORM_ref2', 'DW_FORM_ref4', 'DW_FORM_ref8'):
                    return (self.die.cu, attr.value + self.die.cu.cu_offset)
                elif form in ('DW_FORM_ref_addr', 'DW_FORM_ref'):
                    cualen = len(self.die.cu.dwarfinfo._unsorted_CUs)
                    i = bisect_right(self.die.cu.dwarfinfo._CU_offsets, val) - 1
                    cu = self.die.cu.dwarfinfo._unsorted_CUs[i]
                    return (cu, attr.value)
        except IndexError as exc:
            from .__main__ import version
            from .crash import report_crash
            from inspect import currentframe
            tb = exc.__traceback__
            report_crash(exc, tb, version, currentframe())
            return None



```

`dwex/dwarfone.py`:

```py
# Support for DWARF v1.1 in a way that will be more or less compatible with pyelftools

from io import BytesIO
from collections import OrderedDict, namedtuple
from bisect import bisect_left
from elftools.dwarf.dwarfinfo import DwarfConfig, DebugSectionDescriptor
from elftools.dwarf.die import AttributeValue
from elftools.dwarf.structs import DWARFStructs
from elftools.common.utils import struct_parse, bytelist2string
from elftools.dwarf.enums import ENUM_DW_TAG, ENUM_DW_AT, ENUM_DW_FORM
from elftools.construct import CString
from elftools.dwarf.lineprogram import LineProgramEntry, LineState
from elftools.dwarf.dwarf_expr import DWARFExprOp

LineTableHeader = namedtuple('LineTableHeader', 'version file_entry')
CUv1Header = namedtuple('CUv1Header', 'version unit_length debug_abbrev_offset address_size')

TAG_reverse = dict((v, k) for k, v in ENUM_DW_TAG.items())
ATTR_reverse = dict((v, k) for k, v in ENUM_DW_AT.items())
FORM_reverse = dict((v, k) for k, v in ENUM_DW_FORM.items())

DW_OP_name2opcode = dict(
    DW_OP_reg = 0x01,
    DW_OP_basereg = 0x02,
    DW_OP_addr = 0x03,
    DW_OP_const = 0x04,
    DW_OP_deref2 = 0x05,
    DW_OP_deref = 0x06,
    DW_OP_deref4 = 0x06,
    DW_OP_add = 0x07,
    DW_OP_user_0x80 = 0x80 #Extension op, not sure what's the deal with that
)

DW_OP_opcode2name = dict((v, k) for k, v in DW_OP_name2opcode.items())

class DIEV1(object):
    def __init__(self, stm, cu, di):
        self.cu = cu
        self.dwarfinfo = di
        self.stream = stm
        self.offset = stm.tell()
        self.attributes = OrderedDict()
        self.tag = None
        self.has_children = None
        self.abbrev_code = None
        self.size = 0
        # Null DIE terminator. It can be used to obtain offset range occupied
        # by this DIE including its whole subtree.
        self._terminator = None
        self._parent = None

        structs = self.dwarfinfo.structs
        self.size = struct_parse(structs.Dwarf_uint32(''), stm)
        # Size 8+  can be padding if the tag is 0. No attributes in those.
        # DW_TAG_null and DW_TAG_padding are both code zero
        if self.size < 8:
            self.tag = 'DW_TAG_null' # Null terminates the sibling chain
            self.has_children = False
        else:
            tag_code = struct_parse(structs.Dwarf_uint16(''), stm)
            # Do what pyelftools does, leave tag as int if unknown
            self.tag = TAG_reverse[tag_code] if tag_code in TAG_reverse else tag_code 
            if self.tag == 'DW_TAG_null': # TAG_padding in DWARF1 spec
                self.tag == 'DW_TAG_padding' #Doesn't count for is_null
                # No attributes, just advance the stream
                stm.seek(self.size-6, 1)
                self.has_children = False
            else:
                while stm.tell() < self.offset + self.size:
                    attr_offset = self.stream.tell()
                    attr = struct_parse(structs.Dwarf_uint16(''), stm)
                    form = FORM_reverse[attr & 0xf]
                    attr >>= 4
                    if attr in ATTR_reverse:
                        name = ATTR_reverse[attr]
                    elif 0x200 <= attr <= 0x3ff: #DW_AT_MIPS represented as 0x204???
                        name = 'DW_AT_user_0x%x' % attr
                    else: # Do what pyelftools does, leave tag as int if unknown
                        name = attr

                    raw_value = struct_parse(structs.Dwarf_dw_form[form], stm)
                    value = raw_value

                    self.attributes[name] = AttributeValue(
                        name=name,
                        form=form,
                        value=value,
                        raw_value=raw_value,
                        offset=attr_offset,
                        indirection_length = 0)
                self.has_children = self.attributes['DW_AT_sibling'].value >= self.offset + self.size + 8

    def get_parent(self):
        return self._parent

    def is_null(self):
        return self.tag == 'DW_TAG_null'

    def iter_children(self):
        return self.cu.iter_children(self)

    def sibling(self):
        return self.attributes['DW_AT_sibling'].value

class CompileUnitV1(object):
    def __init__(self, di, top_die):
        self.dwarfinfo = di
        self.structs = di.structs
        end_offset = top_die.attributes['DW_AT_sibling'].value
        self.header = CUv1Header(version = 1, unit_length = end_offset - top_die.offset, debug_abbrev_offset = None, address_size = 4)
        self._dielist = [top_die]
        self._diemap = [top_die.offset]
        # For compatibility with v2+ CU
        self.cu_offset = top_die.offset
        self.cu_die_offset = top_die.offset

    def get_top_DIE(self):
        return self._dielist[0]

    def __getitem__(self, name):
        return self.header._asdict()[name]

    # Caches
    def DIE_at_offset(self, offset):
        i = bisect_left(self._diemap, offset)
        if i < len(self._diemap) and offset == self._diemap[i]:
            die = self._dielist[i]
        else:
            die = self.dwarfinfo.DIE_at_offset(offset, self)
            self._dielist.insert(i, die)
            self._diemap.insert(i, offset)
        return die

    # pyelftools' iter_DIEs sets parent on discovered DIEs, we should too
    def iter_DIEs(self):
        offset = self.cu_offset
        parent = None
        parent_stack = list()
        end_offset = self.get_top_DIE().attributes['DW_AT_sibling'].value
        # Dump the whole section into locals to catch 1610
        if end_offset - offset <= 4096:
            stm = self.dwarfinfo.stm
            stm.seek(offset, 0)
            import base64
            section_dump = base64.encodebytes(stm.read(end_offset - offset)).decode('ASCII')
        while offset < end_offset:
            die = self.DIE_at_offset(offset)

            if die._parent is None:
                die._parent = parent

            if not die.is_null():
                yield die
                offset += die.size
                if offset != die.sibling(): # Start of a subtree
                    parent_stack.append(parent)
                    parent = die
            else: # null - end of a sibling chain
                # Catching 1610
                size = die.size
                tag = die.tag
                parent = parent_stack.pop() # Throws IndexError
                offset += die.size
            prev_die_tag = die.tag

    def iter_children(self, parent_die):
        offset = parent_die.offset + parent_die.size
        parent_sibling_offset = parent_die.attributes['DW_AT_sibling'].value if 'DW_AT_sibling' in parent_die.attributes else None
        section_size = self.dwarfinfo.section_size
        while offset < section_size:
            die = self.DIE_at_offset(offset)

            if die._parent is None:
                die._parent = parent_die
            if not die.is_null():
                yield die
                # Troubleshooting #1497
                
                tag = die.tag
                attr = die.attributes
                off = die.offset
                size = die.size
                has_children = die.has_children
                offset = die.attributes['DW_AT_sibling'].value # will throw KeyError if none
                prev_die = die
                #offset = die.sibling()
            else:
                break
            
    def iter_DIE_children(self, die):
        raise NotImplementedError("Sorry, not supported on DWARFv1 yet")

class LineTableV1(object):
    def __init__(self, stm, structs, len, pc):
        self.stm = stm
        self.structs = structs
        self.len = len
        self.pc = pc
        self._decoded_entries = None
        self.header = LineTableHeader(1, (None))

    def get_entries(self):
        if self._decoded_entries is None:
            stm = self.stm
            offset = stm.tell()
            end_offset = offset + self.len
            structs = self.structs
            entries = []
            pc = self.pc
            while offset < end_offset:
                line = struct_parse(structs.Dwarf_uint32(''), stm)
                col = struct_parse(structs.Dwarf_uint16(''), stm)
                pc_delta = struct_parse(structs.Dwarf_uint32(''), stm)
                if line == 0:
                    break
                state = LineState(True)
                state.file = 0
                state.line = line
                state.column = col if col != 0xffff else None
                state.address = pc
                entries.append(LineProgramEntry(0, False, [], state))
                pc += pc_delta
            self._decoded_entries = entries
        return self._decoded_entries

class DWARFExprParserV1(object):
    def __init__(self, structs):
        self.structs = structs
        
    def parse_expr(self, expr):
        stm = BytesIO(bytelist2string(expr))
        parsed = []

        while True:
            # Get the next opcode from the stream. If nothing is left in the
            # stream, we're done.
            byte = stm.read(1)
            if len(byte) == 0:
                break

            # Decode the opcode and its name.
            op = ord(byte)
            op_name = DW_OP_opcode2name.get(op, 'OP:0x%x' % op)

            if op <= 4 or op == 0x80:
                args = [struct_parse(self.structs.Dwarf_target_addr(''), stm),]
            else:
                args = []

            parsed.append(DWARFExprOp(op=op, op_name=op_name, args=args, offset=stm.tell()))

        return parsed

class DWARFInfoV1(object):
    def __init__(self, elffile):
        section = elffile.get_section_by_name(".debug")
        section_data = section.data()
        self.section_size = len(section_data)
        self.stm = BytesIO()
        self.stm.write(section_data)
        self.stm.seek(0, 0)

        lsection = elffile.get_section_by_name(".line")
        if lsection:
            self.linestream = BytesIO()
            self.linestream.write(lsection.data())
            self.linestream.seek(0, 0)

        self.config = DwarfConfig(
            little_endian = elffile.little_endian,
            default_address_size = elffile.elfclass // 8,
            machine_arch = elffile.get_machine_arch()
        )

        self.structs = DWARFStructs(
            little_endian = self.config.little_endian,
            dwarf_format = 32,
            address_size = self.config.default_address_size)

    def iter_CUs(self):
        offset = 0
        while offset < self.section_size:
            die = self.DIE_at_offset(offset, None)
            if not die.is_null():
                if die.cu is None:
                    die.cu = cu = CompileUnitV1(self, die)
                    cu.cu_offset = offset
                yield die.cu
                offset = die.attributes['DW_AT_sibling'].value
            else:
                break

    # Does not cache
    def DIE_at_offset(self, offset, cu):
        self.stm.seek(offset, 0)
        return DIEV1(self.stm, cu, self)

    def location_lists(self):
        return None

    def line_program_for_CU(self, cu):
        top_DIE = cu.get_top_DIE()
        if 'DW_AT_stmt_list' in top_DIE.attributes:
            stm = self.linestream
            stm.seek(top_DIE.attributes['DW_AT_stmt_list'].value, 0)
            structs = self.structs
            len = struct_parse(structs.Dwarf_uint32(''), stm)
            pc = struct_parse(structs.Dwarf_target_addr(''), stm)
            return LineTableV1(stm, structs, len, pc)
        else:
            return None
        
    def range_lists(self):
        return None
    
    def get_aranges(self):
        return None

def parse_dwarf1(elffile):
    return DWARFInfoV1(elffile)

```

`dwex/dwarfutil.py`:

```py
from bisect import bisect_left
from elftools.dwarf.ranges import BaseAddressEntry as RangeBaseAddressEntry, RangeEntry
from elftools.dwarf.locationlists import LocationExpr
from elftools.dwarf.dwarf_expr import DWARFExprParser

from dwex.dwarfone import DWARFExprParserV1

class NoBaseError(Exception):
    pass

def has_code_location(die):
    attr = die.attributes
    return 'DW_AT_ranges' in attr or ('DW_AT_low_pc' in attr and 'DW_AT_high_pc' in attr)  

def is_inline(func):
    return 'DW_AT_inline' in func.attributes and func.attributes['DW_AT_inline'].value != 0

def DIE_type(die):
    return die.get_DIE_from_attribute("DW_AT_type")

def is_int_list(val):
    return isinstance(val, list) and len(val) > 0 and isinstance(val[0], int)

def is_block(form):
    return form in ('DW_FORM_block', 'DW_FORM_block1', 'DW_FORM_block2', 'DW_FORM_block4')

def DIE_name(die):
    return die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')

def safe_DIE_name(die, default = ''):
    return die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore') if 'DW_AT_name' in die.attributes else default

def DIE_is_ptr_to_member_struct(type_die):
    if type_die.tag == 'DW_TAG_structure_type':
        members = tuple(die for die in type_die.iter_children() if die.tag == "DW_TAG_member")
        return len(members) == 2 and safe_DIE_name(members[0]) == "__pfn" and safe_DIE_name(members[1]) == "__delta"
    return False

class ClassDesc(object):
    def __init__(self):
        self.scopes = ()
        self.const_member = False

class TypeDesc(object):
    def __init__(self):
        self.name = None
        self.modifiers = () # Reads left to right
        self.scopes = () # Reads left to right
        self.tag = None   

# Address is relative to the preferred loading address
# Not generally applicable for pyelftools clients - relies on CU caching by dwex
def find_cu_by_address(di, address):
    if di._aranges:
        cuoffset = di._aranges.cu_offset_at_addr(address)
        if cuoffset is None:
            return None
        i = bisect_left(di._CU_offsets, cuoffset)
        return di._unsorted_CUs[i]
    else:
        for cu in di._unsorted_CUs:
            if ip_in_range(cu.get_top_DIE(), address):
                return cu
    return None

# May return None or raise NoBaseError
def get_cu_base(die):
    top_die = die.cu.get_top_DIE()
    if 'DW_AT_low_pc' in top_die.attributes:
        return top_die.attributes['DW_AT_low_pc'].value
    elif 'DW_AT_entry_pc' in top_die.attributes:
        return top_die.attributes['DW_AT_entry_pc'].value
    # TODO: ranges?
    elif 'DW_AT_ranges' in top_die.attributes:
        di = die.dwarfinfo
        if not di._ranges:
            di._ranges = di.range_lists()
        if not di._ranges: # Absent in the DWARF file
            raise NoBaseError()
        rl = di._ranges.get_range_list_at_offset(top_die.attributes['DW_AT_ranges'].value, cu=die.cu)
        base = None
        for r in rl:
            if isinstance(r, RangeEntry) and r.is_absolute and (base is None or r.begin_offset < base):
                base = r.begin_offset
            elif isinstance(r, RangeBaseAddressEntry) and (base is None or r.base_address < base):
                base = r.base_address
        if base is None:
            raise NoBaseError()
        return base
    else:
        raise NoBaseError()

# Returns a list of DIEs objects for top level functions that contain the address
# Inlines analyzed later
def find_funcs_at_address(cu, address):
    funcs = []
    top_die = cu.get_top_DIE()
    di = cu.dwarfinfo
    first_die = next(top_die.iter_children())
    if first_die is None:
        return []
        
    has_siblings = "DW_AT_sibling" in first_die.attributes 
    if has_siblings:
        die_list = (die for die in cu.iter_DIE_children(top_die))
    else:
        die_list = (die for die in cu.iter_DIEs())

    for die in die_list:
        if die.tag == 'DW_TAG_subprogram' and has_code_location(die):
            if 'DW_AT_range' in die.attributes:
                cu_base = top_die.attributes['DW_AT_low_pc'].value
                rl = di._ranges.get_range_list_at_offset(die.attributes['DW_AT_ranges'].value)
                for r in rl:
                    if r.begin_offset <= address - cu_base < r.end_offset:
                        funcs.append(die)
            else:
                l = die.attributes['DW_AT_low_pc'].value
                h = die.attributes['DW_AT_high_pc'].value
                if not die.attributes['DW_AT_high_pc'].form == 'DW_FORM_addr':
                    h += l
                if address >= l and address < h:
                    funcs.append(die)
    return funcs

# Find helper:
# Returns true if the specified IP is in [low_pc, high_pc)
# Or in ranges
def ip_in_range(die, ip):
    if 'DW_AT_ranges' in die.attributes:
        di = die.dwarfinfo
        if not di._ranges:
            di._ranges = di.range_lists()
        if not di._ranges: # Absent in the DWARF file
            return False
        # TODO: handle base addresses. Never seen those so far...
        cu_base = None
        rl = di._ranges.get_range_list_at_offset(die.attributes['DW_AT_ranges'].value, cu = die.cu)
        for r in rl:
            if isinstance(r, RangeBaseAddressEntry):
                cu_base = r.base_address
            else: # r is RangeEntry, which in DWARF5 can be absolute
                if not r.is_absolute and cu_base is None:
                    cu_base = get_cu_base(die)
                if r.begin_offset <= ip - (0 if r.is_absolute else cu_base) < r.end_offset:
                    return True
    if 'DW_AT_low_pc' in die.attributes and 'DW_AT_high_pc' in die.attributes:
        l = die.attributes['DW_AT_low_pc'].value
        h = die.attributes['DW_AT_high_pc'].value
        if die.attributes['DW_AT_high_pc'].form != 'DW_FORM_addr':
            h += l
        if l <= ip < h:
            return True
    return False

# returns (origin, spec)
def follow_function_spec(func_die):
    origin = func_die.get_DIE_from_attribute('DW_AT_abstract_origin') if 'DW_AT_abstract_origin' in func_die.attributes else func_die
    spec = origin.get_DIE_from_attribute('DW_AT_specification') if 'DW_AT_specification' in origin.attributes else origin
    return (origin, spec)

# Line program navigation - A2L core
# DWEX aware caching
def get_source_line(die, address):
    cu = die.cu
    if cu._lineprogram is None:
        cu._lineprogram = die.dwarfinfo.line_program_for_CU(cu)
    lp = cu._lineprogram
    v5 = cu.header.version >= 5
    file_and_line = None
    prevstate = None
    for entry in lp.get_entries():
        # We're interested in those entries where a new state is assigned
        if entry.state is None:
            continue
        if entry.state.end_sequence:
            # if the line number sequence ends, clear prevstate.
            prevstate = None
            continue
        # Looking for a range of addresses in two consecutive states that
        # contain the required address.
        if prevstate and prevstate.address <= address < entry.state.address and not file_and_line:
            file = lp['file_entry'][prevstate.file + (0 if v5 else -1)].name.decode('UTF-8')
            line = prevstate.line
            file_and_line = (file, line)
        prevstate = entry.state
    return file_and_line

# Resolves source file number in an attribute to a file name
# None if no such attribute or no such file
# DWEX caching aware
def get_source_file_name_from_attr(die, attr_name):
    cu = die.cu
    if cu._lineprogram is None:
        cu._lineprogram = die.dwarfinfo.line_program_for_CU(cu)
    lp = cu._lineprogram
    if attr_name in die.attributes:
        file_no = die.attributes[attr_name].value
        if cu.header.version < 5:
            file_no -= 1
        file_entries = lp['file_entry']
        if file_no >= 0 and file_no < len(file_entries):
            return file_entries[file_no].name.decode('UTF-8')

# Returns (name, mangled_name)
def retrieve_function_names(func_spec, the_func):
    attr = func_spec.attributes
    func_name = DIE_name(func_spec)
    module = the_func.cu.get_top_DIE()
    lang = module.attributes['DW_AT_language'].value if 'DW_AT_language' in module.attributes else None
    if 'DW_AT_MIPS_linkage_name' in attr:
        mangled_func_name = func_spec.attributes['DW_AT_MIPS_linkage_name'].value.decode('UTF-8', errors='ignore')
    elif 'DW_AT_linkage_name' in attr:
        mangled_func_name = func_spec.attributes['DW_AT_linkage_name'].value.decode('UTF-8', errors='ignore')
    else: # Could be a plain-C function...
        mangled_func_name = func_name
        if lang in (0x1, 0x2, 0xc, 0x1d) or (has_code_location(func_spec) and "DW_AT_external" in attr) or "DW_AT_external" in the_func.attributes:
            return (func_name, func_name)
    # Sometimes addr2line spits without even (). Extern "C" maybe? 

    # TODO: augment func name with arguments for ones where it's relevant. External? cdecl?
    if lang in (0x4, 0x19,0x1a, 0x21): # C++
        func_name = generate_full_function_name(func_spec, the_func) 
    # TODO: Pascal, ObjC
    return (func_name, mangled_func_name)

def generate_full_function_name(func_spec, the_func):
    func_name = DIE_name(func_spec)

    spec_params = tuple(ps for ps in func_spec.iter_children() if ps.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in ps.attributes)
    func_params = tuple(p for p in the_func.iter_children() if p.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in p.attributes)
    params = tuple(format_function_param(*pp) for pp in zip(spec_params, func_params))
    class_spec = get_class_spec_if_member(func_spec, the_func)
    class_prefix = "::".join(class_spec.scopes) + "::" if class_spec and class_spec.scopes else ""
    class_postfix = " const" if class_spec and class_spec.const_member else ""
    # I've seen const marker on the this parameter that wasn't const in the source
    return class_prefix + func_name + "(" + ", ".join(params) + ")" + class_postfix

def format_function_param(param_spec, param):
    if param_spec.tag == 'DW_TAG_formal_parameter':
        if 'DW_AT_name' in param.attributes:
            name = DIE_name(param)
        elif 'DW_AT_name' in param_spec.attributes:
            name = DIE_name(param_spec)
        else:
            name = None
        type = parse_datatype(param_spec)
        type_name = type.name
        if type.scopes:
            scopes = "::".join(type.scopes) # Are there any case where namespace and class scopes vary?
            type_name = f"{scopes}::{type_name}"

        mods = type.modifiers
        cpp_symbols = {"pointer": "*", "reference" : "&", "const" : " const"}
        #Ad-hoc fixes
        if mods and len(mods) >= 2 and mods[-1] == "const": # const-ref-const to const-ref # mods[0] == "const" and 
            mods = mods[0:-1]
        # TODO: check if typedef matters            
        return type_name + "".join(cpp_symbols[mod] for mod in mods)
 
    else: #unspecified_parameters AKA variadic
        return "..."

# Follows the modifier chain
# Returns an object:
def parse_datatype(var):
    t = TypeDesc()
    if not 'DW_AT_type' in var.attributes:
        t.tag = ''
        return t

    type_die = var.get_DIE_from_attribute('DW_AT_type')

    mods = []
    last_typedef = None
    while type_die.tag in ('DW_TAG_typedef', 'DW_TAG_array_type', 'DW_TAG_const_type', 'DW_TAG_pointer_type', 'DW_TAG_reference_type'):
        if type_die.tag != 'DW_TAG_typedef':
            mods.insert(0, type_die.tag[7:-5])
            if not 'DW_AT_type' in type_die.attributes and "pointer" in mods:
                t.name = "void"
                t.modifiers = tuple(mods)
                t.tag = None
                return t
        else: # typedef
            last_typedef = DIE_name(type_die)
        type_die = type_die.get_DIE_from_attribute('DW_AT_type')
    t.modifiers = tuple(mods)

    if type_die.tag in ('DW_TAG_ptr_to_member_type', 'DW_TAG_subroutine_type'):
        t.tag = type_die.tag[7:-5]
        if t.tag == 'ptr_to_member':
            ptr_prefix = DIE_name(type_die.get_DIE_from_attribute('DW_AT_containing_type')) + "::"
            type_die = type_die.get_DIE_from_attribute('DW_AT_type')
        elif "DW_AT_object_pointer" in type_die.attributes: # Older compiler... Subroutine, but with an object pointer
            ptr_prefix = DIE_name(DIE_type(DIE_type(type_die.get_DIE_from_attribute('DW_AT_object_pointer')))) + "::"
        else: # Function pointer. Expect a pointer as the final modifier
            mods.pop()
            t.modifiers = tuple(mods)
            ptr_prefix = ''

        if t.tag == 'subroutine':
            params = tuple(format_function_param(p, p) for p in type_die.iter_children() if p.tag in ("DW_TAG_formal_parameter", "DW_TAG_unspecified_parameters") and 'DW_AT_artificial' not in p.attributes)
            params = ", ".join(params)
            if 'DW_AT_type' in type_die.attributes:
                retval_type = parse_datatype(type_die)
                retval_type = retval_type.name # TODO: modifiers...
            else:
                retval_type = "void"
            #class_spec = get_class_spec_if_member(func_spec, the_func)
            #class_prefix = class_spec.name + "::" if class_spec else ""
            #class_postfix = " const" if class_spec and class_spec.const_member else ""
            t.name = f"{retval_type} ({ptr_prefix}*)({params})"
            return t
    elif DIE_is_ptr_to_member_struct(type_die):
        dt =  parse_datatype(next(type_die.iter_children())) # The first element is pfn, a function pointer with a this
        dt.modifiers = tuple(dt.modifiers[:-1]) # Pop the extra pointer
        dt.tag = "ptr_to_member_type" # Not a function pointer per se
        return dt

    type_name = safe_DIE_name(type_die, last_typedef)
    
    # This only for compatibility with addr2line. Debugged on ARM64/Android, might have different encodings on different arches
    if type_die.tag == 'DW_TAG_base_type':
        if type_name.endswith(" int") and type_name != "unsigned int":
            type_name = type_name[:-4]
        if type_name.endswith(" unsigned"):
            type_name = "unsigned " + type_name[:-9]
    t.name = type_name

    # Check the nesting
    parent = type_die.get_parent()
    scopes = list()
    while parent.tag in ('DW_TAG_class_type', 'DW_TAG_structure_type', 'DW_TAG_namespace'):
        scopes.insert(0, DIE_name(parent))
        parent = parent.get_parent()
    t.scopes = tuple(scopes)
    
    return t

def get_class_spec_if_member(func_spec, the_func):
    if 'DW_AT_object_pointer' in the_func.attributes:
        this_param = the_func.get_DIE_from_attribute('DW_AT_object_pointer')
        this_type = parse_datatype(this_param)
        class_spec = ClassDesc()
        class_spec.scopes = this_type.scopes + (this_type.name,)
        class_spec.const_member = any(("const", "pointer") == this_type.modifiers[i:i+2]
            for i in range(len(this_type.modifiers))) # const -> pointer -> const for this arg of const 
        return class_spec

    # Check the parent element chain - could be a class
    parent = func_spec.get_parent()

    scopes = []
    while parent.tag in ("DW_TAG_class_type", "DW_TAG_structure_type", "DW_TAG_namespace"):
        scopes.insert(0, DIE_name(parent))
        parent = parent.get_parent()
    if scopes:
        cs = ClassDesc()
        cs.scopes = tuple(scopes)
        return cs

    return None


# scope is a function DIE with a code address
# returns (locals, next_scope)
# where locals is a list of (name, location)
# and next_scope is a inlined function DIE to examine next
# For now, local datatype is not returned
# location is a list of parsed DWARF operations or an empty list
# if the var has no matching location record for the given address
def scan_scope(scope, address):
    locals = []
    next_scope = None
    if 'DW_AT_frame_base' in scope.attributes:
        locals.append(('__frame_base', parse_location(scope.attributes['DW_AT_frame_base'], scope.cu, address), scope))
        #'Type': {'name': 'void', 'modifiers' : ("pointer",), "scopes": (), "tag": None}}
    
    for die in scope.iter_children():
        if die.tag == 'DW_TAG_variable' or die.tag == 'DW_TAG_formal_parameter':
            (k, v) = resolve_local(die, address)
            locals.append((k, v, die))
        elif die.tag == 'DW_TAG_lexical_block' and ip_in_range(die, address):
            (block_locals, next_scope) = scan_scope(die, address)
            locals += block_locals
        elif die.tag ==  'DW_TAG_inlined_subroutine' and ip_in_range(die, address):
            next_scope = die
    return (locals, next_scope)

# returns (name, location_expression)
def resolve_local(p, address):
    loc = False
    if 'DW_AT_abstract_origin' in p.attributes: # Inlined sub formal param
        if 'DW_AT_location' in p.attributes:
            loc = p.attributes['DW_AT_location']
            loc_cu = p.cu
        p = p.get_DIE_from_attribute('DW_AT_abstract_origin')

    #type = parse_datatype(p)
    if not loc and 'DW_AT_location' in p.attributes:
        loc = p.attributes['DW_AT_location']
        loc_cu = p.cu

    if loc:
        expr = parse_location(loc, loc_cu, address)
    else:
        expr = False

    name = safe_DIE_name(p, "(no name attribute)")
    return (name, expr)


def parse_location(loc, cu, address):
    # TODO: check v5 loclists
    ll = cu.dwarfinfo._locparser.parse_from_attribute(loc, cu['version']) # Either a list or a LocationExpr

    # Find the expression blob
    if isinstance(ll, LocationExpr):
        loc_expr = ll.loc_expr
    else: 
        top_die = cu.get_top_DIE()
        base = top_die.attributes['DW_AT_low_pc'].value
        loc_expr = False
        for l in ll:
            if 'base_address' in l._fields:
                base = l.base_address
            elif l.begin_offset <= address - base < l.end_offset:
                loc_expr = l.loc_expr
                break
            
    # Translate to usable format
    if loc_expr:
        # TODO: cache expr parser. Make sure CUs are cached in the dwarfinfo first.
        return list((DWARFExprParser(cu.structs) if cu['version'] > 1 else DWARFExprParserV1(cu.structs)).parse_expr(loc_expr))
    else:
        return []

```

`dwex/exprutil.py`:

```py
from elftools.dwarf.descriptions import _REG_NAMES_x86, _REG_NAMES_x64, _REG_NAMES_AArch64
from elftools.dwarf.dwarf_expr import DWARFExprOp

# TODO: take from pyelftools when they publish
# Source: https://github.com/ARM-software/abi-aa/blob/main/aadwarf32/aadwarf32.rst#dwarf-register-names
_REG_NAMES_ARM = [
    'r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7',
    'r8', 'r9', 'r10', 'r11', 'r12', 'sp', 'lr', 'pc'
] + ['<none>']*48 + ["s%d" %(n,) for n in range(32)] + [
    'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7',
    'acc0', 'acc1', 'acc2', 'acc3', 'acc4', 'acc5', 'acc6', 'acc7', #AKA wcgr0..7
    'wr0', 'wr1', 'wr2', 'wr3', 'wr4', 'wr5', 'wr6', 'wr7',
    'wr8', 'wr9', 'wr10', 'wr11', 'wr12', 'wr13', 'wr14', 'wr15',
    'spsr', 'spsr_fiq', 'spsr_irq', 'spsr_abt', 'spsr_und', 'spsr_svc'] + ['<none>']*9 + [
    'ra_auth_code', 'r8_usr', 'r9_usr', 'r10_usr', 'r11_usr', 'r12_usr', 'r13_usr', 'r14_usr',
    'r8_fiq', 'r9_fiq', 'r10_fiq', 'r11_fiq', 'r12_fiq', 'r13_fiq', 'r14_fiq',
    'r13_irq', 'r14_irq', 'r13_abt', 'r14_abt',
    'r13_und', 'r14_und', 'r13_svc', 'r14_svc'] + ['<none>']*26 + [
    'wc0', 'wc1', 'wc2', 'wc3', 'wc4', 'wc5', 'wc6', 'wc7'] + ['<none>']*56 + [
        "d%d" %(n,) for n in range(32)] + ['<none>']*32 + [
     'tpidruro', 'tpidrurw', 'tpidpr', 'htpidpr'
]

_REG_NAMES_MIPS = [
    '$zero', '$at', '$v0', '$v1', '$a0', '$a1', '$a2', '$a3',
    '$t0', '$t1', '$t2', '$t3', '$t4', '$t5', '$t6', '$t7',
    '$s0', '$s1', '$s2', '$s3', '$s4', '$s5', '$s6', '$s7',
    '$t8', '$t9', '$k0', '$k1', '$gp', '$sp', '$fp', '$ra',
    '$ps', '$lo', '$hi', '$badvaddr', '$cause', '$pc'] + [
        '$fp%d' % n for n in range(35)] + ['<none>'] + [
        '$cp%d' % n for n in range(15)] + ['$prid']

# Source: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-dwarf.adoc
_REG_NAMES_RISCV = [
    'zero', 'ra', 'sp', 'gp', 'tp', 't0', 't1', 't2',
    'fp', 's1', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5',
    'a6', 'a7', 's2', 's3', 's4', 's5', 's6', 's7',
    't8', 't9', 's10', 's11', 't3', 't4', 't5', 't6'] + [
        'f%d' % n for n in range(32)] + ['afrc'] + ['<none>']*31 + [
        'v%d' % n for n in range(32)]

# Source for 64 bit: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-dwarf.adoc
# Source for 32 bit: http://refspecs.linux-foundation.org/elf/elfspec_ppc.pdf
# They are sufficiently similar
# There are some more kernel level registers defined in the ABI at #356 and further, not listed here
_REG_NAMES_POWERPC = ['r%d' % n for n in range(32)] +[
      'f%d' % n for n in range(32)] +[
    'cr', 'fpscr', 'msr', '<none>', '<none>', '<none>',
    'sr0', 'sr1', 'sr2', 'sr3', 'sr4', 'sr5', 'sr6', 'sr7',
    'sr8', 'sr9', 'sr10', 'sr11', 'sr12', 'sr13', 'sr14', 'sr15'] + ['<none>']*14 + [
    'mq', 'xer', '<none>', '<none>', 'rtcu', 'rtcl', '<none>', '<none>',
    'lr', 'ctr', '<none>', '<none>', '<none>', '<none>', '<none>', '<none>',
    '<none>', '<none>', 'dsisr', 'dar', '<none>', '<none>', 'dec', '<none>',
    '<none>', 'sdr1', 'srr0', 'srr1']

# More? 

# The key here is the machine_arch value in the DWARFConfig struct.
# Machine arch values are generated differently for ELF, MachO and PE
# For ELF, see the values in the architecture dict in get_machine_arch() under elftools.elf.elffile
# For PE, see IMAGE_FILE_MACHINE in filebytes.pe
# For MachO, see make_macho_arch_name() in formats.py, which derives from CpuType under filebytes.mach_o and subtypes

_REG_NAME_MAP = {
    'x86': _REG_NAMES_x86,
    'I386': _REG_NAMES_x86,
    'x64': _REG_NAMES_x64,
    'AMD64': _REG_NAMES_x64,
    'X86_64': _REG_NAMES_x64,
    'ARM': _REG_NAMES_ARM,
    'ARMV6': _REG_NAMES_ARM,
    'ARMV7': _REG_NAMES_ARM,
    'ARMV7A': _REG_NAMES_ARM,
    'ARMV7S': _REG_NAMES_ARM,
    'AArch64': _REG_NAMES_AArch64,
    'ARM64': _REG_NAMES_AArch64,
    'ARME': _REG_NAMES_AArch64,
    'MIPS': _REG_NAMES_MIPS,
    'RISC-V': _REG_NAMES_RISCV,
    'PowerPC': _REG_NAMES_POWERPC,
    '64-bit PowerPC': _REG_NAMES_POWERPC
}

class ExprFormatter:
    # Operator codes differ in DWARFv1, thus the need for version
    # regnames: False for friendly names, True for DWARF names
    # prefix: False for friendly, True for DW_OP_xxx
    # address_delta is the addend that will account for a custom loading address
    def __init__(self, regnames, prefix, arch, dwarf_version, hex):
        self.regnames = regnames
        self.prefix = prefix
        self.arch = arch
        self.regnamelist = _REG_NAME_MAP.get(self.arch)
        self.dwarf_version = dwarf_version # Likely to change
        self.hex = hex
        self.address_delta = 0

    def set_arch(self, arch):
        if arch != self.arch:
            self.arch = arch
            self.regnamelist = _REG_NAME_MAP.get(self.arch)

    def set_address_delta(self, ad):
        self.address_delta = ad

    def decode_breg(self, regno, offset):
        if offset == 0:
            return '[%s]' % (self.regnamelist[regno],)
        elif -10 < offset < 0:
            return '[%s-%x]' % (self.regnamelist[regno], -offset)
        elif offset <= 10:
            return '[%s-0x%x]' % (self.regnamelist[regno], -offset)
        elif 0 < offset < 10:
            return '[%s+%x]' % (self.regnamelist[regno], offset)
        else:
            return '[%s+0x%x]' % (self.regnamelist[regno], offset)

    def format_op(self, op, op_name, args, offset):
        def format_arg(s):
            if isinstance(s, str):
                return s
            elif isinstance(s, int):
                # TODO: more discerning here, hex elsewhere?
                return hex(s) if (self.hex or op == 0x03) and not(-10 < s < 10) else str(s) 
            elif isinstance(s, list): # Could be a blob (list of ints), could be a subexpression
                if len(s) > 0 and isinstance(s[0], DWARFExprOp): # Subexpression
                    return '{' + '; '.join(self.format_op(*op) for op in s) + '}'
                else:
                    return bytes(s).hex() # Python 3.5+

        if not self.regnames and self.regnamelist: # Friendly register names
            if 0x50 <= op <= 0x6f and op - 0x50 < len(self.regnamelist): # reg0...reg31
                op_name = self.regnamelist[op-0x50]
            elif 0x70 <= op <= 0x8f and op - 0x70 < len(self.regnamelist) and len(args) > 0: # breg0...breg31(offset)
                op_name = self.decode_breg(op - 0x70, args[0])
                args = False
            elif (op == 0x90 or (self.dwarf_version == 1 and op == 0x1)) and len(args) > 0 and args[0] >= 0 and args[0] < len(self.regnamelist): # regx(regno)
                op_name = self.regnamelist[args[0]]
                args = False
            elif op == 0x92 and len(args) > 1 and args[0] >= 0 and args[0] < len(self.regnamelist): # bregx(regno, offset)
                op_name = self.decode_breg(args[0], args[1])
                args = False

        if op_name.startswith('DW_OP_') and not self.prefix:
            op_name = op_name[6:]

        if args:
            if op == 0x03: # DW_OP_addr: relocate
                args = [args[0] + self.address_delta]
            return op_name + ' ' + ', '.join(format_arg(s) for s in args)
        else:
            return op_name


```

`dwex/formats.py`:

```py
import io, os
from os import path, listdir
from elftools.dwarf.dwarfinfo import DWARFInfo, DebugSectionDescriptor, DwarfConfig
# This doesn't depend on Qt
# The dependency on filebytes only lives here
# Format codes: 0 = ELF, 1 = MACHO, 2 = PE, 3 - WASM

class FormatError(Exception):
    def __init__(self, s):
        Exception.__init__(self, s)

def read_pe(filename):
    from filebytes.pe import PE, IMAGE_FILE_MACHINE

    pefile = PE(filename)

    # Section's real size might be padded - see https://github.com/sashs/filebytes/issues/28
    sections = [(section.name, section,
        section.header.PhysicalAddress_or_VirtualSize,
        section.header.SizeOfRawData)
        for section in pefile.sections
        if section.name.startswith('.debug')]

    data = {name: DebugSectionDescriptor(io.BytesIO(section.bytes), name, None,
            raw_size if virtual_size == 0 else min((raw_size, virtual_size)), 0)
        for (name, section, virtual_size, raw_size) in sections}

    if not '.debug_info' in data:
        return None

    machine = pefile.imageNtHeaders.header.FileHeader.Machine
    is64 = machine in (IMAGE_FILE_MACHINE.AMD64, IMAGE_FILE_MACHINE.ARM64, IMAGE_FILE_MACHINE.IA64) # There are also some exotic architectures...
    di = DWARFInfo(
        config = DwarfConfig(
            little_endian = True,
            default_address_size = 8 if is64 else 4,
            machine_arch = IMAGE_FILE_MACHINE[machine].name
        ),
        debug_info_sec = data['.debug_info'],
        debug_aranges_sec = data.get('.debug_aranges'),
        debug_abbrev_sec = data.get('.debug_abbrev'),
        debug_frame_sec = data.get('.debug_frame'),
        eh_frame_sec = None, # Haven't seen one in the wild so far
        debug_str_sec = data.get('.debug_str'),
        debug_loc_sec = data.get('.debug_loc'),
        debug_ranges_sec = data.get('.debug_ranges'),
        debug_line_sec = data.get('.debug_line'),
        debug_pubtypes_sec = data.get('.debug_pubtypes'),
        debug_pubnames_sec = data.get('.debug_pubnames'),
        debug_addr_sec = data.get('.debug_addr'),
        debug_str_offsets_sec = data.get('.debug_str_offsets'),
        debug_line_str_sec = data.get('.debug_line_str'),
        debug_loclists_sec = data.get('.debug_loclists'),
        debug_rnglists_sec = data.get('.debug_rnglists'),
        debug_sup_sec = data.get('.debug_sup'),
        gnu_debugaltlink_sec = data.get('.gnu_debugaltlink')
    )
    di._format = 2
    di._start_address = pefile.imageNtHeaders.header.OptionalHeader.ImageBase
    return di

# Arch + flavor where flavor matters
def make_macho_arch_name(macho):
    from filebytes.mach_o import CpuType, CpuSubTypeARM, CpuSubTypeARM64
    h = macho.machHeader.header
    c = h.cputype
    st = h.cpusubtype
    flavor = ''
    if st != 0:
        if c == CpuType.ARM:
            flavor = CpuSubTypeARM[st].name
        elif c == CpuType.ARM64:
            flavor = CpuSubTypeARM64[st].name
    return CpuType[c].name + flavor
        
# For debugging purposes only - dump individual debug related sections in a Mach-O file/slice as files
def macho_save_sections(filename, macho):
    from filebytes.mach_o import LC
    arch = make_macho_arch_name(macho)
    for cmd in macho.loadCommands:
        if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64):
            for section in cmd.sections:
                if section.name.startswith('__debug'):
                    sec_file = ".".join((filename, arch, section.name))
                    if not path.exists(sec_file):
                        with open(sec_file, 'wb') as f:
                            f.write(section.bytes)


# resolve_arch takes a list of architecture descriptions, and returns
# the desired index, or None if the user has cancelled
def read_macho(filename, resolve_arch, friendly_filename):
    from filebytes.mach_o import MachO, CpuType, TypeFlags, LC
    fat_arch = None
    macho = MachO(filename)
    if macho.isFat:
        slices = [make_macho_arch_name(slice) for slice in macho.fatArches]
        arch_no = resolve_arch(slices)
        if arch_no is None: # User cancellation
            return False
        fat_arch = slices[arch_no]
        macho = macho.fatArches[arch_no]

    # We proceed with macho being a arch-specific file, or a slice within a fat binary
    data = {
        section.name: DebugSectionDescriptor(io.BytesIO(section.bytes), section.name, None, len(section.bytes), 0)
        for cmd in macho.loadCommands
        if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64)
        for section in cmd.sections
        if section.name.startswith('__debug')
    }

    #macho_save_sections(friendly_filename, macho)

    if not '__debug_info' in data:
        return None

    cpu = macho.machHeader.header.cputype
    di = DWARFInfo(
        config = DwarfConfig(
            little_endian=True,
            default_address_size = 8 if (cpu & TypeFlags.ABI64) != 0 else 4,
            machine_arch = make_macho_arch_name(macho)
        ),
        debug_info_sec = data['__debug_info'],
        debug_aranges_sec = data.get('__debug_aranges'),
        debug_abbrev_sec = data['__debug_abbrev'],
        debug_frame_sec = data.get('__debug_frame'),
        eh_frame_sec = None, # Haven't seen those in Mach-O
        debug_str_sec = data['__debug_str'],
        debug_loc_sec = data.get('__debug_loc'),
        debug_ranges_sec = data.get('__debug_ranges'),
        debug_line_sec = data.get('__debug_line'),
        debug_pubtypes_sec = data.get('__debug_pubtypes'), #__debug_gnu_pubn?
        debug_pubnames_sec = data.get('__debug_pubtypes'), #__debug_gnu_pubt?
        debug_addr_sec = data.get('__debug_addr'),
        debug_str_offsets_sec = data.get('__debug_str_offsets'),
        debug_line_str_sec = data.get('__debug_line_str'),
        debug_loclists_sec = data.get('__debug_loclists'),
        debug_rnglists_sec = data.get('__debug_rnglists'),
        debug_sup_sec = data.get('__debug_sup'),
        gnu_debugaltlink_sec = data.get('__gnu_debugaltlink')
    )
    di._format = 1
    di._fat_arch = fat_arch
    text_cmd = next((cmd for cmd in macho.loadCommands if cmd.header.cmd in (LC.SEGMENT, LC.SEGMENT_64) and cmd.name == "__TEXT"), False)
    di._start_address = text_cmd.header.vmaddr if text_cmd else 0
    return di

_WASM_section_header = False

def read_wasm(file):
    global _WASM_section_header
    from elftools.common.construct_utils import ULEB128, StreamOffset
    from elftools.construct import ULInt8, ULInt32, Struct, If, PascalString, Value
    if not _WASM_section_header:
        _WASM_section_header = Struct('WASMSectionHeader',
            ULInt8('id'),
            ULEB128('section_length'),
            StreamOffset('off1'),
            # Subheader on custom (id 0) sections - ULEB128 length prefixed name
            If(lambda ctx: ctx.id == 0, PascalString('name', length_field = ULEB128('length'), encoding='UTF-8')),
            StreamOffset('off2'),
            # This is effective content length - for custom sections, section size minus the name subheader
            Value('length', lambda ctxt: ctxt.section_length - ctxt.off2 + ctxt.off1)
        )
    
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    # Signature already checked, move on to file version
    file.seek(4, os.SEEK_SET)
    ver = ULInt32('').parse_stream(file)
    if ver != 1:
        raise FormatError("WASM binary format version %d is not supported." % ver)
    
    data = dict()
    dwarf_url = None
    while file.tell() < file_size:
        sh = _WASM_section_header.parse_stream(file)
        if sh.id == 0 and sh.name.startswith(".debug"):
            content = file.read(sh.length)
            data[sh.name] = DebugSectionDescriptor(io.BytesIO(content), sh.name, None, sh.length, 0)
        elif sh.id == 0 and sh.name == 'external_debug_info':
            dwarf_url = file.read(sh.length).decode('UTF-8')
        else: # Skip this section
            file.seek(sh.length, os.SEEK_CUR)

    if dwarf_url:
        raise FormatError("The debug information for this WASM file is at %s." % dwarf_url)

    # TODO: relocations, start address

    di = DWARFInfo(
        config = DwarfConfig(
            little_endian=True,
            default_address_size = 4, # Is it variable???
            machine_arch = 'WASM'
        ),
        debug_info_sec = data['.debug_info'],
        debug_aranges_sec = data.get('.debug_aranges'),
        debug_abbrev_sec = data['.debug_abbrev'],
        debug_frame_sec = data.get('.debug_frame'),
        eh_frame_sec = None, # In WASM??
        debug_str_sec = data['.debug_str'],
        debug_loc_sec = data.get('.debug_loc'),
        debug_ranges_sec = data.get('.debug_ranges'),
        debug_line_sec = data.get('.debug_line'),
        debug_pubtypes_sec = data.get('.debug_pubtypes'),
        debug_pubnames_sec = data.get('.debug_pubtypes'),
        debug_addr_sec = data.get('.debug_addr'),
        debug_str_offsets_sec = data.get('.debug_str_offsets'),
        debug_line_str_sec = data.get('.debug_line_str'),
        debug_loclists_sec = data.get('.debug_loclists'),
        debug_rnglists_sec = data.get('.debug_rnglists'),
        debug_sup_sec = None,
        gnu_debugaltlink_sec = None
    )
    di._format = 3
    di._start_address = 0
    return di

def read_elf(file, filename):
    from elftools.elf.elffile import ELFFile
    file.seek(0)
    # TODO: interactive supplemental DWARF resolver here...
    elffile = ELFFile(file, lambda s: open(path.join(path.dirname(filename), s), 'rb'))

    # Retrieve the preferred loading address
    load_segment = next((seg for seg in elffile.iter_segments() if seg.header.p_type == 'PT_LOAD'), None)
    start_address = load_segment.header.p_vaddr if load_segment else 0
    di = None
    if elffile.has_dwarf_info():
        di = elffile.get_dwarf_info()
    elif elffile.get_section_by_name(".debug"):
        from .dwarfone import parse_dwarf1
        di = parse_dwarf1(elffile)

    if di:
        di._format = 0
        di._start_address = start_address
    return di    

# UI agnostic - resolve_arch might be interactive
# Returns slightly augmented DWARFInfo
# Or None if not a DWARF containing file (or unrecognized)
# Or False if user has cancelled
# Or throws an exception
# resolve_arch is for Mach-O fat binaries - see read_macho()
def read_dwarf(filename, resolve_arch):
    if path.isfile(filename): # On MacOS, opening dSYM bundles as is would be right
        file = None
        try: # For ELF, the file is to remain open
            file = open(filename, 'rb')
            signature = file.read(4)

            if signature[0:2] == b'MZ': # DOS header - this might be a PE. Don't verify the PE header, just feed it to the parser
                return read_pe(filename)
            elif signature == b'\x7FELF': #It's an ELF
                di = read_elf(file, filename)
                file = None # Keep the file open
                return di
            elif signature in (b'\xCA\xFE\xBA\xBE', b'\xFE\xED\xFA\xCE', b'\xFE\xED\xFA\xCF', b'\xCE\xFA\xED\xFE', b'\xCF\xFA\xED\xFE'):
                if signature == b'\xCA\xFE\xBA\xBE' and int.from_bytes(file.read(4), 'big') >= 0x20:
                    # Java .class files also have CAFEBABE, check the fat binary arch count
                    return None
                # Mach-O fat binary, or 32/64-bit Mach-O in big/little-endian format
                return read_macho(filename, resolve_arch, filename)
            elif signature == b'\0asm':
                return read_wasm(file)
        finally:
            if file:
                file.close()                
    elif path.isdir(filename):
        # Is it a dSYM bundle?
        nameparts = path.basename(filename).split('.') 
        if nameparts[-1] == 'dSYM' and path.exists(path.join(filename, 'Contents', 'Resources', 'DWARF')):
            files = listdir(path.join(filename, 'Contents', 'Resources', 'DWARF'))
            if len(files) > 0:
                # When are there multiple DWARF files in a dSYM bundle?
                # TODO: let the user choose?
                dsym_file_path = path.join(filename, 'Contents', 'Resources', 'DWARF', files[0])
                return read_macho(dsym_file_path, resolve_arch, filename)
        # Is it an app bundle? appname.app
        if len(nameparts) > 1 and nameparts[-1] in ('app', 'framework'):
            app_file = path.join(filename, '.'.join(nameparts[0:-1]))
            if path.exists(app_file):
                return read_macho(app_file, resolve_arch, filename)

        # Any other bundle formats we should be aware of?
    return None

def get_debug_sections(di):
    section_names = {name: "debug_%s_sec" % name
            for name in 
            ('info', 'aranges', 'abbrev', 'frame',
            'str', 'loc', 'ranges', 'line', 'addr',
            'str_offsets', 'line_str', 'pubtypes',
            'pubnames', 'loclists', 'rnglists', 'sup')}
    section_names['eh_frame'] = 'eh_frame_sec'
    section_names['gnu_debugaltlink'] = 'gnu_debugaltlink'

    # Display name to section object
    return {display_name: getattr(di, field_name)
        for (display_name, field_name) in section_names.items()
        if getattr(di, field_name, False)}    

```

`dwex/locals.py`:

```py
from PyQt6.QtCore import Qt, QAbstractTableModel, QSize
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QFontInfo, QFont
from elftools.dwarf.locationlists import LocationParser, LocationExpr

from dwex.exprutil import ExprFormatter
from .dwarfutil import *

#0x25af0
#0xd864 (black)
# test: d989, n with False for expression
#0xdc6e (lxxx)
#TODO: refactor away C++, support C explicitly
#TODO: Objective C, Pascal, more?

headers = ["Name", "Location"]
_bold_font = None

# TODO: move elsewhere
class WaitCursor():
    def __enter__(self):
        QApplication.setOverrideCursor(Qt.CursorShape.WaitCursor)

    def __exit__(self, *args):
        QApplication.restoreOverrideCursor()

class SeveralFunctionsError(Exception):
    pass

#######################################################################

class LocalsModel(QAbstractTableModel):
    # Data is a list (is_scope, name, location, die)
    def __init__(self, data, expr_formatter):
        QAbstractTableModel.__init__(self)
        self.data = data
        self.expr_formatter = expr_formatter

    def headerData(self, section, ori, role):
        if ori == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return headers[section]

    def rowCount(self, parent):
        return len(self.data)

    def columnCount(self, parent):
        return 2

    def data(self, index, role):
        (row, col) = (index.row(), index.column())
        the_row = self.data[row]
        val = the_row[col+1]
        if role == Qt.ItemDataRole.DisplayRole:
            if col == 1 and not the_row[0]: # Location on a variable
                if val is False: # No location
                    return '<N/A>'
                elif len(val) == 0: # Loclist, but not for the given address
                    return '<N/A>'
                elif len(val) > 3: # Variable
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val[0:3]) + "...+%d" % (len(val)-3)
                else:
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val)
            return val
        elif role == Qt.ItemDataRole.FontRole:
            if the_row[0]:
                global _bold_font
                if not _bold_font:
                    fi = QFontInfo(QApplication.font())
                    _bold_font = QFont(fi.family(), fi.pointSize(), QFont.Weight.Bold)
                return _bold_font
        elif role == Qt.ItemDataRole.ToolTipRole:
            if col == 1 and not the_row[0]: # On the location column of a variable
                if val is False:
                    return 'No location provided'
                elif len(val) == 0:
                    return 'The variable was optimized away at the provided address'
                elif len(val) > 3:
                    return "; ".join(self.expr_formatter.format_op(*op) for op in val)

############################################################################

class LocalsDlg(QDialog):
    _last_address = '' # Stored as string to allow for blank
    _last_start_address = 0 # Stored as int

    def __init__(self, win, di, prefix, regnames, hexadecimal):
        QDialog.__init__(self, win, Qt.WindowType.Dialog)
        self.selected_die = False
        self.resize(500, 400)
        self.dwarfinfo = di
        if di._locparser is None:
            di._locparser = LocationParser(di.location_lists())
        if not di._ranges:
            di._ranges = di.range_lists()            
        if not di._aranges:
            di._aranges = di.get_aranges()

        self.expr_formatter = ExprFormatter(regnames, prefix, di.config.machine_arch, 2, hexadecimal) # DWARF version is unknowable for now

        ly = QVBoxLayout()
        l = QLabel(self)
        l.setText("Provide a hex code address:")
        ly.addWidget(l)
        self.address = QLineEdit(self._last_address, self)
        ly.addWidget(self.address)
        l = QLabel(self)
        l.setText("Assuming the module is loaded at:")
        ly.addWidget(l)
        self.start_address = QLineEdit(hex(self._last_start_address), self)
        ly.addWidget(self.start_address)

        buttons = QDialogButtonBox(self)
        bu = QPushButton("Check", self)
        bu.clicked.connect(self.on_check)
        buttons.addButton(bu, QDialogButtonBox.ButtonRole.ApplyRole)
        ly.addWidget(buttons)

        self.locals = QTableView()
        self.locals.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.locals.doubleClicked.connect(self.on_dclick)
        ly.addWidget(self.locals)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close, Qt.Orientation.Horizontal, self)
        self.nav_bu = QPushButton("Navigate", self)
        self.nav_bu.clicked.connect(self.on_navigate)
        self.nav_bu.setEnabled(False)
        buttons.addButton(self.nav_bu, QDialogButtonBox.ButtonRole.ApplyRole)
        buttons.accepted.connect(self.reject)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)
        self.setWindowTitle('Locals at address')
        self.setLayout(ly)

    def on_check(self): #TODO: relocate absolute addresses in expressions
        try: # Try of just in case
            with WaitCursor():
                self.nav_bu.setEnabled(False) # Even if error, stay disabled

                try:
                    # Hex, with or without the 0x prefix
                    address = int(self.address.text(), 16)
                    real_start_address = int(self.start_address.text(), 16)
                except ValueError:
                    return
                
                LocalsDlg._last_address = self.address.text()
                LocalsDlg._last_start_address = real_start_address

                preferred_start_address = self.dwarfinfo._start_address
                address += preferred_start_address - real_start_address # Now relative to the preferred start address
                self.expr_formatter.set_address_delta(real_start_address - preferred_start_address) # Relocate addr on the way out

                # Find the CU for the address
                di = self.dwarfinfo
                funcs = False
                cu = find_cu_by_address(di, address)
                if cu is not None:
                    # Find the function(s) at the address - could be some inlines
                    funcs = find_funcs_at_address(cu, address)
                
                if not funcs: # No CUs or no functions at that IP
                    QMessageBox(QMessageBox.Icon.Information, "DWARF Explorer", 
                        "No functions were found at that code address.", QMessageBox.StandardButton.Ok, self).show()
                    return

                if len(funcs) != 1:
                    raise SeveralFunctionsError()

                func = funcs[0]
                (origin, func_desc) = follow_function_spec(func)
                # This the file:line of the IP. It points at the innermost inline
                file_and_line = get_source_line(func, address)
                (address_file, address_line) = ("?","?") if file_and_line is None else file_and_line
                (func_name, mangled_func_name) = retrieve_function_names(func_desc, func)

                frames = [] # a collection of (func_name, file, line, die, locals), innermost at the top
                while True: # Loop by function from outermost to innermost; inside the top level one there might be inlines
                    (locals, next_func) = scan_scope(func, address)
                    if next_func: # Found a nested inline function, move on to that
                        call_file = get_source_file_name_from_attr(next_func, 'DW_AT_call_file') or '?'
                        call_line = next_func.attributes['DW_AT_call_line'].value if 'DW_AT_call_line' in next_func.attributes else '?'
                        frames.insert(0, (func_name, call_file, call_line, func, locals))
                        func = next_func
                        (inline_func, inline_func_spec) = follow_function_spec(func)
                        (func_name, mangled_func_name) = retrieve_function_names(inline_func_spec, inline_func)
                    else:
                        frames.insert(0, (func_name, address_file, address_line, func, locals))
                        break

                # Now render to lines:
                grid_lines = []
                for (name, file, line, func_die, locals) in frames:
                    grid_lines.append((True, name, '%s:%d' % (file, line), func_die))
                    self.expr_formatter.dwarf_version = func_die.cu['version'] # The variable should not be in a different CU than the containing function
                    for (name, expr, die) in locals:
                        grid_lines.append((False, name,  expr, die))

                # Finally display
                self.locals.setModel(LocalsModel(grid_lines, self.expr_formatter))
                self.locals.selectionModel().currentChanged.connect(self.on_sel)
                header = self.locals.horizontalHeader()
                header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
                header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        except SeveralFunctionsError:
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "Expected one function with that address, found %d." % (len(funcs),), QMessageBox.StandardButton.Ok, self).show()
        except NoBaseError:
            # Any user followup maybe?
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "Unexpected error while analysing the debug information." % (len(funcs),), QMessageBox.StandardButton.Ok, self).show()
        except NotImplementedError as exc:
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer", 
                "This feature is not supported on DWARF v1 yet.", QMessageBox.StandardButton.Ok, self).show()
        except Exception as exc:
            QMessageBox(QMessageBox.Icon.Critical, "DWARF Explorer", 
                "Unexpected error while analysing the debug information.", QMessageBox.StandardButton.Ok, self).show()
            
    def on_navigate(self):
        row = self.locals.currentIndex().row()
        self.selected_die = self.locals.model().data[row][3]
        self.done(QDialog.DialogCode.Accepted)

    def on_dclick(self, index):
        row = index.row()
        self.selected_die = self.locals.model().data[row][3]
        self.done(QDialog.DialogCode.Accepted)        

    def on_sel(self, index, prev = None):
        self.nav_bu.setEnabled(index.isValid())

    @classmethod
    def reset(cl, di):
        cl._last_start_address = di._start_address
        cl._last_address = ''


```

`dwex/locs.py`:

```py
from elftools.dwarf.locationlists import LocationParser, LocationExpr, BaseAddressEntry
from elftools.common.exceptions import ELFParseError
from .details import GenericTableModel
from .dwarfutil import *
from .ranges import lowlevel_v5_tooltips, one_of

def parse_location(self, attr):
    di = self.die.dwarfinfo
    if di._locparser is None:
        di._locparser = LocationParser(di.location_lists())
    try:
        return di._locparser.parse_from_attribute(attr, self.die.cu['version'], die = self.die)
    except ELFParseError as exc:
        from .__main__ import version
        from .crash import report_crash
        from inspect import currentframe

        die = self.die
        header = die.cu.header
        dwarf_version = die.cu.header.version
        di = die.cu.dwarfinfo
        ctxt = {'attr': attr,
                'die': die,
                'cu_header': header,
                'LE': di.config.little_endian,
                'dwarf_version': dwarf_version}
        try:
            if LocationParser._attribute_has_loc_list(attr, self.die.cu['version']):
                tb = exc.__traceback__
                tracebacks = []
                while tb.tb_next:
                    tracebacks.insert(0, tb) # Innermost in the beginning of the list
                    tb = tb.tb_next
                loc_section = di.debug_loclists_sec if dwarf_version >= 5 else di.debug_loc_sec
                if loc_section:
                    buf = loc_section.stream.getbuffer()
                    ctxt['loc_section_len'] = len(buf)
                    if len(tracebacks) > 1 and 'entry_offset' in tracebacks[1].tb_frame.f_locals:
                        fail_entry_offset = tracebacks[1].tb_frame.f_locals['entry_offset']
                        ctxt['fail_entry_offset'] = fail_entry_offset
                        llend = fail_entry_offset + 8*2+2 if fail_entry_offset - attr.value <= 1024 else attr.value + 1024
                        llbytes = buf[attr.value:llend]
                        ctxt['llbytes'] = ' '.join("%02x" % b for b in llbytes)
        except:
            pass

        report_crash(exc, tb, version, currentframe(), ctxt)
        return None

def show_location(self, attr):
# Expression is a list of ints
# TODO: clickable expression maybe?
# TODO: truncate long expressions?
    ll = self.parse_location(attr)
    if ll is None:
        return None
    elif isinstance(ll, LocationExpr):
        # TODO: low level maybe
        # Spell out args?
        # Opcode tooltips?
        return GenericTableModel(("Command",), ((cmd,) for cmd in self.dump_expr(ll.loc_expr)))
    else: # Loclist
        cu_base = get_cu_base(self.die)
        values = list()
        if self.lowlevel:
            ver5 = self.die.cu['version'] >= 5
            if ver5:
                headers = ("Entry offset", "Type", "Start/Index/Base", "End/Index/Length", "Start address", "End address", "Expr bytes", "Expression")
                raw_ll = self.die.dwarfinfo.location_lists().get_location_lists_at_offset_ex(attr.value)
            else:
                headers = ("Entry offset", "Type", "Start address", "End address", "Expr bytes", "Expression")
            for (i, l) in enumerate(raw_ll if ver5 else ll):
                if ver5: #l is raw
                    raw = l
                    l = ll[i] # Translated entry

                if isinstance(l, BaseAddressEntry):
                    cu_base = l.base_address
                    if ver5:
                        (raw_base_type, raw_base) = one_of(raw, ('index','address'))
                        values.append((hex(l.entry_offset),
                            raw.entry_type if self.prefix else raw.entry_type[7:],
                            hex(raw_base) if raw_base_type == 1 else str(raw_base),
                            '',
                            hex(l.base_address),
                            '', '', ''))
                    else:
                        values.append((hex(l.entry_offset), 'Base', hex(l.base_address), '', '', ''))
                else:
                    try: # Catching #1609
                        expr_dump = '; '.join(self.dump_expr(l.loc_expr))
                    except KeyError as exc:
                        expr_dump = "<unrecognized expression>"
                        from .__main__ import version
                        from .crash import report_crash
                        from inspect import currentframe
                        report_crash(exc, exc.__traceback__, version, currentframe())
                    base = 0 if l.is_absolute else cu_base
                    if ver5:
                        is_def_loc = raw.entry_type == 'DW_LLE_default_location'
                        (raw_start_type, raw_start) = one_of(raw, ('index', 'start_index', 'start_offset', 'start_address'))
                        (raw_end_type, raw_end) = one_of(raw, ('end_index', 'length', 'end_offset', 'end_address'))
                        values.append((hex(l.entry_offset),
                            raw.entry_type if self.prefix else raw.entry_type[7:],
                            '' if is_def_loc else (hex(raw_start) if raw_start_type >= 2 else str(raw_start)),
                            '' if is_def_loc else (hex(raw_end) if raw_end_type >= 2 or (raw_end_type == 1 and self.hex) else str(raw_end)),
                            hex(base + l.begin_offset),
                            hex(base + l.end_offset),
                            ' '.join("%02x" % b for b in l.loc_expr),
                            expr_dump))
                    else:
                        values.append((hex(l.entry_offset),
                            'Range',
                            hex(base + l.begin_offset),
                            hex(base + l.end_offset),
                            ' '.join("%02x" % b for b in l.loc_expr),
                            expr_dump))
        else: # Not low level
            headers = ("Start address", "End address", "Expression")
            for l in ll:
                if 'base_address' in l._fields:
                    cu_base = l.base_address
                else:
                    try: # Catching #1609
                        expr_dump = '; '.join(self.dump_expr(l.loc_expr))
                    except KeyError as exc:
                        expr_dump = "<unrecognized expression>"
                        from .__main__ import version
                        from .crash import report_crash
                        from inspect import currentframe
                        report_crash(exc, exc.__traceback__, version, currentframe())
                    base = 0 if l.is_absolute else cu_base
                    values.append((hex(base + l.begin_offset),
                        hex(base + l.end_offset),
                        expr_dump))
                    
        return GenericTableModel(headers, values,
            get_tooltip=lambda row, col: lowlevel_v5_tooltips(raw_ll[row], col-2) if self.lowlevel and ver5 else None)
```

`dwex/patch.py`:

```py
import os

import elftools.dwarf.enums
import elftools.dwarf.dwarf_expr
import elftools.dwarf.locationlists
import elftools.elf.elffile
import elftools.dwarf.dwarfinfo
from elftools.common.utils import struct_parse
from elftools.common.exceptions import DWARFError
from elftools.dwarf.descriptions import _DESCR_DW_CC
from elftools.dwarf.dwarfinfo import DebugSectionDescriptor
from elftools.elf.relocation import RelocationHandler
from elftools.dwarf.locationlists import LocationLists, LocationListsPair
from types import MethodType
from io import BytesIO

def monkeypatch():
    #https://docs.hdoc.io/hdoc/llvm-project/e051F173385B23DEF.html
    elftools.dwarf.enums.ENUM_DW_AT["DW_AT_LLVM_apinotes"] = 0x3e07
    elftools.dwarf.enums.ENUM_DW_AT["DW_AT_APPLE_objc_direct"] = 0x3fee
    elftools.dwarf.enums.ENUM_DW_AT["DW_AT_APPLE_sdk"] = 0x3fef

    # Wasmloc: monkeypatch for #1589
    elftools.dwarf.dwarf_expr.DW_OP_name2opcode["DW_OP_WASM_location"] = 0xed
    elftools.dwarf.dwarf_expr.DW_OP_opcode2name[0xed] = "DW_OP_WASM_location"
    elftools.dwarf.dwarf_expr.DW_OP_name2opcode['DW_OP_GNU_uninit'] = 0xf0
    elftools.dwarf.dwarf_expr.DW_OP_opcode2name[0xf0] = 'DW_OP_GNU_uninit'
    old_init_dispatch_table = elftools.dwarf.dwarf_expr._init_dispatch_table
    def _init_dispatch_table_patch(structs):
        def parse_wasmloc():
            def parse(stream):
                op = struct_parse(structs.Dwarf_uint8(''), stream)
                if 0 <= op <= 2:
                    return [op, struct_parse(structs.Dwarf_uleb128(''), stream)]
                elif op == 3:
                    return [op, struct_parse(structs.Dwarf_uint32(''), stream)]
                else:
                    raise DWARFError("Unknown operation code in DW_OP_WASM_location: %d" % (op,))
            return parse
        #wasmloc patch
        table = old_init_dispatch_table(structs)
        table[0xed] = parse_wasmloc()
        # GNU_uninit
        table[0xf0] = lambda s: []
        return table
    
    elftools.dwarf.dwarf_expr._init_dispatch_table = _init_dispatch_table_patch

    # Fix for 1613 and other bogus loclist/bogus expr bugs
    def _attribute_is_constant(attr, dwarf_version):
        return (((dwarf_version >= 3 and attr.name == 'DW_AT_data_member_location') or
                (attr.name in ('DW_AT_upper_bound', 'DW_AT_count'))) and
            attr.form in ('DW_FORM_data1', 'DW_FORM_data2', 'DW_FORM_data4', 'DW_FORM_data8', 'DW_FORM_sdata', 'DW_FORM_udata', 'DW_FORM_implicit_const'))
    
    def _attribute_has_loc_list(cls, attr, dwarf_version):
        return (((dwarf_version < 4 and
                 attr.form in ('DW_FORM_data1', 'DW_FORM_data2', 'DW_FORM_data4', 'DW_FORM_data8') and
                 not attr.name == 'DW_AT_const_value') or
                attr.form in ('DW_FORM_sec_offset', 'DW_FORM_loclistx')) and
                not _attribute_is_constant(attr, dwarf_version))
    
    def _attribute_is_loclistptr_class(cls, attr):
        return (attr.name in ( 'DW_AT_location', 'DW_AT_string_length',
                               'DW_AT_const_value', 'DW_AT_return_addr',
                               'DW_AT_data_member_location',
                               'DW_AT_frame_base', 'DW_AT_segment',
                               'DW_AT_static_link', 'DW_AT_use_location',
                               'DW_AT_vtable_elem_location',
                               'DW_AT_call_value',
                               'DW_AT_GNU_call_site_value',
                               'DW_AT_GNU_call_site_target',
                               'DW_AT_GNU_call_site_data_value',
                               'DW_AT_call_target',
                               'DW_AT_call_target_clobbered',
                               'DW_AT_call_data_location',
                               'DW_AT_call_data_value',
                               'DW_AT_upper_bound',
                               'DW_AT_count'))
    elftools.dwarf.locationlists.LocationParser._attribute_has_loc_list = MethodType(_attribute_has_loc_list, elftools.dwarf.locationlists.LocationParser)
    elftools.dwarf.locationlists.LocationParser._attribute_is_loclistptr_class = MethodType(_attribute_is_loclistptr_class, elftools.dwarf.locationlists.LocationParser)
    elftools.dwarf.locationlists.LocationParser._attribute_is_loclistptr_class = MethodType(_attribute_is_loclistptr_class, elftools.dwarf.locationlists.LocationParser)

    # Raw location lists
    def get_location_list_at_offset_ex(self, offset):
        self.stream.seek(offset, os.SEEK_SET)
        return [entry
            for entry
            in struct_parse(self.structs.Dwarf_loclists_entries, self.stream)]
    
    elftools.dwarf.locationlists.LocationLists.get_location_lists_at_offset_ex = get_location_list_at_offset_ex
    # Same for the pair object
    elftools.dwarf.locationlists.LocationListsPair.get_location_lists_at_offset_ex = lambda self, offset: self._loclists.get_location_lists_at_offset_ex(offset)

    # Rangelist entry translate with mixed V4/V5
    def translate_v5_entry(self, entry, cu):
        return self._rnglists.translate_v5_entry(entry, cu)
    elftools.dwarf.ranges.RangeListsPair.translate_v5_entry = translate_v5_entry

    # DWARF5 calling convention codes
    _DESCR_DW_CC[4] = '(pass by ref)'
    _DESCR_DW_CC[5] = '(pass by value)'

    # Monkeypatch for bogus XC16 binaries (see pyelftools' #518)
    def _read_dwarf_section(self, section, relocate_dwarf_sections):
        # Patch for the XC16 compiler; see pyelftools' #518
        # Vendor flag EF_PIC30_NO_PHANTOM_BYTE: clear means drop every odd byte
        has_phantom_bytes = self['e_machine'] == 'EM_DSPIC30F' and (self['e_flags'] & 0x80000000) == 0

        # The section data is read into a new stream, for processing
        section_stream = BytesIO()
        section_data = section.data()
        section_stream.write(section_data[::2] if has_phantom_bytes else section_data)

        if relocate_dwarf_sections:
            reloc_handler = RelocationHandler(self)
            reloc_section = reloc_handler.find_relocations_for_section(section)
            if reloc_section is not None:
                if has_phantom_bytes:
                    # No guidance how should the relocation work - before or after the odd byte skip
                    raise DWARFError("This binary has relocations in the DWARF sections, currently not supported. Let the author of DWARF Explorer know.")
                else:
                    reloc_handler.apply_section_relocations(
                        section_stream, reloc_section)

        return DebugSectionDescriptor(
                stream=section_stream,
                name=section.name,
                global_offset=section['sh_offset'],
                size=section.data_size//2 if has_phantom_bytes else section.data_size,
                address=section['sh_addr'])
    
    elftools.elf.elffile.ELFFile._read_dwarf_section = _read_dwarf_section

    # Fix for #1572, also for eliben/pyelftools#519
    def location_lists(self):
        """ Get a LocationLists object representing the .debug_loc/debug_loclists section of
            the DWARF data, or None if this section doesn't exist.
            If both sections exist, it returns a LocationListsPair.
        """
        if self.debug_loclists_sec and self.debug_loc_sec is None:
            return LocationLists(self.debug_loclists_sec.stream, self.structs, 5, self)
        elif self.debug_loc_sec and self.debug_loclists_sec is None:
            return LocationLists(self.debug_loc_sec.stream, self.structs, 4, self)
        elif self.debug_loc_sec and self.debug_loclists_sec:
            return LocationListsPair(self.debug_loc_sec.stream, self.debug_loclists_sec.stream, self.structs, self)
        else:
            return None
        
    elftools.dwarf.dwarfinfo.DWARFInfo.location_lists = location_lists


```

`dwex/ranges.py`:

```py
from .die import GenericTableModel
from elftools.dwarf.ranges import BaseAddressEntry as RangeBaseAddressEntry, RangeEntry
from .dwarfutil import get_cu_base, NoBaseError
from .details import GenericTableModel

def one_of(o, attrs):
    return next(((i, o[attr]) for (i,attr) in enumerate(attrs) if attr in o), (None, None))

def lowlevel_v5_tooltips(entry, col):
    type = entry.entry_type[7:]
    if col == 0: # Start
        if type == 'base_address':
            return 'Base address for entries below'
        elif type == 'offset_pair':
            return 'Starting offset relative to the current base'
        elif type == 'start_end' or type == 'start_length':
            return 'Starting address, absolute'
        elif type == 'base_addressx':
            return 'Index into the address table, resolving to absolute address'
        elif type == 'startx_endx' or type == 'startx_length':
            return 'Index into the address table, resolving to absolute address'
    elif col == 1: # End
        if type == 'offset_pair':
            return 'Ending offset relative to the current base'
        elif type == 'start_end':
            return 'Ending address, absolute'
        elif type == 'start_length' or type == 'startx_length':
            return 'Length of the range'
        elif type == 'startx_endx':
            return 'Index into the address table, resolving to absolute address'

# This is a method of DIETableModel
def show_ranges(self, attr):
    di = self.die.dwarfinfo
    if not di._ranges:
        di._ranges = di.range_lists()
    if not di._ranges: # Absent in the DWARF file
        return None
    v5 = self.die.cu['version'] >= 5
    ll = self.lowlevel

    if v5 and ll: # Dump untranslated v5 entries
        ranges = di._ranges.get_range_list_at_offset_ex(attr.value)
        has_relative_entries = next((r for r in ranges if r.entry_type == 'DW_RLE_offset_pair'), False)
    else:
        ranges = di._ranges.get_range_list_at_offset(attr.value, cu = self.die.cu)
        has_relative_entries = next((r for r in ranges if isinstance(r, RangeEntry) and not r.is_absolute), False)

    warn = None
    lines = []
    if len(ranges):
        cu_base = 0
        # Do we need the base address? We might not.
        if has_relative_entries and not isinstance(ranges[0], RangeBaseAddressEntry):
            try:
                cu_base = get_cu_base(self.die)
            except NoBaseError:
                warn = "Base address not found, assuming 0"

        for r in ranges:
            if v5 and ll: # Dump untranslated v5 entries
                # see _create_rnglists_parsers in elftools/dwarf/structs to see what can be in there
                (start_type, start) = one_of(r, ('index', 'start_index', 'start_offset', 'address', 'start_address'))
                (end_type, end) = one_of(r, ('end_index', 'length', 'end_offset', 'end_address'))
                translated = di._ranges.translate_v5_entry(r, self.die.cu)
                base = 0 if isinstance(translated, RangeEntry) and translated.is_absolute else cu_base
                lines.append((hex(r.entry_offset),
                    r.entry_type if self.prefix else r.entry_type[7:],
                    str(start) if start_type <= 1 else hex(start),
                    (str(end) if end_type == 0 or (end_type == 1 and not self.hex) else hex(end)) if end is not None else '',
                    hex(base + translated.begin_offset if isinstance(translated, RangeEntry) else translated.base_address), 
                    hex(base + translated.end_offset) if isinstance(translated, RangeEntry) else ''
                    ))
                if isinstance(translated, RangeBaseAddressEntry):
                    cu_base = translated.base_address
            else: # V4 or highlevel V5
                if isinstance(r, RangeEntry):
                    base = 0 if r.is_absolute else cu_base
                    if ll: # V4, low level
                        lines.append((hex(r.entry_offset),
                            "Range",
                            hex(r.begin_offset),
                            hex(r.end_offset),
                            hex(base + r.begin_offset),
                            hex(base + r.end_offset),
                            ))
                    else: # V4 high level or translated V5
                        lines.append((hex(base + r.begin_offset),
                                      hex(base + r.end_offset)))
                else: # Base entry
                    if ll:
                        lines.append((hex(r.entry_offset), "Base", hex(r.base_address), '', '', ''))
                    cu_base = r.base_address
    else:
        warn = "Empty range list"

    if v5 and ll:
        headers = ("Entry offset", "Type", "Start/Index/Base", "End/Index/Length", "Start address", "End address")
    elif ll: #Low level and V4
        headers = ("Entry offset", "Type", "Start offset/Base", "End offset", "Start address", "End address")
    else: 
        headers = ("Start address", "End address")
        
    return GenericTableModel(headers, lines, warn,
        get_tooltip=lambda row, col: lowlevel_v5_tooltips(ranges[row], col-2) if v5 and ll else None)

```

`dwex/scriptdlg.py`:

```py
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import *
from elftools.dwarf.locationlists import LocationParser

class ScriptDlg(QDialog):
    def __init__(self, win, sample_die):
        from sys import version_info
        QDialog.__init__(self, win, Qt.WindowType.Dialog)
        self.sample_die = sample_die
        ly = QVBoxLayout()
        ly.addWidget(QLabel("Provide a Python %d.%d expression for the \"die\" object:" % (version_info.major, version_info.minor), self))
        self.text = QPlainTextEdit(self)
        ly.addWidget(self.text)
        l = QLabel("<a href=\"https://github.com/sevaa/dwex/wiki/About-expressions\">See the guide</a>", self)
        l.linkActivated.connect(self.on_see_guide)
        ly.addWidget(l)
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok|QDialogButtonBox.StandardButton.Cancel, Qt.Orientation.Horizontal, self)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        ly.addWidget(buttons)
        self.setWindowTitle('Condition')
        self.setLayout(ly)

    def on_see_guide(self, link):
        try:
            import webbrowser
            webbrowser.open(link, new=0, autoraise=True)
        except:
            pass

    def accept(self):
        self.py = self.text.document().toPlainText()
        if not self.py:
            QMessageBox(QMessageBox.Icon.Warning, "Error",
                "Please provide a Python expression that inspects the \"die\" object.", QMessageBox.StandardButton.Ok, self).show()
        else:
            try:
                self.cond = compile(self.py, 'inline', 'eval')
            except Exception as exc:
                QMessageBox(QMessageBox.Icon.Warning, "Python error",
                    "Python syntax error: " + format(exc), QMessageBox.StandardButton.Ok, self).show()
                return
            
            try:
                env = make_execution_environment(self.sample_die)
            except Exception: #Our error - do not surface
                QDialog.accept(self)
                return

            try:
                eval(self.cond, env)
            except Exception as exc:
                mb = QMessageBox(QMessageBox.Icon.Question, "Python error",
                    "Python execution error (%s) on a sample DIE. Use anyway?\n\n%s" % (type(exc).__name__, format(exc)),
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No, self)
                mb.setEscapeButton(QMessageBox.StandardButton.No)
                if mb.exec() == QMessageBox.StandardButton.No:
                    return
            
            QDialog.accept(self)

def make_execution_environment(die):
    def has_attribute(func):
        for k in die.attributes:
            if func(k, die.attributes[k].value, die.attributes[k].form):
                return True
            
    def has_loclist():
        ver = die.cu.header.version
        def attr_is_loclist(attr):
            return (LocationParser._attribute_is_loclistptr_class(attr) and
                LocationParser._attribute_has_loc_list(attr, ver))
        g = (a for a in die.attributes if attr_is_loclist(die.attributes[a]))
        return bool(next(g, False))
            
    d = {'die' : die,
            'tag': 'user_%X' % (die.tag,) if isinstance(die.tag, int) else die.tag[7:],
            'attr': die.attributes,
            'has_attribute' : has_attribute,
            'has_loclist' : has_loclist}
    for k, a in die.attributes.items():
        d['user_%X' % (k,) if isinstance(k, int) else k[6:]] = a.value
    return d
            


    
        

```

`dwex/tree.py`:

```py
from bisect import bisect_left, bisect_right
from PyQt6.QtCore import Qt, QAbstractItemModel, QModelIndex
from PyQt6.QtGui import QFont, QFontInfo, QBrush
from PyQt6.QtWidgets import QApplication, QMessageBox
from .dwarfutil import has_code_location, safe_DIE_name

# Supports both / and \ - current system separator might not match the system the file came from
# so os.path.basename won't do
def strip_path(filename):
    p = filename.rfind("/")
    pbsl = filename.rfind("\\")
    if pbsl >= 0 and (p < 0 or pbsl > p):
        p = pbsl
    return filename[p+1:] if p >= 0 else filename

def top_die_file_name(die):
    if 'DW_AT_name' in die.attributes:
        source_name = die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')
        return strip_path(source_name)
    elif 'DW_AT_decl_file' in die.attributes:
        val = die.attributes['DW_AT_decl_file'].value
        if val > 0:
            if die.cu._lineprogram is None:
                die.cu._lineprogram = die.dwarfinfo.line_program_for_CU(die.cu)
            return strip_path(die.cu._lineprogram.header.file_entry[val-1].name.decode('utf-8', errors='ignore'))
    return "(no name)"

def cu_sort_key(cu):
    return top_die_file_name(cu.get_top_DIE()).lower()

def die_sort_key(die):
    name = safe_DIE_name(die)
    tag = '%X' % die.tag if isinstance(die.tag, int) else die.tag
    return (tag, name, die.offset)

#------------------------------------------------
# CU tree formatter
#------------------------------------------------    

# Some additional data for every DIE
def decorate_die(die, i):
    die._i = i
    die._children = None
    return die

def load_children(parent_die, sort):
    # Load and cache child DIEs in the parent DIE, if necessary
    # Assumes the check if the DIE has children has been already performed
    if not hasattr(parent_die, "_children") or parent_die._children is None:
        # TODO: wait cursor here.
        try:
            parent_die._children = [decorate_die(die, i) for (i, die) in enumerate(parent_die.iter_children())]
            if sort:
                parent_die._children.sort(key = die_sort_key)
                for (i, die) in enumerate(parent_die._children):
                    die._i = i
        except KeyError as ke:
            # Catching #1516
            QMessageBox(QMessageBox.Icon.Warning, "DWARF Explorer",
                "This executable file is corrupt or incompatible with the current version of DWARF Explorer. Please consider creating a new issue at https://github.com/sevaa/dwex/, and share this file with the tech support.",
                QMessageBox.StandardButton.Ok, QApplication.instance().win).show()
            parent_die._children = []

class DWARFTreeModel(QAbstractItemModel):
    def __init__(self, di, prefix, sortcus, sortdies):
        QAbstractItemModel.__init__(self)
        self.prefix = prefix
        self.top_dies = [decorate_die(CU.get_top_DIE(), i) for (i, CU) in enumerate(di._CUs)]
        self.highlight_condition = None
        fi = QFontInfo(QApplication.font())
        self.bold_font = QFont(fi.family(), fi.pointSize(), QFont.Weight.Bold)
        self.blue_brush = QBrush(Qt.GlobalColor.blue)
        self.sortcus = sortcus
        self.sortdies = sortdies

    # Qt callbacks. QTreeView supports progressive loading, as long as you feed it the "item has children" bit in advance

    def index(self, row, col, parent):
        if parent.isValid():
            parent_die = parent.internalPointer()
            # print("child of %s" % parent_die.tag)
            load_children(parent_die, self.sortdies)
            return self.createIndex(row, col, parent_die._children[row])
        else:
            return self.createIndex(row, col, self.top_dies[row])
        return QModelIndex()

    def flags(self, index):
        f = Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled
        if index.isValid() and not index.internalPointer().has_children:
            f = f | Qt.ItemFlag.ItemNeverHasChildren
        return f

    def hasChildren(self, index):
        return not index.isValid() or index.internalPointer().has_children

    def rowCount(self, parent):
        if parent.isValid():
            parent_die = parent.internalPointer()
            # print('rcount of %s' % parent_die.tag)
            if not parent_die.has_children: # Legitimately nothing
                return 0
            else:
                load_children(parent_die, self.sortdies)
                return len(parent_die._children)
        else:
            return len(self.top_dies)

    def columnCount(self, parent):
        return 1

    def parent(self, index):
        if index.isValid():
            parent = index.internalPointer().get_parent()
            if parent:
                return self.createIndex(parent._i, 0, parent)
        return QModelIndex()

    def data(self, index, role):
        die = index.internalPointer()
        if role == Qt.ItemDataRole.DisplayRole:
            if die.tag == 'DW_TAG_compile_unit' or die.tag == 'DW_TAG_partial_unit': # CU/top die: return file name
                return top_die_file_name(die)
            else: # Return tag, with name if possible
                if isinstance(die.tag, int): # Happens with user tags, #1472
                    s = ('DW_TAG_user_%X' if self.prefix else 'user_%X') % die.tag
                else:
                    s = die.tag if self.prefix or not str(die.tag).startswith('DW_TAG_') else die.tag[7:]
                if 'DW_AT_name' in die.attributes:
                    s += ": " + die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')
                return s
        elif role == Qt.ItemDataRole.ToolTipRole:
            if die.tag == 'DW_TAG_compile_unit' or die.tag == 'DW_TAG_partial_unit':
                return safe_DIE_name(die, None)
        elif role == Qt.ItemDataRole.ForegroundRole and self.is_highlighted(die):
            return self.blue_brush
        elif role == Qt.ItemDataRole.FontRole and self.is_highlighted(die):
            return self.bold_font

    # The rest is not Qt callbacks

    def is_highlighted(self, die):
        if not self.highlight_condition:
            return False
        return next((True for v in self.highlight_condition.values() if v(die)), False)

    def add_highlight(self, key, condition):
        if not self.highlight_condition:
            self.highlight_condition = {key:condition}
        else:
            self.highlight_condition[key] = condition
        self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def remove_highlight(self, key):
        del self.highlight_condition[key]
        self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def clear_highlight(self):
        self.highlight_condition = None
        self.dataChanged.emit(self.createIndex(0, 0, self.top_dies[0]), self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]), (Qt.ItemDataRole.ForegroundRole, Qt.ItemDataRole.FontRole))

    def has_highlight(self, key):
        return bool(self.highlight_condition and key in self.highlight_condition)
    
    def has_any_highlights(self):
        return bool(self.highlight_condition and len(self.highlight_condition))

    def set_prefix(self, prefix):
        if prefix != self.prefix:
            self.prefix = prefix
            self.dataChanged.emit(
                self.createIndex(0, 0, self.top_dies[0]),
                self.createIndex(len(self.top_dies)-1, 0, self.top_dies[-1]))    

    # returns the model index of the selection, or None
    def set_sortcus(self, sortcus, sel):
        if sortcus != self.sortcus:
            sel_die = sel.internalPointer() if sel.isValid() else None
            self.beginResetModel()
            self.sortcus = sortcus
            #Resort the CUs, reload the top_dies
            di = self.top_dies[0].dwarfinfo
            sort_key = cu_sort_key if self.sortcus else lambda cu: cu.cu_offset
            di._CUs.sort(key = sort_key)
            for (i, cu) in enumerate(di._CUs):
                cu._i = i
                self.top_dies[i] = cu.get_top_DIE() # Already decorated, but the index is off
                self.top_dies[i]._i = i
            # Reload
            self.endResetModel()
            if sel_die:
                if sel_die.get_parent(): # Not a top level
                    return sel
                else:
                    return self.createIndex(0, sel_die._i, sel_die)

    # Returns the index of the new selection, if any
    def set_sortdies(self, sortdies):
        if sortdies != self.sortdies:
            self.sortdies = sortdies
            self.beginResetModel()
            for (i, die) in enumerate(self.top_dies):
                # Fragile! We invalidate the children in the decorated DIEs in the CU DIE cache
                # To force reloading and sorting
                for top_die in self.top_dies:
                    for die in top_die.cu._dielist:
                        die._children = None
            self.endResetModel()
            return self.createIndex(0, 0, self.top_dies[0])

    # Identifier for the current tree node that you can navigate to
    # For the back-forward logic
    # Specifically, (cu, offset within the info section)
    def get_navitem(self, index):
        die = index.internalPointer()
        return (die.cu, die.offset) if die else None # Issue # 1473, weird.

    # navitem is (CU, offset within the info section)
    # returns an index within the tree
    def index_for_navitem(self, navitem):
        target_cu, target_offset = navitem
        # Random access is a tricky proposition in the current version. Parse the whole CU.
        for _ in target_cu.iter_DIEs():
            pass

        # Abusing the structure of the per-CU DIE cache of pyelftools, it's the same in DWWARFv1
        i = bisect_left(target_cu._diemap, target_offset)
        if i >= len(target_cu._diemap) or target_cu._diemap[i] != target_offset:
            return None
        target_die = target_cu._dielist[i]
        if target_die.is_null():
            return None
        return self.index_for_die(target_die)

    # Takes a die that might not have an _i
    # Restores the _i
    # Assumes some parent DIEs of the current one are already parsed
    # and cached in the CU, so get_parent will always return a valid parent DIE
    def index_for_die(self, die):
        if hasattr(die, '_i'): # DIE already iterated over
            return self.createIndex(die._i, 0, die)
        else: # Found the DIE, but the tree was never opened this deep. Read the tree along the path to the target DIE
            index = False
            while not hasattr(die, '_i'):
                parent_die = die.get_parent()
                load_children(parent_die, self.sortdies) # This will populate the _i in all children of parent_die, including die
                if not index: # After the first iteration, the one in the direct parent of target_die, target_die will have _i
                    if die.is_null():
                        die = parent_die._children[-1] # Null is a terminator in a sequence - move to the sibling
                        # TODO: move to the closest in terms of offset, which would require going down the nearest sibling's tree
                    index = self.createIndex(die._i, 0, die)
                die = parent_die
            return index

    # Returns the index of the found item, or False
    # start_pos is the index of the current item, or an invalid one
    # cond is a condition function
    # cu_cond is the same for CUs - hook for find by IP
    def find(self, start_pos, cond, cu_cond = False):
        have_start_pos = start_pos.isValid()
        if have_start_pos: # Searching from a specific position, with wrap-around
            start_die = start_pos.internalPointer()
            start_die_offset = start_die.offset # In the current die, before the next one
            start_cu = start_die.cu
            start_cu_offset = start_cu.cu_offset
            cu = start_cu
            wrapped = False
        else:
            cu = self.top_dies[0].cu

        while True:
            cu_offset = cu.cu_offset
            # Parse all DIEs in the current CU
            if cu_cond(cu) if cu_cond else True:
                for die in cu.iter_DIEs():
                    # Quit condition with search from position - quit once we go past the starting position after the wrap
                    if have_start_pos and cu_offset >= start_cu_offset and die.offset > start_die_offset and wrapped:
                        break
                    if not die.is_null() and (not have_start_pos or cu_offset != start_cu_offset or (not wrapped and die.offset > start_die_offset)) and cond(die):
                        return self.index_for_die(die)

            # We're at the end of the CU. What next?
            if cu._i < len(self.top_dies) - 1: # More CUs to scan
                cu = self.top_dies[cu._i + 1].cu
            elif have_start_pos and not wrapped: # Scanned the last CU, wrap around
                cu = self.top_dies[0].cu
                wrapped = True
            else:
                break

        return False

    # Search back - same idea
    def find_back(self, start_pos, cond, cu_cond = False):
        have_start_pos = start_pos.isValid()
        if have_start_pos: # Searching from a specific position, with wrap-around
            start_die = start_pos.internalPointer()
            start_die_offset = start_die.offset # In the current die, before the next one
            start_cu = start_die.cu
            start_cu_offset = start_cu.cu_offset
            cu = start_cu
            wrapped = False
        else:
            cu = self.top_dies[-1].cu

        while True:
            cu_offset = cu.cu_offset
            # Parse all DIEs in the current CU
            if cu_cond(cu) if cu_cond else True:
                for die in cu.iter_DIEs(): # Fill the DIE cache
                    pass

                # Abusing the internal cache of pyelftools - fragile!

                if have_start_pos and not wrapped and cu_offset == start_cu_offset:
                    i = bisect_left(cu._diemap, start_die_offset-1)-1
                else:
                    i = len(cu._diemap) - 1

                while i >= 0:
                    die = cu._dielist[i]
                    if not die.is_null():
                        # Quit condition with search from position - quit once we go past the starting position after the wrap
                        if have_start_pos and die.offset == start_die_offset and wrapped:
                            return False
                        if cond(die):
                            return self.index_for_die(die)
                    i -= 1

            # We're at the end of the CU. What next?
            if cu._i > 0: # More CUs to scan
                cu = self.top_dies[cu._i - 1].cu
            elif have_start_pos and not wrapped: # Scanned the last CU, wrap around
                cu = self.top_dies[-1].cu
                wrapped = True
            else:
                break

        return False            

    
    def find_offset(self, offset):
        cu = next((td.cu
            for td
            in self.top_dies
            if 0 <= offset-td.cu.cu_die_offset < td.cu.header.unit_length), False)
        if not cu:
            return None
        # On an off chance it's already parsed and the offset is precise
        i = bisect_right(cu._diemap, offset)
        if offset == cu._diemap[i - 1]:
            return self.index_for_die(cu._dielist[i - 1])
        # Now the hard way
        # It would be possible to optimize that, parse not all DIEs but just some
        # But let's not.
        for die in cu.iter_DIEs():
            pass
        i = bisect_right(cu._diemap, offset)
        return self.index_for_die(cu._dielist[i - 1])


```

`dwex/ui.py`:

```py
from PyQt6.QtCore import Qt, QRectF, QSizeF, QPointF, QByteArray
from PyQt6.QtGui import QKeySequence, QAction, QImage, QPixmap, QPainter, QIcon
from PyQt6.QtWidgets import *
from PyQt6.QtSvg import QSvgRenderer

def setup_menu(win):
    menu = win.menuBar()
    file_menu = menu.addMenu("&File")
    open_menuitem = file_menu.addAction("Open...")
    open_menuitem.setShortcut(QKeySequence.StandardKey.Open)
    open_menuitem.triggered.connect(win.on_open)
    win.savesection_menuitem = file_menu.addAction("Save a section as...")
    win.savesection_menuitem.triggered.connect(win.on_savesection)
    win.savesection_menuitem.setEnabled(False)
    win.mru_menu = file_menu.addMenu("Recent files")
    if len(win.mru):
        win.populate_mru_menu()
    else:
        win.mru_menu.setEnabled(False)
    exit_menuitem = file_menu.addAction("E&xit")
    exit_menuitem.setMenuRole(QAction.MenuRole.QuitRole)
    exit_menuitem.setShortcut(QKeySequence.StandardKey.Quit)
    exit_menuitem.triggered.connect(win.on_exit)
    #########
    view_menu = menu.addMenu("View")
    win.prefix_menuitem = view_menu.addAction("DWARF prefix")
    win.prefix_menuitem.setCheckable(True)
    win.prefix_menuitem.setChecked(win.prefix)
    win.prefix_menuitem.triggered.connect(win.on_view_prefix)
    win.lowlevel_menuitem = view_menu.addAction("Low level")
    win.lowlevel_menuitem.setCheckable(True)
    win.lowlevel_menuitem.setChecked(win.lowlevel)
    win.lowlevel_menuitem.triggered.connect(win.on_view_lowlevel)
    win.hex_menuitem = view_menu.addAction("Hexadecimal")
    win.hex_menuitem.setCheckable(True)
    win.hex_menuitem.setChecked(win.hex)
    win.hex_menuitem.triggered.connect(win.on_view_hex)
    win.regnames_menuitem = view_menu.addAction("DWARF register names")
    win.regnames_menuitem.setCheckable(True)
    win.regnames_menuitem.setChecked(win.dwarfregnames)
    win.regnames_menuitem.triggered.connect(win.on_view_regnames)
    view_menu.addSeparator()
    win.sortcus_menuitem = view_menu.addAction("Sort CUs")
    win.sortcus_menuitem.setCheckable(True)
    win.sortcus_menuitem.setChecked(win.sortcus)
    win.sortcus_menuitem.triggered.connect(win.on_sortcus)
    win.sortdies_menuitem = view_menu.addAction("Sort DIEs")
    win.sortdies_menuitem.setCheckable(True)
    win.sortdies_menuitem.setChecked(win.sortdies)
    win.sortdies_menuitem.triggered.connect(win.on_sortdies)
    view_menu.addSeparator()
    win.highlightcode_menuitem = view_menu.addAction("Highlight code")
    win.highlightcode_menuitem.setCheckable(True)
    win.highlightcode_menuitem.setEnabled(False)
    win.highlightcode_menuitem.triggered.connect(win.on_highlight_code)
    win.highlightsubstring_menuitem = view_menu.addAction("Highlight by substring...")
    win.highlightsubstring_menuitem.setCheckable(True)
    win.highlightsubstring_menuitem.setEnabled(False)
    win.highlightsubstring_menuitem.triggered.connect(win.on_highlight_substring)
    win.highlightcondition_menuitem = view_menu.addAction("Highlight by condition...")
    win.highlightcondition_menuitem.setCheckable(True)
    win.highlightcondition_menuitem.setEnabled(False)
    win.highlightcondition_menuitem.triggered.connect(win.on_highlight_condition)
    win.highlightnothing_menuitem = view_menu.addAction("Remove highlighting")
    win.highlightnothing_menuitem.setEnabled(False)
    win.highlightnothing_menuitem.triggered.connect(win.on_highlight_nothing)
    view_menu.addSeparator()
    win.cuproperties_menuitem = view_menu.addAction("CU properties...")
    win.cuproperties_menuitem.setEnabled(False)
    win.cuproperties_menuitem.triggered.connect(win.on_cuproperties)
    #########
    edit_menu = menu.addMenu("Edit")
    win.copy_menuitem = edit_menu.addAction("Copy value")
    win.copy_menuitem.setShortcut(QKeySequence.StandardKey.Copy)
    win.copy_menuitem.setEnabled(False)
    win.copy_menuitem.triggered.connect(win.on_copyvalue)
    win.copyline_menuitem = edit_menu.addAction("Copy line")
    win.copyline_menuitem.setEnabled(False)
    win.copyline_menuitem.triggered.connect(win.on_copyline)        
    win.copytable_menuitem = edit_menu.addAction("Copy table")
    win.copytable_menuitem.setEnabled(False)
    win.copytable_menuitem.triggered.connect(win.on_copytable)  
    #########
    nav_menu = menu.addMenu("Navigate")
    win.back_menuitem = nav_menu.addAction("Back")
    win.back_menuitem.setShortcut(QKeySequence.StandardKey.Back)
    win.back_menuitem.setEnabled(False);
    win.back_menuitem.triggered.connect(lambda: win.on_nav(1))
    win.forward_menuitem = nav_menu.addAction("Forward")
    win.forward_menuitem.setShortcut(QKeySequence.StandardKey.Forward)
    win.forward_menuitem.setEnabled(False);
    win.forward_menuitem.triggered.connect(lambda: win.on_nav(-1))
    win.followref_menuitem = nav_menu.addAction("Follow the ref")
    win.followref_menuitem.setEnabled(False);
    win.followref_menuitem.setShortcut(QKeySequence(Qt.Modifier.CTRL | Qt.Key.Key_Return))
    win.followref_menuitem.triggered.connect(win.on_followref)
    nav_menu.addSeparator()
    win.nexthl_menuitem = nav_menu.addAction("To next highlight")
    win.nexthl_menuitem.setEnabled(False)
    win.nexthl_menuitem.triggered.connect(win.on_nexthl)
    win.prevhl_menuitem = nav_menu.addAction("To previous highlight")
    win.prevhl_menuitem.setEnabled(False)
    win.prevhl_menuitem.triggered.connect(win.on_prevhl)
    nav_menu.addSeparator()
    win.byoffset_menuitem = nav_menu.addAction("DIE by offset...")
    win.byoffset_menuitem.setEnabled(False)
    win.byoffset_menuitem.triggered.connect(win.on_byoffset)
    win.find_menuitem = nav_menu.addAction("Find...")
    win.find_menuitem.setEnabled(False)
    win.find_menuitem.setShortcut(QKeySequence.StandardKey.Find)
    win.find_menuitem.triggered.connect(win.on_find)
    win.findip_menuitem = nav_menu.addAction("Find code address...")
    win.findip_menuitem.setEnabled(False)
    win.findip_menuitem.triggered.connect(win.on_findip)
    win.findbycondition_menuitem = nav_menu.addAction("Find by condition...")
    win.findbycondition_menuitem.setEnabled(False)
    win.findbycondition_menuitem.triggered.connect(win.on_findbycondition)
    win.findnext_menuitem = nav_menu.addAction("Find next")
    win.findnext_menuitem.setEnabled(False)
    win.findnext_menuitem.setShortcut(QKeySequence.StandardKey.FindNext)
    win.findnext_menuitem.triggered.connect(win.on_findnext)
    ########
    ana_menu = menu.addMenu("Analysis")
    win.localsat_menuitem = ana_menu.addAction("Locals at address...")
    win.localsat_menuitem.setEnabled(False)
    win.localsat_menuitem.triggered.connect(win.on_localsat)
    ########
    help_menu = menu.addMenu("Help")
    about_menuitem = help_menu.addAction("About...")
    about_menuitem.setMenuRole(QAction.MenuRole.AboutRole)
    about_menuitem.triggered.connect(win.on_about) 
    help_menu.addAction('Check for updates...').triggered.connect(win.on_updatecheck)
    help_menu.addAction('Report an issue').triggered.connect(win.on_issue)
    help_menu.addAction('Homepage').triggered.connect(win.on_homepage)

back_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M 40 20 L 10 50 L 40 80 M 10 50 h 60"/>'
fwd_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M 60 20 L 90 50 L 60 80 M 90 50 h -60"/>'
open_svg = b'<path fill="none" stroke="#000" stroke-width="5" d="M 10 20 v 60 h 80 v -45 h -35 l -15 -15 z"/>'
fwref_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" stroke-linecap="round" d="M20 5v90h40M20 65h40M20 35h15"/><path fill="none" stroke="#000" stroke-width="5" stroke-linecap="round" d="M70 95q30-30-20-60"/><path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="butt" stroke-linecap="round" d="M54 54l-5-20 20-2"/>'
copy_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" d="M15 25h45v60H15zm20 0V15h45v60H60"/>'
byoffset_svg = b'<path fill="none" stroke="#000" stroke-width="5" stroke-linejoin="round" d="M40 5v75h40M40 25h20M40 50h30M10 5v35H5l10 10 10-10h-5V5z"/>'
find_svg = b'<path stroke="#000" fill="#000" fill-rule="evenodd" d="M40 60a25 25 0 1112-8l16 25-12 7zM15 36a15 15 0 1135 0 15 15 0 11-35 0"/>'
nexthl_svg = b'<g stroke="#000" fill="none" stroke-width="5" stroke-linecap="round"><path stroke-linejoin="round" d="M5 20h75L65 5m15 15L65 35"/><path d="M5 60h17M13.787 38.787l12.02 12.02M35 30v17M56.213 38.787l-12.02 12.02M65 60H48M56.213 81.213l-12.02-12.02M35 90V73M13.787 81.213l12.02-12.02"/></g>'
prevhl_svg = b'<g stroke="#000" fill="none" stroke-width="5" stroke-linecap="round"><path stroke-linejoin="round" d="M95 20H20L35 5M20 20l15 15"/><path d="M78 60h17M74.192 69.192l12.021 12.021M65 73v17M55.808 69.192L43.787 81.213M52 60H35M55.808 50.808L43.787 38.787M65 47V30M74.192 50.808l12.021-12.021"/></g>'

def setup_toolbar(win):
    tb = win.addToolBar("Main")
   
    sz = tb.iconSize()
    rc = QRectF(QPointF(0, 0), QSizeF(sz.width(), sz.height()))

    def make_icon(svg_body):
        img = QImage(sz, QImage.Format.Format_ARGB32)
        img.fill(0)
        svg = b'<svg width="100" height="100">' + svg_body + b'</svg>'
        renderer = QSvgRenderer(QByteArray(svg))
        pixmap = QPixmap.fromImage(img, Qt.ImageConversionFlag.NoFormatConversion)
        with QPainter(pixmap) as painter:
            renderer.render(painter, rc)
        return QIcon(pixmap)
    
    tb.setFloatable(False)
    tb.setMovable(False)

    win.back_tbitem = tb.addAction("Back")
    win.back_tbitem.triggered.connect(lambda: win.on_nav(1))
    win.back_tbitem.setEnabled(False)
    win.back_tbitem.setIcon(make_icon(back_svg))
    win.back_tbitem.setToolTip("Navigate to the previous DIE")
    win.forward_tbitem = tb.addAction("Forward")
    win.forward_tbitem.triggered.connect(lambda: win.on_nav(-1))
    win.forward_tbitem.setEnabled(False)
    win.forward_tbitem.setIcon(make_icon(fwd_svg))
    win.forward_tbitem.setToolTip("Navigate to the DIE that you went back from")
    tb.addSeparator()

    ac = tb.addAction("Open")
    ac.triggered.connect(win.on_open)
    ac.setIcon(make_icon(open_svg))
    ac.setToolTip("Open a compiled executable, object, or library file to see its debug information")
    tb.addSeparator()

    win.copy_tbitem = tb.addAction("Copy")
    win.copy_tbitem.setIcon(make_icon(copy_svg))
    win.copy_tbitem.setEnabled(False)
    win.copy_tbitem.setToolTip("Copy the current attribute's value to the clipboard")
    win.copy_tbitem.triggered.connect(win.on_copyvalue)
    tb.addSeparator()
    win.followref_tbitem = tb.addAction("Follow")
    win.followref_tbitem.setEnabled(False)
    win.followref_tbitem.setIcon(make_icon(fwref_svg))
    win.followref_tbitem.triggered.connect(win.on_followref)
    win.followref_tbitem.setToolTip("Navigate to the DIE that the current attribute is referencing")
    win.byoffset_tbitem = tb.addAction("By offset")
    win.byoffset_tbitem.setEnabled(False)
    win.byoffset_tbitem.setIcon(make_icon(byoffset_svg))
    win.byoffset_tbitem.triggered.connect(win.on_byoffset)
    win.byoffset_tbitem.setToolTip("Navigate to the DIE by the hex offset of the DIE in the info section")
    win.find_tbitem = tb.addAction("Find")
    win.find_tbitem.setEnabled(False)
    win.find_tbitem.setIcon(make_icon(find_svg))
    win.find_tbitem.triggered.connect(win.on_find)
    win.find_tbitem.setToolTip("Find the next DIE in the tree by tag/attribute/value substring")
    win.nexthl_tbitem = tb.addAction("Next highlight")
    win.nexthl_tbitem.setEnabled(False)
    win.nexthl_tbitem.setIcon(make_icon(nexthl_svg))
    win.nexthl_tbitem.triggered.connect(win.on_nexthl)
    win.nexthl_tbitem.setToolTip("Navigate to the next highlighted DIE in the tree")
    win.prevhl_tbitem = tb.addAction("Previous highlight")
    win.prevhl_tbitem.setEnabled(False)
    win.prevhl_tbitem.setIcon(make_icon(prevhl_svg))
    win.prevhl_tbitem.triggered.connect(win.on_prevhl)
    win.prevhl_tbitem.setToolTip("Navigate to the previous highlighted DIE in the tree")


def setup_ui(win):
    setup_menu(win)
    setup_toolbar(win)
    # Set up the left pane and the right pane
    tree = win.the_tree = QTreeView()
    tree.header().hide()
    tree.setUniformRowHeights(True)
    
    rpane = QSplitter(Qt.Orientation.Vertical)
    die_table = win.die_table = QTableView()
    die_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
    die_table.doubleClicked.connect(win.on_attribute_dclick)
    rpane.addWidget(die_table)
    
    rbpane = QVBoxLayout()
    rbpane.setContentsMargins(0, 0, 0, 0)
    details_warning = win.details_warning = QLabel()
    details_warning.setVisible(False)
    rbpane.addWidget(details_warning)
    details_table = win.details_table = QTableView()
    details_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
    rbpane.addWidget(details_table)
    rbp = QWidget()
    rbp.setLayout(rbpane)
    rpane.addWidget(rbp)
    # All the resizing goes into the bottom pane
    rpane.setStretchFactor(0, 0)
    rpane.setStretchFactor(1, 1)

    spl = QSplitter()
    spl.addWidget(win.the_tree)
    spl.addWidget(rpane)
    # All the resizing goes into the right pane by default
    spl.setStretchFactor(0, 0)
    spl.setStretchFactor(1, 1) 
    win.setCentralWidget(spl)

    win.setWindowTitle("DWARF Explorer")
    win.resize(win.font_metrics.averageCharWidth() * 250, win.font_metrics.height() * 60)

```

`make.cmd`:

```cmd
@echo off
git diff-index --quiet HEAD --
if errorlevel 1 echo Uncommitted changes! & pause & goto EOF

git log --pretty=format:%%H -n 1 >hash.txt
set /p HASH= <hash.txt
del hash.txt

python -c "import dwex.__main__;print('.'.join(str(x) for x in dwex.__main__.version))" >ver.txt
set /p VER= <ver.txt
del ver.txt

echo %HASH% %VER% >>archive\history.txt

del /q dist\*.*
echo cookie='%HASH%' >dwex\cookie.py
python setup.py sdist
echo cookie=False >dwex\cookie.py
twine upload dist/*
if errorlevel 1 pause 
```

`msi/make.cmd`:

```cmd
@echo off

rem MSITOOLS is expected to be C:\Program Files (x86)\Windows Kits\10\bin\10.0.22000.0\x86
rem Thumbprint.txt is supposed to exist and contain the thumbprint of the signing cert
rem TODO: sign aside from the master copy of the file

cd ..
python -c "import dwex.__main__;print('.'.join(str(x) for x in dwex.__main__.version))" >ver.txt
set /p VER= <ver.txt
del ver.txt
echo Version %VER%
cd msi
powershell MSISetProp.ps1 -Path %CD%\DWEXMin.msi -Property ProductVersion -Value %VER%

set /p THU= <Thumbprint.txt
echo Signing cert %THU%
if x%THU% == x echo No signing cert thumbprint & pause & goto EOF
"%MSITOOLS%\signtool.exe" sign /fd SHA256 /sha1 %THU%  DWEXMin.msi

set D=ftp://ftp.yarxi.ru/public_html/yarxionline/temp/dwex/%VER%
powershell MakeFTPFolder -URL %D%

set D=%D%/
powershell UpFile -Src DWEXMin.msi -Dest %D%

:EOF

```

`refresh.cmd`:

```cmd
pip install --upgrade dwex
```

`setup.cfg`:

```cfg
[metadata]
description-file = README.md
```

`setup.py`:

```py
from setuptools import setup
from setuptools.command.install import install
import platform, sys, os, site
from os import path, environ

#------------------------------------
# Start menu item creation on Windows
#------------------------------------

def create_shortcut_under(root, exepath):
    profile = environ[root]
    linkpath = path.join(profile, "Microsoft", "Windows", "Start Menu", "Programs", "DWARF Explorer.lnk")
    try:
        from win32com.client import Dispatch
        from pywintypes import com_error
        try:
            sh = Dispatch('WScript.Shell')
            link = sh.CreateShortcut(linkpath)
            link.TargetPath = exepath
            link.Save()
            return True
        except com_error:
            return False
    except ImportError:
        import subprocess
        s = "$s=(New-Object -COM WScript.Shell).CreateShortcut('" + linkpath + "');$s.TargetPath='" + exepath + "';$s.Save()"
        return subprocess.call(['powershell', s], stdout = subprocess.DEVNULL, stderr = subprocess.DEVNULL) == 0

def create_shortcut(inst):
    try:
        exepath = path.join(path.dirname(sys.executable), "Scripts", "dwex.exe")
        if not path.exists(exepath):
            exepath = path.join(path.dirname(site.getusersitepackages()), "Scripts", "dwex.exe")

        if not create_shortcut_under('ALLUSERSPROFILE', exepath):
            create_shortcut_under('APPDATA', exepath)
    except:
        pass

#--------------------------------------    

def register_desktop_app():
    try:
        import base64, subprocess
        with open('/usr/share/applications/dwex.desktop', 'w') as f:
            f.write("[Desktop Entry]\nVersion=1.1\nType=Application\nName=DWARF Explorer\nComment=Debug information visualizer\nExec=dwex\nTerminal=false\nIcon=dwex\nCategories=Development;Debugger;\n")
        with open('/usr/share/icons/hicolor/48x48/apps/dwex.png', 'wb') as f:
            f.write(base64.b64decode("iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAAKnRFWHRDcmVhdGlvbiBUaW1lANHhIDYg7e7/IDIwMjEgMTM6MDg6NDcgLTA1MDBuo0qzAAAAB3RJTUUH5QsGEQ8VL0d/PwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURf///wAAAFXC034AAACkSURBVHjavdNREoUgCAXQyw5g/5sNxEoEpvc+yim0OcUoJvBRE2sAaeQRAkgB0NdBbJcPfgMNbglI8w9AAu1tDjXQv8DEUgH1gAwaDKQEu3kDWzBVIBNCReaG+Fc7oIAvGt1/g61cnsGnaM9nn0B89Rloq9UF4JDJd9VHsSILSIR7jiHTAm0qbiHNau7StlEXlCU5T0ALS65Zdh5lp+VwtvByOwCIiA5ALXz03AAAAABJRU5ErkJggg=="))
        subprocess.call('update-desktop-database')
    except:
        pass

#--------------------------------------

class my_install(install):
    def run(self):
        install.run(self)
        if platform.system() == 'Windows':
            create_shortcut(self)
        elif platform.system() == 'Linux':
            register_desktop_app()

# Pull the long desc from the readme
try:
    with open(path.join(path.abspath(path.dirname(__file__)), 'README.md')) as f:
        long_desc = f.read()          
except:
    long_desc = "GUI viewer for DWARF debug information"

setup(
    name='dwex',
    version='3.23',  # Sync with version in __main__
    packages=['dwex'],
    url="https://github.com/sevaa/dwex/",
    entry_points={"gui_scripts": ["dwex = dwex.__main__:main"]},
    cmdclass={'install': my_install},
    keywords = ['dwarf', 'debug', 'debugging', 'symbols', 'viewer', 'view', 'browser', 'browse', 'tree'],
    license="BSD",
    author="Seva Alekseyev",
    author_email="sevaa@sprynet.com",
    description="GUI viewer for DWARF debug information",
    long_description=long_desc,
    long_description_content_type="text/markdown",
    python_requires=">=3.6.1",
    setup_requires=[],
    install_requires=['PyQt6', 'filebytes>=0.10.1', 'pyelftools>=0.30'],
    platforms='any',
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: BSD License",
        "Operating System :: OS Independent",
        "Environment :: MacOS X :: Cocoa",
        "Environment :: Win32 (MS Windows)",
        "Environment :: X11 Applications :: Qt",
        "Programming Language :: Python",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: Implementation :: CPython",
        "Topic :: Software Development :: Debuggers"
    ]
)


```

`test/intest.py`:

```py
import sys, os
sys.path.insert(1, os.getcwd()) # To make sure dwex resolves to local path
import dwex.__main__

def main(debug_crash_reporting, filename, hook_file):
    # Do we need to hook exceptions all the same
    if debug_crash_reporting:
        dwex.__main__.on_exception.prev_exchook = sys.excepthook
        sys.excepthook = dwex.__main__.on_exception

    if len(sys.argv) == 1:
        sys.argv = ['dwex', filename]

    # Monkeypatch to mess with file contents
    old_open_file = dwex.__main__.TheWindow.open_file
    def open_file(self, filename, arch = None):
        r = old_open_file(self, filename, arch)
        hook_file(self.dwarfinfo)
        return r
    
    dwex.__main__.TheWindow.open_file = open_file
    dwex.__main__.main()
```

`test/testall.py`:

```py
import os, sys
from PyQt6.QtCore import Qt, QAbstractItemModel, QAbstractTableModel, QModelIndex
sys.path.insert(1, os.getcwd()) # To make sure dwex resolves to local path
from elftools.dwarf.locationlists import LocationParser, LocationExpr
from dwex.formats import read_dwarf
from dwex.die import DIETableModel
from dwex.tree import strip_path

def test_dwarfinfo(di):
    # Some global cache setup in line with the app proper
    di._ranges = None
    di._CUs = [cu for cu in di.iter_CUs()]
    di._locparser = None

    m = False
    dummy_index = QModelIndex()
    for (i, CU) in enumerate(di._CUs):
        top_die = CU.get_top_DIE()
        print("%s" % strip_path(top_die.attributes['DW_AT_name'].value.decode('utf-8', errors='ignore')) if 'DW_AT_name' in top_die.attributes else "(no name)")
        CU._lineprogram = None
        CU._exprparser = None
        for die in CU.iter_DIEs():
            if not die.is_null():
                assert die.tag.startswith('DW_TAG_')

                if not m:
                    # With prefix, with low level data, decimal
                    m = DIETableModel(die, True, True, False, True) 
                else:
                    m.display_DIE(die)

                rc = m.rowCount(dummy_index)
                cc = m.columnCount(dummy_index)
                keys = list(die.attributes.keys())
                # Assuming rows correspond to attributes; 
                # if we introduce non-attribute metadata into the DIE table, this will break
                for r in range(m.meta_count, rc):
                    key = keys[r - m.meta_count]
                    attr = die.attributes[key]
                    form = attr.form
                    value = attr.value
                    # Check the elftools' results first

                    # Check if the key is interpreted properly
                    assert str(key).startswith('DW_AT_')
                    assert str(form).startswith('DW_FORM_')

                    # Check if attributes with locations are all found
                    if form == 'DW_FORM_exprloc':
                        assert LocationParser.attribute_has_location(attr, CU['version'])
                    # The converse is not true; on DWARF2, location expressions can have form DW_FORM_block1

                    # Now check the spell out logic
                    for c in range(0, cc):
                        m.data(m.index(r, c, dummy_index), Qt.ItemDataRole.DisplayRole)
                    # Low level details, if any
                    details = m.get_attribute_details(m.index(r, 0, dummy_index))
                    if form == 'DW_FORM_section_offset':
                        assert details is not None
                    # Check the high level spell out logic too
                    m.set_lowlevel(False, dummy_index)
                    details = m.get_attribute_details(m.index(r, 0, dummy_index))
                    m.set_lowlevel(True, dummy_index)

def test_file_for(filename, on_di):    
    print("=================== " + filename)
    arches = False
    def save_arches(a):
        nonlocal arches
        arches = a
        return None # Cancel out of loading
    di = read_dwarf(filename, save_arches)
    if arches: # Fat binary - go through all through architectures
        for arch_no in range(0, len(arches)):
            print("----------- " + arches[arch_no])
            di = read_dwarf(filename, lambda arches:arch_no)
            if di:
                on_di(di)
    elif di:
        on_di(di)

def test_file(filename):
    test_file_for(filename, test_dwarfinfo)

def test_tree_for(path, on_di):
    for f in os.listdir(path):
        full_path = os.path.join(path, f)
        # See what can be done about JiPad ones
        if f.endswith('.dSYM') or f.endswith('.o') or f.endswith('.elf') or (f.endswith('.so') and not f.endswith('libJiPadLib.so')):
            test_file_for(full_path, on_di)
        elif os.path.isdir(full_path):
            test_tree_for(full_path, on_di)        

def test_tree(path):
    test_tree_for(path, test_dwarfinfo)




# Caught on GNU_call_site_value

# All sec_offsets must be parsed

# All expressions must be parsed - which forms are expressions?
```