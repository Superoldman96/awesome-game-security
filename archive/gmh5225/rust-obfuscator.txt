Project Path: arc_gmh5225_rust-obfuscator_w_fdnraa

Source Tree:

```txt
arc_gmh5225_rust-obfuscator_w_fdnraa
├── Cargo.toml
├── LICENSE
├── README.md
├── auto_obfuscate
│   ├── Cargo.toml
│   └── src
│       ├── flow
│       │   └── flow_tests.rs
│       ├── flow.rs
│       ├── main.rs
│       ├── obfuscate.rs
│       ├── rename
│       │   └── rename_tests.rs
│       ├── rename.rs
│       ├── string
│       │   └── string_tests.rs
│       └── string.rs
├── cryptify
│   ├── Cargo.toml
│   ├── README.md
│   ├── src
│   │   └── lib.rs
│   └── tests
│       └── macro_tests.rs
└── labyrinth_macros
    ├── @
    ├── Cargo.toml
    ├── README.md
    └── src
        └── lib.rs

```

`Cargo.toml`:

```toml
[workspace]
members = [
    "auto_obfuscate",
    "cryptify",
    "labyrinth_macros",
]
default-members = ["auto_obfuscate"]
resolver = "2"
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Pranav Dronavalli

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Rust-Obfuscator

`rust-obfuscator` is a set of tools designed to automatically obfuscate Rust source code by inserting procedural macros or by (optionally) providing the obfuscation in the source code directly. For more fine-grained obfuscation a procedural macro library [cryptify](https://crates.io/crates/cryptify) is also provided.

## Currently Supported
1. string literal encryption
2. control-flow obfuscation
3. control-flow obfuscation (source code)
4. variable renaming (source code)

## Features

- **String Encryption**: Automatically encrypts string literals assigned to local variables at compile time.
    - Can also be used for formatted strings, but currently requires manual placement
    ```rs
        println!("{}", cryptify::encrypt_string!("hello!"));
    ```
- **Control Flow Obfuscation**: Introduces compile-dummy dummy loops and random variables.
- **Customizable Obfuscation**: Offers flexibility to enable or disable specific obfuscation features based on your requirements.
- **Variable Renaming**: Obfuscation of the source code directly, if you'd like to ship the code or just want to make your code look worse.

## Installation

Add `cryptify` to your `Cargo.toml` as a dependency:

```toml
[dependencies]
cryptify = "3.1.0"
```

To install `rust-obfuscator`, clone the repository and build the tool using Cargo from the root:
```
cargo build --release --bin rust-obfuscator
```
The binary can then be found under /target/release, you can copy it to the root of the project like such
```
cp ./target/release/rust-obfuscator .
```

# Usage
Set the **CRYPTIFY_KEY** environment variable for custom encryption otherwise it defaults to defined fixed key
- Add to source code you'd like to modify
```rs
use cryptify;
```
The binary can be used on either a file or a directory. If provided with a directory it will only modify rust source files within that directory not any subdirectories
```sh
./rust-obfuscator path/to/your_project <Options>
```
- All Obfuscated code will be under the **obfuscated_code** directory that is created from the directory the tool was run.
- **Recommended to use a Rust Formatter with the obfuscated code as syn naturally modifies the structure and it will be written to the file as one line**

## Option Flags
- --no_string: Disables string obfuscation.
- --no_flow: Disables control flow obfuscation.
- --disable_macro: Uses direct source manipulation for flow obfuscation instead of procedural macros.
- --var: Enables variable renaming source code obfuscation.

### Example usage with flag
```sh
rust-obfuscator path/to/your_project --no_flow 
```
(disables flow obfuscation)

# Input
-running the tool with no config
```rs
use cryptify;
mod word_counter;
use std::env;
use std::fs;
use word_counter::count_words;
fn main() {
    let b = "Hello World";
    println!("{}", b);
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <filename>", args[0]);
        return;
    }
    let filename = &args[1];
    let content = fs::read_to_string(filename).expect("Could not read file");
    let word_counts = count_words(&content);
    for (word, count) in word_counts.iter() {
        println!("{}: {}", word, count);
    }
}

fn dummy() {
    let a = 1;
    let b = 2;
    let c = a + b;
    println!("{}", c);
}

fn calc_sum(a: i32, b: i32) -> i32 {
    cryptify::flow_stmt!();
    let c = a + b;
    c
}

fn helloooo(){
    println!("hi");
}

```
# Output
```rs
fn main() {
    cryptify::flow_stmt!();
    let b = cryptify::encrypt_string!("Hello World");
    println!("{}", b);
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <filename>", args[0]);
        return;
    }
    let filename = &args[1];
    let content = fs::read_to_string(filename).expect("Could not read file");
    let word_counts = count_words(&content);
    for (word, count) in word_counts.iter() {
        println!("{}: {}", word, count);
    }
}
fn dummy() {
    cryptify::flow_stmt!();
    let a = 1;
    let b = 2;
    let c = a + b;
    println!("{}", c);
}
fn calc_sum(a: i32, b: i32) -> i32 {
    cryptify::flow_stmt!();
    let c = a + b;
    c
}
fn helloooo() {
    println!("hi");
}
```
## Expanded Output
```rs
fn main() {
    {
        let _is_dummy_145 = true;
        let _dummy_upper_bound = 100;
        let _random_dummy_var = 1;
        let mut _dummy_counter = 6i32;
        let _dummy_increment = 2i32;
        loop {
            if _dummy_counter > _dummy_upper_bound {
                break;
            }
            unsafe {
                std::ptr::write_volatile(
                    &mut _dummy_counter,
                    _dummy_counter + _dummy_increment,
                );
            }
        }
    };
    let b = cryptify::decrypt_string("0\u{b}\r\u{1f}\tFd\u{18}\u{11}\t\0");
    {
        ::std::io::_print(format_args!("{0}\n", b));
    };
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        {
            ::std::io::_eprint(format_args!("Usage: {0} <filename>\n", args[0]));
        };
        return;
    }
    let filename = &args[1];
    let content = fs::read_to_string(filename).expect("Could not read file");
    let word_counts = count_words(&content);
    for (word, count) in word_counts.iter() {
        {
            ::std::io::_print(format_args!("{0}: {1}\n", word, count));
        };
    }
}
fn dummy() {
    {
        let _is_dummy_145 = true;
        let mut _dummy_counter = 4i32;
        let _dummy_upper_bound = 100;
        let _dummy_increment = 3i32;
        loop {
            if _dummy_counter > _dummy_upper_bound {
                break;
            }
            unsafe {
                std::ptr::write_volatile(
                    &mut _dummy_counter,
                    _dummy_counter + _dummy_increment,
                );
            }
        }
    };
    let a = 1;
    let b = 2;
    let c = a + b;
    {
        ::std::io::_print(format_args!("{0}\n", c));
    };
}
fn calc_sum(a: i32, b: i32) -> i32 {
    {
        let _is_dummy_145 = true;
        let mut _dummy_counter = 8i32;
        let _dummy_increment = 3i32;
        let _extra_dummy_var = 4i32;
        let _dummy_upper_bound = 100;
        loop {
            if _dummy_counter > _dummy_upper_bound {
                break;
            }
            unsafe {
                std::ptr::write_volatile(
                    &mut _dummy_counter,
                    _dummy_counter + _dummy_increment,
                );
            }
        }
    };
    let c = a + b;
    c
}
fn helloooo() {
    {
        ::std::io::_print(format_args!("hi\n"));
    };
}
```
# License
rust-obfuscator is licensed under the MIT License - see the [LICENSE](https://github.com/dronavallipranav/rust-obfuscator/blob/main/LICENSE) file for details.

```

`auto_obfuscate/Cargo.toml`:

```toml
[package]
name = "rust-obfuscator"
version = "1.0.0"
edition = "2021"

[[bin]]
name = "rust-obfuscator"
path = "src/main.rs" 

[dependencies]
syn = { version = "2.0", features = ["full", "visit-mut", "visit"] }
quote = "1.0"
proc-macro2 = "1.0"
rand = "0.8.0"
regex = "1.5.4"
clap = "3.0"
cryptify = "3.1.0"
```

`auto_obfuscate/src/flow.rs`:

```rs
use syn::{ visit_mut::VisitMut, Block, Stmt, parse_file, Expr, Pat, PatIdent, parse_quote };
use quote::quote;
use rand::{ Rng, thread_rng };
use rand::seq::SliceRandom;

#[cfg(test)]
mod flow_tests;

#[derive(Clone)]
pub struct FlowConfig {
    pub enable_flow_obfuscation: bool,
    pub use_macro: bool,
}
impl FlowConfig {
    pub fn default() -> Self {
        Self {
            enable_flow_obfuscation: true,
            use_macro: true,
        }
    }
}

pub struct FlowObfuscator {
    loop_counter: u32,
    pub use_macro: bool,
    pub enabled: bool,
}

impl FlowObfuscator {
    pub fn new(config: FlowConfig) -> Self {
        Self {
            loop_counter: 0,
            use_macro: config.use_macro,
            enabled: config.enable_flow_obfuscation,
        }
    }
    pub fn flow_obfuscate(&mut self, code: &str) -> String {
        let ast = parse_file(code).expect("Failed to parse code");
        let mut modified_ast = ast.clone();
        self.visit_file_mut(&mut modified_ast);
        let modified_code = quote!(#modified_ast).to_string();
        modified_code
    }
    //check to see if statement in block is dummy loop
    fn is_dummy_loop(stmt: &Stmt) -> bool {
        if let Stmt::Expr(Expr::Block(expr_block), _) = stmt {
            for stmt in &expr_block.block.stmts {
                if let Stmt::Local(local) = stmt {
                    if let Pat::Ident(PatIdent { ident, .. }) = &local.pat {
                        if ident == "_is_dummy_145" {
                            return true;
                        }
                    }
                }
            }
        }

        false
    }
    //helper to generate random dummy loop
    fn generate_dummy_loop() -> Stmt {
        let mut rng = thread_rng();

        let initial_value = rng.gen_range(1..=10);
        let increment_value = rng.gen_range(1..=5);
        let add_extra_dummy_variable = rng.gen_bool(0.5);

        let mut statements = vec![
            quote! { let mut _dummy_counter = #initial_value; },
            quote! { let _dummy_increment = #increment_value; },
            quote! { let _dummy_upper_bound = 100; }
        ];

        //add extra dummy variable occasionally
        if add_extra_dummy_variable {
            let extra_dummy_value = rng.gen_range(1..=10);
            statements.push(quote! { let _extra_dummy_var = #extra_dummy_value; });
        }

        //randomize the order of variable assignments
        statements.shuffle(&mut rng);

        let loop_block =
            quote! {
        loop {
            if _dummy_counter > _dummy_upper_bound{
                break;
            }
            //prevent compiler optimizations
            unsafe {
                std::ptr::write_volatile(&mut _dummy_counter, _dummy_counter + _dummy_increment);
            }
        }
    };

        parse_quote! {
        {
            let _is_dummy_145 = true;
            #(#statements)*
            #loop_block
        }
    }
    }
}

impl VisitMut for FlowObfuscator {
    fn visit_block_mut(&mut self, block: &mut Block) {
        //check if the block already contains the dummy loop
        if block.stmts.iter().any(|stmt| Self::is_dummy_loop(stmt)) || self.loop_counter % 3 != 0 {
            self.loop_counter += 1;
            return;
        }
        //if use macro enabled, use macro to expand to dummy loop
        if self.use_macro {
            let macro_call = syn::parse_quote! {
                cryptify::flow_stmt!();
            };
            block.stmts.insert(0, macro_call);
        } else {
            let dummy_loop = Self::generate_dummy_loop();
            block.stmts.insert(0, dummy_loop);
        }

        self.loop_counter += 1;
        syn::visit_mut::visit_block_mut(self, block);
    }
}

```

`auto_obfuscate/src/flow/flow_tests.rs`:

```rs
#[cfg(test)]
use super::*;

#[test]
fn test_loop_insertion() {
    let code =
        r#"
            fn main() {
                let mut num1 = 10;
                let num2 = 20;
                num1 = 30;
                let sum = num1 + num2;
                println!("The sum is: {}", sum);
            }
        "#;
    let flow_config = FlowConfig {
        enable_flow_obfuscation: true,
        use_macro: false,
    };
    let mut obfuscator = FlowObfuscator::new(flow_config);
    let modified_code = obfuscator.flow_obfuscate(code);

    assert_ne!(modified_code, code);
    //check if loop is inserted at start of block
    assert!(modified_code.contains("_is_dummy_145"), "Dummy loop not found in modified code");
    //valid rust code
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

#[test]
fn test_loop_skip() {
    let code =
        r#"
        fn calculate_sum(num1: i32, num2: i32) -> i32 {
            num1 + num2
        }
        fn ok(){
            
        }
            fn main() {
                let mut num1 = 10;
                let num2 = 20;
                num1 = 30;
                let sum = num1 + num2;
                println!("The sum is: {}", sum);
            }
        "#;
    let flow_config = FlowConfig {
        enable_flow_obfuscation: true,
        use_macro: false,
    };
    let mut obfuscator = FlowObfuscator::new(flow_config);
    let modified_code = obfuscator.flow_obfuscate(code);

    assert_ne!(modified_code, code);
    //check if loop is inserted at start of block
    assert!(modified_code.contains("_is_dummy_145"), "Dummy loop not found in modified code");

    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");

    let num_loops = modified_code.matches("_is_dummy_145").count();
    assert!(num_loops == 2, "exactly two dummy loops not found in modified code");
}

```

`auto_obfuscate/src/main.rs`:

```rs
mod rename;
mod flow;
mod string;
mod obfuscate;
use crate::obfuscate::{ Obfuscator, Config };
use clap::{ App, Arg };
use std::path::Path;
use std::fs;

fn main() {
    //default config
    let mut config = Config::default();
    let matches = App::new("Rust Automatic Obfuscator")
        .version("1.0")
        .author("Pranav Dronavalli")
        .about("Obfuscates Rust source code")
        .arg(
            Arg::with_name("path")
                .help("Path to the Rust file or directory")
                .required(true)
                .index(1)
        )
        .arg(Arg::with_name("no_string").long("no_string").help("Disable string obfuscation"))
        .arg(Arg::with_name("no_flow").long("no_flow").help("Disable control flow obfuscation"))
        .arg(
            Arg::with_name("disable_macro")
                .long("disable_macro")
                .help("disable macro and modify source directly for flow obfuscation")
        )
        .arg(Arg::with_name("var").long("var").help("Enable variable renaming"))
        .arg(Arg::with_name("p")
                 .short('p')
                 .long("percent_strings_to_encrypt")
                 .help("set upper bound for string literal encryption")
                 .value_name("PERCENTAGE"))
        .get_matches();

    let path = matches.value_of("path").unwrap();

    //disable string obfuscation if the flag is set
    if matches.is_present("no_string") {
        config.string_config.enable_string_obfuscation = false;
    }

    //disable flow obfuscation if the flag is set
    if matches.is_present("no_flow") {
        config.flow_config.enable_flow_obfuscation = false;
    }

    //disable use of proc macro if the flag is set
    if matches.is_present("disable_macro") {
        config.flow_config.use_macro = false;
    }
    //enable variable renaming if the flag is set
    if matches.is_present("var") {
        config.rename_config.enable_rename_obfuscation = true;
    }
    //set upper bound for string literal encryption
    if let Some(percentage) = matches.value_of("p") {
        config.string_config.percentage = match percentage.parse() {
            Ok(n) if n <= 100 => n,
            _ => {
                eprintln!("-p: expected integer between 0 and 100, got: `{}`", percentage);
                eprintln!("defaulting to 100%");
                100
            }
        };
    }

    process_path(&path, &config);
}

fn process_path(path_str: &str, config: &Config) {
    let path = Path::new(path_str);
    if path.is_dir() {
        process_directory(path, config);
    } else if path.is_file() {
        process_file(path, config);
    } else {
        eprintln!("Invalid path: {}", path_str);
    }
}
//process all files in directory
fn process_directory(dir_path: &Path, config: &Config) {
    for entry in fs::read_dir(dir_path).expect("Failed to read directory") {
        let entry = entry.expect("Failed to read entry");
        let path = entry.path();
        if path.is_file() {
            process_file(&path, config);
        }
    }
}
//read code from file
fn process_file(file_path: &Path, config: &Config) {
    if file_path.extension().unwrap_or_default() == "rs" {
        let code = fs::read_to_string(file_path).expect("Failed to read file");

        let mut obfuscator = Obfuscator::from_config(config.clone());
        let obfuscated_code = obfuscator.obfuscate(&code);

        //check if obfuscated code is valid Rust code
        let parse_result = syn::parse_file(&obfuscated_code);
        if parse_result.is_err() {
            eprintln!("Obfuscated code is not valid Rust code");
            return;
        }
        write_obfuscated_code(file_path, &obfuscated_code);
    }
}
//write file to obfuscated_code directory
fn write_obfuscated_code(original_path: &Path, obfuscated_code: &str) {
    let obfuscated_dir = Path::new("obfuscated_code");
    fs::create_dir_all(&obfuscated_dir).expect("Failed to create directory");

    let obfuscated_path = obfuscated_dir.join(original_path.file_name().unwrap());
    println!("Writing to {:?}", obfuscated_path);
    fs::write(obfuscated_path, obfuscated_code).expect("Failed to write obfuscated code");
}

```

`auto_obfuscate/src/obfuscate.rs`:

```rs
use crate::string::{ StringObfuscator, StringConfig };
use crate::rename::{ VariableRenamer, RenameConfig };
use crate::flow::{ FlowObfuscator, FlowConfig };

#[derive(Clone)]
pub struct Config {
    pub rename_config: RenameConfig,
    pub flow_config: FlowConfig,
    pub string_config: StringConfig,
}

impl Config {
    pub fn default() -> Self {
        Self {
            rename_config: RenameConfig::default(),
            flow_config: FlowConfig::default(),
            string_config: StringConfig::default(),
        }
    }
}

pub struct Obfuscator {
    rename_obfuscator: VariableRenamer,
    flow_obfuscator: FlowObfuscator,
    string_obfuscator: StringObfuscator,
}

impl Obfuscator {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self {
            rename_obfuscator: VariableRenamer::new(RenameConfig::default()),
            flow_obfuscator: FlowObfuscator::new(FlowConfig::default()),
            string_obfuscator: StringObfuscator::new(StringConfig::default()),
        }
    }
    pub fn from_config(config: Config) -> Self {
        Self {
            rename_obfuscator: VariableRenamer::new(config.rename_config),
            flow_obfuscator: FlowObfuscator::new(config.flow_config),
            string_obfuscator: StringObfuscator::new(config.string_config),
        }
    }

    pub fn obfuscate(&mut self, code: &str) -> String {
        let mut result = code.to_string();
        if self.string_obfuscator.enabled {
            result = self.string_obfuscator.obfuscate_strings(&result);
        }
        if self.flow_obfuscator.enabled {
            result = self.flow_obfuscator.flow_obfuscate(&result);
        }
        if self.rename_obfuscator.enabled {
            result = self.rename_obfuscator.rename(&result);
        }
        result
    }
}

```

`auto_obfuscate/src/rename.rs`:

```rs
use rand::{ Rng };
use syn::{
    visit_mut::VisitMut,
    parse_file,
    Ident,
    ItemFn,
    Local,
    Expr,
    ExprPath,
    Macro,
    Visibility,
    UseTree,
    UsePath,
    UseName,
    UseRename,
    ItemUse,
};
use quote::quote;
use std::collections::{ HashMap, HashSet };
use proc_macro2::{ TokenStream, TokenTree, Group };

#[cfg(test)]
mod rename_tests;

#[derive(Clone)]
pub struct RenameConfig {
    pub enable_rename_obfuscation: bool,
}

//default rename to false
impl RenameConfig {
    pub fn default() -> Self {
        Self {
            enable_rename_obfuscation: false,
        }
    }
}

pub struct VariableRenamer {
    renamed_vars: HashMap<String, String>,
    imported_functions: HashSet<String>,
    pub enabled: bool,
}

impl VariableRenamer {
    pub fn new(config: RenameConfig) -> Self {
        VariableRenamer {
            renamed_vars: HashMap::new(),
            imported_functions: HashSet::new(),
            enabled: config.enable_rename_obfuscation,
        }
    }
    //helper to process Macros tokenstream and check if it is an identifier or another macro or func call
    fn process_tokens(&mut self, tokens: TokenStream) -> TokenStream {
        tokens
            .into_iter()
            .map(|token| {
                match token {
                    TokenTree::Group(group) => {
                        let modified_tokens = self.process_tokens(group.stream());
                        TokenTree::Group(Group::new(group.delimiter(), modified_tokens))
                    }
                    TokenTree::Ident(ident) => {
                        if let Some(new_name) = self.renamed_vars.get(&ident.to_string()) {
                            TokenTree::Ident(Ident::new(new_name, ident.span()))
                        } else {
                            TokenTree::Ident(ident)
                        }
                    }
                    _ => token,
                }
            })
            .collect()
    }

    //scan use statements to identify imported functions and add them to blacklist
    fn identify_imported_functions(&mut self, tree: &UseTree) {
        match tree {
            UseTree::Path(UsePath { ident: _, tree, .. }) => {
                self.identify_imported_functions(tree);
            }
            UseTree::Name(UseName { ident }) => {
                self.imported_functions.insert(ident.to_string());
            }
            UseTree::Rename(UseRename { rename, .. }) => {
                self.imported_functions.insert(rename.to_string());
            }
            _ => {}
        }
    }
    pub fn rename(&mut self, code: &str) -> String {
        let ast = parse_file(code).expect("Failed to parse code");
        let mut modified_ast = ast.clone();
        self.visit_file_mut(&mut modified_ast);
        let modified_code = quote!(#modified_ast).to_string();
        modified_code
    }
}

//check to see if the function is local, only rename local functions for now
fn is_local_function(fn_item: &ItemFn) -> bool {
    !matches!(fn_item.vis, Visibility::Public(_))
}

impl VisitMut for VariableRenamer {
    //visit use statements to identify imported functions
    fn visit_item_use_mut(&mut self, i: &mut ItemUse) {
        self.identify_imported_functions(&i.tree);
        syn::visit_mut::visit_item_use_mut(self, i);
    }

    fn visit_item_fn_mut(&mut self, i: &mut ItemFn) {
        //rename function names unless it's main
        let old_name = i.sig.ident.to_string();
        if
            old_name != "main" &&
            is_local_function(i) &&
            !self.imported_functions.contains(&old_name)
        {
            if !self.renamed_vars.contains_key(&old_name) {
                let new_name = random_name();
                self.renamed_vars.insert(old_name.clone(), new_name.clone());
                i.sig.ident = Ident::new(&new_name, i.sig.ident.span());
            }
        }

        let len = i.block.stmts.len();
        for (index, stmt) in i.block.stmts.iter_mut().enumerate() {
            match stmt {
                syn::Stmt::Local(local) => self.visit_local_mut(local),

                //check if last statement is an expression
                syn::Stmt::Expr(expr, _) if index == len - 1 => {
                    self.visit_expr_mut(expr);
                }

                _ => syn::visit_mut::visit_stmt_mut(self, stmt),
            }
        }
    }

    fn visit_macro_mut(&mut self, i: &mut Macro) {
        i.tokens = self.process_tokens(i.tokens.clone());
    }

    fn visit_expr_mut(&mut self, expr: &mut Expr) {
        //check expression type and rename vars accordingly
        match expr {
            Expr::Path(ExprPath { ref mut path, .. }) => {
                if let Some(last_segment) = path.segments.last_mut() {
                    let var_name = last_segment.ident.to_string();
                    if let Some(new_name) = self.renamed_vars.get(&var_name) {
                        last_segment.ident = Ident::new(new_name, last_segment.ident.span());
                    }
                }
            }
            Expr::Assign(expr_assign) => {
                //check left of expression
                if let Expr::Path(ExprPath { ref mut path, .. }) = *expr_assign.left {
                    if let Some(last_segment) = path.segments.last_mut() {
                        let var_name = last_segment.ident.to_string();
                        if let Some(new_name) = self.renamed_vars.get(&var_name) {
                            last_segment.ident = Ident::new(new_name, last_segment.ident.span());
                        }
                    }
                }
                // recursively visit right of assignment in case of more complex expression
                self.visit_expr_mut(&mut *expr_assign.right);
            }
            //handle function call
            Expr::Call(expr_call) => {
                //rename function names
                if let Expr::Path(expr_path) = &mut *expr_call.func {
                    if let Some(last_segment) = expr_path.path.segments.last_mut() {
                        let func_name = last_segment.ident.to_string();
                        if let Some(new_name) = self.renamed_vars.get(&func_name) {
                            last_segment.ident = Ident::new(new_name, last_segment.ident.span());
                        }
                    }
                }
                //rename all function arguments
                for arg in &mut expr_call.args {
                    self.visit_expr_mut(arg);
                }
            }

            _ => {}
        }

        syn::visit_mut::visit_expr_mut(self, expr);
    }

    //visit local variables
    fn visit_local_mut(&mut self, local: &mut Local) {
        if let Some(local_init) = &mut local.init {
            self.visit_expr_mut(local_init.expr.as_mut());
        }
        //change variable name
        if let syn::Pat::Ident(ref mut pat_ident) = local.pat {
            let old_name = pat_ident.ident.to_string();
            let new_name = random_name();
            self.renamed_vars.insert(old_name, new_name.clone());
            pat_ident.ident = Ident::new(&new_name, pat_ident.ident.span());
        }
    }
}

// Function to generate a random name
fn random_name() -> String {
    let mut rng = rand::thread_rng();
    let name_length = rng.gen_range(3..=10);

    let mut last_char_was_underscore = false;
    let mut name = String::new();

    while name.len() < name_length {
        let next_char = if rng.gen_bool(0.8) { rng.gen_range(b'a'..=b'z') as char } else { '_' };

        // Ensure not two underscores in a row
        if !(last_char_was_underscore && next_char == '_') {
            name.push(next_char);
            last_char_was_underscore = next_char == '_';
        }
    }
    // Ensure the name does not start or end with an underscore
    if name.starts_with('_') {
        name.remove(0);
        name.insert(0, rng.gen_range(b'a'..=b'z') as char);
    }
    if name.ends_with('_') {
        name.pop();
        name.push(rng.gen_range(b'a'..=b'z') as char);
    }

    name
}

```

`auto_obfuscate/src/rename/rename_tests.rs`:

```rs
#[cfg(test)]
use super::*;
use regex::Regex;

//function for testing
fn is_valid_rust_var_name(name: &str) -> bool {
    let re = Regex::new(r"^[a-zA-Z_][a-zA-Z0-9_]*$").unwrap();
    re.is_match(name)
}

#[test]
fn test_variable_renamer() {
    let code =
        r#"
            fn calculate_sum(a: i32, b: i32) -> i32 {
                let result = a + b;
                result
            }

            fn main() {
                let mut num1 = 10;
                let num2 = 20;
                num1 = 30;
                let sum = calculate_sum(num1, num2);
                println!("The sum is: {}", sum);
            }
        "#;
    let rename_config = RenameConfig {
        enable_rename_obfuscation: true,
    };
    let mut renamer = VariableRenamer::new(rename_config);
    let modified_code = renamer.rename(code);

    //compare the modified code with the original
    assert_ne!(modified_code, code);

    //check if names used are all valid rust variable names
    for new_name in renamer.renamed_vars.values() {
        assert!(is_valid_rust_var_name(new_name), "Invalid variable name: {}", new_name);
    }

    //original names should not be found in modified code (except for sum TO DO: remove when string encryption is implemented)
    let original_names = vec!["calculate_sum", "result", "num1", "num2"];
    for name in original_names {
        assert!(
            !modified_code.contains(name),
            "Original name '{}' still found in modified code",
            name
        );
    }
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}
#[test]
fn test_nested_function_calls() {
    let code =
        r#"
            fn add_one(x: i32) -> i32 {
                x + 1
            }

            fn calculate_sum(a: i32, b: i32) -> i32 {
                let result = a + b;
                result
            }

            fn main() {
                let mut num1 = 10;
                let num2 = 20;
                num1 = 30;
                let sum = calculate_sum(add_one(num1), num2);
                println!("The sum is: {}", sum);
            }
        "#;
    let rename_config = RenameConfig {
        enable_rename_obfuscation: true,
    };
    let mut renamer = VariableRenamer::new(rename_config);
    let modified_code = renamer.rename(code);

    let original_names = vec!["calculate_sum", "add_one", "num1", "num2", "result"];
    for name in original_names {
        assert!(
            !modified_code.contains(name),
            "Original function name '{}' still found in modified code",
            name
        );
    }
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

#[test]
fn test_nested_macros() {
    let code =
        r#"
        fn main() {
            let num1 = 10;
            let num2 = 20;
            println!("Formatted: {}", format!("Num1: {}, Num2: {}", num1, num2));
        }
    "#;
    let rename_config = RenameConfig {
        enable_rename_obfuscation: true,
    };
    let mut renamer = VariableRenamer::new(rename_config);
    let modified_code = renamer.rename(code);

    let original_names = vec!["calculate_sum", "add_one", "num1", "num2", "result"];
    for name in original_names {
        assert!(
            !modified_code.contains(name),
            "Original function name '{}' still found in modified code",
            name
        );
    }
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}
#[test]
fn test_user_defined_nested_macro() {
    let code =
        r#"
            macro_rules! identity {
                ($x:expr) => ($x)
            }

            fn main() {
                let num1 = 10;
                let num2 = 20;
                println!("Num1: {}", identity!(num1));
                println!("Num2: {}", identity!(num2));
            }
        "#;
    let rename_config = RenameConfig {
        enable_rename_obfuscation: true,
    };
    let mut renamer = VariableRenamer::new(rename_config);
    let modified_code = renamer.rename(code);

    let original_names = vec!["calculate_sum", "add_one", "num1", "num2", "result"];
    for name in original_names {
        assert!(
            !modified_code.contains(name),
            "Original function name '{}' still found in modified code",
            name
        );
    }
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}
#[test]
fn test_function_in_macro() {
    let code =
        r#"
            fn add_one(x: i32) -> i32 {
                x + 1
            }

            fn main() {
                let num = 10;
                println!("Num + 1: {}", add_one(num));
            }
        "#;
    let rename_config = RenameConfig {
        enable_rename_obfuscation: true,
    };
    let mut renamer = VariableRenamer::new(rename_config);
    let modified_code = renamer.rename(code);

    let original_names = vec!["calculate_sum", "add_one", "num1", "num2", "result"];
    for name in original_names {
        assert!(
            !modified_code.contains(name),
            "Original function name '{}' still found in modified code",
            name
        );
    }
    let parse_result = syn::parse_file(&modified_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

```

`auto_obfuscate/src/string.rs`:

```rs
use syn::{
    visit_mut::VisitMut,
    visit::Visit,
    parse_file,
    parse_str,
    Expr,
    ExprLit,
    LitStr,
    Lit,
    File,
    Local,
    parse_quote,
};
use quote::quote;
use proc_macro2::{ TokenStream, TokenTree };

#[cfg(test)]
mod string_tests;

#[derive(Clone)]
pub struct StringConfig {
    pub enable_string_obfuscation: bool,
    pub percentage: u8,
}
impl StringConfig {
    pub fn default() -> Self {
        Self {
            enable_string_obfuscation: true,
            percentage: 100,
        }
    }
}

pub struct StringObfuscator {
    pub enabled: bool,
    #[allow(dead_code)]
    percentage: u8,
    encrypted_count: usize,
    strings_to_encrypt: usize,
    num_strings_encrypted: usize,
}

impl StringObfuscator {
    pub fn new(config: StringConfig) -> Self {
        Self {
            enabled: config.enable_string_obfuscation,
            percentage: config.percentage,
            encrypted_count: 0,
            strings_to_encrypt: 0,
            num_strings_encrypted: 0,
        }
    }
    #[allow(dead_code)]
    fn process_macro_tokens(&self, tokens: TokenStream) -> TokenStream {
        tokens
            .into_iter()
            .map(|token| {
                (
                    match token {
                        TokenTree::Literal(lit) => {
                            //convert literal obj to string
                            let lit_str = lit.to_string();

                            //replace literal obj with macro call
                            if let Ok(lit_str) = parse_str::<LitStr>(&lit_str) {
                                let macro_call: TokenStream =
                                    quote! {
                        cryptify::encrypt_string!(#lit_str)
                    };
                                return macro_call;
                            }

                            TokenTree::Literal(lit)
                        }
                        //handle nested groups in macro
                        TokenTree::Group(group) => {
                            let new_stream = self.process_macro_tokens(group.stream());
                            TokenTree::Group(proc_macro2::Group::new(group.delimiter(), new_stream))
                        }
                        _ => token,
                    }
                ).into()
            })
            .collect()
    }

    pub fn obfuscate_strings(&mut self, code: &str) -> String {
        let ast = parse_file(code).expect("Failed to parse code");

        let total_strings = count_string_literals(&ast);
        let strings_to_encrypt = (
            ((self.percentage as f32) / 100.0) *
            (total_strings as f32)
        ).ceil() as usize;
        self.encrypted_count = 0;
        self.strings_to_encrypt = strings_to_encrypt;

        let mut modified_ast = ast.clone();
        self.visit_file_mut(&mut modified_ast);
        let modified_code = quote!(#modified_ast).to_string();
        modified_code
    }
}

impl VisitMut for StringObfuscator {
    //replace all string literals with call to obfuscation macro
    fn visit_local_mut(&mut self, local: &mut Local) {
        if let Some(local_init) = &mut local.init {
            if self.num_strings_encrypted >= self.strings_to_encrypt {
                return;
            }
            self.num_strings_encrypted += 1;


            //match on local variables that contain string literal assignments
            if let Expr::Lit(ExprLit { lit: Lit::Str(lit_str), .. }) = &*local_init.expr {
                let encrypted = quote! { cryptify::encrypt_string!(#lit_str) };
                let new_expr: Expr = parse_quote!(#encrypted);
                *local_init.expr = *Box::new(new_expr);
            }
        }

        syn::visit_mut::visit_local_mut(self, local);
    }
}

struct StringLiteralCounter {
    count: usize,
}

impl StringLiteralCounter {
    fn new() -> Self {
        Self { count: 0 }
    }
}

impl<'ast> Visit<'ast> for StringLiteralCounter {
    fn visit_lit_str(&mut self, _lit_str: &'ast LitStr) {
        self.count += 1;
    }
}

fn count_string_literals(ast: &File) -> usize {
    let mut counter = StringLiteralCounter::new();
    counter.visit_file(ast);
    counter.count
}

```

`auto_obfuscate/src/string/string_tests.rs`:

```rs
#[cfg(test)]
use super::*;

#[test]
fn test_replacement_in_expr() {
    let code = r#"
        fn main() {
            let b = "Hello, world!";
        }
    "#;
    let string_config = StringConfig::default();
    let mut string_obfuscator = StringObfuscator::new(string_config);
    let obfuscated_code = string_obfuscator.obfuscate_strings(code);
    assert_ne!(code, obfuscated_code);
    assert!(obfuscated_code.contains("encrypt_string"));

    let parse_result = syn::parse_file(&obfuscated_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

#[test]
fn test_no_macro() {
    let code =
        r#"
        fn main() {
            println!("Hello, world!");
            let word_re = Regex::new(r"\b\w+\b").unwrap();
        }
    "#;
    let string_config = StringConfig::default();
    let mut string_obfuscator = StringObfuscator::new(string_config);
    let obfuscated_code = string_obfuscator.obfuscate_strings(code);
    assert!(!obfuscated_code.contains("encrypt_string"));
    let parse_result = syn::parse_file(&obfuscated_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

#[test]
fn test_percentage() {
    let code =
        r#"
    fn main() {
        let a = "a";
        let b = "b";
        let c = "c";
        let d = "d";
        let e = "e";
        let f = "f";
        let g = "g";
        let h = "h";
        let i = "i";
        let j = "j";
        println!("Hello");
        println!("Hello");
        println!("Hello");
        println!("Hello");
        println!("Hello");
        println!("Hello");
    }
"#;

    let mut string_config = StringConfig::default();
    string_config.percentage = 80;
    let mut string_obfuscator = StringObfuscator::new(string_config);
    let obfuscated_code = string_obfuscator.obfuscate_strings(code);
    assert_ne!(code, obfuscated_code);
    assert!(obfuscated_code.contains("encrypt_string ! (\"h\")"));
    assert!(obfuscated_code.contains("let i = \"i\""));
    println!("{}", obfuscated_code);

    let parse_result = syn::parse_file(&obfuscated_code);
    assert!(parse_result.is_ok(), "Modified code is not valid Rust code");
}

```

`cryptify/Cargo.toml`:

```toml
[package]
name = "cryptify"
version = "3.1.0"
edition = "2021"
authors = ["Pranav Dronavalli <dronavallipranav@gmail.com>"]
description = "A procedural macro library to obfuscate Rust code. Provides compile-time string encryption and random flow obfuscation."
license = "MIT"
repository = "https://github.com/dronavallipranav/rust-obfuscator/tree/main/labyrinth_macros"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
labyrinth_macros = "2.0.0"

```

`cryptify/README.md`:

```md
# cryptify

`cryptify` is a procedural macro crate for compile-time rust obfuscation. It provides the user with string encryption and compile-time determined flow obfuscation and random variables which survive compile-time optimization.


[rust-obfuscator](https://github.com/dronavallipranav/rust-obfuscator) - Check out this auto obfuscator tool for easier usage and integration
## Features

- **String Obfuscation**: Automatically encrypts string literals in your code at compile time, making them harder to read and understand.
- **Flow Obfuscation**: Introduces dummy loops and random variables into control flows, enhancing the overall obfuscation of the logic.

# Usage

## Bring macro into scope
```rs
use cryptify;

fn main(){
    let decrypted = cryptify::encrypt_string("Hello, World!");
    println!(decrypted);
    println!("{}", cryptify::encrypt_string!("formatted!"));
}
```

Set the **CRYPTIFY_KEY** environment variable for custom encryption otherwise it defaults to defined fixed key

## Output
```
Hello World!
formatted!
```
## Example of expanded Flow_Stmt!

```rs
    {
        let _is_dummy_145 = true;
        let _dummy_upper_bound = 100;
        let _dummy_increment = 1i32;
        let mut _dummy_counter = 10i32;
        let _extra_dummy_var = 2i32;
        loop {
            if _dummy_counter > _dummy_upper_bound {
                break;
            }
            unsafe {
                std::ptr::write_volatile(
                    &mut _dummy_counter,
                    _dummy_counter + _dummy_increment,
                );
            }
        }
    };
    match (&1, &1) {
        (left_val, right_val) => {
            if !(*left_val == *right_val) {
                let kind = ::core::panicking::AssertKind::Eq;
                ::core::panicking::assert_failed(
                    kind,
                    &*left_val,
                    &*right_val,
                    ::core::option::Option::None,
                );
            }
        }
    };

```

# License
cryptify is licensed under the MIT License - see the [LICENSE](https://github.com/dronavallipranav/rust-obfuscator/blob/main/LICENSE) file for details.

```

`cryptify/src/lib.rs`:

```rs
//re-export proc macro crate
pub use labyrinth_macros::*;

/// A helper decryption function meant to decrypt encrypted strings at runtime
///
/// # Parameters
/// - `input`: The encrypted string literal
///
pub fn decrypt_string(encrypted: &str) -> String {
    let key = std::env::var("CRYPTIFY_KEY").unwrap_or_else(|_| "xnasff3wcedj".to_string());
    encrypted
        .chars()
        .zip(key.chars().cycle())
        .map(|(encrypted_char, key_char)| ((encrypted_char as u8) ^ (key_char as u8)) as char)
        .collect()
}

```

`cryptify/tests/macro_tests.rs`:

```rs
//integration tests testing whole crate
#[test]
fn test_encrypt_macro() {
    let decrypted = cryptify::encrypt_string!("Hello World");
    assert_eq!("Hello World", decrypted);
}

#[test]
fn test_flow_macro() {
    //manually test for now with cargo expand
    cryptify::flow_stmt!();
    assert_eq!(1, 1);
}

```

`labyrinth_macros/@`:

```
[package]
name = "obf_macro"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]

```

`labyrinth_macros/Cargo.toml`:

```toml
[package]
name = "labyrinth_macros"
version = "3.0.0"
edition = "2021"
authors = ["Pranav Dronavalli <dronavallipranav@gmail.com>"]
description = "A procedural macro crate for the cryptify crate meant to provide obfuscation through compile time string encryption. not meant to be used standalone"
license = "MIT"
repository = "https://github.com/dronavallipranav/rust-obfuscator/tree/main/labyrinth_macros"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0", features = ["full", "visit-mut"] }
quote = "1.0"
proc-macro2 = "1.0"
rand = "0.8.0"
```

`labyrinth_macros/README.md`:

```md
# labyrinth_macros

`labyrinth_macros` is a procedural macro crate designed to complement the `cryptify` super crate. It provides compile-time string and control flow obfuscation capabilities, aimed at enhancing the security and complexity of Rust code. Not meant to be used standalone, necessary obfuscation features are in the super crate `cryptify`

## Features

- **String Obfuscation**: Automatically encrypts string literals in your code at compile time, making them harder to read and understand.
- **Flow Obfuscation**: Introduces dummy loops and random variables into control flows, enhancing the overall obfuscation of the logic.

# License
labyrinth_macros is licensed under the MIT License - see the [LICENSE](https://github.com/dronavallipranav/rust-obfuscator/blob/main/LICENSE) file for details.
```

`labyrinth_macros/src/lib.rs`:

```rs
//! `labyrinth_macros` crate provides procedural macros for compile-time obfuscation. NOT MEANT TO BE USED STANDALONE.
//!
//! This crate includes macros like `encrypt_string` and `flow_stmt` which are used
//! to enhance the security of Rust code by obfuscating strings and control flows.
use proc_macro::TokenStream;
use quote::quote;
use syn::*;
use std::env;
use rand::Rng;
use rand::seq::SliceRandom;

/// A procedural macro that adds a compile-time randomly generated loop and variables.
///
/// # Note
/// The unsafe operation is meant to help the dummy loop survive compiler optimizations. only writes to dummy variable
///
#[proc_macro]
pub fn flow_stmt(_: TokenStream) -> TokenStream {
    let mut rng = rand::thread_rng();

    let initial_value = rng.gen_range(1..=10);
    let increment_value = rng.gen_range(1..=4);
    let add_extra_dummy_variable = rng.gen_bool(0.5);

    let mut statements = vec![
        quote! { let mut _dummy_counter = #initial_value; },
        quote! { let _dummy_increment = #increment_value; },
        quote! { let _dummy_upper_bound = 100; }
    ];

    //add random dummy variable occasionally
    if add_extra_dummy_variable {
        let extra_dummy_value = rng.gen_range(1..=10);
        statements.push(quote! { let _extra_dummy_var = #extra_dummy_value; });
    }

    //randomize the order of variable assignments
    statements.shuffle(&mut rng);

    let loop_block =
        quote! {
        loop {
            if _dummy_counter > _dummy_upper_bound {
                break;
            }
            //prevent compiler optimizations
            unsafe {
                std::ptr::write_volatile(&mut _dummy_counter, _dummy_counter + _dummy_increment);
            }
        }
    };

    let generated_loop =
        quote! {
        {
            let _is_dummy_145 = true;
            #(#statements)*
            #loop_block
        }
    };

    TokenStream::from(generated_loop)
}
/// A procedural macro that encrypts a string literal at compile time.
///
/// # Parameters
/// - `input`: The string literal to be encrypted.
///
#[proc_macro]
pub fn encrypt_string(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as LitStr);
    let string = input.value();

    //set key to seeded env key or default
    let key = env::var("CRYPTIFY_KEY").unwrap_or_else(|_| "xnasff3wcedj".to_string());

    let encrypted_string = xor_cipher(&string, &key);

    let output = quote! {
        cryptify::decrypt_string(#encrypted_string).as_ref()
    };

    TokenStream::from(output)
}

fn xor_cipher(input: &str, key: &str) -> String {
    input
        .chars()
        .zip(key.chars().cycle())
        .map(|(input_char, key_char)| { ((input_char as u8) ^ (key_char as u8)) as char })
        .collect()
}

//for self-contained tests
#[allow(dead_code)]
fn decrypt_string(encrypted: &str) -> String {
    let key = std::env::var("CRYPTIFY_KEY").unwrap_or_else(|_| "xnasff3wcedj".to_string());
    encrypted
        .chars()
        .zip(key.chars().cycle())
        .map(|(encrypted_char, key_char)| ((encrypted_char as u8) ^ (key_char as u8)) as char)
        .collect()
}

//unit tests testing decryption logic
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xor_cipher_and_decrypt() {
        let key = "xnasff3wcedj";
        let test_strings = ["Hello", "World", "1234", "!@#$%^&*()"];

        for &original in &test_strings {
            let encrypted = xor_cipher(original, &key);
            let decrypted = decrypt_string(&encrypted);
            assert_eq!(original, decrypted, "Failed for string: {}", original);
        }
    }
    #[test]
    fn test_xor_cipher_and_decrypt_customkey() {
        //set key
        std::env::set_var("CRYPTIFY_KEY", "testkey");
        //test loc from encrypt_string meant to extract key
        let key = env::var("CRYPTIFY_KEY").unwrap_or_else(|_| "xnasff3wcedj".to_string());
        assert_eq!(key, "testkey");

        let test_strings = ["Hello", "World", "1234", "!@#$%^&*()"];
        for &original in &test_strings {
            let encrypted = xor_cipher(original, &key);
            let decrypted = decrypt_string(&encrypted);
            assert_eq!(original, decrypted, "Failed for string: {}", original);
        }
    }
}

```