Project Path: arc_gmh5225_IL2CPP_Resolver_External_bu4t7yir

Source Tree:

```txt
arc_gmh5225_IL2CPP_Resolver_External_bu4t7yir
├── IL2CPP_Resolver_External
│   ├── IL2CPP_Resolver_External.cpp
│   ├── IL2CPP_Resolver_External.vcxproj
│   ├── IL2CPP_Resolver_External.vcxproj.filters
│   └── Unity
│       ├── Classes
│       │   ├── Classes.h
│       │   ├── IL2CPP
│       │   │   └── IL2CPPClasses.h
│       │   └── System
│       │       ├── CharacterController.h
│       │       ├── Component.h
│       │       ├── GameClasses.h
│       │       ├── GameObject.h
│       │       ├── Object.h
│       │       ├── Rigidbody.h
│       │       ├── String.h
│       │       └── Transform.h
│       ├── IL2CPP.h
│       ├── Structs
│       │   ├── Engine.h
│       │   └── System_String.h
│       ├── Unity.h
│       └── rw
│           └── usermode.h
├── IL2CPP_Resolver_External.sln
└── README.md

```

`IL2CPP_Resolver_External.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32210.238
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "IL2CPP_Resolver_External", "IL2CPP_Resolver_External\IL2CPP_Resolver_External.vcxproj", "{FF0400F9-6667-42D7-9005-650FFDD69CD0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Debug|x64.ActiveCfg = Debug|x64
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Debug|x64.Build.0 = Debug|x64
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Debug|x86.ActiveCfg = Debug|Win32
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Debug|x86.Build.0 = Debug|Win32
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Release|x64.ActiveCfg = Release|x64
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Release|x64.Build.0 = Release|x64
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Release|x86.ActiveCfg = Release|Win32
		{FF0400F9-6667-42D7-9005-650FFDD69CD0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6DD9676E-A3F1-4967-9E6B-29BAEB4F5BD3}
	EndGlobalSection
EndGlobal

```

`IL2CPP_Resolver_External/IL2CPP_Resolver_External.cpp`:

```cpp
#include <iostream>
#include "Unity/Unity.h"


int main()
{
	if (!um::Init(FindWindowA(nullptr, "Game")))
	{
	   return 0;
	}

	if (!Unity::Initialize())
	{
	    return 0;
	}
	
	while(true)
	{
		// do something
	}
}

```

`IL2CPP_Resolver_External/IL2CPP_Resolver_External.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ff0400f9-6667-42d7-9005-650ffdd69cd0}</ProjectGuid>
    <RootNamespace>IL2CPPResolverExternal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="IL2CPP_Resolver_External.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Unity\Classes\Classes.h" />
    <ClInclude Include="Unity\Classes\IL2CPP\IL2CPPClasses.h" />
    <ClInclude Include="Unity\Classes\System\CharacterController.h" />
    <ClInclude Include="Unity\Classes\System\Component.h" />
    <ClInclude Include="Unity\Classes\System\GameClasses.h" />
    <ClInclude Include="Unity\Classes\System\GameObject.h" />
    <ClInclude Include="Unity\Classes\System\Object.h" />
    <ClInclude Include="Unity\Classes\System\Rigidbody.h" />
    <ClInclude Include="Unity\Classes\System\String.h" />
    <ClInclude Include="Unity\Classes\System\Transform.h" />
    <ClInclude Include="Unity\IL2CPP.h" />
    <ClInclude Include="Unity\rw\usermode.h" />
    <ClInclude Include="Unity\Structs\Engine.h" />
    <ClInclude Include="Unity\Structs\System_String.h" />
    <ClInclude Include="Unity\Unity.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`IL2CPP_Resolver_External/IL2CPP_Resolver_External.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Unity">
      <UniqueIdentifier>{b413b56d-ee68-4ce2-8134-50d6c40c12d0}</UniqueIdentifier>
    </Filter>
    <Filter Include="rw">
      <UniqueIdentifier>{8aaaaef3-dc76-4ddd-898a-d4b4d405411e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Unity\Classes">
      <UniqueIdentifier>{060a77f8-b240-4e3f-a83b-ff5192183d16}</UniqueIdentifier>
    </Filter>
    <Filter Include="Unity\Structs">
      <UniqueIdentifier>{a9bf8ab4-79fc-4682-847a-cb6f4b4fcaa5}</UniqueIdentifier>
    </Filter>
    <Filter Include="Unity\Classes\IL2CPP">
      <UniqueIdentifier>{7c63f1bc-37f9-43ee-8361-7eb421c5f4d7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Unity\Classes\System">
      <UniqueIdentifier>{2d12dd40-a40a-420d-b24e-8618716d2e77}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="IL2CPP_Resolver_External.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Unity\Unity.h">
      <Filter>Unity</Filter>
    </ClInclude>
    <ClInclude Include="Unity\rw\usermode.h">
      <Filter>rw</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\Classes.h">
      <Filter>Unity\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Structs\Engine.h">
      <Filter>Unity\Structs</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\IL2CPP\IL2CPPClasses.h">
      <Filter>Unity\Classes\IL2CPP</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Structs\System_String.h">
      <Filter>Unity\Structs</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\Object.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\String.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\Transform.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\Component.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\GameClasses.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\GameObject.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\CharacterController.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\Classes\System\Rigidbody.h">
      <Filter>Unity\Classes\System</Filter>
    </ClInclude>
    <ClInclude Include="Unity\IL2CPP.h">
      <Filter>Unity</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`IL2CPP_Resolver_External/Unity/Classes/Classes.h`:

```h
#pragma once

#define IL2CPP_PAD_INSERT(x, y) x ## y
#define IL2CPP_PAD_DEFINE(x, y) IL2CPP_PAD_INSERT(x, y)
#define IL2CPP_PAD(size) char IL2CPP_PAD_DEFINE(padding_, __LINE__)[size]

// include IL2CPP Classes
#include "IL2CPP/IL2CPPClasses.h"

// include Structs
#include "../Structs/Engine.h"
#include "../Structs/System_String.h"

// inlcude System Classes
#include "System/Object.h"
#include "System/GameObject.h"
#include "System/Transform.h"
#include "System/Component.h"
#include "System/String.h"

#include "System/CharacterController.h"
#include "System/Rigidbody.h"

struct ComponentList
{
	Component* m_Component;
	void* unk;
};

struct BaseObject
{
	IL2CPP_PAD(0x8);
	BaseObject* nextObjectLink;
	GameObject* object;
};

struct LastObjectBase
{
	IL2CPP_PAD(0x10);
	GameObject* lastObject;
};

struct GameObjectManager {
	LastObjectBase* lastTaggedObject;
	BaseObject* taggedObjects;
	LastObjectBase* lastActiveObject;
	BaseObject* activeObjects;
	LastObjectBase* lastUntaggedObject;
	BaseObject* UntaggedObjects;
};

```

`IL2CPP_Resolver_External/Unity/Classes/IL2CPP/IL2CPPClasses.h`:

```h
#pragma once

struct il2cppImage
{
	const char* m_pName;
	const char* m_pNameNoExt;
	char m_pad0[0x7];
	int m_iClassStartOffset;
	int m_iClassCount;
};

struct il2cppAssemblyName
{
	const char* m_pName;
	const char* m_pCulture;
	const char* m_pHash;
	const char* m_pPublicKey;
	unsigned int m_uHash;
	int m_iHashLength;
	unsigned int m_uFlags;
	int m_iMajor;
	int m_iMinor;
	int m_iBuild;
	int m_bRevision;
	unsigned char m_uPublicKeyToken[8];
};

struct il2cppAssembly
{
	il2cppImage* m_pImage;
	unsigned int m_uToken;
	int m_ReferencedAssemblyStart;
	int m_ReferencedAssemblyCount;
	il2cppAssemblyName m_aName;
};

struct il2cppClass
{
	void* m_pImage;
	void* m_pGC;
	const char* m_pName;
	const char* m_pNamespace;
	void* m_pValue;					//class
	void* m_pArgs;
	il2cppClass* m_pElementClass;
	il2cppClass* m_pCastClass;
	il2cppClass* m_pDeclareClass;
	il2cppClass* m_pParentClass;
	void* m_pGenericClass;
	void* m_pTypeDefinition;
	void* m_pInteropData;
	void* m_pFields;
	void* m_pEvents;
	void* m_pProperties;
	void** m_pMethods;
	il2cppClass** m_pNestedTypes;
	il2cppClass** m_ImplementedInterfaces;
	void* m_pInterfaceOffsets;
	void* m_pStaticFields;
	void* m_pRGCTX;
};

struct il2cppObject
{
	il2cppClass* m_pClass = nullptr;
	void* m_pMonitor = nullptr;
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/CharacterController.h`:

```h
#pragma once

struct CharacterController
{
	IL2CPP_PAD(0x38);
	void* unk_0; //0x38
	IL2CPP_PAD(0x8);
	void* unk_1; //0x48
	IL2CPP_PAD(0x1D);
	bool enable_Collider; //0x6D
	bool enable_Collider_dup; //0x6C
	IL2CPP_PAD(0x3);
	void* unk_2; //0x70
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/Component.h`:

```h
#pragma once

struct Component : Object
{
	IL2CPP_PAD(0x18);			// 0x27
	Component* m_Component;		// 0x28
	IL2CPP_PAD(0x8);			//
	Transform* m_Transform;		// 0x38
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/GameClasses.h`:

```h
#pragma once
#include <cstdint>

// define your game struct here

struct ExampleGameClass
{
  bool m_bGodMode;
  bool m_bNoClip;
};

```

`IL2CPP_Resolver_External/Unity/Classes/System/GameObject.h`:

```h
#pragma once

struct GameObject : Object
{
	IL2CPP_PAD(0x20);			// 0x28
	void* m_ComponentList;		// 0x30
	IL2CPP_PAD(0x8);
	int m_iComponents;			// 0x40
	IL2CPP_PAD(0x16);
	bool m_active;				// 0x56
	bool m_activeCached;		// 0x57
	IL2CPP_PAD(0x2);
	char* m_ObjectName;			// 0x60
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/Object.h`:

```h
#pragma once

struct Object
{
	void* m_Class;				// 0x0
	int m_pad0;					// 0x4
	int m_InstanceID;			// 0x8
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/Rigidbody.h`:

```h
#pragma once

struct Rigidbody
{
	IL2CPP_PAD(0x98);
	bool isKinematic;	//0x98
	IL2CPP_PAD(0x11);
	bool isKinematic_dup;
};
```

`IL2CPP_Resolver_External/Unity/Classes/System/String.h`:

```h
#pragma once

namespace Unity
{
    /*
        Convert To String, Unity String
    */
    std::string Make_String(System_String* m_str)
    {
        System_String m_String;

        um::ReadMemory(m_str, &m_String);

        std::wstring str(m_String.m_wString);

        // 65001 CP_UTF8
        int ANSIStringLength = WideCharToMultiByte(65001, 0, str.c_str(), m_String.m_iLength + 1, 0, 0, 0, 0);

        char* m_Buffer = (char*)malloc(ANSIStringLength);

        WideCharToMultiByte(65001, 0, str.c_str(), m_String.m_iLength + 1, m_Buffer, ANSIStringLength, 0, 0);

        std::string nstr(m_Buffer);

        free(m_Buffer);

        return nstr;
    }
}
```

`IL2CPP_Resolver_External/Unity/Classes/System/Transform.h`:

```h
#pragma once

struct Transform
{
	IL2CPP_PAD(0x90);		// 0x00
	Vector3 m_Position;		// 0x90
	IL2CPP_PAD(0x8);
	Vector3 m_Rotate;		// 0xA4 (express in -1.f to 1.f)
};
```

`IL2CPP_Resolver_External/Unity/IL2CPP.h`:

```h
#pragma once

namespace IL2CPP
{
    inline void** AssembilesTable;
    inline size_t AssemblyCount;
    inline void* ClassesTable;
    inline void* ClassNamePool;
    inline void* ClassNameSpacePool;

    static void FetchClasses(std::vector<std::pair<il2cppClass*, il2cppClass>>* out, const char* ModuleName)
    {
        out->clear();

        il2cppImage Image = {};
        for (int i = 0; i < AssemblyCount; i++)
        {
            il2cppAssembly assembly;
            um::ReadMemory((void*)AssembilesTable[i], &assembly);

            il2cppImage image;
            um::ReadMemory(assembly.m_pImage, &image);

            char Name[255];
            um::ReadMemory((void*)image.m_pNameNoExt, &Name);

            if (!assembly.m_pImage || strcmp(Name, ModuleName))
            {
                continue;
            }

            //Image = assembly.m_pImage;
            um::ReadMemory(assembly.m_pImage, &Image);

            break;
        }
        ClassNamePool = VirtualAlloc(0x0, Image.m_iClassCount * 255, MEM_COMMIT, PAGE_READWRITE);
        ClassNameSpacePool = VirtualAlloc(0x0, Image.m_iClassCount * 255, MEM_COMMIT, PAGE_READWRITE);
        for (size_t i = 0; i < Image.m_iClassCount; i++)
        {
            DWORD offset = Image.m_iClassStartOffset + i;
            if (offset == -1)
                continue;

            offset *= 8;

            il2cppClass* Class;
            um::ReadMemory((void*)((uintptr_t)ClassesTable + offset), &Class);

            if (!Class)
            {
                continue;
            }

            il2cppClass current;
            um::ReadMemory(Class, &current);

            char* buf = (char*)((uintptr_t)ClassNamePool + i * 255);
            um::ReadMemory((void*)current.m_pName, buf, 255);
            current.m_pName = buf;

            char* buf1 = (char*)((uintptr_t)ClassNameSpacePool + i * 255);
            um::ReadMemory((void*)current.m_pNamespace, buf1, 255);
            current.m_pNamespace = buf1;

            out->push_back(std::make_pair(Class, current));
        }

    }

    static il2cppClass* FilterClass(std::vector<std::pair<il2cppClass*, il2cppClass>>& m_pClasses, const char* m_ClassName, const char* m_ClassNameSpace = nullptr)
    {
        for (auto& i : m_pClasses)
        {
            if (strcmp(i.second.m_pName, m_ClassName))
            {
                continue;
            }
            if (!m_ClassNameSpace)
            {
                return i.first;
            }
            else if (!strcmp(i.second.m_pNamespace, m_ClassNameSpace))
            {
                return i.first;
            }
        }
        return nullptr;
    }

    static il2cppClass* GetClassByComponent(Component* component, bool is_system_class)
    {
        il2cppClass* m_class = nullptr;
        if (is_system_class)
        {
            Component comp;
            um::ReadMemory(component, &comp);
            um::ReadMemory(comp.m_Component, &m_class);
            return m_class;
        }
        um::ReadMemory(component, &m_class);
        return m_class;
    }
}
```

`IL2CPP_Resolver_External/Unity/Structs/Engine.h`:

```h
#pragma once

struct Quaternion
{
	float x, y, z, w;

	Quaternion() { x = y = z = w = 0.f; }
	Quaternion(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }
};

struct Vector2
{
	float x, y;

	Vector2() { x = y = 0.f; }
	Vector2(float f1, float f2) { x = f1; y = f2; }
};

struct Vector3
{
	float x, y, z;

	Vector3() { x = y = z = 0.f; }
	Vector3(float f1, float f2, float f3) { x = f1; y = f2; z = f3; }
};

struct Vector4
{
	float x, y, z, w;

	Vector4() { x = y = z = w = 0.f; }
	Vector4(float f1, float f2, float f3, float f4) { x = f1; y = f2; z = f3; w = f4; }
};
```

`IL2CPP_Resolver_External/Unity/Structs/System_String.h`:

```h
#pragma once

struct System_String : il2cppObject
{
	int m_iLength;
	wchar_t m_wString[1024];
};
```

`IL2CPP_Resolver_External/Unity/Unity.h`:

```h
#pragma once

#include <functional>
#include <vector>

#include "rw/usermode.h"

// All Unity Classes/Structs
#include "Classes/Classes.h"

// namespace IL2CPP
#include "IL2CPP.h"

enum LoopType
{
    eLOOPTYPE_All,
    eLOOPTYPE_Tagged,
    eLOOPTYPE_UnTagged,
    eLOOPTYPE_Active
};

namespace Unity
{
    inline GameObjectManager GOM;
    inline GameObjectManager* GOM_Ptr;

    static inline void* GameAssembly;
    static inline void* UnityPlayer;

    static bool Initialize()
    {
        GameAssembly = um::GetModuleBase(L"GameAssembly.dll");
        UnityPlayer = um::GetModuleBase(L"UnityPlayer.dll");

        // Initalize Unity GameObjectManager
        // xref E8 ? ? ? ? 48 8B D0 83 FB 05 75 (UnityPlayer.dll)
        uintptr_t addr = um::SignatureScan(L"UnityPlayer.dll", "E8 ? ? ? ? 48 8B D0 83 FB 05 75");
        addr = helper::relativeToAbsolute(addr);
        addr = helper::relativeToAbsolute(addr, 3);

        void* GOM = (void*)(addr);
        um::ReadMemory(GOM, &GOM);

        if (!GOM)
        {
            return false;
        }

        GOM_Ptr = (GameObjectManager*)GOM;
        um::ReadMemory(GOM_Ptr, &GOM);

        // Initialize IL2CPP Classes
        // xref E8 ? ? ? ? 48 8B 48 08 48 2B 08 48 C1 F9 03 48 89 0B 48 8B 00 48 83 C4 20 5B C3 (GameAssembly.dll)
        addr = um::SignatureScan(L"GameAssembly.dll", "E8 ? ? ? ? 48 8B 48 08 48 2B 08 48 C1 F9 03 48 89 0B 48 8B 00 48 83 C4 20 5B C3");
        addr = helper::relativeToAbsolute(addr);
        addr = helper::relativeToAbsolute(addr, 3);

        void* Assemblies = (void*)(addr);

        void* End = nullptr;
        void* Start = nullptr;

        um::ReadMemory(Assemblies, &Start);
        um::ReadMemory((void*)((uintptr_t)Assemblies + 0x8), &End);

        if (!Start || !End)
        {
            return false;
        }

        IL2CPP::AssemblyCount = ((uintptr_t)End - (uintptr_t)Start) / sizeof(void*);

        IL2CPP::AssembilesTable = (void**)malloc(IL2CPP::AssemblyCount * sizeof(void*));

        um::ReadMemory(Start, IL2CPP::AssembilesTable, IL2CPP::AssemblyCount * sizeof(void*));
        
        // xref 48 8B 05 ? ? ? ? 48 83 3C 03 00 75 45 48 8D 35 ? ? ? ? 48 89 74 24 38 48 8B CE (GameAssembly.dll)
        // mov rax,[7FFE238F2278]
        addr = um::SignatureScan(L"GameAssembly.dll", "48 8B 05 ? ? ? ? 48 83 3C 03 00 75 45 48 8D 35 ? ? ? ? 48 89 74 24 38 48 8B CE");
        addr = helper::relativeToAbsolute(addr,3);

        IL2CPP::ClassesTable = (void*)(addr);
        um::ReadMemory(IL2CPP::ClassesTable, &IL2CPP::ClassesTable);
        if (!IL2CPP::ClassesTable)
        {
            return false;
        }

        return true;
    }

    static void RefreshObject()
    {
        um::ReadMemory(GOM_Ptr, &GOM);
    }

    static GameObject* Find(const char* m_Name)
    {
        RefreshObject();

        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        GameObject* lastGameObject = lastTaggedObject.lastObject;

        GameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        char buf0[255];
        um::ReadMemory(gameObject.m_ObjectName, &buf0);
        if (!strcmp(buf0, m_Name))
        {
            return lastGameObject;
        }

        GameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            GameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            char buf[255];
            um::ReadMemory(gameObject.m_ObjectName, &buf);

            if (!strcmp(buf, m_Name))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

    }
    static GameObject* FindGameObjectOfType(const char* m_TypeName)
    {
        // not implement yet...
    }
    static GameObject* TaggedObjectIterator(std::function<GameObject*(void*,GameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        GameObject* lastGameObject = lastTaggedObject.lastObject;

        GameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        GameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            GameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);
            
            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }
            
            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static GameObject* ActiveObjectIterator(std::function<GameObject* (void*, GameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase activeObject;
        um::ReadMemory(GOM.lastActiveObject, &activeObject);

        BaseObject activeObjects;
        um::ReadMemory(GOM.activeObjects, &activeObjects);

        if ((uintptr_t)GOM.activeObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        GameObject* lastGameObject = activeObject.lastObject;

        GameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        GameObject* curGameObject = activeObjects.object;

        BaseObject curBaseObject = activeObjects;

        while (curGameObject != lastGameObject)
        {
            GameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static GameObject* UntaggedObjectIterator(std::function<GameObject* (void*, GameObject)> loop_func)
    {
        RefreshObject();
        LastObjectBase UntaggedObject;
        um::ReadMemory(GOM.lastUntaggedObject, &UntaggedObject);

        BaseObject UntaggedObjects;
        um::ReadMemory(GOM.UntaggedObjects, &UntaggedObjects);

        if ((uintptr_t)GOM.UntaggedObjects == (uintptr_t)GOM_Ptr)
        {
            return nullptr;
        }

        GameObject* lastGameObject = UntaggedObject.lastObject;

        GameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            return lastGameObject;
        }

        GameObject* curGameObject = UntaggedObjects.object;

        BaseObject curBaseObject = UntaggedObjects;

        while (curGameObject != lastGameObject)
        {
            GameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                return curGameObject;
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return nullptr;
    }
    static GameObject* ObjectIterator(std::function<GameObject* (void*, GameObject)> loop_func, LoopType loop_type = eLOOPTYPE_All)
    {
        GameObject* object = nullptr;
        switch (loop_type)
        {
        case eLOOPTYPE_All:
        {
            object = UntaggedObjectIterator(loop_func);
            if (object)
                return object;
            object = TaggedObjectIterator(loop_func);
            if (object)
                return object;
            object = ActiveObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_Tagged:
        {
            object = TaggedObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_UnTagged:
        {
            object = UntaggedObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        case eLOOPTYPE_Active:
        {
            object = ActiveObjectIterator(loop_func);
            if (object)
                return object;
        }
        break;
        default:
            break;
        }
        return nullptr;
    }
    static std::vector<GameObject*> ObjectIteratorVector(std::function<GameObject* (void*, GameObject)> loop_func)
    {
        RefreshObject();
        std::vector<GameObject*> objects;

        LastObjectBase lastTaggedObject;
        um::ReadMemory(GOM.lastTaggedObject, &lastTaggedObject);

        BaseObject TaggedObjects;
        um::ReadMemory(GOM.taggedObjects, &TaggedObjects);

        if ((uintptr_t)GOM.taggedObjects == (uintptr_t)GOM_Ptr)
        {
            return objects;
        }

        GameObject* lastGameObject = lastTaggedObject.lastObject;

        GameObject gameObject;
        um::ReadMemory(lastGameObject, &gameObject);

        if (loop_func(lastGameObject, gameObject))
        {
            objects.push_back(lastGameObject);
        }

        GameObject* curGameObject = TaggedObjects.object;

        BaseObject curBaseObject = TaggedObjects;

        while (curGameObject != lastGameObject)
        {
            GameObject gameObject;
            um::ReadMemory(curBaseObject.object, &gameObject);

            if (loop_func(curGameObject, gameObject))
            {
                objects.push_back(curGameObject);
            }

            um::ReadMemory(curBaseObject.nextObjectLink, &curBaseObject);
            curGameObject = curBaseObject.object;
        }

        return objects;
    }
    static Transform* GetTransform(GameObject* object)
    {
        GameObject gameObject;
        um::ReadMemory(object, &gameObject);

        void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));
        
        if (!buffer)
        {
            return nullptr;
        }

        um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));

        ComponentList* list = (ComponentList*)buffer;

        Component component;
        um::ReadMemory(list[0].m_Component, &component);

        free(buffer);

        return component.m_Transform;
    }
    /*
        System Class has differen Offset, make sure which component you are touching.
    */
    static Component* GetComponentByIndex(GameObject* object, int index, bool system_class = false)
    {
        GameObject gameObject;
        um::ReadMemory(object, &gameObject);

        void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));
        um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));

        
        ComponentList* list = (ComponentList*)buffer;
         
        Component component;
        if (system_class)
        {
            Component* com = list[index].m_Component;
            free(buffer);
            return com;
        }
        else
        {
            um::ReadMemory(list[index].m_Component, &component);
        }
        free(buffer);

        return component.m_Component;
    }
    /*
        This is not finished yet, if you use it, you need to know the Component if its Unity System Class.
    */
    static Component* ComponentIterator(GameObject* object, std::function<Component*(void*)> loop_func)
    {
        GameObject gameObject;
        um::ReadMemory(object, &gameObject);

        void* buffer = malloc(gameObject.m_iComponents * sizeof(ComponentList));
        um::ReadMemory((void*)((uintptr_t)gameObject.m_ComponentList + 8), buffer, gameObject.m_iComponents * sizeof(ComponentList));

        for (int i = 0; i < gameObject.m_iComponents; i++)
        {
            ComponentList* list = (ComponentList*)buffer;

            Component component;
            um::ReadMemory(list[i].m_Component, &component);

            if (loop_func(component.m_Component))
            {
                free(buffer);
                return component.m_Component;
            }

        }
        free(buffer);
        return nullptr;
    }
    static Vector3 GetPosition(GameObject* object)
    {
        GameObject gameObject;
        um::ReadMemory(object, &gameObject);

        Transform* trans = GetTransform(object);

        Transform transform;

        um::ReadMemory(trans, &transform);

        return transform.m_Position;
    }
    static void SetPosition(GameObject* object, Vector3 pos)
    {
        GameObject gameObject;
        um::ReadMemory(object, &gameObject);

        Transform* trans = GetTransform(object);
        um::WriteMemory((void*)((uintptr_t)trans + offsetof(Transform, m_Position)), &pos);
        
        // Note: The Game maybe has some Physics system that is always writing to y axis, you need find the way to disable it yourself.
    }
}

```

`IL2CPP_Resolver_External/Unity/rw/usermode.h`:

```h
#pragma once
#include <Windows.h>
#include <TlHelp32.h>

namespace um
{
	inline HANDLE hProcess;
	inline DWORD pid;

	static bool Init(HWND hwnd)
	{
		GetWindowThreadProcessId(hwnd, &pid);
		if (!pid)
		{
			return false;
		}
		hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
		if (!hProcess)
		{
			return false;
		}

		return true;
	}

	template<typename T>
	static NTSTATUS ReadMemory(void* TargetAddress, T* Buffer)
	{
		return ReadProcessMemory(hProcess, TargetAddress, Buffer, sizeof(T), 0) == false;
	}
	static NTSTATUS ReadMemory(void* TargetAddress, void* Buffer, DWORD size)
	{
		return ReadProcessMemory(hProcess, TargetAddress, Buffer, size, 0) == false;
	}
	template<typename T>
	static NTSTATUS WriteMemory(void* TargetAddress, T* Buffer)
	{
		return WriteProcessMemory(hProcess, TargetAddress, Buffer, sizeof(T), 0) == false;
	}
	static void* GetModuleBase(const wchar_t* pName)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
		void* dwModuleBaseAddress = 0;
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			MODULEENTRY32 ModuleEntry32 = { 0 };
			ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
			if (Module32First(hSnapshot, &ModuleEntry32))
			{
				do
				{
					if (wcscmp(ModuleEntry32.szModule, pName) == 0)
					{
						dwModuleBaseAddress = ModuleEntry32.modBaseAddr;
						break;
					}
				} while (Module32Next(hSnapshot, &ModuleEntry32));
			}
			CloseHandle(hSnapshot);
		}
		return dwModuleBaseAddress;
	}
	static size_t GetModuleSize(const wchar_t* pName)
	{
		HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
		size_t szModuleSize = 0;
		if (hSnapshot != INVALID_HANDLE_VALUE)
		{
			MODULEENTRY32 ModuleEntry32 = { 0 };
			ModuleEntry32.dwSize = sizeof(MODULEENTRY32);
			if (Module32First(hSnapshot, &ModuleEntry32))
			{
				do
				{
					if (wcscmp(ModuleEntry32.szModule, pName) == 0)
					{
						szModuleSize = ModuleEntry32.modBaseSize;
						break;
					}
				} while (Module32Next(hSnapshot, &ModuleEntry32));
			}
			CloseHandle(hSnapshot);
		}
		return szModuleSize;
	}
	static uintptr_t SignatureScan(uintptr_t start, unsigned long long size, const char* sig)
	{
		unsigned char* data = (unsigned char*)VirtualAlloc(0x0, size, MEM_COMMIT, PAGE_READWRITE);
		if (!data)
			return 0;

		ReadMemory((void*)start, data, size);

		static auto pattern_to_byte = [](const char* pattern) {
			auto bytes = std::vector<int>{};
			auto start = const_cast<char*>(pattern);
			auto end = const_cast<char*>(pattern) + strlen(pattern);

			for (auto current = start; current < end; ++current) {
				if (*current == '?') {
					++current;
					if (*current == '?')
						++current;
					bytes.push_back(-1);
				}
				else {
					bytes.push_back(strtoul(current, &current, 16));
				}
			}
			return bytes;
		};

		auto patternBytes = pattern_to_byte(sig);
		auto scanBytes = reinterpret_cast<unsigned char*>(data);

		auto s = patternBytes.size();
		auto d = patternBytes.data();

		for (auto i = 0ul; i < size - s; ++i) {
			bool found = true;
			for (auto j = 0ul; j < s; ++j) {
				if (scanBytes[i + j] != d[j] && d[j] != -1) {
					found = false;
					break;
				}
			}
			if (found) {
				VirtualFree(data, size, MEM_DECOMMIT);
				return start + i;
			}
		}

		VirtualFree(data, size, MEM_DECOMMIT);
		return 0;
	}
	static uintptr_t SignatureScan(const wchar_t* ModuleName, const char* sig)
	{
		return SignatureScan((uintptr_t)GetModuleBase(ModuleName), GetModuleSize(ModuleName), sig);
	}
}


namespace helper
{
	static uintptr_t relativeToAbsolute(uintptr_t address, int offset_to_delta = 1)
	{
		if (!address)
			return 0;
		int delta;
		um::ReadMemory((void*)(address + offset_to_delta), &delta);

		return (uintptr_t)(address + offset_to_delta + 4 + delta);
	}
}
```

`README.md`:

```md
## IL2CPP Resolver External
A run-time API resolver for IL2CPP Unity in External.

(Internal version)[https://github.com/sneakyevilSK/IL2CPP_Resolver]

### Note
i have provided basic memory r/w and helper functions in Unity/rw/usermode.h.

if you are using for kernel project, you need replace with your own one.

# Initialize
see [Example](https://github.com/extremeblackliu/IL2CPP_Resolver_External/edit/master/IL2CPP_Resolver_External/IL2CPP_Resolver_External.cpp);

if you have more unity different version struct or code improve, pull request!

# Quick Examples

```cpp
GameObject* GetLocalPlayer()
{
    GameObject* Player = Unity::ObjectIterator(
        [](void* ptr, GameObject object) -> GameObject* {

            char buf[255];
            um::ReadMemory(object.m_ObjectName, &buf);
            if (buf[10] == 'L') // L - Local , R - Remote
            {
                return (GameObject*)ptr;
            }
            return nullptr;
        }
    );
    return Player;
}

void Hack()
{
    // example manipulate of rigidbody.isKinematic
    GameObject* Player = GetLocalPlayer();
    
    Component* Component = Unity::GetComponentByIndex(Player, 1, true);
    if(!Component)
       return;
    
    Rigidbody rigidbody;
    um::ReadMemory(Component, &rigidbody);
    
    rigidbody.isKinematic = false;
    
    um::WriteMemory(Component, &rigidbody);
}
```

Position Get/Set:
```cpp
// Teleport to self
void Teleport()
{
    GameObject* Player = GetLocalPlayer();
    
    Vector3 position = Unity::GetPosition(Player);
   
    Unity::SetPosition(Player, position); 
}

```

loop through different type(Active,Tagged,UnTagged) of GameObjects in ALL Scenes:
```cpp
// ObjectIterator lambda: return nullptr to make continue loop.
Unity::ObjectIterator(
    [](void* ptr, GameObject object) -> GameObject* {
        return nullptr;
}, eLOOPTYPE_UnTagged // eLOOPTYPE_Active | eLOOPTYPE_Tagged | eLOOPTYPE_UnTagged
);
```

find the class we want, and use it for find the component
```cpp
// Example of VRChat
namespace GlobalVar // put it on some globalvar, cache it
{
    il2cppClass* VRCPickup;
}

void CacheClasses()
{
    std::vector<std::pair<il2cppClass*, il2cppClass>> Classes;
    IL2CPP::FetchClasses(&Classes, "VRCSDK3");  // in other game, game classes are mostly in Assembly-CSharp.dll

    GlobalVar::VRCPickup = IL2CPP::FilterClass(Classes, "VRCPickup", "VRC.SDK3.Components");
}

void Hack()
{
    Unity::ObjectIterator(
            [](void* ptr, GameObject object) -> GameObject* {
               
            // the loop is manually, see TODO #1
                    
            void* buffer = malloc(object.m_iComponents * sizeof(ComponentList));
            um::ReadMemory((void*)((uintptr_t)object.m_ComponentList + 8), buffer, object.m_iComponents * sizeof(ComponentList));
            if (!buffer)
            {
                return nullptr;
            }

            for (int i = 0; i < object.m_iComponents; i++)
            {
                ComponentList* list = (ComponentList*)buffer;

                Component component;
                um::ReadMemory(list[i].m_Component, &component);

                il2cppClass* klass = IL2CPP::GetClassByComponent(component.m_Component, false);

                if (klass == Cache::VRCPickup) // we compare the il2cppClass Pointer, it will be same
                {
                    bool DisallowTheft = false;
                    um::WriteMemory((void*)((uintptr_t)component.m_Component + 0x1C), &DisallowTheft); // use component.m_Component because its game class
                    // or do something to component...
                    break;
                }
            }
            free(buffer);


            return nullptr;
        }, eLOOPTYPE_UnTagged
    );
}
```

### WARNING
* This is still working-in-progress.
* Basic struct maybe DIFFERENT between DIFFERENT Unity Engine version.(Change in [Classes.h](https://github.com/extremeblackliu/IL2CPP_Resolver_External/blob/master/IL2CPP_Resolver_External/Unity/Classes/Classes.h))

### Requirements
* C++ 17 or greater

### TODO
* Auto-Detect System Class and Game Class for component looping
* More Unity Version Support
* More Methods
* Fetch Method from Module by giving Method's Name

### Tested on
* VRChat[Unity 2019.4]

```