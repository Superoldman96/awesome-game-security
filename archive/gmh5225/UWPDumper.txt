Project Path: arc_gmh5225_UWPDumper_8y4nxq53

Source Tree:

```txt
arc_gmh5225_UWPDumper_8y4nxq53
├── LICENSE
├── README.md
├── UWPDumper
│   ├── UWPDumper.vcxproj
│   ├── UWPDumper.vcxproj.filters
│   ├── include
│   │   └── UWP
│   │       ├── DumperIPC.hpp
│   │       └── UWP.hpp
│   ├── main.cpp
│   └── source
│       └── UWP
│           ├── DumperIPC.cpp
│           └── UWP.cpp
├── UWPDumper.sln
├── UWPInjector
│   ├── UWPInjector.vcxproj
│   ├── UWPInjector.vcxproj.filters
│   └── source
│       └── main.cpp
└── media
    ├── demo1.gif
    └── demo2.gif

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Wunkolo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# UWPDumper [![Build status](https://ci.appveyor.com/api/projects/status/ys3yvpv0bdel15sx?svg=true)](https://ci.appveyor.com/project/Wunkolo/uwpdumper) [![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/Wunkolo/UWPDumper/master/LICENSE)
## [Download latest binary here!](https://github.com/Wunkolo/UWPDumper/releases/)

---
DLL and Injector for dumping UWP applications at run-time to bypass encrypted file system protection.

![Demo1](media/demo1.gif)

![Demo2](media/demo2.gif)


Run `UWPInjector.exe` and enter valid UWP Process ID to inject into.
App file system will be dumped into:

`C:\Users\(Username)\AppData\Local\Packages\(Package Family Name)\TempState\DUMP`

To get a list of command line arguments run the command

`UWPInjector.exe -h`

UWPDumper requires the [Windows 10 SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk) to be compiled.

```

`UWPDumper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29215.179
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UWPDumper", "UWPDumper\UWPDumper.vcxproj", "{169F3E39-2CC2-4136-AD6A-23EA935AE150}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UWPInjector", "UWPInjector\UWPInjector.vcxproj", "{7B3AF0F2-1ADD-4145-B91F-328829797CEE}"
	ProjectSection(ProjectDependencies) = postProject
		{169F3E39-2CC2-4136-AD6A-23EA935AE150} = {169F3E39-2CC2-4136-AD6A-23EA935AE150}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Debug|x64.ActiveCfg = Debug|x64
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Debug|x64.Build.0 = Debug|x64
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Debug|x86.ActiveCfg = Debug|Win32
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Debug|x86.Build.0 = Debug|Win32
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Release|x64.ActiveCfg = Release|x64
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Release|x64.Build.0 = Release|x64
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Release|x86.ActiveCfg = Release|Win32
		{169F3E39-2CC2-4136-AD6A-23EA935AE150}.Release|x86.Build.0 = Release|Win32
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Debug|x64.ActiveCfg = Debug|x64
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Debug|x64.Build.0 = Debug|x64
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Debug|x86.ActiveCfg = Debug|Win32
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Debug|x86.Build.0 = Debug|Win32
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Release|x64.ActiveCfg = Release|x64
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Release|x64.Build.0 = Release|x64
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Release|x86.ActiveCfg = Release|Win32
		{7B3AF0F2-1ADD-4145-B91F-328829797CEE}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1FA5234E-E9F8-4E87-A03C-DA17B6288C27}
	EndGlobalSection
EndGlobal

```

`UWPDumper/UWPDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{169F3E39-2CC2-4136-AD6A-23EA935AE150}</ProjectGuid>
    <RootNamespace>UWPDumper</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>IPC_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <AdditionalDependencies>runtimeobject.lib;Shell32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>IPC_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <AdditionalDependencies>runtimeobject.lib;Shell32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>IPC_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>runtimeobject.lib;Shell32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>IPC_EXPORT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>runtimeobject.lib;Shell32.lib</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="source\UWP\DumperIPC.cpp">
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdcpp17</LanguageStandard>
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdcpp17</LanguageStandard>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <LanguageStandard Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdcpp17</LanguageStandard>
    </ClCompile>
    <ClCompile Include="source\UWP\UWP.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\UWP\DumperIPC.hpp" />
    <ClInclude Include="include\UWP\UWP.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UWPDumper/UWPDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="source\UWP\UWP.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="source\UWP\DumperIPC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include\UWP\UWP.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="include\UWP\DumperIPC.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`UWPDumper/include/UWP/DumperIPC.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstddef>
#include <string>

#ifdef IPC_EXPORT
#define IPC_API __declspec(dllexport)
#else
#define IPC_API __declspec(dllimport)
#endif

/// Exports
namespace IPC
{

struct MessageEntry
{
	MessageEntry() = default;
	explicit MessageEntry(const wchar_t* String);

	static constexpr std::size_t StringSize = 1024;
	wchar_t String[StringSize] = { 0 };
};

IPC_API void SetClientProcess(std::uint32_t ProcessID);
IPC_API std::uint32_t GetClientProcess();
IPC_API void SetTargetProcess(std::uint32_t ProcessID);
IPC_API std::uint32_t GetTargetProcess();

constexpr std::int32_t InvalidThread = -1;

IPC_API void SetTargetThread(std::int32_t ThreadID);
IPC_API std::int32_t GetTargetThread();
IPC_API void ClearTargetThread();

// String messaging
IPC_API void PushMessage(const wchar_t* Format, ...);
IPC_API bool PopMessage(std::wstring& Output);
IPC_API std::size_t MessageCount();
}
```

`UWPDumper/include/UWP/UWP.hpp`:

```hpp
#pragma once
#include <string>

// UWP Helper class
namespace UWP
{
namespace Current
{
std::wstring GetFamilyName();

std::wstring GetFullName();

std::wstring GetArchitecture();

std::wstring GetPublisher();

std::wstring GetPublisherID();

std::wstring GetPackagePath();

namespace Storage
{
/*
Apps from the same publisher may share files using the Publisher folder located at:
"%user_folder%\AppData\Local\Publishers\%PublisherID%\"
*/
std::wstring GetPublisherPath();

// Package Storage folders
std::wstring GetStoragePath();

std::wstring GetLocalPath();

std::wstring GetRoamingPath();

std::wstring GetTemporaryPath();
}
}
}

```

`UWPDumper/main.cpp`:

```cpp
#include <cstddef>
#include <cstddef>
#include <fstream>
#include <iomanip>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <ShlObj.h>

#include <windows.storage.h>
#include <windows.system.h>
#include <wrl.h>

#define WIDEIFYIMP(x) L##x
#define WIDEIFY(x) WIDEIFYIMP(x)

#include <queue>

#include <filesystem>
namespace fs = std::filesystem;

#include <UWP/UWP.hpp>

#include <UWP/DumperIPC.hpp>

void OpenTempState()
{
	Microsoft::WRL::ComPtr<ABI::Windows::Storage::IApplicationDataStatics> AppDataStatics;

	if(
		RoGetActivationFactory(
			Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_Storage_ApplicationData).Get(),
			__uuidof(AppDataStatics), &AppDataStatics
		) < 0
	)
	{
		// Error getting ApplicationData statics
	}

	Microsoft::WRL::ComPtr<ABI::Windows::Storage::IApplicationData> AppData;
	if( AppDataStatics->get_Current(&AppData) < 0 )
	{
		// Error getting current IApplicationData
	}

	Microsoft::WRL::ComPtr<ABI::Windows::System::ILauncherStatics3> LauncherStatics;
	if(
		RoGetActivationFactory(
			Microsoft::WRL::Wrappers::HStringReference(RuntimeClass_Windows_System_Launcher).Get(),
			__uuidof(LauncherStatics), &LauncherStatics
		) < 0
	)
	{
		// Error getting Launcher statics
	}

	Microsoft::WRL::ComPtr<ABI::Windows::Storage::IStorageFolder> TemporaryFolder;

	if( AppData->get_TemporaryFolder(&TemporaryFolder) < 0 )
	{
		// Failed to get folder
		return;
	}

	Microsoft::WRL::ComPtr<ABI::Windows::Foundation::IAsyncOperation<bool>> Result;
	LauncherStatics->LaunchFolderAsync(
		TemporaryFolder.Get(),
		&Result
	);
}

std::uint32_t __stdcall DumperThread(void* DLLHandle)
{
	std::wstring DumpPath = fs::path(UWP::Current::Storage::GetTemporaryPath()) / L"DUMP";

	IPC::SetTargetThread(GetCurrentThreadId());

	IPC::PushMessage(L"UWPDumper Build date(%ls : %ls)\n", WIDEIFY(__DATE__), WIDEIFY(__TIME__));
	IPC::PushMessage(L"\t-https://github.com/Wunkolo/UWPDumper\n");
	IPC::PushMessage(L"Publisher:\n\t%s\n", UWP::Current::GetPublisher().c_str());
	IPC::PushMessage(L"Publisher ID:\n\t%s\n", UWP::Current::GetPublisherID().c_str());
	IPC::PushMessage(L"Publisher Path:\n\t%s\n", UWP::Current::Storage::GetPublisherPath().c_str());
	IPC::PushMessage(L"Package Path:\n\t%s\n", UWP::Current::GetPackagePath().c_str());
	IPC::PushMessage(L"Package Name:\n\t%s\n", UWP::Current::GetFullName().c_str());
	IPC::PushMessage(L"Family Name:\n\t%s\n", UWP::Current::GetFamilyName().c_str());

	IPC::PushMessage(L"Dump Path:\n\t%s\n", DumpPath.c_str());

	std::vector<fs::directory_entry> FileList;

	for( auto& Entry : fs::recursive_directory_iterator(UWP::Current::GetPackagePath()) )
	{
		if( fs::is_regular_file(Entry.path()) )
		{
			FileList.push_back(Entry);
		}
	}

	IPC::PushMessage(L"\tDumping %zu files\n", FileList.size());

	std::size_t i = 0;
	for( const auto& File : FileList )
	{
		try
		{

			const fs::path WritePath = DumpPath + File.path().wstring().substr(UWP::Current::GetPackagePath().length());
			const std::wstring ReadPath = File.path().wstring();
			IPC::PushMessage(
				L"%*.*s %*.u bytes %*zu/%zu\n",
				60, 60,
				ReadPath.c_str() + (ReadPath.length() > 60 ? (ReadPath.length() - (60)) : 0),
				15,
				fs::file_size(File),
				20,
				++i,
				FileList.size()
			);

			std::error_code ErrorCode;
			if( fs::create_directories(WritePath.parent_path(), ErrorCode) == false && ErrorCode )
			{
				const std::string ErrorMessage(ErrorCode.message());
				std::wstring WErrorMessage;
				WErrorMessage.assign(ErrorMessage.begin(), ErrorMessage.end());
				IPC::PushMessage(
					L"Error creating subfolder: %s\n\t%s\n",
					WritePath.parent_path().c_str(),
					WErrorMessage.c_str()
				);
				continue;
			}

			std::ifstream SourceFile(ReadPath, std::ios::binary);
			if( !SourceFile.is_open() )
			{
				IPC::PushMessage(
					L"Error opening %s for reading\n",
					ReadPath.c_str()
				);
				continue;
			}

			std::ofstream DestFile(WritePath, std::ios::binary);
			if( !DestFile.is_open() )
			{
				IPC::PushMessage(
					L"Error opening %s for writing\n",
					WritePath.c_str()
				);
				continue;
			}

			if( SourceFile && DestFile )
			{
				DestFile << SourceFile.rdbuf();
			}
			else
			{
				IPC::PushMessage(
					L"Error copying file data:\n"
					"\t%s\n"
					"\tto\n"
					"\t%s\n",
					File.path().c_str(),
					WritePath.c_str()
				);
			}
		}
		catch( std::exception& Exception )
		{
			//std::wstring ExceptionMessage = std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t>{}.from_bytes( Exception.what() );

			IPC::PushMessage(
				L"Exception {%s}:\n"
				"\t[%s]\n",
				File.path().c_str(),
				Exception.what()
			);
		}
	}

	IPC::PushMessage(L"Dump complete!\n\tPath:\n\t%s\n", DumpPath.c_str());
	IPC::ClearTargetThread();

	FreeLibraryAndExitThread(
		reinterpret_cast<HMODULE>(DLLHandle),
		EXIT_SUCCESS
	);
}

std::int32_t __stdcall DllMain(HINSTANCE hDLL, std::uint32_t Reason, void* Reserved)
{
	switch( Reason )
	{
	case DLL_PROCESS_ATTACH:
	{
		IPC::PushMessage(L"DLL Attached to process %u\n", GetCurrentProcessId());
		if( IPC::GetTargetProcess() == GetCurrentProcessId() )
		{
			IPC::PushMessage(L"Creating dumper thread%u\n");
			CreateThread(
				nullptr,
				0,
				reinterpret_cast<unsigned long(__stdcall*)(void*)>(&DumperThread),
				hDLL,
				0,
				nullptr
			);
		}
	}
	case DLL_PROCESS_DETACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	default:
	{
		return true;
	}
	}

	return false;
}

```

`UWPDumper/source/UWP/DumperIPC.cpp`:

```cpp
#include <UWP/DumperIPC.hpp>

#include <array>
#include <atomic>
#include <thread>
#include <cstdarg>

/// API
namespace IPC
{
/// IPC Message Queue
MessageEntry::MessageEntry(const wchar_t* String)
{
	wcscpy_s(this->String, MessageEntry::StringSize, String);
}

template< typename QueueType, std::size_t PoolSize >
class AtomicQueue
{
public:
	using Type = QueueType;
	static constexpr std::size_t MaxSize = PoolSize;

	AtomicQueue()
		:
		Head(0),
		Tail(0)
	{ }

	~AtomicQueue()
	{ }

	void Enqueue(const Type& Entry)
	{
		while( Mutex.test_and_set(std::memory_order_acquire) )
		{
			std::this_thread::yield();
		}
		Entries[Tail] = Entry;
		Tail = (Tail + 1) % MaxSize;
		Mutex.clear(std::memory_order_release);
	}

	Type Dequeue()
	{
		while( Mutex.test_and_set(std::memory_order_acquire) )
		{
			std::this_thread::yield();
		}
		Type Temp = Entries[Head];
		Head = (Head + 1) % MaxSize;
		Mutex.clear(std::memory_order_release);
		return Temp;
	}

	std::size_t Size()
	{
		while( Mutex.test_and_set(std::memory_order_acquire) )
		{
			std::this_thread::yield();
		}
		Mutex.clear(std::memory_order_release);
		const std::size_t Result = Tail - Head;
		return Result;
	}

	bool Empty()
	{
		return Size() == 0;
	}

private:
	std::array<Type, MaxSize> Entries = {
		Type()
	};
	std::size_t Head = 0;
	std::size_t Tail = 0;
	std::atomic_flag Mutex = ATOMIC_FLAG_INIT;
};

////// Shared IPC Region //////////////////////////////////////////////////////
#pragma data_seg("SHARED")
AtomicQueue<MessageEntry, 1024> MessagePool = {};
std::atomic<std::size_t> CurMessageCount = 0;

// The process we are sending our data to
std::atomic<std::uint32_t> ClientProcess(0);

// The target UWP process we wish to dump
std::atomic<std::uint32_t> TargetProcess(0);

std::atomic<std::int32_t> TargetThread(InvalidThread);

#pragma data_seg()
#pragma comment(linker, "/section:SHARED,RWS")
///////////////////////////////////////////////////////////////////////////////

void SetClientProcess(std::uint32_t ProcessID)
{
	ClientProcess = ProcessID;
}

std::uint32_t GetClientProcess()
{
	return ClientProcess;
}

void SetTargetProcess(std::uint32_t ProcessID)
{
	TargetProcess = ProcessID;
}

std::uint32_t GetTargetProcess()
{
	return TargetProcess;
}

IPC_API void SetTargetThread(std::int32_t ThreadID)
{
	TargetThread = ThreadID;
}

IPC_API std::int32_t GetTargetThread()
{
	return TargetThread;
}

IPC_API void ClearTargetThread()
{
	TargetThread = InvalidThread;
}

void PushMessage(const wchar_t* Format, ...)
{
	std::va_list Args;
	MessageEntry Entry;

	va_start(Args, Format);
	vswprintf_s(
		Entry.String, Entry.StringSize,
		Format, Args
	);
	va_end(Args);

	MessagePool.Enqueue(Entry);
}

bool PopMessage(std::wstring& Output)
{
	if( MessageCount() )
	{
		const MessageEntry Entry = MessagePool.Dequeue();
		Output.assign(Entry.String, wcslen(Entry.String));
		return true;
	}
	return false;
}

std::size_t MessageCount()
{
	return MessagePool.Size();
}
}

```

`UWPDumper/source/UWP/UWP.cpp`:

```cpp
#include <UWP/UWP.hpp>

#include <Windows.h>
#include <ShlObj.h>
#include <appmodel.h>
#include <AppxPackaging.h>

#include <windows.storage.h>
#include <Windows.ApplicationModel.h>
#include <wrl.h>

using namespace Microsoft::WRL;
using namespace Microsoft::WRL::Wrappers;

#include <memory>

namespace
{
ComPtr<ABI::Windows::Storage::IApplicationData> GetIApplicationData()
{
	ComPtr<ABI::Windows::Storage::IApplicationDataStatics> AppDataStatics;

	if(
		RoGetActivationFactory(
			HStringReference(RuntimeClass_Windows_Storage_ApplicationData).Get(),
			__uuidof(AppDataStatics), &AppDataStatics
		) < 0
	)
	{
		// Error getting ApplicationData statics
	}

	ComPtr<ABI::Windows::Storage::IApplicationData> AppData;
	if( AppDataStatics->get_Current(&AppData) < 0 )
	{
		// Error getting current IApplicationData
	}

	return AppData;
}

ComPtr<ABI::Windows::ApplicationModel::IPackage> GetCurrentPackage()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackageStatics> PackageStatics;
	if(
		RoGetActivationFactory(
			HStringReference(RuntimeClass_Windows_ApplicationModel_Package).Get(),
			__uuidof(PackageStatics), &PackageStatics
		) < 0
	)
	{
		// Error getting package statics
		return nullptr;
	}

	ComPtr<ABI::Windows::ApplicationModel::IPackage> CurrentPackage;
	if( PackageStatics->get_Current(&CurrentPackage) )
	{
		// Error getting current package
	}

	return CurrentPackage;
}

ComPtr<ABI::Windows::ApplicationModel::IPackageId> GetCurrentPackageID()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackage> CurrentPackage =
		GetCurrentPackage();

	ComPtr<ABI::Windows::ApplicationModel::IPackageId> CurrentPackageID;
	if( CurrentPackage->get_Id(&CurrentPackageID) < 0 )
	{
		// error getting current package ID
		return nullptr;
	}
	return CurrentPackageID;
}

template< typename T >
void FreeDeleter(T* Data)
{
	free(Data);
}

std::unique_ptr<PACKAGE_ID, decltype(&FreeDeleter<PACKAGE_ID>)> GetPackageIdentifier()
{
	std::uint32_t Size = 0;
	GetCurrentPackageId(&Size, nullptr);

	if( Size )
	{
		std::unique_ptr<PACKAGE_ID, decltype(&FreeDeleter<PACKAGE_ID>)> PackageID(
			reinterpret_cast<PACKAGE_ID*>(malloc(Size)),
			FreeDeleter<PACKAGE_ID>
		);
		GetCurrentPackageId(
			&Size,
			reinterpret_cast<std::uint8_t*>(PackageID.get())
		);
		return PackageID;
	}
	return std::unique_ptr<PACKAGE_ID, decltype(&FreeDeleter<PACKAGE_ID>)>(
		nullptr,
		FreeDeleter<PACKAGE_ID>
	);
}

std::unique_ptr<PACKAGE_INFO, decltype(&FreeDeleter<PACKAGE_INFO>)> GetPackageInfo()
{
	std::uint32_t Size = 0;
	std::uint32_t Count = 0;
	GetCurrentPackageInfo(PACKAGE_FILTER_HEAD, &Size, nullptr, &Count);

	if( Size )
	{
		std::unique_ptr<PACKAGE_INFO, decltype(&FreeDeleter<PACKAGE_INFO>)> PackageInfo(
			reinterpret_cast<PACKAGE_INFO*>(malloc(Size)),
			FreeDeleter<PACKAGE_INFO>
		);

		GetCurrentPackageInfo(
			PACKAGE_FILTER_HEAD,
			&Size,
			reinterpret_cast<std::uint8_t*>(PackageInfo.get()),
			&Count
		);
		return PackageInfo;
	}

	return std::unique_ptr<PACKAGE_INFO, decltype(&FreeDeleter<PACKAGE_INFO>)>(
		nullptr,
		FreeDeleter<PACKAGE_INFO>
	);
}
}

std::wstring UWP::Current::GetFamilyName()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackageId> PackageID = GetCurrentPackageID();

	HString FamilyNameString;

	if( PackageID->get_FamilyName(FamilyNameString.GetAddressOf()) < 0 )
	{
		// Failed to get string
		return L"";
	}

	std::uint32_t StringLength;
	const wchar_t* FamilyNameRaw = FamilyNameString.GetRawBuffer(&StringLength);
	return std::wstring(FamilyNameRaw, StringLength);
}

std::wstring UWP::Current::GetFullName()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackageId> PackageID = GetCurrentPackageID();

	HString FullNameString;

	if( PackageID->get_FullName(FullNameString.GetAddressOf()) < 0 )
	{
		// Failed to get string
		return L"";
	}

	std::uint32_t StringLength;
	const wchar_t* FullNameRaw = FullNameString.GetRawBuffer(&StringLength);
	return std::wstring(FullNameRaw, StringLength);
}

std::wstring UWP::Current::GetArchitecture()
{
	const auto PackageID = GetCurrentPackageID();
	if( PackageID )
	{
		ABI::Windows::System::ProcessorArchitecture Arch;
		PackageID->get_Architecture(&Arch);
		switch( Arch )
		{
		case ABI::Windows::System::ProcessorArchitecture::ProcessorArchitecture_Arm:
		{
			return L"ARM";
		}
		case ABI::Windows::System::ProcessorArchitecture::ProcessorArchitecture_X86:
		{
			return L"x86";
		}
		case ABI::Windows::System::ProcessorArchitecture::ProcessorArchitecture_X64:
		{
			return L"x64";
		}
		case ABI::Windows::System::ProcessorArchitecture::ProcessorArchitecture_Neutral:
		{
			return L"Neutral";
		}
		}
	}
	return L"Unknown";
}

std::wstring UWP::Current::GetPublisher()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackageId> PackageID = GetCurrentPackageID();

	HString PublisherString;

	if( PackageID->get_Publisher(PublisherString.GetAddressOf()) < 0 )
	{
		// Failed to get string
		return L"";
	}

	std::uint32_t StringLength;
	const wchar_t* PublisherRaw = PublisherString.GetRawBuffer(&StringLength);
	return std::wstring(PublisherRaw, StringLength);
}

std::wstring UWP::Current::GetPublisherID()
{
	ComPtr<ABI::Windows::ApplicationModel::IPackageId> PackageID = GetCurrentPackageID();

	HString PublisherID;

	if( PackageID->get_PublisherId(PublisherID.GetAddressOf()) < 0 )
	{
		// Failed to get string
		return L"";
	}

	std::uint32_t StringLength;
	const wchar_t* PublisherIDRaw = PublisherID.GetRawBuffer(&StringLength);
	return std::wstring(PublisherIDRaw, StringLength);
}

std::wstring UWP::Current::GetPackagePath()
{
	auto Package = GetCurrentPackage();

	ComPtr<ABI::Windows::Storage::IStorageFolder> InstallLocationFolder;

	if( Package->get_InstalledLocation(&InstallLocationFolder) < 0 )
	{
		// Failed to get folder
		return L"";
	}

	ComPtr<ABI::Windows::Storage::IStorageItem> FolderItem;
	if( InstallLocationFolder.As(&FolderItem) < 0 )
	{
		// Failed to cast to IStorageItem
		return L"";
	}

	HString PackagePathString;

	if( FolderItem->get_Path(PackagePathString.GetAddressOf()) < 0 )
	{
		// Failed to get path as string
		return L"";
	}

	std::uint32_t PathLength;
	const wchar_t* PackagePathRaw = PackagePathString.GetRawBuffer(&PathLength);
	return std::wstring(PackagePathRaw, PathLength);
}

std::wstring UWP::Current::Storage::GetPublisherPath()
{
	wchar_t UserPath[MAX_PATH] = {
		0
	};
	SHGetFolderPathW(nullptr, CSIDL_PROFILE, nullptr, SHGFP_TYPE_CURRENT, UserPath);

	std::wstring PublisherPath(UserPath);

	PublisherPath += L"\\AppData\\Local\\Publishers\\";
	PublisherPath += GetPublisherID();

	return PublisherPath;
}

std::wstring UWP::Current::Storage::GetStoragePath()
{
	wchar_t UserPath[MAX_PATH] = {
		0
	};
	SHGetFolderPathW(nullptr, CSIDL_PROFILE, nullptr, SHGFP_TYPE_CURRENT, UserPath);

	std::wstring StoragePath(UserPath);

	StoragePath += L"\\AppData\\Local\\Packages\\" + GetFamilyName();

	return StoragePath;
}

std::wstring UWP::Current::Storage::GetLocalPath()
{
	ComPtr<ABI::Windows::Storage::IApplicationData> AppData = GetIApplicationData();

	ComPtr<ABI::Windows::Storage::IStorageFolder> LocalStateFolder;

	if( AppData->get_LocalFolder(&LocalStateFolder) < 0 )
	{
		// Failed to get folder
		return L"";
	}

	ComPtr<ABI::Windows::Storage::IStorageItem> FolderItem;
	if( LocalStateFolder.As(&FolderItem) < 0 )
	{
		// Failed to cast to IStorageItem
		return L"";
	}

	HString LocalPathString;

	if( FolderItem->get_Path(LocalPathString.GetAddressOf()) < 0 )
	{
		// Failed to get path as string
		return L"";
	}

	std::uint32_t PathLength;
	const wchar_t* LocalPathRaw = LocalPathString.GetRawBuffer(&PathLength);
	return std::wstring(LocalPathRaw, PathLength);
}

std::wstring UWP::Current::Storage::GetRoamingPath()
{
	ComPtr<ABI::Windows::Storage::IApplicationData> AppData = GetIApplicationData();

	ComPtr<ABI::Windows::Storage::IStorageFolder> RoamingFolder;

	if( AppData->get_RoamingFolder(&RoamingFolder) < 0 )
	{
		// Failed to get folder
		return L"";
	}

	ComPtr<ABI::Windows::Storage::IStorageItem> FolderItem;
	if( RoamingFolder.As(&FolderItem) < 0 )
	{
		// Failed to cast to IStorageItem
		return L"";
	}

	HString RoamingPathString;

	if( FolderItem->get_Path(RoamingPathString.GetAddressOf()) < 0 )
	{
		// Failed to get path as string
		return L"";
	}

	std::uint32_t PathLength;
	const wchar_t* RoamingPathRaw = RoamingPathString.GetRawBuffer(&PathLength);
	return std::wstring(RoamingPathRaw, PathLength);
}

std::wstring UWP::Current::Storage::GetTemporaryPath()
{
	ComPtr<ABI::Windows::Storage::IApplicationData> AppData = GetIApplicationData();

	ComPtr<ABI::Windows::Storage::IStorageFolder> TemporaryFolder;

	if( AppData->get_TemporaryFolder(&TemporaryFolder) < 0 )
	{
		// Failed to get folder
		return L"";
	}

	ComPtr<ABI::Windows::Storage::IStorageItem> FolderItem;
	if( TemporaryFolder.As(&FolderItem) < 0 )
	{
		// Failed to cast to IStorageItem
		return L"";
	}

	HString TemporaryPathString;

	if( FolderItem->get_Path(TemporaryPathString.GetAddressOf()) < 0 )
	{
		// Failed to get path as string
		return L"";
	}

	std::uint32_t PathLength;
	const wchar_t* TemporyPathRaw = TemporaryPathString.GetRawBuffer(&PathLength);
	return std::wstring(TemporyPathRaw, PathLength);
}

```

`UWPInjector/UWPInjector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7B3AF0F2-1ADD-4145-B91F-328829797CEE}</ProjectGuid>
    <RootNamespace>UWPInjector</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir)UWPDumper\include;$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(OutputPath);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>UWPDumper.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir)UWPDumper\include;$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(OutputPath);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>UWPDumper.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir)UWPDumper\include;$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(OutputPath);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>UWPDumper.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <AdditionalIncludeDirectories>$(SolutionDir)UWPDumper\include;$(ProjectDir)include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(OutputPath);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>UWPDumper.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="source\main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UWPInjector/UWPInjector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="source\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`UWPInjector/source/main.cpp`:

```cpp
#include <iostream>
#include <chrono>
#include <ctime>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <string>
#include <memory>
#include <chrono>
#include <filesystem>

#include <windows.h>
#include <psapi.h> //GetModuleFileNameEx
#include <TlHelp32.h>

// Setting DLL access controls
#include <AccCtrl.h>
#include <Aclapi.h>
#include <Sddl.h>

// UWP
#include <atlbase.h>
#include <appmodel.h>

// IPC
#include <UWP/DumperIPC.hpp>

#define REPARSE_MOUNTPOINT_HEADER_SIZE   8

const wchar_t* DLLFile = L"UWPDumper.dll";

void SetAccessControl(
	const std::wstring& ExecutableName,
	const wchar_t* AccessString
);

bool DLLInjectRemote(uint32_t ProcessID, const std::wstring& DLLpath);

std::wstring GetRunningDirectory();

using ThreadCallback = bool(*)(
	std::uint32_t ThreadID,
	void* Data
	);

typedef struct {
	DWORD ReparseTag;
	DWORD ReparseDataLength;
	WORD Reserved;
	WORD ReparseTargetLength;
	WORD ReparseTargetMaximumLength;
	WORD Reserved1;
	WCHAR ReparseTarget[1];
} REPARSE_MOUNTPOINT_DATA_BUFFER, * PREPARSE_MOUNTPOINT_DATA_BUFFER;

static DWORD CreateJunction(LPCSTR szJunction, LPCSTR szPath)
{
	DWORD LastError = ERROR_SUCCESS;
	std::byte buf[sizeof(REPARSE_MOUNTPOINT_DATA_BUFFER) + MAX_PATH * sizeof(WCHAR)] = {};
	REPARSE_MOUNTPOINT_DATA_BUFFER& ReparseBuffer = (REPARSE_MOUNTPOINT_DATA_BUFFER&)buf;
	char szTarget[MAX_PATH] = "\\??\\";

	strcat_s(szTarget, szPath);
	// strcat_s(szTarget, "\\");

	if( !CreateDirectory(szJunction, nullptr) ) return GetLastError();

	// Obtain SE_RESTORE_NAME privilege (required for opening a directory)
	HANDLE hToken = nullptr;
	TOKEN_PRIVILEGES tp;
	try {
		if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken) ) throw GetLastError();
		if( !LookupPrivilegeValue(nullptr, SE_RESTORE_NAME, &tp.Privileges[0].Luid) )  throw GetLastError();
		tp.PrivilegeCount = 1;
		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
		if( !AdjustTokenPrivileges(hToken, false, &tp, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr) )  throw GetLastError();
	}
	catch( DWORD LastError )
	{
		if( hToken ) CloseHandle(hToken);
		return LastError;
	}
	if( hToken ) CloseHandle(hToken);

	const HANDLE hDir = CreateFile(szJunction, GENERIC_WRITE, 0, nullptr, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, nullptr);
	if( hDir == INVALID_HANDLE_VALUE ) return GetLastError();

	ReparseBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
	int32_t len = MultiByteToWideChar(CP_ACP, 0, szTarget, -1, ReparseBuffer.ReparseTarget, MAX_PATH);
	ReparseBuffer.ReparseTargetMaximumLength = static_cast<WORD>((len--) * sizeof(WCHAR));
	ReparseBuffer.ReparseTargetLength = static_cast<WORD>(len * sizeof(WCHAR));
	ReparseBuffer.ReparseDataLength = ReparseBuffer.ReparseTargetLength + 12;

	DWORD dwRet;
	if( !DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, &ReparseBuffer, ReparseBuffer.ReparseDataLength + REPARSE_MOUNTPOINT_HEADER_SIZE, nullptr, 0, &dwRet, nullptr) )
	{
		LastError = GetLastError();
		CloseHandle(hDir);
		RemoveDirectory(szJunction);
		return LastError;
	}

	CloseHandle(hDir);
	return ERROR_SUCCESS;
}


void IterateThreads(ThreadCallback ThreadProc, std::uint32_t ProcessID, void* Data)
{
	void* hSnapShot = CreateToolhelp32Snapshot(
		TH32CS_SNAPTHREAD,
		ProcessID
	);

	if( hSnapShot == INVALID_HANDLE_VALUE )
	{
		return;
	}

	THREADENTRY32 ThreadEntry = { 0 };
	ThreadEntry.dwSize = sizeof(THREADENTRY32);
	Thread32First(hSnapShot, &ThreadEntry);
	do
	{
		if( ThreadEntry.th32OwnerProcessID == ProcessID )
		{
			const bool Continue = ThreadProc(
				ThreadEntry.th32ThreadID,
				Data
			);
			if( Continue == false )
			{
				break;
			}
		}
	} while( Thread32Next(hSnapShot, &ThreadEntry) );

	CloseHandle(hSnapShot);
}

const char* HelpText =
"To Set PID:\n"
"	  -p {pid}\n"
"EG: -p 1234\n"
"Disable pausing and folder opening(for automation):\n"
"    -c \n"
"To Enable Logging:\n"
"    -l \n"
"To Dump To A Custom Folder:\n"
"    -d {folder} \n"
"EG: -d D:\\uwp\\dumps\\calculator";

int main(int argc, char** argv, char** envp)
{
	std::uint32_t ProcessID = 0;
	std::filesystem::path TargetPath;
	bool Logging = false;
	bool Continuous = false;
	if( argc > 1 )
	{
		for( std::size_t i = 1; i < argc; ++i )
		{
			if( std::string_view(argv[i]) == "-h" )
			{
				std::cout << HelpText << std::endl;
				return 0;
			}
			else if( std::string_view(argv[i]) == "-p" )
			{
				if( i != argc )
				{
					ProcessID = (std::uint32_t)atoi(argv[i + 1]);
				}
				else
				{
					std::cout << "-p must be followed by a pid\n";
					return 0;
				}
			}
			else if( std::string_view(argv[i]) == "-c" )
			{
				Continuous = true;
			}
			else if( std::string_view(argv[i]) == "-l" )
			{
				Logging = true;
			}
			else if( std::string_view(argv[i]) == "-d" )
			{
				if( i != argc )
				{
					TargetPath = argv[i + 1];
				}
				else
				{
					std::cout << "-d must be followed by the custom location\n";
					return 0;
				}
			}
		}
	}
	// Enable VT100
	DWORD ConsoleMode;
	GetConsoleMode(
		GetStdHandle(STD_OUTPUT_HANDLE),
		&ConsoleMode
	);
	SetConsoleMode(
		GetStdHandle(STD_OUTPUT_HANDLE),
		ConsoleMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING
	);
	SetConsoleOutputCP(437);

	std::wcout << "\033[92mUWPInjector Build date (" << __DATE__ << " : " << __TIME__ << ')' << std::endl;
	std::wcout << "\033[96m\t\033(0m\033(Bhttps://github.com/Wunkolo/UWPDumper\n";
	std::wcout << "\033[95m\033(0" << std::wstring(80, 'q') << "\033(B" << std::endl;

	IPC::SetClientProcess(GetCurrentProcessId());

	if( ProcessID == 0 )
	{
		std::cout << "\033[93mCurrently running UWP Apps:" << std::endl;
		void* ProcessSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
		PROCESSENTRY32 ProcessEntry;
		ProcessEntry.dwSize = sizeof(PROCESSENTRY32);

		if( Process32First(ProcessSnapshot, &ProcessEntry) )
		{
			while( Process32Next(ProcessSnapshot, &ProcessEntry) )
			{
				void* ProcessHandle = OpenProcess(
					PROCESS_QUERY_LIMITED_INFORMATION,
					false,
					ProcessEntry.th32ProcessID
				);
				if( ProcessHandle )
				{
					std::uint32_t NameLength = 0;
					std::int32_t ProcessCode = GetPackageFamilyName(
						ProcessHandle, &NameLength, nullptr
					);
					if( NameLength )
					{
						std::wcout
							<< "\033[92m"
							<< std::setw(12)
							<< ProcessEntry.th32ProcessID;

						std::wcout
							<< "\033[96m"
							<< " \033(0x\033(B "
							<< ProcessEntry.szExeFile << " :\n\t\t\033(0m\033(B";

						std::unique_ptr<wchar_t[]> PackageName = std::make_unique<wchar_t[]>(NameLength);

						ProcessCode = GetPackageFamilyName(
							ProcessHandle,
							&NameLength,
							PackageName.get()
						);

						if( ProcessCode != ERROR_SUCCESS )
						{
							std::wcout << "GetPackageFamilyName Error: " << ProcessCode;
						}

						std::wcout << PackageName.get() << std::endl;
					}
				}
				CloseHandle(ProcessHandle);
			}
		}
		else
		{
			std::cout << "\033[91mUnable to iterate active processes" << std::endl;
			if( !Continuous ) system("pause");
			return EXIT_FAILURE;
		}
		std::cout << "\033[93mEnter ProcessID: \033[92m";
		std::cin >> ProcessID;
	}

	// Get package name
	std::wstring PackageFileName;

	if(
		HANDLE ProcessHandle = OpenProcess(
			PROCESS_ALL_ACCESS | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			false, ProcessID
		); ProcessHandle
		)
	{
		std::uint32_t NameLength = 0;
		std::int32_t ProcessCode = GetPackageFamilyName(
			ProcessHandle, &NameLength, nullptr
		);
		if( NameLength )
		{
			std::unique_ptr<wchar_t[]> PackageName(new wchar_t[NameLength]());

			ProcessCode = GetPackageFamilyName(
				ProcessHandle, &NameLength, PackageName.get()
			);

			if( ProcessCode != ERROR_SUCCESS )
			{
				std::wcout << "GetPackageFamilyName Error: " << ProcessCode;
			}
			PackageFileName = PackageName.get();
		}
		CloseHandle(ProcessHandle);
	}
	else
	{
		std::cout << "\033[91mFailed to query process for " << std::endl;
		if( !Continuous ) system("pause");
		return EXIT_FAILURE;
	}

	// Get local app data folder
	std::wofstream LogFile;
	char* LocalAppData;
	size_t len;
	errno_t err = _dupenv_s(&LocalAppData, &len, "LOCALAPPDATA");

	if( !TargetPath.empty() )
	{
		// Fully realize relative path into an absolute path
		TargetPath = std::filesystem::absolute(TargetPath);

		if( !std::filesystem::exists(TargetPath) || !std::filesystem::is_directory(TargetPath) )
		{
			std::cout << "\033[91mInvalid target directory: " << TargetPath << std::endl;
			if( !Continuous ) system("pause");
			return EXIT_FAILURE;
		}

		// Get dump folder path
		std::filesystem::path DumpFolderPath(LocalAppData);
		DumpFolderPath.append("Packages");
		DumpFolderPath.append(PackageFileName);
		DumpFolderPath.append("TempState\\DUMP");
		// Clear out dump folder
		std::filesystem::remove_all(DumpFolderPath);
		// Create junction
		CreateJunction(DumpFolderPath.string().c_str(), TargetPath.string().c_str());
		// Set ACL for target directory
		SetAccessControl(TargetPath, L"S-1-15-2-1");
	}

	SetAccessControl(GetRunningDirectory() + L'\\' + DLLFile, L"S-1-15-2-1");

	IPC::SetTargetProcess(ProcessID);

	std::cout << "\033[93mInjecting into remote process: ";
	if( !DLLInjectRemote(ProcessID, GetRunningDirectory() + L'\\' + DLLFile) )
	{
		std::cout << "\033[91mFailed" << std::endl;
		if( !Continuous ) system("pause");
		return EXIT_FAILURE;
	}
	std::cout << "\033[92mSuccess!" << std::endl;

	std::cout << "\033[93mWaiting for remote thread IPC:" << std::endl;
	std::chrono::high_resolution_clock::time_point ThreadTimeout = std::chrono::high_resolution_clock::now() + std::chrono::seconds(5);
	while( IPC::GetTargetThread() == IPC::InvalidThread )
	{
		if( std::chrono::high_resolution_clock::now() >= ThreadTimeout )
		{
			std::cout << "\033[91mRemote thread wait timeout: Unable to find target thread" << std::endl;
			if( !Continuous ) system("pause");
			return EXIT_FAILURE;
		}
	}

	std::cout << "Remote Dumper thread found: 0x" << std::hex << IPC::GetTargetThread() << std::endl;

	if( Logging )
	{
		std::filesystem::path LogFilePath = std::filesystem::current_path();
		//add package Name to logfile Path
		LogFilePath.append(PackageFileName);
		LogFilePath.concat(" ");

		// Get timestamp for log file name
		{
			std::time_t CurrentTime = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
			std::stringstream TimeString;
			struct tm TimeBuffer;
			gmtime_s(&TimeBuffer, &CurrentTime);
			TimeString << std::put_time(&TimeBuffer, "%Y%m%dT%H%M%S");
			LogFilePath.concat(TimeString.str());
		}

		// Attempt to create file
		LogFilePath.concat(".txt");
		std::cout << LogFilePath << std::endl;
		LogFile = std::wofstream(LogFilePath);
		if( LogFile.is_open() )
		{
			std::cout << "\033[92mLogging to File: " << LogFilePath << "\033[0m" << std::endl;
		}
		else
		{
			std::cout << "\033[91mFailed to open log file\033[0m" << std::endl;;
			if( !Continuous ) system("pause");
			return EXIT_FAILURE;
		}
	}

	std::cout << "\033[0m" << std::flush;
	std::wstring CurMessage;
	CurMessage.reserve(IPC::MessageEntry::StringSize);
	while( IPC::GetTargetThread() != IPC::InvalidThread )
	{
		while( IPC::PopMessage(CurMessage) )
		{
			std::wcout << CurMessage << "\033[0m";
			if( Logging )
			{
				LogFile << CurMessage << std::flush;
			}
		}
	}
	if( Logging ) LogFile.close();
	if( !Continuous ) {
		// Open Tempstate folder for user
		std::filesystem::path DumpFolderPath(LocalAppData);
		DumpFolderPath = DumpFolderPath / "Packages" / PackageFileName / "TempState";

		ShellExecuteW(
			nullptr, L"open", DumpFolderPath.c_str(), nullptr, nullptr,
			SW_SHOWDEFAULT
		);
		system("pause");
	}
	return EXIT_SUCCESS;
}

void SetAccessControl(const std::wstring& ExecutableName, const wchar_t* AccessString)
{
	PSECURITY_DESCRIPTOR SecurityDescriptor = nullptr;
	EXPLICIT_ACCESSW ExplicitAccess = { 0 };

	ACL* AccessControlCurrent = nullptr;
	ACL* AccessControlNew = nullptr;

	SECURITY_INFORMATION SecurityInfo = DACL_SECURITY_INFORMATION;
	PSID SecurityIdentifier = nullptr;

	if(
		GetNamedSecurityInfoW(
			ExecutableName.c_str(),
			SE_FILE_OBJECT,
			DACL_SECURITY_INFORMATION,
			nullptr,
			nullptr,
			&AccessControlCurrent,
			nullptr,
			&SecurityDescriptor
		) == ERROR_SUCCESS
		)
	{
		ConvertStringSidToSidW(AccessString, &SecurityIdentifier);
		if( SecurityIdentifier != nullptr )
		{
			ExplicitAccess.grfAccessPermissions = GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE;
			ExplicitAccess.grfAccessMode = SET_ACCESS;
			ExplicitAccess.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
			ExplicitAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
			ExplicitAccess.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
			ExplicitAccess.Trustee.ptstrName = reinterpret_cast<wchar_t*>(SecurityIdentifier);

			if(
				SetEntriesInAclW(
					1,
					&ExplicitAccess,
					AccessControlCurrent,
					&AccessControlNew
				) == ERROR_SUCCESS
				)
			{
				SetNamedSecurityInfoW(
					const_cast<wchar_t*>(ExecutableName.c_str()),
					SE_FILE_OBJECT,
					SecurityInfo,
					nullptr,
					nullptr,
					AccessControlNew,
					nullptr
				);
			}
		}
	}
	if( SecurityDescriptor )
	{
		LocalFree(reinterpret_cast<HLOCAL>(SecurityDescriptor));
	}
	if( AccessControlNew )
	{
		LocalFree(reinterpret_cast<HLOCAL>(AccessControlNew));
	}
}

bool DLLInjectRemote(uint32_t ProcessID, const std::wstring& DLLpath)
{
	const std::size_t DLLPathSize = ((DLLpath.size() + 1) * sizeof(wchar_t));
	std::uint32_t Result;
	if( !ProcessID )
	{
		std::wcout << "Invalid Process ID: " << ProcessID << std::endl;
		return false;
	}

	if( GetFileAttributesW(DLLpath.c_str()) == INVALID_FILE_ATTRIBUTES )
	{
		std::wcout << "DLL file: " << DLLpath << " does not exists" << std::endl;
		return false;
	}

	SetAccessControl(DLLpath, L"S-1-15-2-1");

	void* ProcLoadLibrary = reinterpret_cast<void*>(
		GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW")
		);

	if( !ProcLoadLibrary )
	{
		std::wcout << "Unable to find LoadLibraryW procedure" << std::endl;
		return false;
	}

	void* Process = OpenProcess(PROCESS_ALL_ACCESS, false, ProcessID);
	if( Process == nullptr )
	{
		std::wcout << "Unable to open process ID" << ProcessID << " for writing" << std::endl;
		return false;
	}
	void* VirtualAlloc = reinterpret_cast<void*>(
		VirtualAllocEx(
			Process,
			nullptr,
			DLLPathSize,
			MEM_RESERVE | MEM_COMMIT,
			PAGE_READWRITE
		)
		);

	if( VirtualAlloc == nullptr )
	{
		std::wcout << "Unable to remotely allocate memory" << std::endl;
		CloseHandle(Process);
		return false;
	}

	SIZE_T BytesWritten = 0;
	Result = WriteProcessMemory(
		Process,
		VirtualAlloc,
		DLLpath.data(),
		DLLPathSize,
		&BytesWritten
	);

	if( Result == 0 )
	{
		std::wcout << "Unable to write process memory" << std::endl;
		CloseHandle(Process);
		return false;
	}

	if( BytesWritten != DLLPathSize )
	{
		std::wcout << "Failed to write remote DLL path name" << std::endl;
		CloseHandle(Process);
		return false;
	}

	void* RemoteThread =
		CreateRemoteThread(
			Process,
			nullptr,
			0,
			reinterpret_cast<LPTHREAD_START_ROUTINE>(ProcLoadLibrary),
			VirtualAlloc,
			0,
			nullptr
		);

	// Wait for remote thread to finish
	if( RemoteThread )
	{
		// Explicitly wait for LoadLibraryW to complete before releasing memory
		// avoids causing a remote memory leak
		WaitForSingleObject(RemoteThread, INFINITE);
		CloseHandle(RemoteThread);
	}
	else
	{
		// Failed to create thread
		std::wcout << "Unable to create remote thread" << std::endl;
	}

	VirtualFreeEx(Process, VirtualAlloc, 0, MEM_RELEASE);
	CloseHandle(Process);
	return true;
}

std::wstring GetRunningDirectory()
{
	wchar_t RunPath[MAX_PATH];
	GetModuleFileNameW(GetModuleHandleW(nullptr), RunPath, MAX_PATH);
	PathRemoveFileSpecW(RunPath);
	return std::wstring(RunPath);
}
```