Project Path: arc_gmh5225_win-shaper_xlc5_fau

Source Tree:

```txt
arc_gmh5225_win-shaper_xlc5_fau
├── LICENSE
├── README.md
├── bin
│   ├── shaper.exe
│   ├── shaper32.sys
│   └── shaper64.sys
├── driver
│   ├── DigiCert High Assurance EV Root CA (cross signing).crt
│   ├── Trace.h
│   ├── common.h
│   ├── interface.h
│   ├── packet_queue.c
│   ├── packet_queue.h
│   ├── shaper.sln
│   ├── shaper.vcxproj
│   ├── shaper.vcxproj.filters
│   ├── wdm_driver.c
│   ├── wfp_callout.c
│   └── wfp_callout.h
├── exe
│   ├── exe.cpp
│   ├── exe.vcxproj
│   ├── exe.vcxproj.filters
│   └── targetver.h
├── gui
│   ├── CustomProfileDlg.cpp
│   ├── CustomProfileDlg.h
│   ├── CustomProfiles.cpp
│   ├── CustomProfiles.h
│   ├── CustomProfilesDlg.cpp
│   ├── CustomProfilesDlg.h
│   ├── WinShaperDlg.cpp
│   ├── WinShaperDlg.h
│   ├── gui.cpp
│   ├── gui.h
│   ├── gui.rc
│   ├── gui.vcxproj
│   ├── gui.vcxproj.filters
│   ├── res
│   │   ├── gui.ico
│   │   └── gui.rc2
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── shaper.sln

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# win-shaper
Windows traffic-shaping packet filter

This tool allows you to emulate various network conditions. For more information, see [the blog post](http://calendar.perfplanet.com/2016/testing-with-realistic-networking-conditions/).

IMPORTANT: The released drivers are code signed but not with an EV certificate so they will not work in WIndows 10 with secureboot enabled.  You must disable secureboot to use the released binaries from here directly (if you build it yourself with EV signing and go through the process the restrictions will not apply).

```

`driver/DigiCert High Assurance EV Root CA (cross signing).crt`:

```crt
-----BEGIN CERTIFICATE-----
MIIFOzCCAyOgAwIBAgIKYSBNtAAAAAAAJzANBgkqhkiG9w0BAQUFADB/MQswCQYD
VQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEe
MBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSkwJwYDVQQDEyBNaWNyb3Nv
ZnQgQ29kZSBWZXJpZmljYXRpb24gUm9vdDAeFw0xMTA0MTUxOTQ1MzNaFw0yMTA0
MTUxOTU1MzNaMGwxCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMx
GTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xKzApBgNVBAMTIkRpZ2lDZXJ0IEhp
Z2ggQXNzdXJhbmNlIEVWIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
ggEKAoIBAQDGzOVz5vvUu+UtLTKm3+WBP8nNJUm2cSrD1ZQ0Z6IKHLBfaaZAscS3
so/QmKSpQVk609yU1jzbdDikSsxNJYL3SqVTEjju80ltcZF+Y7arpl/DpIT4T2JR
vvjF7Ns4kuMG5QiRDMQoQVX7y1qJFX5x6DW/TXIJPb46OFBbdzEbjbPHJEWap6xt
ABRaBLe6E+tRCphBQSJOZWGHgUFQpnlcid4ZSlfVLuZdHFMsfpjNGgYWpGhz0DQE
E1yhcdNafFXbXmThN4cwVgTlEbQpgBLxeTmIogIRfCdmt4i3ePLKCqg4qwpkwr9m
XZWEwaElHoddGlALIBLMQbtuC1E4uEvLAgMBAAGjgcswgcgwEQYDVR0gBAowCDAG
BgRVHSAAMAsGA1UdDwQEAwIBhjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBSx
PsNpA/i/RwHUmCYaCALvY2QrwzAfBgNVHSMEGDAWgBRi+wohW39DbhHaCVRQa/XS
lnHxnjBVBgNVHR8ETjBMMEqgSKBGhkRodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20v
cGtpL2NybC9wcm9kdWN0cy9NaWNyb3NvZnRDb2RlVmVyaWZSb290LmNybDANBgkq
hkiG9w0BAQUFAAOCAgEAIIzBWe1vnGstwUo+dR1FTEFQHL2A6tmwkosGKhM/Uxae
VjlqimO2eCR59X24uUehCpbC9su9omafBuGs0nkJDv083KwCDHCvPxvseH7U60sF
YCbZc2GRIe2waGPglxKrb6AS7dmf0tonPLPkVvnR1IEPcb1CfKaJ3M3VvZWiq/GT
EX3orDEpqF1mcEGd/HXJ1bMaOSrQhQVQi6yRysSTy3GlnaSUb1gM+m4gxAgxtYWd
foH50j3KWxiFbAqG7CIJG6V0NE9/KLyVSqsdtpiwXQmkd3Z+76eOXYT2GCTL0W2m
w6GcwhB1gP+dMv3mz0M6gvfOj+FyKptit1/tlRo5XC+UbUi3AV8zL7vcLXM0iQRC
ChyLefmj+hfv+qEaEN/gssGV61wMBZc7NT4YiE3bbL8kiY3Ivdifezk6JKDV39Hz
ShqX9qZveh+wkKmzrAE5kdNht2TxPlc4A6/OetK1kPWu3DmZ1bY8l+2myxbHfWsq
TJCU5kxU/R7NIOzOaJyHWOlhYL7rDsnVGX2f6Xi9DqwhdQePqW7gjGoqa5zj52W8
vC08bdwE3GdFNjKvBIG8qABuYUyVxVzUjo6fL8EydL29EWUDB83vt14CV9qG1Boo
NK+ISbLPpd2CVm9oqhTiWVT+/+ru7+qScCJggeMlI8CfzA9JsjWqWMM6w9kWlBA=
-----END CERTIFICATE-----

```

`driver/Trace.h`:

```h
/*++

Module Name:

    Trace.h

Abstract:

    Header file for the debug tracing related function defintions and macros.

Environment:

    Kernel mode

--*/

//
// Define the tracing flags.
//
// Tracing GUID - 3040825a-7978-4559-ba48-7b03e72581fc
//

#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        xxxTraceGuid, (3040825a,7978,4559,ba48,7b03e72581fc), \
                                                                            \
        WPP_DEFINE_BIT(MYDRIVER_ALL_INFO)                              \
        WPP_DEFINE_BIT(TRACE_DRIVER)                                   \
        WPP_DEFINE_BIT(TRACE_DEVICE)                                   \
        WPP_DEFINE_BIT(TRACE_QUEUE)                                    \
        )                             

#define WPP_FLAG_LEVEL_LOGGER(flag, level)                                  \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_LEVEL_ENABLED(flag, level)                                 \
    (WPP_LEVEL_ENABLED(flag) &&                                             \
     WPP_CONTROL(WPP_BIT_ ## flag).Level >= level)

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) \
           WPP_LEVEL_LOGGER(flags)
               
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
           (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

//           
// WPP orders static parameters before dynamic parameters. To support the Trace function
// defined below which sets FLAGS=MYDRIVER_ALL_INFO, a custom macro must be defined to
// reorder the arguments to what the .tpl configuration file expects.
//
#define WPP_RECORDER_FLAGS_LEVEL_ARGS(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_ARGS(lvl, flags)
#define WPP_RECORDER_FLAGS_LEVEL_FILTER(flags, lvl) WPP_RECORDER_LEVEL_FLAGS_FILTER(lvl, flags)

//
// This comment block is scanned by the trace preprocessor to define our
// Trace function.
//
// begin_wpp config
// FUNC Trace{FLAGS=MYDRIVER_ALL_INFO}(LEVEL, MSG, ...);
// FUNC TraceEvents(LEVEL, FLAGS, MSG, ...);
// end_wpp
//

```

`driver/common.h`:

```h
#pragma once

#include <Ntifs.h>
#include <wdf.h>

#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>
#pragma warning(pop)
#include <fwpmk.h>

#include <ws2ipdef.h>
#include <in6addr.h>
#include <ip2string.h>

#define INITGUID
#include <guiddef.h>

#include "interface.h"
#include "wfp_callout.h"
#include "packet_queue.h"

```

`driver/interface.h`:

```h
#pragma once

#define SHAPER_DEVICE_NAME     L"\\Device\\TrafficShaper"
#define SHAPER_SYMBOLIC_NAME   L"\\DosDevices\\Global\\TrafficShaper"
#define SHAPER_DOS_NAME        L"\\\\.\\TrafficShaper"
#define SHAPER_SERVICE_NAME    L"shaper"
#define SHAPER_SERVICE_DISPLAY_NAME L"Traffic Shaper Driver"

#pragma pack(push, 8)
typedef struct {
  unsigned short   plr;            // Packet loss rate in hundreths of % (0-10000, i.e. 10% packet loss = 1000)
  unsigned __int64 inBps;          // Inbound bandwidth in bits-per-second
  unsigned __int64 outBps;         // Outbound bandwidth in bits-per-second
  unsigned long    inLatency;      // Inbound latency in milliseconds
  unsigned long    outLatency;     // Outbound latency in milliseconds
  unsigned __int64 inBufferBytes;  // Size of inbound packet buffer in bytes (drop packets that overflow). 150,000 Matches the dummynet default
  unsigned __int64 outBufferBytes; // Size of outbound packet buffer in bytes (drop packets that overflow). 150,000 Matches the dummynet default
} SHAPER_PARAMS;

typedef struct {
  BOOLEAN       enabled;           // If traffic shaping is enabled
  SHAPER_PARAMS params;            // connection settings
  unsigned __int64 inQueuedBytes;  // Size of the pending data in the inbound queue
  unsigned __int64 outQueuedBytes; // Size of the pending data in the inbound queue
} SHAPER_STATUS;

typedef struct {
  unsigned __int64 inBytes;    // Amount of data received (delivered to the OS, after all queues) since starting
  unsigned __int64 inPackets;  // Number of packets received (delivered to the OS, after all queues) since starting
  unsigned __int64 outBytes;   // Amount of data transmitted (delivered to the net, after all queues) since starting
  unsigned __int64 outPackets; // Number of packets transmitted (delivered to the net, after all queues) since starting
} SHAPER_STATS;
#pragma pack(pop)

// from ntifs.h
#ifndef FILE_DEVICE_NETWORK 
#define FILE_DEVICE_NETWORK             0x00000012
#endif

#ifndef METHOD_BUFFERED
#define METHOD_BUFFERED                 0
#endif

#ifndef FILE_READ_ACCESS
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#endif

#ifndef FILE_WRITE_ACCESS
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe
#endif

#ifndef CTL_CODE
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#endif

#define	SHAPER_IOCTL_DISABLE  CTL_CODE(FILE_DEVICE_NETWORK, 0x801, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define	SHAPER_IOCTL_ENABLE CTL_CODE(FILE_DEVICE_NETWORK, 0x802, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define	SHAPER_IOCTL_GET_STATUS CTL_CODE(FILE_DEVICE_NETWORK, 0x803, METHOD_BUFFERED, FILE_READ_ACCESS)
#define	SHAPER_IOCTL_GET_STATS CTL_CODE(FILE_DEVICE_NETWORK, 0x804, METHOD_BUFFERED, FILE_READ_ACCESS)

```

`driver/packet_queue.c`:

```c
/*
Copyright 2016 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "common.h"
#define QUEUED_PACKET_POOL_TAG 'kppD'

// timer
WDFTIMER timer_handle = NULL;
KSPIN_LOCK timer_spinlock = 0;
BOOLEAN timer_pending = FALSE;

// QUEUED_PACKET is the object type we used to store all information
// needed for out-of-band packet re-injection. This type
// also points back to the flow context the packet belongs to.
typedef struct {
   LIST_ENTRY     listEntry;
   HANDLE         injection_handle;
   BOOLEAN        outbound;
   unsigned long  packet_length;  // Size of the packet (in bytes)
   unsigned long  packet_count;	  // Number of packets in the packet buffer
   LARGE_INTEGER  latency_start;  // time it was placed in the latency queue

   // Data fields for packet re-injection.
   UINT16 layerId;
   IF_INDEX interfaceIndex;
   NDIS_PORT_NUMBER NdisPortNumber;
   NET_BUFFER_LIST *netBufferList;
} QUEUED_PACKET;

// packet queues
// All packets are first buffered into the bandwidth queue and released
// at the appropriate rate for the configured bandwidth into the latency queue.
// When they are added to the latency queue they are timestamped when they
// entered and they are released when the appropriate latency has expired.
// Only the bandwidth queue is affected by the queue buffer size.  The latency
// queue has no limit.
typedef struct {
  LIST_ENTRY bandwidth_queue;
  LIST_ENTRY latency_queue;

  unsigned short   plr;         // packet loss in 1/100% (0-10000)
  unsigned __int64 bps;         // bandwidth in bits per second
  unsigned long    latency;     // latency in microseconds
  unsigned __int64 bufferBytes; // size of packet buffer in bytes

  unsigned __int64 queued_bytes;    // accumulated size of queued packets
  unsigned __int64 available_bytes; // accumulated bytes available for sending
  LARGE_INTEGER last_tick;          // performance counter timestamp of the last time the queue was checked
  KSPIN_LOCK lock;
} PACKET_QUEUE;

static BOOLEAN queues_initialized = FALSE;
static KSPIN_LOCK queue_lock = 0;
PACKET_QUEUE inbound_queue;
PACKET_QUEUE outbound_queue;

static BOOLEAN traffic_shaping_enabled = FALSE;

unsigned __int64 inBytes = 0;
unsigned __int64 inPackets = 0;
unsigned __int64 outBytes = 0;
unsigned __int64 outPackets = 0;

// Forward declarations
VOID TimerEvt(_In_ WDFTIMER Timer);
VOID StartPacketTimerIfNecessary();
void ProcessQueue(PACKET_QUEUE *queue);

#define INITIAL_TOKEN_COUNT 1500

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
NTSTATUS InitializePacketQueues(WDFDEVICE timer_parent) {
  NTSTATUS status = STATUS_SUCCESS;

  KeInitializeSpinLock(&queue_lock);   

  queues_initialized = TRUE;

  KeInitializeSpinLock(&timer_spinlock);   
  KeInitializeSpinLock(&inbound_queue.lock);
  InitializeListHead(&inbound_queue.bandwidth_queue);
  InitializeListHead(&inbound_queue.latency_queue);
  KeInitializeSpinLock(&outbound_queue.lock);   
  InitializeListHead(&outbound_queue.bandwidth_queue);
  InitializeListHead(&outbound_queue.latency_queue);

  // Create the timer that will be used to process the queues
  WDF_TIMER_CONFIG timer_config;
  WDF_OBJECT_ATTRIBUTES timer_attributes;
  WDF_TIMER_CONFIG_INIT(&timer_config, TimerEvt);
  timer_config.Period = 0;
  timer_config.TolerableDelay = 0;
  timer_config.AutomaticSerialization = FALSE;
  timer_config.UseHighResolutionTimer = WdfTrue;
  WDF_OBJECT_ATTRIBUTES_INIT(&timer_attributes);
  timer_attributes.ParentObject = timer_parent;
  timer_pending = FALSE;
  status = WdfTimerCreate(&timer_config, &timer_attributes, &timer_handle);

  return status;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void FreeQueuedPacket(_Inout_ __drv_freesMem(Mem) QUEUED_PACKET* packet) {
  if (packet->netBufferList != NULL)
    FwpsFreeCloneNetBufferList(packet->netBufferList, 0);
  ExFreePoolWithTag(packet, QUEUED_PACKET_POOL_TAG);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void DropQueue(PACKET_QUEUE *queue) {
  KLOCK_QUEUE_HANDLE lock;
  KeAcquireInStackQueuedSpinLock(&queue->lock, &lock);
  while (!IsListEmpty(&queue->latency_queue)) {
    LIST_ENTRY * listEntry = RemoveHeadList(&queue->latency_queue);
    QUEUED_PACKET *packet = CONTAINING_RECORD(listEntry, QUEUED_PACKET, listEntry);
    FreeQueuedPacket(packet);
  }
  while (!IsListEmpty(&queue->bandwidth_queue)) {
    LIST_ENTRY * listEntry = RemoveHeadList(&queue->bandwidth_queue);
    QUEUED_PACKET *packet = CONTAINING_RECORD(listEntry, QUEUED_PACKET, listEntry);
    FreeQueuedPacket(packet);
  }
  KeReleaseInStackQueuedSpinLock(&lock);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
BOOLEAN ShaperEnable(_In_ unsigned short plr,
                     _In_ unsigned __int64 inBps,
                     _In_ unsigned __int64 outBps,
                     _In_ unsigned long inLatency,
                     _In_ unsigned long outLatency,
                     _In_ unsigned __int64 inBufferBytes,
                     _In_ unsigned __int64 outBufferBytes) {
  BOOLEAN ret = TRUE;
  KLOCK_QUEUE_HANDLE lock_handle;

  KeAcquireInStackQueuedSpinLock(&inbound_queue.lock, &lock_handle);
  inbound_queue.plr = plr;
  inbound_queue.bps = inBps;
  inbound_queue.latency = inLatency;
  inbound_queue.bufferBytes = inBufferBytes;
  inbound_queue.queued_bytes = 0;
  inbound_queue.available_bytes = INITIAL_TOKEN_COUNT;
  inbound_queue.last_tick = KeQueryPerformanceCounter(NULL);
  KeReleaseInStackQueuedSpinLock(&lock_handle);

  KeAcquireInStackQueuedSpinLock(&outbound_queue.lock, &lock_handle);
  outbound_queue.plr = plr;
  outbound_queue.bps = outBps;
  outbound_queue.latency = outLatency;
  outbound_queue.bufferBytes = outBufferBytes;
  outbound_queue.queued_bytes = 0;
  outbound_queue.available_bytes = INITIAL_TOKEN_COUNT;
  outbound_queue.last_tick = inbound_queue.last_tick;
  KeReleaseInStackQueuedSpinLock(&lock_handle);

  KeAcquireInStackQueuedSpinLock(&queue_lock, &lock_handle);
  traffic_shaping_enabled = TRUE;
  KeReleaseInStackQueuedSpinLock(&lock_handle);
  return ret;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
BOOLEAN ShaperDisable() {
  BOOLEAN ret = TRUE;
  KLOCK_QUEUE_HANDLE lock_handle;
  KeAcquireInStackQueuedSpinLock(&queue_lock, &lock_handle);
  traffic_shaping_enabled = FALSE;
  KeReleaseInStackQueuedSpinLock(&lock_handle);
  ProcessQueue(&outbound_queue);
  ProcessQueue(&inbound_queue);
  return ret;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void DestroyPacketQueues() {
  if (queues_initialized) {
    KLOCK_QUEUE_HANDLE lock_handle;
    KeAcquireInStackQueuedSpinLock(&queue_lock, &lock_handle);
    if (queues_initialized) {
      DropQueue(&inbound_queue);
      DropQueue(&outbound_queue);
    }
    queues_initialized = FALSE;

    if (timer_handle) {
      WdfTimerStop(timer_handle, FALSE);
      timer_handle = NULL;
      timer_pending = FALSE;
    }
    KeReleaseInStackQueuedSpinLock(&lock_handle);
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void PacketInjectionComplete(_Inout_ void* context,
    _Inout_ NET_BUFFER_LIST* netBufferList,
    _In_ BOOLEAN dispatchLevel) {
  QUEUED_PACKET *packet = context;
  UNREFERENCED_PARAMETER(netBufferList);  
  UNREFERENCED_PARAMETER(dispatchLevel);  
  if (packet->outbound) {
    outPackets += packet->packet_count;
    outBytes += packet->packet_length;
  } else {
    inPackets += packet->packet_count;
    inBytes += packet->packet_length;
  }
  FreeQueuedPacket(packet);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void InjectPacket(QUEUED_PACKET *packet) {
  if (packet) {
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    if (packet->outbound) {
      status = FwpsInjectMacSendAsync(packet->injection_handle,
                              NULL,
                              0,
                              packet->layerId,
                              packet->interfaceIndex,
                              packet->NdisPortNumber,
                              packet->netBufferList,
                              PacketInjectionComplete,
                              packet);
    } else {
      status = FwpsInjectMacReceiveAsync(packet->injection_handle,
                                NULL,
                                0,
                                packet->layerId,
                                packet->interfaceIndex,
                                packet->NdisPortNumber,
                                packet->netBufferList,
                                PacketInjectionComplete,
                                packet);
    }
    if (!NT_SUCCESS(status))
      FreeQueuedPacket(packet);
  }
}

/*-----------------------------------------------------------------------------
  Inject any packets that are due (for now, all of them)
-----------------------------------------------------------------------------*/
void ProcessQueue(PACKET_QUEUE *queue) {
  QUEUED_PACKET* packet = NULL;
  KLOCK_QUEUE_HANDLE lock;

  // process the bandwidth queue

  // Increment the available bytes if there is something in the queue
  KeAcquireInStackQueuedSpinLock(&queue->lock, &lock);
  LARGE_INTEGER frequency;
  LARGE_INTEGER now = KeQueryPerformanceCounter(&frequency);
  unsigned __int64 accumulated = ((now.QuadPart - queue->last_tick.QuadPart) * queue->bps) / (8 * frequency.QuadPart);
  queue->available_bytes += accumulated;
  if (IsListEmpty(&queue->bandwidth_queue) && queue->available_bytes > INITIAL_TOKEN_COUNT)
    queue->available_bytes = INITIAL_TOKEN_COUNT;

  // Move as many packets to the latency queue as the accumulated available bytes will allow
  do {
    packet = NULL;
    if (!IsListEmpty(&queue->bandwidth_queue)) {
      LIST_ENTRY * listEntry = RemoveHeadList(&queue->bandwidth_queue);
      packet = CONTAINING_RECORD(listEntry, QUEUED_PACKET, listEntry);
      if (!traffic_shaping_enabled || queue->bps == 0 || packet->packet_length <= queue->available_bytes) {
        queue->available_bytes -= packet->packet_length;
        queue->queued_bytes -= packet->packet_length;
        packet->latency_start = KeQueryPerformanceCounter(NULL);
        InsertTailList(&queue->latency_queue, &packet->listEntry);
      } else {
        InsertHeadList(&queue->bandwidth_queue, &packet->listEntry);
        packet = NULL;
      }
    }
  } while (packet);

  // Reset the byte accumulation if the bandwidth queue is empty
  queue->last_tick = KeQueryPerformanceCounter(NULL);
  KeReleaseInStackQueuedSpinLock(&lock);

  // process the latency queue
  do {
    packet = NULL;
    KeAcquireInStackQueuedSpinLock(&queue->lock, &lock);
    if (!IsListEmpty(&queue->latency_queue)) {
      now = KeQueryPerformanceCounter(&frequency);
      LIST_ENTRY * listEntry = RemoveHeadList(&queue->latency_queue);
      packet = CONTAINING_RECORD(listEntry, QUEUED_PACKET, listEntry);
      if (traffic_shaping_enabled) {
        // round to the closest ms instead of truncating by adding 1/2 of a ms to the elapsed ticks
        unsigned __int64 round = frequency.QuadPart / 2000LL;
        unsigned long elapsed_ms = (unsigned long)(((now.QuadPart - packet->latency_start.QuadPart) * 1000 + round) / frequency.QuadPart);
        if (elapsed_ms < queue->latency) {
          InsertHeadList(&queue->latency_queue, &packet->listEntry);
          packet = NULL;
        }
      }
    }
    KeReleaseInStackQueuedSpinLock(&lock);
    if (packet)
      InjectPacket(packet);
  } while (packet);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
VOID TimerEvt(_In_ WDFTIMER Timer) {
  UNREFERENCED_PARAMETER(Timer);
 
  // Reset the timer state since it is a one-shot timer
  KLOCK_QUEUE_HANDLE timer_spinlock_handle;
  KeAcquireInStackQueuedSpinLock(&timer_spinlock, &timer_spinlock_handle);
  timer_pending = FALSE;
  KeReleaseInStackQueuedSpinLock(&timer_spinlock_handle);

  ProcessQueue(&outbound_queue);
  ProcessQueue(&inbound_queue);

  // Queue up the timer to handle any pending packets
  StartPacketTimerIfNecessary();
}

/*-----------------------------------------------------------------------------
  If any packets are pending in a queue, set the timer to callback when the
  first one is due to be sent.
-----------------------------------------------------------------------------*/
VOID StartPacketTimerIfNecessary() {
  KLOCK_QUEUE_HANDLE timer_spinlock_handle, outbound_lock, inbound_lock;
  KeAcquireInStackQueuedSpinLock(&timer_spinlock, &timer_spinlock_handle);
  KeAcquireInStackQueuedSpinLock(&outbound_queue.lock, &outbound_lock);
  KeAcquireInStackQueuedSpinLock(&inbound_queue.lock, &inbound_lock);
  if (!timer_pending &&
      (!IsListEmpty(&inbound_queue.bandwidth_queue) ||
       !IsListEmpty(&outbound_queue.bandwidth_queue) ||
       !IsListEmpty(&inbound_queue.latency_queue) ||
       !IsListEmpty(&outbound_queue.latency_queue)) &&
      timer_handle) {
    // Set a 1ms tick rate as long as there are packets in one of the queues
    timer_pending = TRUE;
    WdfTimerStart(timer_handle, WDF_REL_TIMEOUT_IN_MS(1));
  }
  KeReleaseInStackQueuedSpinLock(&inbound_lock);
  KeReleaseInStackQueuedSpinLock(&outbound_lock);
  KeReleaseInStackQueuedSpinLock(&timer_spinlock_handle);
}

/*-----------------------------------------------------------------------------
  Decide if the packet should be queued and if so, place it in the appropriate
  queue and start the processing timer.
-----------------------------------------------------------------------------*/
BOOLEAN ShaperQueuePacket(_In_ const FWPS_INCOMING_VALUES* inFixedValues,
                          _In_ const FWPS_INCOMING_METADATA_VALUES* inMetaValues,
                          _Inout_opt_ void* layerData,
                          BOOLEAN outbound,
                          _In_ HANDLE injection_handle) {
  BOOLEAN queued = FALSE;

  PACKET_QUEUE * queue = outbound ? &outbound_queue: &inbound_queue;
  LARGE_INTEGER now = KeQueryPerformanceCounter(NULL);

  // see if we need to drop the packet because of plr
  if (traffic_shaping_enabled && queue->plr > 0) {
    // plr range is 0-10000, grab a random number capped to that range and compare
    ULONG random = RtlRandomEx(&now.LowPart) % 10000;
    if (random < queue->plr)
      return TRUE;
  }

  // see if we need to drop the packet because the buffer is "full"
  NET_BUFFER_LIST *nbl = (NET_BUFFER_LIST*)layerData;
  unsigned long data_length = 0;
  int packet_count = 0;
  NET_BUFFER *buffer = NET_BUFFER_LIST_FIRST_NB(nbl);
  while (buffer) {
	  packet_count++;
	data_length += NET_BUFFER_DATA_LENGTH(buffer);
	buffer = NET_BUFFER_NEXT_NB(buffer);
  }
  if (traffic_shaping_enabled && queue->bufferBytes > 0 && queue->queued_bytes + data_length > queue->bufferBytes)
    return TRUE;

  // clone the packet and add it to the appropriate queue
  QUEUED_PACKET* packet = NULL;
  if (traffic_shaping_enabled && layerData) {
    packet = ExAllocatePoolWithTag(
                          NonPagedPool,
                          sizeof(QUEUED_PACKET),
                          QUEUED_PACKET_POOL_TAG);
    if (packet) {
      RtlZeroMemory(packet, sizeof(QUEUED_PACKET));

      // Keep track of the meta-data necessary for re-injection
      packet->injection_handle = injection_handle;
      packet->outbound = outbound;
      packet->layerId = inFixedValues->layerId;
      UINT ifIndex = outbound ? FWPS_FIELD_OUTBOUND_MAC_FRAME_ETHERNET_INTERFACE_INDEX : FWPS_FIELD_INBOUND_MAC_FRAME_ETHERNET_INTERFACE_INDEX;
      packet->interfaceIndex = inFixedValues->incomingValue[ifIndex].value.uint32;
      UINT ndisPort = outbound ? FWPS_FIELD_OUTBOUND_MAC_FRAME_ETHERNET_NDIS_PORT : FWPS_FIELD_INBOUND_MAC_FRAME_ETHERNET_NDIS_PORT;
      packet->NdisPortNumber = inFixedValues->incomingValue[ndisPort].value.uint32;

      UINT32 bytesRetreated = 0;
      if (!outbound) {
        UINT32 ethernetHeaderSize = 0;
        if(FWPS_IS_L2_METADATA_FIELD_PRESENT(inMetaValues, FWPS_L2_METADATA_FIELD_ETHERNET_MAC_HEADER_SIZE))
          ethernetHeaderSize = inMetaValues->ethernetMacHeaderSize;
        bytesRetreated = ethernetHeaderSize;
      }

      NTSTATUS status = STATUS_SUCCESS;

      // Clone the buffer
      packet->packet_length = data_length;
	  packet->packet_count = packet_count;
      if (bytesRetreated)
        status = NdisRetreatNetBufferDataStart(NET_BUFFER_LIST_FIRST_NB((NET_BUFFER_LIST*)layerData), bytesRetreated, 0, 0);
      if (NT_SUCCESS(status))
        status = FwpsAllocateCloneNetBufferList((NET_BUFFER_LIST*)layerData, NULL, NULL, 0, &packet->netBufferList);
      if (bytesRetreated)
        NdisAdvanceNetBufferDataStart(NET_BUFFER_LIST_FIRST_NB((NET_BUFFER_LIST*)layerData), bytesRetreated, FALSE, 0);

      if (NT_SUCCESS(status)) {
        KLOCK_QUEUE_HANDLE lock;
        KeAcquireInStackQueuedSpinLock(&queue->lock, &lock);
        queue->queued_bytes += data_length;
        InsertTailList(&queue->bandwidth_queue, &packet->listEntry);
        KeReleaseInStackQueuedSpinLock(&lock);
        packet = NULL;
        queued = TRUE;

        // Start the timer to process the packet queue if it isn't already running
        ProcessQueue(queue);
        StartPacketTimerIfNecessary();
      }
    }
  }

  if (!queued) {
    // Make sure to account for packet transfer when we are disabled or otherwise let packets through
    if (outbound) {
      packet_count += packet_count;
      outBytes += data_length;
    } else {
      inPackets += packet_count;
      inBytes += data_length;
    }
  }

  if (!queued && packet)
    FreeQueuedPacket(packet);
  
  return queued;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void ShaperGetStatus(SHAPER_STATUS *status) {
  // Don't bother locking to read the values out
  status->enabled = traffic_shaping_enabled;
  status->params.inBps = inbound_queue.bps;
  status->params.outBps = outbound_queue.bps;
  status->params.inLatency = inbound_queue.latency;
  status->params.outLatency = outbound_queue.latency;
  status->params.plr = inbound_queue.plr;
  status->params.inBufferBytes = inbound_queue.bufferBytes;
  status->params.outBufferBytes = outbound_queue.bufferBytes;
  status->inQueuedBytes = inbound_queue.queued_bytes;
  status->outQueuedBytes = outbound_queue.queued_bytes;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void ShaperGetStats(SHAPER_STATS *stats) {
  stats->outBytes = outBytes;
  stats->outPackets = outPackets;
  stats->inBytes = inBytes;
  stats->inPackets = inPackets;
}
```

`driver/packet_queue.h`:

```h
#pragma once
#include "interface.h"

NTSTATUS InitializePacketQueues(WDFDEVICE timer_parent);
void DestroyPacketQueues();

BOOLEAN ShaperQueuePacket(_In_ const FWPS_INCOMING_VALUES* inFixedValues,
                          _In_ const FWPS_INCOMING_METADATA_VALUES* inMetaValues,
                          _Inout_opt_ void* layerData,
                          BOOLEAN outbound,
                          _In_ HANDLE injection_handle);

BOOLEAN ShaperEnable(_In_ unsigned short plr,
                     _In_ unsigned __int64 inBps,
                     _In_ unsigned __int64 outBps,
                     _In_ unsigned long inLatency,
                     _In_ unsigned long outLatency,
                     _In_ unsigned __int64 inBufferBytes,
                     _In_ unsigned __int64 outBufferBytes);

BOOLEAN ShaperDisable();
void ShaperGetStatus(SHAPER_STATUS *status);
void ShaperGetStats(SHAPER_STATS *stats);

```

`driver/shaper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shaper", "shaper.vcxproj", "{E01B6F50-967B-4012-A437-1F14429CA227}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM.ActiveCfg = Debug|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM.Build.0 = Debug|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM.Deploy.0 = Debug|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM64.Build.0 = Debug|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x64.ActiveCfg = Debug|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x64.Build.0 = Debug|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x64.Deploy.0 = Debug|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x86.ActiveCfg = Debug|Win32
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x86.Build.0 = Debug|Win32
		{E01B6F50-967B-4012-A437-1F14429CA227}.Debug|x86.Deploy.0 = Debug|Win32
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM.ActiveCfg = Release|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM.Build.0 = Release|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM.Deploy.0 = Release|ARM
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM64.ActiveCfg = Release|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM64.Build.0 = Release|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|ARM64.Deploy.0 = Release|ARM64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x64.ActiveCfg = Release|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x64.Build.0 = Release|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x64.Deploy.0 = Release|x64
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x86.ActiveCfg = Release|Win32
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x86.Build.0 = Release|Win32
		{E01B6F50-967B-4012-A437-1F14429CA227}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`driver/shaper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>shaper</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>WindowsV6.3</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <KMDF_VERSION_MAJOR>1</KMDF_VERSION_MAJOR>
    <KMDF_VERSION_MINOR>13</KMDF_VERSION_MINOR>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
    <TargetName>$(TargetName.Replace(' ',''))32</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
    <TargetName>$(TargetName.Replace(' ',''))32</TargetName>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
    <TargetName>$(TargetName.Replace(' ',''))64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
    <TargetName>$(TargetName.Replace(' ',''))64</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <ApiValidator_Enable>false</ApiValidator_Enable>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">
      </WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <PostBuildEvent>
      <Command>copy /Y $(OutDir)shaper\$(TargetName).sys $(SolutionDir)\bin\$(TargetName).sys</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">
      </WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <PostBuildEvent>
      <Command>copy /Y $(OutDir)shaper\$(TargetName).sys $(SolutionDir)\bin\$(TargetName).sys</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">
      </WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">
      </WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <WppMinimalRebuildFromTracking>false</WppMinimalRebuildFromTracking>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <PreprocessorDefinitions>%(PreprocessorDefinitions);BINARY_COMPATIBLE=0;NT;UNICODE;_UNICODE;NDIS60;NDIS_SUPPORT_NDIS6;POOL_NX_OPTIN_AUTO</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>%(AdditionalDependencies);$(DDK_LIB_PATH)\ndis.lib;$(DDK_LIB_PATH)\wdmsec.lib;$(DDK_LIB_PATH)\fwpkclnt.lib;$(SDK_LIB_PATH)\uuid.lib</AdditionalDependencies>
      <Version>1.0</Version>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packet_queue.c" />
    <ClCompile Include="wfp_callout.c" />
    <ClCompile Include="wdm_driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common.h" />
    <ClInclude Include="interface.h" />
    <ClInclude Include="packet_queue.h" />
    <ClInclude Include="wfp_callout.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driver/shaper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="packet_queue.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wdm_driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wfp_callout.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="packet_queue.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="wfp_callout.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="interface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`driver/wdm_driver.c`:

```c
/*
Copyright 2016 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "common.h"

/*-----------------------------------------------------------------------------
  GUIDs
-----------------------------------------------------------------------------*/

// c9ea094d-b304-4f7c-bfc6-608b0ecc5447
DEFINE_GUID(
    SHAPER_OUTBOUND_CALLOUT,
    0xc9ea094d,
    0xb304,
    0x4f7c,
    0xbf, 0xc6, 0x60, 0x8b, 0x0e, 0xcc, 0x54, 0x47
);
// 4fbb02a9-0e93-471e-a04c-d1439b5d402e
DEFINE_GUID(
    SHAPER_INBOUND_CALLOUT,
    0x4fbb02a9,
    0x0e93,
    0x471e,
    0xa0, 0x4c, 0xd1, 0x43, 0x9b, 0x5d, 0x40, 0x2e
);
// ac63c367-b14f-483a-89fc-196c98eec1ad
DEFINE_GUID(
    SHAPER_SUBLAYER,
    0xac63c367,
    0xb14f,
    0x483a,
    0x89, 0xfc, 0x19, 0x6c, 0x98, 0xee, 0xc1, 0xad
);

/*-----------------------------------------------------------------------------
  Globals
-----------------------------------------------------------------------------*/
DEVICE_OBJECT* wdm_device = NULL;
BOOLEAN driver_unloading = FALSE;
HANDLE engine_handle = NULL;
UINT32 outbound_callout_id = 0, inbound_callout_id = 0;

// packet injection handles for inbound/outbound IPv4/IPv6/Unspecified
HANDLE ih_out_ipv4 = NULL;
HANDLE ih_out_ipv6 = NULL;
HANDLE ih_out_unspecified = NULL;
HANDLE ih_in_ipv4 = NULL;
HANDLE ih_in_ipv6 = NULL;
HANDLE ih_in_unspecified = NULL;

/*-----------------------------------------------------------------------------
  Forward declarations
-----------------------------------------------------------------------------*/
NTSTATUS ShaperInitDriverObjects(
    _Inout_ DRIVER_OBJECT* driverObject,
    _In_ const UNICODE_STRING* registryPath,
    _Out_ WDFDRIVER* pDriver,
    _Out_ WDFDEVICE* pDevice);
NTSTATUS RegisterCallouts(_Inout_ void* deviceObject);
void Cleanup(void);
NTSTATUS WaitForWFP();

/******************************************************************************
******************************************************************************/

/*-----------------------------------------------------------------------------
  Main driver entry point
-----------------------------------------------------------------------------*/
NTSTATUS DriverEntry(DRIVER_OBJECT* driverObject, UNICODE_STRING* registryPath) {
  WDFDRIVER driver = NULL;
  WDFDEVICE device = NULL;
  NTSTATUS status = WaitForWFP();

  // Request NX Non-Paged Pool when available
  if (NT_SUCCESS(status)) {
    ExInitializeDriverRuntime(DrvRtPoolNxOptIn);
    status = ShaperInitDriverObjects(driverObject, registryPath, &driver, &device);
  }

  if (NT_SUCCESS(status)) {
    FwpsInjectionHandleCreate(AF_INET, FWPS_INJECTION_TYPE_L2, &ih_out_ipv4);
    FwpsInjectionHandleCreate(AF_INET6, FWPS_INJECTION_TYPE_L2, &ih_out_ipv6);
    FwpsInjectionHandleCreate(AF_UNSPEC, FWPS_INJECTION_TYPE_L2, &ih_out_unspecified);
    FwpsInjectionHandleCreate(AF_INET, FWPS_INJECTION_TYPE_L2, &ih_in_ipv4);
    FwpsInjectionHandleCreate(AF_INET6, FWPS_INJECTION_TYPE_L2, &ih_in_ipv6);
    FwpsInjectionHandleCreate(AF_UNSPEC, FWPS_INJECTION_TYPE_L2, &ih_in_unspecified);
  }

  if (NT_SUCCESS(status))
    status = InitializePacketQueues(device);

  if (NT_SUCCESS(status))
    status = RegisterCallouts(wdm_device);

  if (!NT_SUCCESS(status))
    Cleanup();

  return status;
};

/*-----------------------------------------------------------------------------
  Wait for WFP to start in case we were loaded at boot time
-----------------------------------------------------------------------------*/
NTSTATUS WaitForWFP() {
  NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
  FWPM_SERVICE_STATE  state;

  state = FwpmBfeStateGet0();
  if (state != FWPM_SERVICE_RUNNING) {
    LARGE_INTEGER delay;
    delay.QuadPart = (-5000000);   // wait 500000us (500ms) relative
    DWORD count = 1200;            // wait up to 10 minutes at most
    do {
        KeDelayExecutionThread (KernelMode, FALSE, &delay);
        state = FwpmBfeStateGet0();
        count--;
    } while (state != FWPM_SERVICE_RUNNING && count > 0);
  }

  if (state == FWPM_SERVICE_RUNNING)
    status = STATUS_SUCCESS;

  return status;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void Cleanup(void) {
  DestroyPacketQueues();

  if (engine_handle) {
    FwpmEngineClose(engine_handle);
    engine_handle = NULL;
  }

  if (outbound_callout_id) {
    FwpsCalloutUnregisterById(outbound_callout_id);
    outbound_callout_id = 0;
  }
  if (inbound_callout_id) {
    FwpsCalloutUnregisterById(inbound_callout_id);
    inbound_callout_id = 0;
  }
  if (ih_out_ipv4) {
    FwpsInjectionHandleDestroy(ih_out_ipv4);
    ih_out_ipv4 = NULL;
  }
  if (ih_out_ipv6) {
    FwpsInjectionHandleDestroy(ih_out_ipv6);
    ih_out_ipv6 = NULL;
  }
  if (ih_out_unspecified) {
    FwpsInjectionHandleDestroy(ih_out_unspecified);
    ih_out_unspecified = NULL;
  }
  if (ih_in_ipv4) {
    FwpsInjectionHandleDestroy(ih_in_ipv4);
    ih_in_ipv4 = NULL;
  }
  if (ih_in_ipv6) {
    FwpsInjectionHandleDestroy(ih_in_ipv6);
    ih_in_ipv6 = NULL;
  }
  if (ih_in_unspecified) {
    FwpsInjectionHandleDestroy(ih_in_unspecified);
    ih_in_unspecified = NULL;
  }
}

/*-----------------------------------------------------------------------------
  Called when the driver is unloading
-----------------------------------------------------------------------------*/
_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
void ShaperEvtDriverUnload(_In_ WDFDRIVER driverObject) {
  UNREFERENCED_PARAMETER(driverObject);
  driver_unloading = TRUE;

  Cleanup();
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
VOID EvtDeviceIOCtl(_In_ WDFQUEUE Queue,
                    _In_ WDFREQUEST Request,
                    _In_ size_t OutputBufferLength,
                    _In_ size_t InputBufferLength,
                    _In_ ULONG IoControlCode) {
  UNREFERENCED_PARAMETER(Queue);
  UNREFERENCED_PARAMETER(Request);
  UNREFERENCED_PARAMETER(OutputBufferLength);
  UNREFERENCED_PARAMETER(InputBufferLength);
  NTSTATUS status = STATUS_SUCCESS;
  switch (IoControlCode) {
    case SHAPER_IOCTL_DISABLE: {
      if (!ShaperDisable())
        status = STATUS_INVALID_PARAMETER;
      break;
    }
    case SHAPER_IOCTL_ENABLE: {
      if (InputBufferLength >= sizeof(SHAPER_PARAMS)) {
        WDFMEMORY pMemory;
        SHAPER_PARAMS* settings;
        status = WdfRequestRetrieveInputMemory(Request, &pMemory);
        if (NT_SUCCESS(status)) {
          settings = (SHAPER_PARAMS *)WdfMemoryGetBuffer(pMemory, NULL);
          if (settings) {
            if (!ShaperEnable(settings->plr,
                              settings->inBps,
                              settings->outBps,
                              settings->inLatency,
                              settings->outLatency,
                              settings->inBufferBytes,
                              settings->outBufferBytes)) {
              status = STATUS_INVALID_PARAMETER;
            }
          } else {
            status = STATUS_INVALID_PARAMETER;
          }
        }
      } else {
        status = STATUS_INVALID_PARAMETER;
      }
      break;
    }
    case SHAPER_IOCTL_GET_STATUS: {
      if (OutputBufferLength >= sizeof(SHAPER_STATUS)) {
        WDFMEMORY pMemory;
        SHAPER_STATUS* shaper_status;
        status = WdfRequestRetrieveOutputMemory(Request, &pMemory);
        if (NT_SUCCESS(status)) {
          shaper_status = (SHAPER_STATUS *)WdfMemoryGetBuffer(pMemory, NULL);
          if (shaper_status) {
            ShaperGetStatus(shaper_status);
            WdfRequestSetInformation(Request, sizeof(SHAPER_STATUS));
          } else {
            status = STATUS_INVALID_PARAMETER;
          }
        }
      } else {
        status = STATUS_INVALID_PARAMETER;
      }
      break;
    }
    case SHAPER_IOCTL_GET_STATS: {
      if (OutputBufferLength >= sizeof(SHAPER_STATS)) {
        WDFMEMORY pMemory;
        SHAPER_STATS* shaper_stats;
        status = WdfRequestRetrieveOutputMemory(Request, &pMemory);
        if (NT_SUCCESS(status)) {
          shaper_stats = (SHAPER_STATS *)WdfMemoryGetBuffer(pMemory, NULL);
          if (shaper_stats) {
            ShaperGetStats(shaper_stats);
            WdfRequestSetInformation(Request, sizeof(SHAPER_STATS));
          } else {
            status = STATUS_INVALID_PARAMETER;
          }
        }
      } else {
        status = STATUS_INVALID_PARAMETER;
      }
      break;
    }
    default: {
      DbgPrint("[shaper] IOCTL unknown command - %lu\n", IoControlCode);
      status = STATUS_INVALID_PARAMETER;
    }
  }
  WdfRequestComplete(Request, status);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
NTSTATUS ShaperInitDriverObjects(
    _Inout_ DRIVER_OBJECT* driverObject,
    _In_ const UNICODE_STRING* registryPath,
    _Out_ WDFDRIVER* pDriver,
    _Out_ WDFDEVICE* pDevice) {
  NTSTATUS status;
  WDF_DRIVER_CONFIG config;
  PWDFDEVICE_INIT pInit = NULL;
  DECLARE_CONST_UNICODE_STRING(ntDeviceName, SHAPER_DEVICE_NAME);
  DECLARE_CONST_UNICODE_STRING(symbolicName, SHAPER_SYMBOLIC_NAME);

  WDF_DRIVER_CONFIG_INIT(&config, WDF_NO_EVENT_CALLBACK);

  config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
  config.EvtDriverUnload = ShaperEvtDriverUnload;

  status = WdfDriverCreate(driverObject, registryPath, WDF_NO_OBJECT_ATTRIBUTES,
                           &config, pDriver);

  if (NT_SUCCESS(status)) {
    pInit = WdfControlDeviceInitAllocate(*pDriver, &SDDL_DEVOBJ_KERNEL_ONLY);
    if (pInit) {
      WdfDeviceInitSetDeviceType(pInit, FILE_DEVICE_NETWORK);
      WdfDeviceInitSetCharacteristics(pInit, FILE_DEVICE_SECURE_OPEN, FALSE);

      // Set up the interface for CreateFile/WriteFile from user mode
      status = WdfDeviceInitAssignName(pInit, &ntDeviceName);
      if (NT_SUCCESS(status))
        WdfDeviceInitAssignSDDLString(pInit, &SDDL_DEVOBJ_SYS_ALL_ADM_RWX_WORLD_RWX_RES_RWX);
      if (NT_SUCCESS(status))
        status = WdfDeviceCreate(&pInit, WDF_NO_OBJECT_ATTRIBUTES, pDevice);
      if (NT_SUCCESS(status))
        status = WdfDeviceCreateSymbolicLink(*pDevice, &symbolicName);
      if (NT_SUCCESS(status)) {
        WDF_IO_QUEUE_CONFIG queueConfig;
        WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&queueConfig, WdfIoQueueDispatchSequential);
        queueConfig.EvtIoDeviceControl = EvtDeviceIOCtl;
        status = WdfIoQueueCreate(*pDevice, &queueConfig, WDF_NO_OBJECT_ATTRIBUTES, NULL);
      }
      if (NT_SUCCESS(status))
        wdm_device = WdfDeviceWdmGetDeviceObject(*pDevice);

      if (NT_SUCCESS(status))
        WdfControlFinishInitializing(*pDevice);
      else
        WdfDeviceInitFree(pInit);
    } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
    }
  }

  return status;
}

NTSTATUS AddFilter(
    _In_ const wchar_t* filterName,
    _In_ const wchar_t* filterDesc,
    _In_ UINT64 context,
    _In_ const GUID* layerKey,
    _In_ const GUID* calloutKey) {
  NTSTATUS status = STATUS_SUCCESS;

  FWPM_FILTER filter = {0};
  FWPM_FILTER_CONDITION filterConditions[3] = {0}; 
  UINT conditionIndex;

  filter.layerKey = *layerKey;
  filter.displayData.name = (wchar_t*)filterName;
  filter.displayData.description = (wchar_t*)filterDesc;

  filter.action.type = FWP_ACTION_CALLOUT_TERMINATING;
  filter.action.calloutKey = *calloutKey;
  filter.filterCondition = filterConditions;
  filter.subLayerKey = SHAPER_SUBLAYER;
  filter.weight.type = FWP_EMPTY; // auto-weight.
  filter.rawContext = context;

  conditionIndex = 0;

  filter.numFilterConditions = conditionIndex;

  status = FwpmFilterAdd(engine_handle, &filter, NULL, NULL);

  return status;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
NTSTATUS RegisterCallout(
    _In_ const GUID* layerKey,
    _In_ const GUID* calloutKey,
    _Inout_ void* deviceObject,
    _Out_ UINT32* calloutId,
    _In_ BOOLEAN is_outbound) {
  NTSTATUS status = STATUS_SUCCESS;

  FWPS_CALLOUT sCallout = {0};
  FWPM_CALLOUT mCallout = {0};

  FWPM_DISPLAY_DATA displayData = {0};

  sCallout.calloutKey = *calloutKey;
  sCallout.classifyFn = ShaperClassify;
  sCallout.notifyFn = ShaperNotify;

  status = FwpsCalloutRegister(deviceObject, &sCallout, calloutId);
  if (NT_SUCCESS(status)) {
    displayData.name = is_outbound ? L"Shaper Outbound Callout" : L"Shaper Inbound Callout";
    displayData.description = is_outbound ? L"Traffic-shape outbound traffic" : L"Traffic-shape inbound traffic";

    mCallout.calloutKey = *calloutKey;
    mCallout.displayData = displayData;
    mCallout.applicableLayer = *layerKey;

    status = FwpmCalloutAdd(engine_handle, &mCallout, NULL, NULL);
    if (NT_SUCCESS(status)) {
      status = AddFilter(
                  is_outbound ? L"Traffic Shaper Filter (Outbound)" : L"Traffic Shaper Filter (Inbound)",
                  is_outbound ? L"Traffic-shape outbound traffic" : L"Traffic-shape inbound traffic",
                  0, layerKey, calloutKey);
    }

    if (!NT_SUCCESS(status)) {
      FwpsCalloutUnregisterById(*calloutId);
      *calloutId = 0;
    }
  }

  return status;
}

/*-----------------------------------------------------------------------------
  Register the callouts and filters for intercepting MAC layer traffic
-----------------------------------------------------------------------------*/
NTSTATUS RegisterCallouts(_Inout_ void* deviceObject) {
  NTSTATUS status = STATUS_SUCCESS;
  FWPM_SUBLAYER shaper_sublayer;

  FWPM_SESSION session = {0};
  session.flags = FWPM_SESSION_FLAG_DYNAMIC;

  status = FwpmEngineOpen(NULL, RPC_C_AUTHN_WINNT, NULL, &session, &engine_handle);
  if (NT_SUCCESS(status)) {
    status = FwpmTransactionBegin(engine_handle, 0);
    if (NT_SUCCESS(status)) {
      RtlZeroMemory(&shaper_sublayer, sizeof(FWPM_SUBLAYER)); 
      shaper_sublayer.subLayerKey = SHAPER_SUBLAYER;
      shaper_sublayer.displayData.name = L"Traffic Shaper Sub-Layer";
      shaper_sublayer.displayData.description = L"Sub-Layer for use by Traffic Shaper callouts";
      shaper_sublayer.flags = 0;
      shaper_sublayer.weight = 0;

      status = FwpmSubLayerAdd(engine_handle, &shaper_sublayer, NULL);
      if (NT_SUCCESS(status)) {
        status = RegisterCallout(&FWPM_LAYER_OUTBOUND_MAC_FRAME_ETHERNET,
                    &SHAPER_OUTBOUND_CALLOUT, deviceObject, &outbound_callout_id, TRUE);
        if (NT_SUCCESS(status)) {
          status = RegisterCallout(&FWPM_LAYER_INBOUND_MAC_FRAME_ETHERNET,
                      &SHAPER_INBOUND_CALLOUT, deviceObject, &inbound_callout_id, FALSE);
          if (NT_SUCCESS(status)) {
            status = FwpmTransactionCommit(engine_handle);
          }
        }
      }

      // Cleanup the failed transaction
      if (!NT_SUCCESS(status)) {
        FwpmTransactionAbort(engine_handle);
        _Analysis_assume_lock_not_held_(engine_handle); // Potential leak if "FwpmTransactionAbort" fails
      }
    }

    // Cleanup the engine handle if something went wrong
    if (!NT_SUCCESS(status)) {
      FwpmEngineClose(engine_handle);
      engine_handle = NULL;
    }
  }

  return status;
}

```

`driver/wfp_callout.c`:

```c
/*
Copyright 2016 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include "common.h"

// Globals
extern BOOLEAN driver_unloading;
extern HANDLE ih_out_ipv4;
extern HANDLE ih_out_ipv6;
extern HANDLE ih_out_unspecified;
extern HANDLE ih_in_ipv4;
extern HANDLE ih_in_ipv6;
extern HANDLE ih_in_unspecified;


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
_IRQL_requires_same_
void ShaperClassify(
    _In_ const FWPS_INCOMING_VALUES* inFixedValues,
    _In_ const FWPS_INCOMING_METADATA_VALUES* inMetaValues,
    _Inout_opt_ void* layerData,
    _In_opt_ const void* classifyContext,
    _In_ const FWPS_FILTER* filter,
    _In_ UINT64 flowContext,
    _Inout_ FWPS_CLASSIFY_OUT* classifyOut) {

  NT_ASSERT(filter);
  NT_ASSERT(classifyOut);

  UNREFERENCED_PARAMETER(classifyContext);
  UNREFERENCED_PARAMETER(flowContext);

  // Only bother if we can actually act on the packet
  if ((classifyOut->rights & FWPS_RIGHT_ACTION_WRITE) != 0) {
    NT_ASSERT(layerData != NULL);
    _Analysis_assume_(layerData != NULL);

    BOOLEAN packet_queued = FALSE;

    // Use the correct type of injection handle depending on the protocol
    HANDLE injection_handle = NULL;
    BOOLEAN outbound = inFixedValues->layerId == FWPS_LAYER_OUTBOUND_MAC_FRAME_ETHERNET;
    UINT typeIndex = outbound ? FWPS_FIELD_OUTBOUND_MAC_FRAME_ETHERNET_ETHER_TYPE : FWPS_FIELD_INBOUND_MAC_FRAME_ETHERNET_ETHER_TYPE;
    UINT16 etherType = inFixedValues->incomingValue[typeIndex].value.uint16;
    if (etherType == 0x86DD) {
      injection_handle = outbound ? ih_out_ipv6 : ih_in_ipv6;
    } else if (etherType == 0x8600) {
      injection_handle = outbound ? ih_out_ipv4 : ih_in_ipv4;
    } else {
      injection_handle = outbound ? ih_out_unspecified : ih_in_unspecified;
    }

    // skip packets that we re-injected, that are already being dropped or if we are quitting
    FWPS_PACKET_INJECTION_STATE packet_state = FwpsQueryPacketInjectionState(injection_handle, layerData, NULL);
    if (!driver_unloading &&
        classifyOut->actionType != FWP_ACTION_BLOCK &&
        (packet_state != FWPS_PACKET_INJECTED_BY_SELF) && 
        (packet_state != FWPS_PACKET_PREVIOUSLY_INJECTED_BY_SELF)) {
      packet_queued = ShaperQueuePacket(inFixedValues, inMetaValues, layerData, outbound, injection_handle);
    }

    if (packet_queued) {
      classifyOut->actionType = FWP_ACTION_BLOCK;
      classifyOut->rights &= ~FWPS_RIGHT_ACTION_WRITE;
      classifyOut->flags |= FWPS_CLASSIFY_OUT_FLAG_ABSORB;
    } else {
      classifyOut->actionType = FWP_ACTION_PERMIT;
      if (filter->flags & FWPS_FILTER_FLAG_CLEAR_ACTION_RIGHT)
        classifyOut->rights &= ~FWPS_RIGHT_ACTION_WRITE;
    }
  }

  return;
}

/*-----------------------------------------------------------------------------
  Empty notification function (we don't need to do anything here)
-----------------------------------------------------------------------------*/
NTSTATUS ShaperNotify(
    _In_ FWPS_CALLOUT_NOTIFY_TYPE notifyType,
    _In_ const GUID* filterKey,
    _Inout_ const FWPS_FILTER* filter) {
  UNREFERENCED_PARAMETER(notifyType);
  UNREFERENCED_PARAMETER(filterKey);
  UNREFERENCED_PARAMETER(filter);
  return STATUS_SUCCESS;
}

```

`driver/wfp_callout.h`:

```h
#pragma once

// WFP Callout entry points
void ShaperClassify(
    _In_ const FWPS_INCOMING_VALUES* inFixedValues,
    _In_ const FWPS_INCOMING_METADATA_VALUES* inMetaValues,
    _Inout_opt_ void* layerData,
    _In_opt_ const void* classifyContext,
    _In_ const FWPS_FILTER* filter,
    _In_ UINT64 flowContext,
    _Inout_ FWPS_CLASSIFY_OUT* classifyOut);

NTSTATUS ShaperNotify(
    _In_ FWPS_CALLOUT_NOTIFY_TYPE notifyType,
    _In_ const GUID* filterKey,
    _Inout_ const FWPS_FILTER* filter);

```

`exe/exe.cpp`:

```cpp
// exe.cpp : Defines the entry point for the console application.
//

#include "targetver.h"
#include <stdio.h>
#include <tchar.h>
#include <Windows.h>
#include <Shlwapi.h>

#include "../driver/interface.h"

bool Start() {
  bool ok = false;
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (service) {
      DWORD dwBytesNeeded;
      SERVICE_STATUS_PROCESS status;
      if (QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded)) {
        if (status.dwCurrentState == SERVICE_STOPPED) {
          if (StartService(service, 0, NULL)) {
            DWORD count = 0;
            do {
              QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded);
              if (status.dwCurrentState == SERVICE_START_PENDING)
                Sleep(100);
              count++;
            } while(status.dwCurrentState == SERVICE_START_PENDING && count < 600);
            if (status.dwCurrentState == SERVICE_RUNNING) {
              ok = true;
            } else {
              printf("Error waiting for service to start\n");
            }
          } else {
            printf("Failed to start the service\n");
          }
        } else {
          ok = true;
        }
      } else {
        printf("Failed to query the current service status\n");
      }
      CloseServiceHandle(service);
    } else {
      printf("Failed to open the shaper service\n");
    }
    CloseServiceHandle(scm);
  } else {
    printf("Failed to open the Service Control Manager\n");
  }
  return ok;
}

bool Install() {
  bool ok = false;
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (!service) {
      TCHAR driver_path[MAX_PATH];
      GetModuleFileName(NULL, driver_path, MAX_PATH);
      BOOL is64bit = FALSE;
      IsWow64Process(GetCurrentProcess(), &is64bit);
      if (is64bit)
        lstrcpy(PathFindFileName(driver_path), _T("shaper64.sys"));
      else
        lstrcpy(PathFindFileName(driver_path), _T("shaper32.sys"));
      service = CreateService(scm,
                              SHAPER_SERVICE_NAME,
                              SHAPER_SERVICE_DISPLAY_NAME,
                              SERVICE_ALL_ACCESS,
                              SERVICE_KERNEL_DRIVER,
                              SERVICE_DEMAND_START,
                              SERVICE_ERROR_NORMAL,
                              driver_path,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
      if (service) {
        CloseServiceHandle(service);
        ok = Start();
      } else {
        printf("Failed to install shaper driver\n");
      }
    } else {
      CloseServiceHandle(service);
      ok = Start();
    }
    CloseServiceHandle(scm);
  } else {
    printf("Failed to open the Service Control Manager\n");
  }
  return ok;
}


bool Stop(bool silent = false) {
  bool ok = false;
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (service) {
      DWORD dwBytesNeeded;
      SERVICE_STATUS_PROCESS status;
      if (QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded)) {
        if (status.dwCurrentState == SERVICE_RUNNING) {
          SERVICE_STATUS s;
          if (ControlService(service, SERVICE_CONTROL_STOP, &s)) {
            DWORD count = 0;
            do {
              QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded);
              if (status.dwCurrentState == SERVICE_STOP_PENDING)
                Sleep(100);
              count++;
            } while(status.dwCurrentState == SERVICE_STOP_PENDING && count < 600);
            if (status.dwCurrentState == SERVICE_STOPPED) {
              ok = true;
            } else if (!silent) {
              printf("Error waiting for service to stop\n");
            }
          } else if (!silent) {
            printf("Failed to stop the service\n");
          }
        } else {
          ok = true;
        }
      } else if (!silent) {
        printf("Failed to query the current service status\n");
      }
      CloseServiceHandle(service);
    } else if (!silent) {
      printf("Failed to open the shaper service\n");
    }
    CloseServiceHandle(scm);
  } else if (!silent) {
    printf("Failed to open the Service Control Manager\n");
  }
  return ok;
}

bool Remove(bool silent = false) {
  bool ok = Stop(silent);
  if (ok) {
    ok = false;
    SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
    if (scm) {
      SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
      if (service) {
        if (DeleteService(service)) {
          ok = true;
        } else if (!silent) {
          printf("DeleteService failed\n");
        }
        CloseServiceHandle(service);
      } else if (!silent) {
        printf("Failed to open the shaper service\n");
      }
      CloseServiceHandle(scm);
    } else if (!silent) {
      printf("Failed to open the Service Control Manager\n");
    }
  }
  return ok;
}


bool Set(SHAPER_PARAMS &settings) {
  bool ok = false;
  HANDLE shaper = CreateFile(SHAPER_DOS_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
  if (shaper == INVALID_HANDLE_VALUE) {
    Start();
    shaper = CreateFile(SHAPER_DOS_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
  }
  if (shaper != INVALID_HANDLE_VALUE) {
    DWORD bytesReturned = 0;
    if (DeviceIoControl(shaper, SHAPER_IOCTL_ENABLE, &settings, sizeof(settings), NULL, 0, &bytesReturned, NULL)) {
      ok = true;
    } else {
      printf("SHAPER_IOCTL_ENABLE failed: 0x%08X\n", GetLastError());
    }
    CloseHandle(shaper);
  } else {
    printf("Failed to open Traffic Shaper driver\n");
  }
  return ok;
}

bool Reset() {
  bool ok = false;
  HANDLE shaper = CreateFile(SHAPER_DOS_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
  if (shaper != INVALID_HANDLE_VALUE) {
    DWORD bytesReturned = 0;
    if (DeviceIoControl(shaper, SHAPER_IOCTL_DISABLE, NULL, 0, NULL, 0, &bytesReturned, NULL))
      ok = true;
    else
      printf("SHAPER_IOCTL_DISABLE failed: 0x%08X\n", GetLastError());
    CloseHandle(shaper);
  } else {
    printf("Failed to open Traffic Shaper driver\n");
  }
  return ok;
}

void usage() {
  printf("Usage: shaper [install|remove|set|reset] <options>\n"
         "\n"
         "  install: Installs the shaper driver and starts the service.\n"
         "  remove: Stops the service and uninstalls the driver.\n"
         "  set: Enable traffic-shaping with the supplied configuration (see set options below).\n"
         "  reset: Disable traffic-shaping.\n"
         "\n"
         " Options for set command (specified as option=value):\n"
         "  inbps: Inbound bandwidth in bits-per-second.\n"
         "  outbps: Outbound bandwidth in bits-per-second.\n"
         "  rtt: Connection latency in milliseconds (half applied inbound and half applied outbound).\n"
         "  plr: Random packet loss in percent (accurate to 0.01 percent, defaults to 0)"
         "  inbuff: Inbound buffer size in bytes (defaults to 150,000)\n"
         "  outbuff: Outbound buffer size in bytes (defaults to 150,000)\n"
         "\n"
         " Examples:\n"
         "  shaper install\n"
         "  shaper set inbps=5000000 outbps=1000000 rtt=28\n"
         "  shaper reset\n"
         "  shaper remove\n");
}

int main(int argc, char **argv) {
  bool ok = false;
  if (argc > 1) {
    DWORD bytesReturned = 0;
    if (!lstrcmpiA(argv[1], "install")) {
      Remove(true); // uninstall first in case an older version is registered
      ok = Install();
    } else if (!lstrcmpiA(argv[1], "remove")) {
      ok = Remove();
    } else if (!lstrcmpiA(argv[1], "set")) {
      ok = true;
      SHAPER_PARAMS settings;
      settings.plr = 0;
      settings.inBps = 0;
      settings.outBps = 0;
      settings.inLatency = 0;
      settings.outLatency = 0;
      settings.inBufferBytes = 150000;
      settings.outBufferBytes = 150000;
      for (int i = 2; i < argc; i++) {
        char * separator = strchr(argv[i], '=');
        if (separator) {
          separator[0] = NULL;
          const char * option = argv[i];
          const char * value = &separator[1];
          if (!strcmp(option, "inbps")) {
            settings.inBps = _atoi64(value);
          } else if (!strcmp(option, "outbps")) {
            settings.outBps = _atoi64(value);
          } else if (!strcmp(option, "rtt")) {
            unsigned long rtt = atol(value);
            settings.inLatency = rtt / 2;
            settings.outLatency = rtt / 2;
            if (rtt % 2)
              settings.inLatency += 1;
          } else if (!strcmp(option, "plr")) {
            settings.plr = (unsigned short)(atof(value) * 100.0);
          } else if (!strcmp(option, "inbuff")) {
            settings.inBufferBytes = _atoi64(value);
          } else if (!strcmp(option, "outbuff")) {
            settings.outBufferBytes = _atoi64(value);
          } else {
            ok = false;
            printf("Unrecognized option: %s\n", option);
          }
        } else {
          ok = false;
          printf("Incorrect option: %s\n", argv[i]);
        }
      }
      if (ok) {
        ok = Set(settings);
      }
    } else if (!lstrcmpiA(argv[1], "reset")) {
      ok = Reset();
    }
  }
  if (!ok) {
    usage();
  }
  return ok ? 0 : 1;
}


```

`exe/exe.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>exe</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>shaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>shaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>shaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>shaper</TargetName>
    <CodeAnalysisRuleSet>NativeMinimumRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Setupapi.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Setupapi.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Setupapi.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <PostBuildEvent>
      <Command>copy /Y $(OutDir)$(TargetName).exe $(SolutionDir)bin\$(TargetName).exe</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Setupapi.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="exe.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`exe/exe.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="exe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`exe/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`gui/CustomProfileDlg.cpp`:

```cpp
// CustomProfileDlg.cpp : implementation file
//

#include "stdafx.h"
#include "gui.h"
#include "CustomProfileDlg.h"
#include "afxdialogex.h"


// CustomProfileDlg dialog

IMPLEMENT_DYNAMIC(CustomProfileDlg, CDialogEx)

CustomProfileDlg::CustomProfileDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_CUSTOM_PROFILE, pParent)
  , m_name(_T(""))
  , m_inBps(0)
  , m_outBps(0)
  , m_rtt(0)
  , m_plr(0)
  , m_inBufferLength(0)
  , m_outBufferLen(0)
{

}

CustomProfileDlg::~CustomProfileDlg()
{
}

void CustomProfileDlg::DoDataExchange(CDataExchange* pDX)
{
  CDialogEx::DoDataExchange(pDX);
  DDX_Text(pDX, IDC_NAME, m_name);
  DDV_MaxChars(pDX, m_name, 100);
  DDX_Text(pDX, IDC_IN_BPS, m_inBps);
  DDX_Text(pDX, IDC_OUT_BPS, m_outBps);
  DDX_Text(pDX, IDC_RTT, m_rtt);
  DDV_MinMaxLong(pDX, m_rtt, 0, 60000);
  DDX_Text(pDX, IDC_PLR, m_plr);
  DDV_MinMaxDouble(pDX, m_plr, 0, 100);
  DDX_Text(pDX, IDC_IN_BUFF_LEN, m_inBufferLength);
  DDX_Text(pDX, IDC_OUT_BUFF_LEN, m_outBufferLen);
  if (pDX->m_bSaveAndValidate) {
    if (!m_name.Trim().GetLength()) {
      AfxMessageBox(L"Invalid name");
      pDX->PrepareEditCtrl(IDC_NAME);
      pDX->Fail();
    }
  }
}


BEGIN_MESSAGE_MAP(CustomProfileDlg, CDialogEx)
END_MESSAGE_MAP()


// CustomProfileDlg message handlers


void CustomProfileDlg::OnOK()
{
  
  CDialogEx::OnOK();
}

```

`gui/CustomProfileDlg.h`:

```h
#pragma once


// CustomProfileDlg dialog

class CustomProfileDlg : public CDialogEx
{
	DECLARE_DYNAMIC(CustomProfileDlg)

public:
	CustomProfileDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CustomProfileDlg();

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_CUSTOM_PROFILE };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
  CString m_name;
  ULONGLONG m_inBps;
  ULONGLONG m_outBps;
  long m_rtt;
  double m_plr;
  ULONGLONG m_inBufferLength;
  ULONGLONG m_outBufferLen;
  virtual void OnOK();
};

```

`gui/CustomProfiles.cpp`:

```cpp
#include "stdafx.h"
#include "CustomProfiles.h"


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
CustomProfiles::CustomProfiles() {
  PWSTR path;
  if (SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_CREATE, NULL, &path) == S_OK) {
    CString dir(path);
    CoTaskMemFree(path);
    dir += L"\\winShaper";
    CreateDirectory(dir, NULL);
    data_file_ = dir + L"profiles.txt";
  }
  Load();
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
CustomProfiles::~CustomProfiles() {
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CustomProfiles::Save() {
  CString out = L"";
  int count = (int)profiles_.GetCount();
  for (int i = 0; i < count; i++) {
    CString profile = profiles_[i].Serialize();
    if (!profile.IsEmpty())
      out += profile + L"\n";
  }
  if (out.GetLength()) {
    HANDLE hFile = CreateFile(data_file_, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
    if (hFile != INVALID_HANDLE_VALUE) {
      DWORD written = 0;
      DWORD len = out.GetLength() * sizeof(TCHAR);
      WriteFile(hFile, (LPCTSTR)out, len, &written, 0);
      CloseHandle(hFile);
    }
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CustomProfiles::Load() {
  if (!profiles_.IsEmpty())
    profiles_.RemoveAll();
  HANDLE hFile = CreateFile(data_file_, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
  if (hFile != INVALID_HANDLE_VALUE) {
    DWORD len = GetFileSize(hFile, NULL);
    if (len > 0) {
      DWORD buff_len = len + sizeof(TCHAR);
      TCHAR * buff = (TCHAR *)malloc(buff_len);
      if (buff) {
        memset(buff, buff_len, 0);
        DWORD bytes_read;
        if (ReadFile(hFile, buff, len, &bytes_read, 0) && len == bytes_read) {
          CString in(buff);
          int pos = 0;
          CString line = in.Tokenize(L"\n", pos);
          while (line != L"") {
            ConnectionProfile profile(line);
            if (!profile.name_.IsEmpty())
              profiles_.Add(profile);
            line = in.Tokenize(L"\n", pos);
          }
        }
        free(buff);
      }
    }
    CloseHandle(hFile);
  }
}

```

`gui/CustomProfiles.h`:

```h
#pragma once
class ConnectionProfile {
public:
  ConnectionProfile(){}
  ConnectionProfile(CString          name,
                    unsigned __int64 inBps,
                    unsigned __int64 outBps,
                    unsigned long    rtt,
                    unsigned short   plr,
                    unsigned __int64 inBufferLen,
                    unsigned __int64 outBufferLen){
    name_ = name;
    inBps_ = inBps;
    outBps_ = outBps;
    rtt_ = rtt;
    plr_ = plr;
    inBufferLen_ = inBufferLen;
    outBufferLen_ = outBufferLen;
  }
  ConnectionProfile(const ConnectionProfile &src){*this = src;}
  ConnectionProfile(CString serialized) {
    CStringArray parts;
    int pos = 0;
    CString token = serialized.Tokenize(L"\t", pos);
    while (token != L"") {
      parts.Add(token);
      token = serialized.Tokenize(L"\t", pos);
    }
    if (parts.GetCount() >= 7) {
      name_ = parts[0];
      inBps_ = _ttoi64(parts[1]);
      outBps_ = _ttoi64(parts[2]);
      rtt_ = _ttol(parts[3]);
      plr_ = _ttoi(parts[4]);
      inBufferLen_ = _ttoi64(parts[5]);
      outBufferLen_ = _ttoi64(parts[6]);
    }
  }
  ~ConnectionProfile(){}
  const ConnectionProfile &operator =(const ConnectionProfile &src) {
    name_ = src.name_;
    inBps_ = src.inBps_;
    outBps_ = src.outBps_;
    rtt_ = src.rtt_;
    plr_ = src.plr_;
    inBufferLen_ = src.inBufferLen_;
    outBufferLen_ = src.outBufferLen_;
    return src;
  }
  CString DisplayString() {
    // Format the parameters into a string that includes the name and bandwidth settings
    CString display, buff;
    display = name_ + L" (";
    if (inBps_ >= 1000000) {
      if (inBps_ % 1000000) {
        buff.Format(L"%0.1f Mbps", (double)inBps_ / 1000000.0);
      } else {
        buff.Format(L"%d Mbps", (DWORD)(inBps_ / 1000000));
      }
    } else if (inBps_ >= 1000) {
      if (inBps_ % 1000) {
        buff.Format(L"%0.1f Kbps", (double)inBps_ / 1000.0);
      } else {
        buff.Format(L"%d Kbps", (DWORD)(inBps_ / 1000));
      }
    } else {
      buff.Format(L"%d bps", (DWORD)inBps_);
    }
    display += buff + L"/";
    if (outBps_ >= 1000000) {
      if (outBps_ % 1000000) {
        buff.Format(L"%0.1f Mbps", (double)outBps_ / 1000000.0);
      } else {
        buff.Format(L"%d Mbps", (DWORD)(outBps_ / 1000000));
      }
    } else if (outBps_ >= 1000) {
      if (outBps_ % 1000) {
        buff.Format(L"%0.1f Kbps", (double)outBps_ / 1000.0);
      } else {
        buff.Format(L"%d Kbps", (DWORD)(outBps_ / 1000));
      }
    } else {
      buff.Format(L"%d bps", (DWORD)outBps_);
    }
    display += buff + L" ";
    buff.Format(L"%dms RTT", rtt_);
    display += buff;
    if (plr_ > 0) {
      buff.Format(L", %0.2f%% plr", (double)plr_ / 100.0);
      display += buff;
    }
    display += ")";
    return display;
  }
  CString Serialize() {
    CString buff;
    if (name_.GetLength() && name_.Find(L"\t") == -1)
      buff.Format(L"%s\t%I64u\t%I64u\t%lu\t%u\t%I64u\t%I64u", (LPCTSTR)name_, inBps_, outBps_, rtt_, plr_, inBufferLen_, outBufferLen_);
    return buff;
  }

  CString          name_;
  unsigned __int64 inBps_;
  unsigned __int64 outBps_;
  unsigned long    rtt_;
  unsigned short   plr_; // 0 - 10000 (hundreths)
  unsigned __int64 inBufferLen_;
  unsigned __int64 outBufferLen_;
};


class CustomProfiles {
public:
  CustomProfiles();
  ~CustomProfiles();
  void Load();
  void Save();
  CArray<ConnectionProfile> profiles_;

protected:
  CString data_file_;
};


```

`gui/CustomProfilesDlg.cpp`:

```cpp
// CustomProfilesDlg.cpp : implementation file
//

#include "stdafx.h"
#include "gui.h"
#include "CustomProfilesDlg.h"
#include "CustomProfileDlg.h"
#include "afxdialogex.h"


// CustomProfilesDlg dialog

IMPLEMENT_DYNAMIC(CustomProfilesDlg, CDialogEx)

CustomProfilesDlg::CustomProfilesDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_CUSTOM_PROFILES, pParent)
{

}

CustomProfilesDlg::~CustomProfilesDlg()
{
}

void CustomProfilesDlg::DoDataExchange(CDataExchange* pDX)
{
  CDialogEx::DoDataExchange(pDX);
  DDX_Control(pDX, IDC_LIST1, m_profileList);
  DDX_Control(pDX, IDC_EDIT, m_btnEdit);
  DDX_Control(pDX, IDC_DELETE, m_btnDelete);
}


BEGIN_MESSAGE_MAP(CustomProfilesDlg, CDialogEx)
  ON_BN_CLICKED(IDC_ADD, &CustomProfilesDlg::OnBnClickedAdd)
  ON_BN_CLICKED(IDC_EDIT, &CustomProfilesDlg::OnBnClickedEdit)
  ON_BN_CLICKED(IDC_DELETE, &CustomProfilesDlg::OnBnClickedDelete)
  ON_BN_CLICKED(IDOK, &CustomProfilesDlg::OnBnClickedOk)
  ON_LBN_SELCHANGE(IDC_LIST1, &CustomProfilesDlg::OnLbnSelchangeList1)
END_MESSAGE_MAP()


// CustomProfilesDlg message handlers
BOOL CustomProfilesDlg::OnInitDialog()
{
  CDialogEx::OnInitDialog();
  int count = (int)profiles_.profiles_.GetCount();
  for (int i = 0; i < count; i++) {
    m_profileList.InsertString(i, profiles_.profiles_[i].DisplayString());
  }
  if (count > 0) {
    m_profileList.SetCurSel(0);
    m_btnEdit.EnableWindow(TRUE);
    m_btnDelete.EnableWindow(TRUE);
  }

  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}


void CustomProfilesDlg::OnBnClickedAdd() {
  CustomProfileDlg dlg;
  dlg.m_inBufferLength = 150000;
  dlg.m_outBufferLen = 150000;
  dlg.m_plr = 0;

  if (dlg.DoModal() == IDOK) {
    ConnectionProfile profile;
    profile.name_ = dlg.m_name;
    profile.inBps_ = dlg.m_inBps;
    profile.outBps_ = dlg.m_outBps;
    profile.rtt_ = dlg.m_rtt;
    profile.plr_ = (int)(dlg.m_plr * 100.0);
    profile.inBufferLen_ = dlg.m_inBufferLength;
    profile.outBufferLen_ = dlg.m_outBufferLen;
    int index = (int)profiles_.profiles_.Add(profile);
    m_profileList.InsertString(index, profile.DisplayString());
  }
}


void CustomProfilesDlg::OnBnClickedEdit() {
  int index = m_profileList.GetCurSel();
  if (index >= 0 && index < profiles_.profiles_.GetCount()) {
    ConnectionProfile &profile = profiles_.profiles_[index];
    CustomProfileDlg dlg;
    dlg.m_name = profile.name_;
    dlg.m_inBps = profile.inBps_;
    dlg.m_outBps = profile.outBps_;
    dlg.m_rtt = profile.rtt_;
    dlg.m_plr = (double)profile.plr_ / 100.0;
    dlg.m_inBufferLength = profile.inBufferLen_;
    dlg.m_outBufferLen = profile.outBufferLen_;
    if (dlg.DoModal() == IDOK) {
      profile.name_ = dlg.m_name;
      profile.inBps_ = dlg.m_inBps;
      profile.outBps_ = dlg.m_outBps;
      profile.rtt_ = dlg.m_rtt;
      profile.plr_ = (int)(dlg.m_plr * 100.0);
      profile.inBufferLen_ = dlg.m_inBufferLength;
      profile.outBufferLen_ = dlg.m_outBufferLen;
      m_profileList.SetRedraw(FALSE);
      m_profileList.DeleteString(index);
      m_profileList.InsertString(index, profile.DisplayString());
      m_profileList.SetRedraw(TRUE);
    }
  }
}


void CustomProfilesDlg::OnBnClickedDelete() {
  int index = m_profileList.GetCurSel();
  int count = (int)profiles_.profiles_.GetCount();
  if (index >= 0 && index < count) {
    if (MessageBox(L"Are you sure you want to delete the connection:\n" + profiles_.profiles_[index].DisplayString(), 0, MB_YESNO) == IDYES) {
      count--;
      profiles_.profiles_.RemoveAt(index);
      m_profileList.DeleteString(index);
      index = max(0, index - 1);
      m_profileList.SetCurSel(index);
    }
  }
  if (profiles_.profiles_.IsEmpty()) {
    m_btnEdit.EnableWindow(FALSE);
    m_btnDelete.EnableWindow(FALSE);
  }
}


void CustomProfilesDlg::OnBnClickedOk() {
  profiles_.Save();
  CDialogEx::OnOK();
}

void CustomProfilesDlg::OnLbnSelchangeList1()
{
  m_btnEdit.EnableWindow(TRUE);
  m_btnDelete.EnableWindow(TRUE);
}

```

`gui/CustomProfilesDlg.h`:

```h
#pragma once
#include "CustomProfiles.h"
#include "afxwin.h"

// CustomProfilesDlg dialog

class CustomProfilesDlg : public CDialogEx
{
	DECLARE_DYNAMIC(CustomProfilesDlg)

public:
	CustomProfilesDlg(CWnd* pParent = NULL);   // standard constructor
	virtual ~CustomProfilesDlg();

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_CUSTOM_PROFILES };
#endif

protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()
public:
  afx_msg void OnBnClickedAdd();
  afx_msg void OnBnClickedEdit();
  afx_msg void OnBnClickedDelete();
  afx_msg void OnBnClickedOk();
  virtual BOOL OnInitDialog();

  CustomProfiles profiles_;
  CListBox m_profileList;
  CButton m_btnEdit;
  CButton m_btnDelete;
  afx_msg void OnLbnSelchangeList1();
};

```

`gui/WinShaperDlg.cpp`:

```cpp

// WinShaperDlg.cpp : implementation file
//

#include "stdafx.h"
#include "gui.h"
#include "WinShaperDlg.h"
#include "afxdialogex.h"
#include "CustomProfilesDlg.h"
#include "../driver/interface.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

extern HINSTANCE g_hInstance;

// CAboutDlg dialog used for App About

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_ABOUTBOX };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	DECLARE_MESSAGE_MAP()
public:
  afx_msg void OnNMClickSyslink1(NMHDR *pNMHDR, LRESULT *pResult);
  afx_msg void OnNMReturnSyslink1(NMHDR *pNMHDR, LRESULT *pResult);
};

CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
  ON_NOTIFY(NM_CLICK, IDC_SYSLINK1, &CAboutDlg::OnNMClickSyslink1)
  ON_NOTIFY(NM_RETURN, IDC_SYSLINK1, &CAboutDlg::OnNMReturnSyslink1)
END_MESSAGE_MAP()


// CWinShaperDlg dialog



CWinShaperDlg::CWinShaperDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(IDD_GUI_DIALOG, pParent)
  ,enabled_(false)
  ,driver_interface_(INVALID_HANDLE_VALUE)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CWinShaperDlg::DoDataExchange(CDataExchange* pDX)
{
  CDialogEx::DoDataExchange(pDX);
  DDX_Control(pDX, IDC_CONNECTION_PROFILES, m_profileList);
  DDX_Control(pDX, IDC_ENABLE, m_btnEnable);
  DDX_Control(pDX, IDC_INBOUND_QUEUE, m_inboundQueue);
  DDX_Control(pDX, IDC_OUTBOUND_QUEUE, m_outboundQueue);
}

BEGIN_MESSAGE_MAP(CWinShaperDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
  ON_CBN_SELCHANGE(IDC_CONNECTION_PROFILES, &CWinShaperDlg::OnCbnSelchangeConnectionProfiles)
  ON_BN_CLICKED(IDC_ENABLE, &CWinShaperDlg::OnBnClickedEnable)
  ON_WM_CLOSE()
  ON_WM_TIMER()
END_MESSAGE_MAP()


// CWinShaperDlg message handlers

BOOL CWinShaperDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	PopulateConnectionList();

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWinShaperDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWinShaperDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWinShaperDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void CWinShaperDlg::OnOK()
{
}


void CWinShaperDlg::OnCancel()
{
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::OnCbnSelchangeConnectionProfiles() {
  int total = (int)(connection_profiles_.GetCount() + custom_.profiles_.GetCount());
  int selected = m_profileList.GetCurSel();
  if (selected >= total) {
    CustomProfilesDlg dlg;
    dlg.DoModal();
    PopulateConnectionList();
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::OnBnClickedEnable() {
  if (enabled_)
    Disable();
  else
    Enable();
  if (enabled_) {
    m_btnEnable.SetWindowTextW(L"&Disable");
    m_profileList.EnableWindow(FALSE);
    m_inboundQueue.EnableWindow(TRUE);
    m_inboundQueue.SetState(PBST_PAUSED);
    m_outboundQueue.EnableWindow(TRUE);
    m_outboundQueue.SetState(PBST_PAUSED);
    UpdateStatus();
  } else {
    m_btnEnable.SetWindowTextW(L"&Enable");
    m_profileList.EnableWindow(TRUE);
    m_inboundQueue.SetPos(0);
    m_inboundQueue.EnableWindow(FALSE);
    m_outboundQueue.SetPos(0);
    m_outboundQueue.EnableWindow(FALSE);
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::PopulateConnectionList() {
  int selected = m_profileList.GetCurSel();
  if (selected == CB_ERR)
    selected = 0;

  LoadProfiles();
  int total = 0;
  m_profileList.SetRedraw(FALSE);
  m_profileList.ResetContent();
  int count = (int)connection_profiles_.GetCount();
  for (int i = 0; i < count; i++) {
    m_profileList.InsertString(total, connection_profiles_[i].DisplayString());
    total++;
  }
  custom_.Load();
  count = (int)custom_.profiles_.GetCount();
  for (int i = 0; i < count; i++) {
    m_profileList.InsertString(total, custom_.profiles_[i].DisplayString());
    total++;
  }
  m_profileList.InsertString(total, L"Edit...");
  m_profileList.SetRedraw(TRUE);

  if (selected >= total - 1)
    selected = 0;
  m_profileList.SetCurSel(selected);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::LoadProfiles() {
  connection_profiles_.RemoveAll();
  connection_profiles_.Add(ConnectionProfile(L"Cable", 5000000, 1000000, 28, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"DSL",   1500000, 384000,  50, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"FIOS",  20000000, 5000000, 4, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"56K Dial-Up",  49000, 30000, 120, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile LTE", 12000000, 12000000, 70, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile 3G - Typical", 1600000, 768000, 300, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile 3G - Fast", 1600000, 768000, 150, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile 3G - Slow", 780000, 330000, 200, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile 2G", 280000, 256000, 800, 0, 150000, 150000));
  connection_profiles_.Add(ConnectionProfile(L"Mobile EDGE", 240000, 200000, 840, 0, 150000, 150000));
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::Enable() {
  int stock_count = (int)connection_profiles_.GetCount();
  int custom_count = (int)custom_.profiles_.GetCount();
  int index = m_profileList.GetCurSel();
  if (index >= 0 && index < stock_count + custom_count) {
    if (Install()) {
      if (Start()) {
        if (driver_interface_ == INVALID_HANDLE_VALUE)
          driver_interface_ = CreateFile(SHAPER_DOS_NAME, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);
        if (driver_interface_ != INVALID_HANDLE_VALUE) {
          ConnectionProfile profile;
          if (index < stock_count)
            profile = connection_profiles_[index];
          else
            profile = custom_.profiles_[index - stock_count];
          DWORD bytesReturned = 0;
          SHAPER_PARAMS settings;
          settings.plr = profile.plr_;
          settings.inBps = profile.inBps_;
          settings.outBps = profile.outBps_;
          settings.inLatency = profile.rtt_ / 2;
          settings.outLatency = settings.inLatency;
          if (profile.rtt_ % 2)
            settings.inLatency++;
          settings.inBufferBytes = profile.inBufferLen_;
          settings.outBufferBytes = profile.outBufferLen_;
          if (DeviceIoControl(driver_interface_, SHAPER_IOCTL_ENABLE, &settings, sizeof(settings), NULL, 0, &bytesReturned, NULL)) {
            SetTimer(1, 500, NULL);
            enabled_ = true;
          } else {
            Error(L"Failed to enable traffic-shaping\n");
          }
        } else {
          Error(L"Failed to connect to the traffic-shaper driver\n");
        }
      }
    }
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::Disable() {
  KillTimer(1);
  m_inboundQueue.SetPos(0);
  m_outboundQueue.SetPos(0);
  if (driver_interface_ != INVALID_HANDLE_VALUE) {
    DWORD bytesReturned = 0;
    if (DeviceIoControl(driver_interface_, SHAPER_IOCTL_DISABLE, NULL, 0, NULL, 0, &bytesReturned, NULL))
      enabled_ = false;
    CloseHandle(driver_interface_);
    driver_interface_ = INVALID_HANDLE_VALUE;
  } else {
    enabled_ = false;
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::OnClose() {
  Uninstall();
  CDialogEx::OnOK();
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
bool CWinShaperDlg::Install() {
  bool installed = false;
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (!service) {
      if (driver_path_.IsEmpty())
        driver_path_ = ExtractDriver();
      if (!driver_path_.IsEmpty()) {
        service = CreateService(scm,
                                SHAPER_SERVICE_NAME,
                                SHAPER_SERVICE_DISPLAY_NAME,
                                SERVICE_ALL_ACCESS,
                                SERVICE_KERNEL_DRIVER,
                                SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL,
                                driver_path_,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
        if (service) {
          installed = true;
          CloseServiceHandle(service);
        } else {
          Error(L"Failed to install traffic-shaper driver\n");
        }
      } else {
        Error(L"Failed to extract the traffic-shaper driver\n");
      }
    } else {
      installed = true;
      CloseServiceHandle(service);
    }
    CloseServiceHandle(scm);
  } else {
    Error(L"Failed to open the Service Control Manager");
  }
  return installed;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::Uninstall() {
  Disable();
  Stop();
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (service) {
      if (!DeleteService(service))
        Error(L"Failed to uninstall the driver");
      CloseServiceHandle(service);
    }
    CloseServiceHandle(scm);
  } else if (!driver_path_.IsEmpty()) {
    Error(L"Failed to open the Service Control Manager to uninstall the driver");
  }
  if (!driver_path_.IsEmpty())
    DeleteFile(driver_path_);
  driver_path_.Empty();
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
CString CWinShaperDlg::ExtractDriver() {
  CString driver_file;
  PWSTR path;
  if (SHGetKnownFolderPath(FOLDERID_LocalAppData, KF_FLAG_CREATE, NULL, &path) == S_OK) {
    CString file(path);
    CoTaskMemFree(path);
    file += "\\winShaper.sys";
    DeleteFile(file);

    BOOL is64bit = FALSE;
    IsWow64Process(GetCurrentProcess(), &is64bit);
    UINT resource_id = is64bit ? RC_SHAPER_64 : RC_SHAPER_32;
    HRSRC resource = FindResource(g_hInstance, MAKEINTRESOURCE(resource_id), RT_RCDATA);
    if (resource) {
      HGLOBAL resource_handle = LoadResource(NULL, resource);
      if (resource_handle) {
        LPBYTE driver_bits = (LPBYTE)LockResource(resource_handle);
        DWORD len = SizeofResource(NULL, resource);
        if (driver_bits && len) {
          HANDLE hFile = CreateFile(file, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, 0, 0);
          if (hFile != INVALID_HANDLE_VALUE) {
            DWORD written = 0;
            if (WriteFile(hFile, driver_bits, len, &written, 0) && written == len) {
              driver_file = file;
            }
            CloseHandle(hFile);
          }
        }
      }
    }
  }
  return driver_file;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
bool CWinShaperDlg::Start() {
  bool running = false;
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (service) {
      DWORD dwBytesNeeded;
      SERVICE_STATUS_PROCESS status;
      if (QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded)) {
        if (status.dwCurrentState == SERVICE_STOPPED) {
          if (StartService(service, 0, NULL)) {
            DWORD count = 0;
            do {
              QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded);
              if (status.dwCurrentState == SERVICE_START_PENDING)
                Sleep(100);
              count++;
            } while(status.dwCurrentState == SERVICE_START_PENDING && count < 600);
            if (status.dwCurrentState == SERVICE_RUNNING)
              running = true;
            else
              Error(L"Error waiting for service to start");
          } else {
            Error(L"Failed to start the service");
          }
        } else {
          running = true;
        }
      } else {
        Error(L"Failed to query the current service status");
      }
      CloseServiceHandle(service);
    } else {
      Error(L"Failed to open the shaper service to start the driver");
    }
    CloseServiceHandle(scm);
  } else {
    Error(L"Failed to open the Service Control Manager to start the driver");
  }
  return running;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::Stop() {
  SC_HANDLE scm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); 
  if (scm) {
    SC_HANDLE service = OpenService(scm, SHAPER_SERVICE_NAME, SERVICE_ALL_ACCESS); 
    if (service) {
      DWORD dwBytesNeeded;
      SERVICE_STATUS_PROCESS status;
      if (QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded)) {
        if (status.dwCurrentState == SERVICE_RUNNING) {
          SERVICE_STATUS s;
          if (ControlService(service, SERVICE_CONTROL_STOP, &s)) {
            DWORD count = 0;
            do {
              QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO, (LPBYTE)&status, sizeof(SERVICE_STATUS_PROCESS), &dwBytesNeeded);
              if (status.dwCurrentState == SERVICE_STOP_PENDING)
                Sleep(100);
              count++;
            } while(status.dwCurrentState == SERVICE_STOP_PENDING && count < 10);
          }
        }
      }
      CloseServiceHandle(service);
    }
    CloseServiceHandle(scm);
  }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::Error(CString message) {
  MessageBox(message);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CAboutDlg::OnNMClickSyslink1(NMHDR *pNMHDR, LRESULT *pResult)
{
  ShellExecute(NULL, L"open", L"https://github.com/WPO-Foundation/win-shaper",NULL, NULL,SW_SHOWNORMAL);
  *pResult = 0;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CAboutDlg::OnNMReturnSyslink1(NMHDR *pNMHDR, LRESULT *pResult)
{
  ShellExecute(NULL, L"open", L"https://github.com/WPO-Foundation/win-shaper",NULL, NULL,SW_SHOWNORMAL);
  *pResult = 0;
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::OnTimer(UINT_PTR nIDEvent)
{
  UpdateStatus();
  CDialogEx::OnTimer(nIDEvent);
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
void CWinShaperDlg::UpdateStatus() {
  if (enabled_ && driver_interface_ != INVALID_HANDLE_VALUE) {
    DWORD bytesReturned = 0;
    SHAPER_STATUS status;
    if (DeviceIoControl(driver_interface_, SHAPER_IOCTL_GET_STATUS, NULL, 0, &status, sizeof(status), &bytesReturned, NULL) && bytesReturned >= sizeof(status)) {
      int pct = 0;
      if (status.params.inBufferBytes > 0)
        pct = (int)((status.inQueuedBytes * 100LL) / status.params.inBufferBytes);
      m_inboundQueue.SetPos(pct);
      pct = 0;
      if (status.params.outBufferBytes > 0)
        pct = (int)((status.outQueuedBytes * 100LL) / status.params.outBufferBytes);
      m_outboundQueue.SetPos(pct);
    }
  }
}

```

`gui/WinShaperDlg.h`:

```h

// WinShaperDlg.h : header file
//

#pragma once
#include "afxwin.h"
#include "CustomProfiles.h"
#include "afxcmn.h"

// CWinShaperDlg dialog
class CWinShaperDlg : public CDialogEx
{
// Construction
public:
	CWinShaperDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
#ifdef AFX_DESIGN_TIME
	enum { IDD = IDD_GUI_DIALOG };
#endif

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support


// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	DECLARE_MESSAGE_MAP()
public:
  afx_msg void OnCbnSelchangeConnectionProfiles();
  afx_msg void OnBnClickedEnable();
protected:
  void PopulateConnectionList();
  void LoadProfiles();
  void Enable();
  void Disable();
  bool Install();
  void Uninstall();
  bool Start();
  void Stop();
  CString ExtractDriver();
  void Error(CString message);
  void UpdateStatus();

  bool enabled_;
  CComboBox m_profileList;
  CButton m_btnEnable;
  CArray<ConnectionProfile> connection_profiles_;
  virtual void OnOK();
  virtual void OnCancel();
  CString driver_path_;
  HANDLE  driver_interface_;
  CustomProfiles custom_;
public:
  afx_msg void OnClose();
  afx_msg void OnTimer(UINT_PTR nIDEvent);
  CProgressCtrl m_inboundQueue;
  CProgressCtrl m_outboundQueue;
};

```

`gui/gui.cpp`:

```cpp

// gui.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "gui.h"
#include "WinShaperDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CWinShaperApp

BEGIN_MESSAGE_MAP(CWinShaperApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()


// CWinShaperApp construction

CWinShaperApp::CWinShaperApp()
{
  SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_SYSTEM32);

	// support Restart Manager
	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}


// The one and only CWinShaperApp object

CWinShaperApp theApp;
HINSTANCE g_hInstance = NULL;


// CWinShaperApp initialization

BOOL CWinShaperApp::InitInstance()
{
	// InitCommonControlsEx() is required on Windows XP if an application
	// manifest specifies use of ComCtl32.dll version 6 or later to enable
	// visual styles.  Otherwise, any window creation will fail.
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// Set this to include all the common control classes you want to use
	// in your application.
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);

	CWinApp::InitInstance();


	// Create the shell manager, in case the dialog contains
	// any shell tree view or shell list view controls.
	CShellManager *pShellManager = new CShellManager;

	// Activate "Windows Native" visual manager for enabling themes in MFC controls
	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	// of your final executable, you should remove from the following
	// the specific initialization routines you do not need
	// Change the registry key under which our settings are stored
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

  g_hInstance = theApp.m_hInstance;
	CWinShaperDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}
	else if (nResponse == -1)
	{
		TRACE(traceAppMsg, 0, "Warning: dialog creation failed, so application is terminating unexpectedly.\n");
		TRACE(traceAppMsg, 0, "Warning: if you are using MFC controls on the dialog, you cannot #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS.\n");
	}

	// Delete the shell manager created above.
	if (pShellManager != NULL)
	{
		delete pShellManager;
	}

#ifndef _AFXDLL
	ControlBarCleanUp();
#endif

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}


```

`gui/gui.h`:

```h

// gui.h : main header file for the PROJECT_NAME application
//

#pragma once

#ifndef __AFXWIN_H__
	#error "include 'stdafx.h' before including this file for PCH"
#endif

#include "resource.h"		// main symbols


// CWinShaperApp:
// See gui.cpp for the implementation of this class
//

class CWinShaperApp : public CWinApp
{
public:
	CWinShaperApp();

// Overrides
public:
	virtual BOOL InitInstance();

// Implementation

	DECLARE_MESSAGE_MAP()
};

extern CWinShaperApp theApp;
```

`gui/gui.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "afxres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""afxres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n"
    "LANGUAGE 9, 1\r\n"
    "#include ""res\\gui.rc2""  // non-Microsoft Visual C++ edited resources\r\n"
    "#include ""afxres.rc""      // Standard components\r\n"
    "#if !defined(_AFXDLL)\r\n"
    "#include ""afxribbon.rc""   // MFC ribbon and control bar resources\r\n"
    "#endif\r\n"
    "#endif\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON                    "res\\gui.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOGEX 0, 0, 223, 108
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About winShaper"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LTEXT           "winShaper 1.0",IDC_STATIC,7,7,114,8,SS_NOPREFIX
    DEFPUSHBUTTON   "OK",IDOK,166,87,50,14,WS_GROUP
    CONTROL         "winShaper is UI for WebPageTest's open source packet-level traffic-shaping network filter. \n\nThe UI and driver projects are on GitHub:\n<a>https://github.com/WPO-Foundation/win-shaper</a>",IDC_SYSLINK1,
                    "SysLink",WS_TABSTOP,7,25,209,45
END

IDD_GUI_DIALOG DIALOGEX 0, 0, 263, 62
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW
CAPTION "Windows Network Shaper"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    COMBOBOX        IDC_CONNECTION_PROFILES,7,18,249,118,CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL | WS_TABSTOP
    LTEXT           "Connection Profile:",IDC_STATIC,7,7,62,8
    DEFPUSHBUTTON   "Enable",IDC_ENABLE,199,35,57,20
    CONTROL         "",IDC_INBOUND_QUEUE,"msctls_progress32",PBS_SMOOTH | WS_DISABLED,70,36,113,8
    LTEXT           "Inbound Queue:",IDC_STATIC,7,36,54,8
    LTEXT           "Outbound Queue:",IDC_STATIC,7,46,59,8
    CONTROL         "",IDC_OUTBOUND_QUEUE,"msctls_progress32",PBS_SMOOTH | WS_DISABLED,70,46,113,8
END

IDD_CUSTOM_PROFILES DIALOGEX 0, 0, 309, 268
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Custom Profiles"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,252,228,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,252,247,50,14
    LISTBOX         IDC_LIST1,7,7,238,254,LBS_SORT | LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "&Add",IDC_ADD,252,7,50,14
    PUSHBUTTON      "&Delete",IDC_DELETE,252,45,50,14,WS_DISABLED
    PUSHBUTTON      "&Edit",IDC_EDIT,252,26,50,14,WS_DISABLED
END

IDD_CUSTOM_PROFILE DIALOGEX 0, 0, 205, 157
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Custom Profile"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,94,136,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,148,136,50,14
    LTEXT           "Name:",IDC_STATIC,7,9,37,11
    EDITTEXT        IDC_NAME,35,7,161,12,ES_AUTOHSCROLL
    LTEXT           "Bandwidth in:",IDC_STATIC,7,25,59,11
    LTEXT           "Bandwidth out:",IDC_STATIC,7,41,59,11
    LTEXT           "Latency:",IDC_STATIC,7,57,59,11
    LTEXT           "Packet Loss:",IDC_STATIC,7,73,59,11
    LTEXT           "Inbound Buffer Size:",IDC_STATIC,7,89,69,11
    LTEXT           "Outbound Buffer Size:",IDC_STATIC,7,105,77,11
    LTEXT           "Bytes",IDC_STATIC,145,105,43,11
    LTEXT           "Bytes",IDC_STATIC,145,89,43,11
    LTEXT           "%",IDC_STATIC,145,73,43,11
    LTEXT           "milliseconds",IDC_STATIC,145,57,43,11
    LTEXT           "bits per second",IDC_STATIC,145,41,57,11
    LTEXT           "bits per second",IDC_STATIC,145,25,57,11
    EDITTEXT        IDC_IN_BPS,60,23,82,12,ES_RIGHT | ES_AUTOHSCROLL | ES_NUMBER
    EDITTEXT        IDC_OUT_BPS,60,39,82,12,ES_RIGHT | ES_AUTOHSCROLL | ES_NUMBER
    EDITTEXT        IDC_RTT,108,55,34,12,ES_RIGHT | ES_AUTOHSCROLL | ES_NUMBER
    EDITTEXT        IDC_PLR,108,71,34,12,ES_RIGHT | ES_AUTOHSCROLL
    EDITTEXT        IDC_IN_BUFF_LEN,79,87,64,12,ES_RIGHT | ES_AUTOHSCROLL | ES_NUMBER
    EDITTEXT        IDC_OUT_BUFF_LEN,79,103,64,12,ES_RIGHT | ES_AUTOHSCROLL | ES_NUMBER
END


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,2
 PRODUCTVERSION 1,0,0,2
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "WebPageTest LLC"
            VALUE "FileDescription", "winShaper"
            VALUE "FileVersion", "1.0.0.2"
            VALUE "InternalName", "winShaper.exe"
            VALUE "LegalCopyright", "(c) WebPageTest LLC.  All rights reserved."
            VALUE "OriginalFilename", "winShaper.exe"
            VALUE "ProductName", "Windows Traffic Shaper"
            VALUE "ProductVersion", "1.0.0.2"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 216
        TOPMARGIN, 7
        BOTTOMMARGIN, 101
    END

    IDD_GUI_DIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 256
        TOPMARGIN, 7
        BOTTOMMARGIN, 55
    END

    IDD_CUSTOM_PROFILES, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 302
        TOPMARGIN, 7
        BOTTOMMARGIN, 261
    END

    IDD_CUSTOM_PROFILE, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 198
        TOPMARGIN, 7
        BOTTOMMARGIN, 150
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_GUI_DIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_ABOUTBOX AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_CUSTOM_PROFILES AFX_DIALOG_LAYOUT
BEGIN
    0
END

IDD_CUSTOM_PROFILE AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_ABOUTBOX            "&About winShaper..."
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1
#include "res\gui.rc2"  // non-Microsoft Visual C++ edited resources
#include "afxres.rc"      // Standard components
#if !defined(_AFXDLL)
#include "afxribbon.rc"   // MFC ribbon and control bar resources
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`gui/gui.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}</ProjectGuid>
    <RootNamespace>gui</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
    <Keyword>MFCProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>winShaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <TargetName>winShaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>winShaper</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>winShaper</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <PostBuildEvent>
      <Command>cmd /c "$(OutDir)sign.cmd"</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Signing Binary</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <ValidateAllParameters>true</ValidateAllParameters>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="CustomProfileDlg.h" />
    <ClInclude Include="CustomProfiles.h" />
    <ClInclude Include="CustomProfilesDlg.h" />
    <ClInclude Include="gui.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="WinShaperDlg.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="CustomProfileDlg.cpp" />
    <ClCompile Include="CustomProfiles.cpp" />
    <ClCompile Include="CustomProfilesDlg.cpp" />
    <ClCompile Include="gui.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WinShaperDlg.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="gui.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="res\gui.rc2" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\gui.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
  <ProjectExtensions>
    <VisualStudio>
      <UserProperties RESOURCE_FILE="gui.rc" />
    </VisualStudio>
  </ProjectExtensions>
</Project>
```

`gui/gui.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WinShaperDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CustomProfilesDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CustomProfiles.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CustomProfileDlg.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gui.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinShaperDlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CustomProfilesDlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CustomProfiles.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CustomProfileDlg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="gui.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="res\gui.rc2">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Image Include="res\gui.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`gui/res/gui.rc2`:

```rc2
//
// gui.RC2 - resources Microsoft Visual C++ does not edit directly
//

#ifdef APSTUDIO_INVOKED
#error this file is not editable by Microsoft Visual C++
#endif //APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
// Add manually edited resources here...
RC_SHAPER_32  RCDATA "..\\bin\\shaper32.sys"
RC_SHAPER_64  RCDATA "..\\bin\\shaper64.sys"
/////////////////////////////////////////////////////////////////////////////

```

`gui/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by gui.rc
//
#define IDC_DELETE                      4
#define IDC_EDIT                        5
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_GUI_DIALOG                  102
#define IDR_MAINFRAME                   128
#define IDD_CUSTOM_PROFILES             131
#define IDD_DIALOG1                     133
#define IDD_CUSTOM_PROFILE              133
#define RC_SHAPER_32                    300
#define RC_SHAPER_64                    301
#define IDC_CONNECTION_PROFILES         1001
#define IDC_ENABLE                      1002
#define IDC_SYSLINK1                    1004
#define IDC_LIST1                       1005
#define IDC_ADD                         1007
#define IDC_INBOUND_QUEUE               1008
#define IDC_OUTBOUND_QUEUE              1009
#define IDC_NAME                        1009
#define IDC_IN_BPS                      1010
#define IDC_OUT_BPS                     1011
#define IDC_RTT                         1012
#define IDC_PLR                         1013
#define IDC_IN_BUFF_LEN                 1014
#define IDC_OUT_BUFF_LEN                1015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`gui/stdafx.cpp`:

```cpp

// stdafx.cpp : source file that includes just the standard includes
// gui.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"



```

`gui/stdafx.h`:

```h

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

//#ifndef VC_EXTRALEAN
//#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers
//#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions





#ifndef _AFX_NO_OLE_SUPPORT
#include <afxdtctl.h>           // MFC support for Internet Explorer 4 Common Controls
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcontrolbars.h>     // MFC support for ribbons and control bars









#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif



```

`gui/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
#include <winsdkver.h>
#define WINVER 0x0603  
#define _WIN32_WINNT 0x0603  
#include <SDKDDKVer.h>

```

`shaper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shaper", "driver\shaper.vcxproj", "{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}"
	ProjectSection(ProjectDependencies) = postProject
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9} = {124E7C05-F022-4A67-AB2F-20B1C0D66EF9}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "exe", "exe\exe.vcxproj", "{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gui", "gui\gui.vcxproj", "{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}"
	ProjectSection(ProjectDependencies) = postProject
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B} = {5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x64.ActiveCfg = Debug|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x64.Build.0 = Debug|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x64.Deploy.0 = Debug|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x86.ActiveCfg = Debug|Win32
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x86.Build.0 = Debug|Win32
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Debug|x86.Deploy.0 = Debug|Win32
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x64.ActiveCfg = Release|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x64.Build.0 = Release|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x64.Deploy.0 = Release|x64
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x86.ActiveCfg = Release|Win32
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x86.Build.0 = Release|Win32
		{5D2037F7-4766-4CEB-AA18-1DAFBBB60B7B}.Release|x86.Deploy.0 = Release|Win32
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Debug|x64.ActiveCfg = Debug|x64
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Debug|x64.Build.0 = Debug|x64
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Debug|x86.ActiveCfg = Debug|Win32
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Debug|x86.Build.0 = Debug|Win32
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Release|x64.ActiveCfg = Release|x64
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Release|x64.Build.0 = Release|x64
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Release|x86.ActiveCfg = Release|Win32
		{124E7C05-F022-4A67-AB2F-20B1C0D66EF9}.Release|x86.Build.0 = Release|Win32
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Debug|x64.ActiveCfg = Debug|x64
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Debug|x64.Build.0 = Debug|x64
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Debug|x86.ActiveCfg = Debug|Win32
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Debug|x86.Build.0 = Debug|Win32
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Release|x64.ActiveCfg = Release|x64
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Release|x86.ActiveCfg = Release|Win32
		{7DE1E0E7-CB08-46D8-BC29-C8BE2AECF6C4}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```