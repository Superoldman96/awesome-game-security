Project Path: arc_gmh5225_nohv_w283jor8

Source Tree:

```txt
arc_gmh5225_nohv_w283jor8
├── LICENSE
├── README.md
├── extern
│   └── ia32-doc
├── nohv
│   ├── cpuid.cpp
│   ├── cr0.cpp
│   ├── cr3.cpp
│   ├── cr4.cpp
│   ├── debug.cpp
│   ├── detections.h
│   ├── main.cpp
│   ├── msr.cpp
│   ├── nohv.vcxproj
│   ├── nohv.vcxproj.filters
│   ├── nohv.vcxproj.user
│   ├── timing.cpp
│   ├── vmx-asm.asm
│   ├── vmx.cpp
│   ├── xsetbv-asm.asm
│   └── xsetbv.cpp
└── nohv.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 jono

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# nohv

`nohv` is a kernel driver for detecting Intel VT-x hypervisors. It is useful for benchmarking your hypervisor against common vm-detections.

## Usage

To clone the repo:

```powershell
git clone --recursive https://github.com/jonomango/nohv.git
```

`nohv` is a Windows driver built with MSVC. It requires 
[Visual Studio](https://visualstudio.microsoft.com/downloads/) and the
[WDK](https://docs.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk) for compilation.

Once compiled, `nohv.sys` must be loaded with SEH support. This means that you can't manual map 
the driver (unless you're a wizard) since it'll crash the moment an exception is thrown. I recommend 
restarting Windows while holding SHIFT and disabling Driver Signature Enforcement, then load the
driver normally ([OSR Loader](https://www.osronline.com/article.cfm%5Earticle=157.htm) if you're lazy) 
and hope you don't BSOD :smiley:.

## Remarks

This is a fairly old project of mine and it's missing a lot of common detections (such as 
[NMI checks](https://www.unknowncheats.me/forum/c-and-c-/390593-vm-escape-via-nmi.html)). Also this
**WILL** bluescreen you if your hypervisor sucks. Make sure to test this **BEFORE** loading your
hypervisor, as well as after.

```

`nohv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31313.79
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "nohv", "nohv\nohv.vcxproj", "{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Debug|x64.ActiveCfg = Debug|x64
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Debug|x64.Build.0 = Debug|x64
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Debug|x64.Deploy.0 = Debug|x64
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Release|x64.ActiveCfg = Release|x64
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Release|x64.Build.0 = Release|x64
		{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}.Release|x64.Deploy.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F6386B24-503E-4E5F-B62A-4BB5772718C2}
	EndGlobalSection
EndGlobal

```

`nohv/cpuid.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This detection checks to see if the hypervisor-present bit
// is set in CPUID leaf 0x1.
bool cpuid_detected_1() {
  cpuid_eax_01 cpuid_01;
  __cpuid(reinterpret_cast<int*>(&cpuid_01), 1);

  // bit 31 of ECX is the hypervisor present bit
  return cpuid_01.cpuid_feature_information_ecx.flags & (1 << 31);
}


```

`nohv/cr0.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This detection checks to see if the hypervisor properly handles
// the guest modifying CR0.NE, which is usually reserved during VMX-operation.
bool cr0_detected_1() {
  _disable();

  cr0 curr_cr0;
  curr_cr0.flags = __readcr0();

  __try {
    // flip CR0.NE
    auto test_cr0 = curr_cr0;
    test_cr0.numeric_error = !test_cr0.numeric_error;
    __writecr0(test_cr0.flags);

    // check to see if the write actually went through
    if (__readcr0() != test_cr0.flags) {
      // restore CR0
      __writecr0(curr_cr0.flags);

      _enable();
      return true;
    }

    // restore CR0
    __writecr0(curr_cr0.flags);
  }
  __except (1) {
    _enable();
    return true;
  }

  _enable();
  return false;
}

// This detection tries to set reserved bits in CR0 (bits 63:32)
// that should trigger an exception.
// 
// Vol3[2.5(Control Registers)]
bool cr0_detected_2() {
  _disable();

  cr0 curr_cr0;
  curr_cr0.flags = __readcr0();

  for (int i = 32; i < 64; ++i) {
    __try {
      auto test_cr0 = curr_cr0;

      // set a reserved bit
      test_cr0.flags |= (1ull << i);

      // flip CR0.NE so that a vm-exit is triggered
      test_cr0.numeric_error = !test_cr0.numeric_error;

      // this should trigger an exception
      __writecr0(test_cr0.flags);

      // restore CR0 after the hypervisor mucked it
      __writecr0(curr_cr0.flags);

      _enable();
      return true;
    } __except (1) {
      // maybe the write went through even though an exception was raised?
      if (curr_cr0.flags != __readcr0()) {
        // restore CR0 after the hypervisor mucked it
        __writecr0(curr_cr0.flags);

        _enable();
        return true;
      }
    }
  }

  _enable();
  return false;
}


```

`nohv/cr3.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This function tries to detect hypervisors that don't properly check
// reserved bits in CR3 (aka bits [63:MAXPHYSADDR]).
// 
// Vol3[26.3.1.1(Checks on Guest Control Registers, Debug Registers, and MSRs)]
bool cr3_detected_1() {
  _disable();

  cr3 curr_cr3;
  curr_cr3.flags = __readcr3();

  cpuid_eax_80000008 cpuid_80000008;
  __cpuid(reinterpret_cast<int*>(&cpuid_80000008), 0x80000008);

  // try to set every reserved bit (besides last one, theres a seperate test for that)
  for (int i = cpuid_80000008.eax.number_of_linear_address_bits; i < 63; ++i) {
    __try {
      auto test_cr3 = curr_cr3;
      test_cr3.flags |= (1ull << i);
      __writecr3(test_cr3.flags);

      // restore old CR3 after hypervisor pooped on it
      __writecr3(curr_cr3.flags);

      // hypervisor should've raised an exception >:(
      _enable();

      return true;
    } __except (1) {
      // maybe the write passed through even though an exception was raised?
      if (__readcr3() != curr_cr3.flags) {
        // restore old CR3 after hypervisor pooped on it
        __writecr3(curr_cr3.flags);

        _enable();
        return true;
      }
    }
  }

  _enable();
  return false;
}

// This function tries to detect hypervisors that don't properly ignore
// bit 63 of CR3 while CR4.PCIDE=1.
// 
// Vol3[4.10.4.1(Operations that Invalidate TLBs and Paging-Structure Caches)]
// Vol3[26.3.1.1(Checks on Guest Control Registers, Debug Registers, and MSRs)]
bool cr3_detected_2() {
  _disable();

  cr3 curr_cr3;
  curr_cr3.flags = __readcr3();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  // PCIDE=1
  if (curr_cr4.pcid_enable) {
    __try {
      auto test_cr3 = curr_cr3;
      test_cr3.flags |= (1ull << 63);
      __writecr3(test_cr3.flags);
    }
    __except (1) {
      // shouldn't raise an exception
      _enable();
      return false;
    }
  }
  // PCIDE=0
  else {
    __try {
      auto test_cr3 = curr_cr3;

      // set CR3[11:0] to 0 before enabling PCIDE
      test_cr3.flags &= ~0xFFFull;
      __writecr3(test_cr3.flags);

      // set PCIDE to 1
      auto test_cr4 = curr_cr4;
      test_cr4.pcid_enable = 1;
      __writecr4(test_cr4.flags);

      // set bit 63 of CR3 (should NOT raise an exception in a proper hypervisor)
      test_cr3.flags |= (1ull << 63);
      __writecr3(test_cr3.flags);

      // restore CR4 and CR3
      __writecr4(curr_cr4.flags);
      __writecr3(curr_cr3.flags);
    }
    __except (1) {
      // restore CR4 and CR3
      __writecr4(curr_cr4.flags);
      __writecr3(curr_cr3.flags);

      // shouldn't raise an exception
      _enable();
      return false;
    }
  }

  _enable();
  return false;
}

// This function tries to detect hypervisors that unconditionally ignore
// bit 63 of CR3, even when CR4.PCIDE=0.
bool cr3_detected_3() {
  _disable();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  // TODO: add support for when PCIDE is set
  if (curr_cr4.pcid_enable) {
    _enable();
    return false;
  }

  cr3 curr_cr3;
  curr_cr3.flags = __readcr3();

  bool detected = false;

  __try {
    auto test_cr3 = curr_cr3;
    test_cr3.flags |= (1ull << 63);
    __writecr3(test_cr3.flags);

    // an exception should be raised since bit 63 of CR3
    // is only used when CR4.PCIDE is set to 1.
    detected = true;
  }
  __except (1) {
    detected = false;
  }

  // restore CR3
  __writecr3(curr_cr3.flags);

  _enable();
  return false;
}


```

`nohv/cr4.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This detection checks to see if CR4.VMXE is set to 1.
// 
// Vol3[23.7(Enabling and Entering VMX Operation)]
bool cr4_detected_1() {
  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();
  return curr_cr4.vmx_enable;
}

// This detection tries to flip CR4.VMXE and sees how the hypervisor reacts.
// 
// Vol3[23.7(Enabling and Entering VMX Operation)]
// Vol3[23.8(Restrictions on VMX Operation)]
bool cr4_detected_2() {
  _disable();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  __try {
    auto test_cr4 = curr_cr4;
    test_cr4.vmx_enable = !test_cr4.vmx_enable;
    __writecr4(test_cr4.flags);

    // check if the write actually went through
    if (__readcr4() != test_cr4.flags) {
      // restore CR4
      __writecr4(curr_cr4.flags);

      _enable();
      return true;
    }

    // restore CR4
    __writecr4(curr_cr4.flags);

    // not sure how this would happen but might as well throw it in :)
    if (__readcr4() != curr_cr4.flags) {
      _enable();
      return true;
    }
  }
  __except (1) {
    // an exception should not have been raised...
    _enable();
    return true;
  }

  _enable();
  return false;
}

// This detection tries to modify reserved bits in CR4 and checks if an
// exception was successfully raised. This check is NOT exhaustive, but
// covers (almost) everything.
// 
// Vol2[4.3(MOV - Move to/from Control Registers)]
// Vol3[2.5(Control Registers)]
bool cr4_detected_3() {
  _disable();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  __try {
    auto test_cr4 = curr_cr4;

    // clear CR4.PAE
    test_cr4.physical_address_extension = 0;

    // flip CR4.VMXE to ensure that a vm-exit occurs
    test_cr4.vmx_enable = !test_cr4.vmx_enable;

    __writecr4(test_cr4.flags);

    // restore CR4
    __writecr4(curr_cr4.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  __try {
    auto test_cr4 = curr_cr4;

    // set CR4.LA57
    test_cr4.linear_addresses_57_bit = 1;

    // flip CR4.VMXE to ensure that a vm-exit occurs
    test_cr4.vmx_enable = !test_cr4.vmx_enable;

    __writecr4(test_cr4.flags);

    // restore CR4
    __writecr4(curr_cr4.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // change CR4.PCIDE from 0 to 1 while CR3[11:0] != 000H
  __try {
    // TODO:
  }
  __except (1) {}

  _enable();
  return false;
}

// This detection tries to set reserved bits in CR0 (bits 63:32)
// that should trigger an exception.
// 
// Vol3[2.5(Control Registers)]
bool cr4_detected_4() {
  _disable();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  for (int i = 32; i < 64; ++i) {
    __try {
      auto test_cr4 = curr_cr4;

      // set a reserved bit
      test_cr4.flags |= (1ull << i);

      // flip CR4.VMXE to ensure that a vm-exit occurs
      test_cr4.vmx_enable = !test_cr4.vmx_enable;

      // this should trigger an exception
      __writecr4(test_cr4.flags);

      // restore CR4 after the hypervisor mucked it
      __writecr4(curr_cr4.flags);

      _enable();
      return true;
    } __except (1) {
      // maybe the write went through even though an exception was raised?
      if (curr_cr4.flags != __readcr4()) {
        // restore CR4 after the hypervisor mucked it
        __writecr0(curr_cr4.flags);

        _enable();
        return true;
      }
    }
  }

  _enable();
  return false;
}

```

`nohv/debug.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This detection checks to see if the hypervisor properly stores and
// restores the guest DR7 register during a vm-exit.
// 
// Vol3[27.5.1(Loading Host Control Registers, Debug Registers, MSRs)]
bool debug_detected_1() {
  _disable();

  dr7 curr_dr7;
  curr_dr7.flags = __readdr(7);

  // write to DR7
  __writedr(7, 0x4FF);

  // trigger a vm-exit
  int tmp[4];
  __cpuid(tmp, 0);

  if (__readdr(7) != 0x4FF) {
    // restore DR7, although hypervisor will fuck with it anyways
    __writedr(7, curr_dr7.flags);

    _enable();
    return true;
  }

  // restore DR7, although hypervisor will fuck with it anyways
  __writedr(7, curr_dr7.flags);

  _enable();
  return false;
}

bool debug_detected_2() {
  return false;
}


```

`nohv/detections.h`:

```h
#pragma once

// cpuid.cpp
bool cpuid_detected_1();

// msr.cpp
bool msr_detected_1();
bool msr_detected_2();

// cr0.cpp
bool cr0_detected_1();
bool cr0_detected_2();

// cr3.cpp
bool cr3_detected_1();
bool cr3_detected_2();
bool cr3_detected_3();

// cr4.cpp
bool cr4_detected_1();
bool cr4_detected_2();
bool cr4_detected_3();
bool cr4_detected_4();

// xsetbv.cpp
bool xsetbv_detected_1();
bool xsetbv_detected_2();
bool xsetbv_detected_3();
bool xsetbv_detected_4();
bool xsetbv_detected_5();

// timing.cpp
bool timing_detected_1();
bool timing_detected_2();
bool timing_detected_3();
bool timing_detected_4();
bool timing_detected_5();
bool timing_detected_6();

// debug.cpp
bool debug_detected_1();
bool debug_detected_2();

// vmx.cpp
bool vmx_detected_1();
bool vmx_detected_2();
bool vmx_detected_3();


```

`nohv/main.cpp`:

```cpp
#include <ntddk.h>

#include "detections.h"

#define EXEC_DETECTION(x)\
  if (x())\
    DbgPrint("[-] Failed check: " #x "().\n");\
  else\
    DbgPrint("[+] Passed check: " #x "().\n");

void driver_unload(PDRIVER_OBJECT) {
  DbgPrint("Driver unloaded.\n");
}

NTSTATUS driver_entry(PDRIVER_OBJECT driver, PUNICODE_STRING) {
  DbgPrint("Driver loaded.\n");

  driver->DriverUnload = driver_unload;

  // bind execution to a single logical processor
  auto const affinity = KeSetSystemAffinityThreadEx(1);

  // cpuid.cpp
  DbgPrint("Testing cpuid:\n");
  EXEC_DETECTION(cpuid_detected_1);

  // msr.cpp
  DbgPrint("Testing msr:\n");
  EXEC_DETECTION(msr_detected_1);
  EXEC_DETECTION(msr_detected_2);

  // cr0.cpp
  DbgPrint("Testing cr0:\n");
  EXEC_DETECTION(cr0_detected_1);
  EXEC_DETECTION(cr0_detected_2);

  // cr3.cpp
  DbgPrint("Testing cr3:\n");
  EXEC_DETECTION(cr3_detected_1);
  EXEC_DETECTION(cr3_detected_2);
  EXEC_DETECTION(cr3_detected_3);

  // cr4.cpp
  DbgPrint("Testing cr4:\n");
  EXEC_DETECTION(cr4_detected_1);
  EXEC_DETECTION(cr4_detected_2);
  EXEC_DETECTION(cr4_detected_3);
  EXEC_DETECTION(cr4_detected_4);

  // xsetbv.cpp
  DbgPrint("Testing xsetbv:\n");
  EXEC_DETECTION(xsetbv_detected_1);
  EXEC_DETECTION(xsetbv_detected_2);
  EXEC_DETECTION(xsetbv_detected_3);
  EXEC_DETECTION(xsetbv_detected_4);
  EXEC_DETECTION(xsetbv_detected_5);

  // timing.cpp
  DbgPrint("Testing timing:\n");
  EXEC_DETECTION(timing_detected_1);
  EXEC_DETECTION(timing_detected_2);
  EXEC_DETECTION(timing_detected_3);
  EXEC_DETECTION(timing_detected_4);
  EXEC_DETECTION(timing_detected_5);
  EXEC_DETECTION(timing_detected_6);

  // debug.cpp
  DbgPrint("Testing debug:\n");
  EXEC_DETECTION(debug_detected_1);
  EXEC_DETECTION(debug_detected_2);

  // vmx.cpp
  DbgPrint("Testing vmx:\n");
  EXEC_DETECTION(vmx_detected_1);
  EXEC_DETECTION(vmx_detected_2);
  EXEC_DETECTION(vmx_detected_3);

  KeRevertToUserAffinityThreadEx(affinity);

  return STATUS_SUCCESS;
}


```

`nohv/msr.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>
#include <ntddk.h>

// This detection tries to read from synthetic MSRs and checks if
// an exception is properly raised.
bool msr_detected_1() {
  for (unsigned int msr = 0x4000'0000; msr <= 0x4000'00FF; ++msr) {
    __try {
      __readmsr(msr);

      // an exception should have been raised
      return true;
    }
    __except (1) {}
  }

  return false;
}

// This detection checks to see if the hypervisor lets the guest read
// the MPERF and APERF MSRs while CPUID reports that they are not supported.
bool msr_detected_2() {
  _disable();

  cpuid_eax_06 cpuid_06;
  __cpuid(reinterpret_cast<int*>(&cpuid_06), 6);

  // IA32_MPERF/IA32_APERF MSRs are supported
  if (cpuid_06.ecx.hardware_coordination_feedback_capability) {
    _enable();
    return false;
  }

  __try {
    __readmsr(IA32_MPERF);

    // an exception should be thrown since these registers are not supported
    _enable();
    return true;
  }
  __except (1) {}

  __try {
    __readmsr(IA32_APERF);

    // an exception should be thrown since these registers are not supported
    _enable();
    return true;
  }
  __except (1) {}

  _enable();
  return false;
}


```

`nohv/nohv.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7EEE2802-BAD0-4E78-84E4-2793E6E25E32}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>nohv</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)build\$(ConfigurationName.toLower())\</OutDir>
    <IntDir>$(SolutionDir)build\$(ConfigurationName.toLower())\intermediate\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(SolutionDir)extern\ia32-doc\out;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <OutDir>$(SolutionDir)build\$(ConfigurationName.toLower())\</OutDir>
    <IntDir>$(SolutionDir)build\$(ConfigurationName.toLower())\intermediate\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(SolutionDir)extern\ia32-doc\out;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <DisableSpecificWarnings>4201;5040;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <DisableSpecificWarnings>4201;5040;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="cpuid.cpp" />
    <ClCompile Include="cr0.cpp" />
    <ClCompile Include="cr3.cpp" />
    <ClCompile Include="cr4.cpp" />
    <ClCompile Include="debug.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="msr.cpp" />
    <ClCompile Include="timing.cpp" />
    <ClCompile Include="vmx.cpp" />
    <ClCompile Include="xsetbv.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="detections.h" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="vmx-asm.asm" />
    <MASM Include="xsetbv-asm.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`nohv/nohv.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cr3.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="timing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cr0.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="xsetbv.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cpuid.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cr4.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="msr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="debug.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="vmx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="detections.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="xsetbv-asm.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="vmx-asm.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`nohv/nohv.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`nohv/timing.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>
#include <ntddk.h>

// Hardcoded execution times for CPUID instruction.
inline constexpr size_t max_acceptable_tsc   = 500;
inline constexpr size_t max_acceptable_mperf = 500;
inline constexpr size_t max_acceptable_aperf = 500;

// Classic timing detection that checks if the time to
// execute the CPUID instruction is suspiciously large. This
// check uses the TSC to measure execution time.
bool timing_detected_1() {
  _disable();

  uint64_t lowest_tsc = MAXULONG64;

  // we only care about the lowest TSC delta for reliability since an NMI,
  // an SMI, or TurboBoost could fuck up our timings.
  for (int i = 0; i < 10; ++i) {
    int regs[4] = {};

    _mm_lfence();
    auto const start = __rdtsc();
    _mm_lfence();

    __cpuid(regs, 0);

    _mm_lfence();
    auto const end = __rdtsc();
    _mm_lfence();

    auto const delta = (end - start);
    if (delta < lowest_tsc)
      lowest_tsc = delta;

    // they over-accounted and TSC delta went negative
    if (delta & (1ull << 63)) {
      _enable();
      return true;
    }
  }

  _enable();
  return (lowest_tsc > max_acceptable_tsc);
}

// IPI callback that executes CPUID in a loop on every logical processor.
static ULONG_PTR ipi_callback(ULONG_PTR const context) {
  size_t& detected_count = *reinterpret_cast<size_t*>(context);

  for (size_t i = 0; i < 100; ++i) {
    int regs[4] = {};

    _mm_lfence();
    auto const start = __rdtsc();
    _mm_lfence();

    __cpuid(regs, 0);

    _mm_lfence();
    auto const end = __rdtsc();
    _mm_lfence();

    auto const delta = (end - start);

    // TSC delta went negative
    if (delta & (1ull << 63))
      ++detected_count;
  }

  return 0;
}

// This timing detection tries to simultaneously execute an unconditionally
// vm-exiting instruction on every logical processor in order to catch
// hypervisors that use a shared TSC offset to bypass timing checks. Using
// a shared TSC offset will cause the TSC delta to go negative, since it
// was lowered in another logical processor.
bool timing_detected_2() {
  size_t detected_count = 0;
  KeIpiGenericCall(ipi_callback, reinterpret_cast<ULONG_PTR>(&detected_count));
  return (detected_count > 0);
}

// This detection uses CPU_CLK_UNHALTED.REF_TSC to measure the
// execution time of the CPUID instruction.
// 
// Vol3[19.2.2(Architectural Performance Monitoring Version 2)]
bool timing_detected_3() {
  _disable();

  ia32_fixed_ctr_ctrl_register curr_fixed_ctr_ctrl;
  curr_fixed_ctr_ctrl.flags = __readmsr(IA32_FIXED_CTR_CTRL);

  ia32_perf_global_ctrl_register curr_perf_global_ctrl;
  curr_perf_global_ctrl.flags = __readmsr(IA32_PERF_GLOBAL_CTRL);

  // enable fixed counter #2
  auto new_fixed_ctr_ctrl = curr_fixed_ctr_ctrl;
  new_fixed_ctr_ctrl.en2_os      = 1;
  new_fixed_ctr_ctrl.en2_usr     = 0;
  new_fixed_ctr_ctrl.en2_pmi     = 0;
  new_fixed_ctr_ctrl.any_thread2 = 0;
  __writemsr(IA32_FIXED_CTR_CTRL, new_fixed_ctr_ctrl.flags);

  // enable fixed counter #2
  auto new_perf_global_ctrl = curr_perf_global_ctrl;
  new_perf_global_ctrl.en_fixed_ctrn |= (1ull << 2);
  __writemsr(IA32_PERF_GLOBAL_CTRL, new_perf_global_ctrl.flags);

  bool detected = false;
  uint64_t lowest_tsc = MAXULONG64;

  // we only care about the lowest TSC for reliability since an NMI,
  // an SMI, or TurboBoost could fuck up our timings.
  for (int i = 0; i < 10; ++i) {
    int regs[4] = {};

    _mm_lfence();
    auto const start = __readmsr(IA32_FIXED_CTR2);
    _mm_lfence();

    __cpuid(regs, 0);

    _mm_lfence();
    auto const end = __readmsr(IA32_FIXED_CTR2);
    _mm_lfence();

    auto const delta = (end - start);
    if (delta < lowest_tsc)
      lowest_tsc = delta;

    // they over-accounted and TSC delta went negative
    if (delta & (1ull << 63))
      detected = true;
  }

  if (lowest_tsc > max_acceptable_tsc)
    detected = true;

  // restore MSRs
  __writemsr(IA32_PERF_GLOBAL_CTRL, curr_perf_global_ctrl.flags);
  __writemsr(IA32_FIXED_CTR_CTRL, curr_fixed_ctr_ctrl.flags);

  _enable();
  return detected;
}

// Classic timing detection that checks if the time to
// execute the CPUID instruction is suspiciously large. This
// check uses the MPERF to measure execution time.
bool timing_detected_4() {
  _disable();

  cpuid_eax_06 cpuid_06;
  __cpuid(reinterpret_cast<int*>(&cpuid_06), 6);

  // IA32_MPERF/IA32_APERF MSRs are not supported
  if (!cpuid_06.ecx.hardware_coordination_feedback_capability) {
    _enable();
    return false;
  }

  uint64_t lowest_mperf = MAXULONG64;

  // we only care about the lowest MPERF delta for reliability since an NMI,
  // an SMI, or TurboBoost could fuck up our timings.
  for (int i = 0; i < 10; ++i) {
    int regs[4] = {};

    _mm_lfence();
    auto const start = __readmsr(IA32_MPERF);
    _mm_lfence();

    __cpuid(regs, 0);

    _mm_lfence();
    auto const end = __readmsr(IA32_MPERF);
    _mm_lfence();

    auto const delta = (end - start);
    if (delta < lowest_mperf)
      lowest_mperf = delta;

    // they over-accounted and MPERF delta went negative
    if (delta & (1ull << 63)) {
      _enable();
      return true;
    }
  }

  _enable();
  return (lowest_mperf > max_acceptable_mperf)
      || (lowest_mperf <= 10);
}

// Classic timing detection that checks if the time to
// execute the CPUID instruction is suspiciously large. This
// check uses the APERF to measure execution time.
bool timing_detected_5() {
  _disable();

  cpuid_eax_06 cpuid_06;
  __cpuid(reinterpret_cast<int*>(&cpuid_06), 6);

  // IA32_MPERF/IA32_APERF MSRs are not supported
  if (!cpuid_06.ecx.hardware_coordination_feedback_capability) {
    _enable();
    return false;
  }

  uint64_t lowest_aperf = MAXULONG64;

  // we only care about the lowest APERF delta for reliability since an NMI,
  // an SMI, or TurboBoost could fuck up our timings.
  for (int i = 0; i < 10; ++i) {
    int regs[4] = {};

    _mm_lfence();
    auto const start = __readmsr(IA32_APERF);
    _mm_lfence();

    __cpuid(regs, 0);

    _mm_lfence();
    auto const end = __readmsr(IA32_APERF);
    _mm_lfence();

    auto const delta = (end - start);
    if (delta < lowest_aperf)
      lowest_aperf = delta;

    // they over-accounted and APERF delta went negative
    if (delta & (1ull << 63)) {
      _enable();
      return true;
    }
  }

  _enable();
  return (lowest_aperf > max_acceptable_aperf)
      || (lowest_aperf <= 10);
}

// Measures the amount of time it takes to read+write
// to every byte in the specified array.
static uint64_t time_cacheline(uint8_t cacheline[64]) {
  // touch the memory and ensure that it is in the cache
  cacheline[0] = 1;

  _mm_lfence();
  auto const start = __rdtsc();
  _mm_lfence();

  for (int i = 0; i < 64; ++i)
    cacheline[i] += 1;

  _mm_lfence();
  auto const end = __rdtsc();
  _mm_lfence();

  return (end - start);
}

// This detection tries to catch hypervisors that fail to update the memory
// types in the EPT paging structures after the guest disables caching.
// 
// Vol3[11.5.3(Preventing Caching)]
// Vol3[11.11(Memory Type Range Registers (MTRRs))]
bool timing_detected_6() {
  _disable();

  cr0 curr_cr0;
  curr_cr0.flags = __readcr0();

  ia32_mtrr_def_type_register curr_mtrr_def_type;
  curr_mtrr_def_type.flags = __readmsr(IA32_MTRR_DEF_TYPE);

  // a cacheline that we'll be using to determine whether the memory
  // typing is WB or UC.
  alignas(64) uint8_t cacheline[64] = {};

  // amount of time to access WB memory that is in the cache
  uint64_t wb_timing = MAXUINT64;

  for (int i = 0; i < 10; ++i) {
    auto const timing = time_cacheline(cacheline);
    if (timing < wb_timing)
      wb_timing = timing;
  }

  // set CR0.CD to 1
  __try {
    auto test_cr0 = curr_cr0;
    test_cr0.cache_disable = 1;
    __writecr0(test_cr0.flags);
  }
  __except (1) {
    // an exception shouldn't be thrown
    _enable();
    return true;
  }

  // invalidate the cache since the processor can still use
  // existing cache lines if they exist
  __wbinvd();

  // disable caching through the MTRRs
  auto test_mtrr_def_type = curr_mtrr_def_type;
  test_mtrr_def_type.mtrr_enable         = 0;
  test_mtrr_def_type.default_memory_type = MEMORY_TYPE_UNCACHEABLE;
  __writemsr(IA32_MTRR_DEF_TYPE, test_mtrr_def_type.flags);

  // invalidate the cache again for Pentium 4 and Intel Xeon processors
  __wbinvd();

  // amount of time to access UC memory that is in the cache
  uint64_t uc_timing = MAXUINT64;

  for (int i = 0; i < 10; ++i) {
    auto const timing = time_cacheline(cacheline);
    if (timing < uc_timing)
      uc_timing = timing;
  }

  // restore MTRRs
  __writemsr(IA32_MTRR_DEF_TYPE, curr_mtrr_def_type.flags);

  // restore CR0
  __writecr0(curr_cr0.flags);

  _enable();
  return (uc_timing < wb_timing * 40);
}


```

`nohv/vmx-asm.asm`:

```asm
.code

vmx_vmcall proc
  vmcall
  ret
vmx_vmcall endp

end

```

`nohv/vmx.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>
#include <ntddk.h>

// This detection tries to execute VMXON while CR4.VMXE is
// clear and checks to see if a #UD was successfully raised.
// 
// Vol3[30.3(VMXON - Enter VMX Operaton)
bool vmx_detected_1() {
  _disable();

  cr4 curr_cr4;
  curr_cr4.flags = __readcr4();

  // clear CR4.VMXE
  __try {
    auto test_cr4 = curr_cr4;
    test_cr4.vmx_enable = 0;
    __writecr4(test_cr4.flags);
  }
  __except (1) {
    _enable();
    return true;
  }

  bool detected = false;
  unsigned long ecode = 0;

  // execute VMXON (VMXON region shouldn't matter since an
  // exception should be raised before operand is even checked)
  __try {
    __vmx_on(nullptr);

    // uh... how did we even end up here?
    detected = true;
  }
  __except (ecode = GetExceptionCode(), 1) {
    // check if a #UD was raised
    detected = (ecode != STATUS_ILLEGAL_INSTRUCTION);
  }

  // restore CR4
  __writecr4(curr_cr4.flags);

  _enable();
  return detected;
}

// This detection tries to execute VMXON with an invalid operand
// and checks to see if a VM error code was properly returned.
// 
// Vol3[30.3(VMXON - Enter VMX Operaton)
bool vmx_detected_2() {
  _disable();

  ia32_feature_control_register feature_control;
  feature_control.flags = __readmsr(IA32_FEATURE_CONTROL);

  // check if VMX has been disabled by BIOS
  if (!feature_control.lock_bit || !feature_control.enable_vmx_outside_smx) {
    _enable();
    return false;
  }

  cr0 curr_cr0;
  cr4 curr_cr4;

  curr_cr0.flags = __readcr0();
  curr_cr4.flags = __readcr4();

  // configure CR0 and CR4 for VMX operation
  __try {
    auto test_cr0 = curr_cr0;
    auto test_cr4 = curr_cr4;

    test_cr4.vmx_enable = 1;

    test_cr0.flags |= __readmsr(IA32_VMX_CR0_FIXED0);
    test_cr0.flags &= __readmsr(IA32_VMX_CR0_FIXED1);
    test_cr4.flags |= __readmsr(IA32_VMX_CR4_FIXED0);
    test_cr4.flags &= __readmsr(IA32_VMX_CR4_FIXED1);

    __writecr0(test_cr0.flags);
    __writecr4(test_cr4.flags);
  }
  __except (1) {
    // restore CR0 and CR4
    __writecr0(curr_cr0.flags);
    __writecr4(curr_cr4.flags);

    _enable();
    return true;
  }

  bool detected = false;

  __try {
    unsigned long long address = MAXULONG64;
    auto const ret = __vmx_on(&address);

    // VMXON was successful... bro?
    if (ret == 0)
      detected = true;
    // extended status should not be available since there's no current VMCS
    else if (ret == 1)
      detected = true;
  }
  __except (1) {
    // an exception should not have been raised...
    detected = true;
  }

  // restore CR0 and CR4
  __writecr0(curr_cr0.flags);
  __writecr4(curr_cr4.flags);

  _enable();
  return detected;
}

// This function executes the VMCALL instruction.
extern "C" void vmx_vmcall(uint64_t rcx, uint64_t rdx, uint64_t r8, uint64_t r9);

// This detection tries to execute VMCALL and checks if a #UD was
// correctly raised (since we're not in VMX operation).
bool vmx_detected_3() {
  // we do a lil' bruteforcin
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 20; ++j) {
      unsigned long ecode = 0;

      __try {
        uint64_t args[4] = {};
        args[i] = j;

        vmx_vmcall(args[0], args[1], args[2], args[3]);

        // an exception should've been raised
        return true;
      }
      __except (ecode = GetExceptionCode(), 1) {
        // make sure they injected the correct exception
        if (ecode != STATUS_ILLEGAL_INSTRUCTION)
          return true;
      }
    }
  }

  return false;
}


```

`nohv/xsetbv-asm.asm`:

```asm
.code

xsetbv_full proc
  mov rax, r8
  xsetbv
  ret
xsetbv_full endp

end

```

`nohv/xsetbv.cpp`:

```cpp
#include <ia32.hpp>
#include <intrin.h>

// This detection tries to write to an XCR that is not supported.
// 
// Vol3[2.6(Extended Control Registers (Including XCR0))]
bool xsetbv_detected_1() {
  _disable();

  __try {
    // try to write to XCR69
    _xsetbv(69, _xgetbv(0));

    // an exception should have been raised...
    _enable();
    return true;
  }
  __except (1) {}

  _enable();
  return false;
}

// This detection tries to set every unsupported bit in XCR0.
// 
// Vol3[2.6(Extended Control Registers (Including XCR0))]
bool xsetbv_detected_2() {
  _disable();

  xcr0 curr_xcr0;
  curr_xcr0.flags = _xgetbv(0);

  cpuid_eax_0d_ecx_00 cpuid_0d;
  __cpuidex(reinterpret_cast<int*>(&cpuid_0d), 0x0D, 0x00);
  
  // features in XCR0 that are supported
  auto const supported_mask = (static_cast<uint64_t>(
    cpuid_0d.edx.flags) << 32) | cpuid_0d.eax.flags;

  for (int i = 0; i < 64; ++i) {
    // this is a bit dumb but it works well enough so whatever
    if (supported_mask & (1ull << i))
      continue;

    __try {
      auto test_xcr0 = curr_xcr0;
      test_xcr0.flags |= (1ull << i);

      _xsetbv(0, test_xcr0.flags);

      // restore XCR0 after the hypervisor mucked it
      _xsetbv(0, curr_xcr0.flags);

      // an exception should have been raised...
      _enable();
      return true;
    }
    __except (1) {
      // maybe the write went through even though an exception was raised?
      if (curr_xcr0.flags != _xgetbv(0)) {
        // restore XCR0 after the hypervisor mucked it
        _xsetbv(0, curr_xcr0.flags);

        _enable();
        return true;
      }
    }
  }

  _enable();
  return false;
}

// This function executes XSETBV with full
// 64-bit registers set to whatever specified.
extern "C" void xsetbv_full(uint64_t rcx, uint64_t rdx, uint64_t rax);

// This detection tries to catch hypervisors that incorrectly include
// the high part of the RAX register when emulating XSETBV.
// 
// Vol2[5.2(XSETBV - Set Extended Control Register)]
// https://github.com/wbenny/hvpp/blob/84b3f3c241e1eec3ab42f75cad9deef3ad67e6ab/src/hvpp/hvpp/vmexit/vmexit_passthrough.cpp#L959
// https://github.com/eyalz800/zpp_hypervisor/blob/master/hypervisor/src/hypervisor/hypervisor.cpp#L1021
// https://github.com/ionescu007/SimpleVisor/blob/989d33b1bc6569965d7aad3bd50a8d35fa4c359e/shvvmxhv.c#L163
// https://github.com/HyperDbg/HyperDbg/blob/06c4ea79d93fe6e9851e4ce9c0a8bdb4eb0fb0a6/hyperdbg/hprdbghv/code/vmm/vmx/Vmexit.c#L402
bool xsetbv_detected_3() {
  _disable();

  xcr0 curr_xcr0;
  curr_xcr0.flags = _xgetbv(0);

  cpuid_eax_0d_ecx_00 cpuid_0d;
  __cpuidex(reinterpret_cast<int*>(&cpuid_0d), 0x0D, 0x00);
  
  // features that are unsupported in the high part of XCR0
  auto const unsupported_mask = static_cast<uint64_t>(cpuid_0d.edx.flags);

  __try {
    xsetbv_full(0, curr_xcr0.flags >> 32,
      (curr_xcr0.flags & 0xFFFF'FFFF) | unsupported_mask);
  }
  __except (1) {
    // no exception should be raised since the high part of RAX should be ignored...
    _enable();
    return true;
  }

  _enable();
  return false;
}

// This detection tries to catch hypervisors that incorrectly include
// the high part of the RCX register when emulating XSETBV.
// 
// Vol2[5.2(XSETBV - Set Extended Control Register)]
bool xsetbv_detected_4() {
  _disable();

  xcr0 curr_xcr0;
  curr_xcr0.flags = _xgetbv(0);

  __try {
    xsetbv_full(69ull << 32, curr_xcr0.flags << 32,
      curr_xcr0.flags & 0xFFFF'FFFF);
  }
  __except (1) {
    // no exception should be raised since the high part of RCX should be ignored...
    _enable();
    return true;
  }

  _enable();
  return false;
}

// This detection tries to write an invalid combination to XCR0.
// 
// Vol3[2.6(Extended Control Registers (Including XCR0))]
bool xsetbv_detected_5() {
  _disable();

  xcr0 curr_xcr0;
  curr_xcr0.flags = _xgetbv(0);

  // clear XCR0.x87
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.x87 = 0;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // clear XCR0.SSE and set XCR0.AVX
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.sse = 0;
    test_xcr0.avx = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // clear XCR0.AVX and set any of XCR0.opmask, XCR0.ZMM_Hi256, and XCR0.Hi16_ZMM
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.avx    = 0;
    test_xcr0.opmask = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // clear XCR0.AVX and set any of XCR0.opmask, XCR0.ZMM_Hi256, and XCR0.Hi16_ZMM
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.avx       = 0;
    test_xcr0.zmm_hi256 = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // clear XCR0.AVX and set any of XCR0.opmask, XCR0.ZMM_Hi256, and XCR0.Hi16_ZMM
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.avx      = 0;
    test_xcr0.zmm_hi16 = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // set either XCR0.BNDREG and XCR0.BNDCSR while not setting the other
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.bndreg = 0;
    test_xcr0.bndcsr = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // set either XCR0.BNDREG and XCR0.BNDCSR while not setting the other
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.bndreg = 1;
    test_xcr0.bndcsr = 0;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // set any of XCR0.opmask, XCR0.ZMM_Hi256, and
  // XCR0.Hi16_ZMM while not setting all of them
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.opmask    = 0;
    test_xcr0.zmm_hi256 = 1;
    test_xcr0.zmm_hi16  = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // set any of XCR0.opmask, XCR0.ZMM_Hi256, and
  // XCR0.Hi16_ZMM while not setting all of them
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.opmask    = 1;
    test_xcr0.zmm_hi256 = 0;
    test_xcr0.zmm_hi16  = 1;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  // set any of XCR0.opmask, XCR0.ZMM_Hi256, and
  // XCR0.Hi16_ZMM while not setting all of them
  __try {
    auto test_xcr0 = curr_xcr0;
    test_xcr0.opmask    = 1;
    test_xcr0.zmm_hi256 = 1;
    test_xcr0.zmm_hi16  = 0;
    _xsetbv(0, test_xcr0.flags);

    // an exception should have been raised
    _enable();
    return true;
  }
  __except (1) {}

  _enable();
  return false;
}


```