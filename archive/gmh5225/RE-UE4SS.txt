Project Path: arc_gmh5225_RE-UE4SS_tgmj39o_

Source Tree:

```txt
arc_gmh5225_RE-UE4SS_tgmj39o_
├── CMakeLists.txt
├── Changelog_1.1.txt
├── Changelog_Pre1_1.0.0_To_Pre2_1.0.0.txt
├── Changelog_Pre2_1.0.0_To_Pre3_1.0.0.txt
├── Changelog_Pre3_1.0.0_To_Pre4_1.0.0.txt
├── Changelog_Pre4_1.0.0_To_Final_1.0.0.txt
├── CustomGameConfigs
│   ├── Borderlands 3
│   │   ├── UE4SS-settings.ini
│   │   └── VTableLayout.ini
│   ├── Final Fantasy 7 Remake
│   │   ├── MemberVariableLayout.ini
│   │   ├── UE4SS_Signatures
│   │   │   ├── FName_Constructor.lua
│   │   │   ├── FName_ToString.lua
│   │   │   └── StaticConstructObject.lua
│   │   └── VTableLayout.ini
│   ├── Kingdom Hearts 3
│   │   ├── MemberVariableLayout.ini
│   │   ├── UE4SS_Signatures
│   │   │   ├── FName_Constructor.lua
│   │   │   ├── FName_ToString.lua
│   │   │   └── StaticConstructObject.lua
│   │   └── VTableLayout.ini
│   ├── Readme.md
│   ├── Satisfactory
│   │   └── UE4SS_Signatures
│   │       └── FName_Constructor.lua
│   ├── The Outer Worlds
│   │   ├── MemberVariableLayout.ini
│   │   ├── Readme.md
│   │   ├── UE4SS-settings.ini
│   │   └── VTableLayout.ini
│   ├── Walking Dead Saints & Sinners
│   │   └── UE4SS_Signatures
│   │       ├── FName_Constructor.lua
│   │       └── FName_ToString.lua
│   └── cyubeVR
│       └── UE4SS_Signatures
│           ├── FName_Constructor.lua
│           ├── FName_ToString.lua
│           ├── GMalloc.lua
│           ├── GUObjectArray.lua
│           └── StaticConstructObject.lua
├── Dependencies
│   ├── ArgsParser
│   ├── CommitAndPushAllFirstPartyDependencies.bat
│   ├── Constructs
│   ├── DynamicOutput
│   ├── File
│   ├── Function
│   ├── FunctionTimer
│   ├── Helpers
│   ├── ImGuiColorTextEdit
│   ├── IniParser
│   ├── Input
│   ├── JSON
│   ├── LuaBindingsGenerator
│   ├── LuaMadeSimple
│   ├── LuaRaw
│   ├── MProgram
│   ├── ParserBase
│   ├── PolyHook_2_0
│   ├── ScopedTimer
│   ├── SinglePassSigScanner
│   ├── Unreal
│   ├── fmt
│   └── imgui
├── Internal_Docs
│   ├── 4_12.txt
│   ├── 4_13.txt
│   ├── 4_14.txt
│   ├── 4_15.txt
│   ├── 4_22.txt
│   ├── 4_25.txt
│   ├── 5.0_ea_branch_ue5-main.txt
│   ├── CE_AOB_To_UE4SS_AOB.js
│   ├── FMallocBinned2_vtable.txt
│   ├── GamesWithProblems.txt
│   ├── Required_Changes_From_426_To_500.txt
│   ├── Unreal_Version_Differences.txt
│   ├── WidgetCreation.txt
│   └── aobs
│       ├── EngineVersion.txt
│       ├── FMemory_Free.txt
│       ├── FName_ToString.txt
│       ├── GUObjectArray.txt
│       ├── GUObjectArray2.txt
│       └── StaticLoadObject.txt
├── LICENSE
├── LuaBindings
│   └── include
│       └── LuaBindings
│           └── LuaSetup.hpp
├── Readme.md
├── Staging
│   ├── Changelog_2.0.txt
│   ├── MemberVarLayoutTemplates
│   │   ├── MemberVariableLayout_4_12_Template.ini
│   │   ├── MemberVariableLayout_4_13_Template.ini
│   │   ├── MemberVariableLayout_4_14_Template.ini
│   │   ├── MemberVariableLayout_4_15_Template.ini
│   │   ├── MemberVariableLayout_4_16_Template.ini
│   │   ├── MemberVariableLayout_4_17_Template.ini
│   │   ├── MemberVariableLayout_4_18_Template.ini
│   │   ├── MemberVariableLayout_4_19_Template.ini
│   │   ├── MemberVariableLayout_4_20_Template.ini
│   │   ├── MemberVariableLayout_4_21_Template.ini
│   │   ├── MemberVariableLayout_4_22_Template.ini
│   │   ├── MemberVariableLayout_4_23_Template.ini
│   │   ├── MemberVariableLayout_4_24_Template.ini
│   │   ├── MemberVariableLayout_4_25_Template.ini
│   │   ├── MemberVariableLayout_4_26_Template.ini
│   │   ├── MemberVariableLayout_4_27_CasePreserving_Template.ini
│   │   ├── MemberVariableLayout_4_27_Template.ini
│   │   ├── MemberVariableLayout_5_00_Template.ini
│   │   └── README.txt
│   ├── Mods
│   │   ├── ActorDumperMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   ├── CXXHeaderGeneratorMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   ├── CheatManagerEnablerMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   ├── ConsoleCommandsMod
│   │   │   └── Scripts
│   │   │       ├── dump_object.lua
│   │   │       ├── main.lua
│   │   │       ├── set.lua
│   │   │       └── summon_unloaded_assets.lua
│   │   ├── ConsoleEnablerMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   ├── ObjectDumperMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   ├── UHTCompatibleHeaderGeneratorMod
│   │   │   └── Scripts
│   │   │       └── main.lua
│   │   └── mods.txt
│   ├── Readme.md
│   ├── UE4SS-settings.ini
│   ├── UE4SS_Signatures
│   │   ├── FName_ToString.lua.example
│   │   └── GUObjectArray.lua.example
│   └── VTableLayoutTemplates
│       ├── README.txt
│       ├── VTableLayout_4_12_Template.ini
│       ├── VTableLayout_4_13_Template.ini
│       ├── VTableLayout_4_14_Template.ini
│       ├── VTableLayout_4_15_Template.ini
│       ├── VTableLayout_4_16_Template.ini
│       ├── VTableLayout_4_17_Template.ini
│       ├── VTableLayout_4_18_Template.ini
│       ├── VTableLayout_4_19_Template.ini
│       ├── VTableLayout_4_20_Template.ini
│       ├── VTableLayout_4_21_Template.ini
│       ├── VTableLayout_4_22_Template.ini
│       ├── VTableLayout_4_23_Template.ini
│       ├── VTableLayout_4_24_Template.ini
│       ├── VTableLayout_4_25_Template.ini
│       ├── VTableLayout_4_26_Template.ini
│       ├── VTableLayout_4_27_Template.ini
│       └── VTableLayout_5_00_Template.ini
├── TODO.txt
├── Tests
│   ├── UE4SSProgramTest.cpp
│   ├── UE4SSProgramTest.hpp
│   └── main_ue4ss_tests.cpp
├── VS_Solution
│   └── generate_vs_solution.bat
├── build_auto.bat
├── generated_include
│   ├── MacroSetter.hpp
│   └── build_number.hpp
├── generated_src
│   ├── build_number.cache
│   ├── build_number.cmake
│   └── version.cache
├── git_help.txt
├── include
│   ├── ExceptionHandling.hpp
│   ├── GUI
│   │   ├── Console.hpp
│   │   ├── ConsoleOutputDevice.hpp
│   │   ├── DX11.hpp
│   │   ├── Dumpers.hpp
│   │   ├── GUI.hpp
│   │   ├── ImGuiUtility.hpp
│   │   ├── LiveView.hpp
│   │   └── Windows.hpp
│   ├── LuaCustomMemberFunctions.hpp
│   ├── LuaLibrary.hpp
│   ├── LuaScriptMemoryAccess.hpp
│   ├── LuaTests.hpp
│   ├── LuaType
│   │   ├── LuaAActor.hpp
│   │   ├── LuaCustomProperty.hpp
│   │   ├── LuaFName.hpp
│   │   ├── LuaFOutputDevice.hpp
│   │   ├── LuaFSoftObjectPath.hpp
│   │   ├── LuaFString.hpp
│   │   ├── LuaFText.hpp
│   │   ├── LuaFWeakObjectPtr.hpp
│   │   ├── LuaMod.hpp
│   │   ├── LuaTArray.hpp
│   │   ├── LuaTSoftClassPtr.hpp
│   │   ├── LuaUClass.hpp
│   │   ├── LuaUEnum.hpp
│   │   ├── LuaUFunction.hpp
│   │   ├── LuaUObject.hpp
│   │   ├── LuaUScriptStruct.hpp
│   │   ├── LuaUStruct.hpp
│   │   ├── LuaUWorld.hpp
│   │   ├── LuaXArrayProperty.hpp
│   │   ├── LuaXBoolProperty.hpp
│   │   ├── LuaXEnumProperty.hpp
│   │   ├── LuaXFieldClass.hpp
│   │   ├── LuaXObjectProperty.hpp
│   │   ├── LuaXProperty.hpp
│   │   └── LuaXStructProperty.hpp
│   ├── Mod.hpp
│   ├── ObjectDumper
│   │   └── ObjectToString.hpp
│   ├── SDKGenerator
│   │   ├── Common.hpp
│   │   ├── Generator.hpp
│   │   ├── JSONDumper.hpp
│   │   └── UEHeaderGenerator.hpp
│   ├── SettingsManager.hpp
│   ├── Signatures.hpp
│   ├── UE4SSProgram.hpp
│   ├── UnrealCustom
│   │   └── CustomProperty.hpp
│   └── UnrealDef.hpp
├── internal_build_tools
│   ├── cleanup_build_option_files.bat
│   ├── package_all_distributions.bat
│   ├── package_binary.bat
│   ├── packaging_header.bat
│   ├── reload_cmake.bat
│   ├── set_build_switches.bat
│   └── set_version.bat
├── internal_generate_build_files.bat
├── package_beta_release.bat
├── package_hotfix_release.bat
├── package_minor_release.bat
├── package_pre_release.bat
├── rebuild_auto.bat
├── src
│   ├── GUI
│   │   ├── Console.cpp
│   │   ├── ConsoleOutputDevice.cpp
│   │   ├── DX11.cpp
│   │   ├── Dumpers.cpp
│   │   ├── GUI.cpp
│   │   ├── ImGuiUtility.cpp
│   │   ├── LiveView.cpp
│   │   └── Windows.cpp
│   ├── LuaCustomMemberFunctions.cpp
│   ├── LuaLibrary.cpp
│   ├── LuaScriptMemoryAccess.cpp
│   ├── LuaTests.cpp
│   ├── LuaType
│   │   ├── LuaAActor.cpp
│   │   ├── LuaCustomProperty.cpp
│   │   ├── LuaFName.cpp
│   │   ├── LuaFOutputDevice.cpp
│   │   ├── LuaFSoftObjectPath.cpp
│   │   ├── LuaFString.cpp
│   │   ├── LuaFText.cpp
│   │   ├── LuaFWeakObjectPtr.cpp
│   │   ├── LuaMod.cpp
│   │   ├── LuaTArray.cpp
│   │   ├── LuaTSoftClassPtr.cpp
│   │   ├── LuaUClass.cpp
│   │   ├── LuaUEnum.cpp
│   │   ├── LuaUFunction.cpp
│   │   ├── LuaUObject.cpp
│   │   ├── LuaUScriptStruct.cpp
│   │   ├── LuaUStruct.cpp
│   │   ├── LuaUWorld.cpp
│   │   ├── LuaXArrayProperty.cpp
│   │   ├── LuaXBoolProperty.cpp
│   │   ├── LuaXEnumProperty.cpp
│   │   ├── LuaXFieldClass.cpp
│   │   ├── LuaXObjectProperty.cpp
│   │   ├── LuaXProperty.cpp
│   │   └── LuaXStructProperty.cpp
│   ├── Mod.cpp
│   ├── ObjectDumper
│   │   └── ObjectToString.cpp
│   ├── SDKGenerator
│   │   ├── Common.cpp
│   │   ├── Generator.cpp
│   │   ├── JSONDumper.cpp
│   │   └── UEHeaderGenerator.cpp
│   ├── SettingsManager.cpp
│   ├── Signatures.cpp
│   ├── UE4SSProgram.cpp
│   ├── UnrealCustom
│   │   └── CustomProperty.cpp
│   └── main_ue4ss_rewritten.cpp
└── xinput
    ├── xinput1_3.cpp
    ├── xinput1_3.def
    └── xinput1_3_asm.asm

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.18)
enable_language(CXX)
include(CheckIPOSupported)
check_ipo_supported(RESULT supported OUTPUT error)
message("IPO - Supported: ${supported}; ${error}")
message("Project: UE4SS")

set(MAKE_DEPENDENCIES_SHARED 0)

if (${MAKE_DEPENDENCIES_SHARED} EQUAL 0)
    set(MAKE_DEPENDENCIES_STATIC 1)
    set(DEPENDENCY_BUILD_TYPE STATIC)
    set(BUILD_SHARED_LIBS 0)
else ()
    set(MAKE_DEPENDENCIES_STATIC 0)
    set(DEPENDENCY_BUILD_TYPE SHARED)
    set(BUILD_SHARED_LIBS 1)
endif ()

# We're only using C++20 features but we need to use C++23 so that we get std::format which only exists in the "latest" flag in MSVC
set(CMAKE_CXX_STANDARD 23)

set(TARGET ue4ss)
project(${TARGET})

# Release Settings -> START
set(UE4SS_LIB_BETA_STARTED 1)           # Whether or not beta releases have started for the current major version
set(UE4SS_LIB_IS_BETA 1)                # Whether or not this is a beta release
# Release Settings -> END

# Settings -> START
set(UE4SS_CONSOLE_COLORS_ENABLED 0)
set(FORCE_WITH_CASE_PRESERVING_NAME 0)
set(UE4SS_GENERATED_INCLUDE_DIR "${PROJECT_SOURCE_DIR}/generated_include")
set(UE4SS_GENERATED_SOURCE_DIR "${PROJECT_SOURCE_DIR}/generated_src")
set(LLVM_PATH "D:\\LLVM\\14.0.6\\llvm+clang-14.0.6-x86_64-windows-msvc-release-mt")
set(UE4SS_GENERATE_LUA_BINDINGS 0)
set(BUILD_SCRIPT_DIR ${CMAKE_HOME_DIRECTORY})
# Settings -> END

# Output path -> START
set(UE4SS_OUTPUT_DEBUG_DIR ${CMAKE_SOURCE_DIR}/Output/${PROJECT_NAME}/Binaries/x64/Debug)
set(UE4SS_OUTPUT_RELEASE_DIR ${CMAKE_SOURCE_DIR}/Output/${PROJECT_NAME}/Binaries/x64/Release)
if (${CMAKE_BUILD_TYPE} MATCHES Debug)
    set(LIBRARY_OUTPUT_PATH ${UE4SS_OUTPUT_DEBUG_DIR})
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${UE4SS_OUTPUT_DEBUG_DIR})
elseif (${CMAKE_BUILD_TYPE} MATCHES Release)
    set(LIBRARY_OUTPUT_PATH ${UE4SS_OUTPUT_RELEASE_DIR})
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${UE4SS_OUTPUT_RELEASE_DIR})
else ()
    set(LIBRARY_OUTPUT_PATH ${CMAKE_HOME_DIRECTORY}/Output/${PROJECT_NAME}/Binaries/x64)
    message("Unknown build type. (Build type: ${CMAKE_BUILD_TYPE})")
endif ()
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${UE4SS_OUTPUT_DEBUG_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG ${UE4SS_OUTPUT_DEBUG_DIR})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${UE4SS_OUTPUT_RELEASE_DIR})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE ${UE4SS_OUTPUT_RELEASE_DIR})
# Output path -> END

set(PRIVATE_COMPILE_DEFINITIONS
        $<${MAKE_DEPENDENCIES_SHARED}:RC_EXPORT RC_FUNCTION_EXPORTS>
        $<${MAKE_DEPENDENCIES_STATIC}:RC_FUNCTION_BUILD_STATIC>)
set(PRIVATE_COMPILE_OPTIONS /MP $<$<CONFIG:RELEASE>:/Zi> /W3 /wd4005 /wd4251)
set(PRIVATE_MASM_COMPILE_OPTIONS /MP $<$<CONFIG:RELEASE>:/Zi>)
set(PRIVATE_LINK_OPTIONS /DEBUG:FULL)
set(PUBLIC_COMPILE_FEATURES cxx_std_20)

set(UE4SS_COMPILE_DEFINITIONS
        RC_FILE_BUILD_STATIC
        RC_DYNAMIC_OUTPUT_BUILD_STATIC
        RC_SINGLE_PASS_SIG_SCANNER_BUILD_STATIC
        RC_SINGLE_PASS_SIG_SCANNER_STATIC
        RC_UNREAL_BUILD_STATIC
        RC_INPUT_BUILD_STATIC
        RC_LUA_MADE_SIMPLE_BUILD_STATIC
        RC_FUNCTION_TIMER_BUILD_STATIC
        RC_PARSER_BASE_BUILD_STATIC
        RC_INI_PARSER_BUILD_STATIC
        RC_JSON_BUILD_STATIC
        RC_JSON_PARSER_BUILD_STATIC
        RC_LUA_WRAPPER_GENERATOR_BUILD_STATIC
        )
set(RC_DEPENDENCY_COMPILE_DEFINITIONS ${UE4SS_COMPILE_DEFINITIONS})

if (${UE4SS_CONSOLE_COLORS_ENABLED} EQUAL 1)
    add_compile_definitions(UE4SS_CONSOLE_COLORS_ENABLED)
endif()

add_subdirectory("Dependencies/File")
add_subdirectory("Dependencies/DynamicOutput")
add_subdirectory("Dependencies/Function")
add_subdirectory("Dependencies/Constructs")
add_subdirectory("Dependencies/Helpers")
add_subdirectory("Dependencies/SinglePassSigScanner")

# PolyHook
if (${MAKE_DEPENDENCIES_SHARED} EQUAL 1)
    set(MAKE_POLYHOOK_DEPENDENCIES_SHARED ON)
    set(MAKE_POLYHOOK_DEPENDENCIES_STATIC OFF)
else ()
    set(MAKE_POLYHOOK_DEPENDENCIES_SHARED OFF)
    set(MAKE_POLYHOOK_DEPENDENCIES_STATIC ON)
endif ()
set(POLYHOOK_BUILD_DLL ON CACHE BOOL "Build dll & lib instead of tests" FORCE)
set(POLYHOOK_BUILD_SHARED_LIB ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build polyhook as shared libary" FORCE)
set(POLYHOOK_BUILD_SHARED_ASMJIT ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build polyhook as shared libary" FORCE)
set(POLYHOOK_BUILD_SHARED_CAPSTONE ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build polyhook as shared libary" FORCE)
set(POLYHOOK_BUILD_SHARED_ZYDIS ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build polyhook as shared libary" FORCE)
set(ZYDIS_BUILD_SHARED_LIB ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build zydis as shared libary" FORCE)
set(ZYCORE_BUILD_SHARED_LIB ${MAKE_POLYHOOK_DEPENDENCIES_SHARED} CACHE BOOL "Build zycore as shared libary" FORCE)
set(ASMJIT_STATIC ${MAKE_POLYHOOK_DEPENDENCIES_STATIC} CACHE BOOL "Build asmjit as shared libary" FORCE)
set(POLYHOOK_BUILD_STATIC_RUNTIME OFF CACHE BOOL "Use static runtime" FORCE)
set(POLYHOOK_DISASM_CAPSTONE OFF CACHE BOOL "Enable capstone support" FORCE)
set(POLYHOOK_DISASM_CAPSTONE_FULL OFF CACHE BOOL "Build all features of capstone." FORCE)
set(POLYHOOK_DISASM_ZYDIS ON CACHE BOOL "Enable Zydis support." FORCE)
add_subdirectory(Dependencies/PolyHook_2_0)
# For some reason, PolyHook isn't adding the capstone or zydis include directories
include_directories(Dependencies/PolyHook_2_0)
include_directories(Dependencies/PolyHook_2_0/capstone/include)
include_directories(Dependencies/PolyHook_2_0/zydis/include)
include_directories(Dependencies/PolyHook_2_0/zydis/dependencies/zycore/include)
include_directories(Dependencies/PolyHook_2_0/zydis/msvc)

add_subdirectory("Dependencies/Unreal")
add_subdirectory("Dependencies/MProgram")
add_subdirectory("Dependencies/Input")
add_subdirectory("Dependencies/LuaRaw")
add_subdirectory("Dependencies/LuaMadeSimple")
add_subdirectory("Dependencies/FunctionTimer")
add_subdirectory("Dependencies/ScopedTimer")

# fmtlib::fmt
# This is to be removed when std::format is fully available in the MSVC C++20 toolchain
# I'm using the header-only variant because I can't seem to figure out why it won't link
set(CMAKE_POSITION_INDEPENDENT_CODE ON)
add_subdirectory(Dependencies/fmt)

add_subdirectory("Dependencies/ParserBase")
add_subdirectory("Dependencies/IniParser")
add_subdirectory("Dependencies/JSON")
add_subdirectory("Dependencies/ArgsParser")
add_subdirectory("Dependencies/LuaBindingsGenerator")

# UE4SS
# Settings override -> START
# Used for external manipulation until the entire cmake file has been redone
# An external tool may create these files before running cmake to alter build options
# The external tool must also remove these files after it's done running as to not interfere with the normal build process
if (${FORCE_WITH_CASE_PRESERVING_NAME} MATCHES 0)
    if (EXISTS "${UE4SS_GENERATED_SOURCE_DIR}/enable_with_case_preserving.build_option")
        message("WITH_CASE_PRESERVING_NAME overridden to 1 by '${UE4SS_GENERATED_SOURCE_DIR}/enable_with_case_preserving.build_option'")
        set(WITH_CASE_PRESERVING_NAME 1)
    elseif (EXISTS "${UE4SS_GENERATED_SOURCE_DIR}/disable_with_case_preserving.build_option")
        message("WITH_CASE_PRESERVING_NAME overridden to 0 by '${UE4SS_GENERATED_SOURCE_DIR}/disable_with_case_preserving.build_option'")
        set(WITH_CASE_PRESERVING_NAME 0)
    endif ()
else()
    set(WITH_CASE_PRESERVING_NAME 1)
endif ()
# Settings override -> END

# Version override -> START
file(READ ${UE4SS_GENERATED_SOURCE_DIR}/version.cache UE4SS_LIB_VERSION)
string(REGEX MATCHALL "([0-9]+).([0-9]+).([0-9]+).([0-9]+).([0-9]+)" TEST_OUTPUT_ABC "${UE4SS_LIB_VERSION}")
set(UE4SS_LIB_VERSION_MAJOR ${CMAKE_MATCH_1})
set(UE4SS_LIB_VERSION_MINOR ${CMAKE_MATCH_2})
set(UE4SS_LIB_VERSION_HOTFIX ${CMAKE_MATCH_3})
set(UE4SS_LIB_VERSION_PRERELEASE ${CMAKE_MATCH_4})  # Publicly available pre-release
set(UE4SS_LIB_VERSION_BETA ${CMAKE_MATCH_5})  # Internal version to keep track of pre-pre-releases
file(WRITE ${UE4SS_GENERATED_SOURCE_DIR}/version.cache "${UE4SS_LIB_VERSION}")

message("UE4SS")
message("Major: ${UE4SS_LIB_VERSION_MAJOR}, Minor: ${UE4SS_LIB_VERSION_MINOR}, Hotfix: ${UE4SS_LIB_VERSION_HOTFIX}, PreRelease: ${UE4SS_LIB_VERSION_PRERELEASE}, Beta: ${UE4SS_LIB_VERSION_BETA}")

# Make the hard-coded build numbers available to source files
add_compile_definitions(
        UE4SS_LIB_VERSION_MAJOR=${UE4SS_LIB_VERSION_MAJOR}
        UE4SS_LIB_VERSION_MINOR=${UE4SS_LIB_VERSION_MINOR}
        UE4SS_LIB_VERSION_HOTFIX=${UE4SS_LIB_VERSION_HOTFIX}
        UE4SS_LIB_VERSION_PRERELEASE=${UE4SS_LIB_VERSION_PRERELEASE}
        UE4SS_LIB_VERSION_BETA=${UE4SS_LIB_VERSION_BETA}
        UE4SS_LIB_BETA_STARTED=${UE4SS_LIB_BETA_STARTED}
        UE4SS_LIB_IS_BETA=${UE4SS_LIB_IS_BETA}
)
# Version override -> END

# Tell WinAPI macros to map to unicode functions instead of ansi
add_compile_definitions(_UNICODE)
add_compile_definitions(UNICODE)

set(${TARGET}_Sources
        "${CMAKE_CURRENT_SOURCE_DIR}/src/main_ue4ss_rewritten.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/UE4SSProgram.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/SettingsManager.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/ObjectDumper/ObjectToString.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/Signatures.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/Mod.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/UnrealCustom/CustomProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaLibrary.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaMod.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUObject.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUStruct.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUClass.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaAActor.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFName.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUScriptStruct.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaTArray.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUFunction.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaCustomProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFText.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFString.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXFieldClass.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXObjectProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXBoolProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXStructProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXEnumProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaXArrayProperty.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUEnum.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFOutputDevice.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFWeakObjectPtr.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaFSoftObjectPath.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaTSoftClassPtr.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/LuaType/LuaUWorld.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/SDKGenerator/Common.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/SDKGenerator/Generator.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/SDKGenerator/UEHeaderGenerator.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/SDKGenerator/JSONDumper.cpp"
        #"${CMAKE_CURRENT_SOURCE_DIR}/src/LuaCustomMemberFunctions.cpp"
        #"${CMAKE_CURRENT_SOURCE_DIR}/src/LuaScriptMemoryAccess.cpp"
        #"${CMAKE_CURRENT_SOURCE_DIR}/src/LuaTests.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/GUI.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/DX11.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/Windows.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/Console.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/ConsoleOutputDevice.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/LiveView.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/Dumpers.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/src/GUI/ImGuiUtility.cpp"

        # imgui
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/imgui.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/imgui_draw.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/imgui_tables.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/imgui_widgets.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/misc/cpp/imgui_stdlib.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/backends/imgui_impl_win32.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/backends/imgui_impl_dx11.cpp"
        "${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/ImGuiColorTextEdit/TextEditor.cpp"
        #"${CMAKE_CURRENT_SOURCE_DIR}/Dependencies/imgui/imgui_demo.cpp"
        )
add_library(${TARGET} SHARED ${${TARGET}_Sources})
target_include_directories(${TARGET} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/generated_include> $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/LuaBindings/include>)
target_compile_options(${TARGET} PRIVATE ${PRIVATE_COMPILE_OPTIONS})
target_link_options(${TARGET} PRIVATE ${PRIVATE_LINK_OPTIONS})
target_compile_features(${TARGET} PUBLIC ${PUBLIC_COMPILE_FEATURES})
target_compile_definitions(${TARGET} PUBLIC $<${MAKE_DEPENDENCIES_SHARED}:LUA_BUILD_AS_DLL>)
set(UE4SS_LINK_WITH_LIBRARIES File DynamicOutput Unreal SinglePassSigScanner LuaMadeSimple FunctionTimer Function IniParser JSON Input PolyHook_2 d3d11)
set(UE4SS_LINK_WITH_INTERFACE_LIBRARIES fmt::fmt-header-only Function Constructs Helpers MProgram ScopedTimer)
target_link_libraries(${TARGET} PRIVATE ${UE4SS_LINK_WITH_LIBRARIES} ${UE4SS_LINK_WITH_INTERFACE_LIBRARIES})

set(XINPUT_TARGET xinput1_3)
enable_language(ASM_MASM)
file(GLOB XINPUT_SOURCES "xinput/*")
add_library(${XINPUT_TARGET} SHARED ${${TARGET}_Sources} ${XINPUT_SOURCES})
target_include_directories(${XINPUT_TARGET} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include> $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/generated_include> $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/LuaBindings/include>)
target_compile_features(${XINPUT_TARGET} PUBLIC cxx_std_20)
target_compile_definitions(${XINPUT_TARGET} PUBLIC $<${MAKE_DEPENDENCIES_SHARED}:LUA_BUILD_AS_DLL> UE4SS_LIB_BUILD_AS_XINPUT=1)
target_compile_options(${XINPUT_TARGET} PRIVATE ${PRIVATE_MASM_COMPILE_OPTIONS})
target_link_options(${XINPUT_TARGET} PRIVATE ${PRIVATE_LINK_OPTIONS})
target_link_libraries(${XINPUT_TARGET} PRIVATE ${UE4SS_LINK_WITH_LIBRARIES} ${UE4SS_LINK_WITH_INTERFACE_LIBRARIES})

if (${MAKE_DEPENDENCIES_STATIC} EQUAL 1)
    target_compile_definitions(${TARGET} PRIVATE ${UE4SS_COMPILE_DEFINITIONS})
    target_compile_definitions(${XINPUT_TARGET} PRIVATE ${UE4SS_COMPILE_DEFINITIONS})
endif()

set_property(TARGET ${TARGET} PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
set_property(TARGET ${XINPUT_TARGET} PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)

# imgui -> START
set(IMGUI_INCLUDES Dependencies/imgui Dependencies/ImGuiColorTextEdit)
target_include_directories(${TARGET} PUBLIC ${IMGUI_INCLUDES})
target_include_directories(${XINPUT_TARGET} PUBLIC ${IMGUI_INCLUDES})
# imgui -> END

# Auto incrementing build number -> START
# Fetch the auto incrementing build number
file(READ ${UE4SS_GENERATED_SOURCE_DIR}/build_number.cache UE4SS_LIB_BUILD_NUMBER)
message("Build #${UE4SS_LIB_BUILD_NUMBER} (Target: ${TARGET})")
add_custom_target(IncrementBuildNumber
        COMMAND ${CMAKE_COMMAND}
        -DRC_SOURCE_DIR:PATH="${PROJECT_SOURCE_DIR}"
        -DUE4SS_GENERATED_SOURCE_DIR:PATH="${UE4SS_GENERATED_SOURCE_DIR}"
        -DUE4SS_GENERATED_INCLUDE_DIR:PATH="${UE4SS_GENERATED_INCLUDE_DIR}"
        -P "${UE4SS_GENERATED_SOURCE_DIR}/build_number.cmake"
        )
add_dependencies(${TARGET} IncrementBuildNumber)
add_dependencies(${XINPUT_TARGET} IncrementBuildNumber)
# Auto incrementing build number -> END

# LuaBindingsGenerator -> START
# Create a list of all source files for this project so that LuaBindingsGenerator can know which files to parse.
get_directory_property(Unreal_Sources DIRECTORY Dependencies/Unreal DEFINITION Unreal_Sources)
set(UE4SS_LUA_BINDINGS_GENERATOR_FILES_TO_PARSE "${${TARGET}_Sources};${Unreal_Sources}")

foreach (FILE_TO_PARSE ${UE4SS_LUA_BINDINGS_GENERATOR_FILES_TO_PARSE})
    set(UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_SOURCES_ARGS "${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_SOURCES_ARGS} -sources=\"${FILE_TO_PARSE}\"")
endforeach ()

# https://discourse.cmake.org/t/cmake-list-of-all-project-targets/1077/17
function(_get_all_cmake_targets out_var current_dir)
    get_property(targets DIRECTORY ${current_dir} PROPERTY BUILDSYSTEM_TARGETS)
    get_property(subdirs DIRECTORY ${current_dir} PROPERTY SUBDIRECTORIES)

    foreach (subdir ${subdirs})
        _get_all_cmake_targets(subdir_targets ${subdir})
        list(APPEND targets ${subdir_targets})
    endforeach ()

    set(${out_var} ${targets} PARENT_SCOPE)
endfunction()
_get_all_cmake_targets(ALL_TARGETS ${CMAKE_CURRENT_LIST_DIR})

# Create a list of all include directories so that LuaBindingsGenerator can parse #include statements properly.
set(UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS "")
foreach (THE_TARGET ${ALL_TARGETS})
    get_target_property(TARGET_INCLUDES ${THE_TARGET} INTERFACE_INCLUDE_DIRECTORIES)

    foreach (THE_INCLUDE ${TARGET_INCLUDES})
        if ((NOT "${THE_INCLUDE}" STREQUAL "TARGET_INCLUDES-NOTFOUND") AND (NOT ${THE_INCLUDE} MATCHES "<INSTALL_INTERFACE:"))
            if (${THE_INCLUDE} MATCHES <BUILD_INTERFACE:)
                string(REPLACE "$<BUILD_INTERFACE:" "" THE_INCLUDE ${THE_INCLUDE})
                string(REGEX REPLACE ">$" "" THE_INCLUDE ${THE_INCLUDE})
            endif ()
            set(THE_INCLUDE "-compiler_flags=\"-I${THE_INCLUDE}\"")
            #string(REPLACE "-I" "-compiler_flags=" THE_INCLUDE ${THE_INCLUDE})
            message("THE_INCLUDE: ${THE_INCLUDE}")
            list(APPEND UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS ${THE_INCLUDE})
        endif ()
    endforeach ()

    list(REMOVE_DUPLICATES UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS)
endforeach ()
string(REPLACE ";" " " UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS "${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS}")

get_target_property(ALL_COMPILE_DEFINITIONS ${XINPUT_TARGET} COMPILE_DEFINITIONS)
foreach (COMPILE_DEFINITION ${ALL_COMPILE_DEFINITIONS})
    if (NOT ${COMPILE_DEFINITION} MATCHES "(\\$).*")
        message("COMPILE_DEFINITION: ${COMPILE_DEFINITION}")
        set(UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS "${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS} -compiler_flags=\"-D${COMPILE_DEFINITION}\"")
    endif ()
endforeach()

# Create command line arguments for LuaBindingsGenerator.
set(UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_ARGUMENTS "-output=\"${CMAKE_SOURCE_DIR}/LuaBindings\" ${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_SOURCES_ARGS} -compiler_flags=\"-std=c++20\" ${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_COMPILER_FLAGS_ARGS}")

message("UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_ARGUMENTS: ${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_ARGUMENTS}")

if (UE4SS_GENERATE_LUA_BINDINGS EQUAL 1)
    # Create a custom target that executes before UE4SS compiles which will use LuaBindingGenerator to generate the Lua bindings.
    set(LuaBindingsGeneratorBin ${LIBRARY_OUTPUT_PATH})
    message("LuaBindingsGeneratorBin: ${LuaBindingsGeneratorBin}")
    add_custom_target(LuaBindingsGeneratorExec
            COMMAND ${LuaBindingsGeneratorBin}/LuaWrapperGenerator.exe "${UE4SS_LUA_BINDINGS_GENERATOR_COMMAND_LINE_ARGUMENTS}"
            WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
            DEPENDS LuaWrapperGenerator
            )
    add_dependencies(${TARGET} LuaBindingsGeneratorExec)
    add_dependencies(${XINPUT_TARGET} LuaBindingsGeneratorExec)
    # LuaBindingsGenerator -> END
endif ()

```

`Changelog_1.1.txt`:

```txt
New
* There's a new way to install & use UE4SS, using xinput1_3.dll. More information can be found in the installation guide.
* Added a UHT compatible header generator. Useful for creating BP mods.
* Added a caching system to the aob scanner. It will scan for everything during the first start,
and then it will use the cache for subsequent starts until either the game exe changed or the ue4ss dll changed.
* Added "InvalidateCacheIfDLLDiffers" to the settings file. When this is 0, the cache won't be invalidated if ue4ss.dll has changed.
* Each game can now have its own directory in the root directory of UE4SS, it will automatically be detected and its config & mods
folder will be used instead of the ones in the root directory or the "/Binaries/Win64" directory. This is an optional feature,
you can keep using UE4SS identically to how you've been using it in 1.0.
* Added support to the dumper for the 'DelegateFunction' of 'DelegateProperty','MulticastInlineDelegateProperty' &
'MulticastSparseDelegateProperty', the format is '[df: address]'.
* Added support for games that are compiled with the 'WITH_CASE_PRESERVING_NAME' flag.
An additional dll file is now shipped that should replace the normal one for these games.
* The log file is now re-created on every start of UE4SS.
* The files 'UE4SS.log' and 'UE4SS_ObjectDump.txt' are now always created in the working directory instead of always in the game executable directory.
* Added many new offsets that can be overridden in 'UE4SS-settings.ini', including the MapProperty offsets that were missing in 1.0.
* If there are AOBs or offsets that aren't found, there will now be a message in the log file that tells you what you can do about it.

Lua
* Added global function, 'ExecuteWithDelay', it asynchronously executes code after a specified delay. See API.txt for details.
* Added the 'UE4SS' class that has the member function, 'GetVersion', which returns 3 integers defining the UE4SS version, see API.txt.
* You can now use the FName table functions if you prefer that syntax over using ':', but remember to always pass an FName as the first parameter.

Fixes
* Fixed crash that occurred when hot-reloading mods if one or more Lua scripts had a syntax error.
* Fixed the hot-reload system not working if there was an error in one or more Lua scripts. Different problem than the above crash-fix.
* Fixed encoding problem. The result is that all generated files (such as log files and object dumper) are half as big.

```

`Changelog_Pre1_1.0.0_To_Pre2_1.0.0.txt`:

```txt
Added a config option, 'EnableHotReloadSystem', in the 'General' section.
Rewrote the input handler. This fixes a bug where you could only have one modifier key or strange things would happen.
Fixed a bug where the "FName" global Lua function was being overridden by the "FName" global metatable.
Fixed a compiler warning (unreferenced parameter).
```

`Changelog_Pre2_1.0.0_To_Pre3_1.0.0.txt`:

```txt
Added global Lua function, 'NotifyOnNewObject'. See API.txt for more information.
Added overload for Lua function, 'FName'. It takes the ComparisonIndex instead of a string.
Updated & fixed 'ConsoleEnablerMod'. It now auto-enables the console whenever a PlayerController is created.
```

`Changelog_Pre3_1.0.0_To_Pre4_1.0.0.txt`:

```txt
Added support for StrProperty (both C++ and Lua).
The 'Offset_Internal' value for RegisterCustomProperty can now be either an integer or a table that contains another property in
the same class as 'BelongsToClass' and a relative offset to add to the Offset_Internal of that property.
Added functions UObject.GetPropertyValue & UObject.SetPropertyValue.
Added UObjectReflection, Property, & PropertyClass. See API.txt for more information.
The 'ConsoleEnablerMod' will now only attempt to create a console if a console is not already attached to the GameViewportClient.
Some internal changes to 'FString' in the C++ api. It's now a TArray of wchar_t and the clear() function works properly.
Fixed memory leak in the FString implementation.
Fixed object dumper not dumping detailed information about the inner property (example: PropertyClass of ObjectProperty).
Fixed a bug where the game would crash if you used the global Lua function 'NotifyOnNewObject' and then used the hot-reload feature.
```

`Changelog_Pre4_1.0.0_To_Final_1.0.0.txt`:

```txt
Implemented "GetFullName" in UE4SS. This replaces the scan for the internal engine function.
Improved the speed of the object & property dumper.
```

`CustomGameConfigs/Borderlands 3/UE4SS-settings.ini`:

```ini
[Overrides]
; Path to the 'Mods' folder
; Default: <dll_directory>/Mods
ModsFolderPath =

[General]
EnableHotReloadSystem = 0

; Whether caches will be invalidated if ue4ss.dll has changed
; Default: 1
InvalidateCacheIfDLLDiffers = 1

; The maximum number attempts the scanner will try before erroring out if an aob isn't found
; Default: 60
MaxScanAttemptsNormal = 60

; The maximum number attempts the scanner will try for modular games before erroring out if an aob isn't found
; Default: 2000
MaxScanAttemptsModular = 2500

[EngineVersionOverride]
MajorVersion = 4
MinorVersion = 20

[ObjectDumper]
; Whether to force all assets to be loaded before dumping objects
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeDumpingObjects = 0

[CXXHeaderGenerator]
; Whether to property offsets and sizes
; Default: 0
DumpOffsetsAndSizes = 0

; Whether memory layouts of classes and structs should be accurate
; This must be set to 1, if you want to use the generated headers in an actual C++ project
; When set to 0, padding member variables will not be generated
; NOTE: A VALUE OF 1 HAS NO PURPOSE YET! MEMORY LAYOUT IS NOT ACCURATE EITHER WAY!
; Default: 0
KeepMemoryLayout = 0

; Whether to force all assets to be loaded before generating headers
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeGeneratingCXXHeaders = 0

[UHTHeaderGenerator]
; Whether to skip generating packages that belong to the engine
; Some games make alterations to the engine and for those games you might want to set this to 0
; Default: 0
IgnoreAllCoreEngineModules = 1

; Whether to skip generating the "Engine" and "CoreUObject" packages
; Default: 1
IgnoreEngineAndCoreUObject = 1

; Whether to force all UFUNCTION macros to have "BlueprintCallable"
; Note: This will cause some errors in the generated headers that you will need to manually fix
; Default: 0
MakeAllFunctionsBlueprintCallable = 0

; Whether to force all UPROPERTY macros to have 'BlueprintReadWrite'
; Also forces all UPROPERTY macros to have 'meta=(AllowPrivateAccess=true)'
; Default: 0
MakeAllPropertyBlueprintsReadWrite = 0

; Whether to force UENUM macros on enums to have 'BlueprintType' if the underlying type was implicit or uint8
; Note: This also forces the underlying type to be uint8 where the type would otherwise be implicit
; Default: 0
MakeEnumClassesBlueprintType = 0

[Debug]
; Whether to enable the external UE4SS debug console.
ConsoleEnabled = 1

[Threads]
; The number of threads that the sig scanner will use (not real cpu threads, can be over your physical & hyperthreading max)
; If the game is modular then multi-threading will always be off regardless of the settings in this file
; Min: 1
; Max: 4294967295
; Default: 8
SigScannerNumThreads = 8

; The minimum size that a module has to be in order for multi-threading to be enabled
; This should be large enough so that the cost of creating threads won't out-weigh the speed gained from scanning in multiple threads
; Min: 0
; Max: 4294967295
; Default: 16777216
SigScannerMultithreadingModuleSizeThreshold = 16777216

```

`CustomGameConfigs/Borderlands 3/VTableLayout.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal
UnknownFunc_1
UnknownFunc_2
UnknownFunc_3
UnknownFunc_4
UnknownFunc_5
UnknownFunc_6
UnknownFunc_7
UnknownFunc_8

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`CustomGameConfigs/Final Fantasy 7 Remake/MemberVariableLayout.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xB0
EventGraphFunction = 0xA8
FirstPropertyToInit = 0xA0
Func = 0xB8
FunctionFlags = 0x90
NumParms = 0x94
ParmsSize = 0x96
RPCId = 0x9A
RPCResponseId = 0x9C
ReturnValueOffset = 0x98

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
ActiveLevelCollectionIndex = 0x130
AudioDeviceHandle = 0x8F0
AudioTimeSeconds = 0x90C
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x978
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x910
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x8F8
NextSwitchCountdown = 0x960
NextURL = 0x950
NumInvalidReflectionCaptureComponents = 0x984
NumLightingUnbuiltObjects = 0x980
NumTextureStreamingDirtyResources = 0x98C
NumTextureStreamingUnbuiltComponents = 0x988
OriginOffsetThisFrame = 0x930
PauseDelay = 0x914
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x968
RealTimeSeconds = 0x908
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x86C
TimeSeconds = 0x900
UnpausedTimeSeconds = 0x904
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x990
bAggressiveLOD = 0x990
bAllowAudioPlayback = 0x990
bAreConstraintsDirty = 0x990
bBegunPlay = 0x990
bDebugDrawAllTraceTags = 0x888
bDebugFrameStepExecution = 0x990
bDebugPauseExecution = 0x990
bDoDelayedUpdateCullDistanceVolumes = 0x873
bDropDetail = 0x990
bHack_Force_UsesGameHiddenFlags_True = 0x878
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x990
bIsDefaultLevel = 0x990
bIsLevelStreamingFrozen = 0x870
bIsRunningConstructionScript = 0x879
bIsTearingDown = 0x990
bIsWorldInitialized = 0x868
bKismetScriptError = 0x990
bMatchStarted = 0x990
bPlayersOnly = 0x990
bPlayersOnlyPending = 0x990
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x990
bRequiresHitProxies = 0x388
bShouldForceUnloadStreamingLevels = 0x871
bShouldForceVisibleStreamingLevels = 0x872
bShouldSimulatePhysics = 0x87A
bShouldTick = 0x389
bStartup = 0x990
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xB0
ClassCastFlags = 0xC0
ClassConfigName = 0xD8
ClassConstructor = 0xA0
ClassDefaultObject = 0x100
ClassFlags = 0xBC
ClassGeneratedBy = 0xD0
ClassUnique = 0xB8
ClassVTableHelperCtorCaller = 0xA8
ClassWithin = 0xC8
Interfaces = 0x1A8
NetFields = 0xF0
bCooked = 0xB8

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`CustomGameConfigs/Final Fantasy 7 Remake/UE4SS_Signatures/FName_Constructor.lua`:

```lua
function Register()
    return "4 8/8 9/5 C/2 4/0 8/5 7/4 8/8 3/E C/3 0/4 8/8 B/D 9/4 8/8 9/5 4/2 4/2 0/3 3/C 9"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Final Fantasy 7 Remake/UE4SS_Signatures/FName_ToString.lua`:

```lua
function Register()
    return "E 8/? ?/? ?/? ?/? ?/4 8/6 3/9 E/4 0/0 1/0 0/0 0"
end

function OnMatchFound(MatchAddress)
    local CallInstr = MatchAddress
    local InstrSize = 5
    local NextInstr = CallInstr + InstrSize
    local Offset = DerefToInt32(CallInstr + 1)
    local ToStringAddress = NextInstr + Offset
    return ToStringAddress
end
```

`CustomGameConfigs/Final Fantasy 7 Remake/UE4SS_Signatures/StaticConstructObject.lua`:

```lua
function Register()
    return "4 8/8 9/5 C/2 4/1 8/5 5/5 6/5 7/4 1/5 4/4 1/5 5/4 1/5 6/4 1/5 7/4 8/8 1/E C/A 0/0 1/0 0/0 0/4 8/8 B"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Final Fantasy 7 Remake/VTableLayout.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
UnknownFunction_0
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`CustomGameConfigs/Kingdom Hearts 3/MemberVariableLayout.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x18
InternalIndex = 0xC
NamePrivate = 0x20
ObjectFlags = 0x8
OuterPrivate = 0x28

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x48
DestructorLinkNext = 0x80
ElementSize = 0x4C
NextRef = 0x78
Offset_Internal = 0x68
PostConstructLinkNext = 0x88
PropertyFlags = 0x50
PropertyLinkNext = 0x70
RepIndex = 0x58
RepNotifyFunc = 0x60

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xD0
EventGraphFunction = 0xB8
FirstPropertyToInit = 0xB0
Func = 0xC8
FunctionFlags = 0xA0
NumParms = 0xA6
ParmsSize = 0xA8
RPCId = 0xAC
RPCResponseId = 0xAE
RepOffset = 0xA4
ReturnValueOffset = 0xAA

[UField]
; 0x10 bytes between the end of UObject and UField::Next.
Next = 0x40

[FEnumProperty]
Enum = 0x98
UnderlyingProp = 0x90

[UStruct]
Children = 0x50
DestructorLink = 0x80
MinAlignment = 0x5C
PostConstructLink = 0x88
PropertiesSize = 0x58
PropertyLink = 0x70
RefLink = 0x78
Script = 0x60
ScriptObjectReferences = 0x90
SuperStruct = 0x48

[FDelegateProperty]
SignatureFunction = 0x90

[FMulticastDelegateProperty]
SignatureFunction = 0x90

[FObjectPropertyBase]
PropertyClass = 0x90

[FBoolProperty]
ByteMask = 0x92
ByteOffset = 0x91
FieldMask = 0x93
FieldSize = 0x90

[UScriptStruct]
CppStructOps = 0xA8
StructFlags = 0xA0
bPrepareCppStructOpsCompleted = 0xA4

; This struct has not been converted yet.
; You need to add +0x8 to each of these entries.
; UWorld is however not used for most UE4SS functionality so I'm not gonna bother with it for now.
[UWorld]
AudioDeviceHandle = 0x8F0
AudioTimeSeconds = 0x90C
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x978
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x910
ExtraReferencedObjects = 0x68
FullPurgeTriggered = 0x86C
LastTimeUnbuiltLightingWasEncountered = 0x8F8
NextSwitchCountdown = 0x960
NextURL = 0x950
NumInvalidReflectionCaptureComponents = 0x984
NumLightingUnbuiltObjects = 0x980
NumTextureStreamingDirtyResources = 0x98C
NumTextureStreamingUnbuiltComponents = 0x988
OriginOffsetThisFrame = 0x930
PauseDelay = 0x914
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x968
RealTimeSeconds = 0x908
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x870
TimeSeconds = 0x900
TimeSinceLastPendingKillPurge = 0x868
UnpausedTimeSeconds = 0x904
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x990
bAggressiveLOD = 0x990
bAllowAudioPlayback = 0x990
bAreConstraintsDirty = 0x990
bBegunPlay = 0x990
bDebugDrawAllTraceTags = 0x888
bDebugFrameStepExecution = 0x990
bDebugPauseExecution = 0x990
bDoDelayedUpdateCullDistanceVolumes = 0x877
bDropDetail = 0x990
bHack_Force_UsesGameHiddenFlags_True = 0x87C
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x990
bIsDefaultLevel = 0x990
bIsLevelStreamingFrozen = 0x874
bIsRunningConstructionScript = 0x87D
bIsTearingDown = 0x990
bIsWorldInitialized = 0x86E
bKismetScriptError = 0x990
bMatchStarted = 0x990
bPlayersOnly = 0x990
bPlayersOnlyPending = 0x990
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x990
bRequiresHitProxies = 0x388
bShouldDelayGarbageCollect = 0x86D
bShouldForceUnloadStreamingLevels = 0x875
bShouldForceVisibleStreamingLevels = 0x876
bShouldSimulatePhysics = 0x87E
bShouldTick = 0x389
bStartup = 0x990
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x90

[UClass]
ClassAddReferencedObjects = 0xC0
ClassCastFlags = 0xD0
ClassConfigName = 0xE8
ClassConstructor = 0xB0
; ClassDefaultObject has been confirmed correct.
ClassDefaultObject = 0x118
ClassFlags = 0xCC
ClassGeneratedBy = 0xE0
ClassUnique = 0xC8
ClassVTableHelperCtorCaller = 0xB8
; ClassWithin has been confirmed correct.
ClassWithin = 0xD8
; There's something odd here.
; Interfaces is supposed to be at 0x218 but it's at 0x1D0.
; This suggests that the devs for some reason removed stuff from the original struct.
; Something between ClassDefaultObject and Interfaces is different.
; CppTypeInfo (0x120) has been confirmed correct (not included in this file).
; FuncMap (0x128) has been confirmed correct (not included in this file).
; ParentFuncMap seems to be missing or is inlined, smaller and empty maybe ?
; This will only be a problem if there are any structs that inherit from UClass in this file, which I dont' think there are at the moment.
; If there is in the future, then you'll have to adjust those offsets to account for the missing/smaller stuff in UClass.
Interfaces = 0x1D0
; NetFields has been confirmed correct.
NetFields = 0x108
bCooked = 0xF0

[UEnum]
CppForm = 0x68
CppType = 0x48
EnumDisplayNameFn = 0x70
Names = 0x58

[FMapProperty]
KeyProp = 0x90
ValueProp = 0x98

[FStructProperty]
Struct = 0x90

[FArrayProperty]
Inner = 0x90

[FByteProperty]
Enum = 0x90

[FClassProperty]
MetaClass = 0x98

[FInterfaceProperty]
InterfaceClass = 0x90


```

`CustomGameConfigs/Kingdom Hearts 3/UE4SS_Signatures/FName_Constructor.lua`:

```lua
function Register()
    return "4053 4883EC30 488BD9 4885D2 7421 458BC8 C74424 28 FFFFFFFF 4533C0 C644242001 E8DA040000 488BC3"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Kingdom Hearts 3/UE4SS_Signatures/FName_ToString.lua`:

```lua
function Register()
    return "4 8/8 9/5 C/2 4/0 8/4 8/8 9/7 4/2 4/1 0/4 8/8 9/7 C/2 4/1 8/4 1/5 6/4 8/8 3/E C/2 0/4 8/8 B/D A/4 C/8 B/F 1/? ?/? ?/? ?/? ?/? ?/4 C/8 B/C 8/4 1/8 B/0 6/9 9"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Kingdom Hearts 3/UE4SS_Signatures/StaticConstructObject.lua`:

```lua
function Register()
    return "4 0/5 5/5 6/5 7/4 1/5 4/4 1/5 5/4 1/5 6/4 1/5 7/4 8/8 1/E C/B 0/0 1/0 0/0 0"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Kingdom Hearts 3/VTableLayout.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister
UnknownFunction_1

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`CustomGameConfigs/Readme.md`:

```md
These settings are for games that have altered the engine in ways that make UE4SS not work out of the box.  
The folder structure in each game folder is the same as the regular UE4SS structure, meaning that files in the root directory go in the UE4SS root directory.

```

`CustomGameConfigs/Satisfactory/UE4SS_Signatures/FName_Constructor.lua`:

```lua
function Register()
    return "E 8/? ?/? ?/? ?/? ?/4 8/8 B/4 4/2 4/3 0/4 8/8 9/? ?/? ?/? ?/? ?/? ?/C 7/0 5"
end

function OnMatchFound(MatchAddress)
    local CallInstr = MatchAddress
    local InstrSize = 5
    local NextInstr = CallInstr + InstrSize
    local Offset = DerefToInt32(CallInstr + 1)
    local FNameConstructorAddress = NextInstr + Offset
    return FNameConstructorAddress
end
```

`CustomGameConfigs/The Outer Worlds/MemberVariableLayout.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20
; There's an extra 8 bytes at the end of UObjectBase.

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x68
ElementSize = 0x3C
NextRef = 0x60
Offset_Internal = 0x4C
PostConstructLinkNext = 0x70
PropertyFlags = 0x40
PropertyLinkNext = 0x58
RepIndex = 0x48
RepNotifyFunc = 0x50

[FSoftClassProperty]
MetaClass = 0x80

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xB0
EventGraphFunction = 0xA8
FirstPropertyToInit = 0xA0
Func = 0xB8
FunctionFlags = 0x90
NumParms = 0x94
ParmsSize = 0x96
RPCId = 0x9A
RPCResponseId = 0x9C
ReturnValueOffset = 0x98

[UField]
Next = 0x30

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
Children = 0x40
DestructorLink = 0x70
MinAlignment = 0x4C
PostConstructLink = 0x78
PropertiesSize = 0x48
PropertyLink = 0x60
RefLink = 0x68
Script = 0x50
ScriptObjectReferences = 0x80
SuperStruct = 0x38

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x98
StructFlags = 0x90
bPrepareCppStructOpsCompleted = 0x94

; This struct has not been converted yet.
; You need to add +0x8 to each of these entries.
; UWorld is however not used for most UE4SS functionality so I'm not gonna bother with it for now.
[UWorld]
ActiveLevelCollectionIndex = 0x180
AudioDeviceHandle = 0x748
AudioTimeSeconds = 0x764
BuildStreamingDataTimer = 0x4A8
CommittedPersistentLevelName = 0x7D0
DebugDrawTraceTag = 0x6D8
DeltaTimeSeconds = 0x768
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x750
NextSwitchCountdown = 0x7B8
NextURL = 0x7A8
NumLightingUnbuiltObjects = 0x7D8
NumTextureStreamingDirtyResources = 0x7E4
NumTextureStreamingUnbuiltComponents = 0x7E0
NumUnbuiltReflectionCaptures = 0x7DC
OriginOffsetThisFrame = 0x788
PauseDelay = 0x76C
PerModuleDataObjects = 0x78
PlayerNum = 0x6BC
PreparingLevelNames = 0x7C0
RealTimeSeconds = 0x760
StreamingLevelsPrefix = 0xE8
StreamingVolumeUpdateDelay = 0x6C4
TimeSeconds = 0x758
UnpausedTimeSeconds = 0x75C
ViewLocationsRenderedLastFrame = 0x120
bActorsInitialized = 0x7E8
bAggressiveLOD = 0x7E8
bAllowAudioPlayback = 0x7E8
bAreConstraintsDirty = 0x7E8
bBegunPlay = 0x7E8
bCleanedUpWorld = 0x7E8
bDebugDrawAllTraceTags = 0x6E0
bDebugFrameStepExecution = 0x7E8
bDebugPauseExecution = 0x7E8
bDoDelayedUpdateCullDistanceVolumes = 0x6CC
bDropDetail = 0x7E8
bHack_Force_UsesGameHiddenFlags_True = 0x6D4
bInTick = 0x5A8
bIsBuilt = 0x5A9
bIsCameraMoveableWhenPaused = 0x7E8
bIsDefaultLevel = 0x7E8
bIsLevelStreamingFrozen = 0x6C8
bIsRunningConstructionScript = 0x6D5
bIsTearingDown = 0x7E8
bIsWorldInitialized = 0x6C0
bKismetScriptError = 0x7E8
bMarkedObjectsPendingKill = 0x7E8
bMatchStarted = 0x7E8
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x6CB
bPlayersOnly = 0x7E8
bPlayersOnlyPending = 0x7E8
bPostTickComponentUpdate = 0x6B8
bRequestedBlockOnAsyncLoading = 0x7E8
bRequiresHitProxies = 0x3D8
bShouldForceUnloadStreamingLevels = 0x6C9
bShouldForceVisibleStreamingLevels = 0x6CA
bShouldSimulatePhysics = 0x6D6
bShouldTick = 0x3D9
bStartup = 0x7E8
bStreamingDataDirty = 0x4A0
bTickNewlySpawned = 0x5AA
bTriggerPostLoadMap = 0x130
bWorldWasLoadedThisTick = 0x130

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xB0
ClassConfigName = 0xE0
ClassConstructor = 0xA0
ClassDefaultObject = 0x108
ClassFlags = 0xBC
ClassGeneratedBy = 0xD0
ClassUnique = 0xB8
ClassVTableHelperCtorCaller = 0xA8
ClassWithin = 0xC8
Interfaces = 0x1B8
NetFields = 0xF8
UberGraphFramePointerProperty = 0xD8
bCooked = 0xB8

[UEnum]
CppForm = 0x58
CppType = 0x38
EnumDisplayNameFn = 0x60
Names = 0x48

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`CustomGameConfigs/The Outer Worlds/Readme.md`:

```md
This game is currently unsupported.  
These files are here just for future reference if support is ever added.
```

`CustomGameConfigs/The Outer Worlds/UE4SS-settings.ini`:

```ini
[Overrides]
; Path to the 'Mods' folder
; Default: <dll_directory>/Mods
ModsFolderPath =

[General]
EnableHotReloadSystem = 0

; Whether caches will be invalidated if ue4ss.dll has changed
; Default: 1
InvalidateCacheIfDLLDiffers = 1

; The maximum number attempts the scanner will try before erroring out if an aob isn't found
; Default: 60
MaxScanAttemptsNormal = 60

; The maximum number attempts the scanner will try for modular games before erroring out if an aob isn't found
; Default: 2000
MaxScanAttemptsModular = 2500

[EngineVersionOverride]
MajorVersion = 
MinorVersion =

[ObjectDumper]
; Whether to force all assets to be loaded before dumping objects
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeDumpingObjects = 0

[CXXHeaderGenerator]
; Whether to property offsets and sizes
; Default: 0
DumpOffsetsAndSizes = 1

; Whether memory layouts of classes and structs should be accurate
; This must be set to 1, if you want to use the generated headers in an actual C++ project
; When set to 0, padding member variables will not be generated
; NOTE: A VALUE OF 1 HAS NO PURPOSE YET! MEMORY LAYOUT IS NOT ACCURATE EITHER WAY!
; Default: 0
KeepMemoryLayout = 0

; Whether to force all assets to be loaded before generating headers
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeGeneratingCXXHeaders = 0

[UHTHeaderGenerator]
; Whether to skip generating packages that belong to the engine
; Some games make alterations to the engine and for those games you might want to set this to 0
; Default: 0
IgnoreAllCoreEngineModules = 1

; Whether to skip generating the "Engine" and "CoreUObject" packages
; Default: 1
IgnoreEngineAndCoreUObject = 1

; Whether to force all UFUNCTION macros to have "BlueprintCallable"
; Note: This will cause some errors in the generated headers that you will need to manually fix
; Default: 0
MakeAllFunctionsBlueprintCallable = 0

; Whether to force all UPROPERTY macros to have 'BlueprintReadWrite'
; Also forces all UPROPERTY macros to have 'meta=(AllowPrivateAccess=true)'
; Default: 0
MakeAllPropertyBlueprintsReadWrite = 0

; Whether to force UENUM macros on enums to have 'BlueprintType' if the underlying type was implicit or uint8
; Note: This also forces the underlying type to be uint8 where the type would otherwise be implicit
; Default: 0
MakeEnumClassesBlueprintType = 0

[Debug]
; Whether to enable the external UE4SS debug console.
ConsoleEnabled = 1

[Threads]
; The number of threads that the sig scanner will use (not real cpu threads, can be over your physical & hyperthreading max)
; If the game is modular then multi-threading will always be off regardless of the settings in this file
; Min: 1
; Max: 4294967295
; Default: 8
SigScannerNumThreads = 8

; The minimum size that a module has to be in order for multi-threading to be enabled
; This should be large enough so that the cost of creating threads won't out-weigh the speed gained from scanning in multiple threads
; Min: 0
; Max: 4294967295
; Default: 16777216
SigScannerMultithreadingModuleSizeThreshold = 16777216

```

`CustomGameConfigs/The Outer Worlds/VTableLayout.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
UnknownFunction_1
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
UnknownFunction_2
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType
UnknownFunction_1

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`CustomGameConfigs/Walking Dead Saints & Sinners/UE4SS_Signatures/FName_Constructor.lua`:

```lua
function Register()
    return "48 89 5C 24 08 57 48 83 EC 30 48 8B D9 48 89 54 24 20 33 C9 41 8B F8 4C 8B DA 44"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/Walking Dead Saints & Sinners/UE4SS_Signatures/FName_ToString.lua`:

```lua
function Register()
    return "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 48 83 EC 20 48 8B DA 48 8B F1 E8 ?? ?? ?? ?? 44 8B 46 04"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`CustomGameConfigs/cyubeVR/UE4SS_Signatures/FName_Constructor.lua`:

```lua
function Register()
    return "E8 ?? ?? ?? ?? 4C 8B 6C 24 58 4D 89 2E"
end

function OnMatchFound(MatchAddress)
    local CallInstr = MatchAddress
    local InstrSize = 5
    local NextInstr = CallInstr + InstrSize
    local Offset = DerefToInt32(CallInstr + 1)
    local FNameConstructorAddress = NextInstr + Offset
    return FNameConstructorAddress
end
```

`CustomGameConfigs/cyubeVR/UE4SS_Signatures/FName_ToString.lua`:

```lua
function Register()
    --return "E 8/? ?/? ?/? ?/? ?/4 8/8 B/4 C/2 4/? ?/8 B/F D/4 8/8 5/C 9"
    return "41 57 41 56 41 55 41 54 56 57 53 48 81 EC 20 08 00 00 49 89 D5 49 89 CF"
end

function OnMatchFound(MatchAddress)
    --local AOBSize = 22
    --local CallInstr = MatchAddress
    --local InstrSize = 5
    --local NextInstr = CallInstr + InstrSize
    --local Offset = DerefToInt32(CallInstr + 1)
    --local ToStringAddress = NextInstr + Offset
    --return ToStringAddress
    return MatchAddress
end
```

`CustomGameConfigs/cyubeVR/UE4SS_Signatures/GMalloc.lua`:

```lua
function Register()
    return "48 8B ?? ?? ?? ?? ?? 48 8B 01 FF 50 78 8B ?? ?? ?? ?? ?? 8B"
end

function OnMatchFound(MatchAddress)
    local MovInstr = MatchAddress
    local NextInstr = MovInstr + 0x7
    local Offset = MovInstr + 0x3
    local AddressMoved = NextInstr + DerefToInt32(Offset)
    return AddressMoved
end
```

`CustomGameConfigs/cyubeVR/UE4SS_Signatures/GUObjectArray.lua`:

```lua
function Register()
    return "48 8D ?? ?? ?? ?? ?? E8 ?? ?? ?? ?? C6 05 ?? ?? ?? ?? ?? 80 3D"
end

function OnMatchFound(MatchAddress)
    local LeaInstr = MatchAddress
    local NextInstr = LeaInstr + 0x7
    local Offset = LeaInstr + 0x3
    local AddressLoaded = NextInstr + DerefToInt32(Offset)
    return AddressLoaded
end
```

`CustomGameConfigs/cyubeVR/UE4SS_Signatures/StaticConstructObject.lua`:

```lua
function Register()
    return "41 56 56 57 55 53 48 81 EC A0 01 00 00 48 89 CF"
end

function OnMatchFound(MatchAddress)
    return MatchAddress
end
```

`Dependencies/CommitAndPushAllFirstPartyDependencies.bat`:

```bat
@echo off

set CommitMessage=%~1
IF NOT DEFINED %CommitMessage (
    echo Could not commit and push changes because no commit message was given
    pause
    exit /b
)

cd Constructs
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd DynamicOutput
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd File
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd Function
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd FunctionTimer
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd Helpers
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd IniParser
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd Input
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd JSON
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd LuaMadeSimple
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd LuaRaw
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd MProgram
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd ParserBase
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd ScopedTimer
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd SinglePassSigScanner
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

cd Unreal
git add -A
git commit -m "%CommitMessage%"
git push
cd ..

pause
```

`Internal_Docs/4_12.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet			        =0x00000080,
    //RF_Unused				            =0x00000100,
    RF_TagGarbageTemp			        =0x00000200,

    RF_NeedLoad					        =0x00000400,
    //RF_Unused                         =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    //RF_Unused                         =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    //RF_Unused                         =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    //RF_Unused		                    =0x02000000,
    RF_Dynamic                          =0x04000000,
};

#define CPF_Edit							DECLARE_UINT64(0x0000000000000001)		// Property is user-settable in the editor.
#define CPF_ConstParm						DECLARE_UINT64(0x0000000000000002)		// This is a constant function parameter
#define CPF_BlueprintVisible				DECLARE_UINT64(0x0000000000000004)		// This property can be read by blueprint code
#define CPF_ExportObject					DECLARE_UINT64(0x0000000000000008)		// Object can be exported with actor.
#define CPF_BlueprintReadOnly				DECLARE_UINT64(0x0000000000000010)		// This property cannot be modified by blueprint code
#define CPF_Net								DECLARE_UINT64(0x0000000000000020)		// Property is relevant to network replication.
#define CPF_EditFixedSize					DECLARE_UINT64(0x0000000000000040)		// Indicates that elements of an array can be modified, but its size cannot be changed.
#define CPF_Parm							DECLARE_UINT64(0x0000000000000080)		// Function/When call parameter.
#define CPF_OutParm							DECLARE_UINT64(0x0000000000000100)		// Value is copied out after function call.
#define CPF_ZeroConstructor					DECLARE_UINT64(0x0000000000000200)		// memset is fine for construction
#define CPF_ReturnParm						DECLARE_UINT64(0x0000000000000400)		// Return value.
#define CPF_DisableEditOnTemplate			DECLARE_UINT64(0x0000000000000800)		// Disable editing of this property on an archetype/sub-blueprint
//#define CPF_      						DECLARE_UINT64(0x0000000000001000)		// 
#define CPF_Transient   					DECLARE_UINT64(0x0000000000002000)		// Property is transient: shouldn't be saved, zero-filled at load time.
#define CPF_Config      					DECLARE_UINT64(0x0000000000004000)		// Property should be loaded/saved as permanent profile.
//#define CPF_								DECLARE_UINT64(0x0000000000008000)		// 
#define CPF_DisableEditOnInstance			DECLARE_UINT64(0x0000000000010000)		// Disable editing on an instance of this class
#define CPF_EditConst   					DECLARE_UINT64(0x0000000000020000)		// Property is uneditable in the editor.
#define CPF_GlobalConfig					DECLARE_UINT64(0x0000000000040000)		// Load config from base class, not subclass.
#define CPF_InstancedReference				DECLARE_UINT64(0x0000000000080000)		// Property is a component references.
//#define CPF_								DECLARE_UINT64(0x0000000000100000)
#define CPF_DuplicateTransient				DECLARE_UINT64(0x0000000000200000)		// Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
#define CPF_SubobjectReference				DECLARE_UINT64(0x0000000000400000)		// Property contains subobject references (TSubobjectPtr)
//#define CPF_    							DECLARE_UINT64(0x0000000000800000)		// 
#define CPF_SaveGame						DECLARE_UINT64(0x0000000001000000)		// Property should be serialized for save games
#define CPF_NoClear							DECLARE_UINT64(0x0000000002000000)		// Hide clear (and browse) button.
//#define CPF_  							DECLARE_UINT64(0x0000000004000000)		//
#define CPF_ReferenceParm					DECLARE_UINT64(0x0000000008000000)		// Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
#define CPF_BlueprintAssignable				DECLARE_UINT64(0x0000000010000000)		// MC Delegates only.  Property should be exposed for assigning in blueprint code
#define CPF_Deprecated  					DECLARE_UINT64(0x0000000020000000)		// Property is deprecated.  Read it from an archive, but don't save it.
#define CPF_IsPlainOldData					DECLARE_UINT64(0x0000000040000000)		// If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
#define CPF_RepSkip							DECLARE_UINT64(0x0000000080000000)		// Not replicated. For non replicated properties in replicated structs 
#define CPF_RepNotify						DECLARE_UINT64(0x0000000100000000)		// Notify actors when a property is replicated
#define CPF_Interp							DECLARE_UINT64(0x0000000200000000)		// interpolatable property for use with matinee
#define CPF_NonTransactional				DECLARE_UINT64(0x0000000400000000)		// Property isn't transacted
#define CPF_EditorOnly						DECLARE_UINT64(0x0000000800000000)		// Property should only be loaded in the editor
#define CPF_NoDestructor					DECLARE_UINT64(0x0000001000000000)		// No destructor
//#define CPF_								DECLARE_UINT64(0x0000002000000000)		//
#define CPF_AutoWeak						DECLARE_UINT64(0x0000004000000000)		// Only used for weak pointers, means the export type is autoweak
#define CPF_ContainsInstancedReference		DECLARE_UINT64(0x0000008000000000)		// Property contains component references.
#define CPF_AssetRegistrySearchable			DECLARE_UINT64(0x0000010000000000)		// asset instances will add properties with this flag to the asset registry automatically
#define CPF_SimpleDisplay					DECLARE_UINT64(0x0000020000000000)		// The property is visible by default in the editor details view
#define CPF_AdvancedDisplay					DECLARE_UINT64(0x0000040000000000)		// The property is advanced and not visible by default in the editor details view
#define CPF_Protected						DECLARE_UINT64(0x0000080000000000)		// property is protected from the perspective of script
#define CPF_BlueprintCallable				DECLARE_UINT64(0x0000100000000000)		// MC Delegates only.  Property should be exposed for calling in blueprint code
#define CPF_BlueprintAuthorityOnly			DECLARE_UINT64(0x0000200000000000)		// MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
#define CPF_TextExportTransient				DECLARE_UINT64(0x0000400000000000)		// Property shouldn't be exported to text format (e.g. copy/paste)
#define CPF_NonPIEDuplicateTransient		DECLARE_UINT64(0x0000800000000000)		// Property should only be copied in PIE
#define CPF_ExposeOnSpawn					DECLARE_UINT64(0x0001000000000000)		// Property is exposed on spawn
#define CPF_PersistentInstance				DECLARE_UINT64(0x0002000000000000)		// A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
#define CPF_UObjectWrapper					DECLARE_UINT64(0x0004000000000000)		// Property was parsed as a wrapper class like TSubobjectOf<T>, FScriptInterface etc., rather than a USomething*
#define CPF_HasGetValueTypeHash				DECLARE_UINT64(0x0008000000000000)		// This property can generate a meaningful hash value.
#define CPF_NativeAccessSpecifierPublic		DECLARE_UINT64(0x0010000000000000)		// Public native access specifier
#define CPF_NativeAccessSpecifierProtected	DECLARE_UINT64(0x0020000000000000)		// Protected native access specifier
#define CPF_NativeAccessSpecifierPrivate	DECLARE_UINT64(0x0040000000000000)		// Private native access specifier

#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** the flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** all the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** all the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor)

#define CPF_AllFlags				DECLARE_UINT64(0xFFFFFFFFFFFFFFFF)

```

`Internal_Docs/4_13.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    //RF_Unused				            =0x00000100,
    RF_TagGarbageTemp			        =0x00000200,

    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    //RF_Unused                         =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    //RF_Unused                         =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    //RF_Unused		                    =0x02000000,
    RF_Dynamic                          =0x04000000,
};

#define CPF_Edit							DECLARE_UINT64(0x0000000000000001)		// Property is user-settable in the editor.
#define CPF_ConstParm						DECLARE_UINT64(0x0000000000000002)		// This is a constant function parameter
#define CPF_BlueprintVisible				DECLARE_UINT64(0x0000000000000004)		// This property can be read by blueprint code
#define CPF_ExportObject					DECLARE_UINT64(0x0000000000000008)		// Object can be exported with actor.
#define CPF_BlueprintReadOnly				DECLARE_UINT64(0x0000000000000010)		// This property cannot be modified by blueprint code
#define CPF_Net								DECLARE_UINT64(0x0000000000000020)		// Property is relevant to network replication.
#define CPF_EditFixedSize					DECLARE_UINT64(0x0000000000000040)		// Indicates that elements of an array can be modified, but its size cannot be changed.
#define CPF_Parm							DECLARE_UINT64(0x0000000000000080)		// Function/When call parameter.
#define CPF_OutParm							DECLARE_UINT64(0x0000000000000100)		// Value is copied out after function call.
#define CPF_ZeroConstructor					DECLARE_UINT64(0x0000000000000200)		// memset is fine for construction
#define CPF_ReturnParm						DECLARE_UINT64(0x0000000000000400)		// Return value.
#define CPF_DisableEditOnTemplate			DECLARE_UINT64(0x0000000000000800)		// Disable editing of this property on an archetype/sub-blueprint
//#define CPF_      						DECLARE_UINT64(0x0000000000001000)		// 
#define CPF_Transient   					DECLARE_UINT64(0x0000000000002000)		// Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
#define CPF_Config      					DECLARE_UINT64(0x0000000000004000)		// Property should be loaded/saved as permanent profile.
//#define CPF_								DECLARE_UINT64(0x0000000000008000)		// 
#define CPF_DisableEditOnInstance			DECLARE_UINT64(0x0000000000010000)		// Disable editing on an instance of this class
#define CPF_EditConst   					DECLARE_UINT64(0x0000000000020000)		// Property is uneditable in the editor.
#define CPF_GlobalConfig					DECLARE_UINT64(0x0000000000040000)		// Load config from base class, not subclass.
#define CPF_InstancedReference				DECLARE_UINT64(0x0000000000080000)		// Property is a component references.
//#define CPF_								DECLARE_UINT64(0x0000000000100000)
#define CPF_DuplicateTransient				DECLARE_UINT64(0x0000000000200000)		// Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
#define CPF_SubobjectReference				DECLARE_UINT64(0x0000000000400000)		// Property contains subobject references (TSubobjectPtr)
//#define CPF_    							DECLARE_UINT64(0x0000000000800000)		// 
#define CPF_SaveGame						DECLARE_UINT64(0x0000000001000000)		// Property should be serialized for save games
#define CPF_NoClear							DECLARE_UINT64(0x0000000002000000)		// Hide clear (and browse) button.
//#define CPF_  							DECLARE_UINT64(0x0000000004000000)		//
#define CPF_ReferenceParm					DECLARE_UINT64(0x0000000008000000)		// Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
#define CPF_BlueprintAssignable				DECLARE_UINT64(0x0000000010000000)		// MC Delegates only.  Property should be exposed for assigning in blueprint code
#define CPF_Deprecated  					DECLARE_UINT64(0x0000000020000000)		// Property is deprecated.  Read it from an archive, but don't save it.
#define CPF_IsPlainOldData					DECLARE_UINT64(0x0000000040000000)		// If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
#define CPF_RepSkip							DECLARE_UINT64(0x0000000080000000)		// Not replicated. For non replicated properties in replicated structs 
#define CPF_RepNotify						DECLARE_UINT64(0x0000000100000000)		// Notify actors when a property is replicated
#define CPF_Interp							DECLARE_UINT64(0x0000000200000000)		// interpolatable property for use with matinee
#define CPF_NonTransactional				DECLARE_UINT64(0x0000000400000000)		// Property isn't transacted
#define CPF_EditorOnly						DECLARE_UINT64(0x0000000800000000)		// Property should only be loaded in the editor
#define CPF_NoDestructor					DECLARE_UINT64(0x0000001000000000)		// No destructor
//#define CPF_								DECLARE_UINT64(0x0000002000000000)		//
#define CPF_AutoWeak						DECLARE_UINT64(0x0000004000000000)		// Only used for weak pointers, means the export type is autoweak
#define CPF_ContainsInstancedReference		DECLARE_UINT64(0x0000008000000000)		// Property contains component references.
#define CPF_AssetRegistrySearchable			DECLARE_UINT64(0x0000010000000000)		// asset instances will add properties with this flag to the asset registry automatically
#define CPF_SimpleDisplay					DECLARE_UINT64(0x0000020000000000)		// The property is visible by default in the editor details view
#define CPF_AdvancedDisplay					DECLARE_UINT64(0x0000040000000000)		// The property is advanced and not visible by default in the editor details view
#define CPF_Protected						DECLARE_UINT64(0x0000080000000000)		// property is protected from the perspective of script
#define CPF_BlueprintCallable				DECLARE_UINT64(0x0000100000000000)		// MC Delegates only.  Property should be exposed for calling in blueprint code
#define CPF_BlueprintAuthorityOnly			DECLARE_UINT64(0x0000200000000000)		// MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
#define CPF_TextExportTransient				DECLARE_UINT64(0x0000400000000000)		// Property shouldn't be exported to text format (e.g. copy/paste)
#define CPF_NonPIEDuplicateTransient		DECLARE_UINT64(0x0000800000000000)		// Property should only be copied in PIE
#define CPF_ExposeOnSpawn					DECLARE_UINT64(0x0001000000000000)		// Property is exposed on spawn
#define CPF_PersistentInstance				DECLARE_UINT64(0x0002000000000000)		// A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
#define CPF_UObjectWrapper					DECLARE_UINT64(0x0004000000000000)		// Property was parsed as a wrapper class like TSubobjectOf<T>, FScriptInterface etc., rather than a USomething*
#define CPF_HasGetValueTypeHash				DECLARE_UINT64(0x0008000000000000)		// This property can generate a meaningful hash value.
#define CPF_NativeAccessSpecifierPublic		DECLARE_UINT64(0x0010000000000000)		// Public native access specifier
#define CPF_NativeAccessSpecifierProtected	DECLARE_UINT64(0x0020000000000000)		// Protected native access specifier
#define CPF_NativeAccessSpecifierPrivate	DECLARE_UINT64(0x0040000000000000)		// Private native access specifier
#define CPF_SkipSerialization				DECLARE_UINT64(0x0080000000000000)		// Property shouldn't be serialized, can still be exported to text

#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** the flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** all the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** all the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor)

#define CPF_AllFlags				DECLARE_UINT64(0xFFFFFFFFFFFFFFFF)
```

`Internal_Docs/4_14.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    //RF_Unused				            =0x00000100,
    RF_TagGarbageTemp			        =0x00000200,

    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    //RF_Unused                         =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    RF_DuplicateTransient               =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    RF_NonPIEDuplicateTransient	        =0x02000000,
    RF_Dynamic                          =0x04000000,
};

#define CPF_Edit							DECLARE_UINT64(0x0000000000000001)		// Property is user-settable in the editor.
#define CPF_ConstParm						DECLARE_UINT64(0x0000000000000002)		// This is a constant function parameter
#define CPF_BlueprintVisible				DECLARE_UINT64(0x0000000000000004)		// This property can be read by blueprint code
#define CPF_ExportObject					DECLARE_UINT64(0x0000000000000008)		// Object can be exported with actor.
#define CPF_BlueprintReadOnly				DECLARE_UINT64(0x0000000000000010)		// This property cannot be modified by blueprint code
#define CPF_Net								DECLARE_UINT64(0x0000000000000020)		// Property is relevant to network replication.
#define CPF_EditFixedSize					DECLARE_UINT64(0x0000000000000040)		// Indicates that elements of an array can be modified, but its size cannot be changed.
#define CPF_Parm							DECLARE_UINT64(0x0000000000000080)		// Function/When call parameter.
#define CPF_OutParm							DECLARE_UINT64(0x0000000000000100)		// Value is copied out after function call.
#define CPF_ZeroConstructor					DECLARE_UINT64(0x0000000000000200)		// memset is fine for construction
#define CPF_ReturnParm						DECLARE_UINT64(0x0000000000000400)		// Return value.
#define CPF_DisableEditOnTemplate			DECLARE_UINT64(0x0000000000000800)		// Disable editing of this property on an archetype/sub-blueprint
//#define CPF_      						DECLARE_UINT64(0x0000000000001000)		// 
#define CPF_Transient   					DECLARE_UINT64(0x0000000000002000)		// Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
#define CPF_Config      					DECLARE_UINT64(0x0000000000004000)		// Property should be loaded/saved as permanent profile.
//#define CPF_								DECLARE_UINT64(0x0000000000008000)		// 
#define CPF_DisableEditOnInstance			DECLARE_UINT64(0x0000000000010000)		// Disable editing on an instance of this class
#define CPF_EditConst   					DECLARE_UINT64(0x0000000000020000)		// Property is uneditable in the editor.
#define CPF_GlobalConfig					DECLARE_UINT64(0x0000000000040000)		// Load config from base class, not subclass.
#define CPF_InstancedReference				DECLARE_UINT64(0x0000000000080000)		// Property is a component references.
//#define CPF_								DECLARE_UINT64(0x0000000000100000)
#define CPF_DuplicateTransient				DECLARE_UINT64(0x0000000000200000)		// Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
#define CPF_SubobjectReference				DECLARE_UINT64(0x0000000000400000)		// Property contains subobject references (TSubobjectPtr)
//#define CPF_    							DECLARE_UINT64(0x0000000000800000)		// 
#define CPF_SaveGame						DECLARE_UINT64(0x0000000001000000)		// Property should be serialized for save games
#define CPF_NoClear							DECLARE_UINT64(0x0000000002000000)		// Hide clear (and browse) button.
//#define CPF_  							DECLARE_UINT64(0x0000000004000000)		//
#define CPF_ReferenceParm					DECLARE_UINT64(0x0000000008000000)		// Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
#define CPF_BlueprintAssignable				DECLARE_UINT64(0x0000000010000000)		// MC Delegates only.  Property should be exposed for assigning in blueprint code
#define CPF_Deprecated  					DECLARE_UINT64(0x0000000020000000)		// Property is deprecated.  Read it from an archive, but don't save it.
#define CPF_IsPlainOldData					DECLARE_UINT64(0x0000000040000000)		// If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
#define CPF_RepSkip							DECLARE_UINT64(0x0000000080000000)		// Not replicated. For non replicated properties in replicated structs 
#define CPF_RepNotify						DECLARE_UINT64(0x0000000100000000)		// Notify actors when a property is replicated
#define CPF_Interp							DECLARE_UINT64(0x0000000200000000)		// interpolatable property for use with matinee
#define CPF_NonTransactional				DECLARE_UINT64(0x0000000400000000)		// Property isn't transacted
#define CPF_EditorOnly						DECLARE_UINT64(0x0000000800000000)		// Property should only be loaded in the editor
#define CPF_NoDestructor					DECLARE_UINT64(0x0000001000000000)		// No destructor
//#define CPF_								DECLARE_UINT64(0x0000002000000000)		//
#define CPF_AutoWeak						DECLARE_UINT64(0x0000004000000000)		// Only used for weak pointers, means the export type is autoweak
#define CPF_ContainsInstancedReference		DECLARE_UINT64(0x0000008000000000)		// Property contains component references.
#define CPF_AssetRegistrySearchable			DECLARE_UINT64(0x0000010000000000)		// asset instances will add properties with this flag to the asset registry automatically
#define CPF_SimpleDisplay					DECLARE_UINT64(0x0000020000000000)		// The property is visible by default in the editor details view
#define CPF_AdvancedDisplay					DECLARE_UINT64(0x0000040000000000)		// The property is advanced and not visible by default in the editor details view
#define CPF_Protected						DECLARE_UINT64(0x0000080000000000)		// property is protected from the perspective of script
#define CPF_BlueprintCallable				DECLARE_UINT64(0x0000100000000000)		// MC Delegates only.  Property should be exposed for calling in blueprint code
#define CPF_BlueprintAuthorityOnly			DECLARE_UINT64(0x0000200000000000)		// MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
#define CPF_TextExportTransient				DECLARE_UINT64(0x0000400000000000)		// Property shouldn't be exported to text format (e.g. copy/paste)
#define CPF_NonPIEDuplicateTransient		DECLARE_UINT64(0x0000800000000000)		// Property should only be copied in PIE
#define CPF_ExposeOnSpawn					DECLARE_UINT64(0x0001000000000000)		// Property is exposed on spawn
#define CPF_PersistentInstance				DECLARE_UINT64(0x0002000000000000)		// A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
#define CPF_UObjectWrapper					DECLARE_UINT64(0x0004000000000000)		// Property was parsed as a wrapper class like TSubobjectOf<T>, FScriptInterface etc., rather than a USomething*
#define CPF_HasGetValueTypeHash				DECLARE_UINT64(0x0008000000000000)		// This property can generate a meaningful hash value.
#define CPF_NativeAccessSpecifierPublic		DECLARE_UINT64(0x0010000000000000)		// Public native access specifier
#define CPF_NativeAccessSpecifierProtected	DECLARE_UINT64(0x0020000000000000)		// Protected native access specifier
#define CPF_NativeAccessSpecifierPrivate	DECLARE_UINT64(0x0040000000000000)		// Private native access specifier
#define CPF_SkipSerialization				DECLARE_UINT64(0x0080000000000000)		// Property shouldn't be serialized, can still be exported to text

#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** the flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** all the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** all the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor)

#define CPF_AllFlags				DECLARE_UINT64(0xFFFFFFFFFFFFFFFF)
```

`Internal_Docs/4_15.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    RF_TagGarbageTemp			        =0x00000100,

    RF_NeedInitialization		        =0x00000200,
    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    RF_NewerVersionExists               =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    RF_DuplicateTransient               =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    RF_NonPIEDuplicateTransient	        =0x02000000,
    RF_Dynamic                          =0x04000000,
};

#define CPF_Edit							DECLARE_UINT64(0x0000000000000001)		// Property is user-settable in the editor.
#define CPF_ConstParm						DECLARE_UINT64(0x0000000000000002)		// This is a constant function parameter
#define CPF_BlueprintVisible				DECLARE_UINT64(0x0000000000000004)		// This property can be read by blueprint code
#define CPF_ExportObject					DECLARE_UINT64(0x0000000000000008)		// Object can be exported with actor.
#define CPF_BlueprintReadOnly				DECLARE_UINT64(0x0000000000000010)		// This property cannot be modified by blueprint code
#define CPF_Net								DECLARE_UINT64(0x0000000000000020)		// Property is relevant to network replication.
#define CPF_EditFixedSize					DECLARE_UINT64(0x0000000000000040)		// Indicates that elements of an array can be modified, but its size cannot be changed.
#define CPF_Parm							DECLARE_UINT64(0x0000000000000080)		// Function/When call parameter.
#define CPF_OutParm							DECLARE_UINT64(0x0000000000000100)		// Value is copied out after function call.
#define CPF_ZeroConstructor					DECLARE_UINT64(0x0000000000000200)		// memset is fine for construction
#define CPF_ReturnParm						DECLARE_UINT64(0x0000000000000400)		// Return value.
#define CPF_DisableEditOnTemplate			DECLARE_UINT64(0x0000000000000800)		// Disable editing of this property on an archetype/sub-blueprint
//#define CPF_      						DECLARE_UINT64(0x0000000000001000)		// 
#define CPF_Transient   					DECLARE_UINT64(0x0000000000002000)		// Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
#define CPF_Config      					DECLARE_UINT64(0x0000000000004000)		// Property should be loaded/saved as permanent profile.
//#define CPF_								DECLARE_UINT64(0x0000000000008000)		// 
#define CPF_DisableEditOnInstance			DECLARE_UINT64(0x0000000000010000)		// Disable editing on an instance of this class
#define CPF_EditConst   					DECLARE_UINT64(0x0000000000020000)		// Property is uneditable in the editor.
#define CPF_GlobalConfig					DECLARE_UINT64(0x0000000000040000)		// Load config from base class, not subclass.
#define CPF_InstancedReference				DECLARE_UINT64(0x0000000000080000)		// Property is a component references.
//#define CPF_								DECLARE_UINT64(0x0000000000100000)
#define CPF_DuplicateTransient				DECLARE_UINT64(0x0000000000200000)		// Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
#define CPF_SubobjectReference				DECLARE_UINT64(0x0000000000400000)		// Property contains subobject references (TSubobjectPtr)
//#define CPF_    							DECLARE_UINT64(0x0000000000800000)		// 
#define CPF_SaveGame						DECLARE_UINT64(0x0000000001000000)		// Property should be serialized for save games
#define CPF_NoClear							DECLARE_UINT64(0x0000000002000000)		// Hide clear (and browse) button.
//#define CPF_  							DECLARE_UINT64(0x0000000004000000)		//
#define CPF_ReferenceParm					DECLARE_UINT64(0x0000000008000000)		// Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
#define CPF_BlueprintAssignable				DECLARE_UINT64(0x0000000010000000)		// MC Delegates only.  Property should be exposed for assigning in blueprint code
#define CPF_Deprecated  					DECLARE_UINT64(0x0000000020000000)		// Property is deprecated.  Read it from an archive, but don't save it.
#define CPF_IsPlainOldData					DECLARE_UINT64(0x0000000040000000)		// If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
#define CPF_RepSkip							DECLARE_UINT64(0x0000000080000000)		// Not replicated. For non replicated properties in replicated structs 
#define CPF_RepNotify						DECLARE_UINT64(0x0000000100000000)		// Notify actors when a property is replicated
#define CPF_Interp							DECLARE_UINT64(0x0000000200000000)		// interpolatable property for use with matinee
#define CPF_NonTransactional				DECLARE_UINT64(0x0000000400000000)		// Property isn't transacted
#define CPF_EditorOnly						DECLARE_UINT64(0x0000000800000000)		// Property should only be loaded in the editor
#define CPF_NoDestructor					DECLARE_UINT64(0x0000001000000000)		// No destructor
//#define CPF_								DECLARE_UINT64(0x0000002000000000)		//
#define CPF_AutoWeak						DECLARE_UINT64(0x0000004000000000)		// Only used for weak pointers, means the export type is autoweak
#define CPF_ContainsInstancedReference		DECLARE_UINT64(0x0000008000000000)		// Property contains component references.
#define CPF_AssetRegistrySearchable			DECLARE_UINT64(0x0000010000000000)		// asset instances will add properties with this flag to the asset registry automatically
#define CPF_SimpleDisplay					DECLARE_UINT64(0x0000020000000000)		// The property is visible by default in the editor details view
#define CPF_AdvancedDisplay					DECLARE_UINT64(0x0000040000000000)		// The property is advanced and not visible by default in the editor details view
#define CPF_Protected						DECLARE_UINT64(0x0000080000000000)		// property is protected from the perspective of script
#define CPF_BlueprintCallable				DECLARE_UINT64(0x0000100000000000)		// MC Delegates only.  Property should be exposed for calling in blueprint code
#define CPF_BlueprintAuthorityOnly			DECLARE_UINT64(0x0000200000000000)		// MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
#define CPF_TextExportTransient				DECLARE_UINT64(0x0000400000000000)		// Property shouldn't be exported to text format (e.g. copy/paste)
#define CPF_NonPIEDuplicateTransient		DECLARE_UINT64(0x0000800000000000)		// Property should only be copied in PIE
#define CPF_ExposeOnSpawn					DECLARE_UINT64(0x0001000000000000)		// Property is exposed on spawn
#define CPF_PersistentInstance				DECLARE_UINT64(0x0002000000000000)		// A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
#define CPF_UObjectWrapper					DECLARE_UINT64(0x0004000000000000)		// Property was parsed as a wrapper class like TSubobjectOf<T>, FScriptInterface etc., rather than a USomething*
#define CPF_HasGetValueTypeHash				DECLARE_UINT64(0x0008000000000000)		// This property can generate a meaningful hash value.
#define CPF_NativeAccessSpecifierPublic		DECLARE_UINT64(0x0010000000000000)		// Public native access specifier
#define CPF_NativeAccessSpecifierProtected	DECLARE_UINT64(0x0020000000000000)		// Protected native access specifier
#define CPF_NativeAccessSpecifierPrivate	DECLARE_UINT64(0x0040000000000000)		// Private native access specifier
#define CPF_SkipSerialization				DECLARE_UINT64(0x0080000000000000)		// Property shouldn't be serialized, can still be exported to text

#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** the flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** all the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** all the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor | CPF_HasGetValueTypeHash)

#define CPF_AllFlags				DECLARE_UINT64(0xFFFFFFFFFFFFFFFF)
```

`Internal_Docs/4_22.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    RF_TagGarbageTemp			        =0x00000100,

    RF_NeedInitialization		        =0x00000200,
    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    RF_NewerVersionExists               =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    RF_DuplicateTransient               =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    RF_NonPIEDuplicateTransient	        =0x02000000,
    RF_Dynamic                          =0x04000000,
    RF_WillBeLoaded				        =0x08000000,
};

enum EPropertyFlags : uint64
{
	CPF_None = 0,

	CPF_Edit							= 0x0000000000000001,	///< Property is user-settable in the editor.
	CPF_ConstParm						= 0x0000000000000002,	///< This is a constant function parameter
	CPF_BlueprintVisible				= 0x0000000000000004,	///< This property can be read by blueprint code
	CPF_ExportObject					= 0x0000000000000008,	///< Object can be exported with actor.
	CPF_BlueprintReadOnly				= 0x0000000000000010,	///< This property cannot be modified by blueprint code
	CPF_Net								= 0x0000000000000020,	///< Property is relevant to network replication.
	CPF_EditFixedSize					= 0x0000000000000040,	///< Indicates that elements of an array can be modified, but its size cannot be changed.
	CPF_Parm							= 0x0000000000000080,	///< Function/When call parameter.
	CPF_OutParm							= 0x0000000000000100,	///< Value is copied out after function call.
	CPF_ZeroConstructor					= 0x0000000000000200,	///< memset is fine for construction
	CPF_ReturnParm						= 0x0000000000000400,	///< Return value.
	CPF_DisableEditOnTemplate			= 0x0000000000000800,	///< Disable editing of this property on an archetype/sub-blueprint
	//CPF_      						= 0x0000000000001000,	///< 
	CPF_Transient   					= 0x0000000000002000,	///< Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
	CPF_Config      					= 0x0000000000004000,	///< Property should be loaded/saved as permanent profile.
	//CPF_								= 0x0000000000008000,	///< 
	CPF_DisableEditOnInstance			= 0x0000000000010000,	///< Disable editing on an instance of this class
	CPF_EditConst   					= 0x0000000000020000,	///< Property is uneditable in the editor.
	CPF_GlobalConfig					= 0x0000000000040000,	///< Load config from base class, not subclass.
	CPF_InstancedReference				= 0x0000000000080000,	///< Property is a component references.
	//CPF_								= 0x0000000000100000,	///<
	CPF_DuplicateTransient				= 0x0000000000200000,	///< Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
	CPF_SubobjectReference				= 0x0000000000400000,	///< Property contains subobject references (TSubobjectPtr)
	//CPF_    							= 0x0000000000800000,	///< 
    CPF_SaveGame						= 0x0000000001000000,	///< Property should be serialized for save games
	CPF_NoClear							= 0x0000000002000000,	///< Hide clear (and browse) button.
	//CPF_  							= 0x0000000004000000,	///<
	CPF_ReferenceParm					= 0x0000000008000000,	///< Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
	CPF_BlueprintAssignable				= 0x0000000010000000,	///< MC Delegates only.  Property should be exposed for assigning in blueprint code
	CPF_Deprecated  					= 0x0000000020000000,	///< Property is deprecated.  Read it from an archive, but don't save it.
	CPF_IsPlainOldData					= 0x0000000040000000,	///< If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
	CPF_RepSkip							= 0x0000000080000000,	///< Not replicated. For non replicated properties in replicated structs 
	CPF_RepNotify						= 0x0000000100000000,	///< Notify actors when a property is replicated
	CPF_Interp							= 0x0000000200000000,	///< interpolatable property for use with matinee
	CPF_NonTransactional				= 0x0000000400000000,	///< Property isn't transacted
	CPF_EditorOnly						= 0x0000000800000000,	///< Property should only be loaded in the editor
	CPF_NoDestructor					= 0x0000001000000000,	///< No destructor
	//CPF_								= 0x0000002000000000,	///<
	CPF_AutoWeak						= 0x0000004000000000,	///< Only used for weak pointers, means the export type is autoweak
	CPF_ContainsInstancedReference		= 0x0000008000000000,	///< Property contains component references.
	CPF_AssetRegistrySearchable			= 0x0000010000000000,	///< asset instances will add properties with this flag to the asset registry automatically
	CPF_SimpleDisplay					= 0x0000020000000000,	///< The property is visible by default in the editor details view
	CPF_AdvancedDisplay					= 0x0000040000000000,	///< The property is advanced and not visible by default in the editor details view
	CPF_Protected						= 0x0000080000000000,	///< property is protected from the perspective of script
	CPF_BlueprintCallable				= 0x0000100000000000,	///< MC Delegates only.  Property should be exposed for calling in blueprint code
	CPF_BlueprintAuthorityOnly			= 0x0000200000000000,	///< MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
	CPF_TextExportTransient				= 0x0000400000000000,	///< Property shouldn't be exported to text format (e.g. copy/paste)
	CPF_NonPIEDuplicateTransient		= 0x0000800000000000,	///< Property should only be copied in PIE
	CPF_ExposeOnSpawn					= 0x0001000000000000,	///< Property is exposed on spawn
	CPF_PersistentInstance				= 0x0002000000000000,	///< A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
	CPF_UObjectWrapper					= 0x0004000000000000,	///< Property was parsed as a wrapper class like TSubclassOf<T>, FScriptInterface etc., rather than a USomething*
	CPF_HasGetValueTypeHash				= 0x0008000000000000,	///< This property can generate a meaningful hash value.
	CPF_NativeAccessSpecifierPublic		= 0x0010000000000000,	///< Public native access specifier
	CPF_NativeAccessSpecifierProtected	= 0x0020000000000000,	///< Protected native access specifier
	CPF_NativeAccessSpecifierPrivate	= 0x0040000000000000,	///< Private native access specifier
	CPF_SkipSerialization				= 0x0080000000000000,	///< Property shouldn't be serialized, can still be exported to text
};

/** All Native Access Specifier flags */
#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

/** All parameter flags */
#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)

/** Flags that are propagated to properties inside containers */
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** The flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** All the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** All the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor | CPF_HasGetValueTypeHash)

/** Mask of all property flags */
#define CPF_AllFlags				((EPropertyFlags)0xFFFFFFFFFFFFFFFF)

```

`Internal_Docs/4_25.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    RF_TagGarbageTemp			        =0x00000100,

    RF_NeedInitialization		        =0x00000200,
    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    RF_NewerVersionExists               =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    RF_DuplicateTransient               =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    RF_NonPIEDuplicateTransient	        =0x02000000,
    RF_Dynamic                          =0x04000000,
    RF_WillBeLoaded				        =0x08000000,
    RF_HasExternalPackage		        =0x10000000,
};

enum EPropertyFlags : uint64
{
	CPF_None = 0,

	CPF_Edit							= 0x0000000000000001,	///< Property is user-settable in the editor.
	CPF_ConstParm						= 0x0000000000000002,	///< This is a constant function parameter
	CPF_BlueprintVisible				= 0x0000000000000004,	///< This property can be read by blueprint code
	CPF_ExportObject					= 0x0000000000000008,	///< Object can be exported with actor.
	CPF_BlueprintReadOnly				= 0x0000000000000010,	///< This property cannot be modified by blueprint code
	CPF_Net								= 0x0000000000000020,	///< Property is relevant to network replication.
	CPF_EditFixedSize					= 0x0000000000000040,	///< Indicates that elements of an array can be modified, but its size cannot be changed.
	CPF_Parm							= 0x0000000000000080,	///< Function/When call parameter.
	CPF_OutParm							= 0x0000000000000100,	///< Value is copied out after function call.
	CPF_ZeroConstructor					= 0x0000000000000200,	///< memset is fine for construction
	CPF_ReturnParm						= 0x0000000000000400,	///< Return value.
	CPF_DisableEditOnTemplate			= 0x0000000000000800,	///< Disable editing of this property on an archetype/sub-blueprint
	//CPF_      						= 0x0000000000001000,	///< 
	CPF_Transient   					= 0x0000000000002000,	///< Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
	CPF_Config      					= 0x0000000000004000,	///< Property should be loaded/saved as permanent profile.
	//CPF_								= 0x0000000000008000,	///< 
	CPF_DisableEditOnInstance			= 0x0000000000010000,	///< Disable editing on an instance of this class
	CPF_EditConst   					= 0x0000000000020000,	///< Property is uneditable in the editor.
	CPF_GlobalConfig					= 0x0000000000040000,	///< Load config from base class, not subclass.
	CPF_InstancedReference				= 0x0000000000080000,	///< Property is a component references.
	//CPF_								= 0x0000000000100000,	///<
	CPF_DuplicateTransient				= 0x0000000000200000,	///< Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
	CPF_SubobjectReference				= 0x0000000000400000,	///< Property contains subobject references (TSubobjectPtr)
	//CPF_    							= 0x0000000000800000,	///< 
    CPF_SaveGame						= 0x0000000001000000,	///< Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame
	CPF_NoClear							= 0x0000000002000000,	///< Hide clear (and browse) button.
	//CPF_  							= 0x0000000004000000,	///<
	CPF_ReferenceParm					= 0x0000000008000000,	///< Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
	CPF_BlueprintAssignable				= 0x0000000010000000,	///< MC Delegates only.  Property should be exposed for assigning in blueprint code
	CPF_Deprecated  					= 0x0000000020000000,	///< Property is deprecated.  Read it from an archive, but don't save it.
	CPF_IsPlainOldData					= 0x0000000040000000,	///< If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
	CPF_RepSkip							= 0x0000000080000000,	///< Not replicated. For non replicated properties in replicated structs 
	CPF_RepNotify						= 0x0000000100000000,	///< Notify actors when a property is replicated
	CPF_Interp							= 0x0000000200000000,	///< interpolatable property for use with matinee
	CPF_NonTransactional				= 0x0000000400000000,	///< Property isn't transacted
	CPF_EditorOnly						= 0x0000000800000000,	///< Property should only be loaded in the editor
	CPF_NoDestructor					= 0x0000001000000000,	///< No destructor
	//CPF_								= 0x0000002000000000,	///<
	CPF_AutoWeak						= 0x0000004000000000,	///< Only used for weak pointers, means the export type is autoweak
	CPF_ContainsInstancedReference		= 0x0000008000000000,	///< Property contains component references.
	CPF_AssetRegistrySearchable			= 0x0000010000000000,	///< asset instances will add properties with this flag to the asset registry automatically
	CPF_SimpleDisplay					= 0x0000020000000000,	///< The property is visible by default in the editor details view
	CPF_AdvancedDisplay					= 0x0000040000000000,	///< The property is advanced and not visible by default in the editor details view
	CPF_Protected						= 0x0000080000000000,	///< property is protected from the perspective of script
	CPF_BlueprintCallable				= 0x0000100000000000,	///< MC Delegates only.  Property should be exposed for calling in blueprint code
	CPF_BlueprintAuthorityOnly			= 0x0000200000000000,	///< MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
	CPF_TextExportTransient				= 0x0000400000000000,	///< Property shouldn't be exported to text format (e.g. copy/paste)
	CPF_NonPIEDuplicateTransient		= 0x0000800000000000,	///< Property should only be copied in PIE
	CPF_ExposeOnSpawn					= 0x0001000000000000,	///< Property is exposed on spawn
	CPF_PersistentInstance				= 0x0002000000000000,	///< A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
	CPF_UObjectWrapper					= 0x0004000000000000,	///< Property was parsed as a wrapper class like TSubclassOf<T>, FScriptInterface etc., rather than a USomething*
	CPF_HasGetValueTypeHash				= 0x0008000000000000,	///< This property can generate a meaningful hash value.
	CPF_NativeAccessSpecifierPublic		= 0x0010000000000000,	///< Public native access specifier
	CPF_NativeAccessSpecifierProtected	= 0x0020000000000000,	///< Protected native access specifier
	CPF_NativeAccessSpecifierPrivate	= 0x0040000000000000,	///< Private native access specifier
	CPF_SkipSerialization				= 0x0080000000000000,	///< Property shouldn't be serialized, can still be exported to text
};

/** All Native Access Specifier flags */
#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

/** All parameter flags */
#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)

/** Flags that are propagated to properties inside containers */
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** The flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** All the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** All the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor | CPF_HasGetValueTypeHash)

/** Mask of all property flags */
#define CPF_AllFlags				((EPropertyFlags)0xFFFFFFFFFFFFFFFF)

```

`Internal_Docs/5.0_ea_branch_ue5-main.txt`:

```txt
enum EObjectFlags
{
    RF_NoFlags					        =0x00000000,

    RF_Public					        =0x00000001,
    RF_Standalone				        =0x00000002,
    RF_MarkAsNative				        =0x00000004,
    RF_Transactional			        =0x00000008,
    RF_ClassDefaultObject		        =0x00000010,
    RF_ArchetypeObject			        =0x00000020,
    RF_Transient				        =0x00000040,

    RF_MarkAsRootSet                    =0x00000080,
    RF_TagGarbageTemp			        =0x00000100,

    RF_NeedInitialization		        =0x00000200,
    RF_NeedLoad					        =0x00000400,
    RF_KeepForCooker                    =0x00000800,
    RF_NeedPostLoad				        =0x00001000,
    RF_NeedPostLoadSubobjects	        =0x00002000,
    RF_NewerVersionExists               =0x00004000,
    RF_BeginDestroyed			        =0x00008000,
    RF_FinishDestroyed			        =0x00010000,

    RF_BeingRegenerated			        =0x00020000,
    RF_DefaultSubObject			        =0x00040000,
    RF_WasLoaded				        =0x00080000,
    RF_TextExportTransient		        =0x00100000,
    RF_LoadCompleted			        =0x00200000,
    RF_InheritableComponentTemplate     =0x00400000,
    RF_DuplicateTransient               =0x00800000,
    RF_StrongRefOnFrame		            =0x01000000,
    RF_NonPIEDuplicateTransient	        =0x02000000,
    RF_Dynamic                          =0x04000000,
    RF_WillBeLoaded				        =0x08000000,
    RF_HasExternalPackage		        =0x10000000,
};

enum EPropertyFlags : uint64
{
	CPF_None = 0,

	CPF_Edit							= 0x0000000000000001,	///< Property is user-settable in the editor.
	CPF_ConstParm						= 0x0000000000000002,	///< This is a constant function parameter
	CPF_BlueprintVisible				= 0x0000000000000004,	///< This property can be read by blueprint code
	CPF_ExportObject					= 0x0000000000000008,	///< Object can be exported with actor.
	CPF_BlueprintReadOnly				= 0x0000000000000010,	///< This property cannot be modified by blueprint code
	CPF_Net								= 0x0000000000000020,	///< Property is relevant to network replication.
	CPF_EditFixedSize					= 0x0000000000000040,	///< Indicates that elements of an array can be modified, but its size cannot be changed.
	CPF_Parm							= 0x0000000000000080,	///< Function/When call parameter.
	CPF_OutParm							= 0x0000000000000100,	///< Value is copied out after function call.
	CPF_ZeroConstructor					= 0x0000000000000200,	///< memset is fine for construction
	CPF_ReturnParm						= 0x0000000000000400,	///< Return value.
	CPF_DisableEditOnTemplate			= 0x0000000000000800,	///< Disable editing of this property on an archetype/sub-blueprint
	//CPF_      						= 0x0000000000001000,	///<
	CPF_Transient   					= 0x0000000000002000,	///< Property is transient: shouldn't be saved or loaded, except for Blueprint CDOs.
	CPF_Config      					= 0x0000000000004000,	///< Property should be loaded/saved as permanent profile.
	//CPF_								= 0x0000000000008000,	///<
	CPF_DisableEditOnInstance			= 0x0000000000010000,	///< Disable editing on an instance of this class
	CPF_EditConst   					= 0x0000000000020000,	///< Property is uneditable in the editor.
	CPF_GlobalConfig					= 0x0000000000040000,	///< Load config from base class, not subclass.
	CPF_InstancedReference				= 0x0000000000080000,	///< Property is a component references.
	//CPF_								= 0x0000000000100000,	///<
	CPF_DuplicateTransient				= 0x0000000000200000,	///< Property should always be reset to the default value during any type of duplication (copy/paste, binary duplication, etc.)
    //CPF_								= 0x0000000000400000,	///<
	//CPF_    							= 0x0000000000800000,	///<
    CPF_SaveGame						= 0x0000000001000000,	///< Property should be serialized for save games, this is only checked for game-specific archives with ArIsSaveGame
	CPF_NoClear							= 0x0000000002000000,	///< Hide clear (and browse) button.
	//CPF_  							= 0x0000000004000000,	///<
	CPF_ReferenceParm					= 0x0000000008000000,	///< Value is passed by reference; CPF_OutParam and CPF_Param should also be set.
	CPF_BlueprintAssignable				= 0x0000000010000000,	///< MC Delegates only.  Property should be exposed for assigning in blueprint code
	CPF_Deprecated  					= 0x0000000020000000,	///< Property is deprecated.  Read it from an archive, but don't save it.
	CPF_IsPlainOldData					= 0x0000000040000000,	///< If this is set, then the property can be memcopied instead of CopyCompleteValue / CopySingleValue
	CPF_RepSkip							= 0x0000000080000000,	///< Not replicated. For non replicated properties in replicated structs
	CPF_RepNotify						= 0x0000000100000000,	///< Notify actors when a property is replicated
    CPF_Interp							= 0x0000000200000000,	///< interpolatable property for use with cinematics
	CPF_NonTransactional				= 0x0000000400000000,	///< Property isn't transacted
	CPF_EditorOnly						= 0x0000000800000000,	///< Property should only be loaded in the editor
	CPF_NoDestructor					= 0x0000001000000000,	///< No destructor
	//CPF_								= 0x0000002000000000,	///<
	CPF_AutoWeak						= 0x0000004000000000,	///< Only used for weak pointers, means the export type is autoweak
	CPF_ContainsInstancedReference		= 0x0000008000000000,	///< Property contains component references.
	CPF_AssetRegistrySearchable			= 0x0000010000000000,	///< asset instances will add properties with this flag to the asset registry automatically
	CPF_SimpleDisplay					= 0x0000020000000000,	///< The property is visible by default in the editor details view
	CPF_AdvancedDisplay					= 0x0000040000000000,	///< The property is advanced and not visible by default in the editor details view
	CPF_Protected						= 0x0000080000000000,	///< property is protected from the perspective of script
	CPF_BlueprintCallable				= 0x0000100000000000,	///< MC Delegates only.  Property should be exposed for calling in blueprint code
	CPF_BlueprintAuthorityOnly			= 0x0000200000000000,	///< MC Delegates only.  This delegate accepts (only in blueprint) only events with BlueprintAuthorityOnly.
	CPF_TextExportTransient				= 0x0000400000000000,	///< Property shouldn't be exported to text format (e.g. copy/paste)
	CPF_NonPIEDuplicateTransient		= 0x0000800000000000,	///< Property should only be copied in PIE
	CPF_ExposeOnSpawn					= 0x0001000000000000,	///< Property is exposed on spawn
	CPF_PersistentInstance				= 0x0002000000000000,	///< A object referenced by the property is duplicated like a component. (Each actor should have an own instance.)
	CPF_UObjectWrapper					= 0x0004000000000000,	///< Property was parsed as a wrapper class like TSubclassOf<T>, FScriptInterface etc., rather than a USomething*
	CPF_HasGetValueTypeHash				= 0x0008000000000000,	///< This property can generate a meaningful hash value.
	CPF_NativeAccessSpecifierPublic		= 0x0010000000000000,	///< Public native access specifier
	CPF_NativeAccessSpecifierProtected	= 0x0020000000000000,	///< Protected native access specifier
	CPF_NativeAccessSpecifierPrivate	= 0x0040000000000000,	///< Private native access specifier
	CPF_SkipSerialization				= 0x0080000000000000,	///< Property shouldn't be serialized, can still be exported to text
};

/** All Native Access Specifier flags */
#define CPF_NativeAccessSpecifiers	(CPF_NativeAccessSpecifierPublic | CPF_NativeAccessSpecifierProtected | CPF_NativeAccessSpecifierPrivate)

/** All parameter flags */
#define CPF_ParmFlags				(CPF_Parm | CPF_OutParm | CPF_ReturnParm | CPF_ReferenceParm | CPF_ConstParm)

/** Flags that are propagated to properties inside containers */
#define CPF_PropagateToArrayInner	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper )
#define CPF_PropagateToMapValue		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToMapKey		(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )
#define CPF_PropagateToSetElement	(CPF_ExportObject | CPF_PersistentInstance | CPF_InstancedReference | CPF_ContainsInstancedReference | CPF_Config | CPF_EditConst | CPF_Deprecated | CPF_EditorOnly | CPF_AutoWeak | CPF_UObjectWrapper | CPF_Edit )

/** The flags that should never be set on interface properties */
#define CPF_InterfaceClearMask		(CPF_ExportObject|CPF_InstancedReference|CPF_ContainsInstancedReference)

/** All the properties that can be stripped for final release console builds */
#define CPF_DevelopmentAssets		(CPF_EditorOnly)

/** All the properties that should never be loaded or saved */
#define CPF_ComputedFlags			(CPF_IsPlainOldData | CPF_NoDestructor | CPF_ZeroConstructor | CPF_HasGetValueTypeHash)

/** Mask of all property flags */
#define CPF_AllFlags				((EPropertyFlags)0xFFFFFFFFFFFFFFFF)

```

`Internal_Docs/CE_AOB_To_UE4SS_AOB.js`:

```js
// Run this script on a local JS installation
// Or
// Run this script online at a place like https://playcode.io

// Replace the input string with the AOB that you want to convert
const input = "E8 ?? ?? ?? ?? 48 8B 4C 24 ?? 8B FD 48 85 C9";

const regex = /(.)(.) /gm;
let output = input.replace(regex, "$1 $2/");
output = output.substr(0, output.length - 1) + " " + output.substr(output.length - 1, output.length)
console.log(output)
```

`Internal_Docs/FMallocBinned2_vtable.txt`:

```txt
This file contains the contents of the FMallocBinned2 vtable for multiple engine versions from 0x0 to 0x130 (or until there is no more data).

The mov instruction for GMalloc should be able to be used as the instance when calling the functions inside the vtable.

4.12
{
The second mov instruction is for GMalloc.
Follow the mov, then follow 0x0, then follow 0x0, now you're inside the vtable.

00007FF65528C0F8  00007FF653920210  ue4ss_main412-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned::`scalar deleting destructor'(unsigned int) __ptr64
00007FF65528C100  00007FF655146C10  ue4ss_main412-win64-shipping.public: virtual bool __cdecl UScriptStruct::TCppStructOps<struct FDestructibleSpecialHierarchyDepths>::HasIdentical(void) __ptr64
00007FF65528C108  00007FF653937C00  ue4ss_main412-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned::Malloc(unsigned __int64,unsigned int) __ptr64
00007FF65528C110  00007FF65393CE60  ue4ss_main412-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned::Realloc(void * __ptr64,unsigned __int64,unsigned int) __ptr64
00007FF65528C118  00007FF65392F4F0  ue4ss_main412-win64-shipping.public: virtual void __cdecl FMallocBinned::Free(void * __ptr64) __ptr64
00007FF65528C120  00007FF6542FE5A0  ue4ss_main412-win64-shipping.public: virtual unsigned __int64 __cdecl FMalloc::QuantizeSize(unsigned __int64,unsigned int) __ptr64
00007FF65528C128  00007FF6539301D0  ue4ss_main412-win64-shipping.public: virtual bool __cdecl FMallocBinned::GetAllocationSize(void * __ptr64,unsigned __int64 & __ptr64) __ptr64
00007FF65528C130  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C138  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C140  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C148  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C150  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C158  00007FF653A6CD90  ue4ss_main412-win64-shipping.void __cdecl AddStructReferencedObjectsOrNot<struct FAnimationTransitionRule>(void const * __ptr64,class FReferenceCollector & __ptr64)
00007FF65528C160  00007FF653929060  ue4ss_main412-win64-shipping.public: virtual void __cdecl FMallocBinned::DumpAllocatorStats(class FOutputDevice & __ptr64) __ptr64
00007FF65528C168  00007FF654078F40  ue4ss_main412-win64-shipping.public: virtual bool __cdecl UScriptStruct::TCppStructOps<struct FTickPrerequisite>::HasCopy(void) __ptr64
00007FF65528C170  00007FF653943CE0  ue4ss_main412-win64-shipping.public: virtual bool __cdecl FMallocBinned::ValidateHeap(void) __ptr64
00007FF65528C178  00007FF653932480  ue4ss_main412-win64-shipping.public: virtual wchar_t const * __ptr64 __cdecl FMallocBinned::GetDescriptiveName(void) __ptr64
}

4.22
{
The second mov instruction is for GMalloc.
Follow the mov, then follow 0x0, then follow 0x0, now you're inside the vtable.

00007FF6FA19D790  00007FF6F8520630  ue4ss_main422-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::`scalar deleting destructor'(unsigned int) __ptr64
00007FF6FA19D798  00007FF6F82C6C10  ue4ss_main422-win64-shipping.public: virtual bool __cdecl UScriptStruct::TCppStructOps<struct FCollectionParameterBase>::HasGetTypeHash(void) __ptr64
00007FF6FA19D7A0  00007FF6F8530DC0  ue4ss_main422-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Malloc(unsigned __int64,unsigned int) __ptr64
00007FF6FA19D7A8  00007FF6F8532BB0  ue4ss_main422-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Realloc(void * __ptr64,unsigned __int64,unsigned int) __ptr64
00007FF6FA19D7B0  00007FF6F85265D0  ue4ss_main422-win64-shipping.public: virtual void __cdecl FMallocBinned2::Free(void * __ptr64) __ptr64
00007FF6FA19D7B8  00007FF6F8532880  ue4ss_main422-win64-shipping.public: virtual unsigned __int64 __cdecl FMallocBinned2::QuantizeSize(unsigned __int64,unsigned int) __ptr64
00007FF6FA19D7C0  00007FF6F8527AC0  ue4ss_main422-win64-shipping.public: virtual bool __cdecl FMallocBinned2::GetAllocationSize(void * __ptr64,unsigned __int64 & __ptr64) __ptr64
00007FF6FA19D7C8  00007FF6F85375E0  ue4ss_main422-win64-shipping.public: virtual void __cdecl FMallocBinned2::Trim(bool) __ptr64
00007FF6FA19D7D0  00007FF6F8536610  ue4ss_main422-win64-shipping.public: virtual void __cdecl FMallocBinned2::SetupTLSCachesOnCurrentThread(void) __ptr64
00007FF6FA19D7D8  00007FF6F8521E70  ue4ss_main422-win64-shipping.public: virtual void __cdecl FMallocBinned2::ClearAndDisableTLSCachesOnCurrentThread(void) __ptr64
00007FF6FA19D7E0  00007FF6F82C5260  ue4ss_main422-win64-shipping.public: virtual void __cdecl IMediaPlayer::TickAudio(void) __ptr64
00007FF6FA19D7E8  00007FF6F82C5260  ue4ss_main422-win64-shipping.public: virtual void __cdecl IMediaPlayer::TickAudio(void) __ptr64
00007FF6FA19D7F0  00007FF6F82C5260  ue4ss_main422-win64-shipping.public: virtual void __cdecl IMediaPlayer::TickAudio(void) __ptr64
00007FF6FA19D7F8  00007FF6F8524510  ue4ss_main422-win64-shipping.public: virtual void __cdecl FMallocBinned2::DumpAllocatorStats(class FOutputDevice & __ptr64) __ptr64
00007FF6FA19D800  00007FF6F82C6A00  ue4ss_main422-win64-shipping.private: virtual bool __cdecl MenuStackInternal::SMenuContentWrapper::SupportsKeyboardFocus(void)const __ptr64
00007FF6FA19D808  00007FF6F8537A10  ue4ss_main422-win64-shipping.public: virtual bool __cdecl FMallocBinned2::ValidateHeap(void) __ptr64
00007FF6FA19D810  00007FF6F852AF80  ue4ss_main422-win64-shipping.public: virtual wchar_t const * __ptr64 __cdecl FMallocBinned2::GetDescriptiveName(void) __ptr64

}

4.26
{
The second mov instruction is for GMalloc.
Follow the mov, then follow 0x0, then follow 0x0, now you're inside the vtable.

00007FF6B32FFA00  00007FF6B0CA9A90  ue4ss_main426-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::`vector deleting destructor'(unsigned int) __ptr64
00007FF6B32FFA08  00007FF6B06D6050  ue4ss_main426-win64-shipping.public: virtual bool __cdecl UScriptStruct::TCppStructOps<struct FMovieSceneIntegerPropertySectionTemplate>::HasStructuredSerializer(void) __ptr64
00007FF6B32FFA10  00007FF6B0CAC700  ue4ss_main426-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Malloc(unsigned __int64,unsigned int) __ptr64
00007FF6B32FFA18  00007FF6B06E69B0  ue4ss_main426-win64-shipping.public: virtual void __cdecl FOutputDevice::Serialize(wchar_t const * __ptr64,enum ELogVerbosity::Type,class FName const & __ptr64,double) __ptr64
00007FF6B32FFA20  00007FF6B0CAD370  ue4ss_main426-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Realloc(void * __ptr64,unsigned __int64,unsigned int) __ptr64
00007FF6B32FFA28  00007FF6B0CD73D0  ue4ss_main426-win64-shipping.public: virtual int __cdecl BuildPatchServices::IBuildStatistics::GetInstallMemoryChunkStoreSize(void)const __ptr64
00007FF6B32FFA30  00007FF6B0CAAC80  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::Free(void * __ptr64) __ptr64
00007FF6B32FFA38  00007FF6B0CAD1A0  ue4ss_main426-win64-shipping.public: virtual unsigned __int64 __cdecl FMallocBinned2::QuantizeSize(unsigned __int64,unsigned int) __ptr64
00007FF6B32FFA40  00007FF6B0CAB740  ue4ss_main426-win64-shipping.public: virtual bool __cdecl FMallocBinned2::GetAllocationSize(void * __ptr64,unsigned __int64 & __ptr64) __ptr64
00007FF6B32FFA48  00007FF6B0CAE820  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::Trim(bool) __ptr64
00007FF6B32FFA50  00007FF6B0CADD60  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::SetupTLSCachesOnCurrentThread(void) __ptr64
00007FF6B32FFA58  00007FF6B0CA9E00  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::ClearAndDisableTLSCachesOnCurrentThread(void) __ptr64
00007FF6B32FFA60  00007FF6B06D5E80  ue4ss_main426-win64-shipping.private: static void __cdecl UClothPhysicalMeshDataNv_Legacy::StaticRegisterNativesUClothPhysicalMeshDataNv_Legacy(void)
00007FF6B32FFA68  00007FF6B0CAEAA0  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::UpdateStats(void) __ptr64
00007FF6B32FFA70  00007FF6B090C7B0  ue4ss_main426-win64-shipping.public: virtual void __cdecl AAmbientSound::PostRegisterAllComponents(void) __ptr64
00007FF6B32FFA78  00007FF6B0CA9F60  ue4ss_main426-win64-shipping.public: virtual void __cdecl FMallocBinned2::DumpAllocatorStats(class FOutputDevice & __ptr64) __ptr64
00007FF6B32FFA80  00007FF6B06D5F90  ue4ss_main426-win64-shipping.public: virtual bool __cdecl TBaseRawMethodDelegateInstance<0,class FOnlineSessionNull,void __cdecl(unsigned char * __ptr64,int),struct FDefaultDelegateUserPolicy>::IsSafeToExecute(void)const __ptr64
00007FF6B32FFA88  00007FF6B0CAEC60  ue4ss_main426-win64-shipping.public: virtual bool __cdecl FMallocBinned2::ValidateHeap(void) __ptr64
00007FF6B32FFA90  00007FF6B0CABF90  ue4ss_main426-win64-shipping.public: virtual wchar_t const * __ptr64 __cdecl FMallocBinned2::GetDescriptiveName(void) __ptr64

}

5.0 EA #1 (or #2, or #3, can't remember)
{
The second mov instruction is for GMalloc.
Follow the mov, then follow 0x0, then follow 0x0, now you're inside the vtable.

00007FF6A412AA28  00007FF6A158FAC0  ue4ss_main500-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::`scalar deleting destructor'(unsigned int) __ptr64
00007FF6A412AA30  00007FF6A0C5FEA0  ue4ss_main500-win64-shipping.public: virtual bool __cdecl TBaseStaticDelegateInstance<void __cdecl(class TArray<class FString,class TSizedDefaultAllocator<32> > const & __ptr64,class UWorld * __ptr64,class FOutputDevice & __ptr64),struct FDefaultDelegateUserPolicy>::HasSameObject(voi
00007FF6A412AA38  00007FF6A1594050  ue4ss_main500-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Malloc(unsigned __int64,unsigned int) __ptr64
00007FF6A412AA40  00007FF6A0C70F90  ue4ss_main500-win64-shipping.public: virtual void __cdecl FOutputDevice::Serialize(wchar_t const * __ptr64,enum ELogVerbosity::Type,class FName const & __ptr64,double) __ptr64
00007FF6A412AA48  00007FF6A1594AF0  ue4ss_main500-win64-shipping.public: virtual void * __ptr64 __cdecl FMallocBinned2::Realloc(void * __ptr64,unsigned __int64,unsigned int) __ptr64
00007FF6A412AA50  00007FF6A0F031E0  ue4ss_main500-win64-shipping.public: virtual void __cdecl USpaceCurveDeformationMechanic::OnBeginHover(struct FInputDeviceRay const & __ptr64) __ptr64
00007FF6A412AA58  00007FF6A15927C0  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::Free(void * __ptr64) __ptr64
00007FF6A412AA60  00007FF6A15948F0  ue4ss_main500-win64-shipping.public: virtual unsigned __int64 __cdecl FMallocBinned2::QuantizeSize(unsigned __int64,unsigned int) __ptr64
00007FF6A412AA68  00007FF6A1593380  ue4ss_main500-win64-shipping.public: virtual bool __cdecl FMallocBinned2::GetAllocationSize(void * __ptr64,unsigned __int64 & __ptr64) __ptr64
00007FF6A412AA70  00007FF6A15958E0  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::Trim(bool) __ptr64
00007FF6A412AA78  00007FF6A1595700  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::SetupTLSCachesOnCurrentThread(void) __ptr64
00007FF6A412AA80  00007FF6A158FBD0  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::ClearAndDisableTLSCachesOnCurrentThread(void) __ptr64
00007FF6A412AA88  00007FF6A0C5E280  ue4ss_main500-win64-shipping.public: virtual void __cdecl DeltaStats::FNoMemoryChunkStoreStat::OnChunkReleased(struct FGuid const & __ptr64) __ptr64
00007FF6A412AA90  00007FF6A1595B60  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::UpdateStats(void) __ptr64
00007FF6A412AA98  00007FF6A106E570  ue4ss_main500-win64-shipping.public: static void __cdecl UKismetSystemLibrary::UnregisterForRemoteNotifications(void)
00007FF6A412AAA0  00007FF6A1590E30  ue4ss_main500-win64-shipping.public: virtual void __cdecl FMallocBinned2::DumpAllocatorStats(class FOutputDevice & __ptr64) __ptr64
00007FF6A412AAA8  00007FF6A0C5FDE0  ue4ss_main500-win64-shipping.public: virtual bool __cdecl TBaseRawMethodDelegateInstance<0,class FStaticallyLinkedModuleRegistrant<class FAudioMixerModuleNonRealtime>,class IModuleInterface * __ptr64 __cdecl(void),struct FDefaultDelegateUserPolicy>::IsSafeToExecute(void)const __ptr64
00007FF6A412AAB0  00007FF6A1595BA0  ue4ss_main500-win64-shipping.public: virtual bool __cdecl FMallocBinned2::ValidateHeap(void) __ptr64
00007FF6A412AAB8  00007FF6A1593580  ue4ss_main500-win64-shipping.public: virtual wchar_t const * __ptr64 __cdecl FMallocBinned2::GetDescriptiveName(void) __ptr64

}

```

`Internal_Docs/GamesWithProblems.txt`:

```txt
Games where the version finder fails:

Games where GUObjectArray isn't found:

Games where FName::ToString isn't found (the new AOBs):
Demo games (4.23 (ShooterGame))
MX vs ATV All Out

Games where FName::FName isn't found:
CyubeVR (because this game is using extra inline optimizations)

Games where FMemory::Free isn't found:
CyubeVR (because this game is using extra inline optimizations)

Games where StaticConstructObject_Internal isn't found:
Demo games (4.14, 4.15)

Games that fail with error "Was unable to find SetProperty or it's element property name":

Games where the Property_PropertyFlags offset isn't found:
Demo games (4.13, 4.19, 4.20)

```

`Internal_Docs/Required_Changes_From_426_To_500.txt`:

```txt
This file describes changes that will have to be made in UE4SS in order to support Unreal Engine 5+
This is as of May 27th 2021, this entire file is based on the first early access version of UE5

ObjectProperty & ClassProperty
Added ObjectPtrProperty & ClassPtrProperty
These new properties seem to exist side-by-side with the old ObjectProperty & ClassProperty properties
In the dumped objects & properties file there are entries for both, maybe this is just a transition thing and everything will be the PtrProperty in the final UE5 release ?
I don't yet know what the differences between the two are.
ObjectPtrProperty inherits from ObjectProperty and ClassPtrProperty inherits from ClassProperty and neither have extra member variables


StaticConstructObject_Internal
A new 11th param was added to the params struct, it can be nullptr.


AOBs
The following AOBs need to be updated:
StaticFindObject
FString~FString

FHitResult struct
The bitfield that contains 'bBlockingHit' & 'bStartPenetrating' was moved from the top of the struct to the bottom of the struct
```

`Internal_Docs/Unreal_Version_Differences.txt`:

```txt
EObjectFlags
{
    FROM 4.12 TO 4.14
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    ADDED
    {
        RF_KeepForCooker
        RF_DuplicateTransient
        RF_NonPIEDuplicateTransient
    }
    BREAKING
    {
        No breaking changes
    }
    
    FROM 4.12 TO 4.13
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    NO CHANGES
    
    FROM 4.13 TO 4.14
    ADDED
    {
        RF_DuplicateTransient
        RF_NonPIEDuplicateTransient
    }
    BREAKING
    {
        No breaking changes
    }
    
    FROM 4.14 TO 4.15
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    ADDED
    {
        RF_NeedInitialization
        RF_NewerVersionExists
    }
    BREAKING
    {
        RF_TagGarbageTemp was moved from '0x00000200' to '0x00000100'
        RF_NeedInitialization replaces 'RF_TagGarbageTemp' at '0x00000200'
    }
    
    FROM 4.15 TO 4.22
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    ADDED
    {
        RF_WillBeLoaded
    }
    BREAKING
    {
        No breaking changes
    }
    
    FROM 4.22 TO 4.25
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    ADDED
    {
        RF_HasExternalPackage
    }
    BREAKING
    {
        No breaking changes
    }
    
    FROM 4.25 TO 5.0
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    NO CHANGES
}

EPropertyFlags
{
    FROM x.xx TO 4.12
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectBase.h
    NOTES
    {
        Is not an enum, but a bunch of defines
    }
    
    FROM 4.12 TO 4.13
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectBase.h
    ADDED
    {
        CPF_SkipSerialization
        CPF_PropagateToSetElement <- Combination of flags
    }
    
    FROM 4.13 TO 4.14
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    NO CHANGES
    
    FROM 4.14 TO 4.15
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    CHANGES
    {
        Combination flag CPF_ComputedFlags had CPF_HasGetValueTypeHash added
    }
    BREAKING
    {
        No breaking changes
    }
    
    FROM 4.15 TO 4.20
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    CHANGES
    {
        Changed from a bunch of defines to an enum
    }
    BREAKING CHANGES
    {
        No breaking changes
    }
    
    FROM 4.20 TO 4.22
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    NO CHANGES
    
    FROM 4.22 TO 4.25
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    NO CHANGES
    
    FROM 4.25 TO 5.0_ea_branch_ue5-main
    DEFINED IN: Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h
    REMOVED
    {
        CPF_SubobjectReference
    }
    BREAKING
    {
        Anything that relis on anything listed in the REMOVED section
    }
}
```

`Internal_Docs/WidgetCreation.txt`:

```txt
Create a type that inherits from UUserWidget
Don't know how yet

Call the following on the created type
UUserWidget::CreateWidget<WidgetT, OwnerT>
Call UUserWidget::CreateInstanceInternal

UUserWidget::CreateInstanceInternal
Call NewObject
Call SetPlayerContext on the created object
Call Initialize on the created object

UObjectGlobals::NewObject
Disallow Name == NAME_None
Call StaticConstructObject_Internal
Seems doable

UUserWidget::SetPlayerContext
Non-virtual, non-UFunction
Iterate all user widgets in the UPROPERTY 'WidgetTree', which is a TObjectPtr<UWidgetTree>
PlayerContext is a non-reflected member of UUserWidget so access to it might not be very consistent
Maybe possible, have to look into the iterator

UUserWidget::Initialize
Is virtual, therefore, just call it
Home of this function is UUserWidget, it's not an override
```

`Internal_Docs/aobs/EngineVersion.txt`:

```txt
UNUSED IN RC::UNREAL AT THE MOMENT
static class GetLazy & __ptr64 __cdecl TLazySingleton<struct FGlobalEngineVersions>::GetLazy(void (__cdecl*)(void * __ptr64))'::`2'::`dynamic atexit destructor for 'Singleton''(void)>
40 53 48 83 EC 20 48 8B ?? ?? ?? ?? ?? 48 85 DB 74 27 48 8B 4B 30 48 85 C9 74 05 E8
Find the first MOV and resolve it, follow the pointer at 0x0, and then you have major version at 0x0, minor version at 0x2, and the patch version at 0x4

THIS IS WHAT'S CURRENTLY USED IN RC::UNREAL
FEngineVersion struct
Module: Core
4.27.2
04 00 1B 00 02 00 00 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00
4.26.1
04 00 1A 00 01 00 00 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00
4.25.x
04 00 19 00 ?? 00 00 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00
4.13.x
04 00 0D 00 ?? 00 00 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00
4.x.x (almost unique enough, the last '??' makes it not unique enough)
04 00 ?? 00 ?? 00 00 00 ?? ?? ?? ?? 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00 ?? 00 00 00 ?? 00 00 00 04 00 ?? 00 ?? 00 00 00


The first two bytes is the major version, the next two bytes are the minor version, the third two bytes are the patch version
Then there's some padding and then there's a pointer to the "BranchName" member variable which is an FString
Usage: Replace the version bytes with what you're looking for, probably have to scan for every version and just see which version it finds
Usage (4.x.x): For each result, check for valid pointer at 0x10, if valid pointer is found, check first two bytes to see if they match the wide ascii for "++"
               If "++" exists then this may be the correct result, checking the string further is not possible as it could be anything
               Also, confirm that offset 0x0 doesn't contain anything less than 3 or greater than 5 (update to 6 if they make UE6)
               Offset 0x2 and 0x4 can be sanity checked by making sure the number isn't super high
               For offset 0x2, a good number is 40 as that's very far in the future if it ever happens
               For offset 0x4, a good number is 10 as it's highly unlikely that any version will ever receive 10 patches

```

`Internal_Docs/aobs/FMemory_Free.txt`:

```txt
Unrelated, move to correct file later
{
FMemory::Malloc was changed quite a bit at some point so it's not unlikely that at least two aobs will be needed.
Same with FMemory::Realloc
}

FMemory::Free has not changed very much since 2016.
There is one line of code that's different which is for optional tracking of all allocations.
This one change is a runtime change so it should be noticeable.
This change first appeared 2017-06-21, and 4.12, which is the earliest version UE4SS supports, was released in 2016.
All other changes are very minor changes to this same change that shouldn't affect the aob.
More if there are byte differences between compilers.

Direct scan
{
48 85 C9 74 2E 53 48 83 EC 20 48 8B D9 48 8B ?? ?? ?? ?? ?? 48 85 C9
Module: Core
Originally found in: Demo game (4.12), matches: 1
Works in:
Demo game (4.22), matches: 1
Demo game (4.26), matches: 1
Satisfactory CL#176027 (4.26.1), matches: 1
Dead By Daylight (4.25.1), matches: 1
Deep Rock Galactic CL#64856 (4.25.0), matches: 1
}

Assembly
4.12
{
00007FF65392F7D0 | 48:85C9                     | TEST RCX,RCX                                                                                                                    | fmemory.inl:34
00007FF65392F7D3 | 74 2E                       | JE ue4ss_main412-win64-shipping.7FF65392F803                                                                                    |
00007FF65392F7D5 | 53                          | PUSH RBX                                                                                                                        |
00007FF65392F7D6 | 48:83EC 20                  | SUB RSP,20                                                                                                                      |
00007FF65392F7DA | 48:8BD9                     | MOV RBX,RCX                                                                                                                     | fmemory.inl:34
00007FF65392F7DD | 48:8B0D B4F02302            | MOV RCX,QWORD PTR DS:[<class FMalloc * __ptr64 __ptr64 GMalloc>]                                                                | fmemory.inl:41
00007FF65392F7E4 | 48:85C9                     | TEST RCX,RCX                                                                                                                    |
00007FF65392F7E7 | 75 0C                       | JNE ue4ss_main412-win64-shipping.7FF65392F7F5                                                                                   |
00007FF65392F7E9 | E8 82050000                 | CALL <ue4ss_main412-win64-shipping.private: static void __cdecl FMemory::GCreateMalloc(void)>                                   | fmemory.inl:43
00007FF65392F7EE | 48:8B0D A3F02302            | MOV RCX,QWORD PTR DS:[<class FMalloc * __ptr64 __ptr64 GMalloc>]                                                                |
00007FF65392F7F5 | 48:8B01                     | MOV RAX,QWORD PTR DS:[RCX]                                                                                                      | fmemory.inl:48
00007FF65392F7F8 | 48:8BD3                     | MOV RDX,RBX                                                                                                                     |
00007FF65392F7FB | FF50 20                     | CALL QWORD PTR DS:[RAX+20]                                                                                                      |
00007FF65392F7FE | 48:83C4 20                  | ADD RSP,20                                                                                                                      | fmemory.inl:49
00007FF65392F802 | 5B                          | POP RBX                                                                                                                         |
00007FF65392F803 | C3                          | RET                                                                                                                             |
}

4.21
{
$ ==>            | 48 85 C9                 | test rcx,rcx                                                                              |
$+3              | 74 1D                    | je ue4ss_main421-win64-shipping.7FF77A0E1442                                              |
$+5              | 4C 8B 05 D4 5F 8A 02     | mov r8,qword ptr ds:[<GMalloc>]                                                           |
$+C              | 4D 85 C0                 | test r8,r8                                                                                |
$+F              | 0F 84 9B 05 00 00        | je <ue4ss_main421-win64-shipping.FMemory::FreeExternal>                                   |
$+15             | 49 8B 00                 | mov rax,qword ptr ds:[r8]                                                                 |
$+18             | 48 8B D1                 | mov rdx,rcx                                                                               | rdx:DbgUiRemoteBreakin
$+1B             | 49 8B C8                 | mov rcx,r8                                                                                |
$+1E             | 48 FF 60 20              | jmp qword ptr ds:[rax+20]                                                                 |
$+22             | C3                       | ret                                                                                       |
}


```

`Internal_Docs/aobs/FName_ToString.txt`:

```txt
FName::ToString, indirect scan

4.12
{
    GetFeatureLevelName / GetMaterialQualityLevelName
    Instruction: JMP
    48 63 C1 48 8D ?? ?? ?? ?? ?? 48 8D 0C C1 E9
    Not found in: 4.26
    
    FSoundSource::DrawDebugInfo
    Instruction: CALL
    E8 ?? ?? ?? ?? 48 8B 43 18 83 78 0C 02 75 72 48 8B 43 10
    Not found in: 4.26
    
    FMaterialShaderMapId::AppendKeyString
    Instruction: CALL
    E8 ?? ?? ?? ?? 8B 5D 08 41 8B C5 85 DB 4C 89 6C 24 20
    Not found in: 4.26
    
    FMaterialShaderMapId::GetMaterialHash
    Instruction: CALL
    E8 ?? ?? ?? ?? 44 8B 44 24 28 45 85 C0 74 0A
    Not found in: 4.26
    
    UParticleModule::GenerateLODModule
    Instruction: CALL
    Precursor bytes #1: 48 89 44 24 70
    Precursor bytes #2: 48 89 6C 24 40
    Precursor bytes #3: 48 89 6C 24 48
    E8 ?? ?? ?? ?? 48 8B 4C 24 40 8B FD 48 85 C9
    Confirmed found in: 4.22, 4.26, 5.0 EA #1
    Also found in: Various versions, C++ and BP-only, between 4.12 and 4.26
    Not found in: Demo game (4.25.3, case preserving), Dead Rock Galactic (4.25), DBD (4.25.3, case preserving)
    Improved variant #1 {
        Out of the 'Not found in' section, this improved version is found in: Demo game (4.25.3 case preserving)
        What was changed: A 0x40 was changed to 0x??, and it was 0x50 in "Demo game (4.25.3 case preserving)"

        Still not found in: Dead Rock Galactic (4.25), DBD (4.25.3, case preserving)
        Precursor bytes #1: 48 89 6C 24 50
        Precursor bytes #2: 48 89 6C 24 58
        Precursor bytes #3: 89 44 24 48
        E8 ?? ?? ?? ?? 48 8B 4C 24 ?? 8B FD 48 85 C9
    }
    Improved variant #2 {
        Out of the 'Still not found' from variant #1, this improved version is found in: DBD (4.25.3, case preserving)
        Regression, not found in: Demo game (4.25, case preserving)
        Still not found in: Dead Rock Galactic (4.25)
        48 89 6C 24 48 E8 ?? ?? ?? ?? 48 8B ?? ?? ?? ?? ?? 48 85
    }
    String refs far above: "ServicesBPLibrary"
    String refs nearby below: "ServicesBPLibrary", "alid bitset<N> position"
    None of the string refs are valid for all games, so ignore them
    Usage: Follow the call at 0x0, and you're at FName::ToString.
}

DBD, 4.25
{
    UParticleModule::GenerateLODModule
    Instruction: CALL
    Precursor bytes #1: 48 89 5C 24 40
    Precursor bytes #2: 48 8B CE     
    Precursor bytes #3: 48 89 6C 24 48
    48 89 6C 24 48 E8 ?? ?? ?? ?? 48 8B ?? ?? ?? ?? ?? 48 85

    UEnum::GenerateEnumPrefix
    Instruction: CALL
    E8 ?? ?? ?? ?? BD 01 00 00 00 41 39 6E 50 0F 8E
    Found in: DRG (4.25)
    Not found in: DBD
}

4.26
{
    GetFeatureLevelName / GetMaterialQualityLevelName
    Instruction: JMP
    40 53 48 83 EC 20 48 8B DA 83 F9 04 73 18 48 63 C1 48 8D ?? ?? ?? ?? ?? 48 8D 0C C1 48 83 C4 20 5B E9
    Not found in: 
    
    UEnum::GenerateEnumPrefix
    Instruction: CALL
    E8 ?? ?? ?? ?? BD 01 00 00 00 41 39 6E 48 0F 8E
    Found in: DRG (4.25)
    Not found in: DBD
    Improved variant #1 {
        Also works for DBD
        E8 ?? ?? ?? ?? BD 01 00 00 00 41 39 6E ?? 0F 8E
        
        Usage: Follow the call at 0x0, and you're at FName::ToString.
    }
    Modular variant {
        To be used for modular games (example: Satisfactory)
        This AOB needs work, it's made from a sample size of 1 (Satisfactory)
        FF 15 ?? ?? ?? ?? 41 BE 01 00 00 00 45 39 75 48
    }
    
    GetPackageLinker
    Instruction: CALL
    E8 ?? ?? ?? ?? 48 8B 5D 88 48 8B C7 4C 8B 7D 80
    
    FScene::UpdateSceneCaptureContents
    Instruction: CALL
    E8 ?? ?? ?? ?? 8B 5D F0 33 D2 44 0F B6 B6 FC 00 00 00
    
    RHIInit
    Instruction: CALL
    E8 ?? ?? ?? ?? EB 51 BA 14 00 00 00 48 8D 4C 24 20
    
    FAudioDevice::AddNewActiveSoundInternal
    Instruction: CALL
    E8 ?? ?? ?? ?? 48 8B 53 28 4C 8B C6 48 8B CF
    
    UMaterialInstance::Serialize
    Instruction: CALL
    E8 ?? ?? ?? ?? 45 8D 74 24 40 45 8D 7C 24 05 0F 1F 80 00 00 00 00
    
    UParticleModule::GenerateLODModule
    Instruction: CALL
    E8 ?? ?? ?? ?? 48 8B 4C 24 40 8B FD 48 85 C9
    Modular variant {
        To be used for modular games (example: Satisfactory)
        This AOB needs work, it's made from a sample size of 1 (Satisfactory)
        FF 15 ?? ?? ?? ?? 80 3D ?? ?? ?? ?? ?? 72 3A 44 39 74 24 48
    }
}

Idea so far
{
    Four AOBs, one:
    Module: Engine
    "E8 ?? ?? ?? ?? 48 8B 4C 24 ?? 8B FD 48 85 C9"
    for 4.12 - 5.0 EA #1
    two:
    Module: Engine
    "FF 15 ?? ?? ?? ?? 80 3D ?? ?? ?? ?? ?? 72 3A 44 39 74 24 48"
    same as "one" except for modular games like Satisfactory
    three:
    Module: CoreUObject
    "E8 ?? ?? ?? ?? BD 01 00 00 00 41 39 6E ?? 0F 8E"
    for 4.25+ if the first one fails
    four:
    Module: CoreUObject
    "FF 15 ?? ?? ?? ?? 41 BE 01 00 00 00 45 39 75 48"
    same as "three" except for modular games like Satisfactory
}

```

`Internal_Docs/aobs/GUObjectArray.txt`:

```txt
4.12 (indirect scan, follow mov) (scans for FWeakObjectPtr::Get)
8B 51 04 85 D2 74 5A 48 63 01 85 C0 78 53 44 8B ?? ?? ?? ?? ?? 41 3B C0 7D 47 4C 8B
not found in:
DRG (4.25)
Satisfactory (4.26, modular)
SX4 (4.25)
Demo game (4.26)
Demo game (4.22)
found in
Demo game (4.12)

4.18 (indirect scan, follow lea) (scans for FUObjectArray::FUObjectArray)
48 89 5C 24 08 48 89 74 24 10 57 48 83 EC 20 33 F6 C7 41 04 FF FF FF FF 89
Called from "Unknown function -> _onexit -> atexit -> initterm"
not found in:
Jedi Fallen Order (4.21)
{
    Games doesn't seem to have any references to GUObjectArray from any lea instructions, only from mov instructions
}
found in:
DRG (4.25) - right { lea at 0x94 }
Satisfactory (4.25, modular) - right
SX4 (4.25) - right
Demo game (4.26) - right { lea at 0x94 }
Demo game (4.22) - right { lea at 0x94 }
Demo game (4.12) - wrong {
    goes to a function but the lea does not resolve directly to GUObjectArray
    the lea is at 0x89 in the function and inside is another lea at 0x0 that resolves to GUObjectArray
}
GH demo game (4.24) - right { lea at 0x94 }
Demo game (4.25, BP) - right { lea at 0x94 }
Shooter game (4.17, BP) - right { lea at 0x8C }
Demo game (5.0 EA #1) - right { lea at 0x8C } "48 8D 05 5DC39E03"
DBD (4.25, no aslr) - right { lea at 0x94 } "48 8D 05 F5376805"
Crash Bandicoot 4 (4.24) - right { lea at 0x94 } "48 8D 05 0D3A1E03"
Hello Neighbor 1 (4.21) - right { lea at 0x94 } "48 8D 05 55E28002"
Hello Neighbor 2 (4.25) - right { lea at 0x94 } "48 8D 05 E5C52E03"

4.19+ (direct scan)
?? ?? 0? 00 ?? ?? ?? ?? ?? ?? 0? 00 00 00 00 00 ?? ?? ?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 ?0 2? 00 ?? ?? ?? 00 2? 00 00 00 0? 00 00 00 FF FF FF FF FF FF FF FF FF
59 DC 00 00 58 DC 00 00 59 DC 00 00 00 00 00 00 A0 12 ?? ?? ?? ?? 00 00 00 00 00 00 00 00 00 00 00 00 21 00 ?? ?? ?? 00 21 00 00 00 ?? 00 00 00
found in:
DRG (4.25) - right
Satisfactory (4.25, modular) - right
SX4 (4.25) - right
Demo game (4.26) - right
Demo game (4.22) - right

```

`Internal_Docs/aobs/GUObjectArray2.txt`:

```txt
Function: bool __cdecl UObjectBase::IsValidLowLevel(void)const __ptr64
Module: CoreUObject

4.12
{
$ ==>            | 48:85C9                     | TEST RCX,RCX                                
$+3              | 74 36                       | JE ue4ss_main412-win64-shipping.7FF77FEF4C8B
$+5              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
$+A              | 74 2F                       | JE ue4ss_main412-win64-shipping.7FF77FEF4C8B
$+C              | 48:6341 0C                  | MOVSXD RAX,DWORD PTR DS:[RCX+C]             
$+10             | 83F8 FF                     | CMP EAX,FFFFFFFF                            
$+13             | 74 26                       | JE ue4ss_main412-win64-shipping.7FF77FEF4C8B
$+15             | 3B05 21171B02               | CMP EAX,DWORD PTR DS:[7FF7820A638C]         
$+1B             | 7D 1E                       | JGE ue4ss_main412-win64-shipping.7FF77FEF4C8
$+1D             | 85C0                        | TEST EAX,EAX                                
$+1F             | 78 1A                       | JS ue4ss_main412-win64-shipping.7FF77FEF4C8B
$+21             | 48:C1E0 04                  | SHL RAX,4                                   
$+25             | 48:0305 04171B02            | ADD RAX,QWORD PTR DS:[7FF7820A6380]         
$+2C             | 48:8B10                     | MOV RDX,QWORD PTR DS:[RAX]                  
$+2F             | 48:85D2                     | TEST RDX,RDX                                
$+32             | 74 07                       | JE ue4ss_main412-win64-shipping.7FF77FEF4C8B
$+34             | 48:3BD1                     | CMP RDX,RCX                                 
$+37             | 0F94C0                      | SETE AL                                     
$+3A             | C3                          | RET                                         
$+3B             | 32C0                        | XOR AL,AL                                   
$+3D             | C3                          | RET                                         

AOB to GUObjectArray ADD (start of AOB): 48 03 ?? ?? ?? ?? ?? 48 8B 10 48 85 D2 74 07
AOB works in 4.12
This AOB is for an ADD instruction, which is an instruction that I haven't yet tried to resolve
}

4.13
{
$ ==>            | 48:85C9                     | TEST RCX,RCX                                                                                                                  
$+3              | 75 03                       | JNE ue4ss_main413-win64-shipping.7FF737A1C0A8                                                                                 
$+5              | 32C0                        | XOR AL,AL                                                                                                                     
$+7              | C3                          | RET                                                                                                                           
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                                                                                                   
$+D              | 74 F6                       | JE ue4ss_main413-win64-shipping.7FF737A1C0A5                                                                                  
$+F              | 48:8BD1                     | MOV RDX,RCX                                                                                                                   
$+12             | 48:8D0D B7913D02            | LEA RCX,QWORD PTR DS:[<class FUObjectArray GUObjectArray>]                                                                    
$+19             | E9 42CA0300                 | JMP <ue4ss_main413-win64-shipping.public: bool __cdecl FUObjectArray::IsValid(class UObjectBase const * __ptr64)const __ptr64>

AOB to GUObjectArray LEA (end of AOB): 48 83 79 10 00 74 F6 48 8B D1 48 8D
AOB works in 4.13
Do not subtract 0x10 from the result for this one
}

4.14
{
00007FF6E2E8C190 | 48:8BD1                     | MOV RDX,RCX                                 
00007FF6E2E8C193 | 48:85C9                     | TEST RCX,RCX                                
00007FF6E2E8C196 | 74 37                       | JE ue4ss_main414-win64-shipping.7FF6E2E8C1CF
00007FF6E2E8C198 | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
00007FF6E2E8C19D | 74 30                       | JE ue4ss_main414-win64-shipping.7FF6E2E8C1CF
00007FF6E2E8C19F | 48:6341 0C                  | MOVSXD RAX,DWORD PTR DS:[RCX+C]             
00007FF6E2E8C1A3 | 83F8 FF                     | CMP EAX,FFFFFFFF                            
00007FF6E2E8C1A6 | 74 27                       | JE ue4ss_main414-win64-shipping.7FF6E2E8C1CF
00007FF6E2E8C1A8 | 3B05 4E146B02               | CMP EAX,DWORD PTR DS:[7FF6E553D5FC]         
00007FF6E2E8C1AE | 7D 1F                       | JGE ue4ss_main414-win64-shipping.7FF6E2E8C1C
00007FF6E2E8C1B0 | 85C0                        | TEST EAX,EAX                                
00007FF6E2E8C1B2 | 78 1B                       | JS ue4ss_main414-win64-shipping.7FF6E2E8C1CF
00007FF6E2E8C1B4 | 48:8D0C40                   | LEA RCX,QWORD PTR DS:[RAX+RAX*2]            
00007FF6E2E8C1B8 | 48:8B05 31146B02            | MOV RAX,QWORD PTR DS:[7FF6E553D5F0]         
00007FF6E2E8C1BF | 4C:8B04C8                   | MOV R8,QWORD PTR DS:[RAX+RCX*8]             
00007FF6E2E8C1C3 | 4D:85C0                     | TEST R8,R8                                  
00007FF6E2E8C1C6 | 74 07                       | JE ue4ss_main414-win64-shipping.7FF6E2E8C1CF
00007FF6E2E8C1C8 | 4C:3BC2                     | CMP R8,RDX                                  
00007FF6E2E8C1CB | 0F94C0                      | SETE AL                                     
00007FF6E2E8C1CE | C3                          | RET                                         
00007FF6E2E8C1CF | 32C0                        | XOR AL,AL                                   
00007FF6E2E8C1D1 | C3                          | RET                                         
}

4.16
{
$ ==>            | 48:8BD1                     | MOV RDX,RCX                                                                                                                   
$+3              | 48:85C9                     | TEST RCX,RCX                                                                                                                  
$+6              | 74 37                       | JE ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                  
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                                                                                                   
$+D              | 74 30                       | JE ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                  
$+F              | 48:6341 0C                  | MOVSXD RAX,DWORD PTR DS:[RCX+C]                                                                                               
$+13             | 83F8 FF                     | CMP EAX,FFFFFFFF                                                                                                              
$+16             | 74 27                       | JE ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                  
$+18             | 3B05 CEC0D102               | CMP EAX,DWORD PTR DS:[7FF6E2907B8C]                                                                                           
$+1E             | 7D 1F                       | JGE ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                 
$+20             | 85C0                        | TEST EAX,EAX                                                                                                                  
$+22             | 78 1B                       | JS ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                  
$+24             | 48:8D0C40                   | LEA RCX,QWORD PTR DS:[RAX+RAX*2]                                                                                              
$+28             | 48:8B05 B1C0D102            | MOV RAX,QWORD PTR DS:[7FF6E2907B80]                                                                                           
$+2F             | 4C:8B04C8                   | MOV R8,QWORD PTR DS:[RAX+RCX*8]                                                                                               
$+33             | 4D:85C0                     | TEST R8,R8                                                                                                                    
$+36             | 74 07                       | JE ue4ss_main416-win64-shipping.7FF6DFBEBADF                                                                                  
$+38             | 4C:3BC2                     | CMP R8,RDX                                                                                                                    
$+3B             | 0F94C0                      | SETE AL                                                                                                                       
$+3E             | C3                          | RET                                                                                                                           
}

4.19
{
00007FF6E65B2580 | 48:8BD1                     | MOV RDX,RCX                                 
00007FF6E65B2583 | 48:85C9                     | TEST RCX,RCX                                
00007FF6E65B2586 | 74 37                       | JE ue4ss_main419-win64-shipping.7FF6E65B25BF
00007FF6E65B2588 | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
00007FF6E65B258D | 74 30                       | JE ue4ss_main419-win64-shipping.7FF6E65B25BF
00007FF6E65B258F | 48:6341 0C                  | MOVSXD RAX,DWORD PTR DS:[RCX+C]             
00007FF6E65B2593 | 83F8 FF                     | CMP EAX,FFFFFFFF                            
00007FF6E65B2596 | 74 27                       | JE ue4ss_main419-win64-shipping.7FF6E65B25BF
00007FF6E65B2598 | 3B05 7E157E02               | CMP EAX,DWORD PTR DS:[7FF6E8D93B1C]         
00007FF6E65B259E | 7D 1F                       | JGE ue4ss_main419-win64-shipping.7FF6E65B25B
00007FF6E65B25A0 | 85C0                        | TEST EAX,EAX                                
00007FF6E65B25A2 | 78 1B                       | JS ue4ss_main419-win64-shipping.7FF6E65B25BF
00007FF6E65B25A4 | 48:8D0C40                   | LEA RCX,QWORD PTR DS:[RAX+RAX*2]            
00007FF6E65B25A8 | 48:8B05 61157E02            | MOV RAX,QWORD PTR DS:[7FF6E8D93B10]         
00007FF6E65B25AF | 4C:8B04C8                   | MOV R8,QWORD PTR DS:[RAX+RCX*8]             
00007FF6E65B25B3 | 4D:85C0                     | TEST R8,R8                                  
00007FF6E65B25B6 | 74 07                       | JE ue4ss_main419-win64-shipping.7FF6E65B25BF
00007FF6E65B25B8 | 4C:3BC2                     | CMP R8,RDX                                  
00007FF6E65B25BB | 0F94C0                      | SETE AL                                     
00007FF6E65B25BE | C3                          | RET                                         
00007FF6E65B25BF | 32C0                        | XOR AL,AL                                   
00007FF6E65B25C1 | C3                          | RET                                         

AOB to GUObjectArray MOV (start of AOB): 48 8B ?? ?? ?? ?? ?? 4C 8B 04 C8 4D 85 C0 74 07
AOB works in 4.14, 4.16, 4.19
}

4.20
{
$ ==>            | 4C:8BC9                     | MOV R9,RCX                                  
$+3              | 48:85C9                     | TEST RCX,RCX                                
$+6              | 74 59                       | JE ue4ss_main420-win64-shipping.7FF70C6ECBD1
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
$+D              | 74 52                       | JE ue4ss_main420-win64-shipping.7FF70C6ECBD1
$+F              | 8B49 0C                     | MOV ECX,DWORD PTR DS:[RCX+C]                
$+12             | 83F9 FF                     | CMP ECX,FFFFFFFF                            
$+15             | 74 4A                       | JE ue4ss_main420-win64-shipping.7FF70C6ECBD1
$+17             | 3B0D EF146702               | CMP ECX,DWORD PTR DS:[7FF70ED5E07C]         
$+1D             | 7D 42                       | JGE ue4ss_main420-win64-shipping.7FF70C6ECBD
$+1F             | 85C9                        | TEST ECX,ECX                                
$+21             | 78 3E                       | JS ue4ss_main420-win64-shipping.7FF70C6ECBD1
$+23             | B8 7FE0077E                 | MOV EAX,7E07E07F                            
$+28             | F7E9                        | IMUL ECX                                    
$+2A             | C1FA 0F                     | SAR EDX,F                                   
$+2D             | 8BC2                        | MOV EAX,EDX                                 
$+2F             | C1E8 1F                     | SHR EAX,1F                                  
$+32             | 03D0                        | ADD EDX,EAX                                 
$+34             | 69C2 00040100               | IMUL EAX,EDX,10400                          
$+3A             | 2BC8                        | SUB ECX,EAX                                 
$+3C             | 48:63C1                     | MOVSXD RAX,ECX                              
$+3F             | 48:63CA                     | MOVSXD RCX,EDX                              
$+42             | 4C:8D0440                   | LEA R8,QWORD PTR DS:[RAX+RAX*2]             
$+46             | 48:8B05 AB146702            | MOV RAX,QWORD PTR DS:[7FF70ED5E068]         
$+4D             | 48:8B0CC8                   | MOV RCX,QWORD PTR DS:[RAX+RCX*8]            
$+51             | 4A:8B04C1                   | MOV RAX,QWORD PTR DS:[RCX+R8*8]             
$+55             | 48:85C0                     | TEST RAX,RAX                                
$+58             | 74 07                       | JE ue4ss_main420-win64-shipping.7FF70C6ECBD1
$+5A             | 49:3BC1                     | CMP RAX,R9                                  
$+5D             | 0F94C0                      | SETE AL                                     
$+60             | C3                          | RET                                         
$+61             | 32C0                        | XOR AL,AL                                   
$+63             | C3                          | RET                                         
}

4.24
{
$ ==>            | 4C:8BC1                     | MOV R8,RCX                                  
$+3              | 48:85C9                     | TEST RCX,RCX                                
$+6              | 74 4F                       | JE ue4ss_main424-win64-shipping.7FF70BACA9F7
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
$+D              | 74 48                       | JE ue4ss_main424-win64-shipping.7FF70BACA9F7
$+F              | 8B41 0C                     | MOV EAX,DWORD PTR DS:[RCX+C]                
$+12             | 83F8 FF                     | CMP EAX,FFFFFFFF                            
$+15             | 74 40                       | JE ue4ss_main424-win64-shipping.7FF70BACA9F7
$+17             | 3B05 6FCEB702               | CMP EAX,DWORD PTR DS:[7FF70E64782C]         
$+1D             | 7D 38                       | JGE ue4ss_main424-win64-shipping.7FF70BACA9F
$+1F             | 85C0                        | TEST EAX,EAX                                
$+21             | 78 34                       | JS ue4ss_main424-win64-shipping.7FF70BACA9F7
$+23             | 99                          | CDQ                                         
$+24             | 0FB7D2                      | MOVZX EDX,DX                                
$+27             | 03C2                        | ADD EAX,EDX                                 
$+29             | 8BC8                        | MOV ECX,EAX                                 
$+2B             | 0FB7C0                      | MOVZX EAX,AX                                
$+2E             | 2BC2                        | SUB EAX,EDX                                 
$+30             | C1F9 10                     | SAR ECX,10                                  
$+33             | 48:98                       | CDQE                                        
$+35             | 48:63C9                     | MOVSXD RCX,ECX                              
$+38             | 48:8D1440                   | LEA RDX,QWORD PTR DS:[RAX+RAX*2]            
$+3C             | 48:8B05 35CEB702            | MOV RAX,QWORD PTR DS:[7FF70E647818]         
$+43             | 48:8B0CC8                   | MOV RCX,QWORD PTR DS:[RAX+RCX*8]            
$+47             | 48:8B04D1                   | MOV RAX,QWORD PTR DS:[RCX+RDX*8]            
$+4B             | 48:85C0                     | TEST RAX,RAX                                
$+4E             | 74 07                       | JE ue4ss_main424-win64-shipping.7FF70BACA9F7
$+50             | 49:3BC0                     | CMP RAX,R8                                  
$+53             | 0F94C0                      | SETE AL                                     
$+56             | C3                          | RET                                         
$+57             | 32C0                        | XOR AL,AL                                   
$+59             | C3                          | RET                                         
}

4.25 (case preserving)
{
$ ==>            | 4C:8BC1                     | MOV R8,RCX                                         
$+3              | 48:85C9                     | TEST RCX,RCX                                       
$+6              | 74 4F                       | JE ue4ss_casepreserving-win64-shipping.7FF7E569D457
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                        
$+D              | 74 48                       | JE ue4ss_casepreserving-win64-shipping.7FF7E569D457
$+F              | 8B41 0C                     | MOV EAX,DWORD PTR DS:[RCX+C]                       
$+12             | 83F8 FF                     | CMP EAX,FFFFFFFF                                   
$+15             | 74 40                       | JE ue4ss_casepreserving-win64-shipping.7FF7E569D457
$+17             | 3B05 EF542103               | CMP EAX,DWORD PTR DS:[7FF7E88B290C]                
$+1D             | 7D 38                       | JGE ue4ss_casepreserving-win64-shipping.7FF7E569D45
$+1F             | 85C0                        | TEST EAX,EAX                                       
$+21             | 78 34                       | JS ue4ss_casepreserving-win64-shipping.7FF7E569D457
$+23             | 99                          | CDQ                                                
$+24             | 0FB7D2                      | MOVZX EDX,DX                                       
$+27             | 03C2                        | ADD EAX,EDX                                        
$+29             | 8BC8                        | MOV ECX,EAX                                        
$+2B             | 0FB7C0                      | MOVZX EAX,AX                                       
$+2E             | 2BC2                        | SUB EAX,EDX                                        
$+30             | C1F9 10                     | SAR ECX,10                                         
$+33             | 48:98                       | CDQE                                               
$+35             | 48:63C9                     | MOVSXD RCX,ECX                                     
$+38             | 48:8D1440                   | LEA RDX,QWORD PTR DS:[RAX+RAX*2]                   
$+3C             | 48:8B05 B5542103            | MOV RAX,QWORD PTR DS:[7FF7E88B28F8]                
$+43             | 48:8B0CC8                   | MOV RCX,QWORD PTR DS:[RAX+RCX*8]                   
$+47             | 48:8B04D1                   | MOV RAX,QWORD PTR DS:[RCX+RDX*8]                   
$+4B             | 48:85C0                     | TEST RAX,RAX                                       
$+4E             | 74 07                       | JE ue4ss_casepreserving-win64-shipping.7FF7E569D457
$+50             | 49:3BC0                     | CMP RAX,R8                                         
$+53             | 0F94C0                      | SETE AL                                            
$+56             | C3                          | RET                                                
$+57             | 32C0                        | XOR AL,AL                                          
$+59             | C3                          | RET                                                
}

4.27
{
$ ==>            | 4C:8BC1                     | MOV R8,RCX                                  
$+3              | 48:85C9                     | TEST RCX,RCX                                
$+6              | 74 4F                       | JE ue4ss_main427-win64-shipping.7FF69B5FE777
$+8              | 48:8379 10 00               | CMP QWORD PTR DS:[RCX+10],0                 
$+D              | 74 48                       | JE ue4ss_main427-win64-shipping.7FF69B5FE777
$+F              | 8B41 0C                     | MOV EAX,DWORD PTR DS:[RCX+C]                
$+12             | 83F8 FF                     | CMP EAX,FFFFFFFF                            
$+15             | 74 40                       | JE ue4ss_main427-win64-shipping.7FF69B5FE777
$+17             | 3B05 670F7703               | CMP EAX,DWORD PTR DS:[7FF69ED6F6A4]         
$+1D             | 7D 38                       | JGE ue4ss_main427-win64-shipping.7FF69B5FE77
$+1F             | 85C0                        | TEST EAX,EAX                                
$+21             | 78 34                       | JS ue4ss_main427-win64-shipping.7FF69B5FE777
$+23             | 99                          | CDQ                                         
$+24             | 0FB7D2                      | MOVZX EDX,DX                                
$+27             | 03C2                        | ADD EAX,EDX                                 
$+29             | 8BC8                        | MOV ECX,EAX                                 
$+2B             | 0FB7C0                      | MOVZX EAX,AX                                
$+2E             | 2BC2                        | SUB EAX,EDX                                 
$+30             | C1F9 10                     | SAR ECX,10                                  
$+33             | 48:98                       | CDQE                                        
$+35             | 48:63C9                     | MOVSXD RCX,ECX                              
$+38             | 48:8D1440                   | LEA RDX,QWORD PTR DS:[RAX+RAX*2]            
$+3C             | 48:8B05 2D0F7703            | MOV RAX,QWORD PTR DS:[7FF69ED6F690]         
$+43             | 48:8B0CC8                   | MOV RCX,QWORD PTR DS:[RAX+RCX*8]            
$+47             | 48:8B04D1                   | MOV RAX,QWORD PTR DS:[RCX+RDX*8]            
$+4B             | 48:85C0                     | TEST RAX,RAX                                
$+4E             | 74 07                       | JE ue4ss_main427-win64-shipping.7FF69B5FE777
$+50             | 49:3BC0                     | CMP RAX,R8                                  
$+53             | 0F94C0                      | SETE AL                                     
$+56             | C3                          | RET                                         
$+57             | 32C0                        | XOR AL,AL                                   
$+59             | C3                          | RET                                         

AOB to GUObjectArray MOV (start of AOB): 48 8B ?? ?? ?? ?? ?? 48 8B 0C C8 ?? 8B 04 ?? 48 85 C0
AOB works in 4.20, 4.24, 4.25 (case preserving), 4.27
AOB doesn't work in Satisfactory (4.26.1, modular)
}

Satisfactory (4.26.1, modular)
{
UObjectBase::IsValidLowLevel - 48 83 EC 38             - sub rsp,38
UObjectBase::IsValidLowLevel+4- 48 85 C9               - test rcx,rcx
UObjectBase::IsValidLowLevel+7- 75 12                  - jne FactoryGame-CoreUObject-Win64-Shipping.UObjectBase::IsValidLowLevel+1B
UObjectBase::IsValidLowLevel+9- 80 3D 48F01500 03      - cmp byte ptr [FactoryGame-CoreUObject-Win64-Shipping.LogUObjectBase],03
UObjectBase::IsValidLowLevel+10- 72 3C                 - jb FactoryGame-CoreUObject-Win64-Shipping.UObjectBase::IsValidLowLevel+4E
UObjectBase::IsValidLowLevel+12- 48 8D 05 47CD0B00     - lea rax,[FactoryGame-CoreUObject-Win64-Shipping.dll.rdata+5FFC0]
UObjectBase::IsValidLowLevel+19- EB 17                 - jmp FactoryGame-CoreUObject-Win64-Shipping.UObjectBase::IsValidLowLevel+32
UObjectBase::IsValidLowLevel+1B- 48 83 79 10 00        - cmp qword ptr [rcx+10],00
UObjectBase::IsValidLowLevel+20- 75 33                 - jne FactoryGame-CoreUObject-Win64-Shipping.UObjectBase::IsValidLowLevel+55
UObjectBase::IsValidLowLevel+22- 80 3D 2FF01500 03     - cmp byte ptr [FactoryGame-CoreUObject-Win64-Shipping.LogUObjectBase],03
UObjectBase::IsValidLowLevel+29- 72 23                 - jb FactoryGame-CoreUObject-Win64-Shipping.UObjectBase::IsValidLowLevel+4E
UObjectBase::IsValidLowLevel+2B- 48 8D 05 46CD0B00     - lea rax,[FactoryGame-CoreUObject-Win64-Shipping.dll.rdata+5FFD8]
UObjectBase::IsValidLowLevel+32- 41 B9 03000000        - mov r9d,00000003
UObjectBase::IsValidLowLevel+38- 48 89 44 24 20        - mov [rsp+20],rax
UObjectBase::IsValidLowLevel+3D- 4C 8D 05 18F01500     - lea r8,[FactoryGame-CoreUObject-Win64-Shipping.LogUObjectBase+4]
UObjectBase::IsValidLowLevel+44- 33 D2                 - xor edx,edx
UObjectBase::IsValidLowLevel+46- 33 C9                 - xor ecx,ecx
UObjectBase::IsValidLowLevel+48- FF 15 DACE0500        - call qword ptr [FactoryGame-CoreUObject-Win64-Shipping._imp_?Logf_InternalImplFMsgCAXPEBDHAEBVFNameW4TypeELogVerbosityPEB_WZZ]
UObjectBase::IsValidLowLevel+4E- 32 C0                 - xor al,al
UObjectBase::IsValidLowLevel+50- 48 83 C4 38           - add rsp,38
UObjectBase::IsValidLowLevel+54- C3                    - ret 
UObjectBase::IsValidLowLevel+55- 48 8B D1              - mov rdx,rcx
UObjectBase::IsValidLowLevel+58- 48 8D 0D D1F21500     - lea rcx,[FactoryGame-CoreUObject-Win64-Shipping.GUObjectArray]
UObjectBase::IsValidLowLevel+5F- 48 83 C4 38           - add rsp,38
UObjectBase::IsValidLowLevel+63- E9 78FDFFFF           - jmp FactoryGame-CoreUObject-Win64-Shipping.FUObjectArray::IsValid

AOB to GUObjectArray LEA (end of AOB): 48 83 C4 38 C3 48 8B D1 48 8D
AOB works in Satisfactory (4.26.1, modular)
AOB hasn't been confirmed working in any other game (I know of no other modular games to test, don't feel like making my own)
Do not subtract 0x10 from the result for this one

Search for: NULL object
Search for: Object is not registered
}

```

`Internal_Docs/aobs/StaticLoadObject.txt`:

```txt
StaticLoadObject direct scan
In module: CoreUObject
40 55 53 56 57 41 54 41 55 41 56 41 57 48 8D AC 24 58 FD FF FF 48 81 EC A8 03 00 00

StaticLoadObject indirect scan
In function: FObjectAndNameAsStringProxyArchive::operator<<
In module: CoreUObject
E8 ?? ?? ?? ?? 48 89 06 48 8D 4C 24 40 FF 15

Currently in use!
StaticLoadObject indirect scan
In function: FConvertedBlueprintsDependencies::FillUsedAssetsInDynamicClass
In module: CoreUObject
E8 ?? ?? ?? ?? 80 3D ?? ?? ?? ?? ?? 48 89 85 B8 00 00 00

```

`LICENSE`:

```
MIT License

Copyright (c) 2022 Narknon

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`LuaBindings/include/LuaBindings/LuaSetup.hpp`:

```hpp
#ifndef LUAWRAPPERGENERATOR_LUASETUP_HPP
#define LUAWRAPPERGENERATOR_LUASETUP_HPP

#include <atomic>
#include <format>
#include <functional>

#include <LuaBindings/States/MainState/Main.hpp>

namespace RC::LuaBindings
{
static std::unordered_map<std::string, void (*)(lua_State*)> s_state_setup_functions{
    {"MainState", &lua_setup_state_MainState},
};

auto lua_setup_state(lua_State* lua_state, const std::string& state_name) -> void
{
    if (auto it = s_state_setup_functions.find(state_name); it != s_state_setup_functions.end())
    {
        it->second(lua_state);
    }
    else
    {
        luaL_error(lua_state, std::format("Was unable to find lua state type '{}'", state_name).c_str());
    }
}
} // RC::LuaBindings

#endif //LUAWRAPPERGENERATOR_LUASETUP_HPP

```

`Readme.md`:

```md
# Re-Host of Unreal Engine 4/5 Scripting System

## The original creator no longer wishes to be involved with or connected to this project, or to receive messages related to it. Please respect their wishes, and avoid using their past username(s) in connection with this project. It is being reuploaded as open source with their permission.  Support for/updates to this project will now be very limited.


## Targeting UE Versions: From 4.12 To 5.0

The goal of UE4SS is not to be a plug-n-play solution that always works with every game.  
The goal is to have an underlying system that works for most games.  
You may need to update AOBs on your own, and there's a guide for that below.  

## Links

  [Full installation guide](https://github.com/UE4SS-RE/RE-UE4SS/wiki/FullInstallationGuide)
  
  [Fixing compatibility problems](https://github.com/UE4SS-RE/RE-UE4SS/wiki/FixingBrokenAOBs) 
  
  [Lua API - Overview](https://github.com/UE4SS-RE/RE-UE4SS/wiki/Lua-API)
  
  [Generating UHT compatible headers](https://github.com/UE4SS-RE/RE-UE4SS/wiki/Generating-UHT-compatible-headers)
  
  [Custom Game Configs](https://github.com/UE4SS-RE/RE-UE4SS/wiki/CustomGameConfigs)


## Build requirements

- A computer running Windows.
  - Linux support might happen at some point but not soon.
- A version of MSVC that supports C++20, including std::format.
  - Visual Studio 2019 (recent versions), and Visual Studio 2022 will work.
  - More compilers will hopefully be supported in the future.


## Build instructions

1. Clone the repo.
2. Execute this command: `git submodule update --init --recursive`  
    Do not use the `--remote` option because that will force third-party dependencies to update to the latest commit, and that can break things.
    You will need your github account to be linked to an Epic games account to pull the Unreal pseudo code submodule.
3. There are three different ways you can build UE4SS.  
    1. Execute this command: `build_auto.bat <BuildMode> <Target>`, example: `build_auto.bat Release ue4ss`  
        Valid build modes are `Release` and `Debug`, and valid targets are `ue4ss` and `xinput1_3`.  
        Parallel compilation is enabled for this build method.
    2. Open the root UE4SS directory in CLion, select `ue4ss` or `xinput1_3` from the target list and hit the build button.  
        Parallel compilation is **NOT** enabled for this build method.
    3. Execute `VS_Solution/generate_vs_solution.bat` to generate a Visual Studio solution file.  
        Open the solution with Visual Studio 2019 or Visual Studio 2022, select the build type and build the `ue4ss` project.  
        Parallel compilation is enabled for this build method.
    
## Updating dependencies

If you want to update dependencies, you do so one of three ways:
1. You can execute `remote_update_first_party_submodules.bat` to update all first-party dependencies.  
2. You can also choose to update dependencies one by one, by executing `git submodule update --init --recursive vendor/<RepoOwner>/<Repo>`.  
    Remember to not use the `--remote` option unless you actually want to update to the latest commit.  
3. If you would rather pick a specific commit or branch to update a dependency to then `cd` into the submodule directory for that dependency and execute `git checkout <branch name or commit>`.

Note that you should also commit & push the submodules that you've updated if the reason why you updated was not because someone else pushed an update, and you're just catching up to it.

## Credits

- **Original Creator** The original creator no longer wishes to be involved in or connected to  this project.  Please respect their wishes, and avoid using their past usernames in connection with this project.
- **Archengius**
  - UHT compatible header generator
- **CasualGamer**
  - Injector code & aob scanner is heavily based on his work, 90% of that code is his.
- **SunBeam**
  - Extra signature for function 'GetFullName' for UE4.25.
  - Regex to check for proper signature format when loaded from ini.
  - Lots and lots of work on signatures
- **tomsa**
  - const char* to vector\<int> converter
    - tomsa: Idea & most of the code
    - Original Creator: Nibblet support
- **boop** / **usize**
  - New UFunction hook method
- **Narknon**
  - Certain features and maintenance/rehosting of the project
- **DeadMor0z**
  - Certain features and Lua updates/maintenance
- **DmgVol**
  - Inspiration for map dumper


## Thanks to everyone who helped with testing

- GreenHouse
- Otis_Inf
- SunBeam
- Motoson
- hooter
- Synopis

```

`Staging/Changelog_2.0.txt`:

```txt
## NEW:

Live View Debugger - Allows runtime viewing of Objects in GObject with live updates to property and variable values.
Enable the Debug log in UE4SS-settings.ini to activate.
```[Debug]
; Whether to enable the external UE4SS debug console.
ConsoleEnabled = 1
GuiConsoleEnabled = 1
GuiConsoleVisible = 1```

Watches - Allows watching of values in an object instance. Can print to a new tab or print to a file with timestamps.
Dumpers - NEW: Static Mesh dumper and All Actor dumper - Dumps positions of all loaded SM or all actors to a CSV file which can be loaded in UE to recreate a map or spawn actors at specific locations.  Very early feature, will allow for more properties to be dumped over time.

### Note: Actor dumper requires a specific dll to be compiled correctly for <=4.19 and =>4.20 for now.  Download the version for the engine version you will be working on if you'd like to use the dumper.
Download v2.0-UE419 for 4.19 and below.
Download v2.0-UE420 for 4.20 and above.

## Lua:
* The global function "RegisterHook" now returns two integers that represent pre & post callback ids.
  These ids can be passed to the "UnregisterHook" global function to unhook a function.
* Note that the callbacks for "RegisterHook" and "NotifyOnNewObject" execute in the game thread so the code in these callbacks needs to be careful when accessing Lua variables outside the callbacks.
* Added the global function "UnregisterHook", see API.txt for more information.
* Added better support for TArray. Now it can be used as out parameter in functions correctly.

## Fixes
* Fixed a rare crash that could occur when interacting with parameters in callbacks passed to "RegisterHook".
* Fixed a bug which prohibited using variables, containing unreal objects created in other thread (in main from game and vise versa)
* Fixed most issues with GC of cirtain Lau functions.
```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_12_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bCppStructOpsFromBaseClass = 0x8C
bPrepareCppStructOpsCompleted = 0x8D

[UWorld]
AudioDeviceHandle = 0x858
AudioTimeSeconds = 0x870
BuildStreamingDataTimer = 0x4D0
CommittedPersistentLevelName = 0x8D0
DebugDrawTraceTag = 0x838
DeltaTimeSeconds = 0x874
ExtraReferencedObjects = 0x70
FullPurgeTriggered = 0x824
LastTimeUnbuiltLightingWasEncountered = 0x860
NextSwitchCountdown = 0x8B8
NextURL = 0x8A8
NumLightingUnbuiltObjects = 0x8D8
PauseDelay = 0x878
PerModuleDataObjects = 0x80
PlayerNum = 0x81C
PreparingLevelNames = 0x8C0
RealTimeSeconds = 0x86C
StreamingLevelsPrefix = 0xA0
StreamingVolumeUpdateDelay = 0x828
TimeSeconds = 0x868
TimeSinceLastPendingKillPurge = 0x820
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x8DC
bAggressiveLOD = 0x8DC
bAllowAudioPlayback = 0x8DC
bAreConstraintsDirty = 0x8DC
bBegunPlay = 0x8DC
bCreateRenderStateForHiddenComponents = 0x834
bDebugFrameStepExecution = 0x8DC
bDebugPauseExecution = 0x8DC
bDoDelayedUpdateCullDistanceVolumes = 0x82F
bDropDetail = 0x8DC
bHack_Force_UsesGameHiddenFlags_True = 0x831
bInTick = 0x720
bIsBuilt = 0x721
bIsDefaultLevel = 0x8DC
bIsLevelStreamingFrozen = 0x82C
bIsRunningConstructionScript = 0x832
bIsTearingDown = 0x8DC
bIsWorldInitialized = 0x826
bKismetScriptError = 0x8DC
bMatchStarted = 0x8DC
bOriginOffsetThisFrame = 0x894
bPlayersOnly = 0x8DC
bPlayersOnlyPending = 0x8DC
bPostTickComponentUpdate = 0x818
bRequestedBlockOnAsyncLoading = 0x8DC
bRequiresHitProxies = 0x358
bShouldDelayGarbageCollect = 0x825
bShouldForceUnloadStreamingLevels = 0x82D
bShouldForceVisibleStreamingLevels = 0x82E
bShouldSimulatePhysics = 0x833
bStartup = 0x8DC
bStreamingDataDirty = 0x4C8
bTickNewlySpawned = 0x722
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[UClass]
ClassAddReferencedObjects = 0xA0
ClassCastFlags = 0xB0
ClassConfigName = 0xC8
ClassConstructor = 0x90
ClassDefaultObject = 0xF8
ClassFlags = 0xAC
ClassGeneratedBy = 0xC0
ClassUnique = 0xA8
ClassVTableHelperCtorCaller = 0x98
ClassWithin = 0xB8
Interfaces = 0x1F0
NetFields = 0xE8
bCooked = 0xD0

[UEnum]
CppForm = 0x50
CppType = 0x30
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_13_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bCppStructOpsFromBaseClass = 0x8C
bPrepareCppStructOpsCompleted = 0x8D

[UWorld]
AudioDeviceHandle = 0x8B0
AudioTimeSeconds = 0x8C8
BuildStreamingDataTimer = 0x4E0
CommittedPersistentLevelName = 0x928
DebugDrawTraceTag = 0x848
DeltaTimeSeconds = 0x8CC
ExtraReferencedObjects = 0x70
FullPurgeTriggered = 0x834
LastTimeUnbuiltLightingWasEncountered = 0x8B8
NextSwitchCountdown = 0x910
NextURL = 0x900
NumLightingUnbuiltObjects = 0x930
PauseDelay = 0x8D0
PerModuleDataObjects = 0x80
PlayerNum = 0x82C
PreparingLevelNames = 0x918
RealTimeSeconds = 0x8C4
StreamingLevelsPrefix = 0xA0
StreamingVolumeUpdateDelay = 0x838
TimeSeconds = 0x8C0
TimeSinceLastPendingKillPurge = 0x830
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x934
bAggressiveLOD = 0x934
bAllowAudioPlayback = 0x934
bAreConstraintsDirty = 0x934
bBegunPlay = 0x934
bDebugFrameStepExecution = 0x934
bDebugPauseExecution = 0x934
bDoDelayedUpdateCullDistanceVolumes = 0x83F
bDropDetail = 0x934
bHack_Force_UsesGameHiddenFlags_True = 0x841
bInTick = 0x730
bIsBuilt = 0x731
bIsDefaultLevel = 0x934
bIsLevelStreamingFrozen = 0x83C
bIsRunningConstructionScript = 0x842
bIsTearingDown = 0x934
bIsWorldInitialized = 0x836
bKismetScriptError = 0x934
bMatchStarted = 0x934
bOriginOffsetThisFrame = 0x8EC
bPlayersOnly = 0x934
bPlayersOnlyPending = 0x934
bPostTickComponentUpdate = 0x828
bRequestedBlockOnAsyncLoading = 0x934
bRequiresHitProxies = 0x368
bShouldDelayGarbageCollect = 0x835
bShouldForceUnloadStreamingLevels = 0x83D
bShouldForceVisibleStreamingLevels = 0x83E
bShouldSimulatePhysics = 0x843
bShouldTick = 0x369
bStartup = 0x934
bStreamingDataDirty = 0x4D8
bTickNewlySpawned = 0x732
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xA0
ClassCastFlags = 0xB0
ClassConfigName = 0xC8
ClassConstructor = 0x90
ClassDefaultObject = 0xF8
ClassFlags = 0xAC
ClassGeneratedBy = 0xC0
ClassUnique = 0xA8
ClassVTableHelperCtorCaller = 0x98
ClassWithin = 0xB8
Interfaces = 0x1F0
NetFields = 0xE8
bCooked = 0xD0

[UEnum]
CppForm = 0x50
CppType = 0x30
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_14_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
AudioDeviceHandle = 0x8E8
AudioTimeSeconds = 0x904
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x968
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x908
ExtraReferencedObjects = 0x68
FullPurgeTriggered = 0x86C
LastTimeUnbuiltLightingWasEncountered = 0x8F0
NextSwitchCountdown = 0x950
NextURL = 0x940
NumInvalidReflectionCaptureComponents = 0x974
NumLightingUnbuiltObjects = 0x970
NumTextureStreamingDirtyResources = 0x97C
NumTextureStreamingUnbuiltComponents = 0x978
PauseDelay = 0x90C
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x958
RealTimeSeconds = 0x900
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x870
TimeSeconds = 0x8F8
TimeSinceLastPendingKillPurge = 0x868
UnpausedTimeSeconds = 0x8FC
ViewLocationsRenderedLastFrame = 0xC8
bActorsInitialized = 0x980
bAggressiveLOD = 0x980
bAllowAudioPlayback = 0x980
bAreConstraintsDirty = 0x980
bBegunPlay = 0x980
bDebugFrameStepExecution = 0x980
bDebugPauseExecution = 0x980
bDoDelayedUpdateCullDistanceVolumes = 0x877
bDropDetail = 0x980
bHack_Force_UsesGameHiddenFlags_True = 0x87C
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x980
bIsDefaultLevel = 0x980
bIsLevelStreamingFrozen = 0x874
bIsRunningConstructionScript = 0x87D
bIsTearingDown = 0x980
bIsWorldInitialized = 0x86E
bKismetScriptError = 0x980
bMatchStarted = 0x980
bOriginOffsetThisFrame = 0x928
bPlayersOnly = 0x980
bPlayersOnlyPending = 0x980
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x980
bRequiresHitProxies = 0x380
bShouldDelayGarbageCollect = 0x86D
bShouldForceUnloadStreamingLevels = 0x875
bShouldForceVisibleStreamingLevels = 0x876
bShouldSimulatePhysics = 0x87E
bShouldTick = 0x381
bStartup = 0x980
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xD8
bWorldWasLoadedThisTick = 0xD8

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0x100
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1F8
NetFields = 0xF0
bCooked = 0xD8

[UEnum]
CppForm = 0x50
CppType = 0x30
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_15_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
AudioDeviceHandle = 0x8E8
AudioTimeSeconds = 0x904
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x970
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x908
ExtraReferencedObjects = 0x68
FullPurgeTriggered = 0x86C
LastTimeUnbuiltLightingWasEncountered = 0x8F0
NextSwitchCountdown = 0x958
NextURL = 0x948
NumInvalidReflectionCaptureComponents = 0x97C
NumLightingUnbuiltObjects = 0x978
NumTextureStreamingDirtyResources = 0x984
NumTextureStreamingUnbuiltComponents = 0x980
OriginOffsetThisFrame = 0x928
PauseDelay = 0x90C
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x960
RealTimeSeconds = 0x900
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x870
TimeSeconds = 0x8F8
TimeSinceLastPendingKillPurge = 0x868
UnpausedTimeSeconds = 0x8FC
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x988
bAggressiveLOD = 0x988
bAllowAudioPlayback = 0x988
bAreConstraintsDirty = 0x988
bBegunPlay = 0x988
bDebugFrameStepExecution = 0x988
bDebugPauseExecution = 0x988
bDoDelayedUpdateCullDistanceVolumes = 0x877
bDropDetail = 0x988
bHack_Force_UsesGameHiddenFlags_True = 0x87C
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x988
bIsDefaultLevel = 0x988
bIsLevelStreamingFrozen = 0x874
bIsRunningConstructionScript = 0x87D
bIsTearingDown = 0x988
bIsWorldInitialized = 0x86E
bKismetScriptError = 0x988
bMatchStarted = 0x988
bPlayersOnly = 0x988
bPlayersOnlyPending = 0x988
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x988
bRequiresHitProxies = 0x388
bShouldDelayGarbageCollect = 0x86D
bShouldForceUnloadStreamingLevels = 0x875
bShouldForceVisibleStreamingLevels = 0x876
bShouldSimulatePhysics = 0x87E
bShouldTick = 0x389
bStartup = 0x988
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0x100
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1F8
NetFields = 0xF0
bCooked = 0xD8

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_16_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
AudioDeviceHandle = 0x8E8
AudioTimeSeconds = 0x904
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x970
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x908
ExtraReferencedObjects = 0x68
FullPurgeTriggered = 0x86C
LastTimeUnbuiltLightingWasEncountered = 0x8F0
NextSwitchCountdown = 0x958
NextURL = 0x948
NumInvalidReflectionCaptureComponents = 0x97C
NumLightingUnbuiltObjects = 0x978
NumTextureStreamingDirtyResources = 0x984
NumTextureStreamingUnbuiltComponents = 0x980
OriginOffsetThisFrame = 0x928
PauseDelay = 0x90C
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x960
RealTimeSeconds = 0x900
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x870
TimeSeconds = 0x8F8
TimeSinceLastPendingKillPurge = 0x868
UnpausedTimeSeconds = 0x8FC
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x988
bAggressiveLOD = 0x988
bAllowAudioPlayback = 0x988
bAreConstraintsDirty = 0x988
bBegunPlay = 0x988
bDebugFrameStepExecution = 0x988
bDebugPauseExecution = 0x988
bDoDelayedUpdateCullDistanceVolumes = 0x877
bDropDetail = 0x988
bHack_Force_UsesGameHiddenFlags_True = 0x87C
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x988
bIsDefaultLevel = 0x988
bIsLevelStreamingFrozen = 0x874
bIsRunningConstructionScript = 0x87D
bIsTearingDown = 0x988
bIsWorldInitialized = 0x86E
bKismetScriptError = 0x988
bMatchStarted = 0x988
bPlayersOnly = 0x988
bPlayersOnlyPending = 0x988
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x988
bRequiresHitProxies = 0x388
bShouldDelayGarbageCollect = 0x86D
bShouldForceUnloadStreamingLevels = 0x875
bShouldForceVisibleStreamingLevels = 0x876
bShouldSimulatePhysics = 0x87E
bShouldTick = 0x389
bStartup = 0x988
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0x100
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x200
NetFields = 0xF0
bCooked = 0xD8

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_17_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x68
ElementSize = 0x34
NextRef = 0x60
Offset_Internal = 0x50
PostConstructLinkNext = 0x70
PropertyFlags = 0x38
PropertyLinkNext = 0x58
RepIndex = 0x40
RepNotifyFunc = 0x48

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8E
ParmsSize = 0x90
RPCId = 0x94
RPCResponseId = 0x96
RepOffset = 0x8C
ReturnValueOffset = 0x92

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x78

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
AudioDeviceHandle = 0x8F0
AudioTimeSeconds = 0x90C
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x978
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x910
ExtraReferencedObjects = 0x68
FullPurgeTriggered = 0x86C
LastTimeUnbuiltLightingWasEncountered = 0x8F8
NextSwitchCountdown = 0x960
NextURL = 0x950
NumInvalidReflectionCaptureComponents = 0x984
NumLightingUnbuiltObjects = 0x980
NumTextureStreamingDirtyResources = 0x98C
NumTextureStreamingUnbuiltComponents = 0x988
OriginOffsetThisFrame = 0x930
PauseDelay = 0x914
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x968
RealTimeSeconds = 0x908
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x870
TimeSeconds = 0x900
TimeSinceLastPendingKillPurge = 0x868
UnpausedTimeSeconds = 0x904
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x990
bAggressiveLOD = 0x990
bAllowAudioPlayback = 0x990
bAreConstraintsDirty = 0x990
bBegunPlay = 0x990
bDebugDrawAllTraceTags = 0x888
bDebugFrameStepExecution = 0x990
bDebugPauseExecution = 0x990
bDoDelayedUpdateCullDistanceVolumes = 0x877
bDropDetail = 0x990
bHack_Force_UsesGameHiddenFlags_True = 0x87C
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x990
bIsDefaultLevel = 0x990
bIsLevelStreamingFrozen = 0x874
bIsRunningConstructionScript = 0x87D
bIsTearingDown = 0x990
bIsWorldInitialized = 0x86E
bKismetScriptError = 0x990
bMatchStarted = 0x990
bPlayersOnly = 0x990
bPlayersOnlyPending = 0x990
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x990
bRequiresHitProxies = 0x388
bShouldDelayGarbageCollect = 0x86D
bShouldForceUnloadStreamingLevels = 0x875
bShouldForceVisibleStreamingLevels = 0x876
bShouldSimulatePhysics = 0x87E
bShouldTick = 0x389
bStartup = 0x990
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x78

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0x100
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x200
NetFields = 0xF0
bCooked = 0xD8

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_18_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8C
ParmsSize = 0x8E
RPCId = 0x92
RPCResponseId = 0x94
ReturnValueOffset = 0x90

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
ActiveLevelCollectionIndex = 0x130
AudioDeviceHandle = 0x8F0
AudioTimeSeconds = 0x90C
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x978
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x910
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x8F8
NextSwitchCountdown = 0x960
NextURL = 0x950
NumInvalidReflectionCaptureComponents = 0x984
NumLightingUnbuiltObjects = 0x980
NumTextureStreamingDirtyResources = 0x98C
NumTextureStreamingUnbuiltComponents = 0x988
OriginOffsetThisFrame = 0x930
PauseDelay = 0x914
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x968
RealTimeSeconds = 0x908
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x86C
TimeSeconds = 0x900
UnpausedTimeSeconds = 0x904
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x990
bAggressiveLOD = 0x990
bAllowAudioPlayback = 0x990
bAreConstraintsDirty = 0x990
bBegunPlay = 0x990
bDebugDrawAllTraceTags = 0x888
bDebugFrameStepExecution = 0x990
bDebugPauseExecution = 0x990
bDoDelayedUpdateCullDistanceVolumes = 0x873
bDropDetail = 0x990
bHack_Force_UsesGameHiddenFlags_True = 0x878
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x990
bIsDefaultLevel = 0x990
bIsLevelStreamingFrozen = 0x870
bIsRunningConstructionScript = 0x879
bIsTearingDown = 0x990
bIsWorldInitialized = 0x868
bKismetScriptError = 0x990
bMatchStarted = 0x990
bPlayersOnly = 0x990
bPlayersOnlyPending = 0x990
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x990
bRequiresHitProxies = 0x388
bShouldForceUnloadStreamingLevels = 0x871
bShouldForceVisibleStreamingLevels = 0x872
bShouldSimulatePhysics = 0x87A
bShouldTick = 0x389
bStartup = 0x990
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1A0
NetFields = 0xE8
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_19_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8C
ParmsSize = 0x8E
RPCId = 0x92
RPCResponseId = 0x94
ReturnValueOffset = 0x90

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
ActiveLevelCollectionIndex = 0x130
AudioDeviceHandle = 0x8F0
AudioTimeSeconds = 0x90C
BuildStreamingDataTimer = 0x500
CommittedPersistentLevelName = 0x978
DebugDrawTraceTag = 0x880
DeltaTimeSeconds = 0x910
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x8F8
NextSwitchCountdown = 0x960
NextURL = 0x950
NumLightingUnbuiltObjects = 0x980
NumTextureStreamingDirtyResources = 0x98C
NumTextureStreamingUnbuiltComponents = 0x988
NumUnbuiltReflectionCaptures = 0x984
OriginOffsetThisFrame = 0x930
PauseDelay = 0x914
PerModuleDataObjects = 0x78
PlayerNum = 0x864
PreparingLevelNames = 0x968
RealTimeSeconds = 0x908
StreamingLevelsPrefix = 0x98
StreamingVolumeUpdateDelay = 0x86C
TimeSeconds = 0x900
UnpausedTimeSeconds = 0x904
ViewLocationsRenderedLastFrame = 0xD0
bActorsInitialized = 0x990
bAggressiveLOD = 0x990
bAllowAudioPlayback = 0x990
bAreConstraintsDirty = 0x990
bBegunPlay = 0x990
bDebugDrawAllTraceTags = 0x888
bDebugFrameStepExecution = 0x990
bDebugPauseExecution = 0x990
bDoDelayedUpdateCullDistanceVolumes = 0x873
bDropDetail = 0x990
bHack_Force_UsesGameHiddenFlags_True = 0x878
bInTick = 0x750
bIsBuilt = 0x751
bIsCameraMoveableWhenPaused = 0x990
bIsDefaultLevel = 0x990
bIsLevelStreamingFrozen = 0x870
bIsRunningConstructionScript = 0x879
bIsTearingDown = 0x990
bIsWorldInitialized = 0x868
bKismetScriptError = 0x990
bMatchStarted = 0x990
bPlayersOnly = 0x990
bPlayersOnlyPending = 0x990
bPostTickComponentUpdate = 0x860
bRequestedBlockOnAsyncLoading = 0x990
bRequiresHitProxies = 0x388
bShouldForceUnloadStreamingLevels = 0x871
bShouldForceVisibleStreamingLevels = 0x872
bShouldSimulatePhysics = 0x87A
bShouldTick = 0x389
bStartup = 0x990
bStreamingDataDirty = 0x4F8
bTickNewlySpawned = 0x752
bTriggerPostLoadMap = 0xE0
bWorldWasLoadedThisTick = 0xE0

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassCastFlags = 0xB8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1A0
NetFields = 0xE8
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_20_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8C
ParmsSize = 0x8E
RPCId = 0x92
RPCResponseId = 0x94
ReturnValueOffset = 0x90

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
ActiveLevelCollectionIndex = 0x180
AudioDeviceHandle = 0x780
AudioTimeSeconds = 0x79C
BuildStreamingDataTimer = 0x4F8
CommittedPersistentLevelName = 0x808
DebugDrawTraceTag = 0x710
DeltaTimeSeconds = 0x7A0
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x788
NextSwitchCountdown = 0x7F0
NextURL = 0x7E0
NumLightingUnbuiltObjects = 0x810
NumTextureStreamingDirtyResources = 0x81C
NumTextureStreamingUnbuiltComponents = 0x818
NumUnbuiltReflectionCaptures = 0x814
OriginOffsetThisFrame = 0x7C0
PauseDelay = 0x7A4
PerModuleDataObjects = 0x78
PlayerNum = 0x6F4
PreparingLevelNames = 0x7F8
RealTimeSeconds = 0x798
StreamingLevelsPrefix = 0xE8
StreamingVolumeUpdateDelay = 0x6FC
TimeSeconds = 0x790
UnpausedTimeSeconds = 0x794
ViewLocationsRenderedLastFrame = 0x120
bActorsInitialized = 0x820
bAggressiveLOD = 0x820
bAllowAudioPlayback = 0x820
bAreConstraintsDirty = 0x820
bBegunPlay = 0x820
bDebugDrawAllTraceTags = 0x718
bDebugFrameStepExecution = 0x820
bDebugPauseExecution = 0x820
bDoDelayedUpdateCullDistanceVolumes = 0x704
bDropDetail = 0x820
bHack_Force_UsesGameHiddenFlags_True = 0x70C
bInTick = 0x5E0
bIsBuilt = 0x5E1
bIsCameraMoveableWhenPaused = 0x820
bIsDefaultLevel = 0x820
bIsLevelStreamingFrozen = 0x700
bIsRunningConstructionScript = 0x70D
bIsTearingDown = 0x820
bIsWorldInitialized = 0x6F8
bKismetScriptError = 0x820
bMatchStarted = 0x820
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x703
bPlayersOnly = 0x820
bPlayersOnlyPending = 0x820
bPostTickComponentUpdate = 0x6F0
bRequestedBlockOnAsyncLoading = 0x820
bRequiresHitProxies = 0x3D8
bShouldForceUnloadStreamingLevels = 0x701
bShouldForceVisibleStreamingLevels = 0x702
bShouldSimulatePhysics = 0x70E
bShouldTick = 0x3D9
bStartup = 0x820
bStreamingDataDirty = 0x4F0
bTickNewlySpawned = 0x5E2
bTriggerPostLoadMap = 0x130
bWorldWasLoadedThisTick = 0x130

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1A0
NetFields = 0xE8
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_21_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xA8
EventGraphFunction = 0xA0
FirstPropertyToInit = 0x98
Func = 0xB0
FunctionFlags = 0x88
NumParms = 0x8C
ParmsSize = 0x8E
RPCId = 0x92
RPCResponseId = 0x94
ReturnValueOffset = 0x90

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x38
DestructorLink = 0x68
MinAlignment = 0x44
PostConstructLink = 0x70
PropertiesSize = 0x40
PropertyLink = 0x58
RefLink = 0x60
Script = 0x48
ScriptObjectReferences = 0x78
SuperStruct = 0x30

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0x90
StructFlags = 0x88
bPrepareCppStructOpsCompleted = 0x8C

[UWorld]
ActiveLevelCollectionIndex = 0x180
AudioDeviceHandle = 0x748
AudioTimeSeconds = 0x764
BuildStreamingDataTimer = 0x4A8
CommittedPersistentLevelName = 0x7D0
DebugDrawTraceTag = 0x6D8
DeltaTimeSeconds = 0x768
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x750
NextSwitchCountdown = 0x7B8
NextURL = 0x7A8
NumLightingUnbuiltObjects = 0x7D8
NumTextureStreamingDirtyResources = 0x7E4
NumTextureStreamingUnbuiltComponents = 0x7E0
NumUnbuiltReflectionCaptures = 0x7DC
OriginOffsetThisFrame = 0x788
PauseDelay = 0x76C
PerModuleDataObjects = 0x78
PlayerNum = 0x6BC
PreparingLevelNames = 0x7C0
RealTimeSeconds = 0x760
StreamingLevelsPrefix = 0xE8
StreamingVolumeUpdateDelay = 0x6C4
TimeSeconds = 0x758
UnpausedTimeSeconds = 0x75C
ViewLocationsRenderedLastFrame = 0x120
bActorsInitialized = 0x7E8
bAggressiveLOD = 0x7E8
bAllowAudioPlayback = 0x7E8
bAreConstraintsDirty = 0x7E8
bBegunPlay = 0x7E8
bCleanedUpWorld = 0x7E8
bDebugDrawAllTraceTags = 0x6E0
bDebugFrameStepExecution = 0x7E8
bDebugPauseExecution = 0x7E8
bDoDelayedUpdateCullDistanceVolumes = 0x6CC
bDropDetail = 0x7E8
bHack_Force_UsesGameHiddenFlags_True = 0x6D4
bInTick = 0x5A8
bIsBuilt = 0x5A9
bIsCameraMoveableWhenPaused = 0x7E8
bIsDefaultLevel = 0x7E8
bIsLevelStreamingFrozen = 0x6C8
bIsRunningConstructionScript = 0x6D5
bIsTearingDown = 0x7E8
bIsWorldInitialized = 0x6C0
bKismetScriptError = 0x7E8
bMarkedObjectsPendingKill = 0x7E8
bMatchStarted = 0x7E8
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x6CB
bPlayersOnly = 0x7E8
bPlayersOnlyPending = 0x7E8
bPostTickComponentUpdate = 0x6B8
bRequestedBlockOnAsyncLoading = 0x7E8
bRequiresHitProxies = 0x3D8
bShouldForceUnloadStreamingLevels = 0x6C9
bShouldForceVisibleStreamingLevels = 0x6CA
bShouldSimulatePhysics = 0x6D6
bShouldTick = 0x3D9
bStartup = 0x7E8
bStreamingDataDirty = 0x4A0
bTickNewlySpawned = 0x5AA
bTriggerPostLoadMap = 0x130
bWorldWasLoadedThisTick = 0x130

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassConfigName = 0xD8
ClassConstructor = 0x98
ClassDefaultObject = 0x100
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1B0
NetFields = 0xF0
UberGraphFramePointerProperty = 0xD0
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_22_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xB8
EventGraphFunction = 0xB0
FirstPropertyToInit = 0xA8
Func = 0xC0
FunctionFlags = 0x98
NumParms = 0x9C
ParmsSize = 0x9E
RPCId = 0xA2
RPCResponseId = 0xA4
ReturnValueOffset = 0xA0

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x48
DestructorLink = 0x78
MinAlignment = 0x54
PostConstructLink = 0x80
PropertiesSize = 0x50
PropertyLink = 0x68
RefLink = 0x70
Script = 0x58
ScriptObjectReferences = 0x88
SuperStruct = 0x40

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0xA0
StructFlags = 0x98
bPrepareCppStructOpsCompleted = 0x9C

[UWorld]
ActiveLevelCollectionIndex = 0x158
AudioDeviceHandle = 0x15C
AudioTimeSeconds = 0x534
BuildStreamingDataTimer = 0x350
CommittedPersistentLevelName = 0x598
DeltaTimeSeconds = 0x538
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x520
NextSwitchCountdown = 0x564
NextURL = 0x578
OriginOffsetThisFrame = 0x558
PauseDelay = 0x53C
PerModuleDataObjects = 0x78
PlayerNum = 0x4F8
PreparingLevelNames = 0x588
RealTimeSeconds = 0x530
StreamingLevelsPrefix = 0xC0
StreamingVolumeUpdateDelay = 0x4FC
TimeSeconds = 0x528
UnpausedTimeSeconds = 0x52C
ViewLocationsRenderedLastFrame = 0xF8
bActorsInitialized = 0x10C
bAggressiveLOD = 0x10C
bAllowAudioPlayback = 0x10E
bAreConstraintsDirty = 0x10E
bBegunPlay = 0x10D
bCleanedUpWorld = 0x5A0
bDebugPauseExecution = 0x10D
bDoDelayedUpdateCullDistanceVolumes = 0x10C
bDropDetail = 0x10C
bInTick = 0x10B
bIsBuilt = 0x10B
bIsCameraMoveableWhenPaused = 0x10E
bIsDefaultLevel = 0x10C
bIsLevelStreamingFrozen = 0x10B
bIsRunningConstructionScript = 0x10C
bIsTearingDown = 0x10D
bIsWorldInitialized = 0x10B
bKismetScriptError = 0x10D
bMarkedObjectsPendingKill = 0x5A0
bMatchStarted = 0x10D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x10F
bPlayersOnly = 0x10D
bPlayersOnlyPending = 0x10D
bPostTickComponentUpdate = 0x10B
bRequestedBlockOnAsyncLoading = 0x10C
bRequiresHitProxies = 0x10E
bShouldForceUnloadStreamingLevels = 0x10E
bShouldForceVisibleStreamingLevels = 0x10E
bShouldSimulatePhysics = 0x10C
bShouldTick = 0x10E
bStartup = 0x10D
bStreamingDataDirty = 0x10E
bTickNewlySpawned = 0x10B
bTriggerPostLoadMap = 0x10B
bWorldWasLoadedThisTick = 0x10B

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1A8
NetFields = 0xE8
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_23_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xB8
EventGraphFunction = 0xB0
FirstPropertyToInit = 0xA8
Func = 0xC0
FunctionFlags = 0x98
NumParms = 0x9C
ParmsSize = 0x9E
RPCId = 0xA2
RPCResponseId = 0xA4
ReturnValueOffset = 0xA0

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x48
DestructorLink = 0x78
MinAlignment = 0x54
PostConstructLink = 0x80
PropertiesSize = 0x50
PropertyLink = 0x68
RefLink = 0x70
Script = 0x58
ScriptObjectReferences = 0x88
SuperStruct = 0x40

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0xA0
StructFlags = 0x98
bPrepareCppStructOpsCompleted = 0x9C

[UWorld]
ActiveLevelCollectionIndex = 0x168
AudioDeviceHandle = 0x16C
AudioTimeSeconds = 0x534
BuildStreamingDataTimer = 0x350
CommittedPersistentLevelName = 0x598
DeltaTimeSeconds = 0x538
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x520
LevelSequenceActors = 0x88
NextSwitchCountdown = 0x564
NextURL = 0x578
NumStreamingLevelsBeingLoaded = 0x572
OriginOffsetThisFrame = 0x558
PauseDelay = 0x53C
PerModuleDataObjects = 0x78
PlayerNum = 0x4F8
PreparingLevelNames = 0x588
RealTimeSeconds = 0x530
StreamingLevelsPrefix = 0xD0
StreamingVolumeUpdateDelay = 0x4FC
TimeSeconds = 0x528
UnpausedTimeSeconds = 0x52C
ViewLocationsRenderedLastFrame = 0x108
bActorsInitialized = 0x11C
bAggressiveLOD = 0x11C
bAllowAudioPlayback = 0x11E
bAreConstraintsDirty = 0x11E
bBegunPlay = 0x11D
bCleanedUpWorld = 0x5A0
bDebugPauseExecution = 0x11D
bDoDelayedUpdateCullDistanceVolumes = 0x11C
bDropDetail = 0x11C
bInTick = 0x11B
bIsBuilt = 0x11B
bIsCameraMoveableWhenPaused = 0x11E
bIsDefaultLevel = 0x11C
bIsLevelStreamingFrozen = 0x11B
bIsRunningConstructionScript = 0x11C
bIsTearingDown = 0x11D
bIsWorldInitialized = 0x11B
bKismetScriptError = 0x11D
bMarkedObjectsPendingKill = 0x5A0
bMatchStarted = 0x11D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x11F
bPlayersOnly = 0x11D
bPlayersOnlyPending = 0x11D
bPostTickComponentUpdate = 0x11B
bRequestedBlockOnAsyncLoading = 0x11C
bRequiresHitProxies = 0x11E
bShouldForceUnloadStreamingLevels = 0x11E
bShouldForceVisibleStreamingLevels = 0x11E
bShouldSimulatePhysics = 0x11C
bShouldTick = 0x11E
bStartup = 0x11D
bStreamingDataDirty = 0x11E
bTickNewlySpawned = 0x11B
bTriggerPostLoadMap = 0x11B
bWorldWasLoadedThisTick = 0x11B

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1A8
NetFields = 0xE8
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_24_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FProperty]
ArrayDim = 0x30
DestructorLinkNext = 0x60
ElementSize = 0x34
NextRef = 0x58
Offset_Internal = 0x44
PostConstructLinkNext = 0x68
PropertyFlags = 0x38
PropertyLinkNext = 0x50
RepIndex = 0x40
RepNotifyFunc = 0x48

[FSoftClassProperty]
MetaClass = 0x78

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[UFunction]
EventGraphCallOffset = 0xB8
EventGraphFunction = 0xB0
FirstPropertyToInit = 0xA8
Func = 0xC0
FunctionFlags = 0x98
NumParms = 0x9C
ParmsSize = 0x9E
RPCId = 0xA2
RPCResponseId = 0xA4
ReturnValueOffset = 0xA0

[UField]
Next = 0x28

[FEnumProperty]
Enum = 0x78
UnderlyingProp = 0x70

[UStruct]
Children = 0x48
DestructorLink = 0x78
MinAlignment = 0x54
PostConstructLink = 0x80
PropertiesSize = 0x50
PropertyLink = 0x68
RefLink = 0x70
Script = 0x58
ScriptObjectReferences = 0x88
SuperStruct = 0x40

[FDelegateProperty]
SignatureFunction = 0x70

[FMulticastDelegateProperty]
SignatureFunction = 0x70

[FObjectPropertyBase]
PropertyClass = 0x70

[FBoolProperty]
ByteMask = 0x72
ByteOffset = 0x71
FieldMask = 0x73
FieldSize = 0x70

[UScriptStruct]
CppStructOps = 0xA0
StructFlags = 0x98
bPrepareCppStructOpsCompleted = 0x9C

[UWorld]
ActiveLevelCollectionIndex = 0x168
AudioDeviceHandle = 0x16C
AudioTimeSeconds = 0x514
BuildStreamingDataTimer = 0x350
CleanupWorldTag = 0x584
CommittedPersistentLevelName = 0x578
DeltaTimeSeconds = 0x518
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x500
LevelSequenceActors = 0x88
NextSwitchCountdown = 0x544
NextURL = 0x558
NumStreamingLevelsBeingLoaded = 0x552
OriginOffsetThisFrame = 0x538
PauseDelay = 0x51C
PerModuleDataObjects = 0x78
PlayerNum = 0x4C0
PreparingLevelNames = 0x568
RealTimeSeconds = 0x510
StreamingLevelsPrefix = 0xD0
StreamingVolumeUpdateDelay = 0x4C4
TimeSeconds = 0x508
UnpausedTimeSeconds = 0x50C
ViewLocationsRenderedLastFrame = 0x108
bActorsInitialized = 0x11C
bAggressiveLOD = 0x11C
bAllowAudioPlayback = 0x11E
bAreConstraintsDirty = 0x11E
bBegunPlay = 0x11D
bDebugPauseExecution = 0x11D
bDoDelayedUpdateCullDistanceVolumes = 0x11C
bDropDetail = 0x11C
bInTick = 0x11B
bIsBuilt = 0x11B
bIsCameraMoveableWhenPaused = 0x11E
bIsDefaultLevel = 0x11C
bIsLevelStreamingFrozen = 0x11B
bIsRunningConstructionScript = 0x11C
bIsTearingDown = 0x11D
bIsWorldInitialized = 0x11B
bKismetScriptError = 0x11D
bMarkedObjectsPendingKill = 0x580
bMatchStarted = 0x11D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x11F
bPlayersOnly = 0x11D
bPlayersOnlyPending = 0x11D
bPostTickComponentUpdate = 0x11B
bRequestedBlockOnAsyncLoading = 0x11C
bRequiresHitProxies = 0x11E
bShouldForceUnloadStreamingLevels = 0x11E
bShouldForceVisibleStreamingLevels = 0x11E
bShouldSimulatePhysics = 0x11C
bShouldTick = 0x11E
bStartup = 0x11D
bStreamingDataDirty = 0x11E
bTickNewlySpawned = 0x11B
bTriggerPostLoadMap = 0x11B
bWorldWasLoadedThisTick = 0x11B

[FSetProperty]
ElementProp = 0x70

[UClass]
ClassAddReferencedObjects = 0xA8
ClassConfigName = 0xD0
ClassConstructor = 0x98
ClassDefaultObject = 0xF8
ClassFlags = 0xB4
ClassGeneratedBy = 0xC8
ClassUnique = 0xB0
ClassVTableHelperCtorCaller = 0xA0
ClassWithin = 0xC0
Interfaces = 0x1B8
NetFields = 0xE8
SparseClassData = 0x100
SparseClassDataStruct = 0x108
bCooked = 0xB0

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FMapProperty]
KeyProp = 0x70
ValueProp = 0x78

[FStructProperty]
Struct = 0x70

[FArrayProperty]
Inner = 0x70

[FByteProperty]
Enum = 0x70

[FClassProperty]
MetaClass = 0x78

[FInterfaceProperty]
InterfaceClass = 0x70


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_25_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FField]
ClassPrivate = 0x8
FlagsPrivate = 0x30
NamePrivate = 0x28
Next = 0x20
Owner = 0x10

[FSoftClassProperty]
MetaClass = 0x80

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
ChildProperties = 0x50
Children = 0x48
DestructorLink = 0x80
MinAlignment = 0x5C
PostConstructLink = 0x88
PropertiesSize = 0x58
PropertyLink = 0x70
RefLink = 0x78
Script = 0x60
ScriptAndPropertyObjectReferences = 0x90
SuperStruct = 0x40
UnresolvedScriptProperties = 0xA0

[UFunction]
EventGraphCallOffset = 0xD0
EventGraphFunction = 0xC8
FirstPropertyToInit = 0xC0
Func = 0xD8
FunctionFlags = 0xB0
NumParms = 0xB4
ParmsSize = 0xB6
RPCId = 0xBA
RPCResponseId = 0xBC
ReturnValueOffset = 0xB8

[UField]
Next = 0x28

[FDelegateProperty]
SignatureFunction = 0x78

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x68
ElementSize = 0x3C
NextRef = 0x60
Offset_Internal = 0x4C
PostConstructLinkNext = 0x70
PropertyFlags = 0x40
PropertyLinkNext = 0x58
RepIndex = 0x48
RepNotifyFunc = 0x50

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[UScriptStruct]
CppStructOps = 0xB8
StructFlags = 0xB0
bPrepareCppStructOpsCompleted = 0xB4

[UWorld]
ActiveLevelCollectionIndex = 0x168
AudioTimeSeconds = 0x52C
BuildStreamingDataTimer = 0x368
CleanupWorldTag = 0x59C
CommittedPersistentLevelName = 0x590
DeltaTimeSeconds = 0x530
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x518
LevelSequenceActors = 0x88
NextSwitchCountdown = 0x55C
NextURL = 0x570
NumStreamingLevelsBeingLoaded = 0x56A
OriginOffsetThisFrame = 0x550
PauseDelay = 0x534
PerModuleDataObjects = 0x78
PlayerNum = 0x4D8
PreparingLevelNames = 0x580
RealTimeSeconds = 0x528
StreamingLevelsPrefix = 0xD0
StreamingVolumeUpdateDelay = 0x4DC
TimeSeconds = 0x520
UnpausedTimeSeconds = 0x524
ViewLocationsRenderedLastFrame = 0x108
bActorsInitialized = 0x11C
bAggressiveLOD = 0x11C
bAllowAudioPlayback = 0x11E
bAreConstraintsDirty = 0x11E
bBegunPlay = 0x11D
bDebugPauseExecution = 0x11D
bDoDelayedUpdateCullDistanceVolumes = 0x11C
bDropDetail = 0x11C
bInTick = 0x11B
bIsBuilt = 0x11B
bIsCameraMoveableWhenPaused = 0x11E
bIsDefaultLevel = 0x11C
bIsLevelStreamingFrozen = 0x11B
bIsRunningConstructionScript = 0x11C
bIsTearingDown = 0x11D
bIsWorldInitialized = 0x11B
bKismetScriptError = 0x11D
bMarkedObjectsPendingKill = 0x598
bMatchStarted = 0x11D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x11F
bPlayersOnly = 0x11D
bPlayersOnlyPending = 0x11D
bPostTickComponentUpdate = 0x11B
bRequestedBlockOnAsyncLoading = 0x11C
bRequiresHitProxies = 0x11E
bShouldForceUnloadStreamingLevels = 0x11E
bShouldForceVisibleStreamingLevels = 0x11E
bShouldSimulatePhysics = 0x11C
bShouldTick = 0x11E
bStartup = 0x11D
bStreamingDataDirty = 0x11E
bTickNewlySpawned = 0x11B
bTriggerPostLoadMap = 0x11B
bWorldWasLoadedThisTick = 0x11B

[UClass]
ClassAddReferencedObjects = 0xC0
ClassConfigName = 0xE8
ClassConstructor = 0xB0
ClassDefaultObject = 0x118
ClassFlags = 0xCC
ClassGeneratedBy = 0xE0
ClassUnique = 0xC8
ClassVTableHelperCtorCaller = 0xB8
ClassWithin = 0xD8
FirstOwnedClassRep = 0x110
Interfaces = 0x1D8
NetFields = 0x100
SparseClassData = 0x120
SparseClassDataStruct = 0x128
bCooked = 0xC8

[FSetProperty]
ElementProp = 0x78

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
Names = 0x40

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78

[FFieldPathProperty]
PropertyClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_26_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FField]
ClassPrivate = 0x8
FlagsPrivate = 0x30
NamePrivate = 0x28
Next = 0x20
Owner = 0x10

[FSoftClassProperty]
MetaClass = 0x80

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
ChildProperties = 0x50
Children = 0x48
DestructorLink = 0x80
MinAlignment = 0x5C
PostConstructLink = 0x88
PropertiesSize = 0x58
PropertyLink = 0x70
RefLink = 0x78
Script = 0x60
ScriptAndPropertyObjectReferences = 0x90
SuperStruct = 0x40
UnresolvedScriptProperties = 0xA0

[UFunction]
EventGraphCallOffset = 0xD0
EventGraphFunction = 0xC8
FirstPropertyToInit = 0xC0
Func = 0xD8
FunctionFlags = 0xB0
NumParms = 0xB4
ParmsSize = 0xB6
RPCId = 0xBA
RPCResponseId = 0xBC
ReturnValueOffset = 0xB8

[UField]
Next = 0x28

[FDelegateProperty]
SignatureFunction = 0x78

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x68
ElementSize = 0x3C
NextRef = 0x60
Offset_Internal = 0x4C
PostConstructLinkNext = 0x70
PropertyFlags = 0x40
PropertyLinkNext = 0x58
RepIndex = 0x48
RepNotifyFunc = 0x50

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[UScriptStruct]
CppStructOps = 0xB8
StructFlags = 0xB0
bPrepareCppStructOpsCompleted = 0xB4

[UWorld]
ActiveLevelCollectionIndex = 0x158
AudioTimeSeconds = 0x5A4
BuildStreamingDataTimer = 0x3C8
CleanupWorldTag = 0x614
CommittedPersistentLevelName = 0x608
DeltaTimeSeconds = 0x5A8
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x590
NextSwitchCountdown = 0x5D4
NextURL = 0x5E8
NumStreamingLevelsBeingLoaded = 0x5E2
OriginOffsetThisFrame = 0x5C8
PauseDelay = 0x5AC
PerModuleDataObjects = 0x78
PlayerNum = 0x550
PreparingLevelNames = 0x5F8
RealTimeSeconds = 0x5A0
StreamingLevelsPrefix = 0xC0
StreamingVolumeUpdateDelay = 0x554
TimeSeconds = 0x598
UnpausedTimeSeconds = 0x59C
ViewLocationsRenderedLastFrame = 0xF8
bActorsInitialized = 0x10C
bAggressiveLOD = 0x10C
bAllowAudioPlayback = 0x10E
bAreConstraintsDirty = 0x10E
bBegunPlay = 0x10D
bDebugPauseExecution = 0x10D
bDoDelayedUpdateCullDistanceVolumes = 0x10C
bDropDetail = 0x10C
bInTick = 0x10B
bIsBuilt = 0x10B
bIsCameraMoveableWhenPaused = 0x10E
bIsDefaultLevel = 0x10C
bIsLevelStreamingFrozen = 0x10B
bIsRunningConstructionScript = 0x10C
bIsTearingDown = 0x10D
bIsWorldInitialized = 0x10B
bKismetScriptError = 0x10D
bMarkedObjectsPendingKill = 0x610
bMatchStarted = 0x10D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x10F
bPlayersOnly = 0x10D
bPlayersOnlyPending = 0x10D
bPostTickComponentUpdate = 0x10B
bRequestedBlockOnAsyncLoading = 0x10C
bRequiresHitProxies = 0x10E
bShouldForceUnloadStreamingLevels = 0x10E
bShouldForceVisibleStreamingLevels = 0x10E
bShouldSimulatePhysics = 0x10C
bShouldTick = 0x10E
bStartup = 0x10D
bStreamingDataDirty = 0x10E
bTickNewlySpawned = 0x10B
bTriggerPostLoadMap = 0x10B
bWorldWasLoadedThisTick = 0x10B

[UClass]
ClassAddReferencedObjects = 0xC0
ClassConfigName = 0xE8
ClassConstructor = 0xB0
ClassDefaultObject = 0x118
ClassFlags = 0xCC
ClassGeneratedBy = 0xE0
ClassUnique = 0xC8
ClassVTableHelperCtorCaller = 0xB8
ClassWithin = 0xD8
FirstOwnedClassRep = 0x110
Interfaces = 0x1D8
NetFields = 0x100
SparseClassData = 0x120
SparseClassDataStruct = 0x128
bCooked = 0xC8

[FSetProperty]
ElementProp = 0x78

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
EnumFlags = 0x54
Names = 0x40

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78

[FFieldPathProperty]
PropertyClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_27_CasePreserving_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x28

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FField]
ClassPrivate = 0x8
FlagsPrivate = 0x34
NamePrivate = 0x28
Next = 0x20
Owner = 0x10

[FSoftClassProperty]
MetaClass = 0x88

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[FEnumProperty]
Enum = 0x88
UnderlyingProp = 0x80

[UStruct]
ChildProperties = 0x58
Children = 0x50
DestructorLink = 0x88
MinAlignment = 0x64
PostConstructLink = 0x90
PropertiesSize = 0x60
PropertyLink = 0x78
RefLink = 0x80
Script = 0x68
ScriptAndPropertyObjectReferences = 0x98
SuperStruct = 0x48
UnresolvedScriptProperties = 0xA8

[UFunction]
EventGraphCallOffset = 0xD8
EventGraphFunction = 0xD0
FirstPropertyToInit = 0xC8
Func = 0xE0
FunctionFlags = 0xB8
NumParms = 0xBC
ParmsSize = 0xBE
RPCId = 0xC2
RPCResponseId = 0xC4
ReturnValueOffset = 0xC0

[UField]
Next = 0x30

[FDelegateProperty]
SignatureFunction = 0x80

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x70
ElementSize = 0x3C
NextRef = 0x68
Offset_Internal = 0x4C
PostConstructLinkNext = 0x78
PropertyFlags = 0x40
PropertyLinkNext = 0x60
RepIndex = 0x48
RepNotifyFunc = 0x50

[FMulticastDelegateProperty]
SignatureFunction = 0x80

[FObjectPropertyBase]
PropertyClass = 0x80

[UScriptStruct]
CppStructOps = 0xC0
StructFlags = 0xB8
bPrepareCppStructOpsCompleted = 0xBC

[UWorld]
ActiveLevelCollectionIndex = 0x160
AudioTimeSeconds = 0x5B4
BuildStreamingDataTimer = 0x3D8
CleanupWorldTag = 0x628
CommittedPersistentLevelName = 0x618
DeltaTimeSeconds = 0x5B8
ExtraReferencedObjects = 0x70
LastTimeUnbuiltLightingWasEncountered = 0x5A0
NextSwitchCountdown = 0x5E4
NextURL = 0x5F8
NumStreamingLevelsBeingLoaded = 0x5F2
OriginOffsetThisFrame = 0x5D8
PauseDelay = 0x5BC
PerModuleDataObjects = 0x80
PlayerNum = 0x560
PreparingLevelNames = 0x608
RealTimeSeconds = 0x5B0
StreamingLevelsPrefix = 0xC8
StreamingVolumeUpdateDelay = 0x564
TimeSeconds = 0x5A8
UnpausedTimeSeconds = 0x5AC
ViewLocationsRenderedLastFrame = 0x100
bActorsInitialized = 0x114
bAggressiveLOD = 0x114
bAllowAudioPlayback = 0x116
bAreConstraintsDirty = 0x116
bBegunPlay = 0x115
bDebugPauseExecution = 0x115
bDoDelayedUpdateCullDistanceVolumes = 0x114
bDropDetail = 0x114
bInTick = 0x113
bIsBuilt = 0x113
bIsCameraMoveableWhenPaused = 0x116
bIsDefaultLevel = 0x114
bIsLevelStreamingFrozen = 0x113
bIsRunningConstructionScript = 0x114
bIsTearingDown = 0x115
bIsWorldInitialized = 0x113
bKismetScriptError = 0x115
bMarkedObjectsPendingKill = 0x624
bMatchStarted = 0x115
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x117
bPlayersOnly = 0x115
bPlayersOnlyPending = 0x115
bPostTickComponentUpdate = 0x113
bRequestedBlockOnAsyncLoading = 0x114
bRequiresHitProxies = 0x116
bShouldForceUnloadStreamingLevels = 0x116
bShouldForceVisibleStreamingLevels = 0x116
bShouldSimulatePhysics = 0x114
bShouldTick = 0x116
bStartup = 0x115
bStreamingDataDirty = 0x116
bTickNewlySpawned = 0x113
bTriggerPostLoadMap = 0x113
bWorldWasLoadedThisTick = 0x113

[UClass]
ClassAddReferencedObjects = 0xC8
ClassConfigName = 0xF0
ClassConstructor = 0xB8
ClassDefaultObject = 0x128
ClassFlags = 0xD4
ClassGeneratedBy = 0xE8
ClassUnique = 0xD0
ClassVTableHelperCtorCaller = 0xC0
ClassWithin = 0xE0
FirstOwnedClassRep = 0x120
Interfaces = 0x1E8
NetFields = 0x110
SparseClassData = 0x130
SparseClassDataStruct = 0x138
bCooked = 0xD0

[FSetProperty]
ElementProp = 0x80

[UEnum]
CppForm = 0x58
CppType = 0x38
EnumDisplayNameFn = 0x60
EnumFlags = 0x5C
Names = 0x48

[FStructProperty]
Struct = 0x80

[FArrayProperty]
Inner = 0x80

[FMapProperty]
KeyProp = 0x80
ValueProp = 0x88

[FBoolProperty]
ByteMask = 0x82
ByteOffset = 0x81
FieldMask = 0x83
FieldSize = 0x80

[FByteProperty]
Enum = 0x80

[FClassProperty]
MetaClass = 0x88

[FInterfaceProperty]
InterfaceClass = 0x80

[FFieldPathProperty]
PropertyClass = 0x80


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_4_27_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FField]
ClassPrivate = 0x8
FlagsPrivate = 0x30
NamePrivate = 0x28
Next = 0x20
Owner = 0x10

[FSoftClassProperty]
MetaClass = 0x80

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
ChildProperties = 0x50
Children = 0x48
DestructorLink = 0x80
MinAlignment = 0x5C
PostConstructLink = 0x88
PropertiesSize = 0x58
PropertyLink = 0x70
RefLink = 0x78
Script = 0x60
ScriptAndPropertyObjectReferences = 0x90
SuperStruct = 0x40
UnresolvedScriptProperties = 0xA0

[UFunction]
EventGraphCallOffset = 0xD0
EventGraphFunction = 0xC8
FirstPropertyToInit = 0xC0
Func = 0xD8
FunctionFlags = 0xB0
NumParms = 0xB4
ParmsSize = 0xB6
RPCId = 0xBA
RPCResponseId = 0xBC
ReturnValueOffset = 0xB8

[UField]
Next = 0x28

[FDelegateProperty]
SignatureFunction = 0x78

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x68
ElementSize = 0x3C
NextRef = 0x60
Offset_Internal = 0x4C
PostConstructLinkNext = 0x70
PropertyFlags = 0x40
PropertyLinkNext = 0x58
RepIndex = 0x48
RepNotifyFunc = 0x50

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[UScriptStruct]
CppStructOps = 0xB8
StructFlags = 0xB0
bPrepareCppStructOpsCompleted = 0xB4

[UWorld]
ActiveLevelCollectionIndex = 0x158
AudioTimeSeconds = 0x5AC
BuildStreamingDataTimer = 0x3D0
CleanupWorldTag = 0x61C
CommittedPersistentLevelName = 0x610
DeltaTimeSeconds = 0x5B0
ExtraReferencedObjects = 0x68
LastTimeUnbuiltLightingWasEncountered = 0x598
NextSwitchCountdown = 0x5DC
NextURL = 0x5F0
NumStreamingLevelsBeingLoaded = 0x5EA
OriginOffsetThisFrame = 0x5D0
PauseDelay = 0x5B4
PerModuleDataObjects = 0x78
PlayerNum = 0x558
PreparingLevelNames = 0x600
RealTimeSeconds = 0x5A8
StreamingLevelsPrefix = 0xC0
StreamingVolumeUpdateDelay = 0x55C
TimeSeconds = 0x5A0
UnpausedTimeSeconds = 0x5A4
ViewLocationsRenderedLastFrame = 0xF8
bActorsInitialized = 0x10C
bAggressiveLOD = 0x10C
bAllowAudioPlayback = 0x10E
bAreConstraintsDirty = 0x10E
bBegunPlay = 0x10D
bDebugPauseExecution = 0x10D
bDoDelayedUpdateCullDistanceVolumes = 0x10C
bDropDetail = 0x10C
bInTick = 0x10B
bIsBuilt = 0x10B
bIsCameraMoveableWhenPaused = 0x10E
bIsDefaultLevel = 0x10C
bIsLevelStreamingFrozen = 0x10B
bIsRunningConstructionScript = 0x10C
bIsTearingDown = 0x10D
bIsWorldInitialized = 0x10B
bKismetScriptError = 0x10D
bMarkedObjectsPendingKill = 0x618
bMatchStarted = 0x10D
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x10F
bPlayersOnly = 0x10D
bPlayersOnlyPending = 0x10D
bPostTickComponentUpdate = 0x10B
bRequestedBlockOnAsyncLoading = 0x10C
bRequiresHitProxies = 0x10E
bShouldForceUnloadStreamingLevels = 0x10E
bShouldForceVisibleStreamingLevels = 0x10E
bShouldSimulatePhysics = 0x10C
bShouldTick = 0x10E
bStartup = 0x10D
bStreamingDataDirty = 0x10E
bTickNewlySpawned = 0x10B
bTriggerPostLoadMap = 0x10B
bWorldWasLoadedThisTick = 0x10B

[UClass]
ClassAddReferencedObjects = 0xC0
ClassConfigName = 0xE8
ClassConstructor = 0xB0
ClassDefaultObject = 0x118
ClassFlags = 0xCC
ClassGeneratedBy = 0xE0
ClassUnique = 0xC8
ClassVTableHelperCtorCaller = 0xB8
ClassWithin = 0xD8
FirstOwnedClassRep = 0x110
Interfaces = 0x1D8
NetFields = 0x100
SparseClassData = 0x120
SparseClassDataStruct = 0x128
bCooked = 0xC8

[FSetProperty]
ElementProp = 0x78

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
EnumFlags = 0x54
Names = 0x40

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78

[FFieldPathProperty]
PropertyClass = 0x78


```

`Staging/MemberVarLayoutTemplates/MemberVariableLayout_5_00_Template.ini`:

```ini
[UObjectBase]
ClassPrivate = 0x10
InternalIndex = 0xC
NamePrivate = 0x18
ObjectFlags = 0x8
OuterPrivate = 0x20

[UScriptStruct::ICppStructOps]
Alignment = 0xC
Size = 0x8

[FField]
ClassPrivate = 0x8
FlagsPrivate = 0x30
NamePrivate = 0x28
Next = 0x20
Owner = 0x10

[FSoftClassProperty]
MetaClass = 0x80

[FOutputDevice]
bAutoEmitLineTerminator = 0x9
bSuppressEventTag = 0x8

[FEnumProperty]
Enum = 0x80
UnderlyingProp = 0x78

[UStruct]
ChildProperties = 0x50
Children = 0x48
DestructorLink = 0x80
MinAlignment = 0x5C
PostConstructLink = 0x88
PropertiesSize = 0x58
PropertyLink = 0x70
RefLink = 0x78
Script = 0x60
ScriptAndPropertyObjectReferences = 0x90
SuperStruct = 0x40
UnresolvedScriptProperties = 0xA0

[UFunction]
EventGraphCallOffset = 0xD0
EventGraphFunction = 0xC8
FirstPropertyToInit = 0xC0
Func = 0xD8
FunctionFlags = 0xB0
NumParms = 0xB4
ParmsSize = 0xB6
RPCId = 0xBA
RPCResponseId = 0xBC
ReturnValueOffset = 0xB8

[UField]
Next = 0x28

[FDelegateProperty]
SignatureFunction = 0x78

[FProperty]
ArrayDim = 0x38
DestructorLinkNext = 0x68
ElementSize = 0x3C
NextRef = 0x60
Offset_Internal = 0x4C
PostConstructLinkNext = 0x70
PropertyFlags = 0x40
PropertyLinkNext = 0x58
RepIndex = 0x48
RepNotifyFunc = 0x50

[FMulticastDelegateProperty]
SignatureFunction = 0x78

[FObjectPropertyBase]
PropertyClass = 0x78

[UScriptStruct]
CppStructOps = 0xB8
StructFlags = 0xB0
bPrepareCppStructOpsCompleted = 0xB4

[UWorld]
ActiveLevelCollectionIndex = 0x168
AudioTimeSeconds = 0x5E4
BlockTillLevelStreamingCompletedEpoch = 0x11C
BuildStreamingDataTimer = 0x408
CleanupWorldTag = 0x66C
CommittedPersistentLevelName = 0x660
DeltaRealTimeSeconds = 0x5E8
DeltaTimeSeconds = 0x5EC
ExtraReferencedObjects = 0x68
IsInBlockTillLevelStreamingCompleted = 0x118
LWILastAssignedUID = 0x230
LastTimeUnbuiltLightingWasEncountered = 0x5D0
NextSwitchCountdown = 0x628
NextURL = 0x640
NumStreamingLevelsBeingLoaded = 0x63A
PauseDelay = 0x5F0
PerModuleDataObjects = 0x78
PlayerNum = 0x590
PreparingLevelNames = 0x650
RealTimeSeconds = 0x5E0
StreamingLevelsPrefix = 0xC0
StreamingVolumeUpdateDelay = 0x594
TimeSeconds = 0x5D8
UnpausedTimeSeconds = 0x5DC
bActorsInitialized = 0x114
bAggressiveLOD = 0x114
bAllowAudioPlayback = 0x116
bAllowDeferredPhysicsStateCreation = 0xF8
bAreConstraintsDirty = 0x116
bBegunPlay = 0x115
bDebugPauseExecution = 0x115
bDoDelayedUpdateCullDistanceVolumes = 0x114
bDropDetail = 0x114
bInTick = 0x113
bInitializedAndNeedsCleanup = 0x117
bIsBuilt = 0x113
bIsCameraMoveableWhenPaused = 0x116
bIsDefaultLevel = 0x114
bIsLevelStreamingFrozen = 0x113
bIsRunningConstructionScript = 0x114
bIsTearingDown = 0x115
bIsWorldInitialized = 0x113
bKismetScriptError = 0x115
bMarkedObjectsPendingKill = 0x668
bMatchStarted = 0x115
bMaterialParameterCollectionInstanceNeedsDeferredUpdate = 0x117
bPlayersOnly = 0x115
bPlayersOnlyPending = 0x115
bPostTickComponentUpdate = 0x113
bRequestedBlockOnAsyncLoading = 0x114
bRequiresHitProxies = 0x116
bShouldForceUnloadStreamingLevels = 0x116
bShouldForceVisibleStreamingLevels = 0x116
bShouldSimulatePhysics = 0x114
bShouldTick = 0x116
bStartup = 0x115
bStreamingDataDirty = 0x116
bTickNewlySpawned = 0x113
bTriggerPostLoadMap = 0x113
bWorldWasLoadedThisTick = 0x113

[UClass]
ClassAddReferencedObjects = 0xC0
ClassConfigName = 0xE8
ClassConstructor = 0xB0
ClassDefaultObject = 0x110
ClassFlags = 0xD4
ClassUnique = 0xC8
ClassVTableHelperCtorCaller = 0xB8
ClassWithin = 0xE0
FirstOwnedClassRep = 0xCC
Interfaces = 0x1D0
NetFields = 0x100
SparseClassData = 0x118
SparseClassDataStruct = 0x120
bCooked = 0xD0
bLayoutChanging = 0xD1

[FSetProperty]
ElementProp = 0x78

[UEnum]
CppForm = 0x50
CppType = 0x30
EnumDisplayNameFn = 0x58
EnumFlags = 0x54
Names = 0x40

[FStructProperty]
Struct = 0x78

[FArrayProperty]
Inner = 0x78

[FMapProperty]
KeyProp = 0x78
ValueProp = 0x80

[FBoolProperty]
ByteMask = 0x7A
ByteOffset = 0x79
FieldMask = 0x7B
FieldSize = 0x78

[FByteProperty]
Enum = 0x78

[FClassProperty]
MetaClass = 0x80

[FInterfaceProperty]
InterfaceClass = 0x78

[FFieldPathProperty]
PropertyClass = 0x78


```

`Staging/MemberVarLayoutTemplates/README.txt`:

```txt
These templates are meant to be used as a base for games with custom engine versions or an otherwise unsupported engine version.

1. Figure out the engine version of your game.
2. Copy the template closest to that version to the same folder as the ue4ss.dll/xinput1_3.dll.
3. Rename the file to 'MemberVariableLayout.ini'.
4. Make your adjustments.
   Values are absolute offsets.
   Values can be hex if they are prefixed with 0x and entries with a value of -1 and entries that don't exist will use the default value for the detected engine version.
The game must be restarted after making any adjustments.
```

`Staging/Mods/ActorDumperMod/Scripts/main.lua`:

```lua
RegisterCustomProperty({
    ["Name"] = "Actors",
    ["Type"] = PropertyTypes.ArrayProperty,
    ["BelongsToClass"] = "/Script/Engine.Level",
    ["OffsetInternal"] = 0x98,
    ["ArrayProperty"] = {
        ["Type"] = PropertyTypes.ObjectProperty
    }
})

RegisterKeyBind(Key.NUM_THREE, {ModifierKey.CONTROL}, function()
    local Level = FindFirstOf("Level")
    local Actors = Level.Actors
    
    Actors:ForEach(function(Index, ElemWrapper)
        local Actor = ElemWrapper:get()
        
        print(string.format("0x%X %s\n", Actor:GetAddress(), Actor:GetFullName()))
    end)
end)

```

`Staging/Mods/CXXHeaderGeneratorMod/Scripts/main.lua`:

```lua
RegisterKeyBind(Key.D, {ModifierKey.CONTROL}, function()
    GenerateSDK()
end)


```

`Staging/Mods/CheatManagerEnablerMod/Scripts/main.lua`:

```lua
RegisterHook("/Script/Engine.PlayerController:ClientRestart", function(self, NewPawn)
    local PlayerController = self:get()
    
    local CheatManagerClass = PlayerController.CheatClass
    if not CheatManagerClass then
        print("[CheatManager Creator] Controller:CheatClass is nullptr, using default CheatClass instead\n")
        
        CheatManagerClass = StaticFindObject("/Script/Engine.CheatManager")
    end
    
    if not CheatManagerClass then
        print("[CheatManager Creator] Couldn't find default CheatClass, therefore, could not enable Cheat Manager\n")
        return
    end
    
    local CreatedCheatManager = StaticConstructObject(CheatManagerClass, PlayerController, 0, 0, 0, nil, false, false, nil)
	if CreatedCheatManager then
        print(string.format("[CheatManager Creator] Constructed CheatManager [0x%X]\n", CreatedCheatManager:GetAddress()))
        
		PlayerController.CheatManager = CreatedCheatManager
		print("[CheatManager Creator] Enabled CheatManager\n")
	else
		print("[CheatManager Creator] Was unable to construct CheatManager, therefor, could not enable Cheat Manager\n")
	end
end)

```

`Staging/Mods/ConsoleCommandsMod/Scripts/dump_object.lua`:

```lua
-- This is a custom implementation of UEs "obj dump <obj>" command.
-- It doesn't have a 1:1 feature set.

--[[
    TODO: Expand on the console command format.
          You should be able to specify a sub-object, sub-struct, sub-array, sub-map, etc.
          You do 'dump_object /Engine/Transient.GameEngine_2147482624'.
          You notice '(ArrayProperty) ShaderComplexityColors=StructProperty ...'.
          To get the first element, you do: 'dump_object /Engine/Transient.GameEngine_2147482624 ShaderComplexityColors 0'.
          This will likely see the type-prefix (i.e. UClass /Engine/Script/...) needing to be unsupported just to simplify the code.
          UPDATE: This is currently working with ArrayProperty and StructProperty.
                  Need to add support eventually for MapProperty when UE4SS Lua supports MapProperty.
]]

string.padleft = function(InString, Length, PadWithChar)
    -- We pad with spaces by default.
    if not PadWithChar then PadWithChar = " " end
    return InString .. PadWithChar:rep(Length - #InString)
end

local OriginalLog = Log
local Buffer = ""
function Log(Message)
    Buffer = string.format("%s%s\n", Buffer, Message)
    OriginalLog(Message)
end

local UClassStaticClass = StaticFindObject("/Script/CoreUObject.Class")
local UScriptStructStaticClass = StaticFindObject("/Script/CoreUObject.ScriptStruct")
local UEnumStaticClass = StaticFindObject("/Script/CoreUObject.Enum")
local UPropertyStaticClass = StaticFindObject("/Script/CoreUObject.Property")

local DumpPropertyWithinObject = nil
local DumpObject = nil

DumpPropertyWithinObject = function(Object, Property, DumpRecursively)
    local ValueStr = ""

    -- Cannot resolve the value here because of unhandled types.
    if Property:IsA(PropertyTypes.Int8Property) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.Int16Property) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.IntProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.Int64Property) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.NameProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value:ToString())
    elseif Property:IsA(PropertyTypes.FloatProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.StrProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value:ToString())
    elseif Property:IsA(PropertyTypes.ByteProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value)
    elseif Property:IsA(PropertyTypes.ArrayProperty) then
        local Value = Object[Property:GetFName():ToString()]
        local Inner = Property:GetInner()

        -- Inner Type
        if Inner:IsA(PropertyTypes.StructProperty) then
            ValueStr = string.format("%s\n", Inner:GetStruct():GetFullName())
        else
            ValueStr = string.format("%s\n", Inner:GetFullName())
        end
        
        -- Size & Capacity
        if Value:GetArrayNum() == 0 then
            ValueStr = string.format("%s    ---empty---", ValueStr)
        else
            ValueStr = string.format("%s    %i/%i", ValueStr, Value:GetArrayNum(), Value:GetArrayMax())
        end
        
        -- Inner Value
        if Value:GetArrayNum() > 0 then
            ValueStr = string.format("%s\n", ValueStr)
            if Inner:IsA(PropertyTypes.ObjectProperty) then
                Value:ForEach(function(Index, Elem)
                    ValueStr = string.format("%s    [%i]: %s\n", ValueStr, Index - 1, Elem:get():GetFullName())
                end)
            end
        end
    elseif Property:IsA(PropertyTypes.MapProperty) then
        ValueStr = "UNHANDLED_VALUE"
    elseif Property:IsA(PropertyTypes.StructProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value:GetFullName())
        if DumpRecursively then
            DumpObject(Value)
        end
    elseif Property:IsA(PropertyTypes.ClassProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value:GetFullName())
    elseif Property:IsA(PropertyTypes.WeakObjectProperty) then
        --local Value = Object[Property:GetFName():ToString()]
        ValueStr = "UNHANDLED_VALUE"
    elseif Property:IsA(PropertyTypes.EnumProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s(%s)", Property:GetEnum():GetNameByValue(Value):ToString(), Value)
    elseif Property:IsA(PropertyTypes.TextProperty) then
        local Value = Object[Property:GetFName():ToString()]
        ValueStr = string.format("%s", Value:ToString())
    elseif Property:IsA(PropertyTypes.ObjectProperty) then
        local Value = Object[Property:GetFName():ToString()]
        if DumpRecursively then
            DumpObject(Value)
        else
            ValueStr = string.format("%s", Value:GetFullName())
        end
    elseif Property:IsA(PropertyTypes.BoolProperty) then
        local Value = Object[Property:GetFName():ToString()]
        local FieldMask = Property:GetFieldMask()
        if FieldMask == 255 then
            ValueStr = string.format("%s", (Value and "True" or "False"))
        else
            ValueStr = string.format("%s (FM: 0x%X, BM: 0x%X)", (Value and "True" or "False"), FieldMask, Property:GetByteMask())
        end
    else
        ValueStr = "UNHANDLED_VALUE"
    end

    return string.format("0x%04X    %s %s=%s", Property:GetOffset_Internal(), Property:GetClass():GetFName():ToString(), Property:GetFName():ToString(), ValueStr)
end

local function GetObjectByName(ObjectName)
    local Object = nil
    if FPackageName.IsShortPackageName(ObjectName) then
        Object = FindObject(nil, ObjectName, nil, nil)
    else
        Object = FindObject(nil, nil, ObjectName, false)
    end
    return Object
end

local function GetPropertyByName(ObjectIn, PropertyName)
    local PropertyFName = FName(PropertyName)
    local Object = nil

    if ObjectIn:IsA(UClassStaticClass) or ObjectIn:IsA(UScriptStructStaticClass) then
        Object = ObjectIn
    else
        Object = ObjectIn:GetClass()
    end

    local PropertyFound = nil
    while Object:IsValid() do
        Object:ForEachProperty(function(Property)
            if Property:GetFName():Equals(PropertyFName) then
                PropertyFound = Property
                return true
            end
        end)
        Object = Object:GetSuperStruct()
    end

    return PropertyFound
end

DumpObject = function(Object)
    Log(string.format("*** Property dump for object '%s ***", Object:GetFullName()))

    -- Lets make sure that this is an object type that can be dumped.
    local IsClassCompatible = false
    if Object:IsA(UClassStaticClass) then IsClassCompatible = true end
    local IsUScriptStruct = Object:IsA(UScriptStructStaticClass)
    if IsUScriptStruct and not Object:IsMappedToObject() then IsClassCompatible = true end

    if IsClassCompatible then
        -- A UClass or UScriptStruct.
        local Class = Object
        while Class and Class:IsValid() do
            Log(string.format("=== %s properties ===", Class:GetFullName()))
            Class:ForEachProperty(function(Property)
                local OutputBuffer = string.format("0x%04X    %s %s", Property:GetOffset_Internal(), Property:GetClass():GetFName():ToString(), Property:GetFName():ToString())
                if Property:IsA(PropertyTypes.ObjectProperty) then
                    OutputBuffer = string.format("%s (%s)", OutputBuffer, Property:GetPropertyClass():GetFullName())
                elseif Property:IsA(PropertyTypes.BoolProperty) then
                    local FieldMask = Property:GetFieldMask()
                    if FieldMask ~= 255 then
                        OutputBuffer = string.format("%s (FM: 0x%X, BM: 0x%X)", OutputBuffer, FieldMask, Property:GetByteMask())
                    end
                end
                Log(OutputBuffer)
            end)

            Class = Class:GetSuperStruct()
        end
    elseif Object:IsA(UEnumStaticClass) then
        Object:ForEachName(function(Name, Value)
            Log(string.format("%s (%i)", Name:ToString(), Value))
        end)
    elseif not Object:IsA(UPropertyStaticClass) then
        -- A UObject that isn't a UClass, UScriptStruct, or UProperty (<4.25 only)
        local ObjectClass = nil
        if IsUScriptStruct then
            ObjectClass = Object
        else
            ObjectClass = Object:GetClass()
        end
        while ObjectClass and ObjectClass:IsValid() do
            Log(string.format("=== %s ===", ObjectClass:GetFullName()))
            ObjectClass:ForEachProperty(function(Property)
                Log(DumpPropertyWithinObject(Object, Property))
            end)

            ObjectClass = ObjectClass:GetSuperStruct()
        end
    end
end

local State = {
    ["StoreObjectContext"] = 1,
    ["FindProperty"] = 2,
    ["FoundObject"] = 3,
    ["FoundProperty"] = 4,
}

local ObjectContext = nil
local PropertyContext = nil
local CurrentState = State.StoreObjectContext

function ExecStateMachine(Param)
    if CurrentState == State.StoreObjectContext then
        if not Param or Param == "" or Param == " " then
            Log("No object name supplied")
            return true
        else
            ObjectContext = GetObjectByName(Param)
            if (ObjectContext:IsA(UScriptStructStaticClass)) or (ObjectContext and ObjectContext:IsValid()) then
                CurrentState = State.FindProperty
            else
                Log(string.format("No class found with name %s", Param))
                return true
            end
        end
    elseif CurrentState == State.FindProperty then
        PropertyContext = GetPropertyByName(ObjectContext, Param)
        if PropertyContext and PropertyContext:IsValid() then
            if PropertyContext:IsA(PropertyTypes.ObjectProperty) then
                --CurrentState = State.FindProperty
                --return ExecStateMachine(Param)
            end
            CurrentState = State.FoundProperty
        else
            Log(string.format("Property '%s' not found in '%s'", Param, ObjectContext:GetFullName()))
            return true
        end
    elseif CurrentState == State.FoundProperty then
        if PropertyContext:IsA(PropertyTypes.ArrayProperty) then
            PropertyContext = PropertyContext:GetInner()
            ObjectContext = ObjectContext[PropertyContext:GetFName():ToString()]

            local ArrayIndex = tonumber(Param)
            if not ArrayIndex then
                Log(string.format("Value '%s' is not a valid array index", Param))
                return true
            elseif ObjectContext:GetArrayNum() < ArrayIndex + 1 then
                Log(string.format("Array index '%i' out of bounds.", ArrayIndex))
                return true
            else
                ObjectContext = ObjectContext[ArrayIndex + 1]
                CurrentState = State.FindProperty
                return false
            end
        end

        ObjectContext = ObjectContext[PropertyContext:GetFName():ToString()]
        CurrentState = State.FindProperty
        return ExecStateMachine(Param)
    end
end

RegisterConsoleCommandHandler("dump_object", function(FullCommand, Parameters, Ar)
    ObjectContext = nil
    PropertyContext = nil
    CurrentState = State.StoreObjectContext

    if #Parameters < 1 then return false end
    local ShouldSaveToFile = Parameters[1]:find(".txt")
    if ShouldSaveToFile and #Parameters < 2 then return false end

    GlobalAr = Ar

    for i = ShouldSaveToFile and 2 or 1, #Parameters, 1 do
        local Param = Parameters[i]
        if ExecStateMachine(Param) then
            Buffer = ""
            return true
        end
    end

    if CurrentState == State.FoundProperty then
        Log(DumpPropertyWithinObject(ObjectContext, PropertyContext, true))
    else
        DumpObject(ObjectContext)
    end

    if ShouldSaveToFile then
        local File = io.open(Parameters[1], "w+")
        File:write(Buffer)
        File:close()

    end
    Buffer = ""
    return true
end)

```

`Staging/Mods/ConsoleCommandsMod/Scripts/main.lua`:

```lua
GlobalAr = nil

function Log(Message)
    print(Message .. "\n")
    if type(GlobalAr) == "userdata" and GlobalAr:type() == "FOutputDevice" then
        GlobalAr:Log(Message)
    end
end

require("summon_unloaded_assets")
require("set")
require("dump_object")
```

`Staging/Mods/ConsoleCommandsMod/Scripts/set.lua`:

```lua
RegisterConsoleCommandHandler("set", function(FullCommand, Parameters, Ar)
    -- If we have no parameters then just let someone else handle this command
    if #Parameters < 3 then return false end
    
    GlobalAr = Ar
    
    local ClassOrObjectName = Parameters[1]
    local PropertyName = Parameters[2]
    local NewPropertyValue = Parameters[3]
    
    local BannedFlags = EObjectFlags.RF_ClassDefaultObject | EObjectFlags.RF_ArchetypeObject
    
    if not ClassOrObjectName or ClassOrObjectName == "" or ClassOrObjectName == " " then
        Log("No class or object name supplied")
        return true
    end
    
    local ObjectOrClass = FindObject(nil, ClassOrObjectName, nil, BannedFlags)
    if not ObjectOrClass:IsValid() then
        Log(string.format("Unrecognized class or object %s", ClassOrObjectName))
        return true
    end
    
    -- Replace with a call to "IsA" when it exists
    if (ObjectOrClass:IsClass()) then
        local Property = ObjectOrClass:Reflection():GetProperty(PropertyName)
        if Property:IsValid() then
            local Objects = FindObjects(0, ObjectOrClass, nil, nil, BannedFlags, false)
            for ObjectNum, Object in pairs(Objects) do
                Property:ImportText(NewPropertyValue, Property:ContainerPtrToValuePtr(Object), 0, Object)
            end
            
            if #Objects == 0 then
                Log(string.format("No objects found with class %s", ClassOrObjectName))
            end
        else
            Log(string.format("Unrecognized property %s on class %s", PropertyName, ClassOrObjectName))
        end
    else
        local Property = Object:Reflection():GetProperty(PropertyName)
        if Property:IsValid() then
            Property:ImportText(NewPropertyValue, Property:ContainerPtrToValuePtr(Object), 0, Object)
        else
            Log(string.format("Unrecognized property %s on class %s", PropertyName, ClassOrObjectName))
        end
    end
    
    return true
end)

```

`Staging/Mods/ConsoleCommandsMod/Scripts/summon_unloaded_assets.lua`:

```lua
RegisterConsoleCommandHandler("summon", function(FullCommand, Parameters)
    -- If we have no parameters then just let someone else handle this command
    if #Parameters < 1 then return false end
    
    LoadAsset(Parameters[1])
    
    -- Return true if this is the final handler for this command
    -- Return false if you want another handler to be able to handle this command
    -- In this case, we want the CheatManager to also handle this command
    return false
end)
```

`Staging/Mods/ConsoleEnablerMod/Scripts/main.lua`:

```lua
local Engine = FindFirstOf("Engine")
local PlayerControllerHookActive = false
local WasFirstConsoleCreated = false

local function RemapConsoleKeys()
    -- Change console key
    local InputSettings = StaticFindObject("/Script/Engine.Default__InputSettings")
    if not InputSettings:IsValid() then print("[ConsoleEnabler] InputSettings not found, could not change console key\n") return end
    
    local ConsoleKeys = InputSettings.ConsoleKeys
    
    -- This sets the first console key to F10
    ConsoleKeys[1].KeyName = FName("F10")
    
    ConsoleKeys:ForEach(function(index, elem_wrapper)
        local KeyStruct = elem_wrapper:get()
        local KeyFName = KeyStruct.KeyName
        -- The ToString() call here will go bad if the FName is not ansi
        print(string.format("[ConsoleEnabler] ConsoleKey[%d]: %s\n", index, KeyFName:ToString()))
    end)
end

local function CreateConsole()
    if not Engine:IsValid() then
        Engine = FindFirstOf("Engine")
    end
    
    if not Engine:IsValid() then print("[ConsoleEnabler] Was unable to find an instance of UEngine\n") return end
    
    local ConsoleClass = Engine.ConsoleClass
    local GameViewport = Engine.GameViewport
    
    if GameViewport.ViewportConsole:IsValid() then
        -- Console already exists, let's just remap the keys
        RemapConsoleKeys()
    elseif ConsoleClass:IsValid() and GameViewport:IsValid() then
        local CreatedConsole = StaticConstructObject(ConsoleClass, GameViewport, 0, 0, 0, nil, false, false, nil)
        GameViewport.ViewportConsole = CreatedConsole
        
        PlayerControllerHookActive = true
        WasFirstConsoleCreated = true

        RemapConsoleKeys()
    else
        print("ConsoleClass, GameViewport, or ViewportConsole is invalid\n")
    end
end

CreateConsole()

NotifyOnNewObject("/Script/Engine.PlayerController", function(CreatedObject)
    if PlayerControllerHookActive or not WasFirstConsoleCreated then
        CreateConsole()
    end
end)

```

`Staging/Mods/ObjectDumperMod/Scripts/main.lua`:

```lua
function KeyInput_DumpAllObjects()
	DumpAllObjects()
end
RegisterKeyBind(Key.J, {ModifierKey.CONTROL}, KeyInput_DumpAllObjects) -- Key: 'J'
```

`Staging/Mods/UHTCompatibleHeaderGeneratorMod/Scripts/main.lua`:

```lua
RegisterKeyBind(Key.NUM_NINE, {ModifierKey.CONTROL}, function()
    GenerateUHTCompatibleHeaders()
end)
```

`Staging/Mods/mods.txt`:

```txt
ObjectDumperMod : 1
CXXHeaderGeneratorMod : 1
UHTCompatibleHeaderGeneratorMod : 1
CheatManagerEnablerMod : 1
ActorDumperMod : 0
ConsoleCommandsMod : 1
ConsoleEnablerMod : 1

```

`Staging/Readme.md`:

```md
# Unreal Engine 4/5 Scripting System

## The original creator no longer wishes to be involved in or connected to this project.  Please respect their wishes, and avoid using their past usernames in connection with this project.

### This tool has entered "Maintenance" mode. No more features will be added for the foreseeable future, but it will hopefully still be updated whenever new UE versions are released.

## Targeting UE Versions: From 4.12 To 5.0

The goal of UE4SS is not to be a plug-n-play solution that always works with every game.  
The goal is to have an underlying system that works for most games.  
You may need to update AOBs on your own, and there's a guide for that below.

## Links

[Full installation guide](https://github.com/UE4SS/UE4SS/blob/master/Guides/FullInstallationGuide.md)  
[Updating AOBs](https://github.com/UE4SS/UE4SS/blob/master/Guides/FixingBrokenAOBs.md)  
[Generating UHT compatible headers](https://github.com/UE4SS/UE4SS/wiki/Generating-UHT-compatible-headers)

## Credits

- **Original Creator** The original creator no longer wishes to be involved in or connected to  this project.  Please respect their wishes, and avoid using their past usernames in connection with this project.
- **Archengius**
  - UHT compatible header generator
- **Narknon**
- **CasualGamer**
  - Injector code & aob scanner is heavily based on his work, 90% of that code is his.
- **SunBeam**
  - Extra signature for function 'GetFullName' for UE4.25.
  - Regex to check for proper signature format when loaded from ini.
  - Lots and lots of work on signatures
- **tomsa**
  - const char* to vector\<int> converter
    - tomsa: Idea & most of the code
    - Original Creator: Nibblet support
- **boop** / **usize**
  - New UFunction hook method
- **Deadmoroz**

## Thanks to everyone who helped with testing

- GreenHouse
- Otis_Inf
- SunBeam
- Motoson
- hooter
- Synopis

```

`Staging/UE4SS-settings.ini`:

```ini
[Overrides]
; Path to the 'Mods' folder
; Default: <dll_directory>/Mods
ModsFolderPath =

[General]
EnableHotReloadSystem = 0

; Whether caches will be invalidated if ue4ss.dll has changed
; Default: 1
InvalidateCacheIfDLLDiffers = 1

; The maximum number attempts the scanner will try before erroring out if an aob isn't found
; Default: 60
MaxScanAttemptsNormal = 60

; The maximum number attempts the scanner will try for modular games before erroring out if an aob isn't found
; Default: 2000
MaxScanAttemptsModular = 2500

; Whether to create UObject listeners in GUObjectArray to create a fast cache for use instead of iterating GUObjectArray.
; Setting this to false can help if you're experiencing a crash on startup.
; Default: true
bUseUObjectArrayCache = true

[EngineVersionOverride]
MajorVersion = 
MinorVersion =

[ObjectDumper]
; Whether to force all assets to be loaded before dumping objects
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeDumpingObjects = 0

[CXXHeaderGenerator]
; Whether to property offsets and sizes
; Default: 0
DumpOffsetsAndSizes = 0

; Whether memory layouts of classes and structs should be accurate
; This must be set to 1, if you want to use the generated headers in an actual C++ project
; When set to 0, padding member variables will not be generated
; NOTE: A VALUE OF 1 HAS NO PURPOSE YET! MEMORY LAYOUT IS NOT ACCURATE EITHER WAY!
; Default: 0
KeepMemoryLayout = 0

; Whether to force all assets to be loaded before generating headers
; WARNING: Can require multiple gigabytes of extra memory
; WARNING: Is not stable & will crash the game if you load past the main menu after dumping
; Default: 0
LoadAllAssetsBeforeGeneratingCXXHeaders = 0

[UHTHeaderGenerator]
; Whether to skip generating packages that belong to the engine
; Some games make alterations to the engine and for those games you might want to set this to 0
; Default: 0
IgnoreAllCoreEngineModules = 0

; Whether to skip generating the "Engine" and "CoreUObject" packages
; Default: 1
IgnoreEngineAndCoreUObject = 1

; Whether to force all UFUNCTION macros to have "BlueprintCallable"
; Note: This will cause some errors in the generated headers that you will need to manually fix
; Default: 0
MakeAllFunctionsBlueprintCallable = 0

; Whether to force all UPROPERTY macros to have 'BlueprintReadWrite'
; Also forces all UPROPERTY macros to have 'meta=(AllowPrivateAccess=true)'
; Default: 0
MakeAllPropertyBlueprintsReadWrite = 0

; Whether to force UENUM macros on enums to have 'BlueprintType' if the underlying type was implicit or uint8
; Note: This also forces the underlying type to be uint8 where the type would otherwise be implicit
; Default: 0
MakeEnumClassesBlueprintType = 0

[Debug]
; Whether to enable the external UE4SS debug console.
ConsoleEnabled = 1
GuiConsoleEnabled = 1
GuiConsoleVisible = 1


[Threads]
; The number of threads that the sig scanner will use (not real cpu threads, can be over your physical & hyperthreading max)
; If the game is modular then multi-threading will always be off regardless of the settings in this file
; Min: 1
; Max: 4294967295
; Default: 8
SigScannerNumThreads = 8

; The minimum size that a module has to be in order for multi-threading to be enabled
; This should be large enough so that the cost of creating threads won't out-weigh the speed gained from scanning in multiple threads
; Min: 0
; Max: 4294967295
; Default: 16777216
SigScannerMultithreadingModuleSizeThreshold = 16777216

[Memory]
; The maximum memory usage (in percentage, see Task Manager %) allowed before asset loading (when LoadAllAssetsBefore* is 1) cannot happen.
; Once this percentage is reached, the asset loader will stop loading and whatever operation was in progress (object dump, or cxx generator) will continue.
MaxMemoryUsageDuringAssetLoading = 80

```

`Staging/UE4SS_Signatures/FName_ToString.lua.example`:

```example
function Register()
    return "C 3/3 3/C 0/4 8/8 D/5 4/2 4/2 0/4 8/8 B/C F/4 8/8 9/4 4/2 4/2 0/4 8/8 9/4 4/2 4/2 8/E 8"
end

function OnMatchFound(MatchAddress)
    local AOBSize = 22
    local CallInstr = MatchAddress + AOBSize - 1
    local InstrSize = 5
    local NextInstr = CallInstr + InstrSize
    local Offset = DerefToInt32(CallInstr + 1)
    local ToStringAddress = NextInstr + Offset
    return ToStringAddress
end
```

`Staging/UE4SS_Signatures/GUObjectArray.lua.example`:

```example
function Register()
    return "8 B/5 1/0 4/8 5/D 2/7 4/5 A/4 8/6 3/0 1/8 5/C 0/7 8/5 3/4 4/8 B/? ?/? ?/? ?/? ?/? ?/4 1/3 B/C 0/7 D/4 7/4 C/8 B"
end

function OnMatchFound(matchAddress)
    local movInstr = matchAddress + 0x1A
    local nextInstr = movInstr + 0x7
    local offset = movInstr + 0x3
    local dataMoved = nextInstr + DerefToInt32(offset) - 0x10
    
    return dataMoved
end
```

`Staging/VTableLayoutTemplates/README.txt`:

```txt
These templates are meant to be used as a base for games with custom engine versions or an otherwise unsupported engine version.

1. Figure out the engine version of your game.
2. Copy the template closest to that version to the same folder as the ue4ss.dll/xinput1_3.dll.
3. Rename the file to 'VTableLayout.ini'.
4. Make your adjustments.
The game must be restarted after making any adjustments.
```

`Staging/VTableLayoutTemplates/VTableLayout_4_12_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsPostLoadThreadSafe
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetExporterName
IsLocalizedResource
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, void* Data, uint64 Value);
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_13_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsPostLoadThreadSafe
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, void* Data, uint64 Value);
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_14_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_15_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_16_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_17_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_18_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSize
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_19_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_20_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill
AddToCluster

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
Serialize
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
SerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
SerializeTaggedProperties
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_21_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
NotifyObjectReferenceEliminated
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
SerializeSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_22_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_23_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
Modify
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_24_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetSparseClassDataStruct
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetStructTypeHash
GetComputedPropertyFlags
IsAbstract

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
Realloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_25_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetSparseClassDataStruct
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal
ValidateGeneratedRepEnums
SetNetPushIdDynamic
GetNetPushIdDynamic

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetStructTypeHash
GetComputedPropertyFlags
IsAbstract

[FField]
__vecDelDtor
Serialize
PostLoad
GetPreloadDependencies
BeginDestroy
AddReferencedObjects
AddCppProperty
Bind
PostDuplicate
GetInnerFieldByName

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
ContainsWeakObjectReference
EmitReferenceInfo
SameType

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
; FString GetAuthoredNameForField(param_count: 1, );
GetAuthoredNameForField_2
IsStructTrashed
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
TryMalloc
Realloc
TryRealloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_26_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PreDuplicate
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetSparseClassDataStruct
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal
ValidateGeneratedRepEnums
SetNetPushIdDynamic
GetNetPushIdDynamic

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetStructTypeHash
GetComputedPropertyFlags
IsAbstract

[FField]
__vecDelDtor
Serialize
PostLoad
GetPreloadDependencies
BeginDestroy
AddReferencedObjects
AddCppProperty
Bind
PostDuplicate
GetInnerFieldByName
GetInnerFields

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
EmitReferenceInfo
SameType

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, FArchive& Ar, void* Data);
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
; FString GetAuthoredNameForField(param_count: 1, );
GetAuthoredNameForField_2
IsStructTrashed
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
TryMalloc
Realloc
TryRealloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_4_27_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostCDOContruct
PreSaveRoot
PostSaveRoot
PreSave
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, );
Serialize_2
ShutdownAfterError
PostInterpChange
PostRename
PreDuplicate
PostDuplicate
; void PostDuplicate(param_count: 1, );
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
HasNonEditorOnlyReferences
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetSparseClassDataStruct
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal
ValidateGeneratedRepEnums
SetNetPushIdDynamic
GetNetPushIdDynamic

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
ConstructForTests
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
IsPlainOldData
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetStructTypeHash
GetComputedPropertyFlags
IsAbstract

[FField]
__vecDelDtor
Serialize
PostLoad
GetPreloadDependencies
BeginDestroy
AddReferencedObjects
AddCppProperty
Bind
PostDuplicate
GetInnerFieldByName
GetInnerFields

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
EmitReferenceInfo
SameType

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, );
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, );
SerializeTaggedProperties_2
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
; FString GetAuthoredNameForField(param_count: 1, );
GetAuthoredNameForField_2
IsStructTrashed
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
TryMalloc
Realloc
TryRealloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, );
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
AllowCrossLevel
CheckValidObject


```

`Staging/VTableLayoutTemplates/VTableLayout_5_00_Template.ini`:

```ini
[UObjectBase]
__vecDelDtor
RegisterDependencies
DeferredRegister

[UObjectBaseUtility]
__vecDelDtor
CanBeClusterRoot
CanBeInCluster
CreateCluster
OnClusterMarkedAsPendingKill

[UObject]
__vecDelDtor
GetDetailedInfoInternal
PostInitProperties
PostReinitProperties
PostCDOContruct
PreSaveRoot
; bool PreSaveRoot(param_count: 1, TCHAR* Filename);
PreSaveRoot_2
PostSaveRoot
; void PostSaveRoot(param_count: 1, bool bCleanupIsRequired);
PostSaveRoot_2
PreSave
; void PreSave(param_count: 1, ITargetPlatform* TargetPlatform);
PreSave_2
ResolveSubobject
IsReadyForAsyncPostLoad
PostLoad
PostLoadSubobjects
BeginDestroy
IsReadyForFinishDestroy
FinishDestroy
Serialize
; void Serialize(param_count: 1, FArchive& Ar);
Serialize_2
DeclareCustomVersions
ShutdownAfterError
PostInterpChange
PostRename
PreDuplicate
PostDuplicate
; void PostDuplicate(param_count: 1, bool bDuplicateForPIE);
PostDuplicate_2
NeedsLoadForClient
NeedsLoadForServer
NeedsLoadForTargetPlatform
NeedsLoadForEditorGame
IsEditorOnly
HasNonEditorOnlyReferences
IsPostLoadThreadSafe
IsDestructionThreadSafe
GetPreloadDependencies
GetPrestreamPackages
ExportCustomProperties
ImportCustomProperties
PostEditImport
PostReloadConfig
Rename
GetDesc
GetWorld
GetNativePropertyValues
GetResourceSizeEx
GetExporterName
GetRestoreForUObjectOverwrite
AreNativePropertiesIdenticalTo
GetAssetRegistryTags
GetExternalActorExtendedAssetRegistryTags
IsAsset
GetPrimaryAssetId
IsLocalizedResource
IsSafeForRootSet
TagSubobjects
GetLifetimeReplicatedProps
IsNameStableForNetworking
IsFullNameStableForNetworking
IsSupportedForNetworking
GetSubobjectsWithStableNamesForNetworking
PreNetReceive
PostNetReceive
PostRepNotifies
PreDestroyFromReplication
BuildSubobjectMapping
GetConfigOverridePlatform
OverrideConfigSection
OverridePerObjectConfigSection
ProcessEvent
GetFunctionCallspace
CallRemoteFunction
ProcessConsoleExec
RegenerateClass
MarkAsEditorOnlySubobject
CheckDefaultSubobjectsInternal
ValidateGeneratedRepEnums
SetNetPushIdDynamic
GetNetPushIdDynamic

[UScriptStruct::ICppStructOps]
__vecDelDtor
HasNoopConstructor
HasZeroConstructor
Construct
ConstructForTests
HasDestructor
Destruct
HasSerializer
HasStructuredSerializer
Serialize
; bool Serialize(param_count: 2, );
Serialize_2
HasPostSerialize
PostSerialize
HasNetSerializer
HasNetSharedSerialization
NetSerialize
HasNetDeltaSerializer
NetDeltaSerialize
HasPostScriptConstruct
PostScriptConstruct
GetPreloadDependencies
IsPlainOldData
IsUECoreType
IsUECoreVariant
HasCopy
Copy
HasIdentical
Identical
HasExportTextItem
ExportTextItem
HasImportTextItem
ImportTextItem
HasAddStructReferencedObjects
AddStructReferencedObjects
HasSerializeFromMismatchedTag
HasStructuredSerializeFromMismatchedTag
SerializeFromMismatchedTag
StructuredSerializeFromMismatchedTag
HasGetTypeHash
GetStructTypeHash
GetComputedPropertyFlags
IsAbstract

[FField]
__vecDelDtor
Serialize
PostLoad
GetPreloadDependencies
BeginDestroy
AddReferencedObjects
AddCppProperty
Bind
PostDuplicate
GetInnerFieldByName
GetInnerFields

[FNumericProperty]
__vecDelDtor
IsFloatingPoint
IsInteger
GetIntPropertyEnum
SetIntPropertyValue
; void SetIntPropertyValue(param_count: 2, void* Data, uint64 Value);
SetIntPropertyValue_2
SetFloatingPointPropertyValue
SetNumericPropertyValueFromString
GetSignedIntPropertyValue
GetUnsignedIntPropertyValue
GetFloatingPointPropertyValue
GetNumericPropertyValueToString
CanHoldDoubleValueInternal
CanHoldSignedValueInternal
CanHoldUnsignedValueInternal

[FMulticastDelegateProperty]
__vecDelDtor
GetMulticastDelegate
SetMulticastDelegate
AddDelegate
RemoveDelegate
ClearDelegate
GetInvocationList

[FOutputDevice]
__vecDelDtor
Serialize
; void Serialize(param_count: 3, );
Serialize_2
Flush
TearDown
Dump
IsMemoryOnly
CanBeUsedOnAnyThread
CanBeUsedOnMultipleThreads

[FProperty]
__vecDelDtor
GetCPPMacroType
PassCPPArgsByRef
GetCPPType
GetCPPTypeForwardDeclaration
LinkInternal
ConvertFromType
Identical
SerializeItem
NetSerializeItem
SupportsNetSharedSerialization
ExportTextItem
ImportText_Internal
CopyValuesInternal
GetValueTypeHashInternal
CopySingleValueToScriptVM
CopyCompleteValueToScriptVM
CopySingleValueFromScriptVM
CopyCompleteValueFromScriptVM
ClearValueInternal
DestroyValueInternal
InitializeValueInternal
GetID
InstanceSubobjects
GetMinAlignment
ContainsObjectReference
EmitReferenceInfo
SameType

[UStruct]
__vecDelDtor
GetInheritanceSuper
Link
SerializeBin
; void SerializeBin(param_count: 2, FArchive& Ar, void* Data);
SerializeBin_2
SerializeTaggedProperties
; void SerializeTaggedProperties(param_count: 5, FArchive& Ar, uint8* Data, UStruct* DefaultsStruct, uint8* Defaults, UObject* BreakRecursionIfFullyLoad);
SerializeTaggedProperties_2
PreloadChildren
InitializeStruct
DestroyStruct
CustomFindProperty
SerializeExpr
GetPrefixCPP
SetSuperStruct
PropertyNameToDisplayName
GetAuthoredNameForField
; FString GetAuthoredNameForField(param_count: 1, UField* Field);
GetAuthoredNameForField_2
IsStructTrashed
FindPropertyNameFromGuid
FindPropertyGuidFromName
ArePropertyGuidsAvailable

[UField]
__vecDelDtor
AddCppProperty
Bind

[FMalloc]
__vecDelDtor
Malloc
TryMalloc
Realloc
TryRealloc
Free
QuantizeSize
GetAllocationSize
Trim
SetupTLSCachesOnCurrentThread
ClearAndDisableTLSCachesOnCurrentThread
InitializeStatsMetadata
UpdateStats
GetAllocatorStats
DumpAllocatorStats
IsInternallyThreadSafe
ValidateHeap
GetDescriptiveName

[FObjectPropertyBase]
__vecDelDtor
GetCPPTypeCustom
LoadObjectPropertyValue
GetObjectPropertyValue
SetObjectPropertyValue
CheckValidObject
AllowCrossLevel
AllowObjectTypeReinterpretationTo


```

`TODO.txt`:

```txt
The 'Unreal' module
{
    The function 'Internal::UnrealScriptFunctionHook' should have an error handler mechanism.
    That way we can execute 'luaL_traceback' (or handle_lua_error) without involving Lua in the 'Unreal' module.
}

UE4SS
{
    Lua 2.0 must be integrated properly with the 'Mod' class.
    After that we can put all the static variables in there and clean them up upon reinstall/uninstall and unregister hooks etc.

    Change the 'FindAllOf' custom implementation to return a Lua table instead of Array.
    As good and fun as it is to be able to return an Array, it breaks compatibility with UE4SS 1.3.

    Make "RegisterHook" and "NotifyOnNewObject" callbacks and probably any other possibly-async code execution use a different lua state.
    Prefer to use luaL_newstate over lua_newthread if possible. May need to setup some complicated system for safe cross-state variable or environment access.
}

```

`Tests/UE4SSProgramTest.cpp`:

```cpp
#define NOMINMAX

#include <limits>
#include <type_traits>
#include "UE4SSProgramTest.hpp"
#include <Unreal/TypeChecker.hpp>
#include <UnrealDef.hpp>
#include <Timer/ScopedTimer.hpp>
#include <Timer/FunctionTimer.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Unreal/Hooks.hpp>

#define assert_test(expression, notification) \
if (!(expression)) { throw std::runtime_error{fmt("Test failed -> %S",  notification)}; }

namespace RC
{
    enum class TestableEnumClass
    {
        ClassValueOne,
        ClassValueTwo,
        ClassValueThree,
    };

    class ACharacter : public Unreal::UObject
    {
        ACharacter() = default;

    public:
        struct CanJumpInternal_Params {};
        auto CanJumpInternal() -> bool
        {
            CanJumpInternal_Params params{};
            UFunction* function = UObjectGlobals::static_find_object<UFunction*>(nullptr, nullptr, L"/Script/Engine.Character:CanJumpInternal");

            process_event(function, &params);
        }
    };

    class UCharacterMovementComponent : public Unreal::UObject
    {
        UCharacterMovementComponent() = default;

    public:
        struct SetMovementMode_Params
        {
            uint8_t NewMovementMode;
            uint8_t NewCustomMode;
        };

        auto SetMovementMode(uint8_t NewMovementMode, uint8_t NewCustomMode) -> void
        {
            SetMovementMode_Params params{NewMovementMode, NewCustomMode};
            UFunction* function = UObjectGlobals::static_find_object<UFunction*>(nullptr, nullptr, L"/Script/Engine.CharacterMovementComponent:SetMovementMode");

            process_event(function, &params);
        }
    };

    UE4SSProgramTest::UE4SSProgramTest(const std::wstring& moduleFilePath, std::initializer_list<BinaryOptions> options) : UE4SSProgram(moduleFilePath, options)
    {
        // Don't execute this test program if we already have errors
        if (auto e = get_error_object(); e->has_error()) { return; }

        try
        {
            m_input_handler.register_keydown_event(Input::Key::K, [&]() {
                Output::send(STR("Executing function call tests...\n"));
                execute_function_call_tests();
                Output::send(STR("Function call tests executed\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::HOME, [&]() {
                Output::send(STR("VK_HOME down event\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::J, [&]() {
                Output::send(STR("J was hit\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::J, {Input::ModifierKey::ALT}, [&]() {
                Output::send(STR("ALT + J was hit\n"));
            });

            // Input handler, multi-key tests -> START
            m_input_handler.register_keydown_event(Input::Key::P, [](){
                Output::send(STR("P was hit\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::P, [](){
                Output::send(STR("P was hit / event two\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::P, {Input::ModifierKey::ALT}, [](){
                Output::send(STR("ALT + P was hit\n"));
            });

            m_input_handler.register_keydown_event(Input::Key::P, {Input::ModifierKey::CONTROL}, [](){
                Output::send(STR("Dumping all timed functions\n"));
                FunctionTimerCollection::dump();
            });

            // This one triggers both the "ALT + P" & "CTRL + ALT + P" keydown events
            // All the other events seem fine, so for now we'll just avoid using more than one modifier key
            m_input_handler.register_keydown_event(Input::Key::P, {Input::ModifierKey::CONTROL, Input::ModifierKey::ALT}, [](){
                Output::send(STR("CTRL + ALT + P was hit\n"));
            });

            Output::send(STR("Executing generic tests...\n"));
            execute_tests();
            Output::send(STR("Generic tests executed\n"));

            // Program is now fully setup
            // Start event loop
            m_event_loop = std::jthread{&UE4SSProgramTest::update, this};

            // Wait for thread
            // There's a loop inside the thread that only exits when you hit the 'End' key on the keyboard
            // As long as you don't do that the thread will stay open and accept further inputs
            m_event_loop.join();
        }
        catch (std::runtime_error& e)
        {
            // Returns to main from here which checks, displays & handles whether to close the program or not
            // If has_error() returns false that means that set_error was not called
            // In that case we need to copy the exception message to the error buffer before we return to main
            if (!m_error_object->has_error())
            {
                copy_error_into_message(e.what());

            }
            return;
        }
    }

    auto UE4SSProgramTest::execute_tests() -> void
    {
        TIME_FUNCTION()
        // For testing only!!!

        Output::send(STR("##### CORE OBJECTS DUMP -> START #####\n\n"));
        Unreal::TypeChecker::dump_all_stored_object_types(
                [](uint32_t index, uint32_t number) {
                    FName name{index, number};
                    Output::send(STR("Name: {:#x} | Number: {:#x} | ToString(): {}\n"), index, number, name.to_string());
                },
                [](const std::wstring& obj_name, void* obj_ptr) {
                    Output::send(STR("ptr: {} | obj_name: {}\n"), obj_ptr, obj_name);
                }
        );
        Output::send(STR("\n##### CORE OBJECTS DUMP -> END #####\n\n"));

        auto dump_property_flags = [](Unreal::EPropertyFlags flags) {
            std::wstring all_flags{};

            // (get_property_flags() & flags_to_check) != 0 || flags_to_check == CPF_AllFlags;

            if ((flags & Unreal::EPropertyFlags::CPF_None) != 0) { all_flags.append(STR("CPF_None | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Edit) != 0) { all_flags.append(STR("CPF_Edit | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ConstParm) != 0) { all_flags.append(STR("CPF_ConstParm | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_BlueprintVisible) != 0) { all_flags.append(STR("CPF_BlueprintVisible | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ExportObject) != 0) { all_flags.append(STR("CPF_ExportObject | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_BlueprintReadOnly) != 0) { all_flags.append(STR("CPF_BlueprintReadOnly | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Net) != 0) { all_flags.append(STR("CPF_Net | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_EditFixedSize) != 0) { all_flags.append(STR("CPF_EditFixedSize | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Parm) != 0) { all_flags.append(STR("CPF_Parm | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_OutParm) != 0) { all_flags.append(STR("CPF_OutParm | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ZeroConstructor) != 0) { all_flags.append(STR("CPF_ZeroConstructor | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ReturnParm) != 0) { all_flags.append(STR("CPF_ReturnParm | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_DisableEditOnTemplate) != 0) { all_flags.append(STR("CPF_DisableEditOnTemplate | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Transient) != 0) { all_flags.append(STR("CPF_Transient | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Config) != 0) { all_flags.append(STR("CPF_Config | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_DisableEditOnInstance) != 0) { all_flags.append(STR("CPF_DisableEditOnInstance | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_EditConst) != 0) { all_flags.append(STR("CPF_EditConst | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_GlobalConfig) != 0) { all_flags.append(STR("CPF_GlobalConfig | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_InstancedReference) != 0) { all_flags.append(STR("CPF_InstancedReference | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_DuplicateTransient) != 0) { all_flags.append(STR("CPF_DuplicateTransient | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_SubobjectReference) != 0) { all_flags.append(STR("CPF_SubobjectReference | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_SaveGame) != 0) { all_flags.append(STR("CPF_SaveGame | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NoClear) != 0) { all_flags.append(STR("CPF_NoClear | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ReferenceParm) != 0) { all_flags.append(STR("CPF_ReferenceParm | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_BlueprintAssignable) != 0) { all_flags.append(STR("CPF_BlueprintAssignable | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Deprecated) != 0) { all_flags.append(STR("CPF_Deprecated | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_IsPlainOldData) != 0) { all_flags.append(STR("CPF_IsPlainOldData | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_RepSkip) != 0) { all_flags.append(STR("CPF_RepSkip | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_RepNotify) != 0) { all_flags.append(STR("CPF_RepNotify | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Interp) != 0) { all_flags.append(STR("CPF_Interp | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NonTransactional) != 0) { all_flags.append(STR("CPF_NonTransactional | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_EditorOnly) != 0) { all_flags.append(STR("CPF_EditorOnly | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NoDestructor) != 0) { all_flags.append(STR("CPF_NoDestructor | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_AutoWeak) != 0) { all_flags.append(STR("CPF_AutoWeak | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ContainsInstancedReference) != 0) { all_flags.append(STR("CPF_ContainsInstancedReference | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_AssetRegistrySearchable) != 0) { all_flags.append(STR("CPF_AssetRegistrySearchable | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_SimpleDisplay) != 0) { all_flags.append(STR("CPF_SimpleDisplay | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_AdvancedDisplay) != 0) { all_flags.append(STR("CPF_AdvancedDisplay | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_Protected) != 0) { all_flags.append(STR("CPF_Protected | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_BlueprintCallable) != 0) { all_flags.append(STR("CPF_BlueprintCallable | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_BlueprintAuthorityOnly) != 0) { all_flags.append(STR("CPF_BlueprintAuthorityOnly | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_TextExportTransient) != 0) { all_flags.append(STR("CPF_TextExportTransient | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NonPIEDuplicateTransient) != 0) { all_flags.append(STR("CPF_NonPIEDuplicateTransient | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_ExposeOnSpawn) != 0) { all_flags.append(STR("CPF_ExposeOnSpawn | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_PersistentInstance) != 0) { all_flags.append(STR("CPF_PersistentInstance | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_UObjectWrapper) != 0) { all_flags.append(STR("CPF_UObjectWrapper | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_HasGetValueTypeHash) != 0) { all_flags.append(STR("CPF_HasGetValueTypeHash | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NativeAccessSpecifierPublic) != 0) { all_flags.append(STR("CPF_NativeAccessSpecifierPublic | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NativeAccessSpecifierProtected) != 0) { all_flags.append(STR("CPF_NativeAccessSpecifierProtected | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_NativeAccessSpecifierPrivate) != 0) { all_flags.append(STR("CPF_NativeAccessSpecifierPrivate | ")); }
            if ((flags & Unreal::EPropertyFlags::CPF_SkipSerialization) != 0) { all_flags.append(STR("CPF_SkipSerialization | ")); }

            Output::send(STR("property_flags: {}\n"), all_flags);
        };

        Unreal::EPropertyFlags prop_flags_one{0x0010001040000205};
        Unreal::EPropertyFlags prop_flags_two{0x0018001040000005};
        Unreal::EPropertyFlags prop_flags_three{0x0018001040000205};
        Unreal::EPropertyFlags prop_flags_four{0x0018001040000205};
        dump_property_flags(prop_flags_one);
        dump_property_flags(prop_flags_two);
        dump_property_flags(prop_flags_three);
        dump_property_flags(prop_flags_four);

        auto dump_flags = [](EObjectFlags flags) {
            std::wstring all_flags{};

            if (flags & EObjectFlags::RF_NoFlags) { all_flags.append(STR("NoFlags | ")); }
            if (flags & EObjectFlags::RF_Public) { all_flags.append(STR("Public | ")); }
            if (flags & EObjectFlags::RF_Standalone) { all_flags.append(STR("Standalone | ")); }
            if (flags & EObjectFlags::RF_MarkAsNative) { all_flags.append(STR("MarkAsNative | ")); }
            if (flags & EObjectFlags::RF_Transactional) { all_flags.append(STR("Transactional | ")); }
            if (flags & EObjectFlags::RF_ClassDefaultObject) { all_flags.append(STR("ClassDefaultObject | ")); }
            if (flags & EObjectFlags::RF_ArchetypeObject) { all_flags.append(STR("ArchetypeObject | ")); }
            if (flags & EObjectFlags::RF_Transient) { all_flags.append(STR("Transient | ")); }
            if (flags & EObjectFlags::RF_MarkAsRootSet) { all_flags.append(STR("MarkAsRootSet | ")); }
            if (flags & EObjectFlags::RF_TagGarbageTemp) { all_flags.append(STR("TagGarbageTemp | ")); }
            if (flags & EObjectFlags::RF_NeedInitialization) { all_flags.append(STR("NeedInitialization | ")); }
            if (flags & EObjectFlags::RF_NeedLoad) { all_flags.append(STR("NeedLoad | ")); }
            if (flags & EObjectFlags::RF_KeepForCooker) { all_flags.append(STR("KeepForCooker | ")); }
            if (flags & EObjectFlags::RF_NeedPostLoad) { all_flags.append(STR("NeedPostLoad | ")); }
            if (flags & EObjectFlags::RF_NeedPostLoadSubobjects) { all_flags.append(STR("NeedPostLoadSubobjects | ")); }
            if (flags & EObjectFlags::RF_NewerVersionExists) { all_flags.append(STR("NewerVersionExists | ")); }
            if (flags & EObjectFlags::RF_BeginDestroyed) { all_flags.append(STR("BeginDestroyed | ")); }
            if (flags & EObjectFlags::RF_FinishDestroyed) { all_flags.append(STR("FinishDestroyed | ")); }
            if (flags & EObjectFlags::RF_BeingRegenerated) { all_flags.append(STR("BeingRegenerated | ")); }
            if (flags & EObjectFlags::RF_DefaultSubObject) { all_flags.append(STR("DefaultSubObject | ")); }
            if (flags & EObjectFlags::RF_WasLoaded) { all_flags.append(STR("WasLoaded | ")); }
            if (flags & EObjectFlags::RF_TextExportTransient) { all_flags.append(STR("TextExportTransient | ")); }
            if (flags & EObjectFlags::RF_LoadCompleted) { all_flags.append(STR("LoadCompleted | ")); }
            if (flags & EObjectFlags::RF_InheritableComponentTemplate) { all_flags.append(STR("InheritableComponentTemplate | ")); }
            if (flags & EObjectFlags::RF_DuplicateTransient) { all_flags.append(STR("DuplicateTransient | ")); }
            if (flags & EObjectFlags::RF_StrongRefOnFrame) { all_flags.append(STR("StrongRefOnFrame | ")); }
            if (flags & EObjectFlags::RF_NonPIEDuplicateTransient) { all_flags.append(STR("NonPIEDuplicateTransient | ")); }
            if (flags & EObjectFlags::RF_Dynamic) { all_flags.append(STR("Dynamic | ")); }
            if (flags & EObjectFlags::RF_WillBeLoaded) { all_flags.append(STR("WillBeLoaded | ")); }

            Output::send(STR("\tget_flags(): {:#X} | {}\n"), static_cast<uint32_t>(flags), all_flags);
        };

        auto dump_obj_flags = [&]([[maybe_unused]]UObject* obj) {
            //std::string all_flags{};

            //auto flags = obj->get_flags();
            //dump_flags(flags);
        };

        auto dump_properties = [](UObject* obj) {
            constexpr uint32_t max_props_to_dump{4};
            uint32_t num_props_dumped{};


            UClass* obj_as_class = reinterpret_cast<UClass*>(obj);
            for (XProperty* children = obj_as_class->get_childproperties<XProperty*>(); children && num_props_dumped < max_props_to_dump; children = children->get_next<XProperty*>())
            {
                XProperty* type_ptr = std::bit_cast<XProperty*>(children->static_class().to_field());

                // Can't use GetFullName until the FField version has been implemented
                Output::send(STR("\t\t{} {{\n"), children->get_fname().to_string().c_str());
                Output::send(STR("\t\t\ttype: {} ({})\n"), (void*)children->get_ffieldclass(), children->get_type_fname().to_string());
                // Yes this is a very bizarre place to put '::' but for this test code I need to access the function that XField hides
                Output::send(STR("\t\t\tstatic_obj: {} ({})\n"), (void*)type_ptr, type_ptr->get_fname().to_string().c_str());

                if (UObject* owner = children->get_owner(); owner)
                {
                    Output::send(STR("\t\t\tOwner: {} ({})\n"), (void*)owner, owner->get_fname().to_string().c_str());
                }
                else
                {
                    Output::send(STR("\t\t\tOwner: None\n"));
                }

                Output::send(STR("\t\t\tOffset_Internal: {:#x}\n"), static_cast<XProperty*>(children)->get_offset_for_internal());

                Output::send(STR("\t\t}\n"));

                ++num_props_dumped;
            }

            if (num_props_dumped > 0)
            {
                Output::send(STR("\t\t...\n"));
            }
        };

        auto dump_object = [&](UObject* obj) {
            if (!obj)
            {
                Output::send(STR("Tried dumping nullptr obj\n"));
                return;
            }

            FName name = obj->get_fname();
            UClass* uclass = obj->get_uclass();

            XProperty* type_ptr = std::bit_cast<XProperty*>(obj->static_class());

            Output::send(STR("{} {} {{\n"), (void*)obj, obj->get_full_name());
            Output::send(STR("\tstatic_obj: {} ({})\n"), (void*)type_ptr, type_ptr->get_fname().to_string().c_str());
            Output::send(STR("\tinternal_index: {:#x}\n"), obj->get_internal_index());
            Output::send(STR("\tuclass: {} {}\n"), (void*)uclass, uclass->get_full_name());
            Output::send(STR("\tfname.comparison_index: {:#x}\n"), name.get_comparison_index());
            Output::send(STR("\tfname.number: {:#x}\n"), name.get_number());
            Output::send(STR("\tfname.to_string(): {}\n"), name.to_string().c_str());
            Output::send(STR("\touter: {} {}\n"), (void*)obj->get_outer(), obj->get_outer()->get_full_name());
            Output::send(STR("\ttype.as_string(): {}\n"), obj->get_type().as_string().c_str());
            Output::send(STR("\tget_name(): {}\n"), obj->get_name().c_str());
            dump_obj_flags(obj);
            Output::send(STR("\tis transient: {}\n"), obj->has_any_flag(EObjectFlags::RF_Transient) ? STR("yes") : STR("no"));
            Output::send(STR("\twas loaded: {}\n"), obj->has_any_flag(EObjectFlags::RF_WasLoaded) ? STR("yes") : STR("no"));
            Output::send(STR("\tis public or standalone: {}\n"), obj->has_any_flag(static_cast<EObjectFlags>(EObjectFlags::RF_Public | EObjectFlags::RF_Standalone)) ? STR("yes") : STR("no"));
            Output::send(STR("\tis function: {}\n"), obj->is_function() ? STR("yes") : STR("no"));

            if (obj->is_function())
            {
                // Casting to UClass because UFunction does not exist yet but I want access to some UStruct stuff
                // This is dangerous, don't do this in actual code
                Output::send(STR("\tproperties_size: {:#x}\n"), ((UClass*)obj)->get_properties_size());
                Output::send(STR("\tmin_alignment: {:#x}\n"), ((UClass*)obj)->get_min_alignment());
            }

            Output::send(STR("\tProperties: {\n"));

            if (obj->is_class())
            {
                UClass* obj_as_class = reinterpret_cast<UClass*>(obj);
                dump_properties(obj_as_class);
            }

            dump_properties(uclass);

            Output::send(STR("\t}\n"));

            Output::send(STR("}\n"));
        };

        UObject* obj = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Script/CoreUObject.Object");
        dump_object(obj);

        UObject* engine_object1 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Engine/Transient.FGGameEngine_0");
        dump_object(engine_object1);

        UObject* engine_object2 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Engine/Transient.FGGameEngine_2147482616");
        dump_object(engine_object2);

        UObject* engine_object3 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Engine/Transient.TestableGameEngine_2147482618");
        dump_object(engine_object3);

        UObject* engine_object4 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Engine/Transient.GameEngine_2147482618");
        dump_object(engine_object4);

        UObject* engine_object5 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Engine/Transient.GameEngine_0");
        dump_object(engine_object5);

        UObject* obj4 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Script/CoreUObject.Default__Function");
        dump_object(obj4);

        UObject* obj5 = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Script/CoreUObject.Object:ExecuteUbergraph");
        dump_object(obj5);

        UStruct* obj6 = UObjectGlobals::static_find_object<UStruct*>(nullptr, nullptr, L"/Script/Engine.Actor");
        dump_object(obj6);

        // Property Tests -> START
        // For game: Satisfactory CL#151024 (UE4.25.3.0)
        UObject* default_actor = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Script/Engine.Default__Actor");
        dump_object(default_actor);

        auto test_bool_prop = [](UObject* obj, const wchar_t* prop_name, bool expected_val = false, bool do_test = false) -> bool {
            void* addr = obj->get_property_data_ptr(prop_name);
            if (!addr)
            {
                Output::send(STR("[ERROR] Property '{}' not found in UObject '{}'\n"), fmt(STR("%S"), prop_name), (void*)obj);
                return false;
            }
            else
            {
                bool val = obj->get_property<bool>(prop_name);
                Output::send(STR("{} (val: {} | expected: {}) <- {}\n"), addr, val ? STR("true") : STR("false"), expected_val ? STR("true") : STR("false"), fmt(L"%s", prop_name));
                if (do_test) { assert_test(val == expected_val, fmt(STR("BoolProperty (bitfield -> %s)"), prop_name).c_str())}
                return val;
            }
        };

        if (default_actor)
        {
            uint8_t* remote_role_val = default_actor->get_property<uint8_t>(L"RemoteRole");
            Output::send(STR("remote_role: {} (addr: {})\n"), *remote_role_val, (void*)remote_role_val);

            // Bitfield #1
            Output::send(STR("Dumping bitfield #1\n"));
            test_bool_prop(default_actor, L"bNetTemporary");
            test_bool_prop(default_actor, L"bNetStartup");
            test_bool_prop(default_actor, L"bOnlyRelevantToOwner");
            test_bool_prop(default_actor, L"bAlwaysRelevant");
            test_bool_prop(default_actor, L"bReplicateMovement");
            test_bool_prop(default_actor, L"bHidden");
            test_bool_prop(default_actor, L"bTearOff");
            test_bool_prop(default_actor, L"bExchangedRoles");

            // Bitfield #2
            Output::send(STR("Dumping bitfield #2\n"));
            test_bool_prop(default_actor, L"bNetLoadOnClient");
            test_bool_prop(default_actor, L"bNetUseOwnerRelevancy");
            test_bool_prop(default_actor, L"bRelevantForNetworkReplays");
            test_bool_prop(default_actor, L"bRelevantForLevelBounds");
            test_bool_prop(default_actor, L"bReplayRewindable");
            test_bool_prop(default_actor, L"bAllowTickBeforeBeginPlay");
            test_bool_prop(default_actor, L"bAutoDestroyWhenFinished");
        }

        // Is this how reading/writing values from/to UObjects should work ?
        if (engine_object1)
        {
            auto* int_val = engine_object1->get_property<int32_t>(L"ScreenSaverInhibitorSemaphore");
            auto* float_val = engine_object1->get_property<float>(L"ServerFlushLogInterval");

            Output::send(STR("int_val (#1): {} (addr: {})\n"), *int_val, (void*)int_val);
            Output::send(STR("float_val (#1): {} (addr: {})\n"), *float_val, (void*)float_val);
            //engine_obj->write<int32_t>("ScreenSaverInhibitorSemaphore", 1);
        }
        else
        {
            Output::send(STR("no engine object #1\n"));
        }

        if (engine_object2)
        {
            auto* int_val = engine_object2->get_property<int32_t>(L"ScreenSaverInhibitorSemaphore");
            auto* float_val = engine_object2->get_property<float>(L"ServerFlushLogInterval");

            Output::send(STR("int_val (#1): {} (addr: {})\n"), *int_val, (void*)int_val);
            Output::send(STR("float_val (#1): {} (addr: {})\n"), *float_val, (void*)float_val);
            //engine_obj->write<int32_t>("ScreenSaverInhibitorSemaphore", 1);

            test_bool_prop(engine_object2, L"bRenderLightMapDensityGrayscale");
            test_bool_prop(engine_object2, L"bHardwareSurveyEnabled");
            test_bool_prop(engine_object2, L"bSubtitlesEnabled");
            test_bool_prop(engine_object2, L"bSubtitlesForcedOff");
            test_bool_prop(engine_object2, L"bCanBlueprintsTickByDefault");
            test_bool_prop(engine_object2, L"bOptimizeAnimBlueprintMemberVariableAccess");
            test_bool_prop(engine_object2, L"bAllowMultiThreadedAnimationUpdate");
            test_bool_prop(engine_object2, L"bEnableEditorPSysRealtimeLOD");
            test_bool_prop(engine_object2, L"bSmoothFrameRate");
            test_bool_prop(engine_object2, L"bUseFixedFrameRate");

            UObject** game_viewport = engine_object2->get_property<UObject>(L"GameViewport");
            Output::send(STR("GameViewport: {}\n"), (void*)*game_viewport);

            UObject* asset_manager = *engine_object2->get_property<UObject>(L"AssetManager");
            Output::send(STR("asset_manager: {}\n"), (void*)asset_manager);

            TArray<UObject*> object_reference_list = asset_manager->get_property<TArray<UObject*>>(L"ObjectReferenceList");
            Output::send(STR("Manual access -> START\n"));
            if (object_reference_list.get_array_num() >= 4)
            {
                Output::send(STR("object_reference_list[0]: {} (&:{})\n"), (void*)*object_reference_list[0], (void*)object_reference_list[0]);
                Output::send(STR("object_reference_list[1]: {} (&:{})\n"), (void*)*object_reference_list[1], (void*)object_reference_list[1]);
                Output::send(STR("object_reference_list[2]: {} (&:{})\n"), (void*)*object_reference_list[2], (void*)object_reference_list[2]);
                Output::send(STR("object_reference_list[3]: {} (&:{})\n"), (void*)*object_reference_list[3], (void*)object_reference_list[3]);
            }
            Output::send(STR("Manual access -> END\n"));

            Output::send(STR("Loop access (with both elem & index passed) -> START\n"));
            object_reference_list.for_each([](UObject** elem, size_t index) {
                Output::send(STR("elem: {} (&elem: {}) | index: {}\n"), (void*)*elem, (void*)elem, index);
                return LoopAction::Continue;
            });
            Output::send(STR("Loop access (with both elem & index passed) -> END\n"));

            Output::send(STR("Loop access (with only elem passed) -> START\n"));
            object_reference_list.for_each([](UObject** elem) {
                Output::send(STR("elem: {} (&elem: {})\n"), (void*)*elem, (void*)elem);
                return LoopAction::Continue;
            });
            Output::send(STR("Loop access (with only elem passed) -> END\n"));
        }
        else
        {
            Output::send(STR("no engine object #2\n"));
        }

        if (engine_object3)
        {
            // TODO: Turn all of this into proper tests

            // Numerical Tests
            // TODO: uint8/byte, uint16, uint32, uint64
            int8_t* int8_val = engine_object3->get_property<int8_t>(L"m_testable_int8");
            Output::send(STR("{} (val: {} | expected: {}) <- int8\n"), (void*)int8_val, *int8_val, std::numeric_limits<int8_t>::max());
            assert_test(*int8_val == std::numeric_limits<int8_t>::max(), STR("Int8Property"))

            int16_t* int16_val = engine_object3->get_property<int16_t>(L"m_testable_int16");
            Output::send(STR("{} (val: {} | expected: {}) <- int16\n"), (void*)int16_val, *int16_val, std::numeric_limits<int16_t>::max());
            assert_test(*int16_val == std::numeric_limits<int16_t>::max(), STR("Int16Property"))

            int32_t* int32_val = engine_object3->get_property<int32_t>(L"m_testable_int32");
            Output::send(STR("{} (val: {} | expected: {}) <- int32\n"), (void*)int32_val, *int32_val, std::numeric_limits<int32_t>::max());
            assert_test(*int32_val == std::numeric_limits<int32_t>::max(), STR("IntProperty"))

            int64_t* int64_val = engine_object3->get_property<int64_t>(L"m_testable_int64");
            Output::send(STR("{} (val: {} | expected: {}) <- int64\n"), (void*)int64_val, *int64_val, std::numeric_limits<int64_t>::max());
            assert_test(*int64_val == std::numeric_limits<int64_t>::max(), STR("Int64Property"))

            // uint8 / byte
            uint8_t* byte_val = engine_object3->get_property<uint8_t>(L"m_testable_uint8");
            Output::send(STR("{} (val: {} | expected: {}) <- byte\n"), (void*)byte_val, *byte_val, std::numeric_limits<uint8_t>::max());
            assert_test(*byte_val == std::numeric_limits<uint8_t>::max(), STR("ByteProperty"))

            float* float_val = engine_object3->get_property<float>(L"m_testable_float");
            Output::send(STR("{} (val: {} | expected: {}) <- float\n"), (void*)float_val, *float_val, 99.4f);
            assert_test(*float_val == 99.4f, STR("FloatProperty"))

            // Bool Tests
            // C++ bool
            void* bool_addr = engine_object3->get_property_data_ptr(L"m_testable_bool");
            bool bool_val = engine_object3->get_property<bool>(L"m_testable_bool");
            Output::send(STR("{} (val: {} | expected: {}) <- c++ bool\n"), bool_addr, bool_val ? STR("true") : STR("false"), STR("true"));
            assert_test(bool_val == true, STR("BoolProperty (C++ bool)"))

            // Bitfield
            test_bool_prop(engine_object3, L"m_testable_bool_bit1", true, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit2", true, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit3", true, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit4", false, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit5", false, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit6", true, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit7", true, true);
            test_bool_prop(engine_object3, L"m_testable_bool_bit8", true, true);

            // Object Tests
            UObject** obj_val = engine_object3->get_property<UObject>(L"m_testable_object");
            Output::send(STR("{} (val: {} | expected: {}) <- ObjectProperty\n"), (void*)obj_val, (void*)*obj_val, (void*)engine_object3);
            assert_test(*obj_val == engine_object3, STR("ObjectProperty"))

            // Uncomment when WeakObjectProperty is supported
            /*
            void* weak_obj_addr = engine_object3->get_property_data_ptr(L"m_testable_weakobject");
            UObject* weak_obj_val = *engine_object3->get_property<XObjectProperty>(L"m_testable_weakobject");
            printf_s("%p (val: %p | expected: %p) <- ObjectProperty\n", weak_obj_addr, weak_obj_val, engine_object3);
            */

            // Array Tests
            void* array_addr = engine_object3->get_property_data_ptr(L"m_testable_array_of_int");
            TArray<int32_t> array_val = engine_object3->get_property<TArray<int32_t>>(L"m_testable_array_of_int");
            array_val.for_each([&](const int32_t* elem, auto index) {
                Output::send(STR("{}[{}] -> {} (val: {} | expected: {}) <- ArrayProperty <- TArray<int32>\n"), array_addr, index, (void*)elem, *elem, index + 1);
                assert_test(*elem == index + 1, STR("ArrayProperty <- TArray<int32_t>"))

                return LoopAction::Continue;
            });

            void* array_of_obj_addr = engine_object3->get_property_data_ptr(L"m_testable_array_of_uobject");
            TArray<UObject*> array_of_obj = engine_object3->get_property<TArray<UObject*>>(L"m_testable_array_of_uobject");
            array_of_obj.for_each([&](UObject** elem, auto index) {
                Output::send(STR("{}[{}] -> {} (val: {} | expected: {}) <- ArrayProperty <- TArray<UObject*>\n"), array_of_obj_addr, index, (void*)elem, (void*)*elem, (void*)engine_object3);
                assert_test(*elem == engine_object3, STR("ArrayProperty <- TArray<UObject*>"))

                return LoopAction::Continue;
            });

            // Struct Tests
            {
                XStruct struct_of_int = engine_object3->get_property<XStructProperty>(L"m_testable_struct_of_int");
                int32_t* m_int_one = struct_of_int.get_property<int32_t>(L"m_int_one");
                assert_test(*m_int_one == 1, STR("StructProperty <- int32_t (m_int_one)"))
                int32_t* m_int_two = struct_of_int.get_property<int32_t>(L"m_int_two");
                assert_test(*m_int_two == 2, STR("StructProperty <- int32_t (m_int_two)"))
                int32_t* m_int_three = struct_of_int.get_property<int32_t>(L"m_int_three");
                assert_test(*m_int_three == 3, STR("StructProperty <- int32_t (m_int_three)"))
                Output::send(STR("{}[m_int_one] -> {} (val: {} | expected: {}) <- StructProperty <- int32_t\n"), (void*)m_int_one, (void*)m_int_one, *m_int_one, 1);
                Output::send(STR("{}[m_int_two] -> {} (val: {} | expected: {}) <- StructProperty <- int32_t\n"), (void*)m_int_one, (void*)m_int_two, *m_int_two, 2);
                Output::send(STR("{}[m_int_three] -> {} (val: {} | expected: {}) <- StructProperty <- int32_t\n"), (void*)m_int_one, (void*)m_int_three, *m_int_three, 3);
            }

            {
                XStruct struct_of_array_of_int = engine_object3->get_property<XStructProperty>(L"m_testable_struct_of_array_of_int");
                TArray<int32_t> m_testable_array_of_int = struct_of_array_of_int.get_value<TArray<int32_t>>(L"m_testable_array_of_int");
                m_testable_array_of_int.for_each([&](int32_t* elem, auto index) {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: {}) <- StructProperty <- ArrayProperty <- TArray<int32_t>\n"), (void*)m_testable_array_of_int.get_data_ptr(), index, (void*)elem, *elem, index + 1);
                    assert_test(*elem == index + 1, STR("StructProperty < ArrayProperty <- TArray<int32_t>"))
                    return LoopAction::Continue;
                });
            }

            printf_s("testing array of struct of int\n");
            TArray<XStruct> array_of_struct_of_int = engine_object3->get_property<TArray<XStruct>>(L"m_testable_array_of_struct_of_int");
            printf_s("array_of_struct_of_int retrieved\n");
            printf_s("array_of_struct_of_int.ptr: %p\n", array_of_struct_of_int.get_data_ptr());
            printf_s("array_of_struct_of_int.num: %d\n", array_of_struct_of_int.get_array_num());
            printf_s("array_of_struct_of_int.max: %d\n", array_of_struct_of_int.get_array_max());
            array_of_struct_of_int.for_each([&](XStruct* elem, auto index) {
                printf_s("inside for_each\n");
                // TODO: Improve this test, I think there is too much repetition
                int32_t* val_one = elem->get_property<int32_t>(L"m_int_one");
                int32_t* val_two = elem->get_property<int32_t>(L"m_int_two");
                int32_t* val_three = elem->get_property<int32_t>(L"m_int_three");

                if (index == 0)
                {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 1) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_one, *val_one);
                    assert_test(*val_one == 1, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 2) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_two, *val_two);
                    assert_test(*val_two == 2, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 3) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_three, *val_three);
                    assert_test(*val_three == 3, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())
                }
                else if (index == 1)
                {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 4) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_one, *val_one);
                    assert_test(*val_one == 4, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 5) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_two, *val_two);
                    assert_test(*val_two == 5, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 6) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_three, *val_three);
                    assert_test(*val_three == 6, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())
                }
                else if (index == 2)
                {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 7) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_one, *val_one);
                    assert_test(*val_one == 7, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 8) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_two, *val_two);
                    assert_test(*val_two == 8, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())

                    Output::send(STR("{}[{}] -> {} (val: {} | expected: 9) <- ArrayProperty <- StructProperty (int32_t)>\n"), (void*)array_of_struct_of_int.get_data_ptr(), index, (void*)val_three, *val_three);
                    assert_test(*val_three == 9, fmt(STR("ArrayProperty < StructProperty < int32_t (index: %d)"), index).c_str())
                }
                return LoopAction::Continue;
            });

            // WeakObject Test
            auto do_weak_object_test = [&engine_object3](UObject* expected_value, std::wstring_view expected_value_name) -> FWeakObjectPtr* {
                FWeakObjectPtr* weak_object = engine_object3->get_property<FWeakObjectPtr>(L"m_testable_weakobject");
                assert_test(weak_object, STR("FWeakObjectPtr instance (TestableGameEngine:m_testable_weakobject) was nullptr"))

                UObject* real_object = weak_object->get();
                Output::send(STR("FWeakObjectPtr: {} | Real Object: {} - {}\n"), (void*)weak_object, (void*)real_object, real_object->get_full_name());

                assert_test(real_object == expected_value, std::format(L"Expected 'real_object' to be {}({}) but was {}", expected_value_name, (void*)expected_value, (void*)real_object).c_str())

                return weak_object;
            };

            FWeakObjectPtr* weak_object = do_weak_object_test(engine_object3, L"TestableGameEngine");

            *weak_object = nullptr;
            weak_object = do_weak_object_test(nullptr, L"NULLPTR");

            *weak_object = engine_object3;
            do_weak_object_test(engine_object3, L"TestableGameEngine");

            // Custom Property Test, trivial underlying type
            UObject* object_for_custom_type_test = engine_object3;
            assert_test(object_for_custom_type_test, STR("Expected 'object_for_custom_type_test' to be non-nullptr but it was nullptr"))
            // Custom data is pointing to 'TestableGameEngine:m_testable_int8'
            Unreal::CustomProperty custom_int_property{0xE30};
            int8_t* custom_data = object_for_custom_type_test->get_property<int8_t>(L"Int8WithNoMetadata", &custom_int_property);
            assert_test(custom_data, STR("Expected 'custom_data' to be non-nullptr but it was nullptr"))
            Output::send(STR("Custom data (fully custom) -> Underlying type: int8_t, trivial: yes\n"));
            Output::send(STR("custom_data (m_testable_int8): {}\n"), *custom_data);
            assert_test(*custom_data == std::numeric_limits<int8_t>::max(), std::format(L"Expected '*custom_data' to be equal to '{}' but it was '{}'", std::numeric_limits<int8_t>::max(), *custom_data).c_str())

            // Custom Property Test, non-trivial underlying type
            /**/
            {
                // Custom data is pointing to 'TestableGameEngine:m_testable_array_of_int'
                Unreal::CustomProperty custom_array_of_int_property{0xFA8};
                TArray<int32_t> custom_array = engine_object3->get_property<TArray<int32_t>>(L"ArrayOfIntWithNoMetadata", &custom_array_of_int_property);
                Output::send(STR("Custom data (fully custom) -> Underlying type: TArray<int32_t>, trivial: yes\n"));
                custom_array.for_each([&](const int32_t* elem, auto index) {
                    Output::send(STR("[{}] -> {} (val: {} | expected: {}) <- ArrayProperty(Custom) <- TArray<int32>\n"), index, (void*)elem, *elem, index + 1);
                    assert_test(*elem == index + 1, STR("ArrayProperty <- TArray<int32_t>"))

                    return LoopAction::Continue;
                });
            }
            //*/

            {
                // Custom data is pointing to 'TestableGameEngine:m_testable_array_of_struct_of_int'
                Unreal::UScriptStruct* script_struct_for_custom_struct_property = UObjectGlobals::static_find_object<Unreal::UScriptStruct*>(nullptr, nullptr, L"/Script/UE4SS_Main426.TestableStructOfInt");
                assert_test(script_struct_for_custom_struct_property, "script_struct_for_custom_struct_property was nullptr")
                std::unique_ptr<Unreal::CustomProperty> test_custom_struct_property = CustomStructProperty::construct(0x0, script_struct_for_custom_struct_property);
                std::unique_ptr<Unreal::CustomProperty> test_custom_array_property = CustomArrayProperty::construct(0xFD8, test_custom_struct_property.get());
                Output::send(STR("test_custom_array_property: {}\n"), (void*)test_custom_array_property.get());
                /**/
                TArray<XStruct> custom_struct = engine_object3->get_property<TArray<XStruct>>(L"ArrayOfStructWithNoMetadata", test_custom_array_property.get());
                Output::send(STR("Custom data (partially custom) -> Underlying type: TArray<XStruct>, trivial: no\n"));
                custom_struct.for_each([&](XStruct* elem, auto index) {
                    // TODO: Improve this test, I think there is too much repetition
                    int32_t* val_one = elem->get_property<int32_t>(L"m_int_one");
                    int32_t* val_two = elem->get_property<int32_t>(L"m_int_two");
                    int32_t* val_three = elem->get_property<int32_t>(L"m_int_three");

                    if (index == 0)
                    {
                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 1) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_one, *val_one);
                        assert_test(*val_one == 1, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 2) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_two, *val_two);
                        assert_test(*val_two == 2, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 3) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_three, *val_three);
                        assert_test(*val_three == 3, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())
                    }
                    else if (index == 1)
                    {
                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 4) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_one, *val_one);
                        assert_test(*val_one == 4, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 5) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_two, *val_two);
                        assert_test(*val_two == 5, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 6) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_three, *val_three);
                        assert_test(*val_three == 6, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())
                    }
                    else if (index == 2)
                    {
                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 7) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_one, *val_one);
                        assert_test(*val_one == 7, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 8) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_two, *val_two);
                        assert_test(*val_two == 8, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())

                        Output::send(STR("{}[{}] -> {} (val: {} | expected: 9) <- ArrayProperty(Custom) <- StructProperty (int32_t)>\n"), (void*)custom_struct.get_data_ptr(), index, (void*)val_three, *val_three);
                        assert_test(*val_three == 9, fmt(STR("ArrayProperty(Custom) < StructProperty < int32_t (index: %d)"), index).c_str())
                    }
                    return LoopAction::Continue;
                });
            }
            //*/

            {
                // Custom data is pointing to 'TestableGameEngine:m_testable_struct_of_int'
                Unreal::UScriptStruct* script_struct_for_custom_struct_property = UObjectGlobals::static_find_object<Unreal::UScriptStruct*>(nullptr, nullptr, L"/Script/UE4SS_Main426.TestableStructOfInt");
                assert_test(script_struct_for_custom_struct_property, "script_struct_for_custom_struct_property was nullptr")
                std::unique_ptr<Unreal::CustomProperty> test_custom_struct_property = CustomStructProperty::construct(0xF98, script_struct_for_custom_struct_property);
                Output::send(STR("test_custom_struct_property: {}\n"), (void*)test_custom_struct_property.get());
                XStruct custom_struct_of_int = engine_object3->get_property<XStructProperty>(L"StructOfIntWithNoMetadata", test_custom_struct_property.get());
                Output::send(STR("Custom data (partially custom) -> Underlying type: XStruct, trivial: no\n"));

                /**/
                int32_t* m_int_one = custom_struct_of_int.get_property<int32_t>(L"m_int_one");
                assert_test(*m_int_one == 1, STR("StructProperty(Custom) <- int32_t (m_int_one)"))
                int32_t* m_int_two = custom_struct_of_int.get_property<int32_t>(L"m_int_two");
                assert_test(*m_int_two == 2, STR("StructProperty(Custom) <- int32_t (m_int_two)"))
                int32_t* m_int_three = custom_struct_of_int.get_property<int32_t>(L"m_int_three");
                assert_test(*m_int_three == 3, STR("StructProperty(Custom) <- int32_t (m_int_three)"))
                Output::send(STR("{}[m_int_one] -> {} (val: {} | expected: {}) <- StructProperty(Custom) <- int32_t\n"), (void*)m_int_one, (void*)m_int_one, *m_int_one, 1);
                Output::send(STR("{}[m_int_two] -> {} (val: {} | expected: {}) <- StructProperty(Custom) <- int32_t\n"), (void*)m_int_one, (void*)m_int_two, *m_int_two, 2);
                Output::send(STR("{}[m_int_three] -> {} (val: {} | expected: {}) <- StructProperty(Custom) <- int32_t\n"), (void*)m_int_one, (void*)m_int_three, *m_int_three, 3);
                //*/
            }

            {
                // Custom data is pointing to 'TestableGameEngine:m_testable_struct_of_array_of_int'
                std::unique_ptr<Unreal::CustomProperty> test_custom_struct_property = CustomStructProperty::construct(0xFC8, nullptr);
                XStruct struct_of_array_of_int = engine_object3->get_property<XStructProperty>(L"StructOfArrayOfIntWithNoMetadata", test_custom_struct_property.get());
                Unreal::CustomProperty custom_array_of_int_property{0x0};
                TArray<int32_t> custom_array = struct_of_array_of_int.get_value<TArray<int32_t>>(L"ArrayOfIntWithNoMetadata", &custom_array_of_int_property);

                Output::send(STR("Custom data (fully custom) -> Underlying type: XStruct -> TArray<int>, trivial: no\n"));
                assert_test(custom_array.get_array_num() > 0, STR("custom_array was empty"))
                custom_array.for_each([&](int32_t* elem, auto index) {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: {}) <- StructProperty(Custom) <- ArrayProperty(Custom) <- TArray<int32_t>\n"), (void*)custom_array.get_data_ptr(), index, (void*)elem, *elem, index + 1);
                    assert_test(*elem == index + 1, STR("StructProperty(Custom) < ArrayProperty(Custom) <- TArray<int32_t>"))
                    return LoopAction::Continue;
                });
            }

            {
                // Custom data is pointing to 'TestableGameEngine:m_testable_struct_of_array_of_int'
                Unreal::UScriptStruct* script_struct_for_custom_struct_property = UObjectGlobals::static_find_object<Unreal::UScriptStruct*>(nullptr, nullptr, L"/Script/UE4SS_Main426.TestableStructOfArrayOfInt");
                assert_test(script_struct_for_custom_struct_property, "script_struct_for_custom_struct_property was nullptr")
                std::unique_ptr<Unreal::CustomProperty> test_custom_struct_property = CustomStructProperty::construct(0xFC8, script_struct_for_custom_struct_property);
                XStruct struct_of_array_of_int = engine_object3->get_property<XStructProperty>(L"StructOfArrayOfIntWithNoMetadata", test_custom_struct_property.get());
                TArray<int32_t> custom_array = struct_of_array_of_int.get_value<TArray<int32_t>>(L"m_testable_array_of_int");

                Output::send(STR("Custom data (partially custom) -> Underlying type: XStruct -> TArray<int>, trivial: no\n"));
                assert_test(custom_array.get_array_num() > 0, STR("custom_array was empty"))
                custom_array.for_each([&](int32_t* elem, auto index) {
                    Output::send(STR("{}[{}] -> {} (val: {} | expected: {}) <- StructProperty(Custom) <- ArrayProperty <- TArray<int32_t>\n"), (void*)custom_array.get_data_ptr(), index, (void*)elem, *elem, index + 1);
                    assert_test(*elem == index + 1, STR("StructProperty(Custom) < ArrayProperty <- TArray<int32_t>"))
                    return LoopAction::Continue;
                });
            }
        }
        else
        {
            Output::send(STR("no engine object #3\n"));
        }

        if (engine_object4)
        {
            auto* int_val = engine_object4->get_property<int32_t>(L"ScreenSaverInhibitorSemaphore");
            auto* float_val = engine_object4->get_property<float>(L"ServerFlushLogInterval");

            Output::send(STR("int_val (#3): {} (address: {})\n"), *int_val, (void*)int_val);
            Output::send(STR("float_val (#3): {} (address: {})\n"), *float_val, (void*)float_val);
            //engine_obj->write<int32_t>("ScreenSaverInhibitorSemaphore", 1);
        }
        else
        {
            Output::send(STR("no engine object #4\n"));
        }

        if (engine_object5)
        {
            auto* int_val = engine_object5->get_property<int32_t>(L"ScreenSaverInhibitorSemaphore");
            auto* float_val = engine_object5->get_property<float>(L"ServerFlushLogInterval");

            Output::send(STR("int_val (#4): {} (address: {})\n"), *int_val, (void*)int_val);
            Output::send(STR("float_val (#4): {} (address: {})\n"), *float_val, (void*)float_val);
            //engine_obj->write<int32_t>("ScreenSaverInhibitorSemaphore", 1);
        }
        else
        {
            Output::send(STR("no engine object #5\n"));
        }
        // Property Tests -> END

        // OutputDevice example code
        /**/
        {
            // Setup
            // Set the default device which is never deallocated unless the default device is set again
            //Output::set_default_devices<Output::DebugConsoleDevice>();
            //Output::set_default_devices<Output::DebugConsoleDevice, Output::TestDevice>();

            // Simple output to all default devices
            Output::send(STR("Hello default devices\n"));
            Output::send(STR("Hello default devices with arg {}\n"), 5);
            Output::send(STR("Hello default device with more args {} {}\n"), 5, 6);

            // Output to the specified devices and keep all devices ready for more output until we either go out of scope or call close_devices()
            // Note that you don't have to specify any OutputDevice if Output::open_devices() was called first
            Output::Targets<Output::DebugConsoleDevice, Output::TestDevice> scoped_out;
            scoped_out.send(STR("Hello persistent devices #1\n"), Output::TestDevice::OptionalArgTest::ValueThree);
            scoped_out.send(STR("Hello persistent devices #2 - {}\n"), Output::TestDevice::OptionalArgTest::ValueTwo, 1);
            scoped_out.send(STR("Hello persistent devices #3 - {}\n"), Output::TestDevice::OptionalArgTest::ValueOne, 2);
            scoped_out.send(STR("Hello persistent devices #4 - {}\n"), Output::TestDevice::OptionalArgTest::ValueOne, 3);
            scoped_out.send(STR("Hello persistent devices #5 - {}\n"), Output::TestDevice::OptionalArgTest::ValueOne, 4.4f);
            scoped_out.send(STR("Hello persistent devices #6 - no args\n"), Output::TestDevice::OptionalArgTest::ValueOne);

            // Method #1 - Use a constexpr "string" type as a template param
            //static constexpr char my_filename[]{STR("D:\\test\\my_file.txt")};
            //Output::send<Output::FileDevice<my_filename>>(STR("Test FileOutputDevice - no args\n"));

            // Method #2 - Pass a runtime "string" to a function call
            // May require this output device to be used via the "Output::Targets" method
            using TestFileOutputDevice = Output::FileDevice;
            Output::Targets<TestFileOutputDevice, Output::DebugConsoleDevice> scoped_out2;
            auto& file_output_device = scoped_out2.get_device<TestFileOutputDevice>();
            file_output_device.set_file_name_and_path(STR("D:\\test\\test2\\test3\\test4\\my_file.ini"));
            scoped_out2.send(STR("Hello333 - no args\n"));
            scoped_out2.send(STR("Hello444 - no args\n"));
            scoped_out2.send(STR("Hello555 - {} {}\n"), Color::Red, 3, 4);

            // Method #3 - Identical to method #2 except with default devices
            //auto& file_device = Output::get_device<Output::FileDevice>();
            //file_output_device.set_file_name_and_path(STR("D:\\test\\my_file2.ini"));
            //scoped_out2.send(STR("Hello1 - no args\n"));
            //scoped_out2.send(STR("Hello2 - no args\n"));
            //scoped_out2.send(STR("Hello3 - {} {}\n"), 3, 4);
        }
        //*/

        UObject* player_controller = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Game/FirstPersonCPP/Maps/FirstPersonExampleMap.FirstPersonExampleMap.PersistentLevel.PlayerController_2147482560");
        if (player_controller)
        {
            //dump_flags(player_controller->get_flags());
            Output::send(STR("PlayerController FName: {:#x} / {:#x} ({})\n"), player_controller->get_fname().get_number(), player_controller->get_fname().get_comparison_index(), player_controller->get_fname().to_string());
        }
        else
        {
            Output::send(STR("No PlayerController\n"));
        }

        FName player_controller_class{L"PlayerController"};
        UObject* player_controller_test_one = UObjectGlobals::find_first_of(player_controller_class);
        UObject* player_controller_test_two = UObjectGlobals::find_first_of(L"PlayerController");
        UObject* engine_test = UObjectGlobals::find_first_of(L"Engine");

        std::vector<UObject*> all_pawns_test;
        UObjectGlobals::find_all_of(L"Pawn", all_pawns_test);

        /**/
        if (player_controller_test_one)
        {
            Output::send(L"player_controller_test_one: {} ({})\n", (void*)player_controller_test_one, player_controller_test_one->get_full_name());
        }
        else
        {
            Output::send(STR("No PlayerController #1 found\n"));
        }
        //*/

        /**/
        if (player_controller_test_two)
        {
            Output::send(L"player_controller_test_one: {} ({})\n", (void*)player_controller_test_two, player_controller_test_two->get_full_name());
        }
        else
        {
            Output::send(STR("No PlayerController #2 found\n"));
        }
        //*/

        /**/
        if (engine_test)
        {
            Output::send(L"engine_test_one: {} ({})\n", (void*)engine_test, engine_test->get_full_name());
        }
        else
        {
            Output::send(STR("No Engine #1 found\n"));
        }
        //*/

        /**/
        if (!all_pawns_test.empty())
        {
            Output::send(STR("All Pawns:\n"));
            for (const auto& pawn : all_pawns_test)
            {
                Output::send(STR("{}\n"), pawn->get_full_name());
            }
        }
        else
        {
            Output::send(STR("No pawns found\n"));
        }
        //*/

        // StaticConstructObject_Internal test (creating console)
        // Commented out because I'm executing the same code in the Lua test script
        /*
        UObject* engine_for_console_creation = UObjectGlobals::find_first_of(L"Engine");
        UClass* console_class = static_cast<UClass*>(*engine_for_console_creation->get_property<UObject>(L"ConsoleClass"));
        UObject* viewport = *engine_for_console_creation->get_property<UObject>(L"GameViewport");

        if (!console_class || !viewport)
        {
            throw std::runtime_error{"Tried to create console but console class or viewport was nullptr"};
        }

        UObject* console = UObjectGlobals::static_construct_object(Unreal::FStaticConstructObjectParameters{
            .Class = console_class,
            .Outer = viewport,
            .Name = FName(L"None"),
            .SetFlags = Unreal::RF_NoFlags,
            .InternalSetFlags = Unreal::EInternalObjectFlags::None,
            .bCopyTransientsFromClassDefaults = false,
            .bAssumeTemplateIsArchetype = false,
            .Template = nullptr,
            .InstanceGraph = nullptr,
            .ExternalPackage = nullptr,
            .SubobjectOverrides = nullptr,
        });

        Output::send(STR("Console: {}\n"), (void*)console);

        UObject** viewport_console = viewport->get_property<UObject>(L"ViewportConsole");
        *viewport_console = console;
        //*/

        // Change the console key
        UObject* input_settings = UObjectGlobals::static_find_object(nullptr, nullptr, L"/Script/Engine.Default__InputSettings");
        if (!input_settings) { throw std::runtime_error{"Was unable to find '/Script/Engine.Default__InputSettings'"}; }

        TArray<FName> console_keys = input_settings->get_property<TArray<FName>>(L"ConsoleKeys");
        *console_keys[0] = FName(L"F12");
        console_keys.for_each([&](FName* elem, auto index) {
            Output::send(STR("ConsoleKey #{}: {} | 0x{:X}\n"), index, elem->to_string(), elem->get_comparison_index());
            return LoopAction::Continue;
        });

        // UFunction Hook Test -> START
        UFunction* can_jump_internal_func = UObjectGlobals::static_find_object<UFunction*>(nullptr, nullptr, L"/Script/Engine.Character:CanJumpInternal");
        if (!can_jump_internal_func) { throw std::runtime_error{"UFunction Hook Test failed, 'can_jump_internal_func' is nullptr!"}; }

        can_jump_internal_func->register_hook([](...) {
            // Pre-hook (use for param access & mutation)

            Output::send(STR("[C++] Jump hook #1\n"));
        }, []([[maybe_unused]]Unreal::UnrealScriptFunctionCallableContextParam context, ...) {
            // Post-hook (use for return value access & mutation)

            //context.set_return_value(true);
        });

        UFunction* set_movement_mode_func = UObjectGlobals::static_find_object<UFunction*>(nullptr, nullptr, L"/Script/Engine.CharacterMovementComponent:SetMovementMode");
        if (!set_movement_mode_func) { throw std::runtime_error{"UFunction Hook Test failed, 'set_movement_mode_func' is nullptr!"}; }

        set_movement_mode_func->register_hook([](Unreal::UnrealScriptFunctionCallableContextParam context, ...) {
            auto& params = context.get_params<UCharacterMovementComponent::SetMovementMode_Params>();
            Output::send(STR("[C++] SetMovementMode hook #1 - NewMovementMode: {} | NewCustomMode: {}\n"), params.NewMovementMode, params.NewCustomMode);
        }, [](...) {
        });

        set_movement_mode_func->register_hook([](...) {
            Output::send(STR("[C++] SetMovementMode hook #2\n"));
        }, [](...) {
        });
        // UFunction Hook Test -> END

        // UEnum Test -> START
        if (Unreal::Version::is_atleast(4, 15))
        {
            TestableEnumClass* enum_test = engine_test->get_property<TestableEnumClass>(L"m_testable_enum_class");
            Output::send(STR("{} (val: {} | expected: {}) <- {}\n"), (void*)enum_test, (int32_t)*enum_test, 1, L"m_testable_enum_class");
            assert_test(*enum_test == TestableEnumClass::ClassValueTwo, STR("EnumProperty<TestableEnumClass>"))
        }
        // UEnum Test -> END

        // MapProperty -> START
        auto testable_int_int_map = engine_test->get_property<TMap<int32_t, int32_t>>(L"m_testable_int_int_map");
        int32_t* testable_int_int_map_value_one = testable_int_int_map[3];
        int32_t* testable_int_int_map_value_two = testable_int_int_map[6];
        int32_t* testable_int_int_map_value_three = testable_int_int_map[9];
        Output::send(STR("testable_int_int_map_value_one: {}\n"), *testable_int_int_map_value_one);
        Output::send(STR("testable_int_int_map_value_two: {}\n"), *testable_int_int_map_value_two);
        Output::send(STR("testable_int_int_map_value_three: {}\n"), *testable_int_int_map_value_three);
        assert_test(testable_int_int_map_value_one && *testable_int_int_map_value_one == 1, STR("testable_int_int_map_value_one == 1"))
        assert_test(testable_int_int_map_value_two && *testable_int_int_map_value_two == 2, STR("testable_int_int_map_value_two == 2"))
        assert_test(testable_int_int_map_value_three && *testable_int_int_map_value_three == 3, STR("testable_int_int_map_value_three == 3"))
        // MapProperty -> END
    }

    auto UE4SSProgramTest::execute_function_call_tests() -> void
    {
        // Call to CharacterMovementComponent::SetMovementMode

        UCharacterMovementComponent* movement_component = static_cast<UCharacterMovementComponent*>(UObjectGlobals::find_first_of(L"CharacterMovementComponent"));

        if (!movement_component)
        {
            throw std::runtime_error{"Test failed: [Calling_CharacterMovementComponent_SetMovementMode] => movement_component is nullptr"};
        }

        uint8_t current_movement_mode = *movement_component->get_property<uint8_t>(L"MovementMode");

        // Set MovementMode to Flying if not Flying, otherwise set to Falling
        movement_component->SetMovementMode(current_movement_mode != 5 ? 5 : 3, 0);
    }
}

```

`Tests/UE4SSProgramTest.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_UE4SSPROGRAMTEST_HPP
#define UE4SS_REWRITTEN_UE4SSPROGRAMTEST_HPP

#include <UE4SSProgram.hpp>

namespace RC
{
    class UE4SSProgramTest : public UE4SSProgram
    {
    public:
        UE4SSProgramTest(const std::wstring& moduleFilePath, std::initializer_list<BinaryOptions> options);

    private:
        auto static execute_tests() -> void;
        auto static execute_function_call_tests() -> void;
    };
}


#endif //UE4SS_REWRITTEN_UE4SSPROGRAMTEST_HPP

```

`Tests/main_ue4ss_tests.cpp`:

```cpp
// Main file that initializes all tests
// TODO: Consider using a proper testing framework and maybe making this a separate DLL file

#include <Windows.h>
#include <iostream>
#include "UE4SSProgramTest.hpp"
#include <DynamicOutput/DynamicOutput.hpp>

using namespace RC;

// We're outside DllMain here
auto WINAPI thread_dll_start([[maybe_unused]]LPVOID thread_param) -> unsigned long
{
    // Wrapper for entire program
    // Everything must be channeled through MProgram
    // One of the purposes for this is to forward any errors to main so that we can close or keep the window/console open
    // There is atleast one more purpose but I forgot what it was...
    HMODULE moduleHandle = reinterpret_cast<HMODULE>(thread_param);
    wchar_t moduleFilenameBuffer[1024] {'\0'};
    GetModuleFileNameW(moduleHandle, moduleFilenameBuffer, sizeof(moduleFilenameBuffer) / sizeof(wchar_t));

    UE4SSProgramTest program = UE4SSProgramTest(moduleFilenameBuffer, {});

    if (auto e = program.get_error_object(); e->has_error())
    {
        // If the output system errored out then use printf_s as a fallback
        // Logging will only happen to the debug console but it's something at least
        if (!Output::has_internal_error())
        {
            Output::send(STR("Error: {}\n"), RC::fmt(L"%S", e->get_message()));
        }
        else
        {
            printf_s("Error: %s\n", e->get_message());
        }
    }

    return 0;
}

// We're still inside DllMain so be careful what you do here
auto dll_process_attached(HMODULE moduleHandle) -> void
{
    if (HANDLE handle = CreateThread(nullptr, 0, thread_dll_start, moduleHandle, 0, nullptr); handle)
    {
        CloseHandle(handle);
    }

    std::cin.get();
}

auto APIENTRY DllMain([[maybe_unused]] HMODULE hModule,
                      DWORD ul_reason_for_call,
                      [[maybe_unused]] LPVOID lpReserved
) -> BOOL
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            dll_process_attached(hModule);
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            UE4SSProgram::static_cleanup();
            break;
    }
    return TRUE;
}
```

`VS_Solution/generate_vs_solution.bat`:

```bat
set BuildMode=%1

IF NOT DEFINED %BuildMode (
set BuildMode=Release
)

cmake -DCMAKE_BUILD_TYPE=%BuildMode% -DRC_FORCE_ALL_STATIC_LIBS= -G"Visual Studio 17 2022" ..

```

`build_auto.bat`:

```bat
@echo off

set BuildMode=%1
set TargetName=%2

IF NOT DEFINED %BuildMode (
set BuildMode=Release
)

IF NOT DEFINED %TargetName (
set TargetName=ue4ss
)

set IsBuildConfigValid=1

IF NOT %BuildMode% == Release (
    IF NOT %BuildMode% == Debug (
        set IsBuildConfigValid=0
        echo Build mode must be either Release or Debug, not %BuildMode%.
    )
)

if NOT %TargetName% == ue4ss (
    if NOT %TargetName% == xinput1_3 (
        set IsBuildConfigValid=0
        echo Target name must be either ue4ss or xinput1_3, not %TargetName%
    )
)

IF %IsBuildConfigValid% == 1 (
    echo Target Name: %TargetName%
    echo Build Mode: %BuildMode%

    call internal_generate_build_files.bat %BuildMode%
    MSBuild.exe /m "VS_Solution\%TargetName%.vcxproj" /property:Configuration=%BuildMode%
) else (
    echo Could not build, the build configuration is invalid.
    pause
    exit /b
)
```

`generated_include/MacroSetter.hpp`:

```hpp
if (auto val = parser.get_int64(STR("UObjectBase"), STR("ClassPrivate"), -1); val != -1)
    Unreal::UObjectBase::MemberOffsets.emplace(STR("ClassPrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UObjectBase"), STR("InternalIndex"), -1); val != -1)
    Unreal::UObjectBase::MemberOffsets.emplace(STR("InternalIndex"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UObjectBase"), STR("NamePrivate"), -1); val != -1)
    Unreal::UObjectBase::MemberOffsets.emplace(STR("NamePrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UObjectBase"), STR("ObjectFlags"), -1); val != -1)
    Unreal::UObjectBase::MemberOffsets.emplace(STR("ObjectFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UObjectBase"), STR("OuterPrivate"), -1); val != -1)
    Unreal::UObjectBase::MemberOffsets.emplace(STR("OuterPrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct::ICppStructOps"), STR("Alignment"), -1); val != -1)
    Unreal::UScriptStruct::ICppStructOps::MemberOffsets.emplace(STR("Alignment"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct::ICppStructOps"), STR("Size"), -1); val != -1)
    Unreal::UScriptStruct::ICppStructOps::MemberOffsets.emplace(STR("Size"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("ArrayDim"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("ArrayDim"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("DestructorLinkNext"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("DestructorLinkNext"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("ElementSize"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("ElementSize"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("NextRef"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("NextRef"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("Offset_Internal"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("Offset_Internal"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("PostConstructLinkNext"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("PostConstructLinkNext"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("PropertyFlags"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("PropertyFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("PropertyLinkNext"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("PropertyLinkNext"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("RepIndex"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("RepIndex"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FProperty"), STR("RepNotifyFunc"), -1); val != -1)
    Unreal::FProperty::MemberOffsets.emplace(STR("RepNotifyFunc"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FSoftClassProperty"), STR("MetaClass"), -1); val != -1)
    Unreal::FSoftClassProperty::MemberOffsets.emplace(STR("MetaClass"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FOutputDevice"), STR("bAutoEmitLineTerminator"), -1); val != -1)
    Unreal::FOutputDevice::MemberOffsets.emplace(STR("bAutoEmitLineTerminator"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FOutputDevice"), STR("bSuppressEventTag"), -1); val != -1)
    Unreal::FOutputDevice::MemberOffsets.emplace(STR("bSuppressEventTag"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("EventGraphCallOffset"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("EventGraphCallOffset"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("EventGraphFunction"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("EventGraphFunction"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("FirstPropertyToInit"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("FirstPropertyToInit"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("Func"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("Func"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("FunctionFlags"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("FunctionFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("NumParms"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("NumParms"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("ParmsSize"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("ParmsSize"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("RPCId"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("RPCId"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("RPCResponseId"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("RPCResponseId"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("RepOffset"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("RepOffset"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UFunction"), STR("ReturnValueOffset"), -1); val != -1)
    Unreal::UFunction::MemberOffsets.emplace(STR("ReturnValueOffset"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UField"), STR("Next"), -1); val != -1)
    Unreal::UField::MemberOffsets.emplace(STR("Next"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FEnumProperty"), STR("Enum"), -1); val != -1)
    Unreal::FEnumProperty::MemberOffsets.emplace(STR("Enum"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FEnumProperty"), STR("UnderlyingProp"), -1); val != -1)
    Unreal::FEnumProperty::MemberOffsets.emplace(STR("UnderlyingProp"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("ChildProperties"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("ChildProperties"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("Children"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("Children"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("DestructorLink"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("DestructorLink"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("MinAlignment"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("MinAlignment"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("PostConstructLink"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("PostConstructLink"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("PropertiesSize"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("PropertiesSize"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("PropertyLink"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("PropertyLink"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("RefLink"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("RefLink"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("Script"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("Script"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("ScriptAndPropertyObjectReferences"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("ScriptAndPropertyObjectReferences"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("ScriptObjectReferences"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("ScriptObjectReferences"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("SuperStruct"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("SuperStruct"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UStruct"), STR("UnresolvedScriptProperties"), -1); val != -1)
    Unreal::UStruct::MemberOffsets.emplace(STR("UnresolvedScriptProperties"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FDelegateProperty"), STR("SignatureFunction"), -1); val != -1)
    Unreal::FDelegateProperty::MemberOffsets.emplace(STR("SignatureFunction"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FMulticastDelegateProperty"), STR("SignatureFunction"), -1); val != -1)
    Unreal::FMulticastDelegateProperty::MemberOffsets.emplace(STR("SignatureFunction"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FObjectPropertyBase"), STR("PropertyClass"), -1); val != -1)
    Unreal::FObjectPropertyBase::MemberOffsets.emplace(STR("PropertyClass"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FField"), STR("ClassPrivate"), -1); val != -1)
    Unreal::FField::MemberOffsets.emplace(STR("ClassPrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FField"), STR("FlagsPrivate"), -1); val != -1)
    Unreal::FField::MemberOffsets.emplace(STR("FlagsPrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FField"), STR("NamePrivate"), -1); val != -1)
    Unreal::FField::MemberOffsets.emplace(STR("NamePrivate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FField"), STR("Next"), -1); val != -1)
    Unreal::FField::MemberOffsets.emplace(STR("Next"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FField"), STR("Owner"), -1); val != -1)
    Unreal::FField::MemberOffsets.emplace(STR("Owner"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FBoolProperty"), STR("ByteMask"), -1); val != -1)
    Unreal::FBoolProperty::MemberOffsets.emplace(STR("ByteMask"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FBoolProperty"), STR("ByteOffset"), -1); val != -1)
    Unreal::FBoolProperty::MemberOffsets.emplace(STR("ByteOffset"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FBoolProperty"), STR("FieldMask"), -1); val != -1)
    Unreal::FBoolProperty::MemberOffsets.emplace(STR("FieldMask"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FBoolProperty"), STR("FieldSize"), -1); val != -1)
    Unreal::FBoolProperty::MemberOffsets.emplace(STR("FieldSize"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct"), STR("CppStructOps"), -1); val != -1)
    Unreal::UScriptStruct::MemberOffsets.emplace(STR("CppStructOps"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct"), STR("StructFlags"), -1); val != -1)
    Unreal::UScriptStruct::MemberOffsets.emplace(STR("StructFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct"), STR("bCppStructOpsFromBaseClass"), -1); val != -1)
    Unreal::UScriptStruct::MemberOffsets.emplace(STR("bCppStructOpsFromBaseClass"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UScriptStruct"), STR("bPrepareCppStructOpsCompleted"), -1); val != -1)
    Unreal::UScriptStruct::MemberOffsets.emplace(STR("bPrepareCppStructOpsCompleted"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("ActiveLevelCollectionIndex"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("ActiveLevelCollectionIndex"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("AudioDeviceHandle"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("AudioDeviceHandle"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("AudioTimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("AudioTimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("BlockTillLevelStreamingCompletedEpoch"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("BlockTillLevelStreamingCompletedEpoch"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("BuildStreamingDataTimer"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("BuildStreamingDataTimer"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("CleanupWorldTag"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("CleanupWorldTag"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("CommittedPersistentLevelName"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("CommittedPersistentLevelName"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("DebugDrawTraceTag"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("DebugDrawTraceTag"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("DeltaRealTimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("DeltaRealTimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("DeltaTimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("DeltaTimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("ExtraReferencedObjects"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("ExtraReferencedObjects"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("FullPurgeTriggered"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("FullPurgeTriggered"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("IsInBlockTillLevelStreamingCompleted"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("IsInBlockTillLevelStreamingCompleted"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("LWILastAssignedUID"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("LWILastAssignedUID"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("LastTimeUnbuiltLightingWasEncountered"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("LastTimeUnbuiltLightingWasEncountered"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("LevelSequenceActors"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("LevelSequenceActors"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NextSwitchCountdown"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NextSwitchCountdown"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NextURL"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NextURL"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumInvalidReflectionCaptureComponents"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumInvalidReflectionCaptureComponents"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumLightingUnbuiltObjects"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumLightingUnbuiltObjects"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumStreamingLevelsBeingLoaded"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumStreamingLevelsBeingLoaded"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumTextureStreamingDirtyResources"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumTextureStreamingDirtyResources"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumTextureStreamingUnbuiltComponents"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumTextureStreamingUnbuiltComponents"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("NumUnbuiltReflectionCaptures"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("NumUnbuiltReflectionCaptures"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("OriginOffsetThisFrame"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("OriginOffsetThisFrame"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("PauseDelay"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("PauseDelay"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("PerModuleDataObjects"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("PerModuleDataObjects"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("PlayerNum"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("PlayerNum"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("PreparingLevelNames"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("PreparingLevelNames"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("RealTimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("RealTimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("StreamingLevelsPrefix"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("StreamingLevelsPrefix"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("StreamingVolumeUpdateDelay"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("StreamingVolumeUpdateDelay"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("TimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("TimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("TimeSinceLastPendingKillPurge"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("TimeSinceLastPendingKillPurge"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("UnpausedTimeSeconds"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("UnpausedTimeSeconds"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("ViewLocationsRenderedLastFrame"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("ViewLocationsRenderedLastFrame"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bActorsInitialized"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bActorsInitialized"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bAggressiveLOD"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bAggressiveLOD"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bAllowAudioPlayback"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bAllowAudioPlayback"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bAllowDeferredPhysicsStateCreation"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bAllowDeferredPhysicsStateCreation"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bAreConstraintsDirty"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bAreConstraintsDirty"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bBegunPlay"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bBegunPlay"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bCleanedUpWorld"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bCleanedUpWorld"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bCreateRenderStateForHiddenComponents"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bCreateRenderStateForHiddenComponents"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bDebugDrawAllTraceTags"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bDebugDrawAllTraceTags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bDebugFrameStepExecution"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bDebugFrameStepExecution"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bDebugPauseExecution"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bDebugPauseExecution"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bDoDelayedUpdateCullDistanceVolumes"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bDoDelayedUpdateCullDistanceVolumes"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bDropDetail"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bDropDetail"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bHack_Force_UsesGameHiddenFlags_True"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bHack_Force_UsesGameHiddenFlags_True"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bInTick"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bInTick"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bInitializedAndNeedsCleanup"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bInitializedAndNeedsCleanup"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsBuilt"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsBuilt"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsCameraMoveableWhenPaused"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsCameraMoveableWhenPaused"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsDefaultLevel"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsDefaultLevel"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsLevelStreamingFrozen"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsLevelStreamingFrozen"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsRunningConstructionScript"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsRunningConstructionScript"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsTearingDown"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsTearingDown"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bIsWorldInitialized"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bIsWorldInitialized"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bKismetScriptError"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bKismetScriptError"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bMarkedObjectsPendingKill"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bMarkedObjectsPendingKill"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bMatchStarted"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bMatchStarted"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bMaterialParameterCollectionInstanceNeedsDeferredUpdate"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bMaterialParameterCollectionInstanceNeedsDeferredUpdate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bOriginOffsetThisFrame"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bOriginOffsetThisFrame"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bPlayersOnly"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bPlayersOnly"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bPlayersOnlyPending"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bPlayersOnlyPending"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bPostTickComponentUpdate"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bPostTickComponentUpdate"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bRequestedBlockOnAsyncLoading"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bRequestedBlockOnAsyncLoading"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bRequiresHitProxies"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bRequiresHitProxies"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bShouldDelayGarbageCollect"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bShouldDelayGarbageCollect"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bShouldForceUnloadStreamingLevels"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bShouldForceUnloadStreamingLevels"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bShouldForceVisibleStreamingLevels"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bShouldForceVisibleStreamingLevels"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bShouldSimulatePhysics"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bShouldSimulatePhysics"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bShouldTick"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bShouldTick"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bStartup"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bStartup"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bStreamingDataDirty"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bStreamingDataDirty"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bTickNewlySpawned"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bTickNewlySpawned"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bTriggerPostLoadMap"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bTriggerPostLoadMap"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UWorld"), STR("bWorldWasLoadedThisTick"), -1); val != -1)
    Unreal::UWorld::MemberOffsets.emplace(STR("bWorldWasLoadedThisTick"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FSetProperty"), STR("ElementProp"), -1); val != -1)
    Unreal::FSetProperty::MemberOffsets.emplace(STR("ElementProp"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassAddReferencedObjects"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassAddReferencedObjects"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassCastFlags"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassCastFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassConfigName"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassConfigName"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassConstructor"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassConstructor"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassDefaultObject"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassDefaultObject"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassFlags"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassFlags"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassGeneratedBy"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassGeneratedBy"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassUnique"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassUnique"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassVTableHelperCtorCaller"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassVTableHelperCtorCaller"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("ClassWithin"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("ClassWithin"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("FirstOwnedClassRep"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("FirstOwnedClassRep"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("Interfaces"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("Interfaces"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("NetFields"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("NetFields"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("SparseClassData"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("SparseClassData"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("SparseClassDataStruct"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("SparseClassDataStruct"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("UberGraphFramePointerProperty"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("UberGraphFramePointerProperty"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("bCooked"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("bCooked"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UClass"), STR("bLayoutChanging"), -1); val != -1)
    Unreal::UClass::MemberOffsets.emplace(STR("bLayoutChanging"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UEnum"), STR("CppForm"), -1); val != -1)
    Unreal::UEnum::MemberOffsets.emplace(STR("CppForm"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UEnum"), STR("CppType"), -1); val != -1)
    Unreal::UEnum::MemberOffsets.emplace(STR("CppType"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UEnum"), STR("EnumDisplayNameFn"), -1); val != -1)
    Unreal::UEnum::MemberOffsets.emplace(STR("EnumDisplayNameFn"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UEnum"), STR("EnumFlags_Internal"), -1); val != -1)
    Unreal::UEnum::MemberOffsets.emplace(STR("EnumFlags_Internal"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("UEnum"), STR("Names"), -1); val != -1)
    Unreal::UEnum::MemberOffsets.emplace(STR("Names"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FMapProperty"), STR("KeyProp"), -1); val != -1)
    Unreal::FMapProperty::MemberOffsets.emplace(STR("KeyProp"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FMapProperty"), STR("ValueProp"), -1); val != -1)
    Unreal::FMapProperty::MemberOffsets.emplace(STR("ValueProp"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FStructProperty"), STR("Struct"), -1); val != -1)
    Unreal::FStructProperty::MemberOffsets.emplace(STR("Struct"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FArrayProperty"), STR("Inner"), -1); val != -1)
    Unreal::FArrayProperty::MemberOffsets.emplace(STR("Inner"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FByteProperty"), STR("Enum"), -1); val != -1)
    Unreal::FByteProperty::MemberOffsets.emplace(STR("Enum"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FClassProperty"), STR("MetaClass"), -1); val != -1)
    Unreal::FClassProperty::MemberOffsets.emplace(STR("MetaClass"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FInterfaceProperty"), STR("InterfaceClass"), -1); val != -1)
    Unreal::FInterfaceProperty::MemberOffsets.emplace(STR("InterfaceClass"), static_cast<int32_t>(val));
if (auto val = parser.get_int64(STR("FFieldPathProperty"), STR("PropertyClass"), -1); val != -1)
    Unreal::FFieldPathProperty::MemberOffsets.emplace(STR("PropertyClass"), static_cast<int32_t>(val));

```

`generated_include/build_number.hpp`:

```hpp
#define UE4SS_LIB_BUILD_NUMBER 6012

```

`generated_src/build_number.cache`:

```cache
6012
```

`generated_src/build_number.cmake`:

```cmake
cmake_minimum_required(VERSION 3.17)
set(CMAKE_VERBOSE_MAKEFILE on)

if (NOT RC_SOURCE_DIR)
    message("RC_SOURCE_DIR was undefined")
    return()
endif ()

# Config
set(BUILD_NUMBER_CACHE_FILE "${UE4SS_GENERATED_SOURCE_DIR}/build_number.cache")
set(RC_BUILD_NUMBER_HEADER_FILE "${UE4SS_GENERATED_INCLUDE_DIR}/build_number.hpp")

# Fetch & increment build number
if (EXISTS ${BUILD_NUMBER_CACHE_FILE})
    file(READ ${BUILD_NUMBER_CACHE_FILE} RC_BUILD_NUMBER)
    math(EXPR RC_BUILD_NUMBER "${RC_BUILD_NUMBER} + 1")
else ()
    set(RC_BUILD_NUMBER "0")
endif ()

file(WRITE ${BUILD_NUMBER_CACHE_FILE} "${RC_BUILD_NUMBER}")

# Make build number available by generating a header file
file(WRITE ${RC_BUILD_NUMBER_HEADER_FILE} "#define UE4SS_LIB_BUILD_NUMBER ${RC_BUILD_NUMBER}\n")

message("UE4SS_GENERATED_SOURCE_DIR: ${UE4SS_GENERATED_SOURCE_DIR}")
message("RC_SOURCE_DIR: ${RC_SOURCE_DIR}")
message("CMAKE_SOURCE_DIR: ${CMAKE_SOURCE_DIR}")
message("RC Build Number: ${RC_BUILD_NUMBER}")


```

`generated_src/version.cache`:

```cache
2.0.0.0.0 

```

`git_help.txt`:

```txt
To push new changes:
git add -A
git commit -m "message"

To change branch (save / discard changes first):
git checkout "branch name"

To create a new branch & switch to it with the current state of your files:
1. execute once: git checkout -b "name for new branch"
2. execute once: git push --set-upstream origin name-for-new-branch

To create a new tag and push it to remote:
1. execute once: git tag -a vx.x.x.x -m "version"
2. execute once: git push origin --tags

```

`include/ExceptionHandling.hpp`:

```hpp
#ifndef UE4SS_EXCEPTION_HANDLING_HPP
#define UE4SS_EXCEPTION_HANDLING_HPP

#include <stdexcept>

#include <Helpers/String.hpp>
#include <DynamicOutput/DynamicOutput.hpp>

namespace RC
{
    // Will try some code and properly propagate any exceptions
    // This is a simple helper function to avoid having 15 extra lines of code everywhere
    template<typename CodeToTry>
    auto constexpr TRY(CodeToTry code_to_try)
    {
        try
        {
            return code_to_try();
        }
        catch (std::exception& e)
        {
            if (!Output::has_internal_error())
            {
                Output::send<LogLevel::Error>(STR("Error: {}\n"), to_wstring(e.what()));
            }
            else
            {
                printf_s("Internal Error: %s\n", e.what());
            }

            using LambdaReturnType = decltype(code_to_try());
            if constexpr (!std::is_same_v<LambdaReturnType, void>)
            {
                return LambdaReturnType{};
            }
        }
    }
}

#endif //UE4SS_EXCEPTION_HANDLING_HPP

```

`include/GUI/Console.hpp`:

```hpp
#ifndef UE4SS_GUI_CONSOLE_HPP
#define UE4SS_GUI_CONSOLE_HPP

#include <vector>
#include <string>
#include <mutex>

#include <DynamicOutput/OutputDevice.hpp>
#include <imgui.h>
#include <TextEditor.h>

using namespace RC;

namespace RC::GUI
{
    class Console
    {
    private:
        char m_input_buffer[256]{};
        std::vector<std::string> m_lines{};
        ImGuiTextFilter m_filter{};
        float m_previous_max_scroll_y{};
        float m_current_console_output_width{};
        std::mutex m_lines_mutex{};
        TextEditor m_text_editor{};
        TextEditor::Breakpoints  m_breakpoints{};
        const size_t m_maximum_num_lines{50000};

    public:
        Console()
        {
            m_text_editor.SetConsoleMode(true);
            m_text_editor.SetColorizerEnable(false);
            m_text_editor.SetLanguageDefinition(GetLanguageDefinitionNone());
            m_text_editor.SetPalette(GetPalette());
            m_text_editor.GetErrorMarkers().emplace(6, "Test error");
            m_breakpoints.emplace(5);
            m_text_editor.SetBreakpoints(m_breakpoints);
            m_text_editor.SetTextFilter(&m_filter);
            m_text_editor.GetLineColorMarkers().emplace(4, std::pair{ImColor(148, 36, 20, 255), ImColor(255, 255, 255, 255)});
        }

    private:
        auto GetLanguageDefinitionNone() -> const TextEditor::LanguageDefinition&;
        auto GetPalette() const -> const TextEditor::Palette&;

    public:
        auto render() -> void;
        auto render_search_box() -> void;
        auto add_line(const std::string&, LogLevel::LogLevel) -> void;
        auto add_line(const std::wstring&, LogLevel::LogLevel) -> void;
    };
}

#endif //UE4SS_GUI_CONSOLE_HPP

```

`include/GUI/ConsoleOutputDevice.hpp`:

```hpp
#ifndef UE4SS_CONSOLE_OUTPUT_DEVICE_HPP
#define UE4SS_CONSOLE_OUTPUT_DEVICE_HPP

#ifdef UE4SS_CONSOLE_COLORS_ENABLED
#include <mutex>
#endif

#include <DynamicOutput/Common.hpp>
#include <DynamicOutput/OutputDevice.hpp>
#include <DynamicOutput/Macros.hpp>

namespace RC::Output
{
    // Very simple class that outputs to stdout
    class ConsoleDevice : public OutputDevice
    {
    public:
#if ENABLE_OUTPUT_DEVICE_DEBUG_MODE
        ConsoleDevice()
        {
            fmt::print("ConsoleDevice opening...\n");
        }

        ~ConsoleDevice() override
        {
            fmt::print("ConsoleDevice closing...\n");
        }
#else
        ~ConsoleDevice() override = default;
#endif

    public:
        auto has_optional_arg() const -> bool override;
        auto receive(File::StringViewType fmt) const -> void override;
        auto receive_with_optional_arg(File::StringViewType fmt, int32_t optional_arg = 0) const -> void override;
    };
}


#endif //UE4SS_CONSOLE_OUTPUT_DEVICE_HPP

```

`include/GUI/DX11.hpp`:

```hpp
#ifndef UE4SS_GUI_DX11_HPP
#define UE4SS_GUI_DX11_HPP

#include <GUI/GUI.hpp>

namespace RC::GUI
{
    class Backend_DX11 : public GfxBackendBase
    {
    public:
        ~Backend_DX11() = default;

    public:
        auto init() -> void override;
        auto imgui_backend_newframe() -> void override;
        auto render(const float clear_color_with_alpha[4]) -> void override;
        auto shutdown() -> void override;
        auto cleanup() -> void override;
        auto create_device() -> bool override;
        auto cleanup_device() -> void override;
        auto handle_window_resize(int64_t param_1, int64_t param_2) -> void override;
        auto on_os_backend_set() -> void override;
    };
}

#endif //UE4SS_GUI_DX11_HPP

```

`include/GUI/Dumpers.hpp`:

```hpp
#ifndef UE4SS_GUI_DUMPERS_HPP
#define UE4SS_GUI_DUMPERS_HPP

namespace RC::GUI::Dumpers
{
    auto render() -> void;
}

#endif //UE4SS_GUI_NARKNONS_PLAY_AREA_HPP

```

`include/GUI/GUI.hpp`:

```hpp
#ifndef UE4SS_GUI_HPP
#define UE4SS_GUI_HPP

#include <thread>
#include <memory>
#include <functional>

#include <GUI/Console.hpp>
#include <GUI/LiveView.hpp>
#include <Helpers/String.hpp>
#include <imgui.h>

namespace RC::GUI
{
    enum class GfxBackend
    {
        DX11,
    };

    enum class OSBackend
    {
        Windows,
    };

    struct WindowRect
    {
        long left;
        long top;
        long right;
        long bottom;
    };

    class GfxBackendBase
    {
    protected:
        class OSBackendBase* m_os_backend{};

    public:
        GfxBackendBase() = default;

    public:
        auto set_os_backend(OSBackendBase* backend) { m_os_backend = backend; }

    public:
        virtual auto init() -> void = 0;
        virtual auto imgui_backend_newframe() -> void = 0;
        virtual auto render(const float clear_color_with_alpha[4]) -> void = 0;
        virtual auto shutdown() -> void = 0;
        virtual auto cleanup() -> void = 0;
        virtual auto create_device() -> bool = 0;
        virtual auto cleanup_device() -> void = 0;
        virtual auto handle_window_resize(int64_t param_1, int64_t param_2) -> void = 0;
        virtual auto on_os_backend_set() -> void = 0;
    };

    class OSBackendBase
    {
    protected:
        class GfxBackendBase* m_gfx_backend{};

    public:
        OSBackendBase() = default;

    public:
        auto set_gfx_backend(GfxBackendBase* backend) { m_gfx_backend = backend; }

    public:
        virtual auto init() -> void = 0;
        virtual auto imgui_backend_newframe() -> void = 0;
        virtual auto create_window() -> void = 0;
        virtual auto exec_message_loop(bool* exit_requested) -> void = 0;
        virtual auto shutdown() -> void = 0;
        virtual auto cleanup() -> void = 0;
        virtual auto get_window_handle() -> void* = 0;
        virtual auto get_window_rect() -> WindowRect = 0;
        virtual auto on_gfx_backend_set() -> void = 0;
    };

    extern ImColor g_imgui_bg_color;
    extern ImColor g_imgui_bg_hover_color;
    extern ImColor g_imgui_bg_active_color;
    extern ImColor g_imgui_bg_header_color;
    extern ImColor g_imgui_bg_header_hover_color;
    extern ImColor g_imgui_bg_header_active_color;
    extern ImColor g_imgui_text_color;
    extern ImColor g_imgui_text_inactive_color;
    extern ImColor g_imgui_text_editor_default_bg_color;
    extern ImColor g_imgui_text_editor_default_text_color;
    extern ImColor g_imgui_text_editor_normal_bg_color;
    extern ImColor g_imgui_text_editor_normal_text_color;
    extern ImColor g_imgui_text_editor_verbose_bg_color;
    extern ImColor g_imgui_text_editor_verbose_text_color;
    extern ImColor g_imgui_text_editor_warning_bg_color;
    extern ImColor g_imgui_text_editor_warning_text_color;
    extern ImColor g_imgui_text_editor_error_bg_color;
    extern ImColor g_imgui_text_editor_error_text_color;
    extern ImColor g_imgui_text_live_view_unreflected_data_color;

    class DebuggingGUIBase
    {
    private:
        Console m_console{};

    public:
        auto get_console() -> Console& { return m_console; };

    public:
        virtual auto setup(std::stop_token&& token) -> void = 0;
    };

    //template<Backend SelectedBackend>
    class DebuggingGUI/* : public DebuggingGUIBase*/
    {
    public:
        using EndOfFrameCallback = std::function<void()>;

    private:
        std::unique_ptr<GfxBackendBase> m_gfx_backend{};
        std::unique_ptr<OSBackendBase> m_os_backend{};
        Console m_console{};
        LiveView m_live_view{};
        std::stop_token m_thread_stop_token{};
        bool m_is_open{};
        bool m_exit_requested{};

    public:
        bool m_event_thread_busy{};

    private:
        static std::vector<EndOfFrameCallback> s_end_of_frame_callbacks;

    public:
        DebuggingGUI() = delete;
        DebuggingGUI(GfxBackend selected_gfx_backend, OSBackend selected_os_backend);
        ~DebuggingGUI();

    public:
        auto is_open() -> bool { return m_is_open; };
        auto setup(std::stop_token&& token) -> void/* override*/;
        auto get_console() -> Console& { return m_console; };
        auto get_live_view() -> LiveView& { return m_live_view; };

    private:
        auto on_update() -> void;
        auto main_loop_internal() -> void;

    public:
        static auto execute_at_end_of_frame(EndOfFrameCallback callback) -> void;
    };

    auto gui_thread(std::stop_token stop_token, DebuggingGUI* debugging_ui) -> void;

    // Helper function for executing code that can throw exceptions in the middle of a frame.
    // Moves the exception to the end of the frame so that we can ImGUI errors.
    template<typename CodeToTry>
    auto TRY(CodeToTry code_to_try)
    {
        DebuggingGUI::execute_at_end_of_frame([&] {
            code_to_try();
        });
    }
}

#endif //UE4SS_GUI_HPP

```

`include/GUI/ImGuiUtility.hpp`:

```hpp
#ifndef UE4SS_GUI_IMGUI_UTILITY_HPP
#define UE4SS_GUI_IMGUI_UTILITY_HPP

#include <JSON/JSON.hpp>
//#include <JSONParser/JSON.hpp>
#include <JSON/Parser/Parser.hpp>
#include <imgui.h>

namespace RC::GUI
{
    auto ImGui_AutoScroll(const char* label, float* previous_max_scroll_y) -> void;
    auto ImGui_InputTextMultiline_WithAutoScroll(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = 0, void* user_data = 0, float* previous_max_scroll_y = nullptr);
    auto ImGui_Splitter(bool split_vertically, float thickness, float* size1, float* size2, float min_size1, float min_size2, float splitter_long_axis_size = -1.0f) -> bool;
}

#endif //UE4SS_GUI_IMGUI_UTILITY_HPP

```

`include/GUI/LiveView.hpp`:

```hpp
#ifndef UE4SS_GUI_LIVE_VIEW_HPP
#define UE4SS_GUI_LIVE_VIEW_HPP

#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <functional>

#include <DynamicOutput/DynamicOutput.hpp>

namespace RC::Unreal
{
    class FUObjectItem;
    class UObject;
    class UStruct;
    class UClass;
    class FProperty;
}

namespace RC::GUI
{
    using namespace RC::Unreal;

    class LiveView
    {
    public:
        using ObjectIteratorCallable = void(LiveView::*)(int32_t, int32_t, const std::function<void(UObject*)>&);

        struct WatchIdentifier
        {
            void* container{};
            void* property{};

            auto operator==(const WatchIdentifier& rhs) const -> bool
            {
                return container == rhs.container && property == rhs.property;
            }
        };

        struct Watch
        {
            enum class AcquisitionMethod
            {
                StaticFindObject,
                FindFirstOf,
            };

            Output::Targets<Output::FileDevice> output{};
            FProperty* property{};
            UObject* container{};
            StringType object_name{};
            StringType property_name{};
            StringType property_value{};
            size_t hash{};
            std::string history{};
            float history_previous_max_scroll_y{};
            AcquisitionMethod acquisition_method{};
            bool write_to_file{};
            bool show_history{};
            bool load_on_startup{};
            bool was_stop_load_on_startup_requested{};
            bool enabled{};

            Watch() = delete;
            Watch(StringType&& object_name, StringType&& property_name);
        };

    private:
        std::string_view m_default_search_buffer{"Search by type, path, and name..."};
        constexpr static size_t m_search_buffer_capacity = 2000;
        char* m_search_by_name_buffer{};
        ObjectIteratorCallable m_object_iterator{&LiveView::guobjectarray_iterator};
        std::unordered_set<UObject*> m_opened_tree_nodes{};
        UObject* m_currently_opened_tree_node{};
        float m_top_size{300.0f};
        float m_bottom_size{0.0f};
        bool m_is_searching_by_name{};
        bool m_search_field_clear_requested{};
        bool m_search_field_cleared{};
        bool m_modal_tried_to_open_nullptr_object_is_open{};
        bool m_listeners_set{};
        bool m_listeners_are_required{};
        bool m_is_initialized{};

    public:
        LiveView();
        ~LiveView();

    public:
        struct ObjectOrProperty
        {
            union
            {
                const FUObjectItem* object_item{};
                FProperty* property;
            };
            UObject* object{};
            bool is_object{};
        };

    public:
        static std::vector<ObjectOrProperty> s_object_view_history;
        static size_t s_currently_selected_object_index;
        static std::unordered_map<UObject*, std::vector<size_t>> s_history_object_to_index;
        static std::vector<UObject*> s_name_search_results;
        static std::unordered_set<UObject*> s_name_search_results_set;
        static std::string s_name_to_search_by;
        static std::vector<Watch> s_watches;
        static std::unordered_map<WatchIdentifier, Watch*> s_watch_map;
        static std::unordered_map<void*, std::vector<Watch*>> s_watch_containers;
        static bool s_create_listener_removed;
        static bool s_delete_listener_removed;
        static bool s_selected_item_deleted;
        static bool s_need_to_filter_out_properties;
        static bool s_watches_loaded_from_disk;

    private:
        enum class AffectsHistory { Yes, No };

    public:
        enum class UseIndex { Yes, No };

    private:
        auto render_info_panel() -> void;
        auto render_info_panel_as_object(const FUObjectItem*, UObject*) -> void;
        auto render_info_panel_as_property(FProperty*) -> void;
        auto render_properties() -> void;
        auto render_object_sub_tree_hierarchy(UObject* object) -> void;
        auto render_struct_sub_tree_hierarchy(UStruct* ustruct) -> void;
        auto render_class(UClass*) -> void;
        auto render_super_struct(UStruct*) -> void;

    private:
        auto collapse_all_except(void* except_id) -> void;
        auto search_by_name() -> void;
        auto select_object(size_t index, const FUObjectItem* object_item, UObject* object, AffectsHistory = AffectsHistory::Yes) -> void;
        auto select_property(size_t index, FProperty* property, AffectsHistory affects_history) -> void;
        auto get_selected_object_or_property() -> const ObjectOrProperty&;
        auto get_selected_object(size_t index = 0, UseIndex = UseIndex::No) -> std::pair<const FUObjectItem*, UObject*>;
        auto get_selected_property(size_t index = 0, UseIndex = UseIndex::No) -> FProperty*;

    private:
        auto guobjectarray_iterator(int32_t int_data_1, int32_t int_data_2, const std::function<void(UObject*)>& callable) -> void;
        auto guobjectarray_by_name_iterator([[maybe_unused]]int32_t int_data_1, [[maybe_unused]]int32_t int_data_2, const std::function<void(UObject*)>& callable) -> void;

    public:
        auto was_search_field_clear_requested() -> bool { return m_search_field_clear_requested; }
        auto was_search_field_cleared() -> bool { return m_search_field_cleared; }
        auto set_search_field_cleared(bool new_value) -> void { m_search_field_cleared = new_value; }

    public:
        auto set_listeners() -> void;
        auto unset_listeners() -> void;
        auto initialize() -> void;
        auto render() -> void;
        auto render_watches() -> void;
        auto process_watches() -> void;
        auto set_listeners_are_required(bool new_value) -> void { m_listeners_are_required = new_value; }
        auto are_listeners_requried() -> bool { return m_listeners_are_required; }
    };
}

namespace std
{
    template<>
    struct hash<::RC::GUI::LiveView::WatchIdentifier>
    {
        auto operator()(const ::RC::GUI::LiveView::WatchIdentifier& watch_identifier) const -> size_t
        {
            size_t container_hash = hash<void*>()(watch_identifier.container);
            size_t property_hash = hash<void*>()(watch_identifier.property);
            return container_hash ^ property_hash;
        }
    };
}

#endif //UE4SS_GUI_LIVE_VIEW_HPP

```

`include/GUI/Windows.hpp`:

```hpp
#ifndef UE4SS_GUI_WINDOWS_HPP
#define UE4SS_GUI_WINDOWS_HPP

#include <GUI/GUI.hpp>

namespace RC::GUI
{
    class Backend_Windows : public OSBackendBase
    {
    public:
        ~Backend_Windows() = default;

    public:
        auto init() -> void override;
        auto imgui_backend_newframe() -> void override;
        auto create_window() -> void override;
        auto exec_message_loop(bool* exit_requested) -> void override;
        auto shutdown() -> void override;
        auto cleanup() -> void override;
        auto get_window_handle() -> void* override;
        auto get_window_rect() -> WindowRect override;
        auto on_gfx_backend_set() -> void override;
    };
}

#endif //UE4SS_GUI_WINDOWS_HPP

```

`include/LuaCustomMemberFunctions.hpp`:

```hpp
#ifndef UE4SS_LUACUSTOMMEMBERFUNCTIONS_HPP
#define UE4SS_LUACUSTOMMEMBERFUNCTIONS_HPP

#include <unordered_map>

#include <lua.hpp>
#include <Unreal/PrimitiveTypes.hpp>
#include <Unreal/FScriptArray.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/Property/FObjectProperty.hpp>

namespace RC
{
    extern std::unordered_map<Unreal::FName, Unreal::UScriptStruct*> g_script_struct_cache_map;

    auto setup_script_struct_cache_map() -> void;
    auto setup_global_metatable(lua_State*) -> void;

    auto UObjectBase_memberr_function_wrapper_MyTestFunc(lua_State*) -> int;
    auto UObjectBase_member_function_wrapper_GetNamePrivate(lua_State*) -> int;
    auto UObjectBase_member_function_wrapper_Cast(lua_State*) -> int;
    auto FField_member_function_wrapper_CastField(lua_State*) -> int;
    auto UEnum_member_function_wrapper_ForEachName(lua_State*) -> int;
    auto UClass_member_function_wrapper_StaticClass(lua_State*) -> int;

    auto UObjectBase_metamethod_wrapper_Index(lua_State*, void*) -> int;
    auto UObjectBase_metamethod_wrapper_NewIndex(lua_State*, void*) -> int;
    auto UFunction_metamethod_wrapper_Call(lua_State*, void*) -> int;
    auto UObjectBaseUtility_metamethod_wrapper_Index(lua_State*, void*) -> int;
    auto UObjectBaseUtility_metamethod_wrapper_NewIndex(lua_State*, void*) -> int;
    auto ArrayTest_metamethod_wrapper_GC(lua_State*, void*) -> int;
    auto LuaUScriptStruct_metamethod_wrapper_Index(lua_State*, void*) -> int;
    auto LuaUScriptStruct_metamethod_wrapper_NewIndex(lua_State*, void*) -> int;
    auto LuaUScriptStruct_metamethod_wrapper_GC(lua_State*, void*) -> int;

    auto ArrayTest_member_function_wrapper_GetElementAtIndex(lua_State*) -> int;
    auto ArrayTest_member_function_wrapper_ForEach(lua_State*) -> int;

    auto lua_warn_wrapper(lua_State*) -> int;
    auto lua_print_wrapper(lua_State*) -> int;
    auto lua_FindAllOf_wrapper(lua_State*) -> int;
    auto lua_RegisterKeyBind_wrapper(lua_State*) -> int;
}

namespace RC::LuaBackCompat
{
    using namespace RC::Unreal;

    // Backwards compatibility with UE4SS 1.3.

    auto StaticFindObject(UClass* ObjectClass, UObject* InObjectPackage, const wchar_t* OrigInName, bool bExactClass = false) -> UObject*;
    auto StaticFindObject(const wchar_t* OrigInName) -> UObject*;
    auto NotifyOnNewObject(const wchar_t* class_name, std::function<void(UObject*)>& callable) -> void;

    auto lua_RegisterHook_wrapper(lua_State*) -> int;
    auto lua_UObjectBase_IsA_wrapper(lua_State*) -> int;
}

namespace RC::UnrealRuntimeTypes
{
    using namespace Unreal;

    struct ToLuaParams
    {
        void* base{};
        void** out_data{};
        FProperty* property{};
        UFunction* function{};
        uint32_t pointer_depth{};
        bool base_no_processing_required{};
        bool should_copy_script_struct_contents{};
        bool should_containerize{}; // Only for types that are not already containerized by default.
        int32_t lua_stack_index{-1};

        // Add variable 'containerize_trivial_value' later if there's a need to create, for example, already existing integers in memory that can be accessed & altered.
        // If the variable is true then the integer handler should pass the pointer to the integer to 'lua_int32_t_to_lua_from_heap' instead of passing the integer value to lua_pushinteger.
    };
    using FromLuaParams = ToLuaParams;

    extern std::unordered_map<FName, void (*)(lua_State*, ToLuaParams)> g_unreal_property_to_lua;
    extern std::unordered_map<FName, void (*)(lua_State*, FromLuaParams)> g_unreal_property_from_lua;

    auto populate_unreal_property_to_lua_map() -> void;

    auto ObjectProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto ClassProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto Int8Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto Int16Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto IntProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto Int64Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto ByteProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto UInt16Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto UInt32Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto UInt64Property_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto StructProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto ArrayProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto FloatProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto DoubleProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto BoolProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto EnumProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto WeakObjectProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto NameProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto TextProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto StrProperty_to_lua(lua_State* lua_state, ToLuaParams) -> void;
    auto function_to_lua(lua_State* lua_state, ToLuaParams) -> void;

    auto ObjectProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto ClassProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto Int8Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto Int16Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto IntProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto Int64Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto ByteProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto UInt16Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto UInt32Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto UInt64Property_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto StructProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto ArrayProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto FloatProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto DoubleProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto BoolProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto EnumProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto WeakObjectProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto NameProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto TextProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;
    auto StrProperty_from_lua(lua_State* lua_state, FromLuaParams) -> void;

    auto Array_Type_Handler_Ptr() -> void;
    auto Array_Type_Handler_WChar_T() -> void;

    class Array
    {
    private:
        FScriptArray* ScriptArray{};
        FArrayProperty* Type{};
        int32_t TypeSize{};
        size_t TypeAlignment{};
        using TypeHandlerFunction = void(*)();
        using TypeHandlerMap = std::unordered_map<std::string, TypeHandlerFunction>;
        TypeHandlerMap TypeHandlers{
                {"Pointer", &Array_Type_Handler_Ptr},
                {"wchar_t", &Array_Type_Handler_WChar_T},
        };

    public:
        Array(size_t TypeSize, std::vector<std::string>& TypeNames);

    public:
        FScriptArray* GetScriptArray() { return ScriptArray; }
        FArrayProperty* GetType() { return Type; }

        template <typename CallableType>
        auto WithScriptArray(CallableType&& Callable) const
        {
            return Callable(ScriptArray);
        }

        int32 AddUninitializedValues(int32 Count)
        {
            const int32 OldNum = WithScriptArray([this, Count](auto* Array) { return Array->Add(Count, TypeSize, TypeAlignment); });
            return OldNum;
        }
    };

    template<typename T>
    concept HasStaticClassMemberFunction =
    requires(T t) {
        { T::StaticClass() };
    };

    struct ArrayTest
    {
    private:
        FScriptArray* ScriptArray{};
        FScriptArray InlineScriptArray{};
        bool IsScriptArrayInline{};

    public:
        size_t ElementSize{};
        size_t ElementMinAlignment{};
        std::string TypeName{};
        FArrayProperty* Property{};
        bool TypeIsAlwaysPointer{};

    private:
        uint8* GetRawPtr(int32 Index = 0)
        {
            if (!Num())
            {
                return NULL;
            }
            return static_cast<uint8*>(GetElementAtIndex(Index));
        }

        void DestructItems(int32 Index, int32 Count)
        {
            if (!(Property->GetPropertyFlags() & (CPF_IsPlainOldData | CPF_NoDestructor)))
            {
                if (Count > 0)
                {
                    uint8* Dest = GetRawPtr(Index);
                    for (int32 LoopIndex = 0; LoopIndex < Count; LoopIndex++, Dest += ElementSize)
                    {
                        Property->DestroyValue(Dest);
                    }
                }
            }
        }

    public:
        // Script constructor! Do not use directly!
        ArrayTest() : IsScriptArrayInline(true)
        {
            // Property to be later by the scripting system.
        }

        ArrayTest(FScriptArray* ScriptArray,
                  size_t ElementSize,
                  size_t ElementMinAlignment,
                  const std::string& TypeName,
                  bool TypeIsAlwaysPointer,
                  FArrayProperty* Property = nullptr) : ScriptArray(ScriptArray),
                                                        IsScriptArrayInline(false),
                                                        ElementSize(ElementSize),
                                                        ElementMinAlignment(ElementMinAlignment),
                                                        TypeName(TypeName),
                                                        TypeIsAlwaysPointer(TypeIsAlwaysPointer),
                                                        Property(Property) {}

        ArrayTest(FScriptArray&& ScriptArray,
                  size_t ElementSize,
                  size_t ElementMinAlignment,
                  const std::string& TypeName,
                  bool TypeIsAlwaysPointer,
                  FArrayProperty* Property = nullptr) : ScriptArray(nullptr),
                                                        InlineScriptArray(std::move(ScriptArray), ElementSize, ElementMinAlignment),
                                                        IsScriptArrayInline(true),
                                                        ElementSize(ElementSize),
                                                        ElementMinAlignment(ElementMinAlignment),
                                                        TypeName(TypeName),
                                                        TypeIsAlwaysPointer(TypeIsAlwaysPointer),
                                                        Property(Property) {}

        ArrayTest(ArrayTest&& From)
        {
            if (!From.IsScriptArrayInline)
            {
                ScriptArray = From.ScriptArray;
                From.ScriptArray = nullptr;
            }
            else
            {
                InlineScriptArray.MoveAssign(From.InlineScriptArray, From.ElementSize, From.ElementMinAlignment);
            }
            IsScriptArrayInline = std::move(From.IsScriptArrayInline);
            ElementSize = std::move(From.ElementSize);
            ElementMinAlignment = std::move(From.ElementMinAlignment);
            TypeName = std::move(From.TypeName);
            Property = std::move(From.Property);
            TypeIsAlwaysPointer = std::move(From.TypeIsAlwaysPointer);
        }

        ~ArrayTest()
        {
            if (!GetScriptArray()) { return; }
            if (Property)
            {
                if (IsScriptArrayInline)
                {
                    DestructItems(0, Num());
                }
            }
            else
            {
                GetScriptArray()->Empty(0, ElementSize, ElementMinAlignment);
                ScriptArray = nullptr;
            }
        }

        FScriptArray* GetScriptArray()
        {
            if (IsScriptArrayInline)
            {
                return &InlineScriptArray;
            }
            else
            {
                return ScriptArray;
            }
        }

        auto Num() -> int32 { return GetScriptArray() ? GetScriptArray()->Num() : 0; }
        auto Max() -> int32 { return GetScriptArray() ? GetScriptArray()->Max() : 0; }

        using FuncParamType = bool(*)(int);
        typedef bool(*FuncParamTypedef)(int);
        auto FuncTestOne(bool(*func_param)(int)) -> void { func_param(1); }
        auto FuncTestTwo(FuncParamType func_param) -> void { func_param(2); }
        auto FuncTestThree(FuncParamTypedef func_param) -> void { func_param(3); }
        auto FuncTestFour(std::function<bool(int)> func_param) -> void { func_param(4); }

        auto ForEach(LoopAction(*Callable)(int Index, void* Element)) -> void
        {
            if (!GetScriptArray() || !GetScriptArray()->GetData() || GetScriptArray()->IsEmpty()) { return; }

            printf_s("ScriptArray: %p\n", GetScriptArray());
            printf_s("Data: %p\n", GetScriptArray()->GetData());
            printf_s("*Data: %p\n", *(void**)GetScriptArray()->GetData());
            for (int i = 0; i < GetScriptArray()->Num(); ++i)
            {
                const auto Element = std::bit_cast<void*>(std::bit_cast<char*>(GetScriptArray()->GetData()) + ElementMinAlignment * i);
                // For type-information, we might need to store the UClass pointer instead of just the size & alignment.
                // That might collide with properties whenever support for that is added.
                // Maybe we can store both, one being nullptr when not applicable.
                //printf_s("[%i] Element: %p\n", i, Element);
                if (Callable(i, Element) == LoopAction::Break) { break; }
            }
        }

        auto GetElementAtIndex(int32 index) -> void*
        {
            if (!GetScriptArray() || !GetScriptArray()->GetData() || GetScriptArray()->IsEmpty()) { return nullptr; }
            printf_s("ScriptArray: %p\n", GetScriptArray());
            printf_s("Data: %p\n", GetScriptArray()->GetData());
            printf_s("*Data: %p\n", *(void**)GetScriptArray()->GetData());

            if (!GetScriptArray()->IsValidIndex(index)) { return nullptr; }

            auto Element = std::bit_cast<void*>(std::bit_cast<char*>(GetScriptArray()->GetData()) + ElementMinAlignment * index);
            printf_s("[%i] Element: %p\n", index, Element);
            return Element;
        }
    };

    struct LuaUScriptStruct
    {
        UObject* base{};
        FStructProperty* struct_property{};
        UScriptStruct* script_struct{};
        bool is_user_constructed{};

        LuaUScriptStruct(UObject* base, FStructProperty* struct_property, UScriptStruct* script_struct, bool is_user_constructed = false) :
                base(base),
                struct_property(struct_property),
                script_struct(script_struct),
                is_user_constructed(is_user_constructed) {}

        LuaUScriptStruct(const LuaUScriptStruct& from)
        {
            if (from.is_user_constructed && from.script_struct)
            {
                auto struct_ops = from.script_struct->GetCppStructOps();
                base = static_cast<UObject*>(FMemory::Malloc(struct_ops->GetSize(), struct_ops->GetAlignment()));
                from.script_struct->CopyScriptStruct(base, from.base);
            }
            else
            {
                base = from.base;
            }
            struct_property = from.struct_property;
            script_struct = from.script_struct;
            is_user_constructed = from.is_user_constructed;
        }

        LuaUScriptStruct(LuaUScriptStruct&& from) noexcept
        {
            base = from.base;
            struct_property = from.struct_property;
            script_struct = from.script_struct;
            is_user_constructed = from.is_user_constructed;
            from.base = nullptr;
            from.struct_property = nullptr;
            from.script_struct = nullptr;
            from.is_user_constructed = false;
        }

        ~LuaUScriptStruct()
        {
            if (is_user_constructed && script_struct && base)
            {
                // This might need to be moved elsewhere.
                // Could you have a situation where you have a user-constructed struct that's moved or is referenced outside the Lua script ?
                // If yes, then we can't free here because it will cause use-after-free.
                // If no, then we can and should free here.
                // Since this is a UScriptStruct, which as far as I know are always inlined into other structs or objects when not constructed by the user,
                // it should be safe to free here as there would be no place to reference it. It's mostly (only ?) used for temporary logic in a function or as a UFunction param.
                script_struct->DestroyStruct(base);
                FMemory::Free(base);
                base = nullptr;
            }
        }
    };
}

#endif //UE4SS_LUACUSTOMMEMBERFUNCTIONS_HPP

```

`include/LuaLibrary.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUALIBRARY_HPP
#define UE4SS_REWRITTEN_LUALIBRARY_HPP

#include <cstdint>

#define DefaultStructMemberData(member_name) \
union {                                      \
const char* as_string{};                     \
uint32_t as_int;                             \
float as_float;                              \
} member_name;

struct lua_State;

namespace RC::Unreal
{
    class FOutputDevice;
}

namespace RC::LuaMadeSimple
{
    class Lua;
}

namespace RC::LuaLibrary
{
    auto get_outputdevice_ref(const LuaMadeSimple::Lua&) -> const Unreal::FOutputDevice*;
    auto set_outputdevice_ref(const LuaMadeSimple::Lua&, Unreal::FOutputDevice*) -> void;

    // Global Lua functions are meant to be called with intact Lua stack
    auto global_print(const LuaMadeSimple::Lua&) -> int;

    // Used exclusively for the scripts inside the 'UE4SS_Signatures' folder
    auto deref_to_int32(const LuaMadeSimple::Lua&) -> int;

    // Shared functions, to be used externally (via exporting or some other way of sharing functions)

    enum class ExportedFunctionStatus
    {
        NO_ERROR_TO_EXPORT = 0,
        SUCCESS = 1,
        VARIABLE_NOT_FOUND = 2,
        MOD_IS_NULLPTR = 3,
        SCRIPT_FUNCTION_RETURNED_FALSE = 4,
        UNABLE_TO_CALL_SCRIPT_FUNCTION = 5,
        SCRIPT_FUNCTION_NOT_FOUND = 6,
        UNKNOWN_ERROR = 7,
        UE4SS_NOT_INITIALIZED = 8,
    };

    struct ReturnValue
    {
        ExportedFunctionStatus status{ExportedFunctionStatus::NO_ERROR_TO_EXPORT};
    };

    struct ScriptFuncReturnValue
    {
        bool return_value{false};
    };

    enum class DefaultDataType : uint8_t
    {
        ConstCharPtr,
        Float,
    };

    struct DefaultDataStruct
    {
        DefaultDataType data1_type;
        DefaultDataType data2_type;
        DefaultDataType data3_type;
        DefaultDataType data4_type;

        DefaultStructMemberData(data1)
        DefaultStructMemberData(data2)
        DefaultStructMemberData(data3)
        DefaultStructMemberData(data4)
    };

    extern "C"
    {
    // TODO: Make helper functions inside LuaMadeSimple so that the Lua C api doesn't need to be used in these functions

    __declspec(dllexport) auto get_lua_state_by_mod_name(const char* mod_name) -> lua_State*;
    __declspec(dllexport) auto execute_lua_in_mod(const char* mod_name, const char* script, char* output_buffer) -> const char*;

    using SetScriptVariableInt32Signature = void(*)(const char*, const char*, int32_t, ReturnValue&);
    __declspec(dllexport) auto set_script_variable_int32(const char* mod_name, const char* variable_name, int32_t new_value, ReturnValue&) -> void;

    using SetScriptVariableDefaultDataSignature = void(*)(const char*, const char*, DefaultDataStruct&, ReturnValue&);
    __declspec(dllexport) auto set_script_variable_default_data(const char* mod_name, const char* variable_name, DefaultDataStruct& external_data, ReturnValue&) -> void;

    using CallScriptFunctionSignature = void(*)(const char*, const char*, ReturnValue&, ScriptFuncReturnValue&);
    __declspec(dllexport) auto call_script_function(const char* mod_name, const char* function_name, ReturnValue&, ScriptFuncReturnValue&) -> void;

    using IsUE4SSInitializedSignature = bool(*)();
    __declspec(dllexport) auto is_ue4ss_initialized() -> bool;
    }
};


#endif //UE4SS_REWRITTEN_LUALIBRARY_HPP

```

`include/LuaScriptMemoryAccess.hpp`:

```hpp
#ifndef UE4SS_LUASCRIPTMEMORYACCESS_HPP
#define UE4SS_LUASCRIPTMEMORYACCESS_HPP

struct lua_State;

namespace RC
{
    struct MemoryItem {};

    // Native functions
    auto AllocateMemory(size_t size) -> MemoryItem*;
    auto FreeMemory(MemoryItem* memory_item) -> void;
    auto FreeMemory(uintptr_t memory) -> void;

    // Custom wrappers
    auto lua_Test_ReadBytes_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadUInt8_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadUInt16_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadUInt32_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadUInt64_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadInt8_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadInt16_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadInt32_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_ReadInt64_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteBytes_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteUInt8_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteUInt16_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteUInt32_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteUInt64_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteInt8_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteInt16_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteInt32_wrapper(lua_State* lua_state) -> int;
    auto lua_Test_WriteInt64_wrapper(lua_State* lua_state) -> int;
}

#endif //UE4SS_LUASCRIPTMEMORYACCESS_HPP

```

`include/LuaTests.hpp`:

```hpp
#ifndef UE4SS_LUATESTS_HPP
#define UE4SS_LUATESTS_HPP

#include <cstdint>

#include <Unreal/TArray.hpp>
#include <Unreal/World.hpp>

namespace RC
{
    using namespace Unreal;

    struct MemoryItem;

    auto Test_GetUnsignedMemorySetup() -> MemoryItem*;
    auto Test_GetSignedMemorySetup() -> MemoryItem*;
    auto Test_GetPlayerControllerVTablePointer() -> MemoryItem*;

    auto GetWorldTest() -> UWorld*;
    auto GetArrayTest() -> Unreal::TArray<UObject*>&;
    auto GetArrayTest2() -> Unreal::TArray<int16_t>&;
    auto GetArrayTest3() -> Unreal::TArray<FName>;
    auto Test_Get_UObject_Nullptr() -> UObject*;
}

#endif //UE4SS_LUATESTS_HPP

```

`include/LuaType/LuaAActor.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAAACTOR_HPP
#define UE4SS_REWRITTEN_LUAAACTOR_HPP

#include <LuaType/LuaUObject.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>

namespace RC::Unreal
{
    class AActor;
}

namespace RC::LuaType
{
    struct AActorName { constexpr static const char* ToString() { return "AActor"; }};
    class AActor : public UObjectBase<Unreal::AActor, AActorName>
    {
    private:
        explicit AActor(Unreal::AActor* object);

    public:
        AActor() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::AActor*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAAACTOR_HPP

```

`include/LuaType/LuaCustomProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUACUSTOMPROPERTY_HPP
#define UE4SS_REWRITTEN_LUACUSTOMPROPERTY_HPP

#include <memory>
#include <string>
#include <vector>

namespace RC::Unreal
{
    class UObject;
    class UClass;
    class FProperty;
    class CustomProperty;
}

namespace RC::LuaType
{
    class LuaCustomProperty
    {
    public:
        std::wstring m_name{};
        std::unique_ptr<Unreal::CustomProperty> m_property;

    public:
        LuaCustomProperty(std::wstring name, std::unique_ptr<Unreal::CustomProperty> property);

    private:
        class PropertyList
        {
        private:
            std::vector<LuaCustomProperty> properties;

        public:
            auto add(std::wstring property_name, std::unique_ptr<Unreal::CustomProperty>) -> void;
            auto clear() -> void;
            auto find_or_nullptr(Unreal::UObject* base, std::wstring property_name) -> Unreal::FProperty*;
        };

    public:
        struct StaticStorage
        {
            static PropertyList property_list;
        };
    };
}


#endif //UE4SS_REWRITTEN_LUACUSTOMPROPERTY_HPP

```

`include/LuaType/LuaFName.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFNAME_HPP
#define UE4SS_REWRITTEN_LUAFNAME_HPP

#include <LuaType/LuaUObject.hpp>
#include <Unreal/NameTypes.hpp>

namespace RC::LuaType
{
    struct FNameName { constexpr static const char* ToString() { return "FName"; }};
    class FName : public LocalObjectBase<Unreal::FName, FNameName>
    {
    private:
        explicit FName(Unreal::FName object);

    public:
        FName() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FName) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(LuaMadeSimple::Lua::Table&) -> void;
    };
}



#endif //UE4SS_REWRITTEN_LUAFNAME_HPP

```

`include/LuaType/LuaFOutputDevice.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFOUTPUTDEVICE_HPP
#define UE4SS_REWRITTEN_LUAFOUTPUTDEVICE_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class FOutputDevice;
}

namespace RC::LuaType
{
    struct FOutputDeviceName { constexpr static const char* ToString() { return "FOutputDevice"; }};
    class FOutputDevice : public RemoteObjectBase<Unreal::FOutputDevice, FOutputDeviceName>
    {
    private:
        explicit FOutputDevice(Unreal::FOutputDevice* object);

    public:
        FOutputDevice() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FOutputDevice*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAFOUTPUTDEVICE_HPP

```

`include/LuaType/LuaFSoftObjectPath.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFSOFTOBJECTPATH_HPP
#define UE4SS_REWRITTEN_LUAFSOFTOBJECTPATH_HPP

#include <LuaType/LuaUObject.hpp>
#include <Unreal/Property/FSoftObjectProperty.hpp>

namespace RC::LuaType
{
    struct FSoftObjectPathName { constexpr static const char* ToString() { return "FSoftObjectPath"; }};
    class FSoftObjectPath : public LocalObjectBase<Unreal::FSoftObjectPath, FSoftObjectPathName>
    {
    private:
        explicit FSoftObjectPath(Unreal::FSoftObjectPath& object);

    public:
        FSoftObjectPath() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FSoftObjectPath&) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(LuaMadeSimple::Lua::Table&, std::string_view) -> void;
    };
}



#endif //UE4SS_REWRITTEN_LUAFSOFTOBJECTPATH_HPP

```

`include/LuaType/LuaFString.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFSTRING_HPP
#define UE4SS_REWRITTEN_LUAFSTRING_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class FString;
}

namespace RC::LuaType
{
    struct FStringName { constexpr static const char* ToString() { return "FString"; }};
    class FString : public RemoteObjectBase<Unreal::FString, FStringName>
    {
    private:
        explicit FString(Unreal::FString* object);

    public:
        FString() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FString*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAFSTRING_HPP

```

`include/LuaType/LuaFText.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFTEXT_HPP
#define UE4SS_REWRITTEN_LUAFTEXT_HPP

#include <LuaType/LuaUObject.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>

namespace RC::Unreal
{
    class FText;
}

namespace RC::LuaType
{
    struct FTextName { constexpr static const char* ToString() { return "FText"; }};
    class FText : public RemoteObjectBase<Unreal::FText, FTextName>
    {
    private:
        explicit FText(Unreal::FText* object);

    public:
        FText() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FText*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAFTEXT_HPP

```

`include/LuaType/LuaFWeakObjectPtr.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAFWEAKOBJECTPTR_HPP
#define UE4SS_REWRITTEN_LUAFWEAKOBJECTPTR_HPP

#include <LuaType/LuaUObject.hpp>
#pragma warning(disable: 4005)
#include <Unreal/FWeakObjectPtr.hpp>
#pragma warning(default: 4005)

namespace RC::Unreal
{
    class UClass;
}

namespace RC::LuaType
{
    struct FWeakObjectPtrName { constexpr static const char* ToString() { return "FWeakObjectPtr"; }};
    class FWeakObjectPtr : public LocalObjectBase<Unreal::FWeakObjectPtr, FWeakObjectPtrName>
    {
    private:
        explicit FWeakObjectPtr(Unreal::FWeakObjectPtr object);

    public:
        FWeakObjectPtr() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FWeakObjectPtr) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAFWEAKOBJECTPTR_HPP

```

`include/LuaType/LuaMod.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAMOD_HPP
#define UE4SS_REWRITTEN_LUAMOD_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC
{
    class Mod;
}

namespace RC::LuaType
{
    struct ModName { constexpr static const char* ToString() { return "ModRef"; }};
    class Mod : public RemoteObjectBase<RC::Mod, ModName>
    {
    private:
        explicit Mod(RC::Mod* object);

    public:
        Mod() = delete;
        auto static construct(const LuaMadeSimple::Lua&, RC::Mod*) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAMOD_HPP

```

`include/LuaType/LuaTArray.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUATARRAY_HPP
#define UE4SS_REWRITTEN_LUATARRAY_HPP

#include <LuaType/LuaUObject.hpp>
#pragma warning(disable: 4005)
#include <Unreal/FScriptArray.hpp>
#pragma warning(default: 4005)

namespace RC::Unreal
{
    class UObject;
    class FProperty;
    class FByteProperty;
    class FArrayProperty;
}

namespace RC::LuaType
{
    struct PusherParams;

    struct TArrayName { constexpr static const char* ToString() { return "TArray"; }};
    class TArray : public RemoteObjectBase<Unreal::FScriptArray, TArrayName>
    {
    private:
        Unreal::UObject* m_base;

        Unreal::FArrayProperty* m_property;
        Unreal::FProperty* m_inner_property;

    private:
        explicit TArray(const PusherParams&);

    public:
        TArray() = delete;
        auto static construct(const PusherParams&) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
        auto static handle_unreal_property_value(const LuaMadeSimple::Type::Operation, const LuaMadeSimple::Lua&, Unreal::FScriptArray*, int64_t array_index, const TArray& lua_object) -> void;
        auto static prepare_to_handle(const LuaMadeSimple::Type::Operation, const LuaMadeSimple::Lua&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUATARRAY_HPP

```

`include/LuaType/LuaTSoftClassPtr.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUATSOFTCLASSPTR_HPP
#define UE4SS_REWRITTEN_LUATSOFTCLASSPTR_HPP

#include <LuaType/LuaUObject.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>

namespace RC::LuaType
{
    struct TSoftClassPtrName { constexpr static const char* ToString() { return "TSoftClassPtr"; }};
    class TSoftClassPtr : public LocalObjectBase<Unreal::FSoftObjectPtr, TSoftClassPtrName>
    {
    private:
        explicit TSoftClassPtr(Unreal::FSoftObjectPtr object);

    public:
        TSoftClassPtr() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FSoftObjectPtr&) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(LuaMadeSimple::Lua::Table&, std::string_view) -> void;
    };
}



#endif //UE4SS_REWRITTEN_LUATSOFTCLASSPTR_HPP

```

`include/LuaType/LuaUClass.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUCLASS_HPP
#define UE4SS_REWRITTEN_LUAUCLASS_HPP

#include <LuaMadeSimple/LuaObject.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUStruct.hpp>

namespace RC::Unreal
{
    class UClass;
}

namespace RC::LuaType
{
    struct UClassName { constexpr static const char* ToString() { return "UClass"; }};
    class UClass : public UObjectBase<Unreal::UClass, UClassName>
    {
    public:
        using Super = LuaType::UStruct;

    private:
        explicit UClass(Unreal::UClass* object);

    public:
        auto derives_from_class() -> bool override { return true; }

    public:
        UClass() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::UClass*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    public:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAUCLASS_HPP

```

`include/LuaType/LuaUEnum.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUENUM_HPP
#define UE4SS_REWRITTEN_LUAUENUM_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class UEnum;
}

namespace RC::LuaType
{
    struct UEnumName { constexpr static const char* ToString() { return "UEnum"; }};
    class UEnum : public RemoteObjectBase<Unreal::UEnum, UEnumName>
    {
    public:
        using Super = UObject;

    private:
        explicit UEnum(Unreal::UEnum* object);

    public:
        UEnum() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::UEnum*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAUENUM_HPP

```

`include/LuaType/LuaUFunction.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUFUNCTION_HPP
#define UE4SS_REWRITTEN_LUAUFUNCTION_HPP

#include <array>

#include <LuaType/LuaUObject.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>

namespace RC::Unreal
{
    class FProperty;
}

namespace RC::LuaType
{
    struct DynamicUnrealFunctionData
    {
        uint8_t data[0x200]{};
    };

    struct PropertyAndLuaRefPair
    {
        Unreal::FProperty* property;
        int32_t lua_ref;
    };

    class DynamicUnrealFunctionOutParameters
    {
    private:
        size_t m_last{0};
        using ParamsArray = std::array<PropertyAndLuaRefPair, 10>;
        ParamsArray m_params;

    public:
        auto add(const PropertyAndLuaRefPair) -> void;
        auto get(size_t index) -> const PropertyAndLuaRefPair&;
        auto get() -> const ParamsArray&;
    };

    struct UFunctionName { constexpr static const char* ToString() { return "UFunction"; } };
    class UFunction : public UObjectBase<Unreal::UFunction, UFunctionName>
    {
    private:
        // This is the 'this' pointer for this UFunction
        Unreal::UObject* m_base{};

    private:
        explicit UFunction(Unreal::UObject* base, Unreal::UFunction* function);

    public:
        UFunction() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::UObject*, Unreal::UFunction*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;

    public:
        auto derives_from_ufunction() -> bool override { return true; }

    public:
        auto get_base() -> Unreal::UObject* { return m_base; }
    };
}


#endif //UE4SS_REWRITTEN_LUAUFUNCTION_HPP

```

`include/LuaType/LuaUObject.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUOBJECT_HPP
#define UE4SS_REWRITTEN_LUAUOBJECT_HPP

#define NOMINMAX

#include <format>
#include <functional>

#include <LuaMadeSimple/LuaObject.hpp>
#include <Helpers/String.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <LuaType/LuaCustomProperty.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UObject.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UStruct.hpp>
#include <Unreal/World.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/NameTypes.hpp>
#include <Unreal/VersionedContainer/Container.hpp>
#pragma warning(default: 4005)

template<typename SupposedIntegralType>
concept IsConvertableToLuaInteger = std::is_integral_v<SupposedIntegralType>;

namespace RC::LuaType
{
    auto call_ufunction_from_lua(const LuaMadeSimple::Lua& lua) -> int;

    using Operation = LuaMadeSimple::Type::Operation;

    template<typename ObjectType, template<typename T> typename LuaObjectBase, typename ObjectName>
    class ObjectBase : public LuaObjectBase<ObjectType>
    {
    protected:
        using SelfType = ObjectBase<ObjectType, LuaObjectBase, ObjectName>;
        using Super = SelfType;
        using ClassName = ObjectName;

    public:
        ObjectBase(ObjectType* object) : LuaObjectBase<ObjectType>(ObjectName::ToString(), object) {}
        ObjectBase(ObjectType&& object) : LuaObjectBase<ObjectType>(ObjectName::ToString(), std::move(object)) {}
        ObjectBase() = delete;
        virtual ~ObjectBase() = default;

    public:
        // Whether this object is a specific type or inherits from a specific type
        virtual auto derives_from_actor()           -> bool { return false; }
        virtual auto derives_from_name()            -> bool { return false; }
        virtual auto derives_from_string()          -> bool { return false; }
        virtual auto derives_from_text()            -> bool { return false; }
        virtual auto derives_from_weak_object_ptr() -> bool { return false; }
        virtual auto derives_from_mod()             -> bool { return false; }
        virtual auto derives_from_array()           -> bool { return false; }
        virtual auto derives_from_class()           -> bool { return false; }
        virtual auto derives_from_enum()            -> bool { return false; }
        virtual auto derives_from_function()        -> bool { return false; }
        virtual auto derives_from_object()          -> bool { return false; }
        virtual auto derives_from_script_struct()   -> bool { return false; }
        virtual auto derives_from_world()           -> bool { return false; }
        virtual auto derives_from_property()        -> bool { return false; }
        virtual auto derives_from_property_class()  -> bool { return false; }
        virtual auto derives_from_ufunction()       -> bool { return false; }

    public:
        // Constructor for RemoteObjectBase
        auto static construct(const LuaMadeSimple::Lua& lua, Unreal::UObject* unreal_object) -> const LuaMadeSimple::Lua::Table
        {
            SelfType lua_object{unreal_object};

            auto metatable_name = lua_object.get_object_name();

            LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
            if (lua.is_nil(-1))
            {
                lua.discard_value(-1);
                LuaMadeSimple::Type::RemoteObject<ObjectType>::construct(lua, lua_object);
                setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
                lua.new_metatable<SelfType>(metatable_name, lua_object.get_metamethods());
            }

            // Create object & surrender ownership to Lua
            lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

            return table;
        }

        // Constructor for objects that inherit from RemoteObjectBase
        auto static construct(const LuaMadeSimple::Lua& lua, LuaMadeSimple::Type::BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
        {
            const LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<ObjectType>::construct(lua, construct_to);

            // Setup functions that can be called on this object
            setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

            // Creation & transferring the object & its ownership fully to Lua is the responsibility of the overriding object

            return table;
        }

        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
        {
            // Overridden functions from 'Lua::RemoteObject'.
            table.add_pair("GetAddress", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();
                lua.set_integer(reinterpret_cast<uintptr_t>(lua_object.get_remote_cpp_object()));
                return 1;
            });

            table.add_pair("IsValid", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();
                if (lua_object.get_remote_cpp_object())
                {
                    lua.set_bool(true);
                }
                else
                {
                    lua.set_bool(false);
                }
                return 1;
            });

            // Add things that are intended to be overridden later here
            // These will then be set only if this is the final object (nothing overrides it later)
            if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
            {
                table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                    lua.set_string("RemoteObjectBase");
                    return 1;
                });

                // If this is the final object then we also want to finalize creating the table
                // If not then it's the responsibility of the overriding object to call 'make_global()
                //table.make_global("RemoteObjectBase");
            }
        }
    };

    struct UE4SSBaseObjectName { constexpr static const char* ToString() { return "UE4SSBaseObject"; } };

    template<typename DerivedType, typename ObjectName>
    using RemoteObjectBase = ObjectBase<DerivedType, LuaMadeSimple::Type::RemoteObject, ObjectName>;

    template<typename DerivedType, typename ObjectName>
    using LocalObjectBase = ObjectBase<DerivedType, LuaMadeSimple::Type::LocalObject, ObjectName>;

    using UE4SSBaseObject = ObjectBase<uint8_t, LuaMadeSimple::Type::RemoteObject, UE4SSBaseObjectName>;

    struct PusherParams
    {
        const Operation operation;
        const LuaMadeSimple::Lua& lua;
        Unreal::UObject* base;
        void* data;
        Unreal::FProperty* property;

        // Where in the Lua stack the data is at
        // Default is 1 because that's the default for LuaMadeSimple because that's how the system works
        int32_t stored_at_index = 1;

        // Whether to create a new Lua item (example: table) or use an existing one on the top of the stack
        bool create_new_if_get_non_trivial_local{true};
    };

    struct FunctionPusherParams
    {
        const LuaMadeSimple::Lua& lua;
        Unreal::UObject* base;
        Unreal::UFunction* function;
    };

    struct StaticState
    {
        using PropertyValuePusherCallable = std::function<void(const PusherParams&)>;
        static inline std::unordered_map<int32_t, PropertyValuePusherCallable> m_property_value_pushers;
    };

    auto auto_construct_object(const LuaMadeSimple::Lua&, Unreal::UObject*) -> void;

    // Helpers to construct an object that we cannot have access to in this header
    auto construct_fname(const LuaMadeSimple::Lua&) -> void;
    auto construct_uclass(const LuaMadeSimple::Lua&) -> void;
    auto construct_xproperty(const LuaMadeSimple::Lua&, Unreal::FProperty* property) -> void;

    // Push to Lua -> START
    auto push_unhandledproperty(const PusherParams&) -> void;
    auto push_objectproperty(const PusherParams&) -> void;
    auto push_classproperty(const PusherParams&) -> void;
    auto push_int8property(const PusherParams&) -> void;
    auto push_int16property(const PusherParams&) -> void;
    auto push_intproperty(const PusherParams&) -> void;
    auto push_int64property(const PusherParams&) -> void;
    auto push_byteproperty(const PusherParams&) -> void; // Unreal Engine calls uint8 a "byte"
    auto push_uint16property(const PusherParams&) -> void;
    auto push_uint32property(const PusherParams&) -> void;
    auto push_uint64property(const PusherParams&) -> void;
    auto push_structproperty(const PusherParams&) -> void;
    auto push_arrayproperty(const PusherParams&) -> void;
    auto push_floatproperty(const PusherParams&) -> void;
    auto push_doubleproperty(const PusherParams&) -> void;
    auto push_boolproperty(const PusherParams&) -> void;
    auto push_enumproperty(const PusherParams&) -> void;
    auto push_weakobjectproperty(const PusherParams&) -> void;
    auto push_nameproperty(const PusherParams&) -> void;
    auto push_textproperty(const PusherParams&) -> void;
    auto push_strproperty(const PusherParams&) -> void;
    auto push_softclassproperty(const PusherParams&) -> void;

    auto push_functionproperty(const FunctionPusherParams&) -> void;
    // Push to Lua -> END

    auto handle_unreal_property_value(const Operation operation, const LuaMadeSimple::Lua&, Unreal::UObject* base, Unreal::FName property_name, Unreal::FField* field) -> void;

    auto is_a_implementation(const LuaMadeSimple::Lua& lua) -> int;

    template<typename DerivedType, typename ObjectName>
    class UObjectBase;

    struct UObjectName { constexpr static const char* ToString() { return "UObject"; } };
    using UObject = UObjectBase<Unreal::UObject, UObjectName>;
    
    template<typename DerivedType, typename ObjectName>
    class UObjectBase : public RemoteObjectBase<DerivedType, ObjectName>
    {
    protected:
        using Super = RemoteObjectBase<DerivedType, ObjectName>;
        using SelfType = Super;

    public:
        explicit UObjectBase(DerivedType* object) : Super(object) {}

    public:
        auto derives_from_object() -> bool override { return true; }

    public:
        UObjectBase() = delete;
        virtual ~UObjectBase() = default;

        // Constructor for UObject
        auto static construct(const LuaMadeSimple::Lua& lua, DerivedType* unreal_object) -> const LuaMadeSimple::Lua::Table
        {
            SelfType lua_object{unreal_object};

            auto metatable_name = ObjectName::ToString();

            LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
            if (lua.is_nil(-1))
            {
                lua.discard_value(-1);
                Super::construct(lua, lua_object);
                setup_metamethods(lua_object);
                setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
                lua.new_metatable<SelfType>(metatable_name, lua_object.get_metamethods());
            }

            // Create object & surrender ownership to Lua
            lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

            return table;
        }

        // Constructor for objects that inherit from UObject
        auto static construct(const LuaMadeSimple::Lua& lua, LuaMadeSimple::Type::BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
        {
            LuaMadeSimple::Lua::Table table = Super::construct(lua, construct_to);

            // Setup functions that can be called on this object
            setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

            setup_metamethods(construct_to);

            // Creation & transferring the object & its ownership fully to Lua is the responsibility of the overriding object

            return table;
        }

    private:
        auto static setup_metamethods(LuaMadeSimple::Type::BaseObject& base_object) -> void
        {
            // Another object can override these metamethods by calling the 'create()' function again
            base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Index, [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Get, lua);
                return 1;
            });

            base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::NewIndex, [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Set, lua);
                return 0;
            });

            base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Call, [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();

                if (!lua_object.get_remote_cpp_object())
                {
                    lua.throw_error("Tried calling a member function but the UObject instance is nullptr\n");
                }
                return 0;
            });
        }

    public:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
        {
            Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

            // Add functions that are not intended to be overridden later here
            table.add_pair("GetFullName", [](const LuaMadeSimple::Lua& lua) -> int {
                // Get the userdata from the Lua stack
                // We're making an assumption here about the type
                // I know of no way to get around this assumption
                const auto& lua_object = lua.get_userdata<SelfType>();

                if (lua_object.get_remote_cpp_object())
                {
                    // Set the return value to the ansi version of the full name
                    lua.set_string(to_string(lua_object.get_remote_cpp_object()->GetFullName()).c_str());
                }
                else
                {
                    // We have a nullptr, lets return 'nil' for easy object verification in Lua
                    lua.set_nil();
                }

                return 1;
            });

            table.add_pair("GetFName", [](const LuaMadeSimple::Lua& lua) -> int {
                construct_fname(lua);
                return 1;
            });

            table.add_pair("GetClass", [](const LuaMadeSimple::Lua& lua) -> int {
                construct_uclass(lua);
                return 1;
            });

            table.add_pair("GetOuter", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();

                UObject::construct(lua, lua_object.get_remote_cpp_object()->GetOuterPrivate());

                return 1;
            });

            table.add_pair("IsAnyClass", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();

                lua.set_bool(lua_object.get_remote_cpp_object()->IsA<Unreal::UClass>());

                return 1;
            });

            table.add_pair("Reflection", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();

                auto reflection_table = lua.prepare_new_table();
                reflection_table.set_has_userdata(false);
                reflection_table.add_key("ReflectedObject");
                SelfType::construct(lua, lua_object.get_remote_cpp_object());
                reflection_table.fuse_pair();

                reflection_table.add_pair("GetProperty", [](const LuaMadeSimple::Lua& lua) -> int {
                    // Stack
                    // 1 (-2): ReflectionTable
                    // 2 (-1): Param #1 (PropertyName)

                    if (!lua.is_string(2))
                    {
                        lua.throw_error("Function 'GetProperty' requires a string as the first parameter");
                    }
                    std::wstring property_name = to_wstring(lua.get_string(2));

                    auto reflection_table = lua.get_table();
                    const auto& reflected_object = reflection_table.get_userdata_field<SelfType>("ReflectedObject").get_remote_cpp_object();

                    if (!reflected_object)
                    {
                        construct_xproperty(lua, nullptr);
                        return 1;
                    }

                    auto* obj_as_struct = Unreal::Cast<Unreal::UStruct>(reflected_object);
                    if (!obj_as_struct) { obj_as_struct = reflected_object->GetClassPrivate(); }
                    auto* property = obj_as_struct->FindProperty(Unreal::FName(property_name));

                    construct_xproperty(lua, property);
                    return 1;
                });
                return 1;
            });

            table.add_pair("GetPropertyValue", [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Get, lua);
                return 1;
            });

            table.add_pair("SetPropertyValue", [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Set, lua);
                return 1;
            });

            table.add_pair("IsClass", [](const LuaMadeSimple::Lua& lua) -> int {
                // TODO: Refactor this function into "IsA", but leave the original "IsClass" for compatibility reasons
                //       Creating an "IsA" function will require that we expose some identifier of every class to Lua
                //       We could use strings or FNames, those could be calculated on the Lua side and then
                //       we wouldn't need to preemptively expose anything
                const auto& lua_object = lua.get_userdata<SelfType>();
                lua.set_bool(lua_object.get_remote_cpp_object()->template IsA<Unreal::UClass>());
                return 1;
            });

            table.add_pair("GetWorld", [](const LuaMadeSimple::Lua& lua) -> int {
                const auto& lua_object = lua.get_userdata<SelfType>();
                auto_construct_object(lua, lua_object.get_remote_cpp_object()->GetWorld());
                return 1;
            });

            table.add_pair("CallFunction", [](const LuaMadeSimple::Lua& lua) -> int {
                return call_ufunction_from_lua(lua);
            });

            table.add_pair("IsA", [](const LuaMadeSimple::Lua& lua) -> int {
                return is_a_implementation(lua);
            });

            table.add_pair("HasAllFlags", [](const LuaMadeSimple::Lua& lua) -> int {
                std::string error_overload_not_found{R"(
No overload found for function 'UObject.HasAllFlags'.
Overloads:
#1: HasAllFlags(EObjectFlags ObjectFlags))"};

                const auto& lua_object = lua.get_userdata<SelfType>();

                if (!lua.is_integer())
                {
                    lua.throw_error(error_overload_not_found);
                }

                Unreal::EObjectFlags object_flags = static_cast<Unreal::EObjectFlags>(lua.get_integer());
                lua.set_bool(lua_object.get_remote_cpp_object()->HasAllFlags(object_flags));
                return 1;
            });

            table.add_pair("HasAnyFlags", [](const LuaMadeSimple::Lua& lua) -> int {
                std::string error_overload_not_found{R"(
No overload found for function 'UObject.HasAnyFlags'.
Overloads:
#1: HasAnyFlags(EObjectFlags ObjectFlags))"};

                const auto& lua_object = lua.get_userdata<SelfType>();

                if (!lua.is_integer())
                {
                    lua.throw_error(error_overload_not_found);
                }

                Unreal::EObjectFlags object_flags = static_cast<Unreal::EObjectFlags>(lua.get_integer());
                lua.set_bool(lua_object.get_remote_cpp_object()->HasAnyFlags(object_flags));
                return 1;
            });

            // Add things that are intended to be overridden later here
            // These will then be set only if this is the final object (nothing overrides it later)
            if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
            {
                table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                    lua.set_string("UObject");
                    return 1;
                });

                // If this is the final object then we also want to finalize creating the table
                // If not then it's the responsibility of the overriding object to call 'make_global()
                //table.make_global("UObject");
            }
        }

    private:
        auto static prepare_to_handle(const Operation operation, const LuaMadeSimple::Lua& lua) -> void
        {
            auto& lua_object = lua.get_userdata<SelfType>();

            std::wstring member_name = to_wstring(lua.get_string());

            // If nullptr then we assume the UObject wasn't found so lets return an invalid UObject to Lua
            // This allows the safe chaining of "__index" as long as the Lua script checks ":IsValid()" before using the object
            if (!lua_object.get_remote_cpp_object())
            {
                // If the operation is not "Get" then this isn't "__index" and we want to do nothing in this case
                switch (operation)
                {
                    case Operation::Get:
                    case Operation::GetParam:
                        // Construct an empty object to allow for safe chaining with a validity check at the end
                        SelfType::construct(lua, static_cast<DerivedType*>(nullptr));
                        break;
                    case Operation::Set:
                        Output::send(STR("[Lua][Error] Tried setting member variable '{}' but UObject instance is nullptr\n"), member_name);
                        break;
                    default:
                        Output::send(STR("[Lua][Error] The UObject instance is nullptr & operation type was invalid\n"));
                        break;
                }

                return;
            }

            Unreal::FName property_name = Unreal::FName(member_name);
            Unreal::FField* field = LuaCustomProperty::StaticStorage::property_list.find_or_nullptr(lua_object.get_remote_cpp_object(), member_name);

            if (!field)
            {
                auto* object = lua_object.get_remote_cpp_object();
                auto* obj_as_struct = Unreal::Cast<Unreal::UStruct>(object);
                if (!obj_as_struct) { obj_as_struct = object->GetClassPrivate(); }
                field = obj_as_struct->FindProperty(property_name);
            }

            handle_unreal_property_value(operation, lua, lua_object.get_remote_cpp_object(), property_name, field);
        }
    };

    template<typename ParamType>
    class LocalUnrealParam : public LuaMadeSimple::Type::LocalObject<ParamType>
    {
    private:
        Unreal::FProperty* m_property{};
        Unreal::UObject* m_base{};

    public:
        LocalUnrealParam(ParamType object, Unreal::UObject* base, Unreal::FProperty* property) :
                LuaMadeSimple::Type::LocalObject<ParamType>("LocalParam", std::move(object)),
                m_property(property),
                m_base(base)
        {
        }

        // Constructor for local param
        auto static construct(const LuaMadeSimple::Lua& lua, ParamType& object, Unreal::UObject* base, Unreal::FProperty* property) -> const LuaMadeSimple::Lua::Table
        {
            LuaType::LocalUnrealParam lua_object{object, base, property};

            auto metatable_name = "LocalUnrealParam";

            LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
            if (lua.is_nil(-1))
            {
                lua.discard_value(-1);
                lua.prepare_new_table();
                setup_metamethods(lua_object);
                setup_member_functions(table);
                lua.new_metatable<LuaType::LocalUnrealParam<ParamType>>(metatable_name, lua_object.get_metamethods());
            }

            // Create object & surrender ownership to Lua
            lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

            return table;
        }

    private:
        auto static setup_metamethods(LuaMadeSimple::Type::BaseObject& base_object) -> void
        {
            base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Index, [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Get, lua);
                return 1;
            });

            base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::NewIndex, [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Set, lua);
                return 0;
            });
        }

        auto static setup_member_functions(LuaMadeSimple::Lua::Table& table) -> void
        {
            table.add_pair("get", [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Get, lua);
                return 1;
            });

            table.add_pair("set", [](const LuaMadeSimple::Lua& lua) -> int {
                prepare_to_handle(Operation::Set, lua);
                return 0;
            });

            // This class is not overridable so this is always the final class and because of that we always want to set the type & make it global
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string("LocalUnrealParam");
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global("LocalUnrealParam");
        }

        auto static prepare_to_handle(const Operation operation, const LuaMadeSimple::Lua& lua) -> void
        {
            auto& lua_object = lua.get_userdata<LuaType::LocalUnrealParam<ParamType>>();

            Unreal::FName property_type = lua_object.m_property->GetClass().GetFName();
            int32_t type_name_comparison_index = property_type.GetComparisonIndex();

            if (StaticState::m_property_value_pushers.contains(type_name_comparison_index))
            {
                const PusherParams pusher_params{
                        .operation = operation,
                        .lua = lua,
                        .base = lua_object.m_base,
                        .data = lua_object.get_local_cpp_object().get_data_ptr(),
                        .property = lua_object.m_property
                };
                StaticState::m_property_value_pushers[type_name_comparison_index](pusher_params);
            }
            else
            {
                // We can either throw an error and kill the execution
                /**/
                std::wstring property_type_name = property_type.ToString();
                lua.throw_error(std::format("Tried accessing unreal property without a registered handler. Property type '{}' not supported.", to_string(property_type_name)));
                //*/

                // Or we can treat unhandled property types as some sort of generic type
                // For example, we might want to pass the unhandled property value to some sort of low-level Lua API
                // Then the Lua script can deal with figuring out how to handle the type
                /*
                push_unhandledproperty(lua, base);
                //*/
            }
        }
    };

    class RemoteUnrealParam : public LuaMadeSimple::Type::RemoteObject<void>
    {
    private:
        Unreal::FProperty* m_property{};
        Unreal::UObject* m_base{};
        Unreal::FName m_type{};

    public:
        explicit RemoteUnrealParam(void* param_ptr, Unreal::UObject* base, Unreal::FProperty* param_property_type_name, const Unreal::FName type);
        explicit RemoteUnrealParam(void* data_ptr, const Unreal::FName type);

        // Constructor for param
        auto static construct(const LuaMadeSimple::Lua&, void* param_ptr, Unreal::UObject* base, Unreal::FProperty* property) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, void* data_ptr, const Unreal::FName type) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;
        auto static setup_member_functions(LuaMadeSimple::Lua::Table& table) -> void;
        auto static prepare_to_handle(const Operation, const LuaMadeSimple::Lua&) -> void;
    };

    template<IsConvertableToLuaInteger IntegerType>
    auto push_integer(const PusherParams& params) -> void
    {
        IntegerType* integer_ptr = static_cast<IntegerType*>(params.data);
        if (!integer_ptr) { params.lua.throw_error("[push_integer] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                params.lua.set_integer(*integer_ptr);
                return;
            case Operation::Set:
                *integer_ptr = static_cast<IntegerType>(params.lua.get_integer(params.stored_at_index));
                return;
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, integer_ptr, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_integer] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_integer] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }
}


#endif //UE4SS_REWRITTEN_LUAUOBJECT_HPP

```

`include/LuaType/LuaUScriptStruct.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUSCRIPTSTRUCT_HPP
#define UE4SS_REWRITTEN_LUAUSCRIPTSTRUCT_HPP

#include <LuaType/LuaUStruct.hpp>

namespace RC::Unreal
{
    class UStruct;
    class UScriptStruct;
    class FStructProperty;
}

namespace RC::LuaType
{
    // Simple wrapper that contains the UScriptStruct* and the FStructProperty*
    struct ScriptStructWrapper
    {
        Unreal::UScriptStruct* script_struct{};
        void* start_of_struct{};
        Unreal::FStructProperty* property{};

        // Accessor the LocalParam API
        void* get_data_ptr()
        {
            return start_of_struct;
        }
    };

    struct UScriptStructName { constexpr static const char* ToString() { return "UScriptStruct"; }};
    class UScriptStruct : public LocalObjectBase<ScriptStructWrapper, UScriptStructName>
    {
    public:
        using Super = UStruct;

    private:
        explicit UScriptStruct(ScriptStructWrapper object);

    public:
        UScriptStruct() = delete;
        auto static construct(const LuaMadeSimple::Lua&, ScriptStructWrapper&) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
        auto static handle_unreal_property_value(const LuaMadeSimple::Type::Operation operation, const LuaMadeSimple::Lua&, ScriptStructWrapper& , Unreal::FName property_name) -> void;
        auto static prepare_to_handle(const LuaMadeSimple::Type::Operation, const LuaMadeSimple::Lua&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAUSCRIPTSTRUCT_HPP

```

`include/LuaType/LuaUStruct.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUSTRUCT_HPP
#define UE4SS_REWRITTEN_LUAUSTRUCT_HPP

#include <LuaMadeSimple/LuaObject.hpp>
#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class UStruct;
}

namespace RC::LuaType
{
    struct UStructName { constexpr static const char* ToString() { return "UClass"; }};
    class UStruct : public UObjectBase<Unreal::UStruct, UStructName>
    {
    public:
        using Super = UObject;

    private:
        explicit UStruct(Unreal::UStruct* object);

    public:
        auto derives_from_class() -> bool override { return true; }

    public:
        UStruct() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::UStruct*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    public:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAUSTRUCT_HPP

```

`include/LuaType/LuaUWorld.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAUWORLD_HPP
#define UE4SS_REWRITTEN_LUAUWORLD_HPP

#include <LuaMadeSimple/LuaObject.hpp>
#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class UWorld;
}

namespace RC::LuaType
{
    struct UWorldName { constexpr static const char* ToString() { return "UWorld"; }};
    class UWorld : public RemoteObjectBase<Unreal::UWorld, UWorldName>
    {
    private:
        explicit UWorld(Unreal::UWorld* object);

    public:
        UWorld() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::UWorld*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAUWORLD_HPP

```

`include/LuaType/LuaXArrayProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXARRAYPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXARRAYPROPERTY_HPP

#include <LuaType/LuaXProperty.hpp>

namespace RC::Unreal
{
    class FArrayProperty;
}

namespace RC::LuaType
{
    struct FArrayPropertyName { constexpr static const char* ToString() { return "ArrayProperty"; }};
    class XArrayProperty : public RemoteObjectBase<Unreal::FArrayProperty, FArrayPropertyName>
    {
    public:
        using Super = XProperty;

    private:
        explicit XArrayProperty(Unreal::FArrayProperty* object);

    public:
        XArrayProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FArrayProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXARRAYPROPERTY_HPP

```

`include/LuaType/LuaXBoolProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXBOOLPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXBOOLPROPERTY_HPP

#include <LuaType/LuaXProperty.hpp>

namespace RC::Unreal
{
    class FBoolProperty;
}

namespace RC::LuaType
{
    struct FBoolPropertyName { constexpr static const char* ToString() { return "ObjectProperty"; }};
    class XBoolProperty : public RemoteObjectBase<Unreal::FBoolProperty, FBoolPropertyName>
    {
    public:
        using Super = XProperty;

    private:
        explicit XBoolProperty(Unreal::FBoolProperty* object);

    public:
        XBoolProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FBoolProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXBOOLPROPERTY_HPP

```

`include/LuaType/LuaXEnumProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXENUMPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXENUMPROPERTY_HPP

#include <LuaType/LuaXProperty.hpp>

namespace RC::Unreal
{
    class FEnumProperty;
}

namespace RC::LuaType
{
    struct FEnumPropertyName { constexpr static const char* ToString() { return "EnumProperty"; }};
    class XEnumProperty : public RemoteObjectBase<Unreal::FEnumProperty, FEnumPropertyName>
    {
    public:
        using Super = XProperty;

    private:
        explicit XEnumProperty(Unreal::FEnumProperty* object);

    public:
        XEnumProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FEnumProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXENUMPROPERTY_HPP

```

`include/LuaType/LuaXFieldClass.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXPROPERTYCLASS_HPP
#define UE4SS_REWRITTEN_LUAXPROPERTYCLASS_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC::LuaType
{
    // Special variant of UClass that has to be used when dealing with the ClassPrivate of fields
    // This is because in <4.25, these classes are of type UClass, and in 4.25+ they are FFieldClass
    // This special class is only allowed to use functions that are safe for both (usually through VC)
    struct FFieldClassName { constexpr static const char* ToString() { return "FieldClass"; }};
    //class XFieldClass : public RemoteObjectBase<Unreal::FFieldClass, FFieldClassName>
    class XFieldClass : public LocalObjectBase<Unreal::FFieldClassVariant, FFieldClassName>
    {
    private:
        explicit XFieldClass(Unreal::FFieldClassVariant object);

    public:
        XFieldClass() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FFieldClassVariant) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXPROPERTYCLASS_HPP

```

`include/LuaType/LuaXObjectProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXOBJECTPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXOBJECTPROPERTY_HPP

#include <LuaType/LuaXProperty.hpp>

namespace RC::Unreal
{
    class FObjectProperty;
}

namespace RC::LuaType
{
    struct FObjectPropertyName { constexpr static const char* ToString() { return "ObjectProperty"; }};
    class XObjectProperty : public RemoteObjectBase<Unreal::FObjectProperty, FObjectPropertyName>
    {
    public:
        using Super = XProperty;

    private:
        explicit XObjectProperty(Unreal::FObjectProperty* object);

    public:
        XObjectProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FObjectProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXOBJECTPROPERTY_HPP

```

`include/LuaType/LuaXProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXPROPERTY_HPP

#include <LuaType/LuaUObject.hpp>

namespace RC::Unreal
{
    class FProperty;
}

namespace RC::LuaType
{
    auto auto_construct_property(const LuaMadeSimple::Lua&, Unreal::FProperty*) -> void;

    struct FPropertyName { constexpr static const char* ToString() { return "Property"; }};
    class XProperty : public RemoteObjectBase<Unreal::FProperty, FPropertyName>
    {
    public:
        using Super = RemoteObjectBase<Unreal::FProperty, FPropertyName>;

    private:
        explicit XProperty(Unreal::FProperty* object);

    public:
        XProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    public:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXPROPERTY_HPP

```

`include/LuaType/LuaXStructProperty.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_LUAXSTRUCTPROPERTY_HPP
#define UE4SS_REWRITTEN_LUAXSTRUCTPROPERTY_HPP

#include <LuaType/LuaXProperty.hpp>

namespace RC::Unreal
{
    class FStructProperty;
}

namespace RC::LuaType
{
    struct FStructPropertyName { constexpr static const char* ToString() { return "StructProperty"; }};
    class XStructProperty : public RemoteObjectBase<Unreal::FStructProperty, FStructPropertyName>
    {
    public:
        using Super = XProperty;

    private:
        explicit XStructProperty(Unreal::FStructProperty* object);

    public:
        XStructProperty() = delete;
        auto static construct(const LuaMadeSimple::Lua&, Unreal::FStructProperty*) -> const LuaMadeSimple::Lua::Table;
        auto static construct(const LuaMadeSimple::Lua&, BaseObject&) -> const LuaMadeSimple::Lua::Table;

    private:
        auto static setup_metamethods(BaseObject&) -> void;

    private:
        template<LuaMadeSimple::Type::IsFinal is_final>
        auto static setup_member_functions(const LuaMadeSimple::Lua::Table&) -> void;
    };
}


#endif //UE4SS_REWRITTEN_LUAXSTRUCTPROPERTY_HPP

```

`include/Mod.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_MOD_HPP
#define UE4SS_REWRITTEN_MOD_HPP

#include <string>
#include <chrono>
#include <thread>
#include <mutex>

#include <File/File.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>

#define NEW_LUA 0

namespace RC
{
    class UE4SSProgram;

    namespace Unreal
    {
        class UClass;
    }

    class Mod
    {
    public:
        UE4SSProgram& m_program;

    private:
        std::wstring m_mod_name;
        std::wstring m_mod_path;
        std::wstring m_scripts_path;
        LuaMadeSimple::Lua& m_lua;

    public:
        std::vector<std::shared_ptr<LuaMadeSimple::Lua>> m_hook_lua{};
        LuaMadeSimple::Lua* m_main_lua{};
        LuaMadeSimple::Lua* m_async_lua{};

    private:
        // Whether the mod can be installed
        // This is true by default and is only false if the state of the mod won't allow for a successful installation
        bool m_installable{true};
        bool m_installed{false};
        mutable bool m_is_started{false};

    public:
        enum class IsTrueMod { Yes, No };
        enum class ActionType { Immediate, Delayed, Loop };

        struct AsyncAction
        {
            // TODO: Use LuaMadeSimple instead of lua_State*
            // Not doing it now because the copy constructor gets implicitly deleted which is needed for erase & remove_if
            // lua_State* lua_state;
            int32_t lua_action_function_ref;
            ActionType type;
            std::chrono::time_point<std::chrono::steady_clock> created_at;
            int64_t delay;
        };
        std::vector<AsyncAction> m_pending_actions{};
        std::vector<AsyncAction> m_delayed_actions{};

        struct LuaCallbackData
        {
            const LuaMadeSimple::Lua& lua;
            Unreal::UClass* instance_of_class;
            std::vector<int32_t> registry_indexes;
        };
        static inline std::vector<LuaCallbackData> m_static_construct_object_lua_callbacks;
        static inline std::unordered_map<File::StringType, LuaCallbackData> m_global_command_lua_callbacks;
        static inline std::unordered_map<File::StringType, LuaCallbackData> m_custom_command_lua_pre_callbacks;

    protected:
        std::jthread m_async_thread;
        bool m_processing_events{};
        bool m_pause_events_processing{};
        std::mutex m_actions_lock{};

    public:
        Mod(UE4SSProgram&, std::wstring&& mod_name, std::wstring&& mod_path);
        ~Mod() = default;

    private:
        auto setup_lua_require_paths(const LuaMadeSimple::Lua& lua) const -> void;
        auto setup_lua_global_functions(const LuaMadeSimple::Lua& lua) const -> void;
        auto setup_lua_global_functions_main_state_only() const -> void;
        auto setup_lua_classes(const LuaMadeSimple::Lua& lua) const -> void;

        auto start_async_thread() -> void
        {
            m_async_thread = std::jthread{ &Mod::update_async, this };
        }

    public:
        auto get_name()  const -> std::wstring_view;

        auto set_installable(bool) -> void;
        auto is_installable() const -> bool;
        auto set_installed(bool) -> void;
        auto is_installed() const -> bool;
        auto prepare_mod(const LuaMadeSimple::Lua& lua) -> void;
        auto start_mod() -> void;
        auto is_started() const -> bool;
        auto uninstall() const -> void;

        auto lua() const -> const LuaMadeSimple::Lua&;
        auto main_lua() const -> const LuaMadeSimple::Lua*;
        auto async_lua() const -> const LuaMadeSimple::Lua*;
        auto get_lua_state() const -> lua_State*;

        auto actions_lock() -> void { m_actions_lock.lock(); }
        auto actions_unlock() -> void { m_actions_lock.unlock(); }

    public:
        // Called once when the program is starting, after mods are setup but before any mods have been started
        auto static on_program_start() -> void;

        // Main update from the program
        auto static update() -> void;

        // Async update
        // Used when the main update function would block other mods from executing their scripts
        auto update_async() -> void;

        auto process_delayed_actions() -> void;
        auto clear_delayed_actions() -> void;
    };

    struct LuaStatics
    {
        // Lua instance connected to the in-game console.
        static LuaMadeSimple::Lua* console_executor;
        static bool console_executor_enabled;
    };
}


#endif //UE4SS_REWRITTEN_MOD_HPP

```

`include/ObjectDumper/ObjectToString.hpp`:

```hpp
#ifndef UE4SS_OBJECT_TO_STRING_HPP
#define UE4SS_OBJECT_TO_STRING_HPP

#include <functional>
#include <unordered_map>

#include <File/File.hpp>

namespace RC::ObjectDumper
{
    using ToStringHash = size_t;
    using ObjectToStringDecl = std::function<void(void*, std::wstring&)>;
    extern std::unordered_map<ToStringHash, ObjectToStringDecl> object_to_string_functions;

    using ObjectToStringComplexDeclCallable = const std::function<void(void*)>&;
    using ObjectToStringComplexDecl = std::function<void(void*, File::StringType&, ObjectToStringComplexDeclCallable)>;
    extern std::unordered_map<ToStringHash, ObjectToStringComplexDecl> object_to_string_complex_functions;

    auto get_to_string(size_t hash) -> ObjectToStringDecl;
    auto get_to_string_complex(size_t hash) -> ObjectToStringComplexDecl;
    auto to_string_exists(size_t hash) -> bool;
    auto to_string_complex_exists(size_t hash) -> bool;

    auto object_trivial_dump_to_string(void* p_this, std::wstring& out_line, const wchar_t* post_delimiter = L".") -> void;
    auto object_to_string(void* p_this, std::wstring& out_line) -> void;

    auto property_trivial_dump_to_string(void* p_this, std::wstring& out_line) -> void;
    auto property_to_string(void* p_this, std::wstring& out_line) -> void;

    auto arrayproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto arrayproperty_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void;

    auto mapproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto mapproperty_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void;

    auto classproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto delegateproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto fieldpathproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto interfaceproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto multicastdelegateproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto objectproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto structproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto enumproperty_to_string(void* p_this, std::wstring& out_line) -> void;
    auto boolproperty_to_string(void* p_this, std::wstring& out_line) -> void;

    auto enum_to_string(void* p_this, std::wstring& out_line) -> void;
    auto class_to_string(void* p_this, std::wstring& out_line) -> void;
    auto function_to_string(void* p_this, std::wstring& out_line) -> void;

    auto scriptstruct_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void;

    auto init() -> void;
}

#endif //UE4SS_OBJECT_TO_STRING_HPP

```

`include/SDKGenerator/Common.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_COMMON_HPP
#define UE4SS_REWRITTEN_COMMON_HPP

#include <File/File.hpp>
#include <fmt/core.h>
#include <fmt/xchar.h>

namespace RC
{
    namespace Unreal
    {
        class UObject;
        class UClass;
        class UEnum;
        class UScriptStruct;
        class FProperty;
        class UFunction;
    }

    namespace UEGenerator
    {
        // TODO: Deal with the 'MulticastDelegate' type existing and the 'Inline' & 'Sparse' types not existing in earlier UE4 versions (low priority)
        enum class DelegateType
        {
            Delegate,
            MulticastInlineDelegate,
            MulticastSparseDelegate
        };

        enum class EnableForwardDeclarations { Yes, No };

        auto is_integral_type(Unreal::FProperty* property) -> bool;
        auto get_native_enum_name(Unreal::UEnum* uenum, bool include_type = true) -> File::StringType;
        auto generate_property_cxx_name(Unreal::FProperty* property, bool is_top_level_declaration, Unreal::UObject* class_context, EnableForwardDeclarations = EnableForwardDeclarations::No) -> File::StringType;
        auto sanitize_property_name(const File::StringType& property_name) -> File::StringType;
        auto generate_delegate_name(Unreal::FProperty* property, const File::StringType& context_name) -> File::StringType;
        auto get_native_class_name(Unreal::UClass* uclass, bool interface_name = false) -> File::StringType;
        auto get_native_struct_name(Unreal::UScriptStruct* script_struct) -> File::StringType;
        auto get_native_delegate_type_name(Unreal::UFunction* signature_function, Unreal::UClass* current_class = nullptr, bool strip_outer_name = false) -> File::StringType;
        auto is_delegate_signature_function(Unreal::UFunction* signature_function) -> bool;
        auto strip_delegate_signature_postfix(Unreal::UFunction* signature_function) -> File::StringType;
    }
}

#endif //UE4SS_REWRITTEN_COMMON_HPP

```

`include/SDKGenerator/Generator.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_SDKGENERATOR_GENERATOR_HPP
#define UE4SS_REWRITTEN_SDKGENERATOR_GENERATOR_HPP

#include <filesystem>
#include <unordered_map>
#include <unordered_set>

#include <File/File.hpp>
#include <Unreal/NameTypes.hpp>

namespace RC::Unreal
{
    class UObject;
    class UFunction;
    class UStruct;
    class UClass;
    class UScriptStruct;
    class FProperty;
}

namespace RC::UEGenerator
{
    enum class IsDelegateFunction
    {
        Yes,
        No,
    };

    class CXXGenerator
    {
    private:
        const std::filesystem::path m_directory_to_generate_in;

    public:
        struct ObjectInfo
        {
            Unreal::UObject* object{};
            ObjectInfo* first_encountered_at{};
        };

        struct PropertyInfo
        {
            Unreal::FProperty* property{};
            bool should_forward_declare{};
        };

        struct FunctionInfo
        {
            Unreal::UFunction* function{};
            ObjectInfo& owner;
            std::vector<PropertyInfo> params{};
        };

        struct GeneratedFile
        {
            std::filesystem::path primary_file_name;
            std::filesystem::path secondary_file_name;
            File::StringType primary_file_contents;
            File::StringType secondary_file_content;
            File::StringType package_name;
            File::Handle primary_file;
            File::Handle secondary_file;
            bool primary_file_has_no_contents;
            bool secondary_file_has_no_contents;
        };

        struct FileName
        {
            uint32_t num_collisions{};
        };

        // Map of FName.ComparisonIndex -> File::Handle
        std::unordered_map<Unreal::FName, GeneratedFile> m_files{};
        std::unordered_map<File::StringType, FileName> m_file_names{};
        std::unordered_map<Unreal::UObject*, ObjectInfo> m_classes_dumped{};

    public:
        CXXGenerator() = delete;
        CXXGenerator(const std::filesystem::path directory_to_generate_in);

    private:
        auto create_all_files() -> void;
        auto object_is_package(Unreal::UObject* object) -> bool;

        auto generate_offset_comment(Unreal::FProperty*, File::StringType& file_contents) -> File::StringType;
        auto generate_header_start(GeneratedFile& generated_file, File::StringViewType file_name) -> void;
        auto generate_header_end(GeneratedFile& generated_file) -> void;
        auto generate_tab(size_t num_tabs = 1) -> File::StringType;
        auto make_function_info(ObjectInfo& owner, Unreal::UFunction* function, File::StringType& current_class_content) -> FunctionInfo;
        auto generate_function_declaration(ObjectInfo&, const FunctionInfo&, GeneratedFile&, File::StringType& current_class_content, IsDelegateFunction = IsDelegateFunction::No) -> void;
        auto generate_prefix(Unreal::UStruct* obj_class) -> File::StringType;
        auto generate_class_dependency(ObjectInfo& owner, Unreal::UStruct* native_class, File::StringType& current_class_content) -> void;
        auto generate_class_dependency_from_property(ObjectInfo& owner, Unreal::FProperty* property, File::StringType& current_class_content) -> bool;
        auto generate_class(ObjectInfo object_info, GeneratedFile& generated_file, File::StringType& current_class_content) -> Unreal::FProperty*;
        auto generate_enum(Unreal::UObject* native_object, GeneratedFile& generated_file) -> void;
        auto generate_package(Unreal::UObject* package, File::StringType& out) -> void;
        auto generate_package_if_non_existent(Unreal::UObject* object) -> GeneratedFile*;
        auto cleanup_old_sdk() -> void;

    public:
        auto generate() -> void;
    };
}


#endif //UE4SS_REWRITTEN_SDKGENERATOR_GENERATOR_HPP

```

`include/SDKGenerator/JSONDumper.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_JSONDUMPER_HPP
#define UE4SS_REWRITTEN_JSONDUMPER_HPP

#include <File/File.hpp>

namespace RC
{
    class UE4SSProgram;
}

namespace RC::UEGenerator::JSONDumper
{
    auto dump_to_json(File::StringViewType file_name) -> void;
}

#endif //UE4SS_REWRITTEN_JSONDUMPER_HPP

```

`include/SDKGenerator/UEHeaderGenerator.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_SDKGENERATOR_UE_HEADER_GENERATOR_HPP
#define UE4SS_REWRITTEN_SDKGENERATOR_UE_HEADER_GENERATOR_HPP

#include <filesystem>
#include <unordered_map>
#include <set>

#include <File/File.hpp>
#include <SDKGenerator/Common.hpp>
#pragma warning(disable: 4005)
#include <Unreal/NameTypes.hpp>
#pragma warning(default: 4005)

namespace RC::Unreal
{
    class UObject;
    class UFunction;
    class UStruct;
    class FProperty;
    class UClass;
    class FField;
    class UEnum;
    class UScriptStruct;
}

namespace RC::UEGenerator
{
    using FFilePath = std::filesystem::path;
    using UObject = RC::Unreal::UObject;
    using UClass = RC::Unreal::UClass;
    using FProperty = RC::Unreal::FProperty;
    using FField = RC::Unreal::FField;
    using UEnum = RC::Unreal::UEnum;
    using UScriptStruct = RC::Unreal::UScriptStruct;
    using UFunction = RC::Unreal::UFunction;

    enum class DependencyLevel
    {
        NoDependency,
        /** Object dependency will result in a pre-declaration statement generation */
        PreDeclaration,
        /** Object dependency will result in the header include generation */
        Include,
    };

    enum class AccessModifier
    {
        None,
        Public,
        Protected,
        Private
    };

    struct ClassBlueprintInfo
    {
        bool is_blueprint_type;
        bool is_blueprintable;

        ClassBlueprintInfo() : is_blueprint_type(false), is_blueprintable(false) {}
    };

    struct PropertyTypeDeclarationContext
    {
        std::wstring context_name;

        class GeneratedSourceFile* source_file;

        bool is_top_level_declaration;
        bool* out_is_bitmask_bool;

        PropertyTypeDeclarationContext(const std::wstring& context_name, GeneratedSourceFile* source_file = NULL, bool is_top_level_declaration = false, bool* out_is_bitmask_bool = NULL)
        {
            this->context_name = context_name;
            this->source_file = source_file;
            this->is_top_level_declaration = is_top_level_declaration;
            this->out_is_bitmask_bool = out_is_bitmask_bool;
        }

        auto inner_context() const -> PropertyTypeDeclarationContext
        {
            return PropertyTypeDeclarationContext(context_name, source_file);
        }
    };

    struct StringInsensitiveCompare
    {
        auto operator()(const std::wstring& a, const std::wstring& b) const -> bool
        {
            return _wcsicmp(a.c_str(), b.c_str()) < 0;
        }
    };

    using CaseInsensitiveSet = std::set<std::wstring, StringInsensitiveCompare>;

    class GeneratedFile
    {
    protected:
        std::wstring m_file_base_name;
        FFilePath m_full_file_path;

        std::wstring m_file_contents_buffer;
        int32_t m_current_indent_count;
    public:
        GeneratedFile(const FFilePath& full_file_path);
        virtual ~GeneratedFile() = default;

        //Delete copy and move constructors and assignment operator
        GeneratedFile(const GeneratedFile&) = delete;
        GeneratedFile(GeneratedFile&&) = delete;
        auto operator=(const GeneratedFile&) -> void = delete;

        auto append_line(const std::wstring& line) -> void;
        auto append_line_no_indent(const std::wstring& line) -> void;

        auto begin_indent_level() -> void;
        auto end_ident_level() -> void;
        auto serialize_file_content_to_disk() -> bool;
    protected:
        virtual auto has_content_to_save() const -> bool;
        virtual auto generate_file_contents() -> std::wstring;
    };

    class GeneratedSourceFile : public GeneratedFile
    {
    private:
        std::wstring m_file_module_name;
        std::unordered_map<UObject*, DependencyLevel> m_dependencies;
        std::set<std::wstring> m_extra_includes;
        mutable std::set<std::wstring> m_dependency_module_names;
        GeneratedSourceFile* m_header_file;
        bool m_is_implementation_file;
    public:
        GeneratedSourceFile(const FFilePath& file_path, const std::wstring& file_module_name, bool is_implementation_file);

        //Delete copy and move constructors and assignment operator
        GeneratedSourceFile(const GeneratedSourceFile&) = delete;
        GeneratedSourceFile(GeneratedSourceFile&&) = delete;
        auto operator=(const GeneratedSourceFile&) -> void = delete;

        auto set_header_file(GeneratedSourceFile* header_file) -> void;
        auto add_dependency_object(UObject* object, DependencyLevel dependency_level) -> void;
        auto add_extra_include(const std::wstring& included_file_name) -> void;

        auto get_header_module_name() const -> const std::wstring& { return m_file_module_name; }
        auto is_implementation_file() const -> bool { return m_is_implementation_file; }

        auto copy_dependency_module_names(std::set<std::wstring>& out_dependency_module_names) const -> void
        {
            out_dependency_module_names.insert(m_dependency_module_names.begin(), m_dependency_module_names.end());
        }

        auto static create_source_file(const FFilePath& root_dir, const std::wstring& module_name, const std::wstring& base_name, bool is_implementation_file) -> GeneratedSourceFile;
    protected:
        auto has_dependency(UObject* object, DependencyLevel dependency_level) -> bool;

        virtual auto has_content_to_save() const -> bool override;
        virtual auto generate_file_contents() -> std::wstring override;

        auto generate_pre_declarations_string() const -> std::wstring;
        auto generate_includes_string() const -> std::wstring;
    };

    struct UniqueName
    {
        static constexpr int32_t HAS_NO_DUPLICATES = 1;

        File::StringType name{};
        int32_t usable_id{HAS_NO_DUPLICATES};
    };

    class UEHeaderGenerator
    {
    private:
        FFilePath m_root_directory;
        std::wstring m_primary_module_name;

        std::set<std::wstring> m_forced_module_dependencies;
        std::set<std::wstring> m_ignored_module_names;
        std::set<std::wstring> m_classes_with_object_initializer;

        std::unordered_map<std::wstring, std::wstring> m_underlying_enum_types;
        std::set<std::wstring> m_blueprint_visible_enums;
        std::set<std::wstring> m_blueprint_visible_structs;
        std::unordered_map<std::wstring, std::shared_ptr<std::set<std::wstring>>> m_module_dependencies;

        // Storage to ensure that we don't have duplicate file names
        static std::unordered_map<File::StringType, UniqueName> m_used_file_names;
        static std::unordered_map<UObject*, int32_t> m_dependency_object_to_unique_id;

    public:
        UEHeaderGenerator(const FFilePath& root_directory);

        //Delete copy, move and assignment operators
        UEHeaderGenerator(const UEHeaderGenerator&) = delete;
        UEHeaderGenerator(UEHeaderGenerator&&) = delete;
        auto operator=(const UEHeaderGenerator&) -> void = delete;

        auto ignore_selected_modules() -> void;

        auto dump_native_packages() -> void;
        auto generate_object_description_file(UObject* object) -> bool;
        auto generate_module_build_file(const std::wstring& module_name) -> void;
        auto generate_module_implementation_file(const std::wstring& module_name) -> void;
    private:
        auto generate_interface_definition(UClass* function, GeneratedSourceFile& header_data) -> void;
        auto generate_object_definition(UClass* interface_function, GeneratedSourceFile& header_data) -> void;
        auto generate_struct_definition(UScriptStruct* property, GeneratedSourceFile& header_data) -> void;
        auto generate_enum_definition(UEnum* name_pair, GeneratedSourceFile& header_data) -> void;
        auto generate_global_delegate_declaration(UFunction* signature_function, GeneratedSourceFile& header_data) -> void;
        auto generate_delegate_type_declaration(UFunction* signature_function, GeneratedSourceFile& header_data) -> void;
        auto generate_object_implementation(UClass* property, GeneratedSourceFile& implementation_file) -> void;
        auto generate_struct_implementation(UScriptStruct* property, GeneratedSourceFile& implementation_file) -> void;

        auto generate_property(UObject* uclass, FProperty* property, GeneratedSourceFile& header_data) -> void;
        auto generate_function(UClass* uclass, UFunction* function, GeneratedSourceFile& header_data, bool is_generating_interface, const CaseInsensitiveSet& blacklisted_property_names, bool generate_as_override = false) -> void;

        auto generate_property_value(FProperty* property, void* object, GeneratedSourceFile& implementation_file, const std::wstring& property_scope) -> void;
        auto generate_function_implementation(UClass* uclass, UFunction* function, GeneratedSourceFile& implementation_file, bool is_generating_interface, const CaseInsensitiveSet& blacklisted_property_names) -> void;

        auto generate_interface_flags(UClass* uinterface) const -> std::wstring;
        auto generate_class_flags(UClass* uclass) const -> std::wstring;
        auto generate_struct_flags(UScriptStruct* script_struct) const -> std::wstring;
        auto generate_enum_flags(UEnum* uenum) const -> std::wstring;
        auto generate_property_type_declaration(FProperty* property, const PropertyTypeDeclarationContext& context) -> std::wstring;
        auto generate_property_flags(FProperty* property) const -> std::wstring;
        auto generate_function_argument_flags(FProperty* property) const -> std::wstring;
        auto generate_function_flags(UFunction* function, bool is_function_pure_virtual = false) const -> std::wstring;
        auto generate_function_parameter_list(UClass* property, UFunction* function, GeneratedSourceFile& header_data, bool generate_comma_before_name, const std::wstring& context_name, const CaseInsensitiveSet& blacklisted_property_names, int32_t* out_num_params = NULL) -> std::wstring;
        auto generate_default_property_value(FProperty* property, GeneratedSourceFile& header_data, const std::wstring& ContextName) -> std::wstring;

        auto generate_enum_value(UEnum* uenum, int64_t enum_value) -> std::wstring;
        auto generate_simple_assignment_expression(FProperty* property, const std::wstring& value, GeneratedSourceFile& implementation_file, const std::wstring& property_scope) -> void;

        auto static generate_parameter_count_string(int32_t parameter_count) -> std::wstring;
        auto static determine_primary_game_module_name() -> std::wstring;
    public:
        auto add_module_and_sub_module_dependencies(std::set<std::wstring>& out_module_dependencies, const std::wstring& module_name, bool add_self_module = true) -> void;
        auto static collect_blacklisted_property_names(UObject* property) -> CaseInsensitiveSet;

        auto static generate_object_pre_declaration(UObject* object, std::wstring& out_extra_declaration) -> std::wstring;

        auto static convert_module_name_to_api_name(const std::wstring& module_name) -> std::wstring;
        auto static get_module_name_for_package(UObject* package) -> std::wstring;
        auto static sanitize_enumeration_name(const std::wstring& enumeration_name) -> std::wstring;

        auto static get_class_blueprint_info(UClass* function) -> ClassBlueprintInfo;
        auto static is_struct_blueprint_type(UScriptStruct* property) -> bool;
        auto static is_function_parameter_shadowing(UClass* property, FProperty* function_parameter) -> bool;

        auto static
        append_access_modifier(GeneratedSourceFile& header_data, AccessModifier needed_access, AccessModifier& current_access) -> void;
        auto static get_property_access_modifier(FProperty* property) -> AccessModifier;
        auto static get_function_access_modifier(UFunction* function) -> AccessModifier;
        auto static create_string_literal(const std::wstring& string) -> std::wstring;
        auto static get_header_name_for_object(UObject* object, bool get_existing_header = false) -> std::wstring;
        auto static generate_cross_module_include(UObject* object, const std::wstring& module_name, const std::wstring& fallback_name) -> std::wstring;
    };
}

#endif //UE4SS_REWRITTEN_SDKGENERATOR_UE_HEADER_GENERATOR_HPP
```

`include/SettingsManager.hpp`:

```hpp
#ifndef UE4SS_SETTINGSMANAGER_HPP
#define UE4SS_SETTINGSMANAGER_HPP

#include <cstdint>
#include <filesystem>

#include <File/File.hpp>

namespace RC
{
    class SettingsManager
    {
    public:
        struct SectionOverrides
        {
            File::StringType ModsFolderPath{};
        } Overrides;

        struct SectionGeneral
        {
            bool EnableHotReloadSystem{};
            bool InvalidateCacheIfDLLDiffers{true};
            bool EnableDebugKeyBindings{false};
            int64_t MaxScanAttemptsNormal{20};
            int64_t MaxScanAttemptsModular{2000};
            bool UseUObjectArrayCache{true};
        } General;

        struct SectionEngineVersionOverride
        {
            int64_t MajorVersion{-1};
            int64_t MinorVersion{-1};
        } EngineVersionOverride;

        struct SectionObjectDumper
        {
            bool LoadAllAssetsBeforeDumpingObjects{};
        } ObjectDumper;

        struct SectionCXXHeaderGenerator
        {
            bool DumpOffsetsAndSizes{};
            bool KeepMemoryLayout{};
            bool LoadAllAssetsBeforeGeneratingCXXHeaders{};
        } CXXHeaderGenerator;

        struct SectionUHTHeaderGenerator
        {
            bool IgnoreAllCoreEngineModules{};
            bool IgnoreEngineAndCoreUObject{true};
            bool MakeAllFunctionsBlueprintCallable{};
            bool MakeAllPropertyBlueprintsReadWrite{};
            bool MakeEnumClassesBlueprintType{};
        } UHTHeaderGenerator;

        struct SectionDebug
        {
            bool SimpleConsoleEnabled{true};
            bool DebugConsoleEnabled{ true };
            bool DebugConsoleVisible{ true };
        } Debug;

        struct SectionThreads
        {
            int64_t SigScannerNumThreads{8};
            int64_t SigScannerMultithreadingModuleSizeThreshold{16777216};
        } Threads;

        struct SectionMemory
        {
            int64_t MaxMemoryUsageDuringAssetLoading{85};
        } Memory;

    public:
        SettingsManager() = default;

    public:
        auto deserialize(std::filesystem::path& file_name) -> void;
    };
}

#endif //UE4SS_SETTINGSMANAGER_HPP

```

`include/Signatures.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_SIGNATURES_HPP
#define UE4SS_REWRITTEN_SIGNATURES_HPP

#include <functional>

namespace RC::Unreal::UnrealInitializer
{
    struct Config;
}

namespace RC
{
    class SignatureContainer;

    enum class DidLuaScanSucceed
    {
        Yes,
        No,
    };

    auto scan_complete_default_func(DidLuaScanSucceed) -> void;

    using LuaScriptMatchFoundFunc = const std::function<DidLuaScanSucceed(void*)>;
    using LuaScriptScanCompleteFunc = const std::function<void(DidLuaScanSucceed)>;
    auto scan_from_lua_script(std::wstring& script_file_path_and_name, std::vector<SignatureContainer>&, LuaScriptMatchFoundFunc& match_found_func, LuaScriptScanCompleteFunc& scan_complete_func = &scan_complete_default_func) -> void;

    auto setup_lua_scan_overrides(std::filesystem::path& working_directory, Unreal::UnrealInitializer::Config&) -> void;
}

#endif //UE4SS_REWRITTEN_SIGNATURES_HPP

```

`include/UE4SSProgram.hpp`:

```hpp
#ifndef UE4SS_REWRITE_MAYBE_UE4SSPROGRAM_HPP
#define UE4SS_REWRITE_MAYBE_UE4SSPROGRAM_HPP

#include <thread>
#include <functional>
#include <string>
#include <string_view>
#include <mutex>

#include <MProgram.hpp>
#include <SettingsManager.hpp>
#include <Unreal/UnrealVersion.hpp>
#include <Unreal/TArray.hpp>
#include <Input/Handler.hpp>
#include <Mod.hpp>
#include <LuaLibrary.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <GUI/GUI.hpp>

class GlobalClassTest
{
public:
    auto DoSomething() -> void { printf_s("GlobalClassTest\n"); }
};

auto GlobalFunctionTest() -> GlobalClassTest;

namespace RC2
{
    class MyFirstClass
    {
    public:
        auto DoSomething() -> void { printf_s("RC2::MyFirstClass\n"); }
    };

    namespace RC3::RC4
    {
        class MyFirstClass
        {
        public:
            auto DoSomething() -> void { printf_s("RC2::RC3::RC4::MyFirstClass\n"); }
        };
    }
}

namespace RC
{
    class MyFirstClass
    {
    public:
        auto DoSomething() -> void { printf_s("RC::MyFirstClass\n"); }
    };

    namespace Unreal
    {
        class UObject;
        class UObjectBase;
        class UObjectBaseUtility;
        class UWorld;
    }

    namespace Output
    {
        class ConsoleDevice;
    }

    struct RecognizableStruct
    {
        // Sha1 hash with no salt: "RecognizableString"
        char recognizable_string[41]{"81acd41b7490f7b70ec6455657855733e21d7c0e"};

        LuaLibrary::SetScriptVariableInt32Signature set_script_variable_int32_function;
        LuaLibrary::SetScriptVariableDefaultDataSignature set_script_variable_default_data_function;
        LuaLibrary::CallScriptFunctionSignature call_script_function_function;
        LuaLibrary::IsUE4SSInitializedSignature is_ue4ss_initialized_function;

        // Ensure that we have zero-initialized memory at the end of the struct
        // This means that we can reliably check whether a function exists externally
        uint64_t safety_padding[8]{0};
    };

    auto GetPlayerControllerTest2() -> Unreal::UObjectBase*;
    auto GetPlayerControllerTest3() -> Unreal::UObjectBaseUtility*;
    auto GetMyFirstClass() -> MyFirstClass;
    auto GetMyFirstClass2() -> ::RC2::MyFirstClass;
    auto GetMyFirstClass3() -> ::RC2::RC3::RC4::MyFirstClass;

    class UE4SSProgram : public MProgram
    {
    public:
        constexpr static wchar_t m_settings_file_name[] = L"UE4SS-settings.ini";
        constexpr static wchar_t m_log_file_name[] = L"UE4SS.log";
        constexpr static wchar_t m_object_dumper_file_name[] = L"UE4SS_ObjectDump.txt";

    public:
        static SettingsManager settings_manager;
        static inline bool unreal_is_shutting_down{};

    protected:
        Input::Handler m_input_handler{L"ConsoleWindowClass", L"UnrealWindow"};
        std::jthread m_event_loop;
        std::jthread m_render_thread;

    private:
        std::filesystem::path m_game_path_and_exe_name;
        std::filesystem::path m_root_directory;
        std::filesystem::path m_module_file_path;
        std::filesystem::path m_working_directory;
        std::filesystem::path m_mods_directory;
        std::filesystem::path m_game_executable_directory;
        std::filesystem::path m_log_directory;
        std::filesystem::path m_object_dumper_output_directory;
        std::filesystem::path m_default_settings_path_and_file;
        std::filesystem::path m_settings_path_and_file;
        Output::DebugConsoleDevice* m_debug_console_device{};
        Output::ConsoleDevice* m_console_device{};
        GUI::DebuggingGUI m_debugging_gui{GUI::GfxBackend::DX11, GUI::OSBackend::Windows};

        using EventCallable = void(*)(void* data);
        struct Event
        {
            EventCallable callable{};
            void* data{};
        };
        std::vector<Event> m_queued_events{};
        std::mutex m_event_queue_mutex{};

    public:
        static inline std::vector<std::unique_ptr<Mod>> m_mods;

        static inline RecognizableStruct m_shared_functions{};

        static inline UE4SSProgram* s_program{};

        bool m_has_game_specific_config{};
        bool m_processing_events{};
        bool m_pause_events_processing{};
        bool m_simple_console_enabled{};
        bool m_debug_console_enabled{};
        bool m_debug_console_visible{};

    public:
        enum class IsInstalled
        {
            Yes,
            No
        };

        enum class IsStarted
        {
            Yes,
            No
        };

    public:
        UE4SSProgram(const std::wstring& ModuleFilePath, std::initializer_list<BinaryOptions> options);
        ~UE4SSProgram();
        UE4SSProgram(const UE4SSProgram&) = delete;
        UE4SSProgram(UE4SSProgram&&) = delete;

    private:
        auto setup_paths(const std::wstring& moduleFilePath) -> void;
        enum class FunctionStatus
        {
            Success,
            Failure,
        };
        auto create_emergency_console_for_early_error(File::StringViewType error_message) -> void;
        auto setup_output_devices() -> void;
        auto setup_mod_directory_path() -> void;
        auto create_debug_console() -> void;
        auto setup_unreal() -> void;
        auto load_unreal_offsets_from_file() -> void;
        auto share_lua_functions() -> void;
        auto on_program_start() -> void;
        auto setup_unreal_properties() -> void;

    protected:
        auto update() -> void;
        auto setup_mods() -> void;
        auto start_mods() -> void;
        auto uninstall_mods() -> void;

    public:
        auto reinstall_mods() -> void;
        auto get_object_dumper_output_directory() -> const File::StringType;
        auto get_working_directory() -> File::StringViewType;
        auto get_mods_directory() -> File::StringViewType;
        auto generate_uht_compatible_headers() -> void;
        auto generate_cxx_headers(const std::filesystem::path& output_dir) -> void;
        auto get_debugging_ui() -> GUI::DebuggingGUI& { return m_debugging_gui; };
        auto stop_render_thread() -> void;
        auto queue_event(EventCallable callable, void* data) -> void;
        auto is_queue_empty() -> bool;
        auto can_process_events() -> bool { return m_processing_events; }

    public:
        // API pass-through for use outside the private scope of UE4SSProgram
        auto register_keydown_event(Input::Key, const Input::EventCallbackCallable&, uint8_t custom_data = 0) -> void;
        auto register_keydown_event(Input::Key, const Input::Handler::ModifierKeyArray&, const Input::EventCallbackCallable&, uint8_t custom_data = 0) -> void;

    private:
        static auto install_mods() -> void;

    public:
        static auto dump_all_objects_and_properties(const File::StringType& output_path_and_file_name) -> void;
        static auto find_mod_by_name(std::wstring_view mod_name, IsInstalled = IsInstalled::No, IsStarted = IsStarted::No) -> Mod*;
        static auto find_mod_by_name(std::string_view mod_name, IsInstalled = IsInstalled::No, IsStarted = IsStarted::No) -> Mod*;
        static auto static_cleanup() -> void;
        static auto get_program() -> UE4SSProgram& { return *s_program; }
    };
}

#endif //UE4SS_REWRITE_MAYBE_UE4SSPROGRAM_HPP

```

`include/UnrealCustom/CustomProperty.hpp`:

```hpp
#ifndef UE4SS_CUSTOMPROPERTY_HPP
#define UE4SS_CUSTOMPROPERTY_HPP

#include <cstdint>
#include <memory>

#include <Helpers/Casting.hpp>
#include <Unreal/FProperty.hpp>

namespace RC::Unreal
{
    class UClass;
    class UScriptStruct;

    // Special base to be used for creating our own FProperty objects with our own custom data
    // Used when creating custom properties
    class CustomProperty : public FProperty
    {
    private:
        // Untyped data
        // The proper data will be copied inside at the proper offsets using StaticOffsetFinder
        std::byte m_data[0x128]{};

    public:
        CustomProperty(int32_t offset_internal, int32_t element_size);

    public:
        auto static construct(int32_t offset_internal, UClass* belongs_to_class, UClass* inner_class, int32_t element_size) -> std::unique_ptr<CustomProperty>;

        // 'set_member_variable' is not used anymore because we're using a completely different system for retrieving member variable offsets.
        // This system is abstracted more and doesn't expose offsets as easily.
        // Keeping this code here for reference in case it's needed for fixing things later.
        /*
        template<typename ValueType>
        auto static set_member_variable(const ::RC::Unreal::StaticOffsetFinder::MemberOffsets member, CustomProperty* property, ValueType new_value) -> void
        {
            auto* data_offset_internal = Helper::Casting::ptr_cast<ValueType*>(&property->m_data[StaticOffsetFinder::retrieve_static_offset(member)]);
            *data_offset_internal = new_value;
        }

        template<typename ValueType>
        auto static set_member_variable(const ::RC::Unreal::StaticOffsetFinder::MemberOffsets member, int32_t offset_offset, CustomProperty* property, ValueType new_value) -> void
        {
            auto* data_offset_internal = Helper::Casting::ptr_cast<ValueType*>(&property->m_data[StaticOffsetFinder::retrieve_static_offset(member) + offset_offset]);
            *data_offset_internal = new_value;
        }
        //*/
    };

    class CustomArrayProperty : public CustomProperty
    {
    public:
        CustomArrayProperty(int32_t offset_internal, int32_t element_size);

    public:
        // Used for the C++ API
        auto static construct(int32_t offset_internal, FProperty* array_inner, int32_t element_size) -> std::unique_ptr<CustomProperty>;

        // Used for the Lua API
        auto static construct(int32_t offset_internal, UClass* belongs_to_class, UClass* inner_class, FProperty* array_inner, int32_t element_size) -> std::unique_ptr<CustomProperty>;
    };

    class CustomStructProperty : public CustomProperty
    {
    public:
        CustomStructProperty(int32_t offset_internal, int32_t element_size);

    public:
        auto static construct(int32_t offset_internal, UScriptStruct* script_struct, int32_t element_size) -> std::unique_ptr<CustomProperty>;
    };
}

#endif //UE4SS_CUSTOMPROPERTY_HPP

```

`include/UnrealDef.hpp`:

```hpp
#ifndef UE4SS_REWRITTEN_UNREALDEF_HPP
#define UE4SS_REWRITTEN_UNREALDEF_HPP

#pragma warning(disable: 4005)
#include <Unreal/UObjectGlobals.hpp>
#include <Unreal/UnrealFlags.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UStruct.hpp>
#include <Unreal/FField.hpp>
#include <Unreal/NameTypes.hpp>
#include <Unreal/TArray.hpp>
#include <Unreal/TMap.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FNameProperty.hpp>
#include <Unreal/Property/FTextProperty.hpp>
#include <Unreal/Property/FStrProperty.hpp>
#include <Unreal/Property/FDelegateProperty.hpp>
#include <Unreal/Property/FMulticastInlineDelegateProperty.hpp>
#include <Unreal/Property/FMulticastSparseDelegateProperty.hpp>
#include <Unreal/Property/FSetProperty.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FFieldPathProperty.hpp>
//#include <Unreal/XStructData.hpp>
#include <Unreal/FFrame.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/FWeakObjectPtr.hpp>
//#include <Unreal/CustomType.hpp>
#include <Unreal/FAssetData.hpp>
#include <Unreal/UAssetRegistry.hpp>
#include <Unreal/UAssetRegistryHelpers.hpp>
#pragma warning(default: 4005)

namespace RC
{
    namespace UObjectGlobals = Unreal::UObjectGlobals;
    using EObjectFlags = Unreal::EObjectFlags;
    using UObjectBaseUtility = Unreal::UObjectBaseUtility;
    using UObject = Unreal::UObject;
    using AActor = Unreal::AActor;
    using UClass = Unreal::UClass;
    using UStruct = Unreal::UStruct;
    using UScriptStruct = Unreal::UScriptStruct;
    using FField = Unreal::FField;
    using FName = Unreal::FName;
    using FString = Unreal::FString;
    using FProperty = Unreal::FProperty;
    using FIntProperty = Unreal::FIntProperty;
    using FInt8Property = Unreal::FInt8Property;
    using FInt16Property = Unreal::FInt16Property;
    using FInt64Property = Unreal::FInt64Property;
    using FByteProperty = Unreal::FByteProperty;
    using FFloatProperty = Unreal::FFloatProperty;
    using FObjectProperty = Unreal::FObjectProperty;
    using FWeakObjectProperty = Unreal::FWeakObjectProperty;
    using FClassProperty = Unreal::FClassProperty;
    using FBoolProperty = Unreal::FBoolProperty;
    using FArrayProperty = Unreal::FArrayProperty;
    using FStructProperty = Unreal::FStructProperty;
    using FNameProperty = Unreal::FNameProperty;
    using FTextProperty = Unreal::FTextProperty;
    using FStrProperty = Unreal::FStrProperty;
    template<typename T>
    using TArray = Unreal::TArray<T>;
    using UFunction = Unreal::UFunction;
    using XStruct = Unreal::XStructData;
    template<typename T1, typename T2>
    using TMap = Unreal::TMap<T1, T2>;

    using UnrealScriptFunction = Unreal::UnrealScriptFunction;
    using FFrame = Unreal::FFrame;
    using UEnum = Unreal::UEnum;

    using FWeakObjectPtr = Unreal::FWeakObjectPtr;
    using FDelegateProperty = Unreal::FDelegateProperty;
    using FMulticastInlineDelegateProperty = Unreal::FMulticastInlineDelegateProperty;
    using FMulticastSparseDelegateProperty = Unreal::FMulticastSparseDelegateProperty;
    using FSetProperty = Unreal::FSetProperty;
    using FSoftClassProperty = Unreal::FSoftClassProperty;
    using FEnumProperty = Unreal::FEnumProperty;
    using FFieldPathProperty = Unreal::FFieldPathProperty;

    //using CustomArrayProperty = Unreal::CustomArrayProperty;
    //using CustomStructProperty = Unreal::CustomStructProperty;
    using FAssetData = Unreal::FAssetData;
    using UAssetRegistry = Unreal::UAssetRegistry;
    using UAssetRegistryHelpers = Unreal::UAssetRegistryHelpers;
}

#endif //UE4SS_REWRITTEN_UNREALDEF_HPP

```

`internal_build_tools/cleanup_build_option_files.bat`:

```bat
cd generated_src
if exist %enable_with_case_preserving_file% (
    del "%enable_with_case_preserving_file%"
)
if exist %enable_build_as_xinput_file% (
    del "%enable_build_as_xinput_file%"
)
if exist %disable_with_case_preserving_file% (
    del "%disable_with_case_preserving_file%"
)
if exist %disable_build_as_xinput_file% (
    del "%disable_build_as_xinput_file%"
)
cd ..
```

`internal_build_tools/package_all_distributions.bat`:

```bat
set CASE_PRESERVING=0
set BUILD_AS_XINPUT=1
call internal_build_tools/package_binary.bat "UE4SS - XInput" "xinput1_3"

:: Case-preserving builds have been turned off because we no longer support them widely.
:: set CASE_PRESERVING=1
:: set BUILD_AS_XINPUT=1
:: call internal_build_tools/package_binary.bat "UE4SS - XInput - Case Preserving" "xinput1_3"

:: set CASE_PRESERVING=1
:: set BUILD_AS_XINPUT=0
:: call internal_build_tools/package_binary.bat "UE4SS - Standard - Case Preserving" "ue4ss"

set CASE_PRESERVING=0
set BUILD_AS_XINPUT=0
call internal_build_tools/package_binary.bat "UE4SS - Standard" "ue4ss"

:: Cleanup
call internal_build_tools/cleanup_build_option_files.bat

:: Set version numbers -> After compiling
if %IS_MINOR_RELEASE%==1 (
    set /a minor_version=%minor_version%+1
)
if %IS_MAJOR_RELEASE%==1 (
    set /a major_version=%major_version%+1
)
call internal_build_tools/set_version.bat %major_version% %minor_version% %hotfix_version% %pre_release_version% %beta_version%

```

`internal_build_tools/package_binary.bat`:

```bat
set build_variant=%1%
if not defined build_variant (
    echo Was unable to call 'package_binary' because no build variant was passed
    pause
    exit
)

set file_to_package=%2%
if not defined file_to_package (
    echo Was unable to call 'package_binary' because no binary file was specified
    pause
    exit
)

if not defined IS_MAJOR_RELEASE (
    echo IS_MAJOR_RELEASE must be defined
    pause
    exit
)

if not defined IS_MINOR_RELEASE (
    echo IS_MINOR_RELEASE must be defined
    pause
    exit
)

if not defined IS_HOTFIX_RELEASE (
    echo IS_HOTFIX_RELEASE must be defined
    pause
    exit
)

if not defined IS_PRE_RELEASE (
    echo IS_PRE_RELEASE must be defined
    pause
    exit
)

if not defined IS_BETA_RELEASE (
    echo IS_BETA_RELEASE must be defined
    pause
    exit
)

:: String builder for final packaged filename -> START
set packaged_filename=UE4SS
if %BUILD_AS_XINPUT% == 1 (
    set packaged_filename=%packaged_filename%_Xinput
) else (
    set packaged_filename=%packaged_filename%_Standard
)

if %CASE_PRESERVING% == 1 (
    set packaged_filename=%packaged_filename%_CasePreserving
)

set packaged_filename=%packaged_filename%_v%major_version%.%minor_version%.%hotfix_version%

if %IS_PRE_RELEASE% == 1 (
    set packaged_filename=%packaged_filename%_PreRelease%pre_release_version%
)

if %IS_BETA_RELEASE% == 1 (
    set packaged_filename=%packaged_filename%_Beta%beta_version%
)

set packaged_filename=%packaged_filename%.zip
:: String builder for final packaged filename -> END

Rem Create or remove build option files
echo Packaging %build_variant%...
call internal_build_tools/set_build_switches.bat %build_variant%

Rem Maintain the same build number across all binaries
Rem if %LOG_LEVEL%==VERBOSE echo Maintaining build number (TODO)

Rem Re-run CMake to apply build option files
call internal_build_tools/reload_cmake.bat

Rem Build project
if %LOG_LEVEL%==VERBOSE echo Building...
if %BUILD_AS_XINPUT% == 1 (
    MSBuild.exe /m "VS_Solution\xinput1_3.vcxproj" /property:Configuration=Release > nul
) else (
    MSBuild.exe /m "VS_Solution\ue4ss.vcxproj" /property:Configuration=Release > nul
)

Rem Copy files to staging directory
if %LOG_LEVEL%==VERBOSE echo Staging binaries
xcopy /v /y "%build_output_directory%\%file_to_package%.dll" "%staging_directory%\" > nul

if %IS_BETA_RELEASE%==1 (
    xcopy /v /y "%build_output_directory%\%file_to_package%.pdb" "%staging_directory%\" > nul
)

Rem Zip files (7zip) and give zip a proper name
if %LOG_LEVEL%==VERBOSE echo Creating archive
cd %staging_directory%
%zip_exe% a "%packaged_filename%" "*" > nul
move %packaged_filename% ../%output_directory% > nul
cd ..

Rem Remove binaries from staging area but leave the rest
if %LOG_LEVEL%==VERBOSE echo Cleaning up staging directory
del %staging_directory%\%file_to_package%.dll

if %IS_BETA_RELEASE%==1 (
    del %staging_directory%\%file_to_package%.pdb
)

```

`internal_build_tools/packaging_header.bat`:

```bat
if not exist "VS_Solution\" (
	mkdir "VS_Solution"
)

if not defined IS_MAJOR_RELEASE (
    echo IS_MAJOR_RELEASE must be defined
    pause
    exit
)

if not defined IS_MINOR_RELEASE (
    echo IS_MINOR_RELEASE must be defined
    pause
    exit
)

if not defined IS_HOTFIX_RELEASE (
    echo IS_HOTFIX_RELEASE must be defined
    pause
    exit
)

if not defined IS_PRE_RELEASE (
    echo IS_PRE_RELEASE must be defined
    pause
    exit
)

if not defined IS_BETA_RELEASE (
    echo IS_BETA_RELEASE must be defined
    pause
    exit
)

Rem Required external tools
set zip_exe="D:\Program Files\7-Zip\7z.exe"

set enable_with_case_preserving_file=enable_with_case_preserving.build_option
set disable_with_case_preserving_file=disable_with_case_preserving.build_option
set enable_build_as_xinput_file=enable_build_as_xinput.build_option
set disable_build_as_xinput_file=disable_build_as_xinput.build_option
set build_file=VS_Solution\ue4ss_rewritten.sln
set build_output_directory=Output\ue4ss\Binaries\x64\Release
set staging_directory=Staging
set output_directory=Releases
set version_cache_file=version.cache

if not exist %staging_directory% (
    echo Staging directory, '%staging_directory%', does not exist.
    pause
    exit /b
)

if not exist generated_src (
    echo Unable to find project directory, 'generated_src'.
    pause
    exit /b
)

if not exist generated_src\version.cache (
    echo Unable to find version cache file, 'generated_src\version.cache'.
    pause
    exit /b
)

if not exist %output_directory% (
    mkdir %output_directory%
)

Rem Retrieve version numbers
set major_version=0
set minor_version=0
set hotfix_version=0
set pre_release_version=0
set beta_version=0
for /f "tokens=1,2,3,4,5 delims=." %%a in (generated_src\version.cache) do (
    set major_version=%%a
    set minor_version=%%b
    set hotfix_version=%%c
    set pre_release_version=%%d
    set beta_version=%%e
)

:: Set version numbers -> Before compiling
if %IS_PRE_RELEASE%==1 (
    set /a pre_release_version=%pre_release_version%+1
    set beta_version=0
)
if %IS_BETA_RELEASE%==1 (
    set /a beta_version=%beta_version%+1
)
if %IS_HOTFIX_RELEASE%==1 (
    set /a hotfix_version=%hotfix_version%+1
    set pre_release_version=0
    set beta_version=0
)
if %IS_MINOR_RELEASE%==1 (
    set hotfix_version=0
    set pre_release_version=0
    set beta_version=0
)
if %IS_MAJOR_RELEASE%==1 (
    set minor_version=0
    set hotfix_version=0
    set pre_release_version=0
    set beta_version=0
)
call internal_build_tools/set_version.bat %major_version% %minor_version% %hotfix_version% %pre_release_version% %beta_version%

```

`internal_build_tools/reload_cmake.bat`:

```bat
if %LOG_LEVEL%==VERBOSE echo Reloading CMake
cd VS_Solution
cmake -DCMAKE_BUILD_TYPE=Release -DRC_FORCE_ALL_STATIC_LIBS= -G"Visual Studio 16 2019" .. > nul 2>&1
cd ..
```

`internal_build_tools/set_build_switches.bat`:

```bat
set param_one=%1%
if not defined param_one (
    echo Was unable to call 'set_build_switches' because no build variant was passed
    pause
    exit
)

if %LOG_LEVEL%==VERBOSE echo Setting up build switches for %~1%

cd generated_src

if %LOG_LEVEL%==VERBOSE (
    echo generated src directory contents...
    dir /b /a-d
)

Rem Case Preserving - START
if exist %enable_with_case_preserving_file% (
    if %LOG_LEVEL%==VERBOSE echo Deleting 'enable_with_case_preserving_file'
    del "%enable_with_case_preserving_file%"
)

if exist %disable_with_case_preserving_file% (
    if %LOG_LEVEL%==VERBOSE echo Deleting 'disable_with_case_preserving_file'
    del "%disable_with_case_preserving_file%"
)

if %CASE_PRESERVING% == 1 (
    if %LOG_LEVEL%==VERBOSE echo Creating 'enable_with_case_preserving_file'
    type NUL > %enable_with_case_preserving_file%
) else (
    if %LOG_LEVEL%==VERBOSE echo Creating 'disable_with_case_preserving_file'
    type NUL > %disable_with_case_preserving_file%
)
Rem Case Preserving - END

cd ..

```

`internal_build_tools/set_version.bat`:

```bat
set set_version_param_major=%1%
if not defined set_version_param_major (
    echo Was unable to call 'set_version' because no major version was passed
    pause
    exit
)

set set_version_param_minor=%2%
if not defined set_version_param_minor (
    echo Was unable to call 'set_version' because no minor version was passed
    pause
    exit
)

set set_version_param_hotfix=%3%
if not defined set_version_param_hotfix (
    echo Was unable to call 'set_version' because no hotfix version was passed
    pause
    exit
)

set set_version_param_prerelease=%4%
if not defined set_version_param_prerelease (
    echo Was unable to call 'set_version' because no pre-release version was passed
    pause
    exit
)

set set_version_param_beta=%5%
if not defined set_version_param_beta (
    echo Was unable to call 'set_version' because no beta version was passed
    pause
    exit
)

if not exist generated_src (
    echo Unable to find project directory, 'generated_src'.
    pause
    exit /b
)

if not exist generated_src\version.cache (
    echo Unable to find version cache file, 'generated_src\version.cache'.
    pause
    exit /b
)

echo Setting version to: %set_version_param_major%.%set_version_param_minor%.%set_version_param_hotfix%.%set_version_param_prerelease%.%set_version_param_beta%

Rem Caching the incremented version
set full_version_string=%set_version_param_major%.%set_version_param_minor%.%set_version_param_hotfix%.%set_version_param_prerelease%.%set_version_param_beta%
cd generated_src
del %version_cache_file%
echo %full_version_string% >> %version_cache_file%
cd ..
```

`internal_generate_build_files.bat`:

```bat
set BuildMode=%1

IF NOT DEFINED %BuildMode (
set BuildMode=Release
)

if not exist "VS_Solution\" (
	mkdir "VS_Solution"
)

cd VS_Solution
call generate_vs_solution.bat %BuildMode%
cd ..

```

`package_beta_release.bat`:

```bat
@echo off
set IS_MAJOR_RELEASE=0
set IS_MINOR_RELEASE=0
set IS_HOTFIX_RELEASE=0
set IS_PRE_RELEASE=0
set IS_BETA_RELEASE=1

call internal_build_tools/packaging_header.bat

Rem LogLevel can be VERBOSE or NORMAL
set LOG_LEVEL=NORMAL

echo Packaging %major_version%.%minor_version%.%hotfix_version% - Beta #%beta_version%

call internal_build_tools/package_all_distributions.bat

echo Done.
pause

```

`package_hotfix_release.bat`:

```bat
@echo off
set IS_MAJOR_RELEASE=0
set IS_MINOR_RELEASE=0
set IS_HOTFIX_RELEASE=1
set IS_PRE_RELEASE=0
set IS_BETA_RELEASE=0

call internal_build_tools/packaging_header.bat

Rem LogLevel can be VERBOSE or NORMAL
set LOG_LEVEL=NORMAL

echo Packaging %major_version%.%minor_version%.%hotfix_version%

call internal_build_tools/package_all_distributions.bat

echo Done.
pause

```

`package_minor_release.bat`:

```bat
@echo off
set IS_MAJOR_RELEASE=0
set IS_MINOR_RELEASE=1
set IS_HOTFIX_RELEASE=0
set IS_PRE_RELEASE=0
set IS_BETA_RELEASE=0

call internal_build_tools/packaging_header.bat

Rem LogLevel can be VERBOSE or NORMAL
set LOG_LEVEL=NORMAL

echo Packaging %major_version%.%minor_version%.%hotfix_version%

call internal_build_tools/package_all_distributions.bat

echo Done.
pause

```

`package_pre_release.bat`:

```bat
@echo off
set IS_MAJOR_RELEASE=0
set IS_MINOR_RELEASE=0
set IS_HOTFIX_RELEASE=0
set IS_PRE_RELEASE=1
set IS_BETA_RELEASE=0

call internal_build_tools/packaging_header.bat

Rem LogLevel can be VERBOSE or NORMAL
set LOG_LEVEL=NORMAL

echo Packaging %major_version%.%minor_version%.%hotfix_version% - PreRelease #%pre_release_version%

call internal_build_tools/package_all_distributions.bat

echo Done.
pause

```

`rebuild_auto.bat`:

```bat
@echo off

set BuildMode=%1
set TargetName=%2

IF NOT DEFINED %BuildMode (
set BuildMode=Release
)

IF NOT DEFINED %TargetName (
set TargetName=ue4ss
)

set IsBuildConfigValid=1

IF NOT %BuildMode% == Release (
    IF NOT %BuildMode% == Debug (
        set IsBuildConfigValid=0
        echo Build mode must be either Release or Debug, not %BuildMode%.
    )
)

if NOT %TargetName% == ue4ss (
    if NOT %TargetName% == xinput1_3 (
        set IsBuildConfigValid=0
        echo Target name must be either ue4ss or xinput1_3, not %TargetName%
    )
)

IF %IsBuildConfigValid% == 1 (
    echo Target Name: %TargetName%
    echo Build Mode: %BuildMode%

    call internal_generate_build_files.bat %BuildMode%
    MSBuild.exe /m "VS_Solution\%TargetName%.vcxproj" /property:Configuration=%BuildMode% /t:Clean,Build
) else (
    echo Could not build, the build configuration is invalid.
    pause
    exit /b
)
```

`src/GUI/Console.cpp`:

```cpp
#include <memory>
#include <ctype.h>

#include <GUI/Console.hpp>
#include <GUI/GUI.hpp>
#include <GUI/ImGuiUtility.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <UE4SSProgram.hpp>

#include <imgui_internal.h>

namespace RC::GUI
{
    // Wrapper for CalcTextSizeA.
    auto CalcTextSize(const char* text, float max_width, const char** remaining = nullptr) -> ImVec2
    {
        ImGuiContext& g = *GImGui;
        ImFont* font = g.Font;
        const float font_size = g.FontSize;
        ImVec2 text_size = font->CalcTextSizeA(font_size, max_width, -1.0f, text, nullptr, remaining);
        text_size.x = IM_FLOOR(text_size.x + 0.99999f);
        return text_size;
    }

    auto Console::GetLanguageDefinitionNone() -> const TextEditor::LanguageDefinition&
    {
        static bool inited = false;
        static TextEditor::LanguageDefinition langDef;
        if (!inited)
        {
            langDef.mName = "None";
            inited = true;
        }
        return langDef;
    }

    auto Console::GetPalette() const -> const TextEditor::Palette&
    {
        const static TextEditor::Palette p = { {
                ImGui::ColorConvertFloat4ToU32(ImVec4{0.800f, 0.800f, 0.800f, 1.0f}),	// Default
                0xffd69c56,	// Keyword
                0xff00ff00,	// Number
                0xff7070e0,	// String
                0xff70a0e0, // Char literal
                0xffffffff, // Punctuation
                0xff408080,	// Preprocessor
                0xffaaaaaa, // Identifier
                0xff9bc64d, // Known identifier
                0xffc040a0, // Preproc identifier
                0xff206020, // Comment (single line)
                0xff406020, // Comment (multi line)
                ImGui::ColorConvertFloat4ToU32(ImVec4{0.156f, 0.156f, 0.156f, 1.0f}), // Background
                0xffe0e0e0, // Cursor
                0x80a06020, // Selection
                0x800020ff, // ErrorMarker
                0x40f08000, // Breakpoint
                0xff707000, // Line number
                0x40000000, // Current line fill
                0x40808080, // Current line fill (inactive)
                0x40a0a0a0, // Current line edge
        } };
        return p;
    }

    auto Console::render() -> void
    {
        /*
        auto max_line_width = m_current_console_output_width - 10.0f;
        std::string console_buffer{};
        {
            std::lock_guard<std::mutex> guard(m_lines_mutex);
            for (const auto& line : m_lines)
            {
                if (!m_filter.PassFilter(line.c_str()))
                {
                    continue;
                }
                const char* remaining{};
                auto line_width = CalcTextSize(line.c_str(), m_current_console_output_width, &remaining).x;
                auto max_string_length = remaining - line.c_str();
                if (max_string_length > 0 && line_width > max_line_width)
                {
                    auto num_lines = static_cast<int>(std::ceil(line.length() / max_string_length)) + 1;
                    int last_line{};
                    for (int i = 0; num_lines > 0 && i < num_lines; ++i)
                    {
                        console_buffer.append(line.substr(last_line, max_string_length));
                        console_buffer.append("\n");
                        last_line = last_line + max_string_length;
                    }
                }
                else
                {
                    console_buffer.append(line);
                    console_buffer.append("\n");
                }
            }
        }

        const float footer_height_to_reserve = (ImGui::GetStyle().ItemSpacing.y * 10.0f) + ImGui::GetFrameHeightWithSpacing();
        ImGui_InputTextMultiline_WithAutoScroll("##consolebuffer", console_buffer.data(), console_buffer.size() + 1, {-10, -footer_height_to_reserve}, ImGuiInputTextFlags_ReadOnly, nullptr, nullptr, &m_previous_max_scroll_y);
        m_current_console_output_width = ImGui::CalcItemWidth();

        ImGui::Separator();

        ImGui::BeginDisabled(true);
        bool reclaim_focus{};
        ImGuiInputTextFlags input_text_flags = ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory;
        auto text_edit_callback_wrapper = [](ImGuiInputTextCallbackData* data) -> int {
            Console* console = static_cast<Console*>(data->UserData);
            Output::send(STR("text_edit_callback_wrapper\n"));
            //return console->text_edit_callback(data);
            return 0;
        };
        ImGui::PushItemWidth(-12.0f);
        if (ImGui::InputText("##console_input_buffer", m_input_buffer, IM_ARRAYSIZE(m_input_buffer), input_text_flags, text_edit_callback_wrapper, this))
        {
            Output::send(STR("ConsoleInput\n"));
            reclaim_focus = true;
        }
        ImGui::PopItemWidth();

        ImGui::SetItemDefaultFocus();
        if (reclaim_focus)
        {
            ImGui::SetKeyboardFocusHere(-1);
        }
        ImGui::EndDisabled();
        //*/

        /**/
        const float footer_height_to_reserve = (ImGui::GetStyle().ItemSpacing.y * 10.0f) + ImGui::GetFrameHeightWithSpacing();
        {
            std::lock_guard<std::mutex> guard(m_lines_mutex);
            m_text_editor.Render("TextEditor", {-10, -footer_height_to_reserve});
        }
        ImGui_AutoScroll("TextEditor", &m_previous_max_scroll_y);
        //*/
    }

    auto Console::render_search_box() -> void
    {
        m_filter.Draw("Search log", 200);
    }


    static auto LogLevel_to_ImColor(LogLevel::LogLevel log_level) -> std::pair<ImColor, ImColor>
    {
        switch (log_level)
        {
            case LogLevel::Default:
                return {g_imgui_text_editor_default_bg_color, g_imgui_text_editor_default_text_color};
            case LogLevel::Normal:
                return {g_imgui_text_editor_normal_bg_color, g_imgui_text_editor_normal_text_color};
            case LogLevel::Verbose:
                return {g_imgui_text_editor_verbose_bg_color, g_imgui_text_editor_verbose_text_color};
            case LogLevel::Warning:
                return {g_imgui_text_editor_warning_bg_color, g_imgui_text_editor_warning_text_color};
            case LogLevel::Error:
                return {g_imgui_text_editor_error_bg_color, g_imgui_text_editor_error_text_color};
        }

        throw std::runtime_error{"[LogLevel_to_ImColor] Unhandled log_level"};
    }

    auto Console::add_line(const std::string& line, LogLevel::LogLevel log_level) -> void
    {
        std::lock_guard<std::mutex> guard(m_lines_mutex);
        if (m_text_editor.GetTotalLines() >= m_maximum_num_lines) { m_text_editor.ClearLines(); }
        if (m_lines.size() >= m_maximum_num_lines) { m_lines.clear(); }
        if (log_level != LogLevel::Default && log_level != LogLevel::Normal)
        {
            m_text_editor.GetLineColorMarkers().emplace(m_text_editor.GetTotalLines() + 1, LogLevel_to_ImColor(log_level));
        }
        m_lines.emplace_back(line);
        m_text_editor.AddTextLine(line);
    }

    auto Console::add_line(const std::wstring& line, LogLevel::LogLevel log_level) -> void
    {
        auto ansi_string = to_string(line);
        std::lock_guard<std::mutex> guard(m_lines_mutex);
        if (m_text_editor.GetTotalLines() >= m_maximum_num_lines) { m_text_editor.ClearLines(); }
        if (m_lines.size() >= m_maximum_num_lines) { m_lines.clear(); }
        if (log_level != LogLevel::Default && log_level != LogLevel::Normal)
        {
            m_text_editor.GetLineColorMarkers().emplace(m_text_editor.GetTotalLines() + 1, LogLevel_to_ImColor(log_level));
        }
        m_lines.emplace_back(ansi_string);
        m_text_editor.AddTextLine(ansi_string);
    }
}

```

`src/GUI/ConsoleOutputDevice.cpp`:

```cpp
#include <chrono>
#include <locale>

#include <GUI/ConsoleOutputDevice.hpp>
#include <UE4SSProgram.hpp>

namespace RC::Output
{
    auto ConsoleDevice::has_optional_arg() const -> bool
    {
        return true;
    }

    auto ConsoleDevice::receive(File::StringViewType fmt) const -> void
    {
        receive_with_optional_arg(fmt, Color::NoColor);
    }

    auto ConsoleDevice::receive_with_optional_arg(File::StringViewType fmt, [[maybe_unused]]int32_t optional_arg) const -> void
    {
#if ENABLE_OUTPUT_DEVICE_DEBUG_MODE
        printf_s("ConsoleDevice received: %S", m_formatter(fmt).c_str());
#else
        auto fmt_copy = File::StringType{fmt};
        if (fmt_copy.ends_with(STR('\n')))
        {
            fmt_copy.pop_back();
        }
        auto log_level = static_cast<LogLevel::LogLevel>(optional_arg);
        UE4SSProgram::get_program().get_debugging_ui().get_console().add_line(m_formatter(fmt_copy), log_level);
#endif
    }
}

```

`src/GUI/DX11.cpp`:

```cpp
#include <GUI/DX11.hpp>

#include <imgui.h>
#include <backends/imgui_impl_dx11.h>
#include <d3d11.h>

namespace RC::GUI
{
    static ID3D11Device* g_pd3dDevice = NULL;
    static ID3D11DeviceContext* g_pd3dDeviceContext = NULL;
    static IDXGISwapChain* g_pSwapChain = NULL;
    static ID3D11RenderTargetView* g_mainRenderTargetView = NULL;

    bool CreateDeviceD3D(HWND hWnd);
    void CleanupDeviceD3D();
    void CreateRenderTarget();
    void CleanupRenderTarget();

    auto Backend_DX11::init() -> void
    {
        ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);
    }

    auto Backend_DX11::imgui_backend_newframe() -> void
    {
        ImGui_ImplDX11_NewFrame();
    }

    auto Backend_DX11::render(const float clear_color_with_alpha[4]) -> void
    {
        g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
        g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, clear_color_with_alpha);
        ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
        g_pSwapChain->Present(1, 0);
    }

    auto Backend_DX11::shutdown() -> void
    {
        ImGui_ImplDX11_Shutdown();
    }

    auto Backend_DX11::cleanup() -> void
    {
        CleanupDeviceD3D();
    }

    auto Backend_DX11::create_device() -> bool
    {
        return CreateDeviceD3D(static_cast<HWND>(m_os_backend->get_window_handle()));
    }

    auto Backend_DX11::cleanup_device() -> void
    {
        CleanupDeviceD3D();
    }

    auto Backend_DX11::handle_window_resize(int64_t param_1, int64_t param_2) -> void
    {
        if (g_pd3dDevice != NULL && param_1 != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(param_2), (UINT)HIWORD(param_2), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
    }

    auto Backend_DX11::on_os_backend_set() -> void
    {
    }

    // Helper functions

    bool CreateDeviceD3D(HWND hWnd)
    {
        // Setup swap chain
        DXGI_SWAP_CHAIN_DESC sd;
        ZeroMemory(&sd, sizeof(sd));
        sd.BufferCount = 2;
        sd.BufferDesc.Width = 0;
        sd.BufferDesc.Height = 0;
        sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        sd.BufferDesc.RefreshRate.Numerator = 60;
        sd.BufferDesc.RefreshRate.Denominator = 1;
        sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
        sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
        sd.OutputWindow = hWnd;
        sd.SampleDesc.Count = 1;
        sd.SampleDesc.Quality = 0;
        sd.Windowed = TRUE;
        sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

        UINT createDeviceFlags = 0;
        //createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
        D3D_FEATURE_LEVEL featureLevel;
        const D3D_FEATURE_LEVEL featureLevelArray[2] = {D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0,};
        if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext) != S_OK)
        {
            return false;
        }

        CreateRenderTarget();
        return true;
    }

    void CleanupDeviceD3D()
    {
        CleanupRenderTarget();
        if (g_pSwapChain)
        {
            g_pSwapChain->Release();
            g_pSwapChain = NULL;
        }
        if (g_pd3dDeviceContext)
        {
            g_pd3dDeviceContext->Release();
            g_pd3dDeviceContext = NULL;
        }
        if (g_pd3dDevice)
        {
            g_pd3dDevice->Release();
            g_pd3dDevice = NULL;
        }
    }

    void CreateRenderTarget()
    {
        ID3D11Texture2D* pBackBuffer;
        g_pSwapChain->GetBuffer(0, IID_PPV_ARGS(&pBackBuffer));
        g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView);
        pBackBuffer->Release();
    }

    void CleanupRenderTarget()
    {
        if (g_mainRenderTargetView)
        {
            g_mainRenderTargetView->Release();
            g_mainRenderTargetView = NULL;
        }
    }
}

```

`src/GUI/Dumpers.cpp`:

```cpp
#include <format>
#include <string>
#include <utility>

#include <GUI/Dumpers.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <File/Macros.hpp>
#include <File/File.hpp>
#include <JSON/JSON.hpp>
#ifdef TEXT
#undef TEXT
#endif
#include <UE4SSProgram.hpp>
#include <Unreal/UnrealInitializer.hpp>
#include <Unreal/Searcher/ObjectSearcher.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <imgui.h>

namespace RC::GUI::Dumpers
{
    using namespace ::RC::Unreal;

    // TODO: Move these structs (and the enum) to a proper place in the Unreal module.
    //       They need to be controlled by the engine version select or before 2.0 releases.

    // In KH3, there's an extra float either at the end of FMeshUVChannelInfo or at the end of FStaticMaterial, I can't tell which one.
    enum { MAX_TEXCOORDS = 4, MAX_STATIC_TEXCOORDS = 8 };
    struct FMeshUVChannelInfo
    {
        bool bInitialized;

        /** Whether this values was set manually or is auto generated. */
        bool bOverrideDensities;

        /**
         * The UV density in the mesh, before any transform scaling, in world unit per UV.
         * This value represents the length taken to cover a full UV unit.
         */
        float LocalUVDensities[MAX_TEXCOORDS];
    };

    // This struct changed in 4.20, so we must better support this.
    // The struct below is based on <4.20, change the uncomment 'ImportedMaterialSlowName' and recompile to make it work for 4.20+.
    // Probably gonna avoid fixing this until we do engine version selection at compile-time.
    struct FStaticMaterial
    {
        using UMaterialInterface = ::RC::Unreal::UObject;
        UMaterialInterface* MaterialInterface;

        /*This name should be use by the gameplay to avoid error if the skeletal mesh Materials array topology change*/
        FName MaterialSlotName;

        /*This name should be use when we re-import a skeletal mesh so we can order the Materials array like it should be*/
        FName ImportedMaterialSlotName;

        /** Data used for texture streaming relative to each UV channels. */
        FMeshUVChannelInfo UVChannelData;
    };

	auto generate_root_component_csv(UObject* root_component) -> StringType
    {
        StringType root_actor_buffer{};

        static auto location_property = root_component->GetPropertyByNameInChain(STR("RelativeLocation"));
        static auto rotation_property = root_component->GetPropertyByNameInChain(STR("RelativeRotation"));
        static auto scale_property = root_component->GetPropertyByNameInChain(STR("RelativeScale3D"));

        auto location = root_component->GetValuePtrByPropertyNameInChain<FVector>(STR("RelativeLocation"));
        FString location_string{};
        location_property->ExportTextItem(location_string, location, nullptr, nullptr, 0);
        root_actor_buffer.append(std::format(STR("\"{}\","), location_string.GetCharArray()));

        auto rotation = root_component->GetValuePtrByPropertyNameInChain<FRotator>(STR("RelativeRotation"));
        FString rotation_string{};
        rotation_property->ExportTextItem(rotation_string, rotation, nullptr, nullptr, 0);
        root_actor_buffer.append(std::format(STR("\"{}\","), rotation_string.GetCharArray()));

        auto scale = root_component->GetValuePtrByPropertyNameInChain<FVector>(STR("RelativeScale3D"));
        FString scale_string{};
        scale_property->ExportTextItem(scale_string, scale, nullptr, nullptr, 0);
        root_actor_buffer.append(std::format(STR("\"{}\","), scale_string.GetCharArray()));
        
        return root_actor_buffer;
    }

    static auto generate_actors_csv_file(UClass* dump_actor_class) -> StringType
    {
        StringType file_buffer{};

        file_buffer.append(STR("---,Actor,Location,Rotation,Scale,Mesh,Materials\n"));

        size_t actor_count{};
        FindObjectSearcher(dump_actor_class, AnySuperStruct::StaticClass()).ForEach([&](UObject* object) {
            if (object->HasAnyFlags(RF_ClassDefaultObject)) { return LoopAction::Continue; }

            auto actor = static_cast<AActor*>(object);

            // TODO: figure out if this catches all root components (it doesn't appear to do so)
            auto root_component = actor->GetValuePtrByPropertyNameInChain<UObject*>(STR("RootComponent"));
            if (!root_component || !*root_component) { return LoopAction::Continue; }

            StringType actor_buffer{};

            actor_buffer.append(std::format(STR("Row_{},"), actor_count));

            static auto game_mode_base = UObjectGlobals::FindFirstOf(STR("GameModeBase"));
            static auto class_property = game_mode_base->GetPropertyByNameInChain(STR("GameStateClass"));
            FString actor_class_string{};
            class_property->ExportTextItem(actor_class_string, &actor->GetClassPrivate(), nullptr, nullptr, 0);
            actor_buffer.append(std::format(STR("{},"), actor_class_string.GetCharArray()));

            // TODO: build system to handle other types of components - possibly including a way to specify which components to dump and which properties are important via a config file
            actor_buffer.append(generate_root_component_csv(*root_component));
                
            static auto static_mesh_component_class = UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, STR("/Script/Engine.StaticMeshComponent"));
            auto static_mesh_components = actor->K2_GetComponentsByClass(static_mesh_component_class);

            static_mesh_components.ForEach([&](UObject** static_mesh_component_ptr, size_t static_mesh_component_index) {
                if (!static_mesh_component_ptr || !*static_mesh_component_ptr) { return LoopAction::Continue; }
                auto static_mesh_component = *static_mesh_component_ptr;

                auto mesh = *static_mesh_component->GetValuePtrByPropertyNameInChain<UObject*>(STR("StaticMesh"));
                if (!mesh)
                {
                    Output::send<LogLevel::Warning>(STR("SKIPPING COMPONENT! StaticMeshComponent '{}' has no mesh."), static_mesh_component->GetOuterPrivate()->GetName());
                    return LoopAction::Continue;
                }

                static auto mesh_property = static_mesh_component->GetPropertyByNameInChain(STR("StaticMesh"));
                FString mesh_string{};
                mesh_property->ExportTextItem(mesh_string, &mesh, nullptr, nullptr, 0);
                actor_buffer.append(std::format(STR("\"{}\","), mesh_string.GetCharArray()));

                auto materials = mesh->GetValuePtrByPropertyName<TArray<FStaticMaterial>>(STR("StaticMaterials"));
                actor_buffer.append(STR("\"("));
                materials->ForEach([&](FStaticMaterial* material, size_t material_index) {
                    if (material->MaterialInterface)
                    {
                        auto material_full_name = material->MaterialInterface->GetOuterPrivate()->GetFullName();
                        auto material_type_space_location = material_full_name.find(STR(" "));
                        if (material_type_space_location == material_full_name.npos)
                        {
                            Output::send<LogLevel::Warning>(STR("SKIPPING MATERIAL! Was unable to find space in full material name in component: '{}'."), material_full_name);
                            return LoopAction::Continue;
                        }
                        auto material_typeless_name = StringViewType{material_full_name.begin() + material_type_space_location + 1,
                                material_full_name.end()};

                        actor_buffer.append(std::format(STR("{}'"), material->MaterialInterface->GetClassPrivate()->GetName()));
                        actor_buffer.append(std::format(STR("\"\"{}"), material_typeless_name));
                        actor_buffer.append(STR("\"\"'"));
                        if (material_index + 1 < materials->Num())
                        {
                            actor_buffer.append(STR(","));
                        }

                    }
                    return LoopAction::Continue;
                });
                actor_buffer.append(STR(")\""));

                return LoopAction::Continue;
            });

            actor_buffer.append(STR("\n"));
            file_buffer.append(actor_buffer);

            ++actor_count;
            return LoopAction::Continue;
        });


        return file_buffer;
    }

    static auto generate_actors_json_file(UClass* class_to_dump) -> StringType
    {
        auto global_json_array = JSON::Array{};

        size_t actor_count{};
        FindObjectSearcher(class_to_dump, AnySuperStruct::StaticClass()).ForEach([&](UObject* object) {
            if (object->HasAnyFlags(RF_ClassDefaultObject)) { return LoopAction::Continue; }

            auto actor = static_cast<AActor*>(object);

            // TODO: figure out if this catches all root components (it doesn't appear to do so)
            auto root_component = actor->GetValuePtrByPropertyNameInChain<UObject*>(STR("RootComponent"));
            if (!root_component || !*root_component) { return LoopAction::Continue; }

            auto& actor_json_object = global_json_array.new_object();

            actor_json_object.new_string(STR("Name"), std::format(STR("Row_{}"), actor_count));

            static auto game_mode_base = UObjectGlobals::FindFirstOf(STR("GameModeBase"));
            static auto class_property = game_mode_base->GetPropertyByNameInChain(STR("GameStateClass"));
            FString actor_class_string{};
            class_property->ExportTextItem(actor_class_string, &actor->GetClassPrivate(), nullptr, nullptr, 0);
            actor_json_object.new_string(STR("Actor"), std::format(STR("{}"), StringViewType{actor_class_string.GetCharArray()}));

            auto& root_component_json_object = actor_json_object.new_object(STR("RootComponent"));

            FString root_component_class_string{};
            class_property->ExportTextItem(root_component_class_string, &(*root_component)->GetClassPrivate(), nullptr, nullptr, 0);
            root_component_json_object.new_string(STR("SceneComponentClass"), std::format(STR("{}"), StringViewType{root_component_class_string.GetCharArray()}));

            auto& location_json_object = root_component_json_object.new_object(STR("Location"));
            auto location = (*root_component)->GetValuePtrByPropertyNameInChain<FVector>(STR("RelativeLocation"));
            location_json_object.new_number(STR("X"), location->X());
            location_json_object.new_number(STR("Y"), location->Y());
            location_json_object.new_number(STR("Z"), location->Z());

            auto& rotation_json_object = root_component_json_object.new_object(STR("Rotation"));
            auto rotation = (*root_component)->GetValuePtrByPropertyNameInChain<FRotator>(STR("RelativeRotation"));
            rotation_json_object.new_number(STR("Pitch"), rotation->Pitch);
            rotation_json_object.new_number(STR("Yaw"), rotation->Yaw);
            rotation_json_object.new_number(STR("Roll"), rotation->Roll);

            auto& scale_json_object = root_component_json_object.new_object(STR("Scale"));
            auto scale = (*root_component)->GetValuePtrByPropertyNameInChain<FVector>(STR("RelativeScale3D"));
            scale_json_object.new_number(STR("X"), scale->X());
            scale_json_object.new_number(STR("Y"), scale->Y());
            scale_json_object.new_number(STR("Z"), scale->Z());

            ++actor_count;
            return LoopAction::Continue;
        });

        int32_t indent_level{};
        return global_json_array.serialize(JSON::ShouldFormat::Yes, &indent_level);
    }

    auto render() -> void
    {
        if (!UnrealInitializer::StaticStorage::bIsInitialized) { return; }

        if (ImGui::Button("Dump all static actor meshes to file"))
        {
            static auto dump_actor_class = UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, STR("/Script/Engine.StaticMeshActor"));

            auto file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + STR("\\ue4ss_static_mesh_data.csv"), File::OpenFor::Writing, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
            std::wstring file_buffer{};
            file_buffer.append(generate_actors_csv_file(dump_actor_class));
            file.write_string_to_file(file_buffer);

            /*auto file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + STR("\\ue4ss_static_mesh_data.json"), File::OpenFor::Writing, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
            file.write_string_to_file(generate_actors_json_file(dump_actor_class));*/
        }
        
        if (ImGui::Button("Dump all actors to file"))
        {
            auto file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + STR("\\ue4ss_actor_data.csv"), File::OpenFor::Writing, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
            std::wstring file_buffer{};
            file_buffer.append(generate_actors_csv_file(AActor::StaticClass()));
            file.write_string_to_file(file_buffer);

            /*auto file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + STR("\\ue4ss_actor_data.json"), File::OpenFor::Writing, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
            file.write_string_to_file(generate_actors_json_file(AActor::StaticClass()));*/
        }

        /*ImGui::SameLine();*/

        /*if (ImGui::Button("Test #1"))
        {
            auto func = UObjectGlobals::StaticFindObject<UFunction*>(nullptr, nullptr, STR("/Script/Engine.KismetSystemLibrary:LoadAsset"));
            func->ForEachProperty([](FProperty* param) {
                Output::send<LogLevel::Verbose>(STR("{}\n"), param->GetName());
                if (auto as_struct_prop = CastField<FStructProperty>(param); as_struct_prop)
                {
                    Output::send<LogLevel::Verbose>(STR("Param is StructProperty: {}\n"), as_struct_prop->GetStruct()->GetFullName());
                    if (as_struct_prop->GetStruct()->IsChildOf(UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, STR("/Script/Engine.LatentActionInfo"))))
                    {
                        Output::send<LogLevel::Verbose>(STR("StructProperty is LatentActionInfo\n"));
                    }
                }
                return LoopAction::Continue;
            });
        }*/
    }
}

```

`src/GUI/GUI.cpp`:

```cpp
#include <GUI/GUI.hpp>

#include <ExceptionHandling.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <GUI/DX11.hpp>
#include <GUI/Windows.hpp>
#include <GUI/Dumpers.hpp>

#include <Unreal/UnrealInitializer.hpp>
#include <UE4SSProgram.hpp>
#ifdef TEXT
#undef TEXT
#endif

#include <imgui.h>

namespace RC::GUI
{
    ImColor g_imgui_bg_color{40, 40, 40, 255};
    ImColor g_imgui_bg_hover_color = ImColor{60, 60, 60, 255};
    ImColor g_imgui_bg_active_color = ImColor{50, 50, 50, 255};
    ImColor g_imgui_bg_header_color{50, 50, 50, 255};
    ImColor g_imgui_bg_header_hover_color = ImColor{70, 70, 70, 255};
    ImColor g_imgui_bg_header_active_color = ImColor{60, 60, 60, 255};
    ImColor g_imgui_text_color = ImColor{204, 204, 204, 255};
    ImColor g_imgui_text_inactive_color = ImColor{204, 204, 204, 200};
    ImColor g_imgui_text_editor_default_bg_color = g_imgui_bg_color;
    ImColor g_imgui_text_editor_default_text_color = g_imgui_text_color;
    ImColor g_imgui_text_editor_normal_bg_color = g_imgui_bg_color;
    ImColor g_imgui_text_editor_normal_text_color = g_imgui_text_color;
    ImColor g_imgui_text_editor_verbose_bg_color = ImColor{0, 55, 125, 255};
    ImColor g_imgui_text_editor_verbose_text_color = ImColor{255, 255, 255, 255};
    ImColor g_imgui_text_editor_warning_bg_color = ImColor{120, 60, 0, 250};
    ImColor g_imgui_text_editor_warning_text_color = ImColor{255, 255, 255, 255};
    ImColor g_imgui_text_editor_error_bg_color = ImColor{148, 36, 20, 255};
    ImColor g_imgui_text_editor_error_text_color = ImColor{255, 255, 255, 255};
    ImColor g_imgui_text_live_view_unreflected_data_color = ImColor{235, 128, 52, 255};

    std::vector<DebuggingGUI::EndOfFrameCallback> DebuggingGUI::s_end_of_frame_callbacks{};

    auto DebuggingGUI::on_update() -> void
    {
        static bool show_window = true;
        static bool is_console_open = true;

        if (show_window)
        {
            ImGui::SetNextWindowPos({0, 0});
            auto current_window_rect = m_os_backend->get_window_rect();
            ImGui::SetNextWindowSize({static_cast<float>(current_window_rect.right - current_window_rect.left), static_cast<float>(current_window_rect.bottom - current_window_rect.top)});
            ImGui::Begin("MainWindow", &show_window, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

            if (ImGui::BeginTabBar("##MainTabBar", ImGuiTabBarFlags_None))
            {
                if (ImGui::BeginTabItem("Console"))
                {
                    get_console().render_search_box();

                    ImGui::SameLine();

                    auto event_thread_busy = m_event_thread_busy || !UE4SSProgram::get_program().can_process_events();

                    if (event_thread_busy) { ImGui::BeginDisabled(true); }
                    if (ImGui::Button("Dump Objects & Properties"))
                    {
                        m_event_thread_busy = true;
                        UE4SSProgram::get_program().queue_event([](void* data) {
                            UE4SSProgram::dump_all_objects_and_properties(UE4SSProgram::get_program().get_object_dumper_output_directory() + STR("\\") + UE4SSProgram::m_object_dumper_file_name);
                            static_cast<GUI::DebuggingGUI*>(data)->m_event_thread_busy = false;
                        }, this);
                    }
                    if (event_thread_busy) { ImGui::EndDisabled(); }

                    if (event_thread_busy) { ImGui::BeginDisabled(true); }
                    ImGui::SameLine();
                    if (ImGui::Button("Restart All Mods"))
                    {
                        m_event_thread_busy = true;
                        UE4SSProgram::get_program().queue_event([](void* data) {
                            UE4SSProgram::get_program().reinstall_mods();
                            static_cast<GUI::DebuggingGUI*>(data)->m_event_thread_busy = false;
                        }, this);
                    }
                    if (event_thread_busy) { ImGui::EndDisabled(); }

                    get_console().render();

                    ImGui::EndTabItem();
                }

                bool listeners_are_required{};
                bool should_unset_listeners{};

                auto is_unreal_initialized = Unreal::UnrealInitializer::StaticStorage::bIsInitialized;
                if (!is_unreal_initialized) { ImGui::BeginDisabled(true); }
                if (ImGui::BeginTabItem("Live View"))
                {
                    listeners_are_required = true;
                    m_live_view.set_listeners_are_required(true);
                    m_live_view.set_listeners();
                    m_live_view.render();
                    ImGui::EndTabItem();
                }
                else
                {
                    should_unset_listeners = true;
                }

                if (ImGui::BeginTabItem("Watches"))
                {
                    listeners_are_required = true;
                    m_live_view.set_listeners_are_required(true);
                    m_live_view.render_watches();
                    ImGui::EndTabItem();
                }
                else
                {
                    should_unset_listeners = true;
                }

                if (should_unset_listeners && !listeners_are_required)
                {
                    m_live_view.unset_listeners();
                }

                if (ImGui::BeginTabItem("Dumpers"))
                {
                    Dumpers::render();
                    ImGui::EndTabItem();
                }
                ImGui::EndTabBar();
                if (!is_unreal_initialized) { ImGui::EndDisabled(); }
            }

            ImGui::End();

            m_live_view.process_watches();
        }
    }

    static auto gui_setup_style() -> void
    {
        ImGui::StyleColorsDark();
        //ImGui::GetIO().FontGlobalScale = 2.0f;
        // prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
        //ImGui::GetStyle().ScaleAllSizes(2.0f);
        //ImGui::GetIO().DisplayFramebufferScale.x = 2;
        //ImGui::GetIO().DisplayFramebufferScale.y = 2;
        //ImGui::GetIO().Fonts->Build();
    }

    auto DebuggingGUI::main_loop_internal() -> void
    {
        m_is_open = true;

        auto& style = ImGui::GetStyle();
        //style.Colors[ImGuiCol_FrameBg] = ImVec4{0.118f, 0.118f, 0.118f, 1.0f};
        //style.Colors[ImGuiCol_Tab] = ImVec4{0.118f, 0.118f, 0.118f, 1.0f};
        //style.Colors[ImGuiCol_TabHovered] = ImVec4{0.118f, 0.118f, 0.118f, 1.0f};
        //style.Colors[ImGuiCol_TabActive] = ImVec4{0.118f, 0.118f, 0.118f, 1.0f};
        //style.Colors[ImGuiCol_Text] = ImVec4{0.800f, 0.800f, 0.800f, 1.0f};
        style.Colors[ImGuiCol_FrameBg] = g_imgui_bg_color;
        style.Colors[ImGuiCol_Tab] = g_imgui_bg_color;
        style.Colors[ImGuiCol_TabHovered] = g_imgui_bg_hover_color;
        style.Colors[ImGuiCol_TabActive] = g_imgui_bg_active_color;
        style.Colors[ImGuiCol_Header] = g_imgui_bg_header_color;
        style.Colors[ImGuiCol_HeaderHovered] = g_imgui_bg_header_hover_color;
        style.Colors[ImGuiCol_HeaderActive] = g_imgui_bg_header_active_color;
        style.Colors[ImGuiCol_Text] = g_imgui_text_color;

        ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);

        while (!m_exit_requested)
        {
            m_os_backend->exec_message_loop(&m_exit_requested);

            if (m_exit_requested)
            {
                break;
            }
            if (m_thread_stop_token.stop_requested())
            {
                break;
            }

            m_gfx_backend->imgui_backend_newframe();
            m_os_backend->imgui_backend_newframe();
            ImGui::NewFrame();

            try
            {
                on_update();
            }
            catch (std::exception& e)
            {
                if (!Output::has_internal_error())
                {
                    Output::send<LogLevel::Error>(STR("Error: {}\n"), to_wstring(e.what()));
                }
                else
                {
                    printf_s("Internal Error: %s\n", e.what());
                }

                // You're not allowed to throw exceptions directly inside a frame!
                // Use GUI::TRY to move exceptions to the end of the frame.
                abort();
            }

            ImGui::Render();

            const float clear_color_with_alpha[4] = {clear_color.x * clear_color.w,
                    clear_color.y * clear_color.w,
                    clear_color.z * clear_color.w,
                    clear_color.w};
            m_gfx_backend->render(clear_color_with_alpha);


            s_end_of_frame_callbacks.erase(std::remove_if(s_end_of_frame_callbacks.begin(), s_end_of_frame_callbacks.end(), [&](EndOfFrameCallback& callback) -> bool {
                RC::TRY([&] {
                    callback();
                });
                return true;
            }), s_end_of_frame_callbacks.end());
        }

        m_is_open = false;
        m_exit_requested = false;
    }

    auto DebuggingGUI::execute_at_end_of_frame(EndOfFrameCallback callback) -> void
    {
        s_end_of_frame_callbacks.emplace_back(callback);
    }

    auto DebuggingGUI::setup(std::stop_token&& stop_token) -> void
    {
        m_thread_stop_token = stop_token;

        m_live_view.initialize();

        m_os_backend->create_window();

        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        ImGuiIO& io = ImGui::GetIO();
        (void)io;

        gui_setup_style();

        m_os_backend->init();
        m_gfx_backend->init();

        main_loop_internal();

        m_gfx_backend->shutdown();
        m_os_backend->shutdown();
        ImGui::DestroyContext();

        m_gfx_backend->cleanup();
        m_os_backend->cleanup();
    }

    DebuggingGUI::DebuggingGUI(GfxBackend selected_gfx_backend, OSBackend selected_os_backend)
    {
        switch (selected_gfx_backend)
        {
            case GfxBackend::DX11:
                m_gfx_backend = std::make_unique<Backend_DX11>();
                break;
        }

        switch (selected_os_backend)
        {
            case OSBackend::Windows:
                m_os_backend = std::make_unique<Backend_Windows>();
                break;
        }

        m_gfx_backend->set_os_backend(m_os_backend.get());
        m_os_backend->set_gfx_backend(m_gfx_backend.get());
        m_gfx_backend->on_os_backend_set();
        m_os_backend->on_gfx_backend_set();
    }

    DebuggingGUI::~DebuggingGUI()
    {
        UE4SSProgram::get_program().stop_render_thread();
    }

    auto gui_thread(std::stop_token stop_token, DebuggingGUI* debugging_ui) -> void
    {
        if (!debugging_ui)
        {
            Output::send<LogLevel::Error>(STR("Could not start GUI render thread because 'debugging_ui' was nullptr."));
            return;
        }
        debugging_ui->setup(std::move(stop_token));
    }
}

```

`src/GUI/ImGuiUtility.cpp`:

```cpp
#include <stdexcept>

#include <GUI/ImGuiUtility.hpp>
#undef TEXT
#include <UE4SSProgram.hpp>
#include <imgui.h>
#define IMGUI_DEFINE_MATH_OPERATORS
#include <imgui_internal.h>

namespace RC::GUI
{
    auto ImGui_AutoScroll(const char* label, float* previous_max_scroll_y) -> void
    {
        // NOTE: This function makes use of 'imgui_internal.h'.
        //       As a result, this function is prone to break if you update Imgui.
        ImGuiContext& g = *GImGui;
        const char* child_window_name = NULL;
        ImFormatStringToTempBuffer(&child_window_name, NULL, "%s/%s_%08X", g.CurrentWindow->Name, label, ImGui::GetID(label));
        ImGuiWindow* child_window = ImGui::FindWindowByName(child_window_name);
        if (child_window)
        {
            if (child_window->ScrollMax.y > *previous_max_scroll_y)
            {
                ImGui::SetScrollY(child_window, child_window->ScrollMax.y);
            }
            *previous_max_scroll_y = child_window->ScrollMax.y;
        }
    }

    auto ImGui_InputTextMultiline_WithAutoScroll(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, float* previous_max_scroll_y)
    {
        if (!previous_max_scroll_y) { throw std::runtime_error{"Cannot call 'ImGui_InputTextMultiline_WithAutoScroll' with parameter 'previous_max_scroll_y' == nullptr"}; }

        ImGui::InputTextMultiline(label, buf, buf_size, size, flags, callback, user_data);
        ImGui_AutoScroll(label, previous_max_scroll_y);
    }

    // https://github.com/ocornut/imgui/issues/319#issuecomment-345795629
    auto ImGui_Splitter(bool split_vertically, float thickness, float* size1, float* size2, float min_size1, float min_size2, float splitter_long_axis_size) -> bool
    {
        using namespace ImGui;
        ImGuiContext& g = *GImGui;
        ImGuiWindow* window = g.CurrentWindow;
        ImGuiID id = window->GetID("##Splitter");
        ImRect bb;
        bb.Min = window->DC.CursorPos + (split_vertically ? ImVec2(*size1, 0.0f) : ImVec2(0.0f, *size1));
        bb.Max = bb.Min + CalcItemSize(split_vertically ? ImVec2(thickness, splitter_long_axis_size) : ImVec2(splitter_long_axis_size, thickness), 0.0f, 0.0f);
        return SplitterBehavior(bb, id, split_vertically ? ImGuiAxis_X : ImGuiAxis_Y, size1, size2, min_size1, min_size2, 0.0f);
    }

    static auto dump_json_object_pair(const JSON::TypedKeyValuePair<JSON::Object> element) -> void;
    static auto dump_json_array_pair(const JSON::TypedKeyValuePair<JSON::Array> element) -> void;
    static auto dump_json_string_pair(const JSON::TypedKeyValuePair<JSON::String> element) -> void;
    static auto dump_json_integer_pair(const JSON::TypedKeyValuePair<JSON::Number> element) -> void;
    static auto dump_json_object_value(const JSON::Object& element) -> void;
    static auto dump_json_array_value(const JSON::Array& element) -> void;
    static auto dump_json_string_value(const JSON::String& element) -> void;
    static auto dump_json_integer_value(const JSON::Number& element) -> void;

    static int indent_level{};
    static auto indent() -> std::wstring
    {
        std::wstring indents{};
        for (int i = 0; i < indent_level; ++i)
        {
            indents.append(STR("    "));
        }
        return indents;
    }

    static auto dump_element(const JSON::Value& element) -> void
    {
        if (element.is<JSON::Object>())
        {
            dump_json_object_value(*element.as<JSON::Object>());
        }
        else if (element.is<JSON::Array>())
        {
            dump_json_array_value(*element.as<JSON::Array>());
        }
        else if (element.is<JSON::String>())
        {
            dump_json_string_value(*element.as<JSON::String>());
        }
        else if (element.is<JSON::Number>())
        {
            dump_json_integer_value(*element.as<JSON::Number>());
        }
    }

    static auto dump_element(const JSON::KeyValuePair& element) -> void
    {
        if (element.is<JSON::Object>())
        {
            dump_json_object_pair(element.as<JSON::Object>());
        }
        else if (element.is<JSON::Array>())
        {
            dump_json_array_pair(element.as<JSON::Array>());
        }
        else if (element.is<JSON::String>())
        {
            dump_json_string_pair(element.as<JSON::String>());
        }
        else if (element.is<JSON::Number>())
        {
            dump_json_integer_pair(element.as<JSON::Number>());
        }
    }

    static auto dump_json_object_pair(const JSON::TypedKeyValuePair<JSON::Object> element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}Object: {}\n"), indent(), element.key);

        const auto& object = element.value->get();
        for (const auto& [_, inner_element] : object)
        {
            ++indent_level;
            dump_element(*inner_element.get());
            --indent_level;
        }
    }

    static auto dump_json_array_pair(const JSON::TypedKeyValuePair<JSON::Array> element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}Array: {}\n"), indent(), element.key);

        const auto& array = element.value->get();
        for (const auto& inner_element : array)
        {
            ++indent_level;
            dump_element(*inner_element.get());
            --indent_level;
        }
    }

    static auto dump_json_string_pair(const JSON::TypedKeyValuePair<JSON::String> element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}String: {} == {}\n"), indent(), element.key, element.value->get_view());
    }

    static auto dump_json_integer_pair(const JSON::TypedKeyValuePair<JSON::Number> element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}Integer: {} == {}\n"), indent(), element.key, element.value->get<int64_t>());
    }

    static auto dump_json_object_value(const JSON::Object& element) -> void
    {
        ++indent_level;
        Output::send<LogLevel::Verbose>(STR("{}Object <anon>\n"), indent());

        const auto& object = element.get();
        for (const auto& [_, inner_element] : object)
        {
            ++indent_level;
            dump_element(*inner_element.get());
            --indent_level;
        }

        --indent_level;
    }

    static auto dump_json_array_value(const JSON::Array& element) -> void
    {
        ++indent_level;
        Output::send<LogLevel::Verbose>(STR("{}Array <anon>\n"), indent());

        const auto& array = element.get();
        for (const auto& inner_element : array)
        {
            ++indent_level;
            dump_element(*inner_element.get());
            --indent_level;
        }

        --indent_level;
    }

    static auto dump_json_string_value(const JSON::String& element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}String: {}\n"), indent(), element.get_view());
    }

    static auto dump_json_integer_value(const JSON::Number& element) -> void
    {
        Output::send<LogLevel::Verbose>(STR("{}Integer: {}\n"), indent(), element.get<int64_t>());
    }
}

```

`src/GUI/LiveView.cpp`:

```cpp
#include <algorithm>
#include <string>
#include <format>
#include <unordered_map>

#include <GUI/LiveView.hpp>
#include <GUI/GUI.hpp>
#include <GUI/ImGuiUtility.hpp>
#include <ExceptionHandling.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>
#include <JSON/JSON.hpp>
#include <JSON/Parser/Parser.hpp>
#include <UE4SSProgram.hpp>
#include <Unreal/UnrealInitializer.hpp>
#include <Unreal/UObjectArray.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <imgui.h>
#include <misc/cpp/imgui_stdlib.h>
#include <imgui_internal.h>

namespace RC::GUI
{
    using namespace Unreal;

    static constexpr int s_max_elements_per_chunk = 64 * 1024;
    static constexpr int s_max_chunk_size_doubled = s_max_elements_per_chunk * 2;
    static constexpr int s_num_items_per_chunk = 1;
    static constexpr int s_chunk_id_start = -s_max_elements_per_chunk;

    static bool s_live_view_destructed = false;
    static std::unordered_map<const UObject*, std::string> s_object_ptr_to_full_name{};

    std::vector<LiveView::ObjectOrProperty> LiveView::s_object_view_history{{nullptr, nullptr, false}};
    size_t LiveView::s_currently_selected_object_index{};
    std::unordered_map<UObject*, std::vector<size_t>> LiveView::s_history_object_to_index{{nullptr, {0}}};
    std::vector<UObject*> LiveView::s_name_search_results{};
    std::unordered_set<UObject*> LiveView::s_name_search_results_set{};
    std::string LiveView::s_name_to_search_by{};
    std::vector<LiveView::Watch> LiveView::s_watches{};
    std::unordered_map<LiveView::WatchIdentifier, LiveView::Watch*> LiveView::s_watch_map;
    std::unordered_map<void*, std::vector<LiveView::Watch*>> LiveView::s_watch_containers{};
    bool LiveView::s_create_listener_removed{};
    bool LiveView::s_delete_listener_removed{};
    bool LiveView::s_selected_item_deleted{};
    bool LiveView::s_need_to_filter_out_properties{};
    bool LiveView::s_watches_loaded_from_disk{};

    static auto get_object_full_name_cxx_string(UObject* object) -> std::string;

    static auto attempt_to_add_search_result(UObject* object) -> void
    {
        // TODO: Stop using the 'HashObject' function when needing the address of an FFieldClassVariant because it's not designed to return an address.
        //       Maybe make the ToFieldClass/ToUClass functions public (append 'Unsafe' to the function names).
        if (LiveView::s_need_to_filter_out_properties && object->IsA(std::bit_cast<UClass*>(FProperty::StaticClass().HashObject())))
        {
            return;
        }

        if (!LiveView::s_name_search_results_set.contains(object))
        {
            auto object_full_name = get_object_full_name_cxx_string(object);
            std::transform(object_full_name.begin(), object_full_name.end(), object_full_name.begin(), [](char c) {
                return std::tolower(c);
            });

            auto name_to_search_by = LiveView::s_name_to_search_by;
            std::transform(name_to_search_by.begin(), name_to_search_by.end(), name_to_search_by.begin(), [](char c) {
                return std::tolower(c);
            });

            if (object_full_name.find(name_to_search_by) != object_full_name.npos)
            {
                LiveView::s_name_search_results.emplace_back(object);
                LiveView::s_name_search_results_set.emplace(object);
            }
        }
    }

    static auto remove_search_result(UObject* object) -> void
    {
        LiveView::s_name_search_results.erase(std::remove_if(LiveView::s_name_search_results.begin(), LiveView::s_name_search_results.end(), [&](const auto& item) {
            return item == object;
        }), LiveView::s_name_search_results.end());

        LiveView::s_name_search_results_set.erase(object);

        auto watch_it = LiveView::s_watch_containers.find(object);
        if (watch_it != LiveView::s_watch_containers.end())
        {
            LiveView::s_watches.erase(std::remove_if(LiveView::s_watches.begin(), LiveView::s_watches.end(), [&](const auto& item) {
                if (item.container == object)
                {
                    LiveView::s_watch_map.erase(LiveView::s_watch_map.find({item.container, item.property}));
                    return true;
                }
                else
                {
                    return false;
                }
            }), LiveView::s_watches.end());
            LiveView::s_watch_containers.erase(watch_it);
        }
    }

    struct FLiveViewCreateListener : public FUObjectCreateListener
    {
        static FLiveViewCreateListener LiveViewCreateListener;

        void NotifyUObjectCreated(const UObjectBase* object, int32 index) override
        {
            if (s_live_view_destructed) { return; }
            attempt_to_add_search_result(std::bit_cast<UObject*>(object));
        }

        void OnUObjectArrayShutdown() override
        {
            UObjectArray::RemoveUObjectCreateListener(this);
            LiveView::s_create_listener_removed = true;
        }
    };
    FLiveViewCreateListener FLiveViewCreateListener::LiveViewCreateListener{};

    struct FLiveViewDeleteListener : public FUObjectDeleteListener
    {
        static FLiveViewDeleteListener LiveViewDeleteListener;

        void NotifyUObjectDeleted(const UObjectBase* object, int32 index) override
        {
            if (s_live_view_destructed) { return; }
            if (LiveView::s_history_object_to_index.size() <= 1) { return; }

            auto as_uobject = std::bit_cast<UObject*>(object);
            if (auto it = LiveView::s_history_object_to_index.find(as_uobject); it != LiveView::s_history_object_to_index.end())
            {
                for (const auto& history_index : it->second)
                {
                    auto& selected_object_or_property = LiveView::s_object_view_history[history_index];
                    if (selected_object_or_property.is_object)
                    {
                        selected_object_or_property.object_item = nullptr;
                        selected_object_or_property.object = nullptr;
                        LiveView::s_history_object_to_index.erase(it);
                    }
                }
            }

            remove_search_result(as_uobject);
        }

        void OnUObjectArrayShutdown() override
        {
            UObjectArray::RemoveUObjectDeleteListener(this);
            LiveView::s_delete_listener_removed = true;
        }
    };
    FLiveViewDeleteListener FLiveViewDeleteListener::LiveViewDeleteListener{};

    static auto add_watch(const LiveView::WatchIdentifier& watch_id, UObject* object, FProperty* property) -> LiveView::Watch&
    {
        auto& watch = LiveView::s_watches.emplace_back(LiveView::Watch{
                object->GetOuterPrivate()->GetName() + STR(".") + object->GetName(),
                property->GetName()
        });
        watch.enabled = true;
        watch.property = property;
        watch.container = object;
        watch.hash = std::hash<LiveView::WatchIdentifier>()(watch_id);

        LiveView::s_watch_map.emplace(watch_id, &watch);

        auto& watch_container = LiveView::s_watch_containers[watch.container];
        return *watch_container.emplace_back(&watch);
    }

    static auto add_watch(UObject* object, FProperty* property) -> LiveView::Watch&
    {
        return add_watch(LiveView::WatchIdentifier{object, property}, object, property);
    }

    static auto serialize_watch_to_json_object(const LiveView::Watch& watch) -> std::unique_ptr<JSON::Object>
    {
        auto json_object = std::make_unique<JSON::Object>();
        switch (watch.acquisition_method)
        {
            case LiveView::Watch::AcquisitionMethod::StaticFindObject:
            {
                auto object_full_name = watch.container->GetFullName();
                auto object_type_space_location = object_full_name.find(STR(" "));
                auto object_typeless_name = StringType{object_full_name.begin() + object_type_space_location + 1, object_full_name.end()};
                json_object->new_string(STR("AcquisitionID"), object_typeless_name);
                break;
            }
            case LiveView::Watch::AcquisitionMethod::FindFirstOf:
                json_object->new_string(STR("AcquisitionID"), watch.container->GetClassPrivate()->GetName());
                break;
        }
        json_object->new_string(STR("PropertyName"), watch.property_name);
        json_object->new_number(STR("AcquisitionMethod"), static_cast<int32_t>(watch.acquisition_method));
        return json_object;
    }

    static auto internal_load_watches_from_disk() -> void
    {
        auto json_file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + std::format(STR("\\watches\\watches.meta.json")),
                                    File::OpenFor::Reading,
                                    File::OverwriteExistingFile::No,
                                    File::CreateIfNonExistent::Yes);
        auto json_file_contents = json_file.read_all();
        if (json_file_contents.empty()) { return; }

        auto json_global_object = JSON::Parser::parse(json_file_contents);
        const auto& elements = json_global_object->get<JSON::Array>(STR("Watches"));
        elements.for_each([](JSON::Value& element) {
            auto& json_watch_object = *element.as<JSON::Object>();
            auto acquisition_id = json_watch_object.get<JSON::String>(STR("AcquisitionID")).get_view();
            auto property_name = json_watch_object.get<JSON::String>(STR("PropertyName")).get_view();
            auto acquisition_method = static_cast<LiveView::Watch::AcquisitionMethod>(json_watch_object.get<JSON::Number>(STR("AcquisitionMethod")).get<int64_t>());

            UObject* object{};
            switch (acquisition_method)
            {
                case LiveView::Watch::AcquisitionMethod::StaticFindObject:
                    object = UObjectGlobals::StaticFindObject<UObject*>(nullptr, nullptr, acquisition_id);
                    break;
                case LiveView::Watch::AcquisitionMethod::FindFirstOf:
                    object = UObjectGlobals::FindFirstOf(acquisition_id);
                    break;
                default:
                    throw std::runtime_error{"load_watches_from_disk: Unhandled acquisition method"};
            }
            if (!object) { return LoopAction::Continue; }

            auto property = object->GetPropertyByNameInChain(property_name.data());
            if (!property) { return LoopAction::Continue; }

            auto& watch = add_watch(object, property);
            watch.load_on_startup = true;
            watch.acquisition_method = acquisition_method;

            return LoopAction::Continue;
        });
    }

    static auto load_watches_from_disk() -> void
    {
        TRY([] {
            internal_load_watches_from_disk();
        });
    }

    static auto internal_save_watches_to_disk() -> void
    {
        auto json = JSON::Object{};
        auto& json_uobjects = json.new_array(STR("Watches"));

        for (const auto& watch : LiveView::s_watches)
        {
            if (!watch.load_on_startup) { continue; }
            json_uobjects.add_object(serialize_watch_to_json_object(watch));
        }

        auto json_file = File::open(StringType{UE4SSProgram::get_program().get_working_directory()} + std::format(STR("\\watches\\watches.meta.json")),
                                    File::OpenFor::Writing,
                                    File::OverwriteExistingFile::Yes,
                                    File::CreateIfNonExistent::Yes);
        int32_t json_indent_level{};
        json_file.write_string_to_file(json.serialize(JSON::ShouldFormat::Yes, &json_indent_level));
    }

    static auto save_watches_to_disk() -> void
    {
        TRY([] {
            internal_save_watches_to_disk();
        });
    }

    auto LiveView::set_listeners() -> void
    {
        if (m_listeners_set) { return; }
        m_listeners_set = true;
        UObjectArray::AddUObjectCreateListener(&FLiveViewCreateListener::LiveViewCreateListener);
        UObjectArray::AddUObjectDeleteListener(&FLiveViewDeleteListener::LiveViewDeleteListener);
    }

    auto LiveView::unset_listeners() -> void
    {
        if (!m_listeners_set) { return; }
        m_listeners_set = false;
        UObjectArray::RemoveUObjectCreateListener(&FLiveViewCreateListener::LiveViewCreateListener);
        UObjectArray::RemoveUObjectDeleteListener(&FLiveViewDeleteListener::LiveViewDeleteListener);
    }

    LiveView::Watch::Watch(StringType&& object_name, StringType&& property_name) : object_name(object_name), property_name(property_name)
    {
        auto& file_device = output.get_device<Output::FileDevice>();
        file_device.set_file_name_and_path(StringType{UE4SSProgram::get_program().get_working_directory()} + std::format(STR("\\watches\\ue4ss_watch_{}_{}.txt"), object_name, property_name));
        file_device.set_formatter([](File::StringViewType string) -> File::StringType {
            const auto when_as_string = std::format(STR("{:%Y-%m-%d %H:%M:%S}"), std::chrono::system_clock::now());
            return std::format(STR("[{}] {}"), when_as_string, string);
        });
    }

    auto LiveView::initialize() -> void
    {
        s_need_to_filter_out_properties = Version::IsBelow(4, 25);
        m_is_initialized = true;
    }

    struct PropertyFlagsStringifier
    {
        std::string flags_string{};
        std::vector<std::string> flag_parts{};

        PropertyFlagsStringifier(EPropertyFlags flags)
        {
            if ((flags & CPF_Edit) != 0) { flag_parts.emplace_back("CPF_Edit"); }
            if ((flags & CPF_ConstParm) != 0) { flag_parts.emplace_back("CPF_ConstParm"); }
            if ((flags & CPF_BlueprintVisible) != 0) { flag_parts.emplace_back("CPF_BlueprintVisible"); }
            if ((flags & CPF_ExportObject) != 0) { flag_parts.emplace_back("CPF_ExportObject"); }
            if ((flags & CPF_BlueprintReadOnly) != 0) { flag_parts.emplace_back("CPF_BlueprintReadOnly"); }
            if ((flags & CPF_Net) != 0) { flag_parts.emplace_back("CPF_Net"); }
            if ((flags & CPF_EditFixedSize) != 0) { flag_parts.emplace_back("CPF_EditFixedSize"); }
            if ((flags & CPF_Parm) != 0) { flag_parts.emplace_back("CPF_Parm"); }
            if ((flags & CPF_OutParm) != 0) { flag_parts.emplace_back("CPF_OutParm"); }
            if ((flags & CPF_ZeroConstructor) != 0) { flag_parts.emplace_back("CPF_ZeroConstructor"); }
            if ((flags & CPF_ReturnParm) != 0) { flag_parts.emplace_back("CPF_ReturnParm"); }
            if ((flags & CPF_DisableEditOnTemplate) != 0) { flag_parts.emplace_back("CPF_DisableEditOnTemplate"); }
            if ((flags & CPF_Transient) != 0) { flag_parts.emplace_back("CPF_Transient"); }
            if ((flags & CPF_Config) != 0) { flag_parts.emplace_back("CPF_Config"); }
            if ((flags & CPF_DisableEditOnInstance) != 0) { flag_parts.emplace_back("CPF_DisableEditOnInstance"); }
            if ((flags & CPF_EditConst) != 0) { flag_parts.emplace_back("CPF_EditConst"); }
            if ((flags & CPF_GlobalConfig) != 0) { flag_parts.emplace_back("CPF_GlobalConfig"); }
            if ((flags & CPF_InstancedReference) != 0) { flag_parts.emplace_back("CPF_InstancedReference"); }
            if ((flags & CPF_DuplicateTransient) != 0) { flag_parts.emplace_back("CPF_DuplicateTransient"); }
            if ((flags & CPF_SubobjectReference) != 0) { flag_parts.emplace_back("CPF_SubobjectReference"); }
            if ((flags & CPF_SaveGame) != 0) { flag_parts.emplace_back("CPF_SaveGame"); }
            if ((flags & CPF_NoClear) != 0) { flag_parts.emplace_back("CPF_NoClear"); }
            if ((flags & CPF_ReferenceParm) != 0) { flag_parts.emplace_back("CPF_ReferenceParm"); }
            if ((flags & CPF_BlueprintAssignable) != 0) { flag_parts.emplace_back("CPF_BlueprintAssignable"); }
            if ((flags & CPF_Deprecated) != 0) { flag_parts.emplace_back("CPF_Deprecated"); }
            if ((flags & CPF_IsPlainOldData) != 0) { flag_parts.emplace_back("CPF_IsPlainOldData"); }
            if ((flags & CPF_RepSkip) != 0) { flag_parts.emplace_back("CPF_RepSkip"); }
            if ((flags & CPF_RepNotify) != 0) { flag_parts.emplace_back("CPF_RepNotify"); }
            if ((flags & CPF_Interp) != 0) { flag_parts.emplace_back("CPF_Interp"); }
            if ((flags & CPF_NonTransactional) != 0) { flag_parts.emplace_back("CPF_NonTransactional"); }
            if ((flags & CPF_EditorOnly) != 0) { flag_parts.emplace_back("CPF_EditorOnly"); }
            if ((flags & CPF_NoDestructor) != 0) { flag_parts.emplace_back("CPF_NoDestructor"); }
            if ((flags & CPF_AutoWeak) != 0) { flag_parts.emplace_back("CPF_AutoWeak"); }
            if ((flags & CPF_ContainsInstancedReference) != 0) { flag_parts.emplace_back("CPF_ContainsInstancedReference"); }
            if ((flags & CPF_AssetRegistrySearchable) != 0) { flag_parts.emplace_back("CPF_AssetRegistrySearchable"); }
            if ((flags & CPF_SimpleDisplay) != 0) { flag_parts.emplace_back("CPF_SimpleDisplay"); }
            if ((flags & CPF_AdvancedDisplay) != 0) { flag_parts.emplace_back("CPF_AdvancedDisplay"); }
            if ((flags & CPF_Protected) != 0) { flag_parts.emplace_back("CPF_Protected"); }
            if ((flags & CPF_BlueprintCallable) != 0) { flag_parts.emplace_back("CPF_BlueprintCallable"); }
            if ((flags & CPF_BlueprintAuthorityOnly) != 0) { flag_parts.emplace_back("CPF_BlueprintAuthorityOnly"); }
            if ((flags & CPF_TextExportTransient) != 0) { flag_parts.emplace_back("CPF_TextExportTransient"); }
            if ((flags & CPF_NonPIEDuplicateTransient) != 0) { flag_parts.emplace_back("CPF_NonPIEDuplicateTransient"); }
            if ((flags & CPF_ExposeOnSpawn) != 0) { flag_parts.emplace_back("CPF_ExposeOnSpawn"); }
            if ((flags & CPF_PersistentInstance) != 0) { flag_parts.emplace_back("CPF_PersistentInstance"); }
            if ((flags & CPF_UObjectWrapper) != 0) { flag_parts.emplace_back("CPF_UObjectWrapper"); }
            if ((flags & CPF_HasGetValueTypeHash) != 0) { flag_parts.emplace_back("CPF_HasGetValueTypeHash"); }
            if ((flags & CPF_NativeAccessSpecifierPublic) != 0) { flag_parts.emplace_back("CPF_NativeAccessSpecifierPublic"); }
            if ((flags & CPF_NativeAccessSpecifierProtected) != 0) { flag_parts.emplace_back("CPF_NativeAccessSpecifierProtected"); }
            if ((flags & CPF_NativeAccessSpecifierPrivate) != 0) { flag_parts.emplace_back("CPF_NativeAccessSpecifierPrivate"); }
            if ((flags & CPF_SkipSerialization) != 0) { flag_parts.emplace_back("CPF_SkipSerialization"); }

            std::for_each(flag_parts.begin(), flag_parts.end(), [&](const std::string& flag_part) {
                if (!flags_string.empty())
                {
                    flags_string.append(", ");
                }
                flags_string.append(std::move(flag_part));
            });
        }
    };

    LiveView::LiveView()
    {
        m_search_by_name_buffer = new char[m_search_buffer_capacity];
        strncpy_s(m_search_by_name_buffer, m_default_search_buffer.size() + sizeof(char), m_default_search_buffer.data(), m_default_search_buffer.size() + sizeof(char));
    }

    LiveView::~LiveView()
    {
        s_live_view_destructed = true;
        if (!s_create_listener_removed)
        {
            UObjectArray::RemoveUObjectCreateListener(&FLiveViewCreateListener::LiveViewCreateListener);
        }

        if (!s_delete_listener_removed)
        {
            UObjectArray::RemoveUObjectDeleteListener(&FLiveViewDeleteListener::LiveViewDeleteListener);
        }

        delete[] m_search_by_name_buffer;
    }

    auto LiveView::guobjectarray_iterator(int32_t int_data_1, int32_t int_data_2, const std::function<void(UObject*)>& callable) -> void
    {
        UObjectGlobals::ForEachUObjectInRange(int_data_1, int_data_2, [&](UObject* object, ...) {
            // TODO: Stop using the 'HashObject' function when needing the address of an FFieldClassVariant because it's not designed to return an address.
            //       Maybe make the ToFieldClass/ToUClass functions public (append 'Unsafe' to the function names).
            if (s_need_to_filter_out_properties && object->IsA(std::bit_cast<UClass*>(FProperty::StaticClass().HashObject())))
            {
                return LoopAction::Continue;
            }
            callable(object);
            return LoopAction::Continue;
        });
    }

    auto LiveView::select_object(size_t index, const FUObjectItem* object_item, UObject* object, AffectsHistory affects_history) -> void
    {
        if (object_item && object && affects_history == AffectsHistory::Yes)
        {
            s_object_view_history.resize(s_currently_selected_object_index + 1);
            s_object_view_history.emplace_back(ObjectOrProperty{object_item, object, true});
            s_currently_selected_object_index = s_object_view_history.size() - 1;
            auto[history_object, did_emplace] = s_history_object_to_index.emplace(object, std::vector<size_t>{});
            history_object->second.emplace_back(s_currently_selected_object_index);
        }
        else
        {
            s_currently_selected_object_index = index;
        }
    }

    auto LiveView::select_property(size_t index, FProperty* property, AffectsHistory affects_history) -> void
    {
        s_object_view_history.resize(s_currently_selected_object_index + 1);
        auto object_or_property = ObjectOrProperty{};
        object_or_property.is_object = false;
        object_or_property.property = property;
        object_or_property.object = nullptr;
        s_object_view_history.emplace_back(std::move(object_or_property));
        s_currently_selected_object_index = s_object_view_history.size() - 1;
    }

    static auto get_object_full_name(const UObject* object) -> const char*
    {
        if (!UnrealInitializer::StaticStorage::bIsInitialized) { return ""; }
        if (auto it = s_object_ptr_to_full_name.find(object); it != s_object_ptr_to_full_name.end())
        {
            return it->second.c_str();
        }
        else
        {
            return s_object_ptr_to_full_name.emplace(object, to_string(object->GetFullName())).first->second.c_str();
        }
    }

    static auto get_object_full_name_cxx_string(UObject* object) -> std::string
    {
        if (!UnrealInitializer::StaticStorage::bIsInitialized) { return ""; }
        if (auto it = s_object_ptr_to_full_name.find(object); it != s_object_ptr_to_full_name.end())
        {
            return it->second;
        }
        else
        {
            return s_object_ptr_to_full_name.emplace(object, to_string(object->GetFullName())).first->second;
        }
    }

    auto LiveView::guobjectarray_by_name_iterator([[maybe_unused]]int32_t int_data_1, [[maybe_unused]]int32_t int_data_2, const std::function<void(UObject*)>& callable) -> void
    {
        for (const auto& object : s_name_search_results)
        {
            callable(object);
        }
    }

    auto LiveView::search_by_name() -> void
    {
        Output::send(STR("Searching by name...\n"));
        s_name_search_results.clear();
        s_name_search_results_set.clear();
        UObjectGlobals::ForEachUObject([&](UObject* object, ...) {
            attempt_to_add_search_result(object);
            return LoopAction::Continue;
        });
    }

    static auto ImGui_GetID(int int_id) -> ImGuiID
    {
        ImGuiWindow* window = GImGui->CurrentWindow;
        return window->GetID(int_id);
    }

    static auto ImGui_TreeNodeEx(const char* label, int int_id, ImGuiTreeNodeFlags flags = 0) -> bool
    {
        ImGuiWindow* window = ImGui::GetCurrentWindow();
        if (window->SkipItems)
            return false;

        return ImGui::TreeNodeBehavior(window->GetID(int_id), flags, label, NULL);
    }

    static auto ImGui_TreeNodeEx(const char* label, void* ptr_id, ImGuiTreeNodeFlags flags = 0) -> bool
    {
        ImGuiWindow* window = ImGui::GetCurrentWindow();
        if (window->SkipItems)
            return false;

        return ImGui::TreeNodeBehavior(window->GetID(ptr_id), flags, label, NULL);
    }

    static auto collapse_all_except(int except_id) -> void
    {
        for (int i = 0; i < UObjectArray::GetNumChunks(); ++i)
        {
            if (i + s_chunk_id_start == except_id) { continue; }
            ImGui::GetStateStorage()->SetInt(ImGui_GetID(i + s_chunk_id_start), 0);
        }
    }

    auto LiveView::collapse_all_except(void* except_id) -> void
    {
        // We don't need to do anything if we only have one node open.
        if (m_opened_tree_nodes.size() == 1) { return; }

        for (auto tree_node = m_opened_tree_nodes.begin(); tree_node != m_opened_tree_nodes.end();)
        {
            if (*tree_node != except_id)
            {
                ImGui::GetStateStorage()->SetInt(ImGui::GetID(*tree_node), 0);
                m_opened_tree_nodes.erase(tree_node++);
            }
            else
            {
                ++tree_node;
            }
        }
    }

    auto LiveView::render_object_sub_tree_hierarchy(UObject* object) -> void
    {
        if (!object) { return; }

        auto uclass = object->GetClassPrivate();
        ImGui::Text("%s", get_object_full_name(uclass));
        render_struct_sub_tree_hierarchy(uclass);
    }

    auto LiveView::render_struct_sub_tree_hierarchy(UStruct* ustruct) -> void
    {
        if (!ustruct) { return; }

        auto next_class = ustruct->GetClassPrivate();

        ImGui::Indent();
        ImGui::Text("ClassPrivate");
        if (ImGui::TreeNode(get_object_full_name(next_class)))
        {
            if (next_class && ustruct != next_class)
            {
                render_struct_sub_tree_hierarchy(next_class);
            }
            ImGui::TreePop();
        }
        else
        {
            if (ImGui::IsItemClicked())
            {
                select_object(0, ustruct->GetObjectItem(), ustruct, AffectsHistory::Yes);
            }
        }

        auto next_super = ustruct->GetSuperStruct();

        ImGui::Text("SuperStruct");
        if (ImGui::TreeNode(get_object_full_name(next_super)))
        {
            if (next_super && ustruct != next_super)
            {
                render_struct_sub_tree_hierarchy(next_super);
            }
            ImGui::TreePop();
        }
        else
        {
            if (ImGui::IsItemClicked())
            {
                select_object(0, ustruct->GetObjectItem(), ustruct, AffectsHistory::Yes);
            }
        }

        ImGui::Text("Properties");
        if (ImGui::TreeNodeEx("Show", ImGuiTreeNodeFlags_SpanFullWidth))
        {
            ustruct->ForEachProperty([&](FProperty* property) {
                ImGui::TreeNodeEx(to_string(property->GetFullName()).c_str(), ImGuiTreeNodeFlags_Leaf);
                if (ImGui::IsItemClicked())
                {
                    select_property(0, property, AffectsHistory::Yes);
                }
                ImGui::TreePop();

                return LoopAction::Continue;
            });
            ImGui::TreePop();
        }
        ImGui::Unindent();
    }

    auto LiveView::render_class(UClass* uclass) -> void
    {
        if (!uclass) { return; }
        ImGui::Text("ClassPrivate");
        if (ImGui::TreeNode(get_object_full_name(uclass)))
        {
            auto next_class = uclass->GetClassPrivate();
            if (uclass != next_class)
            {
                render_class(next_class);
                render_super_struct(uclass->GetSuperStruct());
            }
            ImGui::TreePop();
        }
        else
        {
            if (ImGui::IsItemClicked())
            {
                select_object(0, uclass->GetObjectItem(), uclass, AffectsHistory::Yes);
            }
        }

        Output::send(STR("{}\n"), uclass->GetFullName());

        ImGui::Text("Properties");
        uclass->ForEachProperty([](FProperty* property) {
            if (ImGui::TreeNode(to_string(property->GetFullName()).c_str()))
            {
                Output::send(STR("Show property: {}\n"), property->GetFullName());
            }

            return LoopAction::Continue;
        });
    }

    auto LiveView::render_super_struct(UStruct* ustruct) -> void
    {
        if (!ustruct) { return; }
        ImGui::Text("SuperStruct");
        if (ImGui::TreeNode(get_object_full_name(ustruct)))
        {
            auto next_super_struct = ustruct->GetSuperStruct();
            if (ustruct != next_super_struct)
            {
                render_super_struct(next_super_struct);
            }
            ImGui::TreePop();
        }
        else
        {
            if (ImGui::IsItemClicked())
            {
                printf_s("Clicked: %S\n", ustruct->GetFullName().c_str());
                select_object(0, ustruct->GetObjectItem(), ustruct, AffectsHistory::Yes);
            }
        }
    }

    auto LiveView::get_selected_object_or_property() -> const ObjectOrProperty&
    {
        return s_object_view_history[s_currently_selected_object_index];
    }

    auto LiveView::get_selected_object(size_t index, UseIndex use_index) -> std::pair<const FUObjectItem*, UObject*>
    {
        const auto& selected_object_or_property = s_object_view_history[use_index == UseIndex::Yes ? index : s_currently_selected_object_index];
        return std::pair{selected_object_or_property.object_item, selected_object_or_property.object};
    }

    auto LiveView::get_selected_property(size_t index, UseIndex use_index) -> FProperty*
    {
        const auto& selected_object_or_property = s_object_view_history[use_index == UseIndex::Yes ? index : s_currently_selected_object_index];
        return selected_object_or_property.property;
    }

    auto LiveView::render_properties() -> void
    {
        const auto currently_selected_object = get_selected_object();
        if (!currently_selected_object.first || !currently_selected_object.second) { return; }

        bool instance_is_struct = currently_selected_object.second->IsA<UStruct>();
        auto uclass = instance_is_struct ? static_cast<UClass*>(currently_selected_object.second) : currently_selected_object.second->GetClassPrivate();

        UObject* next_object_to_render{};
        FUObjectItem* next_object_item_to_render{};
        FProperty* next_property_to_render{};

        struct OrderedProperty
        {
            int32_t offset{};
            UStruct* owner{};
            FProperty* property{};
        };
        std::vector<OrderedProperty> all_properties{};

        bool tried_to_open_nullptr_object{};

        FProperty* last_property{};

        auto render_property_text = [&](UClass* uclass, FProperty* property) {
            auto property_offset = property->GetOffset_Internal();
            if (last_property)
            {
                auto property_alignment = property->GetMinAlignment();
                auto last_property_alignment = last_property->GetMinAlignment();
                auto last_property_offset = last_property->GetOffset_Internal();
                auto last_property_size = last_property->GetSize();
                auto last_property_offset_with_alignment = ((last_property_offset + last_property_size + (property_alignment - 1)) & ~(property_alignment - 1));
                if (last_property_offset_with_alignment != property_offset && (!property->IsA<FBoolProperty>() && !last_property->IsA<FBoolProperty>()))
                {
                    auto unreflected_size = property_offset - last_property_offset_with_alignment;
                    auto unreflected_offset = property_offset - unreflected_size;
                    ImGui::PushStyleColor(ImGuiCol_Text, g_imgui_text_live_view_unreflected_data_color.Value);
                    ImGui::Text("0x%X: Unknown unreflected data", unreflected_offset);
                    ImGui::PopStyleColor();
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::BeginTooltip();
                        ImGui::Text("Offset: 0x%X", unreflected_offset);
                        ImGui::Text("Size: 0x%X", unreflected_size);
                        ImGui::EndTooltip();
                    }
                }
            }

            FString TextItem{};
            auto container_ptr = property->ContainerPtrToValuePtr<void*>(currently_selected_object.second);
            auto property_name = to_string(property->GetName());
            property->ExportTextItem(TextItem, container_ptr, container_ptr, const_cast<UObject*>(currently_selected_object.second), NULL);
            ImGui::Text("0x%X %s: %S", property_offset, property_name.c_str(), TextItem.GetCharArray());

            if (ImGui::IsItemHovered())
            {
                ImGui::BeginTooltip();
                ImGui::Text("%S", property->GetFullName().c_str());
                ImGui::Separator();
                ImGui::Text("Offset: 0x%X", property->GetOffset_Internal());
                ImGui::Text("Size: 0x%X", property->GetSize());
                ImGui::EndTooltip();
            }

            if (ImGui::BeginPopupContextItem(property_name.c_str()))
            {
                if (ImGui::MenuItem("Copy name"))
                {
                    ImGui::SetClipboardText(property_name.c_str());
                }
                if (ImGui::MenuItem("Copy full name"))
                {
                    ImGui::SetClipboardText(to_string(property->GetFullName()).c_str());
                }
                if (ImGui::MenuItem("Copy value"))
                {
                    ImGui::SetClipboardText(to_string(TextItem.GetCharArray()).c_str());
                }

                auto watch_id = WatchIdentifier{currently_selected_object.second, property};
                auto property_watcher_it = s_watch_map.find(watch_id);
                if (property_watcher_it == s_watch_map.end())
                {
                    ImGui::Separator();
                    if (ImGui::MenuItem("Watch value"))
                    {
                        add_watch(watch_id, currently_selected_object.second, property);
                    }
                }
                else
                {
                    ImGui::Checkbox("Watch value", &property_watcher_it->second->enabled);
                }

                ImGui::Separator();

                if (ImGui::MenuItem("Go to property"))
                {
                    next_property_to_render = property;
                }

                if (property->IsA<FObjectProperty>())
                {
                    if (ImGui::MenuItem("Go to object"))
                    {
                        auto hovered_object = *property->ContainerPtrToValuePtr<UObject*>(currently_selected_object.second);

                        if (!hovered_object)
                        {
                            tried_to_open_nullptr_object = true;
                        }
                        else
                        {
                            // Cannot go to another object in the middle of rendering properties.
                            // Doing so would cause the properties to be looked up on an instance with a property-list from another class.
                            // To fix this, we save which instance we want to go to and then we go to it at the end when we're done accessing all properties.
                            next_object_to_render = hovered_object;
                            next_object_item_to_render = next_object_to_render->GetObjectItem();
                        }
                    }
                }

                ImGui::EndPopup();
            }

            last_property = property;
        };

        if (instance_is_struct)
        {
            // TODO: Redirect to property rendered (this is the property-value renderer even though the name says otherwise).
            return;
        }
        else
        {
            ImGui::Separator();
            uclass->ForEachProperty([&](FProperty* property) {
                all_properties.emplace_back(OrderedProperty{property->GetOffset_Internal(), uclass, property});
                return LoopAction::Continue;
            });

            uclass->ForEachSuperStruct([&](UStruct* super_struct) {
                super_struct->ForEachProperty([&](FProperty* property) {
                    all_properties.emplace_back(OrderedProperty{property->GetOffset_Internal(), super_struct, property});
                    return LoopAction::Continue;
                });
                return LoopAction::Continue;
            });

            std::sort(all_properties.begin(), all_properties.end(), [](const OrderedProperty& a, const OrderedProperty& b) {
                return a.offset < b.offset;
            });

            for (const auto& ordered_property : all_properties)
            {
                render_property_text(static_cast<UClass*>(ordered_property.owner), ordered_property.property);
            }

            if (tried_to_open_nullptr_object)
            {
                ImGui::OpenPopup("ObjectPropertyValueOpenNullptrWarning");
                m_modal_tried_to_open_nullptr_object_is_open = true;
            }

            if (ImGui::BeginPopupModal("ObjectPropertyValueOpenNullptrWarning", &m_modal_tried_to_open_nullptr_object_is_open, ImGuiWindowFlags_NoResize))
            {
                ImGui::Text("Cannot open ObjectProperty value because it's nullptr");
                ImGui::EndPopup();
            }

            if (next_object_to_render && next_object_item_to_render)
            {
                select_object(0, next_object_item_to_render, next_object_to_render, AffectsHistory::Yes);
            }

            if (next_property_to_render)
            {
                select_property(0, next_property_to_render, AffectsHistory::Yes);
            }
        }
    }

    auto LiveView::render_info_panel_as_object(const FUObjectItem* object_item, UObject* object) -> void
    {
        if (!object || (!object_item || object_item->IsUnreachable()))
        {
            ImGui::Text("No object selected.");
            return;
        }

        auto object_full_name = get_object_full_name(object);

        ImGui::Text("Selected: %s", to_string(object->GetName()).c_str());
        ImGui::Text("Address: %016llX", std::bit_cast<uintptr_t>(object));
        if (ImGui::BeginPopupContextItem(object_full_name))
        {
            if (ImGui::MenuItem("Copy address"))
            {
                ImGui::SetClipboardText(std::format("{:016X}", std::bit_cast<uintptr_t>(object)).c_str());
            }
            ImGui::EndPopup();
        }
        ImGui::Text("ClassPrivate: %s", to_string(object->GetClassPrivate()->GetName()).c_str());
        ImGui::Text("Path: %S", object->GetPathName().c_str());
        ImGui::Separator();
        // Potential sizes: 385, -180 (open) | // 385, -286 (closed)
        if (ImGui::CollapsingHeader("Size (total size of class + parents in parentheses)"))
        {
            auto uclass = object->IsA<UStruct>() ? static_cast<UClass*>(object) : object->GetClassPrivate();
            ImGui::Text("The allocated structure may be larger due to alignment");
            ImGui::Indent();
            ImGui::Text("Total: 0x%X", uclass->GetPropertiesSize());

            std::vector<UClass*> all_super_structs{};

            while (uclass)
            {
                all_super_structs.emplace_back(uclass);
                auto current_class = uclass;
                uclass = uclass->GetSuperClass();
                if (uclass == current_class) { break; }
            }

            for (auto it = all_super_structs.begin(); it != all_super_structs.end(); ++it)
            {
                auto super = *it;
                auto super_size = super->GetPropertiesSize();
                auto supers_super_it = it;
                ++supers_super_it;
                if (supers_super_it != all_super_structs.end())
                {
                    auto supers_super = *supers_super_it;
                    super_size -= supers_super->GetPropertiesSize();
                }
                ImGui::Text("%S: 0x%X (0x%X)", super->GetName().c_str(), super_size, super->GetPropertiesSize());
            }

            ImGui::Unindent();
        }

        render_properties();
    }

    static auto render_fname(FName name) -> void
    {
        ImGui::Text("ComparisonIndex: 0x%X", name.GetComparisonIndex());
#ifdef WITH_CASE_PRESERVING_NAME
        ImGui::Text("DisplayIndex: 0x%X", name.GetDisplayIndex());
#endif
        ImGui::Text("Number: 0x%X", name.GetNumber());
    }

    auto LiveView::render_info_panel_as_property(FProperty* property) -> void
    {
        if (!property)
        {
            ImGui::Text("Property is nullptr.");
            return;
        }

        FProperty* next_property_to_render{};
        bool tried_to_open_nullptr_property{};
        auto property_full_name = property->GetFullName();

        ImGui::Text("Selected: %S", property->GetName().c_str());
        ImGui::Text("Address: %016llX", std::bit_cast<uintptr_t>(property));
        if (ImGui::BeginPopupContextItem(to_string(property_full_name).c_str()))
        {
            if (ImGui::MenuItem("Copy address"))
            {
                ImGui::SetClipboardText(std::format("{:016X}", std::bit_cast<uintptr_t>(property)).c_str());
            }
            ImGui::EndPopup();
        }
        ImGui::Text("Class: %S", property->GetClass().GetName().c_str());
        ImGui::Text("Path: %S", property->GetPathName().c_str());

        ImGui::Separator();

        ImGui::Text("ArrayDim: %i (0x%X)", property->GetArrayDim(), property->GetArrayDim());
        ImGui::Text("ElementSize: %i (0x%X)", property->GetElementSize(), property->GetElementSize());
        auto property_flags = property->GetPropertyFlags();
        ImGui::Text("PropertyFlags (Raw): 0x%llX", property_flags);
        if (ImGui::BeginPopupContextItem("property_raw_flags_menu"))
        {
            if (ImGui::MenuItem("Copy raw flags"))
            {
                ImGui::SetClipboardText(std::format("0x{:X}", static_cast<uint64_t>(property_flags)).c_str());
            }
            ImGui::EndPopup();
        }
        PropertyFlagsStringifier property_flags_stringifier{property_flags};
        size_t current_flag_line_count{};
        std::string current_flag_line{};
        std::string all_flags{};
        auto create_menu_for_copy_flags = [&](size_t menu_index) {
            if (ImGui::BeginPopupContextItem(std::format("property_flags_menu_{}", menu_index).c_str()))
            {
                if (ImGui::MenuItem("Copy flags"))
                {
                    std::string flags_string_for_copy{};
                    std::for_each(property_flags_stringifier.flag_parts.begin(), property_flags_stringifier.flag_parts.end(), [&](const std::string& flag_part) {
                        if (!flags_string_for_copy.empty())
                        {
                            flags_string_for_copy.append(" | ");
                        }
                        flags_string_for_copy.append(std::move(flag_part));
                    });
                    ImGui::SetClipboardText(flags_string_for_copy.c_str());
                }
                ImGui::EndPopup();
            }
        };
        ImGui::Text("PropertyFlags:");
        create_menu_for_copy_flags(99); // 'menu_index' of '99' because we'll never reach 99 lines of flags and we can't use '0' as that'll be used in the loop below.
        ImGui::Indent();
        for (size_t i = 0; i < property_flags_stringifier.flag_parts.size(); ++i)
        {
            const auto& property_flag_part_string = property_flags_stringifier.flag_parts[i];
            const auto last_element_in_vector = i + 1 >= property_flags_stringifier.flag_parts.size();

            if (current_flag_line_count < 3)
            {
                current_flag_line.append(std::move(property_flag_part_string) + (last_element_in_vector ? "" : " | "));
                ++current_flag_line_count;
            }

            if (current_flag_line_count >= 3 || last_element_in_vector)
            {
                ImGui::Text("%s", current_flag_line.c_str());
                create_menu_for_copy_flags(i);
                all_flags.append(current_flag_line);
                current_flag_line.clear();
                current_flag_line_count = 0;
            }
        }
        ImGui::Unindent();
        ImGui::Text("RepIndex: %i (0x%X)", property->GetRepIndex(), property->GetRepIndex());
        ImGui::Text("OffsetInternal: %i (0x%X)", property->GetOffset_Internal(), property->GetOffset_Internal());
        ImGui::Text("RepNotifyFunc: %S", property->GetRepNotifyFunc().ToString().c_str());
        if (ImGui::IsItemHovered())
        {
            ImGui::BeginTooltip();
            render_fname(property->GetRepNotifyFunc());
            ImGui::EndTooltip();
        }

        auto render_property_pointer = [](std::string_view pointer_name, FProperty* property) {
            ImGui::Text("%s: %p %S", pointer_name.data(), property, property ? property->GetFullName().c_str() : STR("None"));
            return property;
        };
        int go_to_property_menu_count{};
        auto create_go_to_property_menu = [&](FProperty* goto_to_property) {
            if (ImGui::BeginPopupContextItem(std::format("property_link_next_menu_{}", go_to_property_menu_count++).c_str()))
            {
                if (ImGui::MenuItem("Go to property"))
                {
                    if (!goto_to_property)
                    {
                        tried_to_open_nullptr_property = true;
                    }
                    else
                    {
                        // Cannot go to another property in the middle of rendering property.
                        // Doing so would cause the property member-variables to be looked up on the wrong property.
                        // To fix this, we save which property we want to go to and then we go to it after we're done rendering.
                        next_property_to_render = goto_to_property;
                    }
                }
                ImGui::EndPopup();
            }
        };
        create_go_to_property_menu(render_property_pointer("PropertyLinkNext", property->GetPropertyLinkNext()));
        create_go_to_property_menu(render_property_pointer("NextRef", property->GetNextRef()));
        create_go_to_property_menu(render_property_pointer("DestructorLinkNext", property->GetDestructorLinkNext()));
        create_go_to_property_menu(render_property_pointer("PostConstructLinkNext", property->GetPostConstructLinkNext()));

        if (tried_to_open_nullptr_property)
        {
            ImGui::OpenPopup("PropertyOpenNullptrWarning");
            m_modal_tried_to_open_nullptr_object_is_open = true;
        }

        if (ImGui::BeginPopupModal("PropertyOpenNullptrWarning", &m_modal_tried_to_open_nullptr_object_is_open, ImGuiWindowFlags_NoResize))
        {
            ImGui::Text("Cannot go to property because it's nullptr");
            ImGui::EndPopup();
        }

        if (next_property_to_render)
        {
            select_property(0, next_property_to_render, AffectsHistory::Yes);
        }
    }

    auto LiveView::render_info_panel() -> void
    {
        ImGui::BeginChild("LiveView_InfoPanel", {-14.0f, m_bottom_size}, true, ImGuiWindowFlags_HorizontalScrollbar);

        bool should_select_object{};
        bool select_previous_object{};

        if (ImGui::Button("<<<"))
        {
            should_select_object = true;
            select_previous_object = true;
        }
        ImGui::SameLine();
        if (ImGui::Button(">>>"))
        {
            should_select_object = true;
            select_previous_object = false;
        }

        ImGui::Separator();

        auto currently_selected_object = get_selected_object_or_property();
        if (currently_selected_object.is_object)
        {
            render_info_panel_as_object(currently_selected_object.object_item, currently_selected_object.object);
        }
        else
        {
            render_info_panel_as_property(currently_selected_object.property);
        }

        ImGui::EndChild();

        if (should_select_object)
        {
            if (select_previous_object)
            {
                if (s_currently_selected_object_index <= 0 || s_currently_selected_object_index - 1 <= 0) { return; }
                select_object(s_currently_selected_object_index - 1, nullptr, nullptr, AffectsHistory::No);
            }
            else
            {
                if (s_currently_selected_object_index + 1 >= s_object_view_history.size()) { return; }
                select_object(s_currently_selected_object_index + 1, nullptr, nullptr, AffectsHistory::No);
            }
        }
    }

    static auto search_field_always_callback(ImGuiInputTextCallbackData* data) -> int
    {
        auto typed_this = static_cast<LiveView*>(data->UserData);
        if (typed_this->was_search_field_clear_requested() && !typed_this->was_search_field_cleared())
        {
            strncpy_s(data->Buf, 1, "", 1);
            data->BufTextLen = 0;
            data->BufDirty = true;
            typed_this->set_search_field_cleared(true);
        }
        return 1;
    }

    auto LiveView::process_watches() -> void
    {
        for (auto& watch : s_watches)
        {
            if (!watch.enabled) { continue; }

            FString live_value_fstring{};
            watch.property->ExportTextItem(live_value_fstring, watch.property->ContainerPtrToValuePtr<void>(watch.container), nullptr, nullptr, 0);
            auto live_value_string = StringType{live_value_fstring.GetCharArray()};

            if (watch.property_value == live_value_string) { continue; }

            watch.property_value = std::move(live_value_string);

            const auto when_as_string = std::format(STR("{:%H:%M:%S}"), std::chrono::system_clock::now());
            watch.history.append(to_string(when_as_string + STR(" ") + watch.property_value + STR("\n")));

            if (watch.write_to_file)
            {
                watch.output.send(STR("{}\n"), watch.property_value);
            }
        }
    }

    auto LiveView::render() -> void
    {
        if (!UnrealInitializer::StaticStorage::bIsInitialized) { return; }
        if (!m_is_initialized) { return; }

        if (!s_watches_loaded_from_disk)
        {
            load_watches_from_disk();
            s_watches_loaded_from_disk = true;
        }

        ImGui::PushItemWidth(-14.0f);
        bool push_inactive_text_color = !m_search_field_cleared;
        if (push_inactive_text_color) { ImGui::PushStyleColor(ImGuiCol_Text, g_imgui_text_inactive_color.Value); }
        if (ImGui::InputText("##Search by name", m_search_by_name_buffer, m_search_buffer_capacity, ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackAlways, &search_field_always_callback, this))
        {
            std::string search_buffer{m_search_by_name_buffer};
            if (search_buffer.empty())
            {
                Output::send(STR("Search all chunks\n"));
                s_name_to_search_by.clear();
                m_object_iterator = &LiveView::guobjectarray_iterator;
                m_is_searching_by_name = false;
            }
            else
            {
                Output::send(STR("Search for: {}\n"), search_buffer.empty() ? STR("") : to_wstring(search_buffer));
                s_name_to_search_by = search_buffer;
                m_object_iterator = &LiveView::guobjectarray_by_name_iterator;
                m_is_searching_by_name = true;
                search_by_name();
            }
        }
        if (push_inactive_text_color) { ImGui::PopStyleColor(); }
        ImGui::PopItemWidth();

        if (!m_is_searching_by_name && m_search_field_clear_requested && !ImGui::IsItemActive())
        {
            strncpy_s(m_search_by_name_buffer, m_default_search_buffer.size() + sizeof(char), m_default_search_buffer.data(), m_default_search_buffer.size() + sizeof(char));
            m_search_field_clear_requested = false;
            m_search_field_cleared = false;
        }

        if (ImGui::IsItemClicked())
        {
            if (!m_is_searching_by_name)
            {
                m_search_field_clear_requested = true;
            }
        }

        m_bottom_size = (ImGui::GetContentRegionMaxAbs().y - m_top_size) - 94.0f;
        ImGui_Splitter(false, 4.0f, &m_top_size, &m_bottom_size, 32.0f, 32.0f, -14.0f);

        ImGui::PushStyleColor(ImGuiCol_ChildBg, ImVec4{0.156f, 0.156f, 0.156f, 1.0f});
        ImGui::BeginChild("LiveView_TreeView", {-14.0f, m_top_size}, true);

        auto do_iteration = [&](int32_t int_data_1 = 0, int32_t int_data_2 = 0) {
            ((*this).*((*this).m_object_iterator))(int_data_1, int_data_2, [&](UObject* object) {
                auto tree_node_name = std::string{get_object_full_name(object)};

                auto render_context_menu = [&]{
                    if (ImGui::BeginPopupContextItem(tree_node_name.c_str()))
                    {
                        if (ImGui::MenuItem("Copy Full Name"))
                        {
                            Output::send(STR("Copy Full Name: {}\n"), object->GetFullName());
                            ImGui::SetClipboardText(tree_node_name.c_str());
                        }
                        ImGui::EndPopup();
                    }
                };

                if (ImGui_TreeNodeEx(tree_node_name.c_str(), object))
                {
                    m_currently_opened_tree_node = object;
                    m_opened_tree_nodes.emplace(object);

                    // For some reason, the menu has to be rendered both if the node is open and if it's closed.
                    // Rendering after the 'TreeNodeEx' if-statement only works if the node is closed.
                    render_context_menu();

                    if (auto as_struct = Cast<UStruct>(object); as_struct)
                    {
                        render_struct_sub_tree_hierarchy(as_struct);
                    }
                    else
                    {
                        render_object_sub_tree_hierarchy(object);
                    }

                    ImGui::TreePop();
                }
                else
                {
                    if (ImGui::IsItemClicked())
                    {
                        select_object(0, object->GetObjectItem(), object, AffectsHistory::Yes);
                    }
                }
                collapse_all_except(m_currently_opened_tree_node);
                render_context_menu();
            });
        };

        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, {0.0f, 0.0f});
        if (m_is_searching_by_name)
        {
            do_iteration();
        }
        else
        {
            auto num_elements = UObjectArray::GetNumElements();
            int num_total_chunks = (num_elements / s_max_elements_per_chunk) + (num_elements % s_max_elements_per_chunk == 0 ? 0 : 1);
            for (int i = 0; i < num_total_chunks; ++i)
            {
                if (ImGui_TreeNodeEx(std::format("Chunk #{}", i).c_str(), i + s_chunk_id_start, ImGuiTreeNodeFlags_CollapsingHeader))
                {
                    ::RC::GUI::collapse_all_except(i + s_chunk_id_start);
                    auto start = s_max_elements_per_chunk * i;
                    auto end = start + s_max_elements_per_chunk;
                    do_iteration(start, end);
                }
            }
        }
        ImGui::PopStyleVar();

        ImGui::EndChild();
        ImGui::PopStyleColor();

        render_info_panel();
    }

    static auto toggle_all_watches(bool check) -> void
    {
        for (auto& watch : LiveView::s_watches)
        {
            watch.enabled = check;
        }
    }

    auto LiveView::render_watches() -> void
    {
        if (!s_watches_loaded_from_disk)
        {
            load_watches_from_disk();
            s_watches_loaded_from_disk = true;
        }

        ImGui::BeginChild("watch_render_frame", {-13.0f, -35.0f});

        if (ImGui::Button("All Off"))
        {
            toggle_all_watches(false);
        }
        ImGui::SameLine();
        if (ImGui::Button("All On"))
        {
            toggle_all_watches(true);
        }

        static int num_columns = 3;
        ImGui::PushStyleVar(ImGuiStyleVar_CellPadding, {2.0f, 2.0f});
        if (ImGui::BeginTable("watch_table", num_columns, ImGuiTableFlags_Borders | ImGuiTableFlags_NoPadOuterX))
        {
            ImGui::TableSetupColumn("Controls", ImGuiTableColumnFlags_WidthFixed, 60.0f);
            ImGui::TableSetupColumn("Watch Identifier", ImGuiTableColumnFlags_WidthStretch);
            ImGui::TableSetupColumn("##watch-from-disk", ImGuiTableColumnFlags_WidthFixed, 21.0f);
            ImGui::TableHeadersRow();

            for (auto& watch : s_watches)
            {
                ImGui::TableNextRow();
                ImGui::TableNextColumn();
                ImGui::Checkbox(to_string(std::format(STR("##watch-on-off-{}"), watch.hash)).c_str(), &watch.enabled);
                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("On/Off");
                    ImGui::EndTooltip();
                }
                ImGui::SameLine(0.0f, 2.0f);
                ImGui::Checkbox(to_string(std::format(STR("##watch-write-to-file-{}"), watch.hash)).c_str(), &watch.write_to_file);
                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Write to file");
                    ImGui::EndTooltip();
                }
                ImGui::SameLine(0.0f, 2.0f);
                if (!watch.show_history)
                {
                    ImGui::PushID(std::format("button_open_history_{}", watch.hash).c_str());
                    if (ImGui::Button("+", {20.0f, 0.0f}))
                    {
                        watch.show_history = true;
                    }
                    ImGui::PopID();
                }
                else
                {
                    ImGui::PushID(std::format("button_close_history_{}", watch.hash).c_str());
                    if (ImGui::Button("-", {20.0f, 0.0f}))
                    {
                        watch.show_history = false;
                    }
                    ImGui::PopID();
                }
                ImGui::TableNextColumn();
                ImGui::Text("%S.%S", watch.object_name.c_str(), watch.property_name.c_str());
                if (watch.show_history)
                {
                    ImGui::PushID(std::format("history_{}", watch.hash).c_str());
                    ImGui::InputTextMultiline("##history", &watch.history, {-13.0f, 0.0f}, ImGuiInputTextFlags_ReadOnly);
                    ImGui_AutoScroll("##history", &watch.history_previous_max_scroll_y);
                    ImGui::PopID();
                }
                ImGui::TableNextColumn();
                if (ImGui::Checkbox(to_string(std::format(STR("##watch-from-disk-{}"), watch.hash)).c_str(), &watch.load_on_startup))
                {
                    save_watches_to_disk();
                }
                ImGui::SetNextWindowSize({690.0f, 0.0f});
                if (ImGui::BeginPopupContextItem(to_string(std::format(STR("##watch-from-disk-settings-popup-{}"), watch.hash)).c_str()))
                {
                    ImGui::Text("Acquisition Method");
                    ImGui::Text("This determines how the watch will be reacquired.");
                    ImGui::RadioButton("StaticFindObject", std::bit_cast<int*>(&watch.acquisition_method), static_cast<int>(Watch::AcquisitionMethod::StaticFindObject));
                    ImGui::RadioButton("FindFirstOf", std::bit_cast<int*>(&watch.acquisition_method), static_cast<int>(Watch::AcquisitionMethod::FindFirstOf));
                    save_watches_to_disk();
                    ImGui::EndPopup();
                }
                if (ImGui::IsItemHovered())
                {
                    ImGui::BeginTooltip();
                    ImGui::Text("Auto-create on startup.\nRight-click for options.");
                    ImGui::EndTooltip();
                }
            }

            ImGui::EndTable();
            ImGui::PopStyleVar();
        }
        ImGui::EndChild();
    }
}

```

`src/GUI/Windows.cpp`:

```cpp
#include <GUI/Windows.hpp>

#include <imgui.h>
#include <backends/imgui_impl_win32.h>
#include <tchar.h>

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <Windows.h>

// Forward declare message handler from imgui_impl_win32.cpp
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

namespace RC::GUI
{
    static HWND s_hwnd{};
    static WNDCLASSEX s_wc{};
    static GfxBackendBase* s_gfx_backend{};

    LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

    auto Backend_Windows::init() -> void
    {
        ImGui_ImplWin32_Init(s_hwnd);
    }

    auto Backend_Windows::imgui_backend_newframe() -> void
    {
        ImGui_ImplWin32_NewFrame();
    }

    auto Backend_Windows::create_window() -> void
    {
        //ImGui_ImplWin32_EnableDpiAwareness()
        s_wc.cbSize = sizeof(WNDCLASSEX);
        //wc.style = CS_CLASSDC;
        s_wc.style = CS_HREDRAW | CS_VREDRAW;
        s_wc.lpfnWndProc = WndProc;
        s_wc.cbClsExtra = 0L;
        s_wc.cbWndExtra = 0L;
        s_wc.hInstance = GetModuleHandle(NULL);
        s_wc.hIcon = NULL;
        s_wc.hCursor = NULL;
        //wc.hbrBackground = NULL;
        s_wc.hbrBackground = CreateSolidBrush(RGB(0, 0, 0));
        s_wc.lpszMenuName = NULL;
        s_wc.lpszClassName = _T("UE4SS Debugging Tools");
        s_wc.hIconSm = NULL;
        ::RegisterClassEx(&s_wc);
        s_hwnd = ::CreateWindow(s_wc.lpszClassName, _T("UE4SS Debugging Tools"), WS_OVERLAPPEDWINDOW, 100, 100, 1280, 800, NULL, NULL, s_wc.hInstance, NULL);

        if (!m_gfx_backend->create_device())
        {
            m_gfx_backend->cleanup_device();
            ::UnregisterClass(s_wc.lpszClassName, s_wc.hInstance);
            throw std::runtime_error{"Was unable to create d3d device"};
        }

        ::ShowWindow(s_hwnd, SW_SHOWDEFAULT);
        ::UpdateWindow(s_hwnd);
    }

    auto Backend_Windows::exec_message_loop(bool* exit_requested) -> void
    {
        MSG msg;
        while (::PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
            if (msg.message == WM_QUIT)
            {
                *exit_requested = true;
            }
        }
    }

    auto Backend_Windows::shutdown() -> void
    {
        ImGui_ImplWin32_Shutdown();
    }

    auto Backend_Windows::cleanup() -> void
    {
        ::DestroyWindow(s_hwnd);
        ::UnregisterClass(s_wc.lpszClassName, s_wc.hInstance);
    }

    auto Backend_Windows::get_window_handle() -> void*
    {
        return s_hwnd;
    }

    auto Backend_Windows::get_window_rect() -> WindowRect
    {
        RECT current_window_rect{};
        GetWindowRect(s_hwnd, &current_window_rect);
        return {current_window_rect.left, current_window_rect.top, current_window_rect.right, current_window_rect.bottom};
    }

    auto Backend_Windows::on_gfx_backend_set() -> void
    {
        s_gfx_backend = m_gfx_backend;
    }

    // Win32 message handler
    // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
    // - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application, or clear/overwrite your copy of the mouse data.
    // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application, or clear/overwrite your copy of the keyboard data.
    // Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
    LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        {
            return true;
        }

        switch (msg)
        {
            case WM_SIZE:
                s_gfx_backend->handle_window_resize(wParam, lParam);
                return 0;
            case WM_SYSCOMMAND:
                if ((wParam & 0xfff0) == SC_KEYMENU)
                { // Disable ALT application menu
                    return 0;
                }
                break;
            case WM_DESTROY:
                ::PostQuitMessage(0);
                return 0;
        }
        return ::DefWindowProc(hWnd, msg, wParam, lParam);
    }
}

```

`src/LuaCustomMemberFunctions.cpp`:

```cpp
#include <LuaCustomMemberFunctions.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <ExceptionHandling.hpp>
#include <LuaBindings/States/MainState/Main.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>

#define EMPLACE_INTO_UNREAL_PROPERTY_MAP(PropertyTypeName) \
auto PropertyTypeName##_name = FName(STR(#PropertyTypeName)); \
if (PropertyTypeName##_name == NAME_None) \
{ \
    throw std::runtime_error{"FName for '"#PropertyTypeName"' was NAME_None"}; \
} \
g_unreal_property_to_lua.emplace(PropertyTypeName##_name, &PropertyTypeName##_to_lua); \
g_unreal_property_from_lua.emplace(PropertyTypeName##_name, &PropertyTypeName##_from_lua);

namespace RC::UnrealRuntimeTypes
{
    using namespace ::RC::Unreal;

    std::unordered_map<FName, void (*)(lua_State*, ToLuaParams)> g_unreal_property_to_lua{};
    std::unordered_map<FName, void (*)(lua_State*, FromLuaParams)> g_unreal_property_from_lua{};

    auto populate_unreal_property_to_lua_map() -> void
    {
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(ObjectProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(ClassProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(Int8Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(Int16Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(IntProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(Int64Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(ByteProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(UInt16Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(UInt32Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(UInt64Property)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(StructProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(ArrayProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(FloatProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(DoubleProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(BoolProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(EnumProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(WeakObjectProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(NameProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(TextProperty)
        EMPLACE_INTO_UNREAL_PROPERTY_MAP(StrProperty)
    }

    auto ObjectProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_UObjectMetatable", ::RC::Unreal::UObject>(lua_state, params.base_no_processing_required ? params.base : *params.property->ContainerPtrToValuePtr<UObject*>(params.base), params.pointer_depth);
    }
    auto ClassProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_UClassMetatable", ::RC::Unreal::UClass>(lua_state, *params.property->ContainerPtrToValuePtr<UClass*>(params.base));
    }
    auto Int8Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<int8_t>(params.base));
    }
    auto Int16Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<int16_t>(params.base));
    }
    auto IntProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<int32_t>(params.base));
    }
    auto Int64Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<int64_t>(params.base));
    }
    auto ByteProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        if (params.should_containerize)
        {
            LuaBindings::lua_uint8_t_to_lua_from_heap(lua_state, params.property->ContainerPtrToValuePtr<uint8_t>(params.base), params.pointer_depth);
        }
        else
        {
            lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<uint8_t>(params.base));
        }
    }
    auto UInt16Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<uint16_t>(params.base));
    }
    auto UInt32Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<uint32_t>(params.base));
    }
    auto UInt64Property_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushinteger(lua_state, *params.property->ContainerPtrToValuePtr<uint64_t>(params.base));
    }
    auto StructProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        auto struct_property = static_cast<FStructProperty*>(params.property);
        void* script_struct_ptr{};
        if (params.should_copy_script_struct_contents)
        {
            auto script_struct = struct_property->GetStruct();
            auto struct_ops = script_struct->GetCppStructOps();
            script_struct_ptr = FMemory::Malloc(struct_ops->GetSize(), struct_ops->GetAlignment());
            script_struct->CopyScriptStruct(script_struct_ptr, struct_property->ContainerPtrToValuePtr<void*>(params.base));
        }
        else
        {
            script_struct_ptr = params.base;
        }
        LuaUScriptStruct lua_script_struct{
            /*.base = */static_cast<UObject*>(script_struct_ptr),
            /*.struct_property = */struct_property,
            /*.script_struct = */struct_property->GetStruct(),
            /*.is_user_constructed = */false,
        };
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__UnrealRuntimeTypes_LuaUScriptStructMetatable", LuaUScriptStruct, false, true>(lua_state, lua_script_struct, 0);
    }
    auto ArrayProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        auto property = static_cast<FArrayProperty*>(params.property);
        ArrayTest array_test{
                params.base_no_processing_required ? static_cast<FScriptArray*>(params.base) : property->ContainerPtrToValuePtr<FScriptArray>(params.base),
                static_cast<size_t>(property->GetElementSize()),
                static_cast<size_t>(property->GetMinAlignment()),
                "",
                property->GetInner()->IsA<FObjectProperty>(),
                property,
        };
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__UnrealRuntimeTypes_ArrayTestMetatable", ::RC::UnrealRuntimeTypes::ArrayTest, false, true>(lua_state, array_test, 0);
    }
    auto FloatProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushnumber(lua_state, *params.property->ContainerPtrToValuePtr<float>(params.base));
    }
    auto DoubleProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        lua_pushnumber(lua_state, *params.property->ContainerPtrToValuePtr<double>(params.base));
    }
    auto BoolProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        auto property = static_cast<FBoolProperty*>(params.property);
        lua_pushboolean(lua_state, property->GetPropertyValueInContainer(params.base));
    }
    auto EnumProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        auto property = static_cast<FEnumProperty*>(params.property);
        auto the_enum = property->GetEnum();

        lua_newtable(lua_state);

        the_enum->ForEachName([&](FName key, uint8 value) {
            lua_pushstring(lua_state, to_string(key.ToString()).c_str());
            lua_pushinteger(lua_state, value);
            lua_rawset(lua_state, -3);
            return LoopAction::Continue;
        });

        auto enum_lua_name_back_compat = std::format("Enum_{}", to_string(property->GetName()));
        auto enum_lua_name = std::format("Enum_{}", to_string(the_enum->GetName()));

        lua_pushvalue(lua_state, -1);
        lua_setglobal(lua_state, enum_lua_name_back_compat.c_str());
        lua_setglobal(lua_state, enum_lua_name.c_str());

        lua_pushnumber(lua_state, *property->ContainerPtrToValuePtr<uint8_t>(params.base));
    }
    auto WeakObjectProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FWeakObjectPtrMetatable", ::RC::Unreal::FWeakObjectPtr>(lua_state, params.property->ContainerPtrToValuePtr<FWeakObjectPtr>(params.base));
    }
    auto NameProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FNameMetatable", ::RC::Unreal::FName>(lua_state, params.property->ContainerPtrToValuePtr<FName>(params.base));
    }
    auto TextProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FTextMetatable", ::RC::Unreal::FText>(lua_state, params.property->ContainerPtrToValuePtr<FText>(params.base));
    }
    auto StrProperty_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FStringMetatable", ::RC::Unreal::FString>(lua_state, params.property->ContainerPtrToValuePtr<FString>(params.base));
    }
    auto function_to_lua(lua_State* lua_state, ToLuaParams params) -> void
    {
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_UFunctionMetatable", ::RC::Unreal::UFunction>(lua_state, params.function);
    }

    auto ObjectProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<UObject**>(params.base) : params.property->ContainerPtrToValuePtr<UObject*>(params.base);
        auto new_value = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_UObjectMetatable", ::RC::Unreal::UObject*, LuaBindings::convertible_to___RC__Unreal_UObject>(lua_state, params.lua_stack_index);
        *property_value_ptr = new_value;
    }
    auto ClassProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<UClass**>(params.base) : params.property->ContainerPtrToValuePtr<UClass*>(params.base);
        auto new_value = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_UClassMetatable", ::RC::Unreal::UClass*, LuaBindings::convertible_to___RC__Unreal_UClass>(lua_state, params.lua_stack_index);
        *property_value_ptr = new_value;
    }
    auto Int8Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<int8_t*>(params.base) : params.property->ContainerPtrToValuePtr<int8_t>(params.base);
        auto new_value = static_cast<int8_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto Int16Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<int16_t*>(params.base) : params.property->ContainerPtrToValuePtr<int16_t>(params.base);
        auto new_value = static_cast<int16_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto IntProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<int32_t*>(params.base) : params.property->ContainerPtrToValuePtr<int32_t>(params.base);
        if (lua_isuserdata(lua_state, 1))
        {
            *params.out_data = lua_touserdata(lua_state, 1);
            *property_value_ptr = *static_cast<int32_t*>(*params.out_data);
        }
        else
        {
            *property_value_ptr = static_cast<int32_t>(lua_tointeger(lua_state, 1));
        }
    }
    auto Int64Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<int64_t*>(params.base) : params.property->ContainerPtrToValuePtr<int64_t>(params.base);
        auto new_value = static_cast<int64_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto ByteProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<uint8_t*>(params.base) : params.property->ContainerPtrToValuePtr<uint8_t>(params.base);
        auto new_value = static_cast<uint8_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto UInt16Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<uint16_t*>(params.base) : params.property->ContainerPtrToValuePtr<uint16_t>(params.base);
        auto new_value = static_cast<uint16_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto UInt32Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<uint32_t*>(params.base) : params.property->ContainerPtrToValuePtr<uint32_t>(params.base);
        auto new_value = static_cast<uint32_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto UInt64Property_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<uint64_t*>(params.base) : params.property->ContainerPtrToValuePtr<uint64_t>(params.base);
        auto new_value = static_cast<uint64_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto StructProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        if (!params.should_copy_script_struct_contents && !params.out_data)
        {
            luaL_error(lua_state, "A ScriptStruct cannot be modified, please specify a property of this ScriptStruct to modify.");
        }

        auto& script_struct_ref = LuaBindings::lua_util_userdata_Get<"__RC__UnrealRuntimeTypes_LuaUScriptStructMetatable", ::RC::UnrealRuntimeTypes::LuaUScriptStruct&, LuaBindings::convertible_to___RC__UnrealRuntimeTypes_LuaUScriptStruct>(lua_state, params.lua_stack_index);
        script_struct_ref.script_struct->CopyScriptStruct(params.property->ContainerPtrToValuePtr<void*>(params.base), script_struct_ref.base);
        if (params.out_data)
        {
            *params.out_data = script_struct_ref.base;
        }
    }
    auto ArrayProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void/* { luaL_error(lua_state, "newindex handler not yet implemented (ArrayProperty)"); }*/
    {
        auto array_property = static_cast<FArrayProperty*>(params.property);
        auto* script_array_ref = LuaBindings::lua_util_userdata_Get<"__RC__UnrealRuntimeTypes_ArrayTestMetatable", ::RC::UnrealRuntimeTypes::ArrayTest*, LuaBindings::convertible_to___RC__UnrealRuntimeTypes_ArrayTest>(lua_state, params.lua_stack_index);
        if (params.out_data)
        {
            // Destructively overrides whatever values these members used to hold.
            // They are supposed to be default constructed by Lua.
            // I'm not sure if this code could ever execute in some other circumstance.
            script_array_ref->Property = array_property;
            script_array_ref->ElementSize = array_property->GetElementSize();
            script_array_ref->ElementMinAlignment = array_property->GetMinAlignment();
            *params.out_data = script_array_ref->GetScriptArray();
        }
        else
        {
            Output::send(STR("ArrayProperty_from_lua not yet implemented for __newindex."));
        }

        params.property->ContainerPtrToValuePtr<int16_t>(params.base);
        script_array_ref->Property->CopyCompleteValue(params.property->ContainerPtrToValuePtr<void*>(params.base), script_array_ref->GetScriptArray());
    }
    auto FloatProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<float*>(params.base) : params.property->ContainerPtrToValuePtr<float>(params.base);
        auto new_value = static_cast<float>(lua_tonumber(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto DoubleProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<double*>(params.base) : params.property->ContainerPtrToValuePtr<double>(params.base);
        auto new_value = static_cast<double>(lua_tonumber(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto BoolProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        static_cast<FBoolProperty*>(params.property)->SetPropertyValueInContainer(params.base, lua_toboolean(lua_state, 1));
    }
    auto EnumProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<uint8_t*>(params.base) : params.property->ContainerPtrToValuePtr<uint8_t>(params.base);
        auto new_value = static_cast<uint8_t>(lua_tointeger(lua_state, 1));
        *property_value_ptr = new_value;
    }
    auto WeakObjectProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void { luaL_error(lua_state, "newindex handler not yet implemented (WeakObjectProperty)"); }
    auto NameProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<FName*>(params.base) : params.property->ContainerPtrToValuePtr<FName>(params.base);
        *property_value_ptr = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_FNameMetatable", ::RC::Unreal::FName, LuaBindings::convertible_to___RC__Unreal_FName>(lua_state, params.lua_stack_index);
    }
    auto TextProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<FText*>(params.base) : params.property->ContainerPtrToValuePtr<FText>(params.base);
        *property_value_ptr = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_FTextMetatable", ::RC::Unreal::FText, LuaBindings::convertible_to___RC__Unreal_FText>(lua_state, params.lua_stack_index);
    }
    auto StrProperty_from_lua(lua_State* lua_state, FromLuaParams params) -> void
    {
        auto property_value_ptr = params.base_no_processing_required ? static_cast<FString*>(params.base) : params.property->ContainerPtrToValuePtr<FString>(params.base);
        *property_value_ptr = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_FStringMetatable", ::RC::Unreal::FString, LuaBindings::convertible_to___RC__Unreal_FString>(lua_state, params.lua_stack_index);
    }
}

namespace RC
{
    using namespace ::RC::Unreal;

    std::unordered_map<FName, UScriptStruct*> g_script_struct_cache_map{};

    auto setup_script_struct_cache_map() -> void
    {
        UObjectGlobals::ForEachUObject([](UObject* object, ...) {
            if (auto as_script_struct = Cast<UScriptStruct>(object); as_script_struct)
            {
                g_script_struct_cache_map.emplace(as_script_struct->GetNamePrivate(), as_script_struct);
            }
            return LoopAction::Continue;
        });
    }

    auto setup_global_metatable(lua_State* lua_state) -> void
    {
        lua_getglobal(lua_state, "_G");

        lua_newtable(lua_state);
        lua_pushliteral(lua_state, "__index");
        lua_pushcclosure(lua_state, [](lua_State* lua_state) -> int {
            // Stack
            // -2 (1): _G
            // -1 (2): string (key to access in _G, or lookup in the reflection system)

            if (!lua_isstring(lua_state, -1))
            {
                lua_pushnil(lua_state);
                return 1;
            }

            auto key = to_wstring(lua_tostring(lua_state, -1));
            if (lua_rawget(lua_state, -2) != LUA_TNIL)
            {
                return 1;
            }
            else
            {
                // Stack
                // -2 (1): _G
                // -1 (2): nil (from lua_rawget)
                lua_pop(lua_state, 1);

                if (auto it = g_script_struct_cache_map.find(FName(key)); it != g_script_struct_cache_map.end())
                {
                    lua_pushlightuserdata(lua_state, it->second);
                    lua_pushcclosure(lua_state, [](lua_State* lua_state) -> int {
                        // TODO: Use the virtual ICppStructOps::Construct when the wrapper has been implemented.
                        //       For now, we'll construct it and zero-fill the entire struct.
                        auto script_struct = static_cast<UScriptStruct*>(lua_touserdata(lua_state, lua_upvalueindex(1)));
                        auto struct_ops = script_struct->GetCppStructOps();
                        auto default_constructed_script_struct = FMemory::Malloc(struct_ops->GetSize(), struct_ops->GetAlignment());
                        script_struct->InitializeStruct(default_constructed_script_struct);
                        UnrealRuntimeTypes::LuaUScriptStruct lua_script_struct{
                                /*.base = */static_cast<UObject*>(default_constructed_script_struct),
                                /*.struct_property = */nullptr,
                                /*.script_struct = */script_struct,
                                /*.is_user_constructed = */true,
                        };
                        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__UnrealRuntimeTypes_LuaUScriptStructMetatable", UnrealRuntimeTypes::LuaUScriptStruct, false, true>(lua_state, lua_script_struct, 0);
                        return 1;
                    }, 1);
                    return 1;
                }
                else
                {
                    lua_pushnil(lua_state);
                    return 1;
                }
            }
        }, 0);
        lua_rawset(lua_state, -3);

        // Stack
        // -2 (1): _G
        // -1 (2): metatable (created above)
        lua_setmetatable(lua_state, -2);
        lua_pop(lua_state, 1);
    }

    auto UObjectBase_memberr_function_wrapper_MyTestFunc(lua_State* lua_state) -> int
    {
        auto [_, self] = LuaBindings::internal___RC__Unreal__UObjectBase_get_self(lua_state);

        printf_s("MyTestFunc says hello, 'this' == %S\n", static_cast<Unreal::UObject*>(self)->GetFullName().c_str());

        return 0;
    }

    auto UObjectBase_member_function_wrapper_GetNamePrivate(lua_State* lua_state) -> int
    {
        auto [_, self] = LuaBindings::internal___RC__Unreal__UObjectBase_get_self(lua_state);

        printf_s("GetNamePrivate redirected!\n");

        auto return_value = self->GetNamePrivate();
        auto* userdata = static_cast<::RC::Unreal::FName*>(lua_newuserdatauv(lua_state, sizeof(::RC::Unreal::FName), 1));
        lua_pushinteger(lua_state, 0);
        lua_setiuservalue(lua_state, -2, 1);
        new(userdata) ::RC::Unreal::FName{return_value};
        luaL_getmetatable(lua_state, "__RC__Unreal_FNameMetatable");
        lua_setmetatable(lua_state, -2);
        return 1;
    }

    auto UObjectBase_member_function_wrapper_Cast(lua_State* lua_state) -> int
    {
        try
        {
            auto [_, self] = LuaBindings::internal___RC__Unreal__UObject_get_self(lua_state);
            auto param_1 = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_UClassMetatable", ::RC::Unreal::UClass*, LuaBindings::convertible_to___RC__Unreal_UClass>(lua_state, -1);

            auto construct_empty_object = [&]() {
                LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_UObjectMetatable", ::RC::Unreal::UObject>(lua_state, nullptr);
            };

            if (!param_1)
            {
                construct_empty_object();
                return 1;
            }

            lua_getmetatable(lua_state, 1);
            lua_pushliteral(lua_state, "__cxx_name");
            lua_rawget(lua_state, -2);
            auto cxx_name = std::string{lua_tostring(lua_state, -1)};
            lua_pop(lua_state, 2);

            if (auto type_handler = LuaBindings::lua_ue_type_name_to_lua_object_from_heap.find(to_string(param_1->GetName())); type_handler != LuaBindings::lua_ue_type_name_to_lua_object_from_heap.end())
            {
                type_handler->second(lua_state, self->IsA(param_1) ? self : nullptr, 1);
            }
            else if (auto type_handler = LuaBindings::lua_type_name_to_lua_object_from_heap.find(cxx_name); type_handler != LuaBindings::lua_type_name_to_lua_object_from_heap.end())
            {
                type_handler->second(lua_state, self->IsA(param_1) ? self : nullptr, 1);
            }
            else
            {
                construct_empty_object();
            }

            return 1;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

//#define MAKE_LAMBDA(LambdaName, LambdaIdentifier, LambdaCallOperator) \
//class RC_LAMBDA_##LambdaIdentifier \
//{ \
//public: \
//    inline /*constexpr */ void operator()() const \
//    { \
//        LambdaCallOperator \
//    } \
//     \
//private: \
//    float * d; \
//    int c; \
//public: \
//    RC_LAMBDA_##LambdaIdentifier(float * _d, int & _c) : d{_d} , c{_c} {} \
//}; \
//auto LambdaName = RC_LAMBDA_##LambdaIdentifier{}; \





    auto FField_member_function_wrapper_CastField(lua_State* lua_state) -> int
    {
        //MAKE_LAMBDA(lambda, 0, {
        //    printf_s("fhfdhfdgh\n");
        //})

        try
        {
            auto [_, self] = LuaBindings::internal___RC__Unreal__FField_get_self(lua_state);
            auto& param_1 = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_FFieldClassVariantMetatable", ::RC::Unreal::FFieldClassVariant&, LuaBindings::convertible_to___RC__Unreal_FFieldClassVariant>(lua_state, -1);

            lua_getmetatable(lua_state, 1);
            lua_pushliteral(lua_state, "__cxx_name");
            lua_rawget(lua_state, -2);
            auto cxx_name = std::string{lua_tostring(lua_state, -1)};
            lua_pop(lua_state, 2);

            if (auto type_handler = LuaBindings::lua_ue_type_name_to_lua_object_from_heap.find(to_string(param_1.GetName())); type_handler != LuaBindings::lua_ue_type_name_to_lua_object_from_heap.end())
            {
                type_handler->second(lua_state, self->IsA(param_1) ? self : nullptr, 1);
            }
            else if (auto type_handler = LuaBindings::lua_type_name_to_lua_object_from_heap.find(cxx_name); type_handler != LuaBindings::lua_type_name_to_lua_object_from_heap.end())
            {
                type_handler->second(lua_state, self->IsA(param_1) ? self : nullptr, 1);
            }
            else
            {
                LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FFieldMetatable", ::RC::Unreal::FField>(lua_state, nullptr);
                printf_s("dgdsgfsdg");
            }

            return 1;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    auto UEnum_member_function_wrapper_ForEachName(lua_State* lua_state) -> int
    {
        try
        {
            // Prologue
            auto [_, self] = LuaBindings::internal___RC__Unreal__UEnum_get_self(lua_state);

            // Native call
            luaL_argcheck(lua_state, lua_isfunction(lua_state, 1), 2, "");
            auto param_inter_1 = luaL_ref(lua_state, LUA_REGISTRYINDEX);
            auto param_function_ref_1 = [=](FName lambda_param_1, int64_t lambda_param_2) -> RC::LoopAction {
                if (lua_rawgeti(lua_state, LUA_REGISTRYINDEX, param_inter_1) != LUA_TFUNCTION)
                {
                    luaL_error(lua_state, std::format("Expected 'function' got '{}'", lua_typename(lua_state, -1)).c_str());
                }

                {
                    LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_FNameMetatable", ::RC::Unreal::FName, false>(lua_state, lambda_param_1, 0);
                }

                {
                    lua_pushinteger(lua_state, lambda_param_2);
                }

                if (int status = lua_pcall(lua_state, 2, 1, 0); status != LUA_OK)
                {
                    throw std::runtime_error{std::format("lua_pcall returned {}", LuaBindings::resolve_status_message(lua_state, status))};
                }

                if (lua_isinteger(lua_state, -1))
                {
                    return static_cast<RC::LoopAction>(lua_tointeger(lua_state, -1));
                }
                else
                {
                    return RC::LoopAction{};
                }
            };
            auto param_1 = param_function_ref_1;

            self->ForEachName(param_1);

            return 0;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    //static std::function<void()> callable_container{};
    //struct A
    //{
//
    //};
//
    //auto Test(void(*TestCallable)()) -> void
    //{
    //    TestCallable();
    //}
//
    //auto Test2(lua_State* lua_state) -> int
    //{
    //    callable_container = [&]() {
//
    //    };
//
    //    Test(callable_container.operator bool());
    //}

    auto UClass_member_function_wrapper_StaticClass(lua_State* lua_state) -> int
    {
        printf_s("UClass::StaticClass redirected!\n");

        auto return_value = ::RC::Unreal::UClass::StaticClass();
        auto* userdata = static_cast<::RC::Unreal::UClass*>(lua_newuserdatauv(lua_state, sizeof(::RC::Unreal::UClass*), 1));
        lua_pushinteger(lua_state, 1);
        lua_setiuservalue(lua_state, -2, 1);
        new(userdata) ::RC::Unreal::UClass*{return_value};
        luaL_getmetatable(lua_state, "__RC__Unreal_UClassMetatable");
        lua_setmetatable(lua_state, -2);
        return 1;
    }

    auto UObjectBase_metamethod_wrapper_Index(lua_State* lua_state, void* untyped_self) -> int
    {
        // Type has already been confirmed but we can't pass it properly because of how we store pointers to these wrapper functions.
        auto typed_self = static_cast<Unreal::UObject*>(untyped_self);

        printf_s("UObjectBase __index metamethod overridden\n");

        // Remove the 'this' userdata from the stack.
        // This is done because we already have what it holds in 'typed_self' and we don't need to do further processing on the userdata.
        lua_remove(lua_state, 1);

        File::StringType property_name_final{};
        auto property_name_ansi = lua_tostring(lua_state, 1);
        if (lua_isstring(lua_state, 1))
        {
            property_name_final = to_wstring(property_name_ansi);
        }
        else
        {
            throw std::runtime_error{"Indexing into UObjectBase and derivatives by non-string is not allowed."};
        }

        auto* function = typed_self->GetFunctionByNameInChain(property_name_final.c_str());
        FProperty* property{};
        if (!function)
        {
            property = typed_self->GetPropertyByNameInChain(property_name_final.c_str());
        }

        if (!property && !function)
        {
            luaL_error(lua_state, std::format("No function or property by name '{}' found in UObject '{}'", property_name_ansi, to_string(typed_self->GetFullName())).c_str());
        }

        if (function)
        {
            UnrealRuntimeTypes::function_to_lua(lua_state, UnrealRuntimeTypes::ToLuaParams{
                    .base = typed_self,
                    .out_data = nullptr,
                    .property = nullptr,
                    .function = function,
                    .pointer_depth = 0,
                    .base_no_processing_required = false,
                    .should_copy_script_struct_contents = false,
                    .should_containerize = false,
            });
            return 1;
        }
        else if (property)
        {
            if (auto it = UnrealRuntimeTypes::g_unreal_property_to_lua.find(property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
            {
                it->second(lua_state, UnrealRuntimeTypes::ToLuaParams{
                        .base = typed_self,
                        .out_data = nullptr,
                        .property = property,
                        .function = nullptr,
                        .pointer_depth = property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(property)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                        .base_no_processing_required = false,
                        .should_copy_script_struct_contents = false,
                        .should_containerize = false,
                });
                return 1;
            }
            else
            {
                luaL_error(lua_state, std::format("Property type '{}' not supported (for property: '{}' in '{}')", to_string(property->GetClass().GetName()), property_name_ansi, to_string(typed_self->GetFullName())).c_str());
            }
        }
        else
        {
            luaL_error(lua_state, std::format("No property or function found with name '{}' in '{}')", property_name_ansi, to_string(typed_self->GetFullName())).c_str());
        }

        return 0;
    }

    auto UObjectBase_metamethod_wrapper_NewIndex(lua_State* lua_state, void* untyped_self) -> int
    {
        // Type has already been confirmed but we can't pass it properly because of how we store pointers to these wrapper functions.
        auto typed_self = static_cast<Unreal::UObject*>(untyped_self);
        printf_s("UObjectBase __newindex metamethod overridden\n");
        lua_remove(lua_state, 1);

        File::StringType property_name_final{};
        auto property_name_ansi = lua_tostring(lua_state, 1);
        if (lua_isstring(lua_state, 1))
        {
            property_name_final = to_wstring(property_name_ansi);
        }
        else
        {
            throw std::runtime_error{"Indexing into UObjectBase and derivatives by non-string is not allowed."};
        }
        // Remove the property name string from the stack
        lua_remove(lua_state, 1);

        auto property = typed_self->GetPropertyByNameInChain(property_name_final.c_str());
        if (!property)
        {
            luaL_error(lua_state, std::format("No property by name '{}' found in UObject '{}'", property_name_ansi, to_string(typed_self->GetFullName())).c_str());
        }

        if (auto it = UnrealRuntimeTypes::g_unreal_property_from_lua.find(property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_from_lua.end())
        {
            it->second(lua_state, UnrealRuntimeTypes::FromLuaParams{
                    .base = typed_self,
                    .out_data = nullptr,
                    .property = property,
                    .function = nullptr,
                    .pointer_depth = property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(property)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                    .base_no_processing_required = false,
                    .should_copy_script_struct_contents = false,
                    .should_containerize = false,
            });
            return 1;
        }
        else
        {
            luaL_error(lua_state, std::format("Property type '{}' not supported (for property: '{}' in '{}')", to_string(property->GetClass().GetName()), property_name_ansi, to_string(typed_self->GetFullName())).c_str());
        }

        return 0;
    }

    auto UFunction_metamethod_wrapper_Call(lua_State* lua_state, void* untyped_self) -> int
    {
        // Stack (variation #1):
        // Code example #1: Character:GetMovementComponent(3, 4, 5)
        // Code example #2: GetMovementComponent(Character, 3, 4, 5)
        // -5   1       userdata        00000232A2EBC618        UFunction                   Immediately popped from the stack
        // -4   2       userdata        00000232A2EBB498        UObject, this/context       Immediately popped from the stack
        // -3   3       number  3                               Param #1                    Only popped from the stack if the UFunction has parameters
        // -2   4       number  4                               Param #2                    Only popped from the stack if the UFunction has parameters
        // -1   5       number  5                               Param #3                    Only popped from the stack if the UFunction has parameters

        auto [_, function] = LuaBindings::internal___RC__Unreal__UFunction_get_self(lua_state);
        auto [__, object] = LuaBindings::internal___RC__Unreal__UObject_get_self(lua_state);

        auto num_expected_params = function->GetNumParms();
        auto return_value_offset = function->GetReturnValueOffset();
        bool has_return_value = return_value_offset != 0xFFFF;
        if (has_return_value && num_expected_params > 0) { --num_expected_params; }

        auto params_size = function->GetParmsSize();
        uint8_t* params_raw{};
        if (params_size > 0)
        {
            if (params_size > 1024) { luaL_error(lua_state, "Tried allocating too much data on the stack"); }
            params_raw = static_cast<uint8_t*>(_alloca(params_size));
            FMemory::Memzero(params_raw, params_size);
        }

        auto num_supplied_params = static_cast<uint8_t>(lua_gettop(lua_state));
        if (num_expected_params > num_supplied_params)
        {
            luaL_error(lua_state, to_string(std::format(STR("Not enough parameters supplied for call to '{}', expected '{}', got '{}'"), function->GetFullName(), num_expected_params, num_supplied_params)).c_str());
        }
        else if (num_supplied_params > num_expected_params)
        {
            Output::send<LogLevel::Verbose>(STR("Function '{}' called with superfluous parameters.\n"), function->GetFullName());
        }

        std::vector<std::pair<FProperty*, void*>> out_params{};

        FProperty* return_value_property{};
        bool has_out_params{};
        function->ForEachProperty([&](FProperty* child) {
            if (child->HasAnyPropertyFlags(CPF_ReturnParm))
            {
                return_value_property = child;
                return LoopAction::Continue;
            }
            /*
            else if (child->HasAnyPropertyFlags(CPF_OutParm))
            {
                // TODO: Handle out params.
                //       Decide whether to break compatibility and only accept user-constructed data (i.e. UScriptStruct),
                //       or whether to still allow tables to be passed.
                //       If a table is passed, it can't simply be converted to UScriptData or anything else because I don't think we can change the value of the parameter and have the reflect in Lua.
                //       Not 100% sure though so some testing should be done.
                //       For now, table are not allowed.
                //       Currently, only UScriptStructs work.
                //       Anything else doesn't work.
                //       Need to come up with a way of handling other types.
                //       Do we need to support integers and other basic types as out params ?
                //       Based on what I've seen in Unreal Header Tool, any type can be an out param.
                //       This complicates things because now we need a handler for every type.
                //       A Lua script also needs to be able to construct something representing that type that can be passed back & fourth between Lua and C++ by reference.
                //       Maybe add a 'containerize' bool to the params of the '<Type>Property_from_lua' handlers.
                //       For example, if 'containerize' is true for '<Int8Property_from_lua', then instead of using 'lua_tointeger', it would use 'lua_int8_t_to_lua_from_heap' which is userdata 'int8_tMetaTable'.
                //       It's not a complicated type, it's just an int8_t* wrapped in userdata.
                //       It's possible that not all handlers need to do anything special.
            }
            //*/
            else
            {
                if (auto it = UnrealRuntimeTypes::g_unreal_property_from_lua.find(child->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_from_lua.end())
                {
                    auto is_out_param = child->HasAnyPropertyFlags(CPF_OutParm);
                    void* data{};
                    it->second(lua_state, UnrealRuntimeTypes::FromLuaParams{
                            .base = params_raw,
                            .out_data = is_out_param ? &data : nullptr,
                            .property = child,
                            .function = nullptr,
                            .pointer_depth = child->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(child)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                            .base_no_processing_required = false,
                            .should_copy_script_struct_contents = true,
                            .should_containerize = is_out_param,
                            .lua_stack_index = 1,
                    });
                    if (is_out_param) { out_params.emplace_back(std::pair{child, data}); }
                    lua_remove(lua_state, 1);
                }
                else
                {
                    luaL_error(lua_state, std::format("Property type '{}' not supported (for parameter: '{}' for '{}')", to_string(child->GetClass().GetName()), to_string(child->GetName()), to_string(function->GetFullName())).c_str());
                }
            }

            return LoopAction::Continue;
        });

        object->ProcessEvent(function, params_raw);

        if (!out_params.empty())
        {
            for (const auto& out_param : out_params)
            {
                auto param = out_param.first;
                auto data_ptr = out_param.second;
                if (!data_ptr) { continue; }
                param->CopyCompleteValue(data_ptr, param->ContainerPtrToValuePtr<void*>(params_raw));
            }
        }

        if (return_value_property)
        {
            if (auto it = UnrealRuntimeTypes::g_unreal_property_to_lua.find(return_value_property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
            {
                it->second(lua_state, UnrealRuntimeTypes::ToLuaParams{
                        .base = params_raw,
                        .out_data = nullptr,
                        .property = return_value_property,
                        .function = nullptr,
                        .pointer_depth = return_value_property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(return_value_property)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                        .base_no_processing_required = false,
                        .should_copy_script_struct_contents = true,
                        .should_containerize = false,
                });
                return 1;
            }
            else
            {
                luaL_error(lua_state, std::format("Property type '{}' not supported (for return property: '{}' for '{}')", to_string(return_value_property->GetClass().GetName()), to_string(return_value_property->GetName()), to_string(function->GetFullName())).c_str());
            }
        }

        Output::send<LogLevel::Error>(STR("UFunction handler not fully yet implemented\n"));
        return 0;
    }

    auto ArrayTest_metamethod_wrapper_GC(lua_State* lua_state, void* untyped_self) -> int
    {
        printf_s("ArrayTest GC\n");
        auto self = static_cast<UnrealRuntimeTypes::ArrayTest*>(untyped_self);
        self->~ArrayTest();
        return 0;
    }

    auto LuaUScriptStruct_metamethod_wrapper_Index(lua_State* lua_state, void* untyped_self) -> int
    {
        auto typed_self = static_cast<UnrealRuntimeTypes::LuaUScriptStruct*>(untyped_self);
        lua_remove(lua_state, 1);

        File::StringType property_name_final{};
        auto property_name_ansi = lua_tostring(lua_state, 1);
        if (lua_isstring(lua_state, 1))
        {
            property_name_final = to_wstring(property_name_ansi);
        }
        else
        {
            throw std::runtime_error{"Indexing into UScriptStruct and derivatives by non-string is not allowed."};
        }

        if (property_name_final == STR("type"))
        {
            lua_pushcfunction(lua_state, [](lua_State* lua_state) {
                lua_pushliteral(lua_state, "UScriptStruct");
                return 1;
            });
            return 1;
        }

        auto property = typed_self->script_struct->GetPropertyByNameInChain(property_name_final.c_str());
        if (!property)
        {
            luaL_error(lua_state, std::format("No property by name '{}' found in UScriptStruct '{}'", property_name_ansi, to_string(typed_self->script_struct->GetFullName())).c_str());
        }

        if (auto it = UnrealRuntimeTypes::g_unreal_property_to_lua.find(property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
        {
            it->second(lua_state, UnrealRuntimeTypes::ToLuaParams{
                    .base = typed_self->struct_property ? typed_self->struct_property->ContainerPtrToValuePtr<UObject*>(typed_self->base) : std::bit_cast<UObject**>(typed_self->base),
                    .out_data = nullptr,
                    .property = property,
                    .function = nullptr,
                    .pointer_depth = property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(property)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                    .base_no_processing_required = false,
                    .should_copy_script_struct_contents = false,
                    .should_containerize = false,
            });
            return 1;
        }
        else
        {
            luaL_error(lua_state, std::format("Property type '{}' not supported (for property: '{}' in '{}')", to_string(property->GetClass().GetName()), property_name_ansi, to_string(typed_self->script_struct->GetFullName())).c_str());
        }

        return 0;
    }

    auto LuaUScriptStruct_metamethod_wrapper_NewIndex(lua_State* lua_state, void* untyped_self) -> int
    {
        auto typed_self = static_cast<UnrealRuntimeTypes::LuaUScriptStruct*>(untyped_self);
        lua_remove(lua_state, 1);

        File::StringType property_name_final{};
        auto property_name_ansi = lua_tostring(lua_state, 1);
        if (lua_isstring(lua_state, 1))
        {
            property_name_final = to_wstring(property_name_ansi);
        }
        else
        {
            throw std::runtime_error{"Indexing into UScriptStruct and derivatives by non-string is not allowed."};
        }
        lua_remove(lua_state, 1);

        auto property = typed_self->script_struct->GetPropertyByNameInChain(property_name_final.c_str());
        if (!property)
        {
            luaL_error(lua_state, std::format("No property by name '{}' found in UScriptStruct '{}'", property_name_ansi, to_string(typed_self->script_struct->GetFullName())).c_str());
        }

        if (auto it = UnrealRuntimeTypes::g_unreal_property_from_lua.find(property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_from_lua.end())
        {
            it->second(lua_state, UnrealRuntimeTypes::FromLuaParams{
                    .base = typed_self->base,
                    .out_data = nullptr,
                    .property = property,
                    .function = nullptr,
                    .pointer_depth = property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(property)->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                    .base_no_processing_required = false,
                    .should_copy_script_struct_contents = false,
                    .should_containerize = false,
            });
            return 1;
        }
        else
        {
            luaL_error(lua_state, std::format("Property type '{}' not supported (for property: '{}' in '{}')", to_string(property->GetClass().GetName()), property_name_ansi, to_string(typed_self->script_struct->GetFullName())).c_str());
        }

        return 0;
    }

    auto LuaUScriptStruct_metamethod_wrapper_GC(lua_State* lua_state, void* untyped_self) -> int
    {
        printf_s("LuaUScriptStruct GC\n");
        auto self = static_cast<UnrealRuntimeTypes::LuaUScriptStruct*>(untyped_self);
        self->~LuaUScriptStruct();
        return 0;
    }

    auto ArrayTest_member_function_wrapper_GetElementAtIndex(lua_State* lua_state) -> int
    {
        try
        {
            // Prologue
            auto [_, self] = LuaBindings::internal___RC__UnrealRuntimeTypes__ArrayTest_get_self(lua_state);

            // Native call
            luaL_argcheck(lua_state, lua_isnumber(lua_state, 1), 2, "");
            auto param_1 = static_cast<int32_t>(lua_tonumber(lua_state, 1));

            auto element = self->GetElementAtIndex(param_1);

            bool unhandled_type{};
            if (self->Property)
            {
                if (auto type_handler = UnrealRuntimeTypes::g_unreal_property_to_lua.find(self->Property->GetClass().GetFName()); type_handler != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
                {
                    type_handler->second(lua_state, UnrealRuntimeTypes::ToLuaParams{
                            .base = self->GetScriptArray(),
                            .out_data = nullptr,
                            .property = self->Property,
                            .function = nullptr,
                            .pointer_depth = self->Property->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                            .base_no_processing_required = false,
                            .should_copy_script_struct_contents = false,
                            .should_containerize = false,
                    });
                }
                else
                {
                    unhandled_type = true;
                }
            }
            else if (auto type_handler = LuaBindings::lua_type_name_to_lua_object_from_heap.find(self->TypeName); type_handler != LuaBindings::lua_type_name_to_lua_object_from_heap.end())
            {
                type_handler->second(lua_state, element, self->TypeIsAlwaysPointer ? 2 : 1);
            }
            else
            {
                unhandled_type = true;
            }

            if (unhandled_type)
            {
                throw std::runtime_error{std::format("Unhandled array type: '{}'", self->TypeName)};
            }

            return 1;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    auto ArrayTest_member_function_wrapper_ForEach(lua_State* lua_state) -> int
    {
        try
        {
            // Prologue
            auto [_, aself] = LuaBindings::internal___RC__UnrealRuntimeTypes__ArrayTest_get_self(lua_state);
            auto self = aself;

            // Native call
            luaL_argcheck(lua_state, lua_isfunction(lua_state, 1), 2, "");
            auto param_inter_1 = luaL_ref(lua_state, LUA_REGISTRYINDEX);
            auto param_function_ref_1 = [&](int32_t lambda_param_1, void* lambda_param_2) -> LoopAction {
                if (lua_rawgeti(lua_state, LUA_REGISTRYINDEX, param_inter_1) != LUA_TFUNCTION)
                {
                    luaL_error(lua_state, std::format("Expected 'function' got '{}'", lua_typename(lua_state, -1)).c_str());
                }

                lua_pushnumber(lua_state, static_cast<int32_t>(lambda_param_1));

                bool unhandled_type{};
                if (self->Property)
                {
                    if (auto type_handler = UnrealRuntimeTypes::g_unreal_property_to_lua.find(self->Property->GetInner()->GetClass().GetFName()); type_handler != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
                    {
                        type_handler->second(lua_state, UnrealRuntimeTypes::ToLuaParams{
                                .base = lambda_param_2,
                                .out_data = nullptr,
                                .property = self->Property->GetInner(),
                                .function = nullptr,
                                .pointer_depth = self->Property->GetInner()->IsA<FObjectProperty>() ? 2u : 1u,
                                .base_no_processing_required = true,
                                .should_copy_script_struct_contents = false,
                                .should_containerize = true,
                        });
                    }
                    else
                    {
                        unhandled_type = true;
                    }
                }
                else if (auto type_handler = LuaBindings::lua_type_name_to_lua_object_from_heap.find(self->TypeName); type_handler != LuaBindings::lua_type_name_to_lua_object_from_heap.end())
                {
                    // lambda_param_2 == Element.
                    // Element == T*, meaning for it's UObject** for UObjects.
                    if (self->TypeIsAlwaysPointer)
                    {
                        //type_handler->second(lua_state, *static_cast<void**>(lambda_param_2), 1);
                        type_handler->second(lua_state, lambda_param_2, 2);
                    }
                    else
                    {
                        type_handler->second(lua_state, lambda_param_2, 1);
                    }
                }
                else
                {
                    throw std::runtime_error{std::format("Unhandled array type: '{}'", self->TypeName)};
                }

                if (int status = lua_pcall(lua_state, 2, 1, 0); status != LUA_OK)
                {
                    throw std::runtime_error{std::format("lua_pcall returned {}", LuaBindings::resolve_status_message(lua_state, status))};
                }

                if (lua_isboolean(lua_state, -1))
                {
                    return static_cast<LoopAction>(lua_tointeger(lua_state, -1));
                }
                else
                {
                    return LoopAction{};
                }
            };
            auto param_1 = LuaBindings::fnptr<LoopAction(int32_t, void*)>(param_function_ref_1);

            self->ForEach(param_1);
            return 0;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    auto lua_warn_wrapper(lua_State* lua_state) -> int
    {
        try
        {
            // Native call
            luaL_argcheck(lua_state, lua_isstring(lua_state, 1), 2, "");
            auto param_1 = std::string{lua_tostring(lua_state, 1)};

            luaL_traceback(lua_state, lua_state, param_1.c_str(), 1);
            Output::send<LogLevel::Warning>(STR("Warning: {}"), to_wstring(lua_tostring(lua_state, -1)));

            return 0;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    auto lua_print_wrapper(lua_State* lua_state) -> int
    {
        if (!lua_isstring(lua_state, 1))
        {
            luaL_error(lua_state, "The 'print' function requires the first parameter to be 'string'");
        }

        auto format = to_wstring(lua_tostring(lua_state, 1));
        lua_remove(lua_state, 1);

        // TODO: Pass 'format' to UEs OutputDevice

        // Emulate the original 'print' Lua function by adding a newline.
        format.append(STR("\n"));

        Output::send(format);

        return 0;
    }

    auto lua_FindAllOf_wrapper(lua_State* lua_state) -> int
    {
        //auto FindAllOf(FName SuperStruct, std::vector<UObject*>& ChunkIndex) -> void;
        //auto FindAllOf(const wchar_t* ClassName, std::vector<UObject*>& OutStorage) -> void;
        //auto FindAllOf(std::wstring_view ClassName, std::vector<UObject*>& OutStorage) -> void;
        //auto FindAllOf(const std::wstring& ClassName, std::vector<UObject*>& OutStorage) -> void;
        //auto FindAllOf(std::string_view ClassName, std::vector<UObject*>& OutStorage) -> void;
        //auto FindAllOf(const std::string& ClassName, std::vector<UObject*>& OutStorage) -> void;

        FName super_struct;
        //auto out_storage = static_cast<TArray<UObject*>*>(FMemory::Malloc(sizeof(TArray<UObject*>)));
        //new (out_storage) TArray<UObject*>{};
        auto out_storage = TArray<UObject*>{};
        printf_s("num: %i\n", out_storage.Num());
        printf_s("max: %i\n", out_storage.Max());

        bool param_1_is_fname{};
        int fname_pointer_depth{};
        bool fname_is_pointer{};
        if (lua_isuserdata(lua_state, 1))
        {
            lua_getiuservalue(lua_state, 1, 1);
            fname_pointer_depth = lua_tointeger(lua_state, -1);
            fname_is_pointer = fname_pointer_depth > 0;
            lua_getmetatable(lua_state, 1);
            lua_pushliteral(lua_state, "__name");
            lua_rawget(lua_state, -2);
            auto metatable_name = std::string{lua_tostring(lua_state, -1)};
            if (LuaBindings::convertible_to___RC__Unreal_FName.contains(metatable_name))
            {
                param_1_is_fname = true;
            }
            lua_pop(lua_state, 3);
        }

        if (param_1_is_fname)
        {
            if (fname_is_pointer)
            {
                auto param_1_outer_most = lua_touserdata(lua_state, 1);
                if (!param_1_outer_most)
                {
                    auto param_1_pointer = static_cast<FName*>(LuaBindings::deref(param_1_outer_most, fname_pointer_depth));
                    if (param_1_pointer)
                    {
                        super_struct = *param_1_pointer;
                    }
                }
            }
            else
            {
                super_struct = *static_cast<FName*>(lua_touserdata(lua_state, 1));
            }
        }
        else if (lua_isinteger(lua_state, 1))
        {
            if (lua_isinteger(lua_state, 2))
            {
                super_struct = FName(static_cast<uint32_t>(lua_tointeger(lua_state, 1)), static_cast<uint32_t>(lua_tointeger(lua_state, 2)));
            }
            else
            {
                super_struct = FName(lua_tointeger(lua_state, 1));
            }
        }
        else if (lua_isstring(lua_state, 1))
        {
            super_struct = FName(to_wstring(lua_tostring(lua_state, 1)));
        }
        else
        {
            luaL_error(lua_state, "Param 1 for FindAllOf must be either an FName or an integer.");
        }

        std::vector<UObject*> vector_of_objects{};
        UObjectGlobals::FindAllOf(super_struct, vector_of_objects);
        for (const auto& object : vector_of_objects)
        {
            out_storage.Add(object);
        }

        //auto array_wrapper = UnrealRuntimeTypes::ArrayTest{std::bit_cast<FScriptArray*>(out_storage), sizeof(UObject*), alignof(UObject*), "::RC::Unreal::UObject", true};
        auto array_wrapper = UnrealRuntimeTypes::ArrayTest{std::move(*std::bit_cast<FScriptArray*>(&out_storage)), sizeof(UObject*), alignof(UObject*), "::RC::Unreal::UObject", true};
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__UnrealRuntimeTypes_ArrayTestMetatable", ::RC::UnrealRuntimeTypes::ArrayTest, false, true>(lua_state, array_wrapper, 0);

        return 1;
    }

    auto lua_RegisterKeyBind_wrapper(lua_State* lua_state) -> int
    {
        try
        {
            if (!lua_isinteger(lua_state, 1))
            {
                luaL_error(lua_state, "RegisterKeyBind: First param must be integer (enum: Key).");
            }

            auto key = static_cast<Input::Key>(lua_tointeger(lua_state, 1));
            Input::Handler::ModifierKeyArray modifier_keys{};
            bool has_modifier_keys{};
            int function_ref{};

            if (lua_istable(lua_state, 2))
            {
                lua_pushnil(lua_state);
                for (lua_Integer i = 0; lua_next(lua_state, 2); ++i)
                {
                    if (!lua_isinteger(lua_state, -1))
                    {
                        luaL_error(lua_state, "RegisterKeyBind: Value in Keys table must be integer.");
                    }

                    modifier_keys[i] = static_cast<Input::ModifierKey>(lua_tointeger(lua_state, -1));
                    has_modifier_keys = true;
                    lua_pop(lua_state, 1);
                }

                if (!lua_isfunction(lua_state, 3))
                {
                    luaL_error(lua_state, "RegisterKeyBind: Third param must be function.");
                }

                function_ref = luaL_ref(lua_state, LUA_REGISTRYINDEX);
                Output::send(STR("setting function_ref to {}\n"), function_ref);
            }
            else if (lua_isfunction(lua_state, 2))
            {
                function_ref = luaL_ref(lua_state, LUA_REGISTRYINDEX);
                Output::send(STR("setting function_ref to {}\n"), function_ref);
            }

            auto lua_callable_wrapper = [=]() {
                TRY([&] {
                    Output::send(STR("calling function_ref {}\n"), function_ref);
                    if (lua_rawgeti(lua_state, LUA_REGISTRYINDEX, function_ref) != LUA_TFUNCTION)
                    {
                        throw std::runtime_error{"RegisterKeyBind: Tried calling keybind callback but the callback reference wasn't a function."};
                    }

                    if (int status = lua_pcall(lua_state, 0, 0, 0); status != LUA_OK)
                    {
                        throw std::runtime_error{std::format("RegisterKeyBind: lua_pcall returned {}", LuaBindings::resolve_status_message(lua_state, status)).c_str()};
                    }
                });
            };

            if (has_modifier_keys)
            {
                UE4SSProgram::get_program().register_keydown_event(key, modifier_keys, lua_callable_wrapper);
            }
            else
            {
                UE4SSProgram::get_program().register_keydown_event(key, lua_callable_wrapper);
            }

            return 0;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }
}

namespace RC::LuaBackCompat
{
    auto StaticFindObject(UClass* ObjectClass, UObject* InObjectPackage, const wchar_t* OrigInName, bool bExactClass) -> UObject*
    {
        return UObjectGlobals::StaticFindObject<UObject*>(ObjectClass, InObjectPackage, OrigInName, bExactClass);
    }

    auto StaticFindObject(const wchar_t* OrigInName) -> UObject*
    {
        return UObjectGlobals::StaticFindObject<UObject*>(nullptr, nullptr, OrigInName);
    }

    struct NotifyOnNewObjectCallback
    {
        std::function<void(UObject*)> callable{};
        UClass* class_filter{};

        NotifyOnNewObjectCallback(std::function<void(UObject*)> callable, UClass* class_filter) : callable(std::move(callable)), class_filter(class_filter) {}
    };
    static std::vector<NotifyOnNewObjectCallback> s_notify_on_new_object_callbacks{};

    static auto static_construct_object_hook_wrapper(const FStaticConstructObjectParameters& params, UObject* constructed_object) -> UObject*
    {
        try
        {
            auto object_class = constructed_object->GetClassPrivate();
            while (object_class)
            {
                for (const auto& callback_data : s_notify_on_new_object_callbacks)
                {
                    if (object_class != callback_data.class_filter) { continue; }
                    callback_data.callable(constructed_object);
                }

                object_class = object_class->GetSuperClass();
            }
        }
        catch (std::exception& e)
        {
            Output::send<LogLevel::Error>(STR("Error during StaticConstructHook wrapper: {}\n"), to_wstring(e.what()));
        }
        return constructed_object;
    }

    auto NotifyOnNewObject(const wchar_t* class_name, std::function<void(UObject*)>& callable) -> void
    {
        auto the_class = UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, class_name);
        if (!the_class) { throw std::runtime_error{"NotifyOnNewObject: First parameter must be string."}; }

        s_notify_on_new_object_callbacks.emplace_back(callable, the_class);

        static bool static_construct_object_already_hooked{};
        if (!static_construct_object_already_hooked) { Hook::RegisterStaticConstructObjectPostCallback(&static_construct_object_hook_wrapper); }
    }

    static auto set_is_in_game_thread(lua_State* lua_state, bool new_value)
    {
        lua_pushboolean(lua_state, new_value);
        lua_setfield(lua_state, LUA_REGISTRYINDEX, "IsInGameThread");
    }

    static auto is_in_game_thread(lua_State* lua_state) -> bool
    {
        lua_getfield(lua_state, LUA_REGISTRYINDEX, "IsInGameThread");
        return lua_toboolean(lua_state, -1);
    }

    struct RegisterHookCustomData
    {
        lua_State* lua_state{};
        const int lua_function_ref{};
        CallbackId pre_callback_id{};
        CallbackId post_callback_id{};
        bool has_return_value{};
        // Will be non-nullptr if the UFunction has a return value
        FProperty* return_property{};
    };
    static std::vector<std::unique_ptr<RegisterHookCustomData>> g_hooked_script_function_data{};

    static auto lua_RegisterHook_pre_hook(UnrealScriptFunctionCallableContext context, void *custom_data)
    {
        if (!custom_data)
        {
            Output::send<LogLevel::Error>(STR("Wrapper 'lua_RegisterHook_pre_hook' was called with nullptr for custom_data.\nCannot execute hook.\n"));
        }

        // Fetch the data corresponding to this hook
        auto& lua_data = *static_cast<RegisterHookCustomData*>(custom_data);

        // This is a promise that we're in the game thread, used by other functions to ensure that they don't execute when unsafe
        set_is_in_game_thread(lua_data.lua_state, true);

        // Use the stored registry index to put a Lua function on the Lua stack
        // This is the function that was provided by the Lua call to "RegisterHook"
        if (lua_rawgeti(lua_data.lua_state, LUA_REGISTRYINDEX, lua_data.lua_function_ref) != LUA_TFUNCTION)
        {
            lua_remove(lua_data.lua_state, -1);
            throw std::runtime_error("[lua_RegisterHook_pre_hook] Ref was not function");
        }

        // Set up the first param (context / this-ptr)
        // TODO: Check what happens if a static UFunction is hooked since they don't have any context
        LuaBindings::lua_Userdata_to_lua_from_heap<"__RC__Unreal_UObjectMetatable", ::RC::UObject>(lua_data.lua_state, context.Context);

        // Attempt at dynamically fetching the params
        uint16_t return_value_offset = context.TheStack.CurrentNativeFunction->GetReturnValueOffset();

        // 'ReturnValueOffset' is 0xFFFF if the UFunction return type is void
        lua_data.has_return_value = return_value_offset != 0xFFFF;

        uint8_t num_unreal_params = context.TheStack.CurrentNativeFunction->GetNumParms();
        if (lua_data.has_return_value)
        {
            // Subtract one from the number of params if there's a return value
            // This is because Unreal treats the return value as a param, and it's included in the 'NumParms' member variable
            --num_unreal_params;
        }

        bool has_properties_to_process = lua_data.has_return_value || num_unreal_params > 0;
        if (has_properties_to_process && context.TheStack.Locals)
        {
            int32_t current_param_offset{};

            context.TheStack.CurrentNativeFunction->ForEachProperty([&](FProperty* func_prop) {
                // Skip this property if it's not a parameter
                if (!func_prop->HasAnyPropertyFlags(EPropertyFlags::CPF_Parm))
                {
                    return LoopAction::Continue;
                }


                // Skip this property if it's the return value
                if (lua_data.has_return_value && func_prop->GetOffset_Internal() == return_value_offset)
                {
                    lua_data.return_property = func_prop;
                    return LoopAction::Continue;
                }

                if (auto it = UnrealRuntimeTypes::g_unreal_property_to_lua.find(func_prop->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_to_lua.end())
                {
                    it->second(lua_data.lua_state,
                               UnrealRuntimeTypes::ToLuaParams{
                                   .base = &context.TheStack.Locals[current_param_offset],
                                   .out_data = nullptr,
                                   .property = func_prop,
                                   .function = nullptr,
                                   .pointer_depth = 1,
                                   .base_no_processing_required = false,
                                   .should_copy_script_struct_contents = false,
                                   .should_containerize = true,
                               });
                }
                else
                {
                    throw std::runtime_error(to_string(std::format(STR("Property type '{}' not supported (for parameter: '{}' in '{}')"), func_prop->GetClass().GetName(), func_prop->GetName(), context.Context->GetFullName())).c_str());
                }

                return LoopAction::Continue;
            });

            // Call the Lua function with the correct number of parameters & return values
            // Increasing the 'num_params' by one to account for the 'this / context' param
            if (int status = lua_pcall(lua_data.lua_state, num_unreal_params + 1, 1, 0); status != LUA_OK)
            {
                throw std::runtime_error(std::format("[lua_RegisterHook_pre_hook] lua_pcall returned (error in callback) {}", LuaBindings::resolve_status_message(lua_data.lua_state, status)));
            }

            // This function continues in 'lua_unreal_script_function_hook_post' which executes immediately after the original function gets called

            // No longer promising to be in the game thread
            set_is_in_game_thread(lua_data.lua_state, false);
        }
    }

    static auto lua_RegisterHook_post_hook(UnrealScriptFunctionCallableContext context, void *custom_data)
    {
        if (!custom_data)
        {
            Output::send<LogLevel::Error>(STR("Wrapper 'lua_RegisterHook_post_hook' was called with nullptr for custom_data.\nCannot execute hook.\n"));
        }

        // Fetch the data corresponding to this hook
        auto& lua_data = *static_cast<RegisterHookCustomData*>(custom_data);

        // This is a promise that we're in the game thread, used by other functions to ensure that they don't execute when unsafe
        set_is_in_game_thread(lua_data.lua_state, true);

        // If 'nil' exists on the Lua stack, that means that the UFunction expected a return value but the Lua script didn't return anything
        // So we can simply clean the stack and let the UFunction decide the return value on its own
        if (lua_isnil(lua_data.lua_state, -1))
        {
            lua_remove(lua_data.lua_state, -1);
        }
        else if (lua_data.has_return_value && lua_data.return_property && context.RESULT_DECL)
        {
            if (auto it = UnrealRuntimeTypes::g_unreal_property_from_lua.find(lua_data.return_property->GetClass().GetFName()); it != UnrealRuntimeTypes::g_unreal_property_from_lua.end())
            {
                it->second(lua_data.lua_state,
                           UnrealRuntimeTypes::FromLuaParams{
                               .base = &context.RESULT_DECL,
                               .out_data = &context.RESULT_DECL,
                               .property = lua_data.return_property,
                               .function = nullptr,
                               .pointer_depth = 1,
                               .base_no_processing_required = false,
                               .should_copy_script_struct_contents = false,
                               .should_containerize = false,
                           });
            }
            else
            {
                throw std::runtime_error{to_string(std::format(STR("Property type '{}' not supported (for return value: '{}' in '{}')"),lua_data.return_property->GetClass().GetName(), lua_data.return_property->GetName(), context.TheStack.CurrentNativeFunction->GetFullName())).c_str()};
            }
        }

        // No longer promising to be in the game thread
        set_is_in_game_thread(lua_data.lua_state, false);
    }

    auto lua_RegisterHook_wrapper(lua_State* lua_state) -> int
    {
        try
        {
            if (!lua_isstring(lua_state, 1))
            {
                luaL_error(lua_state, "RegisterHook: First param must be string (full function name without type prefix).");
            }
            const auto function_name = to_wstring(lua_tostring(lua_state, 1));

            if (!lua_isfunction(lua_state, 2))
            {
                luaL_error(lua_state, "RegisterHook: Second param must be function.");
            }
            const auto lua_function_ref = luaL_ref(lua_state, LUA_REGISTRYINDEX);

            const auto unreal_function = UObjectGlobals::StaticFindObject<UFunction*>(nullptr, nullptr, function_name.c_str());
            if (!unreal_function)
            {
                luaL_error(lua_state, to_string(std::format(STR("RegisterHook: Function '{}' not found."), function_name)).c_str());
            }

            auto& custom_data = g_hooked_script_function_data.emplace_back(std::make_unique<RegisterHookCustomData>(RegisterHookCustomData{
                .lua_state = lua_state,
                .lua_function_ref = lua_function_ref,
            }));

            const auto pre_callback_id = unreal_function->RegisterPreHook(&lua_RegisterHook_pre_hook, custom_data.get());
            const auto post_callback_id = unreal_function->RegisterPostHook(&lua_RegisterHook_post_hook, custom_data.get());

            custom_data->pre_callback_id = pre_callback_id;
            custom_data->post_callback_id = post_callback_id;

            return 0;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }

    auto lua_UObjectBase_IsA_wrapper(lua_State* lua_state) -> int
    {
        try
        {
            auto [_, self] = LuaBindings::internal___RC__Unreal__UObjectBase_get_self(lua_state);

            UClass* param_1{};
            if (lua_isstring(lua_state, 1))
            {
                param_1 = UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, to_wstring(lua_tostring(lua_state, 1)));
            }
            else if (lua_isuserdata(lua_state, 1))
            {
                param_1 = LuaBindings::lua_util_userdata_Get<"__RC__Unreal_UClassMetatable", ::RC::Unreal::UClass*, LuaBindings::convertible_to___RC__Unreal_UClass>(lua_state, 1);
            }
            else
            {
                throw std::runtime_error{"UObjectBase::IsA: The first parameter must be either UClass or string."};
            }

            auto return_value = self->IsA(param_1);

            lua_pushboolean(lua_state, return_value);
            return 1;
        }
        catch (std::exception& e)
        {
            luaL_error(lua_state, e.what());
            return 0;
        }
    }
}

namespace RC::UnrealRuntimeTypes
{
    auto Array_Type_Handler_Ptr() -> void
    {

    }

    auto Array_Type_Handler_WChar_T() -> void
    {

    }

    Array::Array(size_t TypeSize, std::vector<std::string>& TypeNames) : TypeSize(TypeSize)
    {

    }
}


```

`src/LuaLibrary.cpp`:

```cpp
#include <format>

#include <Helpers/Casting.hpp>
#include <LuaLibrary.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>
#include <UE4SSProgram.hpp>
#include <Unreal/UnrealInitializer.hpp>
#include <Unreal/FOutputDevice.hpp>

namespace RC::LuaLibrary
{
    auto get_outputdevice_ref(const LuaMadeSimple::Lua& lua) -> const Unreal::FOutputDevice*
    {
        if (lua_getglobal(lua.get_lua_state(), "OutputDeviceRef") == LUA_TNIL)
        {
            lua.discard_value(-1);
            return nullptr;
        }

        // Explicitly using the top of the stack (-1) since that's where 'getglobal' puts stuff
        return static_cast<const Unreal::FOutputDevice*>(lua_touserdata(lua.get_lua_state(), -1));
    }

    auto set_outputdevice_ref(const LuaMadeSimple::Lua& lua, Unreal::FOutputDevice* output_device) -> void
    {
        lua_pushlightuserdata(lua.get_lua_state(), output_device);
        lua_setglobal(lua.get_lua_state(), "OutputDeviceRef");
    }

    auto global_print(const LuaMadeSimple::Lua& lua) -> int
    {
        int32_t stack_size = lua.get_stack_size();

        if (stack_size <= 0)
        {
            lua.throw_error("[do_tests => lambda(register_function(print))] stack_size was <= 0");
        }

        if (!lua.is_string())
        {
            lua.throw_error(std::format("[do_tests => lambda(register_function(print))] Parameter #1 must be of type 'string'. Was of type '{}'.", lua.get_type_string()));
        }

        std::wstring format = to_wstring(lua.get_string());

        // The output device is at the top of the stack, therefore we must call this function after retrieving all of the params.
        auto* output_device = get_outputdevice_ref(lua);

        if (stack_size == 1)
        {
            auto formatted_string = std::format(STR("[Lua] {}"), format.c_str());
            Output::send(formatted_string);
            if (output_device)
            {
                output_device->Log(formatted_string.c_str());
            }
        }
        else if (stack_size >= 2)
        {
            // Extra params are not yet implemented.
            // Remember to deal with the output device if you ever support more params (i.e. baked-in string.format).
        }

        return 0;
    }

    auto deref_to_int32(const LuaMadeSimple::Lua& lua) -> int
    {
        if (lua.get_stack_size() != 1 || !lua.is_integer())
        {
            Output::send(STR("[Fatal] Lua function 'DerefToInt32' must have only 1 parameter and it must be of type 'int'.\n"));
            lua.set_nil();
            return 1;
        }

        int32_t* int32_ptr = reinterpret_cast<int32_t*>(lua.get_integer());
        int32_t int32_val = Helper::Casting::offset_deref_safe<int32_t>(int32_ptr, 0, GetCurrentProcess());

        if (int32_val == 0)
        {
            Output::send(STR("[Fatal] Address passed to Lua function 'DerefToInt32' was not a valid pointer.\n"));
            lua.set_nil();
            return 1;
        }

        lua.set_integer(int32_val);
        return 1;
    }

    static auto error_handler_for_exported_functions(std::string_view e) -> void
    {
        // If the output system errored out then use printf_s as a fallback
        // Logging will only happen to the debug console but it's something at least
        if (!Output::has_internal_error())
        {
            Output::send(STR("Error: {}\n"), to_wstring(e));
        }
        else
        {
            printf_s("Internal Error: %s\n", e.data());
        }
    }

    static auto exported_function_status_to_string(ExportedFunctionStatus status) -> std::wstring_view
    {
        switch (status)
        {

            case ExportedFunctionStatus::UNKNOWN_ERROR:
                return L"UNKNOWN_ERROR | 0";
            case ExportedFunctionStatus::SUCCESS:
                return L"SUCCESS | 1";
            case ExportedFunctionStatus::VARIABLE_NOT_FOUND:
                return L"VARIABLE_NOT_FOUND | 2";
            case ExportedFunctionStatus::MOD_IS_NULLPTR:
                return L"MOD_IS_NULLPTR | 3";
            case ExportedFunctionStatus::SCRIPT_FUNCTION_RETURNED_FALSE:
                return L"SCRIPT_FUNCTION_RETURNED_FALSE | 4";
            case ExportedFunctionStatus::UNABLE_TO_CALL_SCRIPT_FUNCTION:
                return L"UNABLE_TO_CALL_SCRIPT_FUNCTION | 5";
            case ExportedFunctionStatus::SCRIPT_FUNCTION_NOT_FOUND:
                return L"SCRIPT_FUNCTION_NOT_FOUND | 6";
        }

        return L"Missed switch case";
    }

    auto get_lua_state_by_mod_name(const char* mod_name) -> lua_State*
    {
        auto* mod = UE4SSProgram::find_mod_by_name(mod_name);
        if (!mod) { return nullptr; }
        return mod->lua().get_lua_state();
    };

    auto execute_lua_in_mod(const char* mod_name, const char* script, char* output_buffer) -> const char*
    {
        std::string_view output_buffer_view{output_buffer};

        auto* mod = UE4SSProgram::find_mod_by_name(mod_name);
        if (!mod || !mod->is_installed() || !mod->is_started()) { return std::format("No mod by name '{}' found.", mod_name).c_str(); }

        try
        {
            if (int status = luaL_loadstring(mod->lua().get_lua_state(), script); status != LUA_OK)
            {
                mod->lua().throw_error(std::format("luaL_loadstring returned {}", mod->lua().resolve_status_message(status, true)));
            }

            if (int status = lua_pcall(mod->lua().get_lua_state(), 0, LUA_MULTRET, 0); status != LUA_OK)
            {
                mod->lua().throw_error(std::format("lua_pcall returned {}", mod->lua().resolve_status_message(status, true)));
            }
        }
        catch (std::runtime_error& e)
        {
            std::string_view what_view{e.what()};
            std::memcpy(output_buffer, what_view.data(), what_view.size());
            return output_buffer;
        }

        return nullptr;
    };

    auto set_script_variable_int32(const char* mod_name, const char* variable_name, int32_t new_value, ReturnValue& return_struct) -> void
    {
        try
        {
            if (!Unreal::UnrealInitializer::StaticStorage::bIsInitialized)
            {
                return_struct.status = ExportedFunctionStatus::UE4SS_NOT_INITIALIZED;
                Output::send(STR("set_script_variable_int32 | UE4SS is not initialized\n"));
                return;
            }

            // TODO: Remove this in non-debug versions
            /*
            const std::string tmp_var_name = variable_name;
            const std::wstring variable_name_wide = std::wstring(tmp_var_name.begin(), tmp_var_name.end());
            const std::string tmp_mod_name = mod_name;
            const std::wstring mod_name_wide = std::wstring(tmp_mod_name.begin(), tmp_mod_name.end());
            Output::send(STR("Setting variable '{}' in mod '{}' to {}\n"), variable_name_wide, mod_name_wide, new_value);
            //*/

            auto mod = UE4SSProgram::find_mod_by_name(mod_name, UE4SSProgram::IsInstalled::Yes, UE4SSProgram::IsStarted::Yes);
            if (!mod)
            {
                return_struct.status = ExportedFunctionStatus::MOD_IS_NULLPTR;
                Output::send(STR("set_script_variable_int32 | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
                return;
            }

            const LuaMadeSimple::Lua& lua = mod->lua();

            auto type = lua_getglobal(lua.get_lua_state(), variable_name);
            lua_pop(lua.get_lua_state(), 1);

            if (type == LUA_TNIL)
            {
                return_struct.status = ExportedFunctionStatus::VARIABLE_NOT_FOUND;
                Output::send(STR("set_script_variable_int32 | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
                return;
            }

            lua.set_integer(new_value);
            lua_setglobal(lua.get_lua_state(), variable_name);

            return_struct.status = ExportedFunctionStatus::SUCCESS;
            Output::send(STR("set_script_variable_int32 | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
        }
        catch (std::runtime_error& e)
        {
            error_handler_for_exported_functions(e.what());
            return_struct.status = ExportedFunctionStatus::UNKNOWN_ERROR;
        }
    }

    auto set_script_variable_default_data([[maybe_unused]]const char* mod_name, [[maybe_unused]]const char* variable_name, [[maybe_unused]]DefaultDataStruct& external_data, ReturnValue& return_struct) -> void
    {
        try
        {
            if (!Unreal::UnrealInitializer::StaticStorage::bIsInitialized)
            {
                return_struct.status = ExportedFunctionStatus::UE4SS_NOT_INITIALIZED;
                Output::send(STR("set_script_variable_default_data | UE4SS is not initialized\n"));
                return;
            }

            // TODO: Remove this in non-debug versions
            /*
            const std::string tmp_var_name = variable_name;
            const std::wstring variable_name_wide = std::wstring(tmp_var_name.begin(), tmp_var_name.end());
            const std::string tmp_mod_name = mod_name;
            const std::wstring mod_name_wide = std::wstring(tmp_mod_name.begin(), tmp_mod_name.end());

            switch (external_data.data1_type)
            {
                case DefaultDataType::ConstCharPtr:
                {
                    const std::string tmp_data1_value_ansi = external_data.data1.as_string;
                    const std::wstring data1_value_wide = std::wstring(tmp_data1_value_ansi.begin(), tmp_data1_value_ansi.end());
                    Output::send(STR("Setting '{}.data1' as string to '{}' in mod '{}'"), variable_name_wide, data1_value_wide, mod_name_wide);
                    break;
                }
                case DefaultDataType::Float:
                    Output::send(STR("Setting '{}.data1' as float to '{}' in mod '{}'"), variable_name_wide, external_data.data1.as_float, mod_name_wide);
                    break;
            }
            //*/

            auto mod = UE4SSProgram::find_mod_by_name(mod_name, UE4SSProgram::IsInstalled::Yes, UE4SSProgram::IsStarted::Yes);
            if (!mod)
            {
                return_struct.status = ExportedFunctionStatus::MOD_IS_NULLPTR;
                Output::send(STR("set_script_variable_default_data | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
                return;
            }

            const LuaMadeSimple::Lua& lua = mod->lua();
            auto lua_table = lua.prepare_new_table();

            if (external_data.data1.as_string)
            {
                switch (external_data.data1_type)
                {
                    case DefaultDataType::ConstCharPtr:
                        lua_table.add_pair("data1", external_data.data1.as_string);
                        break;
                    case DefaultDataType::Float:
                        lua_table.add_pair("data1", external_data.data1.as_float);
                        break;
                }
            }

            if (external_data.data2.as_string)
            {
                switch (external_data.data2_type)
                {
                    case DefaultDataType::ConstCharPtr:
                        lua_table.add_pair("data2", external_data.data2.as_string);
                        break;
                    case DefaultDataType::Float:
                        lua_table.add_pair("data2", external_data.data2.as_float);
                        break;
                }
            }

            if (external_data.data3.as_string)
            {
                switch (external_data.data3_type)
                {
                    case DefaultDataType::ConstCharPtr:
                        lua_table.add_pair("data3", external_data.data3.as_string);
                        break;
                    case DefaultDataType::Float:
                        lua_table.add_pair("data3", external_data.data3.as_float);
                        break;
                }
            }

            if (external_data.data4.as_string)
            {
                switch (external_data.data4_type)
                {
                    case DefaultDataType::ConstCharPtr:
                        lua_table.add_pair("data4", external_data.data4.as_string);
                        break;
                    case DefaultDataType::Float:
                        lua_table.add_pair("data4", external_data.data4.as_float);
                        break;
                }
            }

            lua_table.make_global(variable_name);

            return_struct.status = ExportedFunctionStatus::SUCCESS;
        }
        catch (std::runtime_error& e)
        {
            error_handler_for_exported_functions(e.what());
            return_struct.status = ExportedFunctionStatus::UNKNOWN_ERROR;
        }
    }

    auto call_script_function(const char* mod_name, const char* function_name, ReturnValue& return_struct, ScriptFuncReturnValue& script_return_struct) -> void
    {
        try
        {
            if (!Unreal::UnrealInitializer::StaticStorage::bIsInitialized)
            {
                return_struct.status = ExportedFunctionStatus::UE4SS_NOT_INITIALIZED;
                Output::send(STR("call_script_function | UE4SS is not initialized\n"));
                return;
            }

            // TODO: Remove this in non-debug versions
            /*
            const std::string tmp_func_name = function_name;
            const std::wstring func_name_wide = std::wstring(tmp_func_name.begin(), tmp_func_name.end());
            const std::string tmp_mod_name = mod_name;
            const std::wstring mod_name_wide = std::wstring(tmp_mod_name.begin(), tmp_mod_name.end());
            Output::send(STR("Calling script function '{}' in mod '{}'\n"), func_name_wide, mod_name_wide);
            //*/

            auto mod = UE4SSProgram::find_mod_by_name(mod_name, UE4SSProgram::IsInstalled::Yes, UE4SSProgram::IsStarted::Yes);
            if (!mod)
            {
                return_struct.status = ExportedFunctionStatus::MOD_IS_NULLPTR;
                Output::send(STR("call_script_function | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
                return;
            }

            const LuaMadeSimple::Lua& lua = mod->lua();

            try
            {
                lua.prepare_function_call(function_name);
            }
            catch (std::runtime_error&)
            {
                return_struct.status = ExportedFunctionStatus::SCRIPT_FUNCTION_NOT_FOUND;
                Output::send(STR("call_script_function | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
                return;
            }

            lua.call_function(0, 1);

            if (lua.is_nil())
            {
                // Stack is empty or nil, treat as 'false' (default is already 'false')
                // Since we assume that 'nil == false' we don't actually retrieve anything from teh Lua stack
                // Because of that we need to manually remove the 'nil' from the Lua stack
                lua.discard_value();
            }
            else if (lua.is_bool())
            {
                script_return_struct.return_value = lua.get_bool();

                if (!script_return_struct.return_value)
                {
                    return_struct.status = ExportedFunctionStatus::SCRIPT_FUNCTION_RETURNED_FALSE;
                }
            }
            else if (lua.is_integer())
            {
                int64_t script_return_value = lua.get_integer();
                script_return_struct.return_value = script_return_value >= 1;
            }
            else
            {
                // The return type is not something that can be deduced to true/false, lets assume false
            }

            if (return_struct.status == ExportedFunctionStatus::NO_ERROR_TO_EXPORT)
            {
                return_struct.status = ExportedFunctionStatus::SUCCESS;
            }

            Output::send(STR("call_script_function | return_struct.status: {}\n"), exported_function_status_to_string(return_struct.status));
        }
        catch (std::runtime_error& e)
        {
            error_handler_for_exported_functions(e.what());
            return_struct.status = ExportedFunctionStatus::UNKNOWN_ERROR;
        }
    }

    auto is_ue4ss_initialized() -> bool
    {
        return Unreal::UnrealInitializer::StaticStorage::bIsInitialized;
    }
}

```

`src/LuaScriptMemoryAccess.cpp`:

```cpp
#include <stdio.h>
#include <cstdlib>
#include <cstdint>
#include <bit>

#include <LuaScriptMemoryAccess.hpp>
#include <LuaBindings/States/MainState/Main.hpp>

namespace RC
{
    auto AllocateMemory(size_t Size) -> MemoryItem*
    {
        return static_cast<MemoryItem*>(std::malloc(Size));
    }
    auto FreeMemory(MemoryItem* memory_item) -> void
    {
        std::free(memory_item);
    }
    auto FreeMemory(uintptr_t memory) -> void
    {
        std::free(std::bit_cast<void*>(memory));
    }

    enum class ByteReadWriteMode
    {
        SingleByte,
        MultiByte,
    };

    template<typename NumberType>
    auto read_generic_number_wrapper(lua_State* lua_state, ByteReadWriteMode byte_read_write_mode = ByteReadWriteMode::SingleByte) -> int
    {
        NumberType* data{};

        if (lua_isinteger(lua_state, 1))
        {
            data = std::bit_cast<NumberType*>(lua_tointeger(lua_state, 1));
        }
        else if (lua_islightuserdata(lua_state, 1))
        {
            data = static_cast<NumberType*>(lua_touserdata(lua_state, 1));
        }
        else if (lua_isuserdata(lua_state, 1))
        {
            auto get_address_type = lua_getfield(lua_state, 1, "GetAddress");
            if (get_address_type != LUA_TFUNCTION)
            {
                luaL_error(lua_state, "Userdata is incompatible with memory functions because it has has no 'GetAddress' function.");
            }

            lua_pushvalue(lua_state, 1); // Duplicate the userdata because pcall will pop it from the stack for the first function param (self).

            if (int status = lua_pcall(lua_state, 1, 1, 0); status != LUA_OK)
            {
                luaL_error(lua_state, LuaBindings::resolve_status_message(lua_state, status).c_str());
            }

            if (!lua_isinteger(lua_state, -1) && !lua_isnil(lua_state, -1))
            {
                luaL_error(lua_state, "Userdata is incompatible with memory functions because its 'GetAddress' function returned non-integer.");
            }

            if (lua_isnil(lua_state, -1))
            {
                luaL_error(lua_state, "Cannot place a call to a memory function with a nullptr.");
            }

            data = std::bit_cast<NumberType*>(lua_tointeger(lua_state, -1));
            lua_pop(lua_state, 1);
        }

        //auto memory_item = MemoryItem{data};
        //LuaBindings::lua_Userdata_to_lua_from_heap<"__RC_MemoryItemMetatable", ::RC::MemoryItem, false>(lua_state, memory_item, 0);

        bool return_as_table{};
        if (lua_isboolean(lua_state, 3))
        {
            return_as_table = lua_toboolean(lua_state, 3);
            lua_pop(lua_state, 1);
        }

        if (return_as_table)
        {
            lua_newtable(lua_state);
        }

        if (byte_read_write_mode == ByteReadWriteMode::SingleByte)
        {
            if (return_as_table) { lua_pushinteger(lua_state, 1); }
            lua_pushinteger(lua_state, *data);
            if (return_as_table) { lua_rawset(lua_state, -3); }
            return 1;
        }
        else
        {
            if (!lua_isinteger(lua_state, 2))
            {
                luaL_error(lua_state, "Cannot read bytes in MultiByte mode without specifying how many bytes to read.");
            }

            auto num_bytes_to_read = lua_tointeger(lua_state, 2);
            if (num_bytes_to_read < 1) { luaL_error(lua_state, "Must specify at least one byte to read. Specified: 0 (param #2)"); }

            for (lua_Integer i = 0; i < num_bytes_to_read; ++i)
            {
                if (return_as_table) { lua_pushinteger(lua_state, i + 1); }
                lua_pushinteger(lua_state, *std::bit_cast<NumberType*>(std::bit_cast<uint8_t*>(data) + i));
                if (return_as_table) { lua_rawset(lua_state, -3); }
            }
            return return_as_table ? 1 : num_bytes_to_read;
        }
    }

    template<typename NumberType, typename LuaVerificationFunction, typename LuaFetchFunction>
    auto write_generic_number_wrapper(lua_State* lua_state, LuaVerificationFunction lua_verification_function, LuaFetchFunction lua_fetch_function, ByteReadWriteMode byte_read_write_mode = ByteReadWriteMode::SingleByte) -> int
    {
        NumberType* data{};
        NumberType new_value{};

        if (lua_isinteger(lua_state, 1))
        {
            data = std::bit_cast<NumberType*>(lua_tointeger(lua_state, 1));
        }
        else if (lua_islightuserdata(lua_state, 1))
        {
            data = static_cast<NumberType*>(lua_touserdata(lua_state, 1));
        }
        else if (lua_isuserdata(lua_state, 1))
        {
            auto get_address_type = lua_getfield(lua_state, 1, "GetAddress");
            if (get_address_type != LUA_TFUNCTION)
            {
                luaL_error(lua_state, "Userdata is incompatible with memory functions because it has has no 'GetAddress' function.");
            }

            lua_pushvalue(lua_state, 1); // Duplicate the userdata because pcall will pop it from the stack for the first function param (self).

            if (int status = lua_pcall(lua_state, 1, 1, 0); status != LUA_OK)
            {
                luaL_error(lua_state, LuaBindings::resolve_status_message(lua_state, status).c_str());
            }

            if (!lua_isinteger(lua_state, -1) && !lua_isnil(lua_state, -1))
            {
                luaL_error(lua_state, "Userdata is incompatible with memory functions because its 'GetAddress' function returned non-integer.");
            }

            if (lua_isnil(lua_state, -1))
            {
                luaL_error(lua_state, "Cannot place a call to a memory function with a nullptr.");
            }

            data = std::bit_cast<NumberType*>(lua_tointeger(lua_state, -1));
            lua_pop(lua_state, 1);
        }

        bool values_as_table = lua_istable(lua_state, 2);

        if (byte_read_write_mode == ByteReadWriteMode::SingleByte)
        {
            if (values_as_table)
            {
                lua_pushinteger(lua_state, 1);
                lua_rawget(lua_state, 2);
            }
            if (!lua_verification_function(lua_state, values_as_table ? -1 : 2))
            {
                luaL_error(lua_state, "The new value is invalid for this type.");
            }
            new_value = lua_fetch_function(lua_state, values_as_table ? -1 : 2);
            *data = new_value;
        }
        else
        {
            if (values_as_table)
            {
                lua_pushnil(lua_state);
                for (lua_Integer i = 0; lua_next(lua_state, 2); ++i)
                {
                    if (lua_isinteger(lua_state, -1))
                    {
                        new_value = lua_fetch_function(lua_state, -1);
                        data[i] = new_value;
                    }
                    lua_pop(lua_state, 1);
                }
            }
            else
            {
                for (lua_Integer i = 2; lua_verification_function(lua_state, i); ++i)
                {
                    new_value = lua_fetch_function(lua_state, i);
                    data[i - 2] = new_value;
                }
            }
        }

        return 1;
    }

    auto lua_fetch_integer(lua_State* lua_state, int index) -> int
    {
        return lua_tointeger(lua_state, index);
    }

    auto lua_Test_ReadBytes_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<uint8_t>(lua_state, ByteReadWriteMode::MultiByte);
    }
    auto lua_Test_ReadUInt8_wrapper(lua_State* lua_state) -> int
    {
        return lua_isboolean(lua_state, 2) && lua_toboolean(lua_state, 2) ? read_generic_number_wrapper<int8_t>(lua_state) : read_generic_number_wrapper<uint8_t>(lua_state);
    }
    auto lua_Test_ReadUInt16_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<uint16_t>(lua_state);
    }
    auto lua_Test_ReadUInt32_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<uint32_t>(lua_state);
    }
    auto lua_Test_ReadUInt64_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<uint64_t>(lua_state);
    }
    auto lua_Test_ReadInt8_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<int8_t>(lua_state);
    }
    auto lua_Test_ReadInt16_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<int16_t>(lua_state);
    }
    auto lua_Test_ReadInt32_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<int32_t>(lua_state);
    }
    auto lua_Test_ReadInt64_wrapper(lua_State* lua_state) -> int
    {
        return read_generic_number_wrapper<int64_t>(lua_state);
    }

    auto lua_Test_WriteBytes_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<uint8_t>(lua_state, &lua_isinteger, &lua_fetch_integer, ByteReadWriteMode::MultiByte);
    }
    auto lua_Test_WriteUInt8_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<uint8_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteUInt16_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<uint16_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteUInt32_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<uint32_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteUInt64_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<uint64_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }

    auto lua_Test_WriteInt8_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<int8_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteInt16_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<int16_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteInt32_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<int32_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
    auto lua_Test_WriteInt64_wrapper(lua_State* lua_state) -> int
    {
        return write_generic_number_wrapper<int64_t>(lua_state, &lua_isinteger, &lua_fetch_integer);
    }
}

```

`src/LuaTests.cpp`:

```cpp
#include <LuaTests.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <LuaScriptMemoryAccess.hpp>
#include <Unreal/UObjectGlobals.hpp>

namespace RC
{
    auto Test_GetUnsignedMemorySetup() -> MemoryItem*
    {
        uint8_t* mem = static_cast<uint8_t*>(std::malloc(0x8));
        mem[0] = 1;
        mem[1] = 2;
        mem[2] = 3;
        mem[3] = 4;
        mem[4] = 5;
        mem[5] = 6;
        mem[6] = 7;
        mem[7] = 8;
        return std::bit_cast<MemoryItem*>(mem);
    }

    auto Test_GetSignedMemorySetup() -> MemoryItem*
    {
        int8_t* mem = static_cast<int8_t*>(std::malloc(0x8));
        mem[0] = 1;
        mem[1] = 2;
        mem[2] = 3;
        mem[3] = 4;
        mem[4] = 5;
        mem[5] = 6;
        mem[6] = 7;
        mem[7] = 8;
        return std::bit_cast<MemoryItem*>(mem);
    }

    auto Test_GetPlayerControllerVTablePointer() -> MemoryItem*
    {
        return std::bit_cast<MemoryItem*>(*std::bit_cast<void**>(Unreal::UObjectGlobals::FindFirstOf(STR("PlayerController"))));
    }

    auto GetWorldTest() -> UWorld*
    {
        auto world = static_cast<UWorld*>(UObjectGlobals::FindFirstOf(STR("World")));
        auto& net_fields = world->GetPreparingLevelNames();
        Output::send(STR("net_fields num: {}\n"), net_fields.Num());
        Output::send(STR("net_fields max: {}\n"), net_fields.Max());
        return world;
    }

    auto GetArrayTest() -> TArray<UObject*>&
    {
        auto objects = static_cast<TArray<UObject*>*>(FMemory::Malloc(sizeof(TArray<UObject*>)));
        new(objects) TArray<UObject*>{};
        objects->Add(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Script/CoreUObject.Object")));
        objects->Add(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Script/Engine.MaterialExpression")));
        objects->Add(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Script/Engine.MaterialExpressionTextureBase")));
        objects->Add(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Script/Engine.MaterialExpressionTextureSample")));
        objects->Add(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Script/Engine.MaterialExpressionTextureSampleParameter")));
        return *objects;
    }

    auto GetArrayTest2() -> TArray<int16_t>&
    {
        auto ints = static_cast<TArray<int16_t>*>(FMemory::Malloc(sizeof(TArray<int16_t>)));
        new(ints) TArray<int16_t>{};
        ints->Add(1);
        ints->Add(2);
        ints->Add(3);
        ints->Add(4);
        ints->Add(5);
        return *ints;
    }

    auto GetArrayTest3() -> TArray<FName>
    {
        //auto names = static_cast<TArray<FName>*>(FMemory::Malloc(sizeof(TArray<FName>)));
        //new(names) TArray<FName>{};
        TArray<FName> names{};
        names.Add(FName(STR("HelloOne"), EFindName::FNAME_Add));
        names.Add(FName(STR("HelloTwo"), EFindName::FNAME_Add));
        names.Add(FName(STR("HelloThree"), EFindName::FNAME_Add));
        names.Add(FName(STR("HelloFour"), EFindName::FNAME_Add));
        names.Add(FName(STR("HelloFive"), EFindName::FNAME_Add));
        return names;
    }

    auto Test_Get_UObject_Nullptr() -> UObject*
    {
        return nullptr;
    }
}
```

`src/LuaType/LuaAActor.cpp`:

```cpp
#include <LuaType/LuaAActor.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/World.hpp>

namespace RC::LuaType
{
    AActor::AActor(Unreal::AActor* object) : UObjectBase<Unreal::AActor, AActorName>(object) {}

    auto AActor::construct(const LuaMadeSimple::Lua& lua, Unreal::AActor* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::AActor lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::AActor>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto AActor::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto AActor::setup_metamethods(BaseObject&) -> void
    {
        // AActor has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto AActor::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetWorld", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<AActor>();

            if (Unreal::UWorld* world = lua_object.get_remote_cpp_object()->GetWorld(); world)
            {
                auto_construct_object(lua, world);
            }
            else
            {
                lua.set_nil();
            }

            return 1;
        });

        table.add_pair("GetLevel", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<AActor>();

            if (Unreal::UObject* level = lua_object.get_remote_cpp_object()->GetLevel(); level)
            {
                auto_construct_object(lua, level);
            }
            else
            {
                lua.set_nil();
            }

            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaCustomProperty.cpp`:

```cpp
#include <bit>

#include <LuaType/LuaCustomProperty.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UClass.hpp>
#include <Unreal/FProperty.hpp>
#include <UnrealCustom/CustomProperty.hpp>
#include <Unreal/UnrealVersion.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    LuaCustomProperty::PropertyList LuaCustomProperty::StaticStorage::property_list;

    LuaCustomProperty::LuaCustomProperty(std::wstring name, std::unique_ptr<Unreal::CustomProperty> property)
            : m_name(name), m_property(std::move(property))
    {

    }

    auto LuaCustomProperty::PropertyList::add(std::wstring property_name, std::unique_ptr<Unreal::CustomProperty> property) -> void
    {
        (void)properties.emplace_back(LuaCustomProperty{property_name, std::move(property)}).m_property.get();
    }

    auto LuaCustomProperty::PropertyList::clear() -> void
    {
        properties.clear();
    }

    auto LuaCustomProperty::PropertyList::find_or_nullptr(Unreal::UObject* base, std::wstring property_name) -> Unreal::FProperty*
    {
        Unreal::FProperty* custom_property_found{};

        for (const auto& property_item : properties)
        {
            void* owner_or_outer{};
            auto owner = property_item.m_property->GetOwnerVariant();
            if (owner.IsUObject())
            {
                owner_or_outer = owner.ToUObject();
            }
            else
            {
                owner_or_outer = owner.ToField();
            }

            Unreal::UStruct* ptr = base->GetClassPrivate();
            bool class_matches = ptr == owner_or_outer;

            if (!class_matches)
            {
                ptr->ForEachSuperStruct([&](Unreal::UStruct* super_struct) {
                    if (super_struct == owner_or_outer)
                    {
                        class_matches = true;
                        return LoopAction::Break;
                    }
                    else
                    {
                        return LoopAction::Continue;
                    }
                });
            }

            if (class_matches && property_name == property_item.m_name)
            {
                // Compare name here
                custom_property_found = property_item.m_property.get();
                break;
            }
        }

        return custom_property_found;
    }
}

```

`src/LuaType/LuaFName.cpp`:

```cpp
#include <LuaType/LuaFName.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>

namespace RC::LuaType
{
    FName::FName(Unreal::FName object) : LocalObjectBase<Unreal::FName, FNameName>(std::move(object)) {}

    auto FName::construct(const LuaMadeSimple::Lua& lua, Unreal::FName unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FName lua_object{unreal_object};

        auto metatable_name = "FNameUserdata";

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::FName>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FName::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto FName::setup_metamethods(BaseObject& base_object) -> void
    {
        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Call, []([[maybe_unused]]const LuaMadeSimple::Lua& lua) -> int {
            // Acts as a "constructor" for FName
            std::string error_overload_not_found{R"(
No overload found for function 'FName'.
Overloads:
#1: FName(string Name)
#2: FName(integer ComparisonIndex))"};

            Unreal::FName fname;

            if (lua.is_userdata())
            {
                // Discard the userdata since it's unwanted data
                lua.discard_value();
            }

            if (lua.is_string())
            {
                std::wstring name = to_wstring(lua.get_string());

                fname = Unreal::FName(name);
            }
            else if (lua.is_integer())
            {
                int64_t comparison_index = lua.get_integer();
                fname = Unreal::FName(comparison_index);
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            LuaType::FName::construct(lua, fname);

            return 1;
        });

        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Equal, []([[maybe_unused]]const LuaMadeSimple::Lua& lua) -> int {
            if (!lua.is_userdata(1) || !lua.is_userdata(2))
            {
                lua.throw_error("FName __eq metamethod called but there was not two userdata to compare");
            }

            auto name_a = lua.get_userdata<LuaType::FName>();
            auto name_b = lua.get_userdata<LuaType::FName>();

            return name_a.get_local_cpp_object() == name_b.get_local_cpp_object();
        });
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FName::setup_member_functions(LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("ToString", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<FName>();

            lua.set_string(to_string(lua_object.get_local_cpp_object().ToString()));

            return 1;
        });

        table.add_pair("GetComparisonIndex", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<FName>();

            lua.set_integer(lua_object.get_local_cpp_object().GetComparisonIndex());

            return 1;
        });

        table.add_pair("Equals", [](const LuaMadeSimple::Lua& lua) -> int {
            if (!lua.is_userdata(1) || !lua.is_userdata(2))
            {
                lua.throw_error("FName.Equals called but there was not two userdata to compare (use ':' to call, not '.')");
            }

            auto name_a = lua.get_userdata<LuaType::FName>();
            auto name_b = lua.get_userdata<LuaType::FName>();

            return name_a.get_local_cpp_object().Equals(name_b.get_local_cpp_object());
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global("FNameUserdata");
        }
    }
}

```

`src/LuaType/LuaFOutputDevice.cpp`:

```cpp
#include <LuaType/LuaFOutputDevice.hpp>
#include <Helpers/String.hpp>

#pragma warning(disable: 4005)
#include <Unreal/FOutputDevice.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    FOutputDevice::FOutputDevice(Unreal::FOutputDevice* object) : RemoteObjectBase<Unreal::FOutputDevice, FOutputDeviceName>(object) {}

    auto FOutputDevice::construct(const LuaMadeSimple::Lua& lua, Unreal::FOutputDevice* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FOutputDevice lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            SelfType::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::FOutputDevice>(metatable_name, lua_object.get_metamethods());
        }
        // Transfer the object & its ownership fully to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FOutputDevice::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FOutputDevice>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto FOutputDevice::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // FOutputDevice has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FOutputDevice::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("Log", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'Log'.
Overloads:
#1: Log(string Message))"};

            const auto& lua_object = lua.get_userdata<FOutputDevice>();

            if (!lua.is_string())
            {
                throw std::runtime_error{error_overload_not_found};
            }
            auto message = lua.get_string();

            lua_object.get_remote_cpp_object()->Log(to_wstring(message).c_str());

            return 0;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaFSoftObjectPath.cpp`:

```cpp
#include <LuaType/LuaFSoftObjectPath.hpp>
#include <LuaType/LuaFName.hpp>
#include <LuaType/LuaFString.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>

namespace RC::LuaType
{
    FSoftObjectPath::FSoftObjectPath(Unreal::FSoftObjectPath& object) : LocalObjectBase<Unreal::FSoftObjectPath, FSoftObjectPathName>(std::move(object)) {}

    auto FSoftObjectPath::construct(const LuaMadeSimple::Lua& lua, Unreal::FSoftObjectPath& unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FSoftObjectPath lua_object{unreal_object};

        auto metatable_name = "FSoftObjectPathUserdata";

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table, metatable_name);
            lua.new_metatable<LuaType::FName>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FSoftObjectPath::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();

        auto metatable_name = "FSoftObjectPathUserdata";

        setup_metamethods(construct_to);
        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table, metatable_name);

        return table;
    }

    auto FSoftObjectPath::setup_metamethods(BaseObject& base_object) -> void
    {

    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FSoftObjectPath::setup_member_functions(LuaMadeSimple::Lua::Table& table, std::string_view metatable_name) -> void
    {
        table.add_pair("GetAssetPathName", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<FSoftObjectPath>();
            FName::construct(lua, lua_object.get_local_cpp_object().AssetPathName);
            return 1;
        });

        table.add_pair("GetSubPathString", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<FSoftObjectPath>();
            FString::construct(lua, &lua_object.get_local_cpp_object().SubPathString);
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string("FSoftObjectPathUserdata");
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(metatable_name);// , is_final == LuaMadeSimple::Type::IsFinal::No);
        }
    }
}

```

`src/LuaType/LuaFString.cpp`:

```cpp
#include <LuaType/LuaFString.hpp>
#include <Helpers/String.hpp>
#pragma warning(disable: 4005)
#include <Unreal/FString.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    FString::FString( Unreal::FString* object) : RemoteObjectBase<Unreal::FString, FStringName>(object) {}

    auto FString::construct(const LuaMadeSimple::Lua& lua, Unreal::FString* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FString lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FString>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::FString>(metatable_name, lua_object.get_metamethods());
        }

        // Transfer the object & its ownership fully to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FString::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FString>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto FString::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // FString has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FString::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("ToString", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<LuaType::FString>();

            const wchar_t* string_data = lua_object.get_remote_cpp_object()->GetCharArray();
            if (string_data)
            {
                lua.set_string(to_string(string_data));
            }
            else
            {
                lua.set_string("");
            }

            return 1;
        });

        table.add_pair("Clear", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<LuaType::FString>();

            lua_object.get_remote_cpp_object()->Clear();

            return 0;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaFText.cpp`:

```cpp
#include <LuaType/LuaFText.hpp>
#include <Unreal/FText.hpp>
#include <Unreal/FString.hpp>

namespace RC::LuaType
{
    FText::FText(Unreal::FText* object) : RemoteObjectBase<Unreal::FText, FTextName>(object) {}

    auto FText::construct(const LuaMadeSimple::Lua& lua, Unreal::FText* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FText lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::FText>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FText::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto FText::setup_metamethods(BaseObject&) -> void
    {
        // AActor has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FText::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("ToString", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<FText>();

            lua.set_string(to_string(lua_object.get_remote_cpp_object()->ToString()));

            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaFWeakObjectPtr.cpp`:

```cpp
#include <LuaType/LuaFWeakObjectPtr.hpp>
#include <LuaType/LuaUObject.hpp>
#include <DynamicOutput/Output.hpp>

namespace RC::LuaType
{
    FWeakObjectPtr::FWeakObjectPtr(Unreal::FWeakObjectPtr object) : LocalObjectBase<Unreal::FWeakObjectPtr, FWeakObjectPtrName>(std::move(object)) {}

    auto FWeakObjectPtr::construct(const LuaMadeSimple::Lua& lua, Unreal::FWeakObjectPtr unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::FWeakObjectPtr lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::FWeakObjectPtr>(metatable_name, lua_object.get_metamethods());
        }

        // Transfer the object & its ownership fully to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto FWeakObjectPtr::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto FWeakObjectPtr::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // FWeakObjectPtr has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto FWeakObjectPtr::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("Get", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<FWeakObjectPtr>();
            LuaType::auto_construct_object(lua, lua_object.get_local_cpp_object().Get());
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaMod.cpp`:

```cpp
#include <LuaType/LuaMod.hpp>

namespace RC::LuaType
{
    Mod::Mod(RC::Mod* object) : RemoteObjectBase<RC::Mod, ModName>(object) {}

    auto Mod::construct(const LuaMadeSimple::Lua& lua, RC::Mod* cpp_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::Mod lua_object{cpp_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::Mod>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto Mod::setup_metamethods(BaseObject&) -> void
    {
        // Mod has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto Mod::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaTArray.cpp`:

```cpp
#include <format>

#include <LuaType/LuaTArray.hpp>
#include <LuaType/LuaUObject.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    TArray::TArray(const PusherParams& params) :
            RemoteObjectBase<Unreal::FScriptArray, TArrayName>(static_cast<Unreal::FScriptArray*>(params.data)),
            m_base(params.base),
            
            m_property(static_cast<Unreal::FArrayProperty*>(params.property)),
            m_inner_property(m_property->GetInner())
    {
    }

    auto TArray::construct(const PusherParams& params) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::TArray lua_object{params};

        if (!lua_object.m_inner_property)
        {
            Output::send<LogLevel::Error>(STR("TArray::construct: m_inner_property is nullptr for {}"), lua_object.m_property->GetFullName());
        }

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = params.lua.get_metatable(metatable_name);
        if (params.lua.is_nil(-1))
        {
            params.lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FScriptArray>::construct(params.lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            params.lua.new_metatable<LuaType::TArray>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        params.lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto TArray::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FScriptArray>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto TArray::setup_metamethods(BaseObject& base_object) -> void
    {
        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Index, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(LuaMadeSimple::Type::Operation::Get, lua);
            return 1;
        });

        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::NewIndex, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(LuaMadeSimple::Type::Operation::Set, lua);
            return 1;
        });

        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Length, [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();
            lua.set_integer(lua_object.get_remote_cpp_object()->Num());
            return 1;
        });
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto TArray::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetArrayAddress", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();

            lua.set_integer(reinterpret_cast<uintptr_t>(lua_object.get_remote_cpp_object()));

            return 1;
        });

        table.add_pair("GetArrayNum", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();

            lua.set_integer(lua_object.get_remote_cpp_object()->Num());

            return 1;
        });

        table.add_pair("GetArrayMax", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();

            lua.set_integer(lua_object.get_remote_cpp_object()->Max());

            return 1;
        });

        table.add_pair("GetArrayDataAddress", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();

            lua.set_integer(reinterpret_cast<uintptr_t>(lua_object.get_remote_cpp_object()->GetData()));

            return 1;
        });

        // This is a read-only ForEach implementation (if inner type is trivial)
        // TODO: Make it writable
        table.add_pair("ForEach", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TArray>();

            Unreal::FName property_type_name = lua_object.m_inner_property->GetClass().GetFName();
            int32_t name_comparison_index = property_type_name.GetComparisonIndex();

            if (StaticState::m_property_value_pushers.contains(name_comparison_index))
            {
                uint8_t* array_data = static_cast<uint8_t*>(lua_object.get_remote_cpp_object()->GetData());

                int32_t array_size = lua_object.get_remote_cpp_object()->Num();
                for (int32_t i = 0; i < array_size; ++i)
                {
                    // Duplicate the Lua function so that we can use it in subsequent iterations of this loop (call_function pops the function from the stack)
                    lua_pushvalue(lua.get_lua_state(), 1);

                    // Set the 'index' parameter for the Lua function (P1)
                    lua.set_integer(i + 1); // Adding 1 here to account for that fact that Lua tables are 1-indexed

                    // Set the 'elem' parameter for the Lua function (P2)
                    // TODO: Fix crash that occurs here.
                    //       It appears that the Lua stack is getting corrupted somehow, or lua_object is getting GC'd by Lua.
                    //       It seems to only affect large arrays, and I don't know how to fix it.
                    void* property_value = array_data + (i * lua_object.m_inner_property->GetElementSize());
                    const PusherParams pusher_params{
                            .operation = LuaMadeSimple::Type::Operation::GetParam,
                            .lua = lua,
                            .base = lua_object.m_base,
                            .data = property_value,
                            .property = lua_object.m_inner_property
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);

                    // Call function passing index & the element
                    // The element is read-only for all trivial types
                    // The element is writable if it's a UObject
                    lua.call_function(2, 0);
                }
            }
            else
            {
                lua.throw_error(std::format("[TArray:ForEach] Tried iterating an array but the unreal property has no registered handler (via ArrayProperty). Property type '{}' not supported.", to_string(property_type_name.ToString())));
            }

            return 0;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }

    auto TArray::handle_unreal_property_value(const LuaMadeSimple::Type::Operation operation, const LuaMadeSimple::Lua& lua, Unreal::FScriptArray* array, int64_t array_index, const TArray& lua_object) -> void
    {
        Unreal::FName property_type_fname = lua_object.m_inner_property->GetClass().GetFName();
        int32_t name_comparison_index = property_type_fname.GetComparisonIndex();

        if (StaticState::m_property_value_pushers.contains(name_comparison_index))
        {
            uint8_t* array_data = static_cast<uint8_t*>(array->GetData());
            void* property_value = array_data + (array_index * lua_object.m_inner_property->GetElementSize());

            const PusherParams pusher_params{
                    .operation = operation,
                    .lua = lua,
                    .base = lua_object.m_base,
                    .data = property_value,
                    .property = lua_object.m_inner_property
            };
            StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
        }
        else
        {
            std::string property_type_name = to_string(property_type_fname.ToString());
            lua.throw_error(std::format("Tried accessing unreal property without a registered handler (via ArrayProperty). Property type '{}' not supported.", property_type_name));
        }
    }

    auto TArray::prepare_to_handle(const LuaMadeSimple::Type::Operation operation, const LuaMadeSimple::Lua& lua) -> void
    {
        auto& lua_object = lua.get_userdata<TArray>();
        int64_t array_index = lua.get_integer() - 1; // Subtracting 1 here to account for that fact that Lua tables are 1-indexed

        if (array_index > lua_object.get_remote_cpp_object()->Num())
        {
            if (operation == Operation::Get || operation == Operation::GetParam)
            {
                Output::send(STR("[Error][Lua] Tried accessing element of TArray but the index was out of range\n"));
                lua.set_nil();
            }

            return;
        }

        handle_unreal_property_value(operation, lua, lua_object.get_remote_cpp_object(), array_index, lua_object);
    }
}

```

`src/LuaType/LuaTSoftClassPtr.cpp`:

```cpp
#include <LuaType/LuaTSoftClassPtr.hpp>
#include <LuaType/LuaFWeakObjectPtr.hpp>
#include <LuaType/LuaFSoftObjectPath.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>

namespace RC::LuaType
{
    TSoftClassPtr::TSoftClassPtr(Unreal::FSoftObjectPtr object) : LocalObjectBase<Unreal::FSoftObjectPtr, TSoftClassPtrName>(std::move(object)) {}

    auto TSoftClassPtr::construct(const LuaMadeSimple::Lua& lua, Unreal::FSoftObjectPtr& unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::TSoftClassPtr lua_object{unreal_object};

        auto metatable_name = "TSoftClassPtrUserdata";

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table, metatable_name);
            lua.new_metatable<LuaType::TSoftClassPtr>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto TSoftClassPtr::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();;

        auto metatable_name = "TSoftClassPtrUserdata";

        setup_metamethods(construct_to);
        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table, metatable_name);

        return table;
    }

    auto TSoftClassPtr::setup_metamethods(BaseObject& base_object) -> void
    {

    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto TSoftClassPtr::setup_member_functions(LuaMadeSimple::Lua::Table& table, std::string_view metatable_name) -> void
    {
        table.add_pair("GetTagAtLastTest", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TSoftClassPtr>();
            lua.set_integer(lua_object.get_local_cpp_object().TagAtLastTest);
            return 1;
        });

        table.add_pair("GetObjectID", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<TSoftClassPtr>();
            FSoftObjectPath::construct(lua, lua_object.get_local_cpp_object().ObjectID);
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string("TSoftClassPtrUserdata");
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(metatable_name);// , is_final == LuaMadeSimple::Type::IsFinal::No);
        }
    }
}

```

`src/LuaType/LuaUClass.cpp`:

```cpp
#include <LuaType/LuaUClass.hpp>
#include <LuaType/LuaUFunction.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UFunction.hpp>
#include <DynamicOutput/Output.hpp>

namespace RC::LuaType
{
    UClass::UClass(Unreal::UClass* object) : UObjectBase<Unreal::UClass, UClassName>(object) /*LuaMadeSimple::Type::RemoteObject<Unreal::UClass>("UClass", object)*/ {}

    auto UClass::construct(const LuaMadeSimple::Lua& lua, Unreal::UClass* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UClass lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UClass>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UClass::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UClass::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // UClass has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UClass::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        // CDO = ClassDefaultObject
        table.add_pair("GetCDO", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<UClass>();

            if (!lua_object.get_remote_cpp_object())
            {
                LuaType::UObject::construct(lua, nullptr);
                Output::send(STR("[Lua][Error] Tried getting the CDO but the UClass instance is nullptr\n"));
            }
            else
            {
                LuaType::UObject::construct(lua, lua_object.get_remote_cpp_object()->GetClassDefaultObject());
            }

            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaUEnum.cpp`:

```cpp
#include <LuaType/LuaUEnum.hpp>
#include <LuaType/LuaFName.hpp>
#include <Unreal/UEnum.hpp>

namespace RC::LuaType
{
    UEnum::UEnum(Unreal::UEnum* object) : RemoteObjectBase<Unreal::UEnum, UEnumName>(object) {}

    auto UEnum::construct(const LuaMadeSimple::Lua& lua, Unreal::UEnum* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UEnum lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UEnum>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UEnum::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UEnum::setup_metamethods(BaseObject&) -> void
    {
        // UEnum has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UEnum::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetNameByValue", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UEnum.GetNameByValue'.
Overloads:
#1: GetNameByValue(integer Value))"};

            auto& lua_object = lua.get_userdata<UEnum>();

            if (!lua.is_integer())
            {
                lua.throw_error(error_overload_not_found);
            }

            auto value = lua.get_integer();
            LuaType::FName::construct(lua, lua_object.get_remote_cpp_object()->GetNameByValue(value));
            return 1;
        });

        table.add_pair("ForEachName", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UEnum.ForEachName'.
Overloads:
#1: ForEachName(LuaFunction Callback))"};

            auto& lua_object = lua.get_userdata<UEnum>();

            lua_object.get_remote_cpp_object()->ForEachName([&](Unreal::FName name, int64_t value) {
                // Duplicate the Lua function so that we can use it in subsequent iterations of this loop (call_function pops the function from the stack)
                lua_pushvalue(lua.get_lua_state(), 1);

                // Set the 'Name' parameter for the Lua function (P1)
                LuaType::FName::construct(lua, name);

                // Set the 'Value' parameter for the Lua function (P2)
                lua.set_integer(value);

                lua.call_function(2, 1);

                // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                if (lua.is_bool(2) && lua.get_bool(2))
                {
                    return LoopAction::Break;
                }                else
                {
                    // There's a 'nil' on the stack because we told Lua that we expect a return value.
                    // Lua will put 'nil' on the stack if the Lua function doesn't explicitly return anything.
                    // We discard the 'nil' here, otherwise the Lua stack is corrupted on the next iteration of the 'ForEachFunction' loop.
                    // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                    lua.discard_value(2);
                    return LoopAction::Continue;
                }
            });

            return 0;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaUFunction.cpp`:

```cpp
#include <format>

#include <LuaType/LuaUFunction.hpp>
#include <Helpers/Integer.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    auto DynamicUnrealFunctionOutParameters::add(const PropertyAndLuaRefPair param_ref_pair) -> void
    {
        m_params[m_last] = param_ref_pair;
        ++m_last;
    }

    auto DynamicUnrealFunctionOutParameters::get(size_t index) -> const PropertyAndLuaRefPair&
    {
        return m_params[index];
    }

    auto DynamicUnrealFunctionOutParameters::get() -> const DynamicUnrealFunctionOutParameters::ParamsArray&
    {
        return m_params;
    }

    UFunction::UFunction(Unreal::UObject* base, Unreal::UFunction* function) : UObjectBase<Unreal::UFunction, UFunctionName>(function), m_base(base) {}

    auto UFunction::construct(const LuaMadeSimple::Lua& lua, Unreal::UObject* owning_object, Unreal::UFunction* function) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UFunction lua_object{owning_object, function};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UFunction>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UFunction::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UFunction::setup_metamethods(BaseObject& base_object) -> void
    {
        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Call, [](const LuaMadeSimple::Lua& lua) -> int {
            return call_ufunction_from_lua(lua);
        });
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UFunction::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaUObject.cpp`:

```cpp
#include <Helpers/Casting.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUStruct.hpp>
#include <LuaType/LuaUClass.hpp>
#include <LuaType/LuaFName.hpp>
#include <LuaType/LuaAActor.hpp>
#include <LuaType/LuaUScriptStruct.hpp>
#include <LuaType/LuaTArray.hpp>
#include <LuaType/LuaUFunction.hpp>
#include <LuaType/LuaFText.hpp>
#include <LuaType/LuaFString.hpp>
#include <LuaType/LuaXProperty.hpp>
#include <LuaType/LuaFWeakObjectPtr.hpp>
#include <LuaType/LuaCustomProperty.hpp>
#include <LuaType/LuaXObjectProperty.hpp>
#include <LuaType/LuaUWorld.hpp>
#include <LuaType/LuaUEnum.hpp>
#include <LuaType/LuaTSoftClassPtr.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/FText.hpp>
#include <Unreal/FString.hpp>
#include <Unreal/FScriptArray.hpp>
#include <Unreal/World.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>
#pragma warning(default: 4005)
#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/Integer.hpp>

namespace RC::LuaType
{
    auto call_ufunction_from_lua(const LuaMadeSimple::Lua& lua) -> int
    {
        if (!lua.is_userdata())
        {
            lua.throw_error("[UFunction::setup_metamethods -> __call] Attempted to call a UFunction without UFunction userdata attached");
        }

        auto& lua_object = lua.get_userdata<LuaType::UFunction>();

        Unreal::UFunction* func{};
        Unreal::UObject* calling_context{};
        bool is_first_userdata_function = lua_object.get_remote_cpp_object()->IsA<Unreal::UFunction>();

        if (is_first_userdata_function)
        {
            func = lua_object.get_remote_cpp_object();
            calling_context = lua_object.get_base();
        }
        else
        {
            calling_context = lua_object.get_remote_cpp_object();
        }

        if (lua.is_userdata())
        {
            auto& lua_object2 = lua.get_userdata<LuaType::UFunction>();
            if (!is_first_userdata_function && lua_object2.get_remote_cpp_object()->IsA<Unreal::UFunction>())
            {
                func = lua_object2.get_remote_cpp_object();
            }
        }

        if (!func || !calling_context)
        {
            lua.throw_error("[UFunction::call_ufunction_from_lua] Tried calling function without both UFunction and calling context");
        }

        uint8_t num_ufunc_params = func->GetNumParms();
        uint16_t return_value_offset = func->GetReturnValueOffset();

        //Unreal::FProperty* param_next = func->get_child_properties<Unreal::FProperty*>();
        Unreal::FProperty* return_value_property{};
        Unreal::FName return_value_property_type{0u, 0u};
        int32_t return_value_property_offset_internal{};

        DynamicUnrealFunctionData dynamic_unreal_function_data{};
        DynamicUnrealFunctionOutParameters dynamic_unreal_function_out_parameters{};
        bool has_out_params{false};

        //if (param_next)
        if (func->HasChildren())
        {
            uint8_t num_supplied_params = Helper::Integer::to<uint8_t>(lua.get_stack_size());

            // When return_value_offset is 0xFFFF it means that there is no return value so num_ufunc_params is accurate
            // Otherwise you must subtract 1 to account for the return value (stored in the same struct and counts as a param)
            // The ternary makes sure that we never have a negative number of params
            bool has_return_value = return_value_offset != 0xFFFF;
            uint8_t num_expected_params = num_ufunc_params;
            uint8_t num_expected_params_with_return_value = has_return_value ? (num_expected_params - 1 < 0 ? 0 : num_expected_params - 1) : num_expected_params;

            if (num_supplied_params != num_expected_params_with_return_value)
            {
                lua.throw_error(std::format("[UFunction::setup_metamethods -> __call] UFunction expected {} parameters, received {}", num_expected_params, num_supplied_params));
            }

            //for (uint8_t i = 0; i < num_expected_params; ++i)
            uint8_t i = 0;
            func->ForEachProperty([&](Unreal::FProperty* param_next) {
                //if (i > 0)
                //{
                //    // If not the first iteration then get the next param
                //    // If it's the first iteration then paramNext was already set earlier
                //    param_next = param_next->get_next<Unreal::XProperty*>();
                //}

                //if (!param_next)
                //{
                //    break;
                //}

                int32_t offset_internal = param_next->GetOffset_Internal();
                Unreal::FName property_type_fname = param_next->GetClass().GetFName();

                // Is the offset of this parameter is the same as the ReturnValueOffset in the UFunction ?
                // If yes, then this parameter should be treated as the return value
                // If no, then treat this as just another parameter
                if (offset_internal == return_value_offset)
                {
                    return_value_property = param_next;
                    return_value_property_type = property_type_fname;
                    return_value_property_offset_internal = offset_internal;
                }
                else
                {
                    if (param_next->HasAnyPropertyFlags(Unreal::CPF_OutParm) && !param_next->HasAnyPropertyFlags(Unreal::CPF_ReturnParm) && !param_next->HasAnyPropertyFlags(Unreal::CPF_ConstParm))
                    {
                        has_out_params = true;

                        // Store pointer to params property, and a Lua ref to the corresponding table

                        if (!lua.is_table())
                        {
                            lua.throw_error("Tried storing reference to a Lua table for an 'Out' parameter when calling a UFunction but no table was on the stack");
                        }

                        // Duplicate the Lua function to the top of the stack for luaL_ref
                        lua_pushvalue(lua.get_lua_state(), 1);

                        // Take a reference to the Lua function (it also pops it of the stack)
                        dynamic_unreal_function_out_parameters.add({
                                                                           .property = param_next,
                                                                           .lua_ref = lua.registry().make_ref()
                                                                   });
                    }

                    int32_t name_comparison_index = property_type_fname.GetComparisonIndex();

                    if (StaticState::m_property_value_pushers.contains(name_comparison_index))
                    {
                        void* data = &dynamic_unreal_function_data.data[offset_internal];

                        const PusherParams pusher_params{
                                .operation = Operation::Set,
                                .lua = lua,
                                .base = static_cast<Unreal::UObject*>(static_cast<void*>(dynamic_unreal_function_data.data)),
                                .data = data,
                                .property = param_next
                        };
                        StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
                    }
                    else
                    {
                        std::string parameter_type_name = to_string(property_type_fname.ToString());
                        std::string parameter_name = to_string(param_next->GetName());
                        lua.throw_error(std::format("Tried calling UFunction without a registered handler for parameter. Parameter '{}' of type '{}' not supported.", parameter_name, parameter_type_name));
                    }
                }

                return LoopAction::Continue;
            });
        }

        // It's assumed that everything is safe here
        // Every part of the system is designed to throw when stuff goes wrong
        // This code should never be executed in those cases
        calling_context->ProcessEvent(func, dynamic_unreal_function_data.data);

        // If there are any 'Out' params, update the table that they correspond to
        if (has_out_params)
        {
            for (auto const [param, lua_table_ref] : dynamic_unreal_function_out_parameters.get())
            {
                if (!param)
                {
                    break;
                }

                // Use the stored registry index to put the original Lua table for the 'Out' param back on the stack
                lua.registry().get_table_ref(lua_table_ref);
                auto lua_table = lua.get_table();

                Unreal::FName param_type_fname = param->GetClass().GetFName();
                int32_t name_comparison_index = param_type_fname.GetComparisonIndex();

                if (StaticState::m_property_value_pushers.contains(name_comparison_index))
                {
                    uint8_t* data = &dynamic_unreal_function_data.data[param->GetOffset_Internal()];

                    const PusherParams pusher_params{
                            .operation = Operation::GetNonTrivialLocal,
                            .lua = lua,
                            .base = static_cast<Unreal::UObject*>(static_cast<void*>(dynamic_unreal_function_data.data)),
                            .data = data,
                            .property = param,
                            .create_new_if_get_non_trivial_local = false,
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
                }
                else
                {
                    std::string param_type_name = to_string(param_type_fname.ToString());
                    lua.throw_error(std::format("Tried calling UFunction without a registered handler 'Out' param. Type '{}' not supported.", param_type_name));
                }
            }
        }

        // If there's a return value, then forward it to the Lua script
        if (return_value_property)
        {
            int32_t name_comparison_index = return_value_property_type.GetComparisonIndex();

            if (StaticState::m_property_value_pushers.contains(name_comparison_index))
            {
                uint8_t* data = &dynamic_unreal_function_data.data[return_value_property_offset_internal];

                const PusherParams pusher_params{
                        .operation = Operation::GetNonTrivialLocal,
                        .lua = lua,
                        .base = static_cast<Unreal::UObject*>(static_cast<void*>(data)), // Base is the start of the params struct
                        .data = data,
                        .property = return_value_property
                };
                StaticState::m_property_value_pushers[name_comparison_index](pusher_params);

                return 1;
            }
            else
            {
                std::string return_value_type_name = to_string(return_value_property_type.ToString());
                lua.throw_error(std::format("Tried calling UFunction without a registered handler for return value. Return value of type '{}' not supported.", return_value_type_name));
            }

            return 0;
        }
        else
        {
            return 0;
        }
    }

    auto auto_construct_object(const LuaMadeSimple::Lua& lua, Unreal::UObject* object) -> void
    {
        // If the UObject is nullptr (which is valid), then construct an empty Lua object to enable chaining
        if (!object)
        {
            UObject::construct(lua, nullptr);
        }
        else if (object->IsA<Unreal::UClass>())
        {
            UClass::construct(lua, static_cast<Unreal::UClass*>(object));
        }
        else if (object->IsA<Unreal::UScriptStruct>())
        {
            ScriptStructWrapper script_struct_wrapper{static_cast<Unreal::UScriptStruct*>(object), nullptr, nullptr};
            UScriptStruct::construct(lua, script_struct_wrapper);
        }
        else if (object->IsA<Unreal::UStruct>())
        {
            UStruct::construct(lua, static_cast<Unreal::UStruct*>(object));
        }
        else if (object->IsA<Unreal::UEnum>())
        {
            UEnum::construct(lua, static_cast<Unreal::UEnum*>(object));
        }
        else if (object->IsA<Unreal::UWorld>())
        {
            UWorld::construct(lua, static_cast<Unreal::UWorld*>(object));
        }
        else if (object->IsA<Unreal::AActor>())
        {
            AActor::construct(lua, static_cast<Unreal::AActor*>(object));
        }
        else
        {
            UObject::construct(lua, object);
        }
    }

    auto construct_fname(const LuaMadeSimple::Lua& lua) -> void
    {
        const auto& lua_object = lua.get_userdata<UObject>();
        LuaType::FName::construct(lua, lua_object.get_remote_cpp_object()->GetNamePrivate());
    }

    auto construct_uclass(const LuaMadeSimple::Lua& lua) -> void
    {
        const auto& lua_object = lua.get_userdata<UObject>();
        LuaType::UClass::construct(lua, lua_object.get_remote_cpp_object()->GetClassPrivate());
    }

    auto construct_xproperty(const LuaMadeSimple::Lua& lua, Unreal::FProperty* property) -> void
    {
        auto_construct_property(lua, property);
    }

    auto push_unhandledproperty([[maybe_unused]]const PusherParams& params) -> void
    {
        // TODO: Implement or remove this function
    }

    auto push_objectproperty(const PusherParams& params) -> void
    {
        // We're already setup for the alternate branch inside the get_property_vc() function
        // We don't need to supply a property name because the alternate branch has already been told about the property from the push_unreal_object() function()
        Unreal::UObject** property_value = static_cast<Unreal::UObject**>(params.data);

        // Finally construct the Lua object
        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                auto_construct_object(params.lua, *property_value);
                break;
            case Operation::Set:
            {
                if (params.lua.is_userdata())
                {
                    const auto& lua_object = params.lua.get_userdata<LuaType::UObject>(params.stored_at_index);
                    *property_value = lua_object.get_remote_cpp_object();
                }
                else if (params.lua.is_nil())
                {
                    params.lua.discard_value();
                }
                else
                {
                    params.lua.throw_error("[push_objectproperty] Value must be UObject or nil");
                }
                break;
            }
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
                break;
            default:
                params.lua.throw_error("[push_objectproperty] Unhandled Operation");
                break;
        }
    }

    auto push_classproperty(const PusherParams& params) -> void
    {
        Unreal::UClass** property_value = static_cast<Unreal::UClass**>(params.data);

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                LuaType::UClass::construct(params.lua, *property_value);
                break;
            case Operation::Set:
            {
                if (params.lua.is_userdata())
                {
                    const auto& lua_object = params.lua.get_userdata<LuaType::UClass>(params.stored_at_index);
                    *property_value = lua_object.get_remote_cpp_object();
                }
                else if (params.lua.is_nil())
                {
                    params.lua.discard_value();
                }
                else
                {
                    params.lua.throw_error("[push_classproperty] Value must be UClass or nil");
                }
                break;
            }
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
                break;
            default:
                params.lua.throw_error("[push_classproperty] Unhandled Operation");
                break;
        }
    }

    auto push_int8property(const PusherParams& params) -> void
    {
        // Some code that might be useful later
        // Keeping it here for now
        /*
        LuaType::Object<int8_t>::construct(lua, property_value, [&](const LuaMadeSimple::Lua& lua, int8_t* value) {
            printf_s("returning Int8Property\n");
            lua.set_integer(*value);
        });
        //*/

        push_integer<int8_t>(params);
    }

    auto push_int16property(const PusherParams& params) -> void
    {
        push_integer<int16_t>(params);
    }

    auto push_intproperty(const PusherParams& params) -> void
    {
        push_integer<int32_t>(params);
    }

    auto push_int64property(const PusherParams& params) -> void
    {
        push_integer<int64_t>(params);
    }

    auto push_byteproperty(const PusherParams& params) -> void
    {
        push_integer<uint8_t>(params);
    }

    auto push_uint16property(const PusherParams& params) -> void
    {
        push_integer<uint16_t>(params);
    }

    auto push_uint32property(const PusherParams& params) -> void
    {
        push_integer<uint32_t>(params);
    }

    auto push_uint64property(const PusherParams& params) -> void
    {
        push_integer<uint64_t>(params);
    }

    auto push_structproperty(const PusherParams& params) -> void
    {
        // params.base = Base of the object that this struct belongs in
        // params.data = Start of the struct
        // params.property = The corresponding FStructProperty
        auto* struct_property = Unreal::CastField<Unreal::FStructProperty>(params.property);
        auto* script_struct = struct_property->GetStruct();

        auto iterate_struct_and_turn_into_lua_table = [&](const LuaMadeSimple::Lua& lua, void* data_ptr) {
            auto* data = static_cast<unsigned char*>(data_ptr);

            // Get the table from the stack or create a new one
            LuaMadeSimple::Lua::Table lua_table = [&](){
                if (params.create_new_if_get_non_trivial_local)
                {
                    return lua.prepare_new_table();
                }
                else
                {
                    return lua.get_table();
                }
            }();

            // Put all the script struct properties into the table
            script_struct->ForEachPropertyInChain([&](Unreal::FProperty* field) {
                // There can be non-property items in the linked list, like 'ExecuteUbergraph'
                // We only care about actual properties, so let's ignore anything else
                // TODO: This may have only been the case before the ForEachProperty abstraction
                //       The abstraction filters out any non-property types
                //       Commenting out this code for now, should investigate this later to confirm
                //if (!Unreal::TypeChecker::is_property(field))
                //{
                //    return LoopAction::Continue;
                //}

                std::string field_name = to_string(field->GetName());

                Unreal::FName field_type = field->GetClass().GetFName();
                int32_t name_comparison_index = field_type.GetComparisonIndex();

                if (StaticState::m_property_value_pushers.contains(name_comparison_index))
                {
                    // This example uses the Vector struct and its "IntProperty Vector:X" property
                    // Push key (i.e: X)
                    lua_table.add_key(field_name.c_str());

                    // Push value (i.e: 4.243)
                    const PusherParams pusher_params{
                            .operation = Operation::GetNonTrivialLocal,
                            .lua = lua,
                            .base = Helper::Casting::ptr_cast<Unreal::UObject*>(data), // Base is the start of the params struct
                            .data = &data[field->GetOffset_Internal()],
                            .property = field,
                            .stored_at_index = params.stored_at_index
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);

                    // On the top of the stack now: Value for this field in the struct
                    lua_table.fuse_pair();
                }
                else
                {
                    std::string field_type_name = to_string(field_type.ToString());
                    lua.throw_error(std::format("Tried getting without a registered handler. 'StructProperty'.'{}' not supported. Field: '{}'", field_type_name, field_name));
                }

                return LoopAction::Continue;
            });

            lua_table.make_local();
        };

        auto lua_table_to_memory = [&]() {
            // At the bottom of the stack now: table that has struct data

            // Duplicating the table and putting the duplicate at the top of the stack
            lua_pushvalue(params.lua.get_lua_state(), 1);

            script_struct->ForEachPropertyInChain([&](Unreal::FProperty* field) {
                Unreal::FName field_type_fname = field->GetClass().GetFName();
                const std::string field_name = to_string(field->GetName());

                // At the top of the stack now: table that has struct data

                // Pushing the field name (key for the table)
                lua_pushstring(params.lua.get_lua_state(), field_name.c_str());

                // At the top of the stack now: key to find in table (string)

                // Pushing on to the stack, the value corresponding to table[key] if it exists
                auto table_value_type = lua_rawget(params.lua.get_lua_state(), -2);

                // At the top of the stack now: the value corresponding to table[key] or nil

                // If there was nothing in the table for this field, leave default value and move on to the next field
                if (table_value_type == LUA_TNIL || table_value_type == LUA_TNONE)
                {
                    // Remove the 'nil' from the stack
                    params.lua.discard_value(-1);
                    return LoopAction::Continue;
                }

                int32_t name_comparison_index = field_type_fname.GetComparisonIndex();

                if (StaticState::m_property_value_pushers.contains(name_comparison_index))
                {
                    unsigned char* data = static_cast<unsigned char*>(params.data);
                    data = &data[field->GetOffset_Internal()];

                    const PusherParams pusher_params{
                            .operation = Operation::Set,
                            .lua = params.lua,
                            .base = static_cast<Unreal::UObject*>(params.data), // Base is the start of the params struct
                            .data = data,
                            .property = field,
                            .stored_at_index = -1 // Using -1 here because we know the value is at the top of the stack instead of at the bottom of the stack
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
                }
                else
                {
                    std::string field_type_name = to_string(field_type_fname.ToString());
                    params.lua.throw_error(std::format("Tried pushing (Operation::Set) StructProperty without a registered handler for field '{} {}'.", field_type_name, field_name));
                }

                return LoopAction::Continue;
            });

            // Discard the original & the duplicated tables
            params.lua.discard_value(1); // Original
            params.lua.discard_value(-1); // Duplicated
        };

        auto lua_to_memory = [&]() {
            if (params.lua.is_userdata())
            {
                // StructData as userdata
                params.lua.throw_error("[push_structproperty::lua_to_memory] StructData as userdata is not yet implemented but there's userdata on the stack");
            }
            else if (params.lua.is_table())
            {
                // StructData as table
                lua_table_to_memory();
            }
            else if (params.lua.is_nil())
            {
                params.lua.discard_value();
            }
            else
            {
                params.lua.throw_error("[push_structproperty::lua_to_memory] Parameter must be of type 'StructProperty' or table");
            }
        };

        auto property_value = ScriptStructWrapper{struct_property->GetStruct(), params.data, struct_property};

        switch (params.operation)
        {
            case Operation::Get:
                UScriptStruct::construct(params.lua, property_value);
                return;
            case Operation::GetNonTrivialLocal:
                iterate_struct_and_turn_into_lua_table(params.lua, params.data);
                return;
            case Operation::Set:
                lua_to_memory();
                return;
            case Operation::GetParam:
                LocalUnrealParam<ScriptStructWrapper>::construct(params.lua, property_value, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_structproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_structproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_arrayproperty(const PusherParams& params) -> void
    {
        auto iterate_array_and_turn_into_lua_table = [&](const LuaMadeSimple::Lua& lua, Unreal::FProperty* array_property, void* data_ptr) {
            auto array_inner = static_cast<Unreal::FArrayProperty*>(array_property)->GetInner();
            Unreal::FName property_type_fname = array_inner->GetClass().GetFName();
            int32_t name_comparison_index = property_type_fname.GetComparisonIndex();

            if (StaticState::m_property_value_pushers.contains(name_comparison_index))
            {
                Unreal::FScriptArray* array_container = static_cast<Unreal::FScriptArray*>(data_ptr);

                uint8_t* array_data = static_cast<uint8_t*>(array_container->GetData());
                int32_t array_size = array_container->Num();

                // Get the table from the stack or create a new one
                LuaMadeSimple::Lua::Table lua_table = [&]() {
                    if (params.create_new_if_get_non_trivial_local)
                    {
                        return lua.prepare_new_table();
                    }
                    else
                    {
                        return lua.get_table();
                    }
                }();

                for (int32_t i = 0; i < array_size; ++i)
                {
                    //Array index
                    lua_table.add_key(i + 1);

                    const PusherParams pusher_params{
                            .operation = LuaMadeSimple::Type::Operation::GetParam,
                            .lua = lua,
                            .base = params.base,
                            .data = array_data + (i * array_inner->GetElementSize()),
                            .property = array_inner
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);

                    lua_table.fuse_pair();
                }

                lua_table.make_local();
            }
            else
            {
                std::string property_type_name = to_string(property_type_fname.ToString());
                lua.throw_error(std::format("Tried interacting with an array but the inner property has no registered handler. Property type '{}' not supported.", property_type_name));
            }
        };

        auto lua_table_to_memory = [&]() {
            Unreal::FArrayProperty* array_property = static_cast<Unreal::FArrayProperty*>(params.property);
            Unreal::FProperty* inner = array_property->GetInner();
            Unreal::FName inner_type_fname = inner->GetClass().GetFName();

            int32_t name_comparison_index = inner_type_fname.GetComparisonIndex();
            if (!StaticState::m_property_value_pushers.contains(name_comparison_index))
            {
                std::string inner_type_name = to_string(inner_type_fname.ToString());
                params.lua.throw_error(std::format("Tried pushing (Operation::Set) ArrayProperty with unsupported inner type of '{}'", inner_type_name));
            }

            size_t array_element_size = inner->GetElementSize();

            Unreal::FScriptArray* current_array{static_cast<Unreal::FScriptArray*>(params.data)};
            unsigned char* array{};
            size_t table_length = lua_rawlen(params.lua.get_lua_state(), 1);
            bool has_elements = table_length > 0;

            size_t element_index{0};

            if (has_elements)
            {
                array = new unsigned char[array_property->GetElementSize() * table_length];

                params.lua.for_each_in_table([&](LuaMadeSimple::LuaTableReference table) -> bool {
                    // Skip this table entry if the key wasn't numerical, who knows what the user put in their script
                    if (!table.key.is_integer()) { return false; }

                    params.lua.insert_value(-2);
                    const PusherParams pusher_params{
                            .operation = Operation::Set,
                            .lua = params.lua,
                            .base = static_cast<Unreal::UObject*>(static_cast<void*>(array)), // Base is the start of the params struct
                            .data = &array[array_element_size * element_index],
                            .property = inner
                    };
                    StaticState::m_property_value_pushers[name_comparison_index](pusher_params);

                    ++element_index;

                    return false;
                });
            }

            auto* new_script_array = static_cast<Unreal::FScriptArray*>(Unreal::FMemory::Malloc(sizeof(Unreal::FScriptArray)));

            auto* to_array = static_cast<Unreal::FScriptArray*>(params.data);
            if (has_elements)
            {
                //to_array->SetAllocatorInstance(array);
                //size_t new_array_num = element_index - 1 <= 0 ? 0 : element_index - 1;
                //to_array->SetArrayNum(static_cast<int32_t>(new_array_num));
                //to_array->SetArrayMax(to_array->GetArrayNum());
            }
            else
            {
                //to_array->SetAllocatorInstance(nullptr);
                //to_array->SetArrayNum(0);
                //to_array->SetArrayMax(0);
            }

            // Remove the table from the stack to remain consistent to the pusher system, if there were no elements
            // Otherwise it get removed in the end of for_each_in_table loop
            // Other systems might rely on this behavior
            if (!has_elements)
            {
                params.lua.discard_value();
            }
        };

        auto lua_to_memory = [&]() {
            if (params.lua.is_userdata())
            {
                // TArray as userdata
                params.lua.throw_error("[push_arrayproperty::lua_to_memory] StructData as userdata is not yet implemented but there's userdata on the stack");
            }
            else if (params.lua.is_table())
            {
                // TArray as table
                lua_table_to_memory();
            }
            else if (params.lua.is_nil())
            {
                params.lua.discard_value();
            }
            else
            {
                params.lua.throw_error("[push_arrayproperty::lua_to_memory] Parameter must be of type 'StructProperty' or table");
            }
        };

        switch (params.operation)
        {
            case Operation::Get:
                TArray::construct(params);
                return;
            case Operation::GetNonTrivialLocal:
                iterate_array_and_turn_into_lua_table(params.lua, params.property, params.data);
                return;
            case Operation::Set:
                lua_to_memory();
                return;
            case Operation::GetParam:
                // TODO: Test this
                RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_arrayproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_arrayproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_functionproperty(const FunctionPusherParams& params) -> void
    {
        UFunction::construct(params.lua, params.base, params.function);
    }

    auto push_floatproperty(const PusherParams& params) -> void
    {
        float* float_ptr = static_cast<float*>(params.data);
        if (!float_ptr) { params.lua.throw_error("[push_floatproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                params.lua.set_float(*float_ptr);
                return;
            case Operation::Set:
                *float_ptr = params.lua.get_float(params.stored_at_index);
                return;
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, float_ptr, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_floatproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_floatproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_doubleproperty(const PusherParams& params) -> void
    {
        double* double_ptr = static_cast<double*>(params.data);
        if (!double_ptr) { params.lua.throw_error("[push_doubleproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                params.lua.set_number(*double_ptr);
                return;
            case Operation::Set:
                *double_ptr = params.lua.get_number(params.stored_at_index);
                return;
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, double_ptr, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_doubleproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_doubleproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_boolproperty(const PusherParams& params) -> void
    {
        uint8_t* bitfield_ptr = static_cast<uint8_t*>(params.data);
        if (!bitfield_ptr) { params.lua.throw_error("[push_boolproperty] data pointer is nullptr"); }

        Unreal::FBoolProperty* bp = static_cast<Unreal::FBoolProperty*>(params.property);
        uint8_t field_mask = bp->GetFieldMask();
        uint8_t byte_offset = bp->GetByteOffset();
        uint8_t* byte_value = bitfield_ptr + byte_offset;

        switch (params.operation)
        {
            case Operation::Get:
                params.lua.set_bool(!!(*byte_value & field_mask));
                return;
            case Operation::GetNonTrivialLocal:
                params.lua.set_bool(*static_cast<bool*>(params.data));
                return;
            case Operation::Set:
            {
                uint8_t byte_mask = bp->GetByteMask();

                *byte_value = ((*byte_value) & ~field_mask) | (params.lua.get_bool(params.stored_at_index) ? byte_mask : 0);
                return;
            }
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, bitfield_ptr, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_boolproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_boolproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_enumproperty(const PusherParams& params) -> void
    {
        Unreal::UEnum* enum_ptr = static_cast<Unreal::FEnumProperty*>(params.property)->GetEnum();
        if (!enum_ptr) { params.lua.throw_error("[push_enumproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
            {
                // Make global table to store enum name/value pairs -> START
                auto table = params.lua.prepare_new_table();

                std::string prop_name = to_string(params.property->GetName());

                auto& names = enum_ptr->GetEnumNames();

                names.ForEach([&](Unreal::FEnumNamePair* elem, [[maybe_unused]]size_t index) {
                    std::string elem_name = to_string(elem->Key.ToString());
                    table.add_pair(elem_name.c_str(), static_cast<unsigned int>(elem->Value));

                    return LoopAction::Continue;
                });

                // TODO: Optimize this... it'll probably do a dynamic allocation here in order to fit the new beginning of the string
                prop_name.insert(0, "Enum_");
                table.make_global(prop_name);
                // Make global table to store enum name/value pairs -> END

                // Push the actual enum value to the Lua stack
                params.lua.set_integer(*static_cast<uint8_t*>(params.data));

                return;
            }
            case Operation::Set:
                // TODO: Verify that this works
                // TODO: Bounds checking to make sure we don't set an invalid uint8_t because Lua can send us up to 64 bits
                *static_cast<uint8_t*>(params.data) = static_cast<uint8_t>(params.lua.get_integer(params.stored_at_index));
                return;
            case Operation::GetParam:
                // TODO: Verify that this works
                RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_enumproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_enumproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_weakobjectproperty(const PusherParams& params) -> void
    {
        if (!params.data) { params.lua.throw_error("[push_weakobjectproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
            {
                if (!params.data)
                {
                    LuaType::FWeakObjectPtr::construct(params.lua, Unreal::FWeakObjectPtr{});
                }
                else
                {
                    LuaType::FWeakObjectPtr::construct(params.lua, *static_cast<Unreal::FWeakObjectPtr*>(params.data));
                }
                return;
            }
            case Operation::Set:
                // For now, doing nothing just to get past the error
                Output::send(STR("[push_weakobjectproperty] Operation::Set is not supported\n"));
                return;
            case Operation::GetParam:
                params.lua.throw_error("[push_weakobjectproperty] Operation::GetParam is not supported");
                return;
            default:
                params.lua.throw_error("[push_weakobjectproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_weakobjectproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_nameproperty(const PusherParams& params) -> void
    {
        Unreal::FName* name = static_cast<Unreal::FName*>(params.data);
        if (!name) { params.lua.throw_error("[push_nameproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                LuaType::FName::construct(params.lua, *name);
                return;
            case Operation::Set:
            {
                auto& lua_object = params.lua.get_userdata<LuaType::FName>(params.stored_at_index);
                *name = lua_object.get_local_cpp_object();
                return;
            }
            case Operation::GetParam:
                params.lua.throw_error("[push_nameproperty] Operation::GetParam is not supported");
                return;
            default:
                params.lua.throw_error("[push_nameproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_nameproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_textproperty(const PusherParams& params) -> void
    {
        Unreal::FText* text = static_cast<Unreal::FText*>(params.data);
        if (!text) { params.lua.throw_error("[push_textproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                LuaType::FText::construct(params.lua, text);
                return;
            case Operation::Set:
            {
                auto& lua_other_object = params.lua.get_userdata<LuaType::FText>(params.stored_at_index);
                text->SetString(lua_other_object.get_remote_cpp_object()->ToFString());
                return;
            }
            case Operation::GetParam:
                params.lua.throw_error("[push_textproperty] Operation::GetParam is not supported");
                return;
            default:
                params.lua.throw_error("[push_textproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_textproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_strproperty(const PusherParams& params) -> void
    {
        Unreal::FString* string = static_cast<Unreal::FString*>(params.data);
        if (!string) { params.lua.throw_error("[push_strproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
            case Operation::GetNonTrivialLocal:
            case Operation::Get:
                LuaType::FString::construct(params.lua, string);
                return;
            case Operation::Set:
            {
                if (params.lua.is_string())
                {
                    auto lua_string = params.lua.get_string();
                    auto fstring = Unreal::FString{ to_wstring(lua_string).c_str() };
                    string->SetCharArray(fstring.GetCharTArray());
                }
                else if (params.lua.is_userdata())
                {
                    auto& rhs = params.lua.get_userdata<LuaType::FString>();
                    string->SetCharArray(rhs.get_remote_cpp_object()->GetCharTArray());
                }
                else
                {
                    params.lua.throw_error("[push_strproperty] StrProperty can only be set to a string or FString");
                }
                return;
            }
            case Operation::GetParam:
                RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
                return;
            default:
                params.lua.throw_error("[push_strproperty] Unhandled Operation");
                break;
        }

        params.lua.throw_error(std::format("[push_strproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto push_softclassproperty(const PusherParams& params) -> void
    {
        auto soft_ptr = static_cast<Unreal::FSoftObjectPtr*>(params.data);
        if (!soft_ptr) { params.lua.throw_error("[push_softclassproperty] data pointer is nullptr"); }

        switch (params.operation)
        {
        case Operation::GetNonTrivialLocal:
        case Operation::Get:
            LuaType::TSoftClassPtr::construct(params.lua, *soft_ptr);
            return;
        case Operation::Set:
        {
            auto& lua_object = params.lua.get_userdata<LuaType::TSoftClassPtr>(params.stored_at_index);
            *soft_ptr = lua_object.get_local_cpp_object();
            return;
        }
        case Operation::GetParam:
            RemoteUnrealParam::construct(params.lua, params.data, params.base, params.property);
            return;
        default:
            params.lua.throw_error("[push_softclassproperty] Unhandled Operation");
            break;
        }

        params.lua.throw_error(std::format("[push_softclassproperty] Unknown Operation ({}) not supported", static_cast<int32_t>(params.operation)));
    }

    auto static is_a_internal(const LuaMadeSimple::Lua& lua, Unreal::UObject* object, Unreal::UClass* object_class) -> bool
    {
        if (!object || !object_class)
        {
            return false;
        }
        else
        {
            return object->IsA(object_class);
        }
    }

    auto is_a_implementation(const LuaMadeSimple::Lua& lua) -> int
    {
        std::string error_overload_not_found{R"(
No overload found for function 'IsA'.
Overloads:
#1: IsA(UClass Class)
#2: IsA(string ObjectFullName)"};

        auto& lua_object = lua.get_userdata<UObject>();
        auto* object = lua_object.get_remote_cpp_object();

        if (lua.is_userdata())
        {
            auto& lua_object_class = lua.get_userdata<UClass>();
            auto* object_class = lua_object_class.get_remote_cpp_object();
            lua.set_bool(is_a_internal(lua, object, object_class));
        }
        else if (lua.is_string())
        {
            auto* object_class = Unreal::UObjectGlobals::StaticFindObject<Unreal::UClass*>(nullptr, nullptr, to_wstring(lua.get_string()));
            lua.set_bool(is_a_internal(lua, object, object_class));
        }
        else
        {
            lua.throw_error(error_overload_not_found);
        }

        return 1;
    }

    auto handle_unreal_property_value(const Operation operation, const LuaMadeSimple::Lua& lua, Unreal::UObject* base, Unreal::FName property_name, Unreal::FField* field) -> void
    {
        // In UE versions prior to 4.25, UFunctions can be found with 'find_property', and thus 'property' will not be nullptr
        // So you must take that into account when checking if the Lua script is trying to call a UFunction
        if (!field || field->GetClass().GetFName() == Unreal::GFunctionName)
        {
            Unreal::UFunction* func{};

            // We can take a shortcut if property is non-nullptr
            // It means that the UFunction was found and is stored in 'property', so we don't need to do anything to find it
            if (!field && property_name != Unreal::FName(0u, 0u))
            {
                std::vector<Unreal::UObject*> found_functions;
                Unreal::UObjectGlobals::FindObjects(Unreal::GFunctionName, property_name, found_functions);

                for (const auto& found_function : found_functions)
                {
                    Unreal::UStruct* inheritance_to_test = static_cast<Unreal::UStruct*>(found_function->GetOuterPrivate());
                    Unreal::UStruct* base_class = base->GetClassPrivate();

                    while (base_class)
                    {
                        if (inheritance_to_test == base_class)
                        {
                            func = static_cast<Unreal::UFunction*>(found_function);
                            break;
                        }

                        Unreal::UStruct* next = base_class->GetSuperStruct();

                        // This shouldn't be the case with the super struct linked list, but I'm putting this here just in case
                        if (base_class == next) { break; }

                        base_class = next;
                    }
                }
            }
            else
            {
                // TODO: Figure out a better way to do this, ideally, there shouldn't be a need to bit_cast here
                func = std::bit_cast<Unreal::UFunction*>(field);
            }

            if (func)
            {
                push_functionproperty(FunctionPusherParams{
                    .lua = lua,
                    .base = base,
                    .function = func
                });
            }
            else
            {
                // Construct an empty object to allow for safe chaining with a validity check at the end
                LuaType::UObject::construct(lua, nullptr);
            }

            return;
        }

        // Casting to XProperty here so that we can get access to property members
        // It needed to be FField above so that it could be converted to UFunction without force
        // This is because UFunction & XProperty both inherit from XField, but UFunction doesn't inherit from XProperty
        Unreal::FProperty* property = static_cast<Unreal::FProperty*>(field);

        Unreal::FName property_type = property->GetClass().GetFName();
        int32_t name_comparison_index = property_type.GetComparisonIndex();

        if (StaticState::m_property_value_pushers.contains(name_comparison_index))
        {
            void* data = static_cast<uint8_t*>(static_cast<void*>(base)) + property->GetOffset_Internal();

            const PusherParams pusher_params{
                .operation = operation,
                .lua = lua,
                .base = base,
                .data = data,
                .property = property
            };
            StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
        }
        else
        {
            // We can either throw an error and kill the execution
            /**/
            std::string property_type_name = to_string(property_type.ToString());
            lua.throw_error(std::format("Tried accessing unreal property without a registered handler. Property type '{}' not supported.", property_type_name));
            //*/

            // Or we can treat unhandled property types as some sort of generic type
            // For example, we might want to pass the unhandled property value to some sort of low-level Lua API
            // Then the Lua script can deal with figuring out how to handle the type
            /*
            push_unhandledproperty(lua, base);
            //*/
        }
    }

    RemoteUnrealParam::RemoteUnrealParam( void* ptr_object, Unreal::UObject* base, Unreal::FProperty* property, const Unreal::FName type) :
            LuaMadeSimple::Type::RemoteObject<void>("Param", ptr_object),
            m_property(property),
            m_base(base),
            m_type(type)
    {
    }

    RemoteUnrealParam::RemoteUnrealParam(void* data_ptr, const Unreal::FName type) :
            LuaMadeSimple::Type::RemoteObject<void>("Param", data_ptr),
            m_type(type)
    {
    }

    auto RemoteUnrealParam::construct(const LuaMadeSimple::Lua& lua, void* param_ptr, Unreal::UObject* base, Unreal::FProperty* property) -> const LuaMadeSimple::Lua::Table
    {
        const Unreal::FName property_type = property->GetClass().GetFName();
        LuaType::RemoteUnrealParam lua_object{param_ptr, base, property, property_type};

        auto metatable_name = "RemoteUnrealParam";

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions(table);
            lua.new_metatable<LuaType::RemoteUnrealParam>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto RemoteUnrealParam::construct(const LuaMadeSimple::Lua& lua, void* data_ptr, const Unreal::FName type) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::RemoteUnrealParam lua_object{data_ptr, type};

        auto metatable_name = "RemoteUnrealParam";

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions(table);
            lua.new_metatable<LuaType::RemoteUnrealParam>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto RemoteUnrealParam::setup_metamethods(BaseObject& base_object) -> void
    {
        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Index, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(Operation::Get, lua);
            return 1;
        });

        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::NewIndex, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(Operation::Set, lua);
            return 0;
        });
    }

    auto RemoteUnrealParam::setup_member_functions(LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("get", [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(Operation::Get, lua);
            return 1;
        });

        table.add_pair("set", [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(Operation::Set, lua);
            return 0;
        });

        // This class is not overridable so this is always the final class and because of that we always want to set the type & make it global
        table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
            lua.set_string("RemoteUnrealParam");
            return 1;
        });

        // If this is the final object then we also want to finalize creating the table
        // If not then it's the responsibility of the overriding object to call 'make_global()'
        //table.make_global("RemoteUnrealParam");
    }

    auto RemoteUnrealParam::prepare_to_handle(const Operation operation, const LuaMadeSimple::Lua& lua) -> void
    {
        auto& lua_object = lua.get_userdata<LuaType::RemoteUnrealParam>();

        int32_t type_name_comparison_index = lua_object.m_type.GetComparisonIndex();

        if (StaticState::m_property_value_pushers.contains(type_name_comparison_index))
        {
            const PusherParams pusher_params{
                    .operation = operation,
                    .lua = lua,
                    .base = lua_object.m_base,
                    .data = lua_object.get_remote_cpp_object(),
                    .property = lua_object.m_property
            };
            StaticState::m_property_value_pushers[type_name_comparison_index](pusher_params);
        }
        else
        {
            // We can either throw an error and kill the execution
            /**/
            std::string property_type_name = to_string(lua_object.m_type.ToString());
            lua.throw_error(std::format("Tried accessing unreal property without a registered handler. Property type '{}' not supported.", property_type_name));
            //*/

            // Or we can treat unhandled property types as some sort of generic type
            // For example, we might want to pass the unhandled property value to some sort of low-level Lua API
            // Then the Lua script can deal with figuring out how to handle the type
            /*
            push_unhandledproperty(lua, base);
            //*/
        }
    }
}

```

`src/LuaType/LuaUScriptStruct.cpp`:

```cpp
#include <format>

#include <Helpers/Casting.hpp>
#include <LuaType/LuaUScriptStruct.hpp>
#include <LuaType/LuaUStruct.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaXStructProperty.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#pragma warning(default: 4005)
#include <DynamicOutput/Output.hpp>

namespace RC::LuaType
{
    UScriptStruct::UScriptStruct(ScriptStructWrapper object) : LocalObjectBase<ScriptStructWrapper, UScriptStructName>(std::move(object)) {}

    auto UScriptStruct::construct(const LuaMadeSimple::Lua& lua, ScriptStructWrapper& unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UScriptStruct lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            //LuaType::Super::construct(lua, lua_object);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UScriptStruct>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UScriptStruct::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UScriptStruct::setup_metamethods(BaseObject& base_object) -> void
    {
        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::Index, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(LuaMadeSimple::Type::Operation::Get, lua);
            return 1;
        });

        base_object.get_metamethods().create(LuaMadeSimple::Lua::MetaMethod::NewIndex, [](const LuaMadeSimple::Lua& lua) -> int {
            prepare_to_handle(LuaMadeSimple::Type::Operation::Set, lua);
            return 0;
        });
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UScriptStruct::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetBaseAddress", [](const LuaMadeSimple::Lua& lua) -> int {
            // Update: We are no longer storing the base so this function has no use anymore
            lua.throw_error("WARNING! Use of deprecated & removed function 'UScriptStruct::GetBaseAddress'!");
            return 0;
        });

        table.add_pair("GetStructAddress", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();

            auto* data = Helper::Casting::ptr_cast<void*>(lua_object.get_local_cpp_object().start_of_struct);
            lua.set_integer(std::bit_cast<uintptr_t>(data));

            return 1;
        });

        table.add_pair("GetPropertyAddress", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();

            lua.set_integer(std::bit_cast<uintptr_t>(lua_object.get_local_cpp_object().property));

            return 1;
        });

        table.add_pair("IsValid", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();

            if (lua_object.get_local_cpp_object().script_struct)
            {
                lua.set_bool(true);
            }
            else
            {
                lua.set_bool(false);
            }

            return 1;
        });

        table.add_pair("IsMappedToObject", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();

            if (lua_object.get_local_cpp_object().start_of_struct)
            {
                lua.set_bool(true);
            }
            else
            {
                lua.set_bool(false);
            }

            return 1;
        });

        table.add_pair("IsMappedToProperty", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();

            if (lua_object.get_local_cpp_object().property)
            {
                lua.set_bool(true);
            }
            else
            {
                lua.set_bool(false);
            }

            return 1;
        });

        table.add_pair("GetProperty", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<UScriptStruct>();
            XStructProperty::construct(lua, lua_object.get_local_cpp_object().property);
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }

    auto UScriptStruct::handle_unreal_property_value(const LuaMadeSimple::Type::Operation operation, const LuaMadeSimple::Lua& lua, ScriptStructWrapper& struct_data, RC::Unreal::FName property_name) -> void
    {
        // Access the given property in the given UScriptStruct

        Unreal::FStructProperty* property = reinterpret_cast<Unreal::FStructProperty*>(struct_data.script_struct->FindProperty(property_name));
        if (!property)
        {
            lua.throw_error(std::format("[handle_unreal_property_value]: Was unable to retrieve property mapped to '{}'", to_string(struct_data.script_struct->GetFullName())));
        }

        auto property_type_fname = property->GetClass().GetFName();
        int32_t name_comparison_index = property_type_fname.GetComparisonIndex();

        if (StaticState::m_property_value_pushers.contains(name_comparison_index))
        {
            void* data = Helper::Casting::ptr_cast<void*>(struct_data.start_of_struct, property->GetOffset_Internal());

            const PusherParams pusher_params{
                    .operation = operation,
                    .lua = lua,
                    .base = nullptr,
                    .data = data,
                    .property = property
            };
            StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
        }
        else
        {
            std::string property_type_name = to_string(property_type_fname.ToString());
            lua.throw_error(std::format("Tried accessing unreal property without a registered handler (via StructProperty). Property type '{}' not supported.", property_type_name));
        }
    }

    auto UScriptStruct::prepare_to_handle(const LuaMadeSimple::Type::Operation operation, const LuaMadeSimple::Lua& lua) -> void
    {
        auto& lua_object = lua.get_userdata<UScriptStruct>();

        Unreal::FName property_name = Unreal::FName(to_wstring(lua.get_string()));

        // Check if property_name is 'NONE'
        if (property_name.GetComparisonIndex() == 0)
        {
            // No property was found so lets return nil and let the Lua script handle this failure
            lua.set_nil();
            return;
        }

        handle_unreal_property_value(operation, lua, lua_object.get_local_cpp_object(), property_name);
    }
}

```

`src/LuaType/LuaUStruct.cpp`:

```cpp
#include <LuaType/LuaUStruct.hpp>
#include <LuaType/LuaUFunction.hpp>
#include <LuaType/LuaXProperty.hpp>
#include <Unreal/UStruct.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#include <DynamicOutput/Output.hpp>

namespace RC::LuaType
{
    UStruct::UStruct(Unreal::UStruct* object) : UObjectBase<Unreal::UStruct, UStructName>(object) {}

    auto UStruct::construct(const LuaMadeSimple::Lua& lua, Unreal::UStruct* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UStruct lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UStruct>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UStruct::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UStruct::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // UClass has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UStruct::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetSuperStruct", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<UStruct>();

            LuaType::UStruct::construct(lua, static_cast<Unreal::UClass*>(lua_object.get_remote_cpp_object()->GetSuperStruct()));

            return 1;
        });

        table.add_pair("ForEachFunction", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<UStruct>();

            lua_object.get_remote_cpp_object()->ForEachFunction([&](Unreal::UFunction* function) {
                // Duplicate the Lua function so that we can use it in subsequent iterations of this loop (call_function pops the function from the stack)
                lua_pushvalue(lua.get_lua_state(), 1);

                // Set the 'Function' parameter for the Lua function (P1)
                LuaType::UFunction::construct(lua, lua_object.get_remote_cpp_object(), function);

                lua.call_function(1, 1);

                // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                if (lua.is_bool(2) && lua.get_bool(2))
                {
                    return LoopAction::Break;
                }
                else
                {
                    // There's a 'nil' on the stack because we told Lua that we expect a return value.
                    // Lua will put 'nil' on the stack if the Lua function doesn't explicitly return anything.
                    // We discard the 'nil' here, otherwise the Lua stack is corrupted on the next iteration of the 'ForEachFunction' loop.
                    // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                    lua.discard_value(2);
                    return LoopAction::Continue;
                }
            });

            return 1;
        });

        table.add_pair("ForEachProperty", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<UStruct>();

            lua_object.get_remote_cpp_object()->ForEachProperty([&](Unreal::FProperty* property) {
                // Duplicate the Lua function so that we can use it in subsequent iterations of this loop (call_function pops the function from the stack)
                lua_pushvalue(lua.get_lua_state(), 1);

                // Set the 'Property' parameter for the Lua function (P1)
                auto_construct_property(lua, property);

                lua.call_function(1, 1);

                // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                if (lua.is_bool(2) && lua.get_bool(2))
                {
                    return LoopAction::Break;
                }
                else
                {
                    // There's a 'nil' on the stack because we told Lua that we expect a return value.
                    // Lua will put 'nil' on the stack if the Lua function doesn't explicitly return anything.
                    // We discard the 'nil' here, otherwise the Lua stack is corrupted on the next iteration of the 'ForEachFunction' loop.
                    // We explicitly specify index 2 because we duplicated the function earlier and that's located at index 1.
                    lua.discard_value(2);
                    return LoopAction::Continue;
                }
            });

            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaUWorld.cpp`:

```cpp
#include <LuaType/LuaUWorld.hpp>
#include <LuaType/LuaAActor.hpp>
#include <LuaType/LuaUClass.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/World.hpp>
#include <Unreal/UnrealCoreStructs.hpp>
#include <Unreal/Rotator.hpp>
#include <Unreal/Transform.hpp>
#include <Unreal/GameplayStatics.hpp>
#include <DynamicOutput/Output.hpp>

namespace RC::LuaType
{
    UWorld::UWorld(Unreal::UWorld* object) : RemoteObjectBase<Unreal::UWorld, UWorldName>(object) {}

    auto UWorld::construct(const LuaMadeSimple::Lua& lua, Unreal::UWorld* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::UWorld lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaType::UObject::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::UWorld>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto UWorld::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = UObject::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto UWorld::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // UWorld has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto UWorld::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("SpawnActor", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<UWorld>();

            std::string error_overload_not_found{R"(
No overload found for function 'SpawnActor'.
Overloads:
#1: SpawnActor(UClass Class, table Location, table Rotation))"};

            if (!lua.is_userdata())
            {
                lua.throw_error(error_overload_not_found);
            }

            const auto& actor_class = lua.get_userdata<UClass>();

            Unreal::FVector location{};
            if (lua.is_userdata())
            {
                //location = lua.get_userdata<FVector>().get_remote_cpp_object();
                lua.throw_error(error_overload_not_found);
            }
            else if (lua.is_table())
            {
                lua.for_each_in_table([&](const LuaMadeSimple::LuaTableReference& table) {
                    if (table.key.is_string() && table.key.get_string() == "X" &&
                        table.value.is_number())
                    {
                        location.SetX(table.value.get_number());
                    }

                    if (table.key.is_string() && table.key.get_string() == "Y" &&
                        table.value.is_number())
                    {
                        location.SetY(table.value.get_number());
                    }

                    if (table.key.is_string() && table.key.get_string() == "Z" &&
                        table.value.is_number())
                    {
                        location.SetZ(table.value.get_number());
                    }
                    return false;
                });
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            Unreal::FRotator rotation{};
            if (lua.is_userdata())
            {
                //location = lua.get_userdata<FRotator>().get_remote_cpp_object();
                lua.throw_error(error_overload_not_found);
            }
            else if (lua.is_table())
            {
                lua.for_each_in_table([&](const LuaMadeSimple::LuaTableReference& table) {
                    if (table.key.is_string() && table.key.get_string() == "Yaw" &&
                        table.value.is_number())
                    {
                        rotation.Yaw = table.value.get_number();
                    }

                    if (table.key.is_string() && table.key.get_string() == "Pitch" &&
                        table.value.is_number())
                    {
                        rotation.Pitch = table.value.get_number();
                    }

                    if (table.key.is_string() && table.key.get_string() == "Roll" &&
                        table.value.is_number())
                    {
                        rotation.Roll = table.value.get_number();
                    }
                    return false;
                });
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            auto* actor = lua_object.get_remote_cpp_object()->SpawnActor(actor_class.get_remote_cpp_object(), &location, &rotation);
            LuaType::AActor::construct(lua, actor);

            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXArrayProperty.cpp`:

```cpp
#include <LuaType/LuaXArrayProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaXProperty.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/FArrayProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    XArrayProperty::XArrayProperty(Unreal::FArrayProperty* object) : RemoteObjectBase<Unreal::FArrayProperty, FArrayPropertyName>(object) {}

    auto XArrayProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FArrayProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XArrayProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FArrayProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XArrayProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XArrayProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FArrayProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XArrayProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XArrayProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XArrayProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetInner", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<XArrayProperty>();
            LuaType::auto_construct_property(lua, lua_object.get_remote_cpp_object()->GetInner());
            return 1;
        });

        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXBoolProperty.cpp`:

```cpp
#include <LuaType/LuaXBoolProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUClass.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/FBoolProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    XBoolProperty::XBoolProperty(Unreal::FBoolProperty* object) : RemoteObjectBase<Unreal::FBoolProperty, FBoolPropertyName>(object) {}

    auto XBoolProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FBoolProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XBoolProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FBoolProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XBoolProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XBoolProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FBoolProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XBoolProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XBoolProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XBoolProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetByteMask", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XBoolProperty>();
            lua.set_integer(lua_object.get_remote_cpp_object()->GetByteMask());
            return 1;
        });

        table.add_pair("GetByteOffset", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XBoolProperty>();
            lua.set_integer(lua_object.get_remote_cpp_object()->GetByteOffset());
            return 1;
        });

        table.add_pair("GetFieldMask", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XBoolProperty>();
            lua.set_integer(lua_object.get_remote_cpp_object()->GetFieldMask());
            return 1;
        });

        table.add_pair("GetFieldSize", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XBoolProperty>();
            lua.set_integer(lua_object.get_remote_cpp_object()->GetFieldSize());
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXEnumProperty.cpp`:

```cpp
#include <LuaType/LuaXEnumProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUEnum.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/FEnumProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    XEnumProperty::XEnumProperty(Unreal::FEnumProperty* object) : RemoteObjectBase<Unreal::FEnumProperty, FEnumPropertyName>(object) {}

    auto XEnumProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FEnumProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XEnumProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FEnumProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XEnumProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XEnumProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FEnumProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XEnumProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XEnumProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XEnumProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetEnum", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<XEnumProperty>();
            LuaType::UEnum::construct(lua, lua_object.get_remote_cpp_object()->GetEnum());
            return 1;
        });

        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXFieldClass.cpp`:

```cpp
#include <LuaType/LuaXFieldClass.hpp>
#include <LuaType/LuaFName.hpp>

namespace RC::LuaType
{
    XFieldClass::XFieldClass(Unreal::FFieldClassVariant object) : LocalObjectBase<Unreal::FFieldClassVariant, FFieldClassName>(std::move(object)) {}

    auto XFieldClass::construct(const LuaMadeSimple::Lua& lua, Unreal::FFieldClassVariant unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XFieldClass lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            lua.prepare_new_table();
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XFieldClass>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XFieldClass::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = lua.prepare_new_table();

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XFieldClass::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XFieldClass has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XFieldClass::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetFName", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<XFieldClass>();
            FName::construct(lua, lua_object.get_local_cpp_object().GetFName());
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXObjectProperty.cpp`:

```cpp
#include <LuaType/LuaXObjectProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUClass.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/FObjectProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    XObjectProperty::XObjectProperty(Unreal::FObjectProperty* object) : RemoteObjectBase<Unreal::FObjectProperty, FObjectPropertyName>(object) {}

    auto XObjectProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FObjectProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XObjectProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FObjectProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XObjectProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XObjectProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FObjectProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XObjectProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XObjectProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XObjectProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetPropertyClass", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XObjectProperty>();
            LuaType::UClass::construct(lua, lua_object.get_remote_cpp_object()->GetPropertyClass());
            return 1;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXProperty.cpp`:

```cpp
#include <LuaType/LuaXProperty.hpp>
#include <LuaType/LuaXFieldClass.hpp>
#include <LuaType/LuaXObjectProperty.hpp>
#include <LuaType/LuaXBoolProperty.hpp>
#include <LuaType/LuaXStructProperty.hpp>
#include <LuaType/LuaXEnumProperty.hpp>
#include <LuaType/LuaXArrayProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaFName.hpp>
#pragma warning(disable: 4005)
#include <Unreal/FProperty.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    auto auto_construct_property(const LuaMadeSimple::Lua& lua, Unreal::FProperty* property) -> void
    {
        // If the FProperty is nullptr (which is valid), then construct an empty Lua object to enable chaining
        if (!property)
        {
            XProperty::construct(lua, nullptr);
        }
        else if (auto* as_object_property = Unreal::CastField<Unreal::FObjectProperty>(property); as_object_property)
        {
            XObjectProperty::construct(lua, as_object_property);
        }
        else if (auto* as_bool_property = Unreal::CastField<Unreal::FBoolProperty>(property); as_bool_property)
        {
            XBoolProperty::construct(lua, as_bool_property);
        }
        else if (auto* as_struct_property = Unreal::CastField<Unreal::FStructProperty>(property); as_struct_property)
        {
            XStructProperty::construct(lua, as_struct_property);
        }
        else if (auto* as_enum_property = Unreal::CastField<Unreal::FEnumProperty>(property); as_enum_property)
        {
            XEnumProperty::construct(lua, as_enum_property);
        }
        else if (auto* as_array_property = Unreal::CastField<Unreal::FArrayProperty>(property); as_array_property)
        {
            XArrayProperty::construct(lua, as_array_property);
        }
        else
        {
            XProperty::construct(lua, property);
        }
    }

    XProperty::XProperty(Unreal::FProperty* object) : RemoteObjectBase<Unreal::FProperty, FPropertyName>(object) {}

    auto XProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;
    }

    auto XProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        table.add_pair("GetClass", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XProperty>();

            LuaType::XFieldClass::construct(lua, lua_object.get_remote_cpp_object()->GetClass());
            return 1;
        });

        table.add_pair("GetFullName", [](const LuaMadeSimple::Lua& lua) -> int {
            // Get the userdata from the Lua stack
            // We're making an assumption here about the type
            // I know of no way to get around this assumption
            const auto& lua_object = lua.get_userdata<XProperty>();

            if (lua_object.get_remote_cpp_object())
            {
                // Set the return value to the ansi version of the full name
                lua.set_string(to_string(lua_object.get_remote_cpp_object()->GetFullName()).c_str());
            }
            else
            {
                // We have a nullptr, lets return 'nil' for easy object verification in Lua
                lua.set_nil();
            }

            return 1;
        });

        table.add_pair("GetFName", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XProperty>();
            LuaType::FName::construct(lua, lua_object.get_remote_cpp_object()->GetFName());
            return 1;
        });

        table.add_pair("GetOffset_Internal", [](const LuaMadeSimple::Lua& lua) -> int {
            const auto& lua_object = lua.get_userdata<XProperty>();
            lua.set_integer(lua_object.get_remote_cpp_object()->GetOffset_Internal());
            return 1;
        });

        table.add_pair("IsA", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'IsA'.
Overloads:
#1: IsA(PropertyTypes PropertyType)"};

            const auto& lua_object = lua.get_userdata<XProperty>();
            if (lua.is_table())
            {
                int64_t ffield_class_pointer{};
                lua.for_each_in_table([&](const LuaMadeSimple::LuaTableReference& table) {
                    if (table.key.is_string() && table.key.get_string() == "FFieldClassPointer")
                    {
                        if (!table.value.is_integer())
                        {
                            lua.throw_error("Table value for key 'FFieldClassPointer' must be integer");
                        }
                        ffield_class_pointer = table.value.get_integer();
                        return true;
                    }

                    return false;
                });

                if (!ffield_class_pointer)
                {
                    lua.throw_error("Could not find FFieldClassPointer");
                }

                if (Unreal::Version::IsAtLeast(4, 25))
                {
                    auto* ffield_class = std::bit_cast<Unreal::FFieldClass*>(ffield_class_pointer);
                    lua.set_bool(lua_object.get_remote_cpp_object()->IsA(ffield_class));
                }
                else
                {
                    auto* ffield_class = std::bit_cast<Unreal::UClass*>(ffield_class_pointer);
                    lua.set_bool(lua_object.get_remote_cpp_object()->IsA(ffield_class));
                }
                return 1;
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            lua.set_bool(false);
            return 1;
        });

        table.add_pair("ContainerPtrToValuePtr", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'ContainerPtrToValuePtr'.
Overloads:
#1: ContainerPtrToValuePtr(UObjectDerivative Container, integer ArrayIndex = 0))"};

            const auto& lua_object = lua.get_userdata<XProperty>();

            if (!lua.is_userdata())
            {
                throw std::runtime_error{error_overload_not_found};
            }
            const auto& container = lua.get_userdata<UObject>();

            int32_t array_index{};
            if (lua.is_integer())
            {
                array_index = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            void* data = lua_object.get_remote_cpp_object()->ContainerPtrToValuePtr<uint8_t>(container.get_remote_cpp_object(), array_index);
            lua_pushlightuserdata(lua.get_lua_state(), data);
            return 1;
        });

        table.add_pair("ImportText", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'ImportText'.
Overloads:
#1: ImportText(string Buffer, lightuserdata Data, integer PortFlags, UObject OwnerObject))"};

            const auto& lua_object = lua.get_userdata<XProperty>();

            File::StringType buffer;
            if (lua.is_string())
            {
                buffer = to_wstring(lua.get_string());
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            void* data{};
            if (lua_islightuserdata(lua.get_lua_state(), 1))
            {
                data = lua_touserdata(lua.get_lua_state(), 1);
                lua_remove(lua.get_lua_state(), 1);
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            int32_t port_flags{};
            if (lua.is_integer())
            {
                port_flags = static_cast<int32_t>(lua.get_integer());
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            if (!lua.is_userdata())
            {
                throw std::runtime_error{error_overload_not_found};
            }
            auto* owner_object = lua.get_userdata<UObject>().get_remote_cpp_object();
            
            lua_object.get_remote_cpp_object()->ImportText(buffer.c_str(), data, port_flags, owner_object, nullptr);
            return 0;
        });

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/LuaType/LuaXStructProperty.cpp`:

```cpp
#include <LuaType/LuaXStructProperty.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUScriptStruct.hpp>
#pragma warning(disable: 4005)
#include <Unreal/Property/FStructProperty.hpp>
#pragma warning(default: 4005)

namespace RC::LuaType
{
    XStructProperty::XStructProperty(Unreal::FStructProperty* object) : RemoteObjectBase<Unreal::FStructProperty, FStructPropertyName>(object) {}

    auto XStructProperty::construct(const LuaMadeSimple::Lua& lua, Unreal::FStructProperty* unreal_object) -> const LuaMadeSimple::Lua::Table
    {
        LuaType::XStructProperty lua_object{unreal_object};

        auto metatable_name = ClassName::ToString();

        LuaMadeSimple::Lua::Table table = lua.get_metatable(metatable_name);
        if (lua.is_nil(-1))
        {
            lua.discard_value(-1);
            LuaMadeSimple::Type::RemoteObject<Unreal::FStructProperty>::construct(lua, lua_object);
            setup_metamethods(lua_object);
            setup_member_functions<LuaMadeSimple::Type::IsFinal::Yes>(table);
            lua.new_metatable<LuaType::XStructProperty>(metatable_name, lua_object.get_metamethods());
        }

        // Create object & surrender ownership to Lua
        lua.transfer_stack_object(std::move(lua_object), metatable_name, lua_object.get_metamethods());

        return table;

        return table;
    }

    auto XStructProperty::construct(const LuaMadeSimple::Lua& lua, BaseObject& construct_to) -> const LuaMadeSimple::Lua::Table
    {
        LuaMadeSimple::Lua::Table table = LuaMadeSimple::Type::RemoteObject<Unreal::FStructProperty>::construct(lua, construct_to);

        setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        setup_metamethods(construct_to);

        return table;
    }

    auto XStructProperty::setup_metamethods([[maybe_unused]]BaseObject& base_object) -> void
    {
        // XStructProperty has no metamethods
    }

    template<LuaMadeSimple::Type::IsFinal is_final>
    auto XStructProperty::setup_member_functions(const LuaMadeSimple::Lua::Table& table) -> void
    {
        table.add_pair("GetStruct", [](const LuaMadeSimple::Lua& lua) -> int {
            auto& lua_object = lua.get_userdata<XStructProperty>();
            auto script_struct_wrapper = ScriptStructWrapper{lua_object.get_remote_cpp_object()->GetStruct(), nullptr, lua_object.get_remote_cpp_object()};
            LuaType::UScriptStruct::construct(lua, script_struct_wrapper);
            return 1;
        });

        Super::setup_member_functions<LuaMadeSimple::Type::IsFinal::No>(table);

        if constexpr (is_final == LuaMadeSimple::Type::IsFinal::Yes)
        {
            table.add_pair("type", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.set_string(ClassName::ToString());
                return 1;
            });

            // If this is the final object then we also want to finalize creating the table
            // If not then it's the responsibility of the overriding object to call 'make_global()'
            //table.make_global(ClassName::ToString());
        }
    }
}

```

`src/Mod.cpp`:

```cpp
#define NOMINMAX

#include <memory>
#include <string>
#include <format>

#include <Mod.hpp>
#include <Helpers/Format.hpp>
#include <Helpers/String.hpp>
#include <ExceptionHandling.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>
#include <LuaLibrary.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaUClass.hpp>
#include <LuaType/LuaAActor.hpp>
#include <LuaType/LuaFName.hpp>
#include <LuaType/LuaMod.hpp>
#include <LuaType/LuaCustomProperty.hpp>
#include <LuaType/LuaFOutputDevice.hpp>
#include <Input/Handler.hpp>
#pragma warning(disable: 4005)
#include <UE4SSProgram.hpp>
#include <Unreal/UnrealVersion.hpp>
#include <Unreal/Hooks.hpp>
#include <Unreal/UnrealVersion.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/UPackage.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UAssetRegistry.hpp>
#include <Unreal/UAssetRegistryHelpers.hpp>
#include <Unreal/UGameViewportClient.hpp>
#include <Unreal/PackageName.hpp>
#include <Unreal/TypeChecker.hpp>
#include <Unreal/FOutputDevice.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FMapProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FNameProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FTextProperty.hpp>
#include <Unreal/Property/FStrProperty.hpp>
#include <UnrealCustom/CustomProperty.hpp>
#include <Unreal/PrimitiveTypes.hpp>
#pragma warning(default: 4005)

#include <Timer/FunctionTimer.hpp>

#if NEW_LUA
#include <LuaBindings/States/MainState/Main.hpp>
#include <LuaBindings/LuaSetup.hpp>
#endif

namespace RC
{
    LuaMadeSimple::Lua* LuaStatics::console_executor{};
    bool LuaStatics::console_executor_enabled{};

    static auto get_mod_ref(const LuaMadeSimple::Lua& lua) -> Mod*
    {
        if (lua_getglobal(lua.get_lua_state(), "ModRef") == LUA_TNIL)
        {
            lua.throw_error("[get_mod_ref] Tried retrieving 'ModRef' global variable but it was nil, please do not override this global");
        }

        // Explicitly using the top of the stack (-1) since that's where 'getglobal' puts stuff
        auto& lua_object = lua.get_userdata<LuaType::Mod>(-1);
        return lua_object.get_remote_cpp_object();
    }

    static auto set_is_in_game_thread(const LuaMadeSimple::Lua& lua, bool new_value)
    {
        lua.set_bool(new_value);
        lua_setfield(lua.get_lua_state(), LUA_REGISTRYINDEX, "IsInGameThread");
    }

    static auto is_in_game_thread(const LuaMadeSimple::Lua& lua) -> bool
    {
        lua_getfield(lua.get_lua_state(), LUA_REGISTRYINDEX, "IsInGameThread");
        return lua.get_bool(-1);
    }

    struct LuaUnrealScriptFunctionData
    {
        Unreal::CallbackId pre_callback_id;
        Unreal::CallbackId post_callback_id;
        Unreal::UFunction* unreal_function;
        const Mod* mod;
        const LuaMadeSimple::Lua& lua;
        const int lua_callback_ref;

        bool has_return_value{};
        // Will be non-nullptr if the UFunction has a return value
        Unreal::FProperty* return_property{};
    };
    static std::vector<std::unique_ptr<LuaUnrealScriptFunctionData>> g_hooked_script_function_data{};

    static auto lua_unreal_script_function_hook_pre(Unreal::UnrealScriptFunctionCallableContext context, void* custom_data) -> void
    {
        TIME_FUNCTION()

        // Fetch the data corresponding to this UFunction
        auto& lua_data = *static_cast<LuaUnrealScriptFunctionData*>(custom_data);

        // This is a promise that we're in the game thread, used by other functions to ensure that we don't execute when unsafe
        set_is_in_game_thread(lua_data.lua, true);

        // Use the stored registry index to put a Lua function on the Lua stack
        // This is the function that was provided by the Lua call to "RegisterHook"
        lua_data.lua.registry().get_function_ref(lua_data.lua_callback_ref);

        // Set up the first param (context / this-ptr)
        // TODO: Check what happens if a static UFunction is hooked since they don't have any context
        static auto s_object_property_name = Unreal::FName(STR("ObjectProperty"));
        LuaType::RemoteUnrealParam::construct(lua_data.lua, &context.Context, s_object_property_name);

        // Attempt at dynamically fetching the params
        uint16_t return_value_offset = context.TheStack.CurrentNativeFunction->GetReturnValueOffset();

        // 'ReturnValueOffset' is 0xFFFF if the UFunction return type is void
        lua_data.has_return_value = return_value_offset != 0xFFFF;

        uint8_t num_unreal_params = context.TheStack.CurrentNativeFunction->GetNumParms();
        if (lua_data.has_return_value)
        {
            // Subtract one from the number of params if there's a return value
            // This is because Unreal treats the return value as a param, and it's included in the 'NumParms' member variable
            --num_unreal_params;
        }

        bool has_properties_to_process = lua_data.has_return_value || num_unreal_params > 0;
        if (has_properties_to_process && context.TheStack.Locals)
        {
            //int32_t current_param_offset{};

            context.TheStack.CurrentNativeFunction->ForEachProperty([&](Unreal::FProperty* func_prop) {
                // Skip this property if it's not a parameter
                if (!func_prop->HasAnyPropertyFlags(Unreal::EPropertyFlags::CPF_Parm))
                {
                    return LoopAction::Continue;
                }

                // Skip if this property corresponds to the return value
                if (lua_data.has_return_value && func_prop->GetOffset_Internal() == return_value_offset)
                {
                    lua_data.return_property = func_prop;
                    return LoopAction::Continue;
                }

                Unreal::FName property_type = func_prop->GetClass().GetFName();
                int32_t name_comparison_index = property_type.GetComparisonIndex();

                if (LuaType::StaticState::m_property_value_pushers.contains(name_comparison_index))
                {
                    // Non-typed pointer to the current parameter value
                    //void* data = &context.TheStack.Locals[current_param_offset];
                    void* data = func_prop->ContainerPtrToValuePtr<void>(context.TheStack.Locals);

                    // Keeping track of where in the 'Locals' array the next property is
                    //current_param_offset += func_prop->GetSize();

                    // Set up a call to a handler for this type of Unreal property (the param)
                    // The FName is being used as a key for an unordered_map which has the types & corresponding handlers filled right after the dll is injected
                    const LuaType::PusherParams pusher_params{
                            .operation = LuaType::Operation::GetParam,
                            .lua = lua_data.lua,
                            .base = nullptr,
                            .data = data,
                            .property = func_prop
                    };
                    LuaType::StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
                }
                else
                {
                    lua_data.lua.throw_error(std::format("[unreal_script_function_hook] Tried accessing unreal property without a registered handler. Property type '{}' not supported.", to_string(property_type.ToString())));
                }

                return LoopAction::Continue;
            });
        }

        // Call the Lua function with the correct number of parameters & return values
        // Increasing the 'num_params' by one to account for the 'this / context' param
        lua_data.lua.call_function(num_unreal_params + 1, 1);

        // The params for the Lua script will be 'userdata' and they will have get/set functions
        // Use these functions in the Lua script to access & mutate the parameter values

        // After the Lua function has been executed you should call the original function
        // This will execute any internal UE4 scripting functions & native functions depending on the type of UFunction
        // The API will automatically call the original function
        // This function continues in 'lua_unreal_script_function_hook_post' which executes immediately after the original function gets called

        // No longer promising to be in the game thread
        set_is_in_game_thread(lua_data.lua, false);
    }

    static auto lua_unreal_script_function_hook_post(Unreal::UnrealScriptFunctionCallableContext context, void* custom_data) -> void
    {
        // Fetch the data corresponding to this UFunction
        auto& lua_data = *static_cast<LuaUnrealScriptFunctionData*>(custom_data);

        // This is a promise that we're in the game thread, used by other functions to ensure that we don't execute when unsafe
        set_is_in_game_thread(lua_data.lua, true);

        // If 'nil' exists on the Lua stack, that means that the UFunction expected a return value but the Lua script didn't return anything
        // So we can simply clean the stack and let the UFunction decide the return value on its own
        if (lua_data.lua.is_nil())
        {
            lua_data.lua.discard_value();
        }
        else if (lua_data.has_return_value && lua_data.return_property && context.RESULT_DECL)
        {
            // Fetch the return value from Lua if the UFunction expects one
            // If no return value exists then assume that the Lua script didn't want to override the original
            // Keep in mind that the if this was a Blueprint UFunction then the entire byte-code will already have executed
            // That means that changing the return value here won't affect the script itself
            // If this was a native UFunction then changing the return value here will have the desired effect

            Unreal::FName property_type_name = lua_data.return_property->GetClass().GetFName();
            int32_t name_comparison_index = property_type_name.GetComparisonIndex();

            if (LuaType::StaticState::m_property_value_pushers.contains(name_comparison_index))
            {
                const LuaType::PusherParams pusher_params{
                        .operation = LuaType::Operation::Set,
                        .lua = lua_data.lua,
                        .base = static_cast<Unreal::UObject*>(context.RESULT_DECL),
                        .data = context.RESULT_DECL,
                        .property = lua_data.return_property
                };
                LuaType::StaticState::m_property_value_pushers[name_comparison_index](pusher_params);
            }
            else
            {
                // If the type wasn't supported then we simply clean the Lua stack, output a warning and then do nothing
                lua_data.lua.discard_value();

                std::wstring parameter_type_name = property_type_name.ToString();
                std::wstring parameter_name = lua_data.return_property->GetName();

                Output::send(STR("Tried altering return value of a hooked UFunction without a registered handler for return type Return property '{}' of type '{}' not supported."), parameter_name, parameter_type_name);
            }
        }

        // No longer promising to be in the game thread
        set_is_in_game_thread(lua_data.lua, false);
    }

    static auto register_input_globals(const LuaMadeSimple::Lua& lua) -> void
    {
        LuaMadeSimple::Lua::Table key_table = lua.prepare_new_table();
        key_table.add_pair("LEFT_MOUSE_BUTTON", 0x1);
        key_table.add_pair("RIGHT_MOUSE_BUTTON", 0x2);
        key_table.add_pair("CANCEL", 0x3);
        key_table.add_pair("MIDDLE_MOUSE_BUTTON", 0x4);
        key_table.add_pair("XBUTTON_ONE", 0x5);
        key_table.add_pair("XBUTTON_TWO", 0x6);
        key_table.add_pair("BACKSPACE", 0x8);
        key_table.add_pair("TAB", 0x9);
        key_table.add_pair("CLEAR", 0x0C);
        key_table.add_pair("RETURN", 0x0D);
        key_table.add_pair("PAUSE", 0x13);
        key_table.add_pair("CAPS_LOCK", 0x14);
        key_table.add_pair("IME_KANA", 0x15);
        key_table.add_pair("IME_HANGUEL", 0x15);
        key_table.add_pair("IME_HANGUL", 0x15);
        key_table.add_pair("IME_ON", 0x16);
        key_table.add_pair("IME_JUNJA", 0x17);
        key_table.add_pair("IME_FINAL", 0x18);
        key_table.add_pair("IME_HANJA", 0x19);
        key_table.add_pair("IME_KANJI", 0x19);
        key_table.add_pair("IME_OFF", 0x1A);
        key_table.add_pair("ESCAPE", 0x1B);
        key_table.add_pair("IME_CONVERT", 0x1C);
        key_table.add_pair("IME_NONCONVERT", 0x1D);
        key_table.add_pair("IME_ACCEPT", 0x1E);
        key_table.add_pair("IME_MODECHANGE", 0x1F);
        key_table.add_pair("SPACE", 0x20);
        key_table.add_pair("PAGE_UP", 0x21);
        key_table.add_pair("PAGE_DOWN", 0x22);
        key_table.add_pair("END", 0x23);
        key_table.add_pair("HOME", 0x24);
        key_table.add_pair("LEFT_ARROW", 0x25);
        key_table.add_pair("UP_ARROW", 0x26);
        key_table.add_pair("RIGHT_ARROW", 0x27);
        key_table.add_pair("DOWN_ARROW", 0x28);
        key_table.add_pair("SELECT", 0x29);
        key_table.add_pair("PRINT", 0x2A);
        key_table.add_pair("EXECUTE", 0x2B);
        key_table.add_pair("PRINT_SCREEN", 0x2C);
        key_table.add_pair("INS", 0x2D);
        key_table.add_pair("DEL", 0x2E);
        key_table.add_pair("HELP", 0x2F);
        key_table.add_pair("ZERO", 0x30);
        key_table.add_pair("ONE", 0x31);
        key_table.add_pair("TWO", 0x32);
        key_table.add_pair("THREE", 0x33);
        key_table.add_pair("FOUR", 0x34);
        key_table.add_pair("FIVE", 0x35);
        key_table.add_pair("SIX", 0x36);
        key_table.add_pair("SEVEN", 0x37);
        key_table.add_pair("EIGHT", 0x38);
        key_table.add_pair("NINE", 0x39);
        key_table.add_pair("A", 0x41);
        key_table.add_pair("B", 0x42);
        key_table.add_pair("C", 0x43);
        key_table.add_pair("D", 0x44);
        key_table.add_pair("E", 0x45);
        key_table.add_pair("F", 0x46);
        key_table.add_pair("G", 0x47);
        key_table.add_pair("H", 0x48);
        key_table.add_pair("I", 0x49);
        key_table.add_pair("J", 0x4A);
        key_table.add_pair("K", 0x4B);
        key_table.add_pair("L", 0x4C);
        key_table.add_pair("M", 0x4D);
        key_table.add_pair("N", 0x4E);
        key_table.add_pair("O", 0x4F);
        key_table.add_pair("P", 0x50);
        key_table.add_pair("Q", 0x51);
        key_table.add_pair("R", 0x52);
        key_table.add_pair("S", 0x53);
        key_table.add_pair("T", 0x54);
        key_table.add_pair("U", 0x55);
        key_table.add_pair("V", 0x56);
        key_table.add_pair("W", 0x57);
        key_table.add_pair("X", 0x58);
        key_table.add_pair("Y", 0x59);
        key_table.add_pair("Z", 0x5A);
        key_table.add_pair("LEFT_WIN", 0x5B);
        key_table.add_pair("RIGHT_WIN", 0x5C);
        key_table.add_pair("APPS", 0x5D);
        key_table.add_pair("SLEEP", 0x5F);
        key_table.add_pair("NUM_ZERO", 0x69);
        key_table.add_pair("NUM_ONE", 0x61);
        key_table.add_pair("NUM_TWO", 0x62);
        key_table.add_pair("NUM_THREE", 0x63);
        key_table.add_pair("NUM_FOUR", 0x64);
        key_table.add_pair("NUM_FIVE", 0x65);
        key_table.add_pair("NUM_SIX", 0x66);
        key_table.add_pair("NUM_SEVEN", 0x67);
        key_table.add_pair("NUM_EIGHT", 0x68);
        key_table.add_pair("NUM_NINE", 0x69);
        key_table.add_pair("MULTIPLY", 0x6A);
        key_table.add_pair("ADD", 0x6B);
        key_table.add_pair("SEPARATOR", 0x6C);
        key_table.add_pair("SUBTRACT", 0x6D);
        key_table.add_pair("DECIMAL", 0x6E);
        key_table.add_pair("DIVIDE", 0x6F);
        key_table.add_pair("F1", 0x70);
        key_table.add_pair("F2", 0x71);
        key_table.add_pair("F3", 0x72);
        key_table.add_pair("F4", 0x73);
        key_table.add_pair("F5", 0x74);
        key_table.add_pair("F6", 0x75);
        key_table.add_pair("F7", 0x76);
        key_table.add_pair("F8", 0x77);
        key_table.add_pair("F9", 0x78);
        key_table.add_pair("F10", 0x79);
        key_table.add_pair("F11", 0x7A);
        key_table.add_pair("F12", 0x7B);
        key_table.add_pair("F13", 0x7C);
        key_table.add_pair("F14", 0x7D);
        key_table.add_pair("F15", 0x7E);
        key_table.add_pair("F16", 0x7F);
        key_table.add_pair("F17", 0x80);
        key_table.add_pair("F18", 0x81);
        key_table.add_pair("F19", 0x82);
        key_table.add_pair("F20", 0x83);
        key_table.add_pair("F21", 0x84);
        key_table.add_pair("F22", 0x85);
        key_table.add_pair("F23", 0x86);
        key_table.add_pair("F24", 0x87);
        key_table.add_pair("NUM_LOCK", 0x90);
        key_table.add_pair("SCROLL_LOCK", 0x91);
        key_table.add_pair("BROWSER_BACK", 0xA6);
        key_table.add_pair("BROWSER_FORWARD", 0xA7);
        key_table.add_pair("BROWSER_REFRESH", 0xA8);
        key_table.add_pair("BROWSER_STOP", 0xA9);
        key_table.add_pair("BROWSER_SEARCH", 0xAA);
        key_table.add_pair("BROWSER_FAVORITES", 0xAB);
        key_table.add_pair("BROWSER_HOME", 0xAC);
        key_table.add_pair("VOLUME_MUTE", 0xAD);
        key_table.add_pair("VOLUME_DOWN", 0xAE);
        key_table.add_pair("VOLUME_UP", 0xAF);
        key_table.add_pair("MEDIA_NEXT_TRACK", 0xB0);
        key_table.add_pair("MEDIA_PREV_TRACK", 0xB1);
        key_table.add_pair("MEDIA_STOP", 0xB2);
        key_table.add_pair("MEDIA_PLAY_PAUSE", 0xB3);
        key_table.add_pair("LAUNCH_MAIL", 0xB4);
        key_table.add_pair("LAUNCH_MEDIA_SELECT", 0xB5);
        key_table.add_pair("LAUNCH_APP1", 0xB6);
        key_table.add_pair("LAUNCH_APP2", 0xB7);
        key_table.add_pair("OEM_ONE", 0xBA);
        key_table.add_pair("OEM_PLUS", 0xBB);
        key_table.add_pair("OEM_COMMA", 0xBC);
        key_table.add_pair("OEM_MINUS", 0xBD);
        key_table.add_pair("OEM_PERIOD", 0xBE);
        key_table.add_pair("OEM_TWO", 0xBF);
        key_table.add_pair("OEM_THREE", 0xC0);
        key_table.add_pair("OEM_FOUR", 0xDB);
        key_table.add_pair("OEM_FIVE", 0xDC);
        key_table.add_pair("OEM_SIX", 0xDD);
        key_table.add_pair("OEM_SEVEN", 0xDE);
        key_table.add_pair("OEM_EIGHT", 0xDF);
        key_table.add_pair("OEM_102", 0xE2);
        key_table.add_pair("IME_PROCESS", 0xE5);
        key_table.add_pair("PACKET", 0xE7);
        key_table.add_pair("ATTN", 0xF6);
        key_table.add_pair("CRSEL", 0xF7);
        key_table.add_pair("EXSEL", 0xF8);
        key_table.add_pair("EREOF", 0xF9);
        key_table.add_pair("PLAY", 0xFA);
        key_table.add_pair("ZOOM", 0xFB);
        key_table.add_pair("PA1", 0xFD);
        key_table.add_pair("OEM_CLEAR", 0xFE);
        key_table.make_global("Key");

        LuaMadeSimple::Lua::Table modifier_key_table = lua.prepare_new_table();
        modifier_key_table.add_pair("SHIFT", 0x10);
        modifier_key_table.add_pair("CONTROL", 0x11);
        modifier_key_table.add_pair("ALT", 0x12);
        /*modifier_key_table.add_pair("LEFT_SHIFT", 0xA0);
        modifier_key_table.add_pair("RIGHT_SHIFT", 0xA1);
        modifier_key_table.add_pair("LEFT_CONTROL", 0xA2);
        modifier_key_table.add_pair("RIGHT_CONTROL", 0xA3);
        modifier_key_table.add_pair("LEFT_ALT", 0xA4);
        modifier_key_table.add_pair("RIGHT_ALT", 0xA5);*/
        modifier_key_table.make_global("ModifierKey");
    }

    static auto register_object_flags(const LuaMadeSimple::Lua& lua) -> void
    {
        LuaMadeSimple::Lua::Table object_flags_table = lua.prepare_new_table();
        object_flags_table.add_pair("RF_NoFlags", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NoFlags));
        object_flags_table.add_pair("RF_Public", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_Public));
        object_flags_table.add_pair("RF_Standalone", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_Standalone));
        object_flags_table.add_pair("RF_MarkAsNative", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_MarkAsNative));
        object_flags_table.add_pair("RF_Transactional", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_Transactional));
        object_flags_table.add_pair("RF_ClassDefaultObject", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_ClassDefaultObject));
        object_flags_table.add_pair("RF_ArchetypeObject", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_ArchetypeObject));
        object_flags_table.add_pair("RF_Transient", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_Transient));
        object_flags_table.add_pair("RF_MarkAsRootSet", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_MarkAsRootSet));
        object_flags_table.add_pair("RF_TagGarbageTemp", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_TagGarbageTemp));
        object_flags_table.add_pair("RF_NeedInitialization", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NeedInitialization));
        object_flags_table.add_pair("RF_NeedLoad", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NeedLoad));
        object_flags_table.add_pair("RF_KeepForCooker", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_KeepForCooker));
        object_flags_table.add_pair("RF_NeedPostLoad", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NeedPostLoad));
        object_flags_table.add_pair("RF_NeedPostLoadSubobjects", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NeedPostLoadSubobjects));
        object_flags_table.add_pair("RF_NewerVersionExists", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NewerVersionExists));
        object_flags_table.add_pair("RF_BeginDestroyed", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_BeginDestroyed));
        object_flags_table.add_pair("RF_FinishDestroyed", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_FinishDestroyed));
        object_flags_table.add_pair("RF_BeingRegenerated", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_BeingRegenerated));
        object_flags_table.add_pair("RF_DefaultSubObject", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_DefaultSubObject));
        object_flags_table.add_pair("RF_WasLoaded", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_WasLoaded));
        object_flags_table.add_pair("RF_TextExportTransient", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_TextExportTransient));
        object_flags_table.add_pair("RF_LoadCompleted", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_LoadCompleted));
        object_flags_table.add_pair("RF_InheritableComponentTemplate", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_InheritableComponentTemplate));
        object_flags_table.add_pair("RF_DuplicateTransient", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_DuplicateTransient));
        object_flags_table.add_pair("RF_StrongRefOnFrame", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_StrongRefOnFrame));
        object_flags_table.add_pair("RF_NonPIEDuplicateTransient", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_NonPIEDuplicateTransient));
        object_flags_table.add_pair("RF_Dynamic", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_Dynamic));
        object_flags_table.add_pair("RF_WillBeLoaded", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_WillBeLoaded));
        object_flags_table.add_pair("RF_HasExternalPackage", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_HasExternalPackage));
        object_flags_table.add_pair("RF_AllFlags", static_cast<std::underlying_type_t<Unreal::EObjectFlags>>(Unreal::EObjectFlags::RF_AllFlags));
        object_flags_table.make_global("EObjectFlags");
    }

    Mod::Mod(UE4SSProgram& program, std::wstring&& mod_name, std::wstring&& mod_path) : m_program(program), m_mod_name(mod_name), m_mod_path(mod_path), m_lua(LuaMadeSimple::new_state())
    {
        // Verify that there's a 'Scripts' directory
        // Give the full path to the 'Scripts' directory to the mod container
        m_scripts_path = std::move(m_mod_path + L"\\scripts");

        // If the 'Scripts' directory doesn't exist then mark the mod as non-installable and move on to the next mod
        if (!std::filesystem::exists(m_scripts_path))
        {
            set_installable(false);
            return;
        }
    }

    template<typename PropertyType>
    auto add_property_type_table(const LuaMadeSimple::Lua& lua, LuaMadeSimple::Lua::Table& property_types_table, std::string_view property_type_name) -> void
    {
        property_types_table.add_key(property_type_name.data());

        auto property_type_table = lua.prepare_new_table();
        property_type_table.add_pair("Name", property_type_name.data());

        if constexpr (Unreal::IsTProperty<PropertyType>)
        {
            // TODO: Update LuaMadeSimple to accept an unsigned long long, and do it with proper bounds checking
            property_type_table.add_pair("Size", static_cast<int64_t>(sizeof(typename PropertyType::TCppType)));
        }
        else
        {
            // Sizes for types are unknown and will only be known dynamically at runtime
            // TODO: The size is used in LuaTArray to calculate the address of an element (element index * size)
            //       Reimplement this by requiring a custom "Size" field in the Lua table
            property_type_table.add_pair("Size", 0);
        }

        //property_type_table.add_pair("Size", PropertyType::size);
        // This should be a lightuserdata instead of a reinterpret_cast to int64_t
        // This is not very safe at all, what if the pointer is too large for a signed 64-bit integer ?
        property_type_table.add_pair("FFieldClassPointer", static_cast<int64_t>(PropertyType::StaticClass().HashObject()));
        // TODO: Figure out if the static object pointer is needed
        property_type_table.add_pair("StaticPointer", 0);

        property_types_table.fuse_pair();

        property_type_table.make_local();
    }

    //auto static make_hook_state(Mod* mod, const LuaMadeSimple::Lua& lua)->std::shared_ptr<LuaMadeSimple::Lua>
    auto static make_hook_state(Mod* mod) -> std::shared_ptr<LuaMadeSimple::Lua>
    {
        //if (!mod->m_hook_lua)
        //{
            return mod->m_hook_lua.emplace_back(&mod->lua().new_thread());

            // Make the hook thread (which is just a separate Lua stack) be a global in its parent.
            // This is needed because otherwise it will be GCd when we don't want it to.
            //lua_setglobal(lua.get_lua_state(), "HookThread");

            // Commenting out until we switch to lua_newstate instead of lua_newthread.
            // For the switch to happen, we need to be able to move or copy Lua types across lua_states which we can't do yet.
            /*
            mod->m_hook_lua->register_function("RegisterHook", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'RegisterHook' is not allowed from the game thread");
                return 0;
            });

            mod->m_hook_lua->register_function("NotifyOnNewObject", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'NotifyOnNewObject' is not allowed in the game thread");
                return 0;
            });
            //*/
        //}
    }

    auto static make_async_state(Mod* mod, const LuaMadeSimple::Lua& lua) -> void
    {
        if (!mod->m_async_lua)
        {
            mod->m_async_lua = &lua.new_thread();

            // Make the hook thread (which is just a separate Lua stack) be a global in its parent.
            // This is needed because otherwise it will be GCd when we don't want it to.
            lua_setglobal(lua.get_lua_state(), "AsyncThread");

            // Commenting out until we switch to lua_newstate instead of lua_newthread.
            // For the switch to happen, we need to be able to move or copy Lua types across lua_states which we can't do yet.
            /*
            mod->m_hook_lua->register_function("RegisterHook", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'RegisterHook' is not allowed from the game thread");
                return 0;
            });

            mod->m_hook_lua->register_function("NotifyOnNewObject", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'NotifyOnNewObject' is not allowed in the game thread");
                return 0;
            });
            //*/
        }
    }

    auto static make_main_state(Mod* mod, const LuaMadeSimple::Lua& lua) -> void
    {
        if (!mod->m_main_lua)
        {
            mod->m_main_lua = &lua.new_thread();

            // Make the hook thread (which is just a separate Lua stack) be a global in its parent.
            // This is needed because otherwise it will be GCd when we don't want it to.
            lua_setglobal(lua.get_lua_state(), "MainThread");

            // Commenting out until we switch to lua_newstate instead of lua_newthread.
            // For the switch to happen, we need to be able to move or copy Lua types across lua_states which we can't do yet.
            /*
            mod->m_hook_lua->register_function("RegisterHook", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'RegisterHook' is not allowed from the game thread");
                return 0;
            });

            mod->m_hook_lua->register_function("NotifyOnNewObject", [](const LuaMadeSimple::Lua& lua) -> int {
                lua.throw_error("'NotifyOnNewObject' is not allowed in the game thread");
                return 0;
            });
            //*/
        }
    }
    auto static register_all_property_types(const LuaMadeSimple::Lua& lua) -> void
    {
        auto property_types_table = lua.prepare_new_table();

        add_property_type_table<Unreal::FObjectProperty>(lua, property_types_table, "ObjectProperty");
        add_property_type_table<Unreal::FObjectPtrProperty>(lua, property_types_table, "ObjectPtrProperty");
        add_property_type_table<Unreal::FInt8Property>(lua, property_types_table, "Int8Property");
        add_property_type_table<Unreal::FInt16Property>(lua, property_types_table, "Int16Property");
        add_property_type_table<Unreal::FIntProperty>(lua, property_types_table, "IntProperty");
        add_property_type_table<Unreal::FInt64Property>(lua, property_types_table, "Int64Property");
        add_property_type_table<Unreal::FByteProperty>(lua, property_types_table, "ByteProperty");
        add_property_type_table<Unreal::FUInt16Property>(lua, property_types_table, "UInt16Property");
        add_property_type_table<Unreal::FUInt32Property>(lua, property_types_table, "UInt32Property");
        add_property_type_table<Unreal::FUInt64Property>(lua, property_types_table, "UInt64Property");
        add_property_type_table<Unreal::FNameProperty>(lua, property_types_table, "NameProperty");
        add_property_type_table<Unreal::FFloatProperty>(lua, property_types_table, "FloatProperty");
        //add_property_type_table<Unreal::FStrProperty>(lua, property_types_table, "StrProperty");
        add_property_type_table<Unreal::FBoolProperty>(lua, property_types_table, "BoolProperty");
        add_property_type_table<Unreal::FArrayProperty>(lua, property_types_table, "ArrayProperty");
        add_property_type_table<Unreal::FMapProperty>(lua, property_types_table, "MapProperty");
        add_property_type_table<Unreal::FStructProperty>(lua, property_types_table, "StructProperty");
        add_property_type_table<Unreal::FClassProperty>(lua, property_types_table, "ClassProperty");
        add_property_type_table<Unreal::FWeakObjectProperty>(lua, property_types_table, "WeakObjectProperty");
        if (Unreal::Version::IsAtLeast(4,15))
        {
            add_property_type_table<Unreal::FEnumProperty>(lua, property_types_table, "EnumProperty");
        }
        add_property_type_table<Unreal::FTextProperty>(lua, property_types_table, "TextProperty");
        add_property_type_table<Unreal::FStrProperty>(lua, property_types_table, "StrProperty");

        property_types_table.make_global("PropertyTypes");
    }

    auto Mod::setup_lua_require_paths(const LuaMadeSimple::Lua& lua) const -> void
    {
        auto* lua_state = m_lua.get_lua_state();
        lua_getglobal(lua_state, "package");
        lua_getfield(lua_state, -1, "path");
        std::string current_paths = lua_tostring(lua_state, -1);

        current_paths.append(std::format(";{}\\{}\\Scripts\\?.lua", to_string(m_program.get_mods_directory()).c_str(), to_string(get_name())));
        current_paths.append(std::format(";{}\\shared\\?.lua", to_string(m_program.get_mods_directory()).c_str()));
        current_paths.append(std::format(";{}\\shared\\?\\?.lua", to_string(m_program.get_mods_directory()).c_str()));

        lua_pop(lua_state, 1);
        lua_pushstring(lua_state, current_paths.c_str());
        lua_setfield(lua_state, -2, "path");
        lua_pop(lua_state, 1);
    }

    auto static setup_lua_global_functions_internal(const LuaMadeSimple::Lua& lua, Mod::IsTrueMod is_true_mod) -> void
    {
        lua.register_function("print", LuaLibrary::global_print);

        lua.register_function("StaticFindObject", [](const LuaMadeSimple::Lua& lua) -> int {
            // Stack size @ the start of the function is the same as the number of params
            int32_t stack_size = lua.get_stack_size();

            if (stack_size <= 0)
            {
                lua.throw_error("Function 'StaticFindObject' cannot be called with 0 parameters.");
            }

            std::string error_overload_not_found{R"(
No overload found for function 'StaticFindObject'.
Overloads:
#1: StaticFindObject(string name)
#2: StaticFindObject(UClass* Class, UObject* InOuter, string name, bool ExactClass = false))"};

            // Overload #1
            // P1: string name
            // Ignores any params after P1
            if (lua.is_string())
            {
                Unreal::UObject* object = Unreal::UObjectGlobals::StaticFindObject(nullptr, nullptr, to_wstring(lua.get_string()));

                // Construct a Lua object of type 'UObject'
                // Auto constructing is nullptr safe
                LuaType::auto_construct_object(lua, object);

                return 1;
            }

            // Overload #2
            // P1: UClass* Class
            // P2: UObject* InOuter
            // P3: string Name
            // P4: bool ExactClass = false
            // Full definition of StaticFindObject, including default values
            // Ignores any params after P4
            if (stack_size < 3)
            {
                // No overload found for function 'StaticFindObject'. Overloads are:
                lua.throw_error(error_overload_not_found);
            }

            Unreal::UClass* param_class{};
            Unreal::UObject* param_in_outer{};
            std::wstring param_name{};
            bool param_exact_class{};

            // P1 (Class), userdata
            if (lua.is_userdata())
            {
                auto& lua_object = lua.get_userdata<LuaType::UClass>();
                param_class = lua_object.get_remote_cpp_object();
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            // P2 (InOuter), userdata
            if (lua.is_userdata())
            {
                auto& lua_object = lua.get_userdata<LuaType::UObject>();
                param_in_outer = lua_object.get_remote_cpp_object();
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            // P3 (Name), string
            if (lua.is_string())
            {
                param_name = to_wstring(lua.get_string());
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            // P4 (ExactClass), bool = false
            if (lua.is_bool())
            {
                param_exact_class = lua.get_bool();
            }
            // There's no error if P4 isn't a bool, simply ignore all parameters after P3

            Unreal::UObject* object = Unreal::UObjectGlobals::StaticFindObject(param_class, param_in_outer, param_name, param_exact_class);

            // Construct a Lua object of type 'UObject'
            // Auto constructing is nullptr safe
            LuaType::auto_construct_object(lua, object);

            return 1;

        });

        lua.register_function("FindFirstOf", [](const LuaMadeSimple::Lua& lua) -> int {
            // Stack size @ the start of the function is the same as the number of params
            int32_t stack_size = lua.get_stack_size();

            if (stack_size <= 0)
            {
                lua.throw_error("Function 'FindFirstOf' cannot be called with 0 parameters.");
            }

            std::string error_overload_not_found{R"(
No overload found for function 'FindFirstOf'.
Overloads:
#1: FindFirstOf(string short_class_name))"};

            // Overload #1
            // P1: string short_name
            // Ignores any params after P1
            if (lua.is_string())
            {
                Unreal::UObject* object = Unreal::UObjectGlobals::FindFirstOf(to_wstring(lua.get_string()));

                // Construct a Lua object of type 'UObject'
                // Auto constructing is nullptr safe
                LuaType::auto_construct_object(lua, object);

                return 1;
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            return 0;
        });

        lua.register_function("FindAllOf", [](const LuaMadeSimple::Lua& lua) -> int {
            // Stack size @ the start of the function is the same as the number of params
            int32_t stack_size = lua.get_stack_size();

            if (stack_size <= 0)
            {
                lua.throw_error("Function 'FindAllOf' cannot be called with 0 parameters.");
            }

            std::string error_overload_not_found{R"(
No overload found for function 'FindAllOf'.
Overloads:
#1: FindAllOf(string short_class_name))"};

            // Overload #1
            // P1: string short_name
            // Ignores any params after P1
            if (lua.is_string())
            {
                constexpr int32_t elements_to_reserve = 40;

                std::vector<Unreal::UObject*> found_unreal_objects;

                // Reserving some space because FindAllOf is likely to find lots of objects
                found_unreal_objects.reserve(elements_to_reserve);

                Unreal::UObjectGlobals::FindAllOf(lua.get_string(), found_unreal_objects);

                if (!found_unreal_objects.empty())
                {
                    LuaMadeSimple::Lua::Table table = lua.prepare_new_table(elements_to_reserve);

                    for (size_t count{}; const auto& unreal_object : found_unreal_objects)
                    {
                        // Increasing the count first, this is to accommodate the one-index based tables of Lua
                        ++count;

                        table.add_key(count);

                        // Construct a Lua version of a UObject
                        // It will be at the top of the Lua stack and can act as the value of a key/value pair if fuse_pair() is called
                        LuaType::auto_construct_object(lua, unreal_object);
                        table.fuse_pair();
                    }

                    table.make_local();
                }
                else
                {
                    lua.set_nil();
                }

                return 1;
            }
            else
            {
                lua.throw_error(error_overload_not_found);
            }

            // This code isn't executed
            // Lua will error out in the else statement above
            // This is purely to shut the compiler up
            lua.set_nil();
            return 1;
        });

        if (is_true_mod == Mod::IsTrueMod::Yes)
        {
            lua.register_function("RegisterKeyBind", [](const LuaMadeSimple::Lua& lua) -> int {
                std::string error_overload_not_found{R"(
No overload found for function 'RegisterKeyBind'.
Overloads:
#1: RegisterKeyBind(integer key)
#2: RegisterKeyBind(integer key, table modifier_key_integers))"};

                const Mod* mod = get_mod_ref(lua);

                if (!lua.is_integer())
                {
                    lua.throw_error(error_overload_not_found);
                }

                int64_t key_from_lua = lua.get_integer();
                if (key_from_lua < std::numeric_limits<uint8_t>::min() || key_from_lua > std::numeric_limits<uint8_t>::max())
                {
                    lua.throw_error("Parameter #1 for function 'RegisterKeyBind' must be an integer between 0 and 255");
                }

                Input::Key key_to_register = static_cast<Input::Key>(key_from_lua);

                const auto lua_keybind_callback_lambda = [](const LuaMadeSimple::Lua& lua, const int callback_register_index) -> void {
                    try
                    {
                        lua.registry().get_function_ref(callback_register_index);
                        lua.call_function(0, 0);
                    }
                    catch (std::runtime_error& e)
                    {
                        Output::send(STR("{}\n"), to_wstring(lua.handle_error(e.what())));
                    }
                };

                if (lua.is_function())
                {
                    // Overload #1
                    // P1: Key to register
                    // P2: Callback

                    // Duplicate the Lua function to the top of the stack for luaL_ref
                    lua_pushvalue(lua.get_lua_state(), 1);

                    // Take a reference to the Lua function (it also pops it of the stack)
                    const int32_t lua_callback_registry_index = lua.registry().make_ref();

                    // Taking 'lua_callback_registry_index' by copy here to ensure its survival
                    // Using a 'custom_data' of 1 to signify that this keydown event was created by a mod
                    mod->m_program.register_keydown_event(key_to_register, [&lua, lua_callback_registry_index, &lua_keybind_callback_lambda]() {
                        lua_keybind_callback_lambda(lua, lua_callback_registry_index);
                    }, 1);
                }
                else if (lua.is_table())
                {
                    // Overload #2
                    // P1: Key to register
                    // P2: Table of modifier keys
                    // P3: Callback

                    Input::Handler::ModifierKeyArray modifier_keys{};

                    uint8_t table_counter{};
                    lua.for_each_in_table([&](LuaMadeSimple::LuaTableReference table) -> bool {
                        if (!table.value.is_integer())
                        {
                            lua.throw_error("Lua function 'RegisterKeyBind', overload #2, requires a table of 1-byte large integers as the second parameter");
                        }

                        int64_t full_integer = table.value.get_integer();
                        if (full_integer < std::numeric_limits<uint8_t>::min() || full_integer > std::numeric_limits<uint8_t>::max())
                        {
                            lua.throw_error("Lua function 'RegisterKeyBind', overload #2, requires a table of 1-byte large integers as the second parameter");
                        }

                        modifier_keys[table_counter++] = static_cast<Input::ModifierKey>(table.value.get_integer());

                        return false;
                    });

                    // Duplicate the Lua function to the top of the stack for luaL_ref
                    lua_pushvalue(lua.get_lua_state(), 1);

                    // Take a reference to the Lua function (it also pops it of the stack)
                    const auto lua_callback_registry_index = lua.registry().make_ref();

                    mod->m_program.register_keydown_event(key_to_register, modifier_keys, [&lua, lua_callback_registry_index, &lua_keybind_callback_lambda]() {
                        lua_keybind_callback_lambda(lua, lua_callback_registry_index);
                    }, 1);
                }
                else
                {
                    lua.throw_error(error_overload_not_found);
                }

                return 0;
            });

            lua.register_function("UnregisterHook", [](const LuaMadeSimple::Lua& lua) -> int {
                std::string error_overload_not_found{R"(
No overload found for function 'UnregisterHook'.
Overloads:
#1: UnregisterHook(string UFunction_Name, integer PreCallbackId, integer PostCallbackId))" };

                if (!lua.is_string()) { lua.throw_error(error_overload_not_found); }

                std::wstring function_name = to_wstring(lua.get_string());
                std::wstring function_name_no_prefix = function_name.substr(function_name.find_first_of(L" ") + 1, function_name.size());

                if (!lua.is_function()) { lua.throw_error(error_overload_not_found); }

                // Duplicate the Lua function to the top of the stack for luaL_ref
                lua_pushvalue(lua.get_lua_state(), 1);

                // Take a reference to the Lua function (it also pops it of the stack)
                const auto lua_callback_registry_index = luaL_ref(lua.get_lua_state(), LUA_REGISTRYINDEX);

                Unreal::UFunction* unreal_function = Unreal::UObjectGlobals::StaticFindObject<Unreal::UFunction*>(nullptr, nullptr, function_name_no_prefix);
                if (!unreal_function)
                {
                    lua.throw_error("Tried to unregister a hook with Lua function 'UnregisterHook' but no UFunction with the specified name was found.");
                }

                if (!lua.is_integer()) { lua.throw_error(error_overload_not_found); }
                const auto pre_id = lua.get_integer();

                if (!lua.is_integer()) { lua.throw_error(error_overload_not_found); }
                const auto post_id = lua.get_integer();

                unreal_function->UnregisterHook(pre_id);
                unreal_function->UnregisterHook(post_id);

                return 0;
            });

            lua.register_function("DumpAllObjects", []([[maybe_unused]]const LuaMadeSimple::Lua& lua) -> int {
                const Mod* mod = get_mod_ref(lua);
                if (!mod) { lua.throw_error("Could not dump objects and properties because the pointer to 'Mod' was nullptr"); }
                UE4SSProgram::dump_all_objects_and_properties(mod->m_program.get_object_dumper_output_directory() + STR("\\") + UE4SSProgram::m_object_dumper_file_name);
                return 0;
            });

            lua.register_function("GenerateSDK", []([[maybe_unused]]const LuaMadeSimple::Lua& lua) -> int {
                const Mod* mod = get_mod_ref(lua);
                File::StringType working_dir{mod->m_program.get_working_directory()};
                mod->m_program.generate_cxx_headers(working_dir + STR("\\CXXHeaderDump"));
                return 0;
            });

            lua.register_function("GenerateUHTCompatibleHeaders", []([[maybe_unused]]const LuaMadeSimple::Lua& lua) -> int {
                const Mod* mod = get_mod_ref(lua);
                mod->m_program.generate_uht_compatible_headers();
                return 0;
            });
        }

        lua.register_function("StaticConstructObject", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'StaticConstructObject'.
Overloads:
#1: StaticConstructObject(
                            UClass Class,
                            UObject Outer,
                            FName Name, #Optional
                            EObjectFlags Flags, #Optional
                            EInternalObjectFlags InternalSetFlags, #Optional
                            bool CopyTransientsFromClassDefaults, #Optional
                            bool AssumeTemplateIsArchetype, #Optional
                            UObject Template, #Optional
                            FObjectInstancingGraph InstanceGraph, #Optional
                            UPackage ExternalPackage, #Optional
                            void SubobjectOverrides #Optional

))"};


            // For now, we're assuming that if there's userdata, that userdata is of the correct underlying type
            if (!lua.is_userdata()) { lua.throw_error(error_overload_not_found); }
            Unreal::UClass* param_class = lua.get_userdata<LuaType::UClass>().get_remote_cpp_object();

            if (!lua.is_userdata()) { lua.throw_error(error_overload_not_found); }
            Unreal::UObject* param_outer = lua.get_userdata<LuaType::UObject>().get_remote_cpp_object();

            Unreal::FName param_name;
            if (lua.is_userdata())
            {
                param_name = lua.get_userdata<LuaType::FName>().get_local_cpp_object();
            }
            else if (lua.is_integer())
            {
                param_name = Unreal::FName(lua.get_integer());
            }
            else
            {
                param_name = Unreal::FName(static_cast<int64_t>(0));
            }

            Unreal::EObjectFlags param_set_flags{};
            if (lua.is_integer())
            {
                param_set_flags = static_cast<Unreal::EObjectFlags>(lua.get_integer());
            }

            Unreal::EInternalObjectFlags param_internal_set_flags{};
            if (lua.is_integer())
            {
                param_internal_set_flags = static_cast<Unreal::EInternalObjectFlags>(lua.get_integer());
            }

            // The rest are all optional parameters
            bool param_copy_transients_from_class_defaults{};
            if (lua.is_bool()) { param_copy_transients_from_class_defaults = lua.get_bool(); }

            bool param_assume_template_is_archetype{};
            if (lua.is_bool()) { param_assume_template_is_archetype = lua.get_bool(); }

            Unreal::UObject* param_template{};
            if (lua.is_userdata()) { param_template = lua.get_userdata<LuaType::UObject>().get_remote_cpp_object(); }

            // Change this to userdata if support for 'FObjectInstancingGraph' is ever added
            void* param_instance_graph{};
            if (lua.is_integer()) { param_instance_graph = reinterpret_cast<void*>(static_cast<uintptr_t>(lua.get_integer())); }

            // Change this to userdata if support for 'UPackage' is ever added
            void* param_external_package{};
            if (lua.is_integer()) { param_external_package = reinterpret_cast<void*>(static_cast<uintptr_t>(lua.get_integer())); }

            void* param_subobject_overrides{};
            if (lua.is_integer()) { param_subobject_overrides = reinterpret_cast<void*>(static_cast<uintptr_t>(lua.get_integer())); }

            Unreal::FStaticConstructObjectParameters params{param_class, param_outer};
            params.Name = param_name;
            params.SetFlags = param_set_flags;
            params.InternalSetFlags = param_internal_set_flags;
            params.bCopyTransientsFromClassDefaults = param_copy_transients_from_class_defaults;
            params.bAssumeTemplateIsArchetype = param_assume_template_is_archetype;
            params.Template = param_template;
            params.InstanceGraph = static_cast<struct RC::Unreal::FObjectInstancingGraph*>(param_instance_graph);
            params.ExternalPackage = static_cast<class RC::Unreal::UPackage*>(param_external_package);
            Unreal::UObject* created_object = Unreal::UObjectGlobals::StaticConstructObject(params);

            LuaType::UObject::construct(lua, created_object);

            return 1;
        });

        lua.register_function("RegisterCustomProperty", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'RegisterCustomProperty'.
Overloads:
#1: RegisterCustomProperty(table PropertyInfo))"};

            if (!lua.is_table()) { lua.throw_error(error_overload_not_found); }

            struct PropertyTypeInfo
            {
                std::string_view name{};
                int32_t size{-1};
                void* ffieldclass_pointer{};
                void* static_pointer{};

                auto is_valid() -> bool
                {
                    if (size < 0) { return false; }
                    if (!ffieldclass_pointer) { return false; }
                    //if (!static_pointer) { return false; }

                    return true;
                }
            };

            struct PropertyInfo
            {
                std::wstring name{};
                PropertyTypeInfo type{}; // Figure out what to do here, it shouldn't be just a string
                std::wstring belongs_to_class{};
                int32_t offset_internal{-1};
                int32_t element_size{-1}; // Is this required for trivial types like integers and floats ?

                // ArrayProperty
                PropertyTypeInfo array_inner{};

                bool offset_internal_is_table{};

                // Only one of these booleans can be true
                bool is_array_property{};

                auto set_is_array_property() -> void
                {
                    // Check here if any incompatible booleans have been set, and throw error if so
                    is_array_property = true;
                }

                auto is_missing_values() -> bool
                {
                    if (name.empty()) { return true; }
                    if (!type.is_valid()) { return true; }
                    if (belongs_to_class.empty()) { return true;}
                    if (!offset_internal_is_table && offset_internal < 0) { return true; }
                    //if (element_size < 0) { return true; }

                    if (is_array_property && !array_inner.is_valid()) { return true; }

                    return false;
                }
            };

            PropertyInfo property_info{};

            auto lua_table = lua.get_table();

            auto verify_and_convert_int64_to_int32 = [&](std::string_view field_name, std::string_view second_field_name = {}, std::string_view third_field_name = {}, bool* has_error = nullptr) -> int32_t {
                int64_t integer;

                if (second_field_name.empty())
                {
                    // Ignore the third field name if the second one isn't set
                    integer = lua_table.get_int_field(field_name, has_error);
                }
                else if (third_field_name.empty())
                {
                    // If the second field name is set but the third isn't, then we have two layers to the table
                    integer = lua_table.get_table_field(field_name, has_error).get_int_field(second_field_name, has_error);
                }
                else
                {
                    // If both the second field name and the third field name is set, then we have three layers to the table
                    integer = lua_table.get_table_field(field_name, has_error).get_table_field(second_field_name, has_error).get_int_field(third_field_name, has_error);
                }

                if (integer < std::numeric_limits<int32_t>::min() || integer > std::numeric_limits<int32_t>::max())
                {
                    std::string error_field_names;

                    if (second_field_name.empty())
                    {
                        error_field_names = std::format("{}", field_name);
                    }
                    else if (third_field_name.empty())
                    {
                        error_field_names = std::format("{}.{}", field_name, second_field_name);
                    }
                    else
                    {
                        error_field_names = std::format("{}.{}.{}", field_name, second_field_name, third_field_name);
                    }

                    lua.throw_error(std::format("Parameter #1 for function 'RegisterCustomProperty'. The table value for key '{}' is outside the range of a 32-bit integer", error_field_names));
                }

                return static_cast<int32_t>(integer);
            };

            // Always required, for all property types
            property_info.name = to_wstring(lua_table.get_string_field("Name"));
            property_info.type.name = lua_table.get_table_field("Type").get_string_field("Name");
            property_info.type.size = verify_and_convert_int64_to_int32("Type", "Size");
            property_info.type.ffieldclass_pointer = reinterpret_cast<void*>(lua_table.get_table_field("Type").get_int_field("FFieldClassPointer"));
            property_info.type.static_pointer = reinterpret_cast<void*>(lua_table.get_table_field("Type").get_int_field("StaticPointer"));
            property_info.belongs_to_class = to_wstring(lua_table.get_string_field("BelongsToClass"));

            std::string oi_property_name;
            int32_t oi_relative_offset{};

            bool error_while_getting_offset_internal{};
            property_info.offset_internal = verify_and_convert_int64_to_int32("OffsetInternal", "", "", &error_while_getting_offset_internal);

            if (error_while_getting_offset_internal)
            {
                // Failed to get integer from table
                // This means that we may have a table instead of an integer

                oi_property_name = lua_table.get_table_field("OffsetInternal").get_string_field("Property");
                oi_relative_offset = verify_and_convert_int64_to_int32("OffsetInternal", "RelativeOffset");

                property_info.offset_internal_is_table = true;
            }

            // Only required for ArrayProperty
            if (property_info.type.name == "ArrayProperty")
            {
                if (!lua_table.does_field_exist("ArrayProperty"))
                {
                    lua.throw_error("Parameter #1 for function 'RegisterCustomProperty'. The table entry 'ArrayProperty' is missing.");
                }
                else
                {
                    property_info.set_is_array_property();
                    property_info.array_inner.name = lua_table.get_table_field("ArrayProperty").get_table_field("Type").get_string_field("Name");
                    property_info.array_inner.size = verify_and_convert_int64_to_int32("ArrayProperty", "Type", "Size");
                    property_info.array_inner.ffieldclass_pointer = reinterpret_cast<void*>(lua_table.get_table_field("ArrayProperty").get_table_field("Type").get_int_field("FFieldClassPointer"));
                    property_info.array_inner.static_pointer = reinterpret_cast<void*>(lua_table.get_table_field("ArrayProperty").get_table_field("Type").get_int_field("StaticPointer"));
                }
            }

            if (property_info.is_missing_values())
            {
                lua.throw_error("Parameter #1 for function 'RegisterCustomProperty'. The table is missing required fields.");
            }

            Unreal::UClass* belongs_to_class = Unreal::UObjectGlobals::StaticFindObject<Unreal::UClass*>(nullptr, nullptr, property_info.belongs_to_class);
            if (!belongs_to_class)
            {
                lua.throw_error("Tried to 'RegisterCustomProperty' but 'BelongsToClass' could not be found");
            }

            if (property_info.offset_internal_is_table)
            {
                auto name = Unreal::FName(to_wstring(oi_property_name));
                Unreal::FProperty* oi_property = belongs_to_class->FindProperty(name);
                if (!oi_property)
                {
                    lua.throw_error(std::format("Was unable to find property '{}' in class '{}' for use for relative Offset_Internal", oi_property_name, to_string(property_info.belongs_to_class)));
                }

                property_info.offset_internal = oi_property->GetOffset_Internal() + oi_relative_offset;
            }

            if (property_info.type.size == 0)
            {
                lua.throw_error(std::format("The size for property '{}' was unknown. Custom sizes are unsupported but will likely be supported in the future.", property_info.type.name));
            }

            if (property_info.is_array_property && property_info.array_inner.size == 0)
            {
                lua.throw_error(std::format("The size for inner property '{}' was unknown. Custom sizes are unsupported but will likely be supported in the future.", property_info.array_inner.name));
            }

            LuaType::LuaCustomProperty::StaticStorage::property_list.add(
                    property_info.name,
                    Unreal::CustomArrayProperty::construct(
                            property_info.offset_internal,
                            belongs_to_class,
                            static_cast<Unreal::UClass*>(property_info.type.ffieldclass_pointer),
                            static_cast<Unreal::FProperty*>(property_info.array_inner.ffieldclass_pointer),
                            property_info.is_array_property ? property_info.array_inner.size : property_info.type.size

                    ));

            printf_s("Registered Custom Property\n");
            printf_s("PropertyInfo {\n");
            printf_s("\tName: %S\n", property_info.name.c_str());
            printf_s("\tType {\n");
            printf_s("\t\tName: %s\n", property_info.type.name.data());
            printf_s("\t\tSize: 0x%X\n", property_info.type.size);
            printf_s("\t\tFFieldClassPointer: 0x%p\n", property_info.type.ffieldclass_pointer);
            printf_s("\t\tStaticPointer: 0x%p\n", property_info.type.static_pointer);
            printf_s("\t}\n");
            printf_s("\tBelongsToClass: %S\n", property_info.belongs_to_class.c_str());
            printf_s("\tOffsetInternal: 0x%X\n", property_info.offset_internal);

            if (property_info.is_array_property)
            {
                printf_s("\tArrayProperty {\n");
                printf_s("\t\tType {\n");
                printf_s("\t\t\tName: %s\n", property_info.array_inner.name.data());
                printf_s("\t\t\tSize: 0x%X\n", property_info.array_inner.size);
                printf_s("\t\t\tFFieldClassPointer: %p\n", property_info.array_inner.ffieldclass_pointer);
                printf_s("\t\t\tStaticPointer: %p\n", property_info.array_inner.static_pointer);
                printf_s("\t\t}\n");
                printf_s("\t}\n");
            }

            printf_s("}\n");

            return 0;
        });

        lua.register_function("ForEachUObject", [](const LuaMadeSimple::Lua& lua) -> int {
            Unreal::UObjectGlobals::ForEachUObject([&](void* object, int32_t chunk_index, int32_t object_index) {
                // Duplicate the Lua function so that we can use it in subsequent iterations of this loop (call_function pops the function from the stack)
                lua_pushvalue(lua.get_lua_state(), 1);

                // Set the 'Object' parameter for the Lua function (P1)
                LuaType::auto_construct_object(lua, static_cast<Unreal::UObject*>(object));

                // Set the 'ChunkIndex' parameter for the Lua function (P2)
                lua.set_integer(chunk_index);

                // Set the 'ObjectIndex' parameter for the Lua function (P3)
                lua.set_integer(object_index);

                lua.call_function(3, 1);

                return LoopAction::Continue;
            });
            return 0;
        });

        lua.register_function("NotifyOnNewObject", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'NotifyOnNewObject'.
Overloads:
#1: NotifyOnNewObject(string UClassName, LuaFunction Callback))"};

            if (!lua.is_string())
            {
                lua.throw_error(error_overload_not_found);
            }

            std::wstring class_name = to_wstring(lua.get_string());

            if (!lua.is_function())
            {
                lua.throw_error(error_overload_not_found);
            }

            auto mod = get_mod_ref(lua);
            auto hook_lua = make_hook_state(mod);

            lua_xmove(lua.get_lua_state(), hook_lua->get_lua_state(), 1);

            // Take a reference to the Lua function (it also pops it of the stack)
            const int32_t lua_callback_registry_index = hook_lua->registry().make_ref();

            Unreal::UClass* instance_of_class = Unreal::UObjectGlobals::StaticFindObject<Unreal::UClass*>(nullptr, nullptr, class_name);

            Mod::m_static_construct_object_lua_callbacks.emplace_back(Mod::LuaCallbackData{ *hook_lua, instance_of_class, {lua_callback_registry_index} });

            return 0;
        });

        lua.register_function("ExecuteAsync", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'ExecuteAsync'.
Overloads:
#1: ExecuteAsync(LuaFunction Callback))"};

            auto mod = get_mod_ref(lua);

            if (!lua.is_function()) { throw std::runtime_error{error_overload_not_found}; }
            const int32_t lua_function_ref = lua.registry().make_ref();

            mod->actions_lock();
            mod->m_pending_actions.emplace_back(Mod::AsyncAction{
                lua_function_ref,
                Mod::ActionType::Immediate
             });
            mod->actions_unlock();

            return 0;
        });

        lua.register_function("ExecuteWithDelay", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'ExecuteWithDelay'.
Overloads:
#1: ExecuteWithDelay(integer DelayInMilliseconds, LuaFunction Callback))"};

            if (!lua.is_integer()) { throw std::runtime_error{error_overload_not_found}; }
            int64_t delay = lua.get_integer();

            if (!lua.is_function()) { throw std::runtime_error{error_overload_not_found}; }
            const int32_t lua_function_ref = lua.registry().make_ref();

            auto mod = get_mod_ref(lua);

            mod->actions_lock();
            mod->m_pending_actions.emplace_back(Mod::AsyncAction{
                lua_function_ref,
                Mod::ActionType::Delayed,
                std::chrono::steady_clock::now(),
                delay,
            });
            mod->actions_unlock();
            return 0;
        });

        lua.register_function("LoopAsync", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{ R"(
No overload found for function 'LoopAsync'.
Overloads:
#1: LoopAsync(integer DelayInMilliseconds, LuaFunction Callback))" };

            if (!lua.is_integer()) { throw std::runtime_error{ error_overload_not_found }; }
            int64_t delay = lua.get_integer();

            if (!lua.is_function()) { throw std::runtime_error{ error_overload_not_found }; }
            const int32_t lua_function_ref = lua.registry().make_ref();

            auto mod = get_mod_ref(lua);

            mod->actions_lock();
            mod->m_pending_actions.emplace_back(Mod::AsyncAction{
                lua_function_ref,
                Mod::ActionType::Loop,
                std::chrono::steady_clock::now(),
                delay,
            });
            mod->actions_unlock();

            return 0;
        });

        lua.register_function("RegisterConsoleCommandGlobalHandler", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'RegisterConsoleCommandGlobalHandler'.
Overloads:
#1: RegisterConsoleCommandGlobalHandler(string CommandName, LuaFunction Callback))"};

            if (!lua.is_string()) { throw std::runtime_error{error_overload_not_found}; }
            auto command_name = to_wstring(lua.get_string());

            if (!lua.is_function()) { throw std::runtime_error{error_overload_not_found}; }

            Mod::LuaCallbackData* callback = nullptr;
            auto iter = Mod::m_global_command_lua_callbacks.find(command_name);
            if (iter == Mod::m_global_command_lua_callbacks.end())
            {
                auto mod = get_mod_ref(lua);
                auto hook_lua = make_hook_state(mod);
                callback = &Mod::m_global_command_lua_callbacks.emplace(command_name, Mod::LuaCallbackData{ *hook_lua, nullptr, {} }).first->second;
            }
            else
            {
                callback = &iter->second;
            }
            lua_xmove(lua.get_lua_state(), callback->lua.get_lua_state(), 1);
            const int32_t lua_function_ref = callback->lua.registry().make_ref();
            callback->registry_indexes.emplace_back(lua_function_ref);
            return 0;
        });

        lua.register_function("RegisterConsoleCommandHandler", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'RegisterConsoleCommandHandler'.
Overloads:
#1: RegisterConsoleCommandHandler(string CommandName, LuaFunction Callback))"};

            if (!lua.is_string()) { throw std::runtime_error{error_overload_not_found}; }
            auto command_name = to_wstring(lua.get_string());

            if (!lua.is_function()) { throw std::runtime_error{error_overload_not_found}; }

            Mod::LuaCallbackData* callback = nullptr;
            auto iter = Mod::m_custom_command_lua_pre_callbacks.find(command_name);
            if (iter == Mod::m_custom_command_lua_pre_callbacks.end())
            {
                auto mod = get_mod_ref(lua);
                auto hook_lua = make_hook_state(mod);
                callback = &Mod::m_custom_command_lua_pre_callbacks.emplace(command_name, Mod::LuaCallbackData{ *hook_lua, nullptr, {} }).first->second;
            }
            else
            {
                callback = &iter->second;
            }
            lua_xmove(lua.get_lua_state(), callback->lua.get_lua_state(), 1);
            const int32_t lua_function_ref = callback->lua.registry().make_ref();
            callback->registry_indexes.emplace_back(lua_function_ref);
            return 0;
        });

        lua.register_function("LoadAsset", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'LoadAsset'.
Overloads:
#1: LoadAsset(string AssetPathAndName))"};

            if (!is_in_game_thread(lua))
            {
                throw std::runtime_error{"Function 'LoadAsset' can only be called from within the game thread"};
            }

            if (!lua.is_string()) { throw std::runtime_error{error_overload_not_found}; }
            auto asset_path_and_name = Unreal::FName(to_wstring(lua.get_string()), Unreal::FNAME_Add);

            auto* asset_registry = static_cast<Unreal::UAssetRegistry*>(Unreal::UAssetRegistryHelpers::GetAssetRegistry().ObjectPointer);
            if (!asset_registry)
            {
                throw std::runtime_error{"Did not load assets because asset_registry was nullptr\n"};
            }

            Unreal::UObject* loaded_asset{};
            bool was_asset_found{};
            bool did_asset_load{};
            Unreal::FAssetData asset_data = asset_registry->GetAssetByObjectPath(asset_path_and_name);
            if (asset_data.ObjectPath().GetComparisonIndex())
            {
                was_asset_found = true;
                loaded_asset = Unreal::UAssetRegistryHelpers::GetAsset(asset_data);
                if (loaded_asset)
                {
                    did_asset_load = true;
                    Output::send(STR("Asset loaded\n"));
                }
                else
                {
                    Output::send(STR("Asset was found but not loaded, could be a package\n"));
                }
            }

            LuaType::auto_construct_object(lua, loaded_asset);
            lua.set_bool(was_asset_found);
            lua.set_bool(did_asset_load);
            return 3;
        });

        lua.register_function("FindObject", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'FindObject'.
Overloads:
#1: FindObject(UClass InClass, UObject InOuter, string Name, bool ExactClass)
#2: FindObject(string|FName|nil ClassName, string|FName|nil ObjectShortName, EObjectFlags RequiredFlags, EObjectFlags BannedFlags)
#3: FindObject(UClass|nil Class, string|FName|nil ObjectShortName, EObjectFlags RequiredFlags, EObjectFlags BannedFlags))"};

            if (!lua.is_string() && !lua.is_userdata() && !lua.is_nil())
            {
                throw std::runtime_error{error_overload_not_found};
            }

            Unreal::FName object_class_name{};
            Unreal::UClass* in_class{};
            bool object_class_name_supplied{true};
            bool could_be_in_class{};
            if (lua.is_string())
            {
                object_class_name = Unreal::FName(to_wstring(lua.get_string()), Unreal::FNAME_Add);
            }
            else if (lua.is_userdata())
            {
                // The API is a bit awkward, we have to tell it to preserve the stack
                // That way, when we call 'get_userdata' again with a more specific type, there's still something to actually get
                auto& userdata = lua.get_userdata<LuaType::UE4SSBaseObject>(1, true);
                if (std::string_view{userdata.get_object_name()} == "UClass")
                {
                    in_class = lua.get_userdata<LuaType::UClass>().get_remote_cpp_object();
                    could_be_in_class = true;
                    object_class_name = in_class->GetNamePrivate();
                }
                else if (std::string_view{userdata.get_object_name()} == "FName")
                {
                    object_class_name = lua.get_userdata<LuaType::FName>().get_local_cpp_object();
                }
                else
                {
                    throw std::runtime_error{error_overload_not_found};
                }
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
                object_class_name_supplied = false;
                could_be_in_class = true;
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            if (!lua.is_string() && !lua.is_userdata() && !lua.is_integer() && !lua.is_nil())
            {
                throw std::runtime_error{error_overload_not_found};
            }

            Unreal::FName object_short_name{};
            Unreal::UObject* in_outer{};
            bool could_be_in_outer{};
            bool could_be_object_short_name{};
            if (lua.is_string())
            {
                object_short_name = Unreal::FName(to_wstring(lua.get_string()), Unreal::FNAME_Add);
                could_be_object_short_name = true;
            }
            else if (lua.is_userdata())
            {
                // The API is a bit awkward, we have to tell it to preserve the stack
                // That way, when we call 'get_userdata' again with a more specific type, there's still something to actually get
                auto& userdata = lua.get_userdata<LuaType::UE4SSBaseObject>(1, true);
                std::string_view lua_object_name = userdata.get_object_name();
                // TODO: Redo when there's a bette way of checking whether a lua object is derived from UObject
                if (lua_object_name == "UObject" || lua_object_name == "World" || lua_object_name == "Actor")
                {
                    in_outer = lua.get_userdata<LuaType::UObject>().get_remote_cpp_object();
                    could_be_in_outer = true;
                }
                else if (lua_object_name == "FName")
                {
                    object_short_name = lua.get_userdata<LuaType::FName>().get_local_cpp_object();
                    could_be_object_short_name = true;
                }
                else
                {
                    throw std::runtime_error{error_overload_not_found};
                }
            }
            else if (lua.is_integer())
            {
                if (lua.get_integer() == -1)
                {
                    in_outer = Unreal::UObjectGlobals::ANY_PACKAGE;
                    could_be_in_outer = true;
                }
                else
                {
                    throw std::runtime_error{error_overload_not_found};
                }
            }
            else if (lua.is_nil())
            {
                could_be_in_outer = true;
                could_be_object_short_name = true;
                lua.discard_value();
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            int32_t required_flags{Unreal::EObjectFlags::RF_NoFlags};
            std::string in_name{};
            bool could_be_in_name{};
            if (lua.is_string())
            {
                in_name = lua.get_string();
                could_be_in_name = true;
            }
            else if (lua.is_integer())
            {
                required_flags = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            int32_t banned_flags{Unreal::EObjectFlags::RF_NoFlags};
            bool exact_class{};
            bool could_be_exact_class{};
            if (lua.is_bool())
            {
                exact_class = lua.get_bool();
                could_be_exact_class = true;
            }
            else if (lua.is_integer())
            {
                banned_flags = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            if (could_be_in_class && could_be_in_outer && could_be_in_name)
            {
                LuaType::auto_construct_object(lua, Unreal::UObjectGlobals::FindObject(in_class, in_outer, to_wstring(in_name), exact_class));
            }
            else
            {
                if (could_be_exact_class || !could_be_object_short_name) { throw std::runtime_error{error_overload_not_found}; }
                LuaType::auto_construct_object(lua, Unreal::UObjectGlobals::FindObject(object_class_name, object_short_name, required_flags, banned_flags));
            }
            return 1;
        });

        lua.register_function("FindObjects", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'FindObjects'.
Overloads:
#1: FindObjects(integer NumObjectsToFind, string|FName|nil ClassName, string|FName|nil ObjectShortName, EObjectFlags RequiredFlags, EObjectFlags BannedFlags, bool bExactClass)
#2: FindObjects(integer NumObjectsToFind, UClass|nil Class, string|FName|nil ObjectShortName, EObjectFlags RequiredFlags, EObjectFlags BannedFlags, bool bExactClass))"};

            int32_t num_objects_to_find{};
            if (lua.is_integer())
            {
                num_objects_to_find = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            if (!lua.is_string() && !lua.is_userdata() && !lua.is_nil())
            {
                throw std::runtime_error{error_overload_not_found};
            }

            Unreal::FName object_class_name{};
            bool object_class_name_supplied{true};
            if (lua.is_string())
            {
                object_class_name = Unreal::FName(to_wstring(lua.get_string()), Unreal::FNAME_Add);
            }
            else if (lua.is_userdata())
            {
                // The API is a bit awkward, we have to tell it to preserve the stack
                // That way, when we call 'get_userdata' again with a more specific type, there's still something to actually get
                auto& userdata = lua.get_userdata<LuaType::UE4SSBaseObject>(1, true);
                if (std::string_view{userdata.get_object_name()} == "UClass")
                {
                    object_class_name = lua.get_userdata<LuaType::UClass>().get_remote_cpp_object()->GetNamePrivate();
                }
                else if (std::string_view{userdata.get_object_name()} == "FName")
                {
                    object_class_name = lua.get_userdata<LuaType::FName>().get_local_cpp_object();
                }
                else
                {
                    throw std::runtime_error{error_overload_not_found};
                }
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
                object_class_name_supplied = false;
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            if (!lua.is_string() && !lua.is_userdata() && !lua.is_nil())
            {
                throw std::runtime_error{error_overload_not_found};
            }

            Unreal::FName object_short_name{};
            if (lua.is_string())
            {
                object_short_name = Unreal::FName(to_wstring(lua.get_string()), Unreal::FNAME_Add);
            }
            else if (lua.is_userdata())
            {
                // The API is a bit awkward, we have to tell it to preserve the stack
                // That way, when we call 'get_userdata' again with a more specific type, there's still something to actually get
                auto& userdata = lua.get_userdata<LuaType::UE4SSBaseObject>(1, true);
                if (std::string_view{userdata.get_object_name()} == "FName")
                {
                    object_short_name = lua.get_userdata<LuaType::FName>().get_local_cpp_object();
                }
                else
                {
                    throw std::runtime_error{error_overload_not_found};
                }
            }
            else if (lua.is_nil())
            {
                if (!object_class_name_supplied)
                {
                    error_overload_not_found.append("\nBoth param #1 and param #2 cannot be nil");
                    throw std::runtime_error{error_overload_not_found};
                }
                else
                {
                    lua.discard_value();
                }
            }
            else
            {
                throw std::runtime_error{error_overload_not_found};
            }

            int32_t required_flags{Unreal::EObjectFlags::RF_NoFlags};
            if (lua.is_integer())
            {
                required_flags = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            int32_t banned_flags{Unreal::EObjectFlags::RF_NoFlags};
            if (lua.is_integer())
            {
                banned_flags = static_cast<int32_t>(lua.get_integer());
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            bool exact_class{true};
            if (lua.is_integer())
            {
                exact_class = lua.get_integer();
            }
            else if (lua.is_bool())
            {
                exact_class = lua.get_bool();
            }
            else if (lua.is_nil())
            {
                lua.discard_value();
            }

            std::vector<Unreal::UObject*> objects_found{};
            Unreal::UObjectGlobals::FindObjects(num_objects_to_find, object_class_name, object_short_name, objects_found, required_flags, banned_flags, exact_class);

            auto table = lua.prepare_new_table(static_cast<int32_t>(objects_found.size()));
            for (auto i = 0; i < objects_found.size(); ++i)
            {
                table.add_key(i + 1);
                LuaType::auto_construct_object(lua, objects_found[i]);
                table.fuse_pair();
            }

            return 1;
        });
    }

    auto Mod::setup_lua_global_functions(const LuaMadeSimple::Lua& lua) const -> void
    {
        setup_lua_global_functions_internal(lua, IsTrueMod::Yes);
    }

    auto Mod::setup_lua_global_functions_main_state_only() const -> void
    {
        m_lua.register_function("RegisterHook", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{ R"(
No overload found for function 'RegisterHook'.
Overloads:
#1: RegisterHook(string UFunction_Name, LuaFunction callback))" };

            if (!lua.is_string()) { lua.throw_error(error_overload_not_found); }

            std::wstring function_name = to_wstring(lua.get_string());
            std::wstring function_name_no_prefix = function_name.substr(function_name.find_first_of(L" ") + 1, function_name.size());

            if (!lua.is_function()) { lua.throw_error(error_overload_not_found); }

            auto mod = get_mod_ref(lua);
            auto hook_lua = make_hook_state(mod);

            // Duplicate the Lua function to the top of the stack for lua_xmove and luaL_ref
            lua_pushvalue(lua.get_lua_state(), 1);

            lua_xmove(lua.get_lua_state(), hook_lua->get_lua_state(), 1);

            // Take a reference to the Lua function (it also pops it of the stack)
            const auto lua_callback_registry_index = luaL_ref(hook_lua->get_lua_state(), LUA_REGISTRYINDEX);

            Unreal::UFunction* unreal_function = Unreal::UObjectGlobals::StaticFindObject<Unreal::UFunction*>(nullptr, nullptr, function_name_no_prefix);
            if (!unreal_function)
            {
                lua.throw_error("Tried to register a hook with Lua function 'RegisterHook' but no UFunction with the specified name was found.");
            }

            auto& custom_data = g_hooked_script_function_data.emplace_back(
                std::make_unique<LuaUnrealScriptFunctionData>(LuaUnrealScriptFunctionData{
                    0,
                    0,
                    unreal_function,
                    mod,
                    *hook_lua,
                    lua_callback_registry_index
                    })
            );
            auto pre_id = unreal_function->RegisterPreHook(&lua_unreal_script_function_hook_pre, custom_data.get());
            auto post_id = unreal_function->RegisterPostHook(&lua_unreal_script_function_hook_post, custom_data.get());
            custom_data->pre_callback_id = pre_id;
            custom_data->post_callback_id = post_id;

            lua.set_integer(pre_id);
            lua.set_integer(post_id);

            return 2;
        });
    }


    auto static is_unreal_version_out_of_bounds_from_64bit(int64_t major_version, int64_t minor_version) -> bool
    {
        if (major_version < std::numeric_limits<uint32_t>::min() || major_version > std::numeric_limits<uint32_t>::max() ||
            minor_version < std::numeric_limits<uint32_t>::min() || minor_version > std::numeric_limits<uint32_t>::max())
        {
            return false;
        }
        else
        {
            return true;
        }
    };

    using UnrealVersionCheckFunctionPtr = bool(*)(int32_t, int32_t);
    auto static unreal_version_check(const LuaMadeSimple::Lua& lua, UnrealVersionCheckFunctionPtr check_function, const std::string& error_overload_not_found) -> void
    {
        // Removing the table from the stack as we don't need it
        // This is required in order to align the parameters (or manually provide the stack index for the params)
        if (lua.is_table()) { lua.discard_value(); }

        // Checking the first and second param, without retrieving either
        // Makes for less code
        if (!lua.is_integer() || !lua.is_integer(2))
        {
            lua.throw_error(error_overload_not_found);
        }

        int64_t major_version = lua.get_integer();
        int64_t minor_version = lua.get_integer();

        if (!is_unreal_version_out_of_bounds_from_64bit(major_version, minor_version))
        {
            lua.throw_error("[UnrealVersion::unreal_version_check] Major/minor version numbers must be within the range of uint32");
        }

        lua.set_bool(check_function(static_cast<int32_t>(major_version), static_cast<int32_t>(minor_version)));
    }

    auto static setup_lua_classes_internal(const LuaMadeSimple::Lua& lua) -> void
    {
        // UE4SS Class -> START
        auto mod_class = lua.prepare_new_table();
        mod_class.set_has_userdata(false);

        mod_class.add_pair("GetVersion", [](const LuaMadeSimple::Lua& lua) -> int {
            lua.set_integer(UE4SS_LIB_VERSION_MAJOR);
            lua.set_integer(UE4SS_LIB_VERSION_MINOR);
            lua.set_integer(UE4SS_LIB_VERSION_HOTFIX);
            return 3;
        });
        mod_class.make_global("UE4SS");
        // UE4SS Class -> END

        // UnrealVersion Class -> START
        auto unreal_version_class = lua.prepare_new_table();
        unreal_version_class.set_has_userdata(false);

        unreal_version_class.add_pair("GetMajor", [](const LuaMadeSimple::Lua& lua) -> int {
            lua.set_integer(Unreal::Version::Major);
            return 1;
        });

        unreal_version_class.add_pair("GetMinor", [](const LuaMadeSimple::Lua& lua) -> int {
            lua.set_integer(Unreal::Version::Minor);
            return 1;
        });

        unreal_version_class.add_pair("IsEqual", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UnrealVersion:IsEqual'.
Overloads:
#1: IsEqual(number MajorVersion, number MinorVersion))"};

            unreal_version_check(lua, &Unreal::Version::IsEqual, error_overload_not_found);

            return 1;
        });

        unreal_version_class.add_pair("IsAtLeast", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UnrealVersion:IsAtLeast'.
Overloads:
#1: IsAtLeast(number MajorVersion, number MinorVersion))"};

            unreal_version_check(lua, &Unreal::Version::IsAtLeast, error_overload_not_found);

            return 1;
        });

        unreal_version_class.add_pair("IsAtMost", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UnrealVersion:IsAtMost'.
Overloads:
#1: IsAtMost(number MajorVersion, number MinorVersion))"};

            unreal_version_check(lua, &Unreal::Version::IsAtMost, error_overload_not_found);

            return 1;
        });

        unreal_version_class.add_pair("IsBelow", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UnrealVersion:IsBelow'.
Overloads:
#1: IsBelow(number MajorVersion, number MinorVersion))"};

            unreal_version_check(lua, &Unreal::Version::IsBelow, error_overload_not_found);

            return 1;
        });

        unreal_version_class.add_pair("IsAbove", [](const LuaMadeSimple::Lua& lua) -> int {
            std::string error_overload_not_found{R"(
No overload found for function 'UnrealVersion:IsAbove'.
Overloads:
#1: IsAbove(number MajorVersion, number MinorVersion))"};

            unreal_version_check(lua, &Unreal::Version::IsAbove, error_overload_not_found);

            return 1;
        });
        unreal_version_class.make_global("UnrealVersion");
        // UnrealVersion Class -> END

        // FName Class -> START
        // Pre-load the global FName table
        // Without this, the metatable won't be created until an FName is constructed by another part of UE4SS
        LuaType::FName::construct(lua, Unreal::FName(static_cast<int64_t>(0)));
        lua_setglobal(lua.get_lua_state(), "FName");
        // FName Class -> END

        // FPackageName -> START
        auto package_name = lua.prepare_new_table();
        package_name.set_has_userdata(false);

        package_name.add_pair("IsShortPackageName", [](const LuaMadeSimple::Lua& lua) -> int {
            static std::string error_overload_not_found{R"(
No overload found for function 'FPackageName:IsShortPackageName'.
Overloads:
#1: IsShortPackageName(string PossiblyLongName))"};

            if (!lua.is_string())
            {
                lua.throw_error(error_overload_not_found);
            }

            File::StringType PossiblyLongName = to_wstring(lua.get_string());
            lua.set_bool(Unreal::FPackageName::IsShortPackageName(PossiblyLongName));

            return 1;
        });

        package_name.add_pair("IsValidLongPackageName", [](const LuaMadeSimple::Lua& lua) -> int {
            static std::string error_overload_not_found{R"(
No overload found for function 'FPackageName:IsValidLongPackageName'.
Overloads:
#1: IsValidLongPackageName(string InLongPackageName))"};

            if (!lua.is_string())
            {
                lua.throw_error(error_overload_not_found);
            }

            File::StringType InLongPackageName = to_wstring(lua.get_string());
            lua.set_bool(Unreal::FPackageName::IsValidLongPackageName(InLongPackageName));

            return 1;
        });

        package_name.make_global("FPackageName");
        // FPackageName -> END
    }

    auto Mod::setup_lua_classes(const LuaMadeSimple::Lua& lua) const -> void
    {
        setup_lua_classes_internal(lua);
    }

    auto Mod::get_name() const -> std::wstring_view
    {
        return m_mod_name;
    }

    auto Mod::set_installable(bool is_installable) -> void
    {
        m_installable = is_installable;
    }

    auto Mod::is_installable() const -> bool
    {
        return m_installable;
    }

    auto Mod::set_installed(bool is_installed) -> void
    {
        m_installed = is_installed;
    }

    auto Mod::is_installed() const -> bool
    {
        return m_installed;
    }

    auto Mod::prepare_mod(const LuaMadeSimple::Lua& lua) -> void
    {
        lua.open_all_libs();

        setup_lua_require_paths(lua);

        setup_lua_global_functions(lua);
        setup_lua_classes(lua);


        // Setup a global reference for this mod
        // It can be accessed later when you otherwise don't have access to the 'Mod' instance
        LuaType::Mod::construct(lua, this);
        lua_setglobal(lua.get_lua_state(), "ModRef");

        // Setup all the input related globals (keys & modifier keys)
        register_input_globals(lua);

        register_all_property_types(lua);
        register_object_flags(lua);
    }

    auto Mod::start_mod() -> void
    {
        prepare_mod(lua());
        make_main_state(this, lua());
        setup_lua_global_functions_main_state_only();

        make_async_state(this, lua());
        start_async_thread();

        m_is_started = true;
        main_lua()->execute_file(m_scripts_path + L"\\main.lua");
    }

    auto Mod::is_started() const -> bool
    {
        return m_is_started;
    }

    auto Mod::uninstall() const -> void
    {
        Output::send(STR("Stopping mod '{}' for uninstall\n"), m_mod_name);
        if (m_hook_lua.size() > 0)
        {
            for (auto lua : m_hook_lua)
            {
                lua_resetthread(lua->get_lua_state());
            }
        }

        if (m_async_lua && m_async_lua->get_lua_state())
        {
            lua_resetthread(m_async_lua->get_lua_state());
        }

        if (m_main_lua && m_main_lua->get_lua_state())
        {
            lua_resetthread(m_main_lua->get_lua_state());
        }

        lua_close(lua().get_lua_state());

        // Unhook all UFunctions for this mod & remove from the map that keeps track of which UFunctions have been hooked
        std::erase_if(g_hooked_script_function_data, [&](std::unique_ptr<LuaUnrealScriptFunctionData>& item) -> bool {
            if (item->mod == this)
            {
                Output::send(STR("\tUnregistering hook by id '{}#{}' for mod {}\n"), item->unreal_function->GetName(), item->pre_callback_id, item->mod->get_name());
                Output::send(STR("\tUnregistering hook by id '{}#{}' for mod {}\n"), item->unreal_function->GetName(), item->post_callback_id, item->mod->get_name());
                item->unreal_function->UnregisterHook(item->pre_callback_id);
                item->unreal_function->UnregisterHook(item->post_callback_id);
                return true;
            }

            return false;
        });
    }

    auto Mod::lua() const -> const LuaMadeSimple::Lua&
    {
        return m_lua;
    }

    auto Mod::main_lua() const -> const LuaMadeSimple::Lua*
    {
        return m_main_lua;
    }

    auto Mod::async_lua() const -> const LuaMadeSimple::Lua*
    {
        return m_async_lua;
    }

    auto Mod::get_lua_state() const -> lua_State*
    {
        return lua().get_lua_state();
    }

    auto static start_console_lua_executor() -> void
    {
        LuaStatics::console_executor = &LuaMadeSimple::new_state();
        LuaStatics::console_executor->open_all_libs();
        setup_lua_global_functions_internal(*LuaStatics::console_executor, Mod::IsTrueMod::No);
        setup_lua_classes_internal(*LuaStatics::console_executor);
        register_input_globals(*LuaStatics::console_executor);
        register_all_property_types(*LuaStatics::console_executor);
        register_object_flags(*LuaStatics::console_executor);
        LuaStatics::console_executor_enabled = true;
    };

    auto static stop_console_lua_executor() -> void
    {
        lua_close(LuaStatics::console_executor->get_lua_state());

        LuaStatics::console_executor = nullptr;
        LuaStatics::console_executor_enabled = false;
    }

    auto Mod::on_program_start() -> void
    {
        Unreal::Hook::RegisterStaticConstructObjectPostCallback([](const Unreal::FStaticConstructObjectParameters&, Unreal::UObject* constructed_object) {
            Unreal::UStruct* object_class = constructed_object->GetClassPrivate();
            while (object_class)
            {
                for (const auto& callback_data : m_static_construct_object_lua_callbacks)
                {
                    if (callback_data.instance_of_class == object_class)
                    {
                        try
                        {
                            for (const auto& registry_index : callback_data.registry_indexes)
                            {
                                callback_data.lua.registry().get_function_ref(registry_index);
                                LuaType::auto_construct_object(callback_data.lua, constructed_object);
                                callback_data.lua.call_function(1, 0);
                            }
                        }
                        catch (std::runtime_error& e)
                        {
                            Output::send(STR("{}\n"), to_wstring(e.what()));
                        }
                    }
                }

                object_class = object_class->GetSuperStruct();
            }

            return constructed_object;
        });

        // Lua from the in-game console.
        Unreal::Hook::RegisterProcessConsoleExecCallback([](Unreal::UObject* context, const TCHAR* cmd, Unreal::FOutputDevice& ar, Unreal::UObject* executor) -> bool {
            auto logln = [&ar](const File::StringType& log_message) {
                Output::send(std::format(STR("{}\n"), log_message));
                ar.Log(log_message.c_str());
            };

            if (!LuaStatics::console_executor_enabled && String::iequal(File::StringViewType{cmd}, STR("luastart")))
            {
                start_console_lua_executor();
                logln(STR("Console Lua executor started"));
                return true;
            }
            else if (LuaStatics::console_executor_enabled && String::iequal(File::StringViewType{cmd}, STR("luastop")))
            {
                stop_console_lua_executor();
                logln(STR("Console Lua executor stopped"));
                return true;
            }
            else if (LuaStatics::console_executor_enabled && String::iequal(File::StringViewType{cmd}, STR("luarestart")))
            {
                stop_console_lua_executor();
                start_console_lua_executor();
                logln(STR("Console Lua executor restarted"));
                return true;
            }
            else if (String::iequal(File::StringViewType{cmd}, STR("clear")))
            {
                // TODO: Replace with proper implementation when we have UGameViewportClient and UConsole.
                //       This should be fairly cross-game & cross-engine-version compatible even without the proper implementation.
                //       This is because I don't think they've changed the layout here and we have a reflected property right before the unreflected one that we're looking for.
                Unreal::UObject** console = static_cast<Unreal::UObject**>(context->GetValuePtrByPropertyName(STR("ViewportConsole")));
                auto* default_texture_white = std::bit_cast<Unreal::TArray<Unreal::FString>*>(static_cast<uint8_t*>((*console)->GetValuePtrByPropertyNameInChain(STR("DefaultTexture_White"))) + 0x8);
                auto* scrollback = std::bit_cast<int32_t*>(std::bit_cast<uint8_t*>(default_texture_white) + 0x10);
                default_texture_white->SetNum(0);
                default_texture_white->SetMax(0);
                *scrollback = 0;
                return true;
            }
            else if (LuaStatics::console_executor_enabled)
            {
                if (!LuaStatics::console_executor)
                {
                    logln(STR("Console Lua executor is enabled but the Lua instance is nullptr. Please try run RC_LUA_START again."));
                    return true;
                }

                LuaLibrary::set_outputdevice_ref(*LuaStatics::console_executor, &ar);

                //logln(std::format(STR("Executing '{}' as Lua"), cmd));

                try
                {
                    if (int status = luaL_loadstring(LuaStatics::console_executor->get_lua_state(), to_string(cmd).c_str()); status != LUA_OK)
                    {
                        LuaStatics::console_executor->throw_error(std::format("luaL_loadstring returned {}", LuaStatics::console_executor->resolve_status_message(status, true)));
                    }

                    if (int status = lua_pcall(LuaStatics::console_executor->get_lua_state(), 0, LUA_MULTRET, 0); status != LUA_OK)
                    {
                        LuaStatics::console_executor->throw_error(std::format("lua_pcall returned {}", LuaStatics::console_executor->resolve_status_message(status, true)));
                    }
                }
                catch (std::runtime_error& e)
                {
                    logln(to_wstring(e.what()));
                }

                // We always return true when the console Lua executor is enabled in order to suppress other handlers
                return true;
            }
            else
            {
                return false;
            }
        });

        Unreal::Hook::RegisterProcessConsoleExecCallback([](Unreal::UObject* context, const TCHAR* cmd, Unreal::FOutputDevice& ar, Unreal::UObject* executor) -> bool {
            (void)executor;

            if (!Unreal::Cast<Unreal::UGameViewportClient>(context)) { return false; }

            return TRY([&] {
                auto command = File::StringViewType{cmd};
                auto command_parts = explode_by_occurrence(cmd, ' ');
                File::StringType command_name;
                if (command_parts.size() > 1)
                {
                    command_name = command_parts[0];
                }
                else
                {
                    command_name = command;
                }

                if (auto it = m_custom_command_lua_pre_callbacks.find(command_name); it != m_custom_command_lua_pre_callbacks.end())
                {
                    const auto& callback_data = it->second;

                    // This is a promise that we're in the game thread, used by other functions to ensure that we don't execute when unsafe
                    set_is_in_game_thread(callback_data.lua, true);

                    bool return_value{};

                    for (const auto& registry_index : callback_data.registry_indexes)
                    {
                        callback_data.lua.registry().get_function_ref(registry_index);
                        callback_data.lua.set_string(to_string(command));

                        auto params_table = callback_data.lua.prepare_new_table();
                        for (auto i = 1; i < command_parts.size(); ++i)
                        {
                            const auto& command_part = command_parts[i];
                            params_table.add_pair(i, to_string(command_part).c_str());
                        }

                        LuaType::FOutputDevice::construct(callback_data.lua, &ar);

                        callback_data.lua.call_function(3, 1);

                        if (!callback_data.lua.is_bool())
                        {
                            throw std::runtime_error{"A custom console command handle must return true or false"};
                        }

                        return_value = callback_data.lua.get_bool();
                    }
                    // No longer promising to be in the game thread
                    set_is_in_game_thread(callback_data.lua, false);

                    return return_value;
                }

                return false;
            });
        });

        Unreal::Hook::RegisterProcessConsoleExecCallback([](Unreal::UObject* context, const TCHAR* cmd, Unreal::FOutputDevice& ar, Unreal::UObject* executor) -> bool {
            (void)context;
            (void)executor;

            return TRY([&] {
                auto command = File::StringViewType{cmd};
                auto command_parts = explode_by_occurrence(cmd, ' ');
                File::StringType command_name;
                if (command_parts.size() > 1)
                {
                    command_name = command_parts[0];
                }
                else
                {
                    command_name = command;
                }

                if (auto it = m_global_command_lua_callbacks.find(command_name); it != m_global_command_lua_callbacks.end())
                {
                    const auto& callback_data = it->second;

                    // This is a promise that we're in the game thread, used by other functions to ensure that we don't execute when unsafe
                    set_is_in_game_thread(callback_data.lua, true);

                    bool return_value{};

                    for (const auto& registry_index : callback_data.registry_indexes)
                    {
                        callback_data.lua.registry().get_function_ref(registry_index);
                        callback_data.lua.set_string(to_string(command));

                        auto params_table = callback_data.lua.prepare_new_table();
                        for (auto i = 1; i < command_parts.size(); ++i)
                        {
                            const auto& command_part = command_parts[i];
                            params_table.add_pair(i, to_string(command_part).c_str());
                        }

                        LuaType::FOutputDevice::construct(callback_data.lua, &ar);

                        callback_data.lua.call_function(3, 1);

                        if (!callback_data.lua.is_bool())
                        {
                            throw std::runtime_error{"A custom console command handle must return true or false"};
                        }

                        return_value = callback_data.lua.get_bool();
                    }

                    // No longer promising to be in the game thread
                    set_is_in_game_thread(callback_data.lua, false);

                    return return_value;
                }

                return false;
            });
        });
    }

    auto Mod::update() -> void
    {
    }

    auto Mod::update_async() -> void
    {
        for (m_processing_events = true; m_processing_events;)
        {
            if (m_pause_events_processing) { continue; }

            process_delayed_actions();

            std::this_thread::sleep_for(std::chrono::milliseconds(5));
        }
    }

    auto Mod::process_delayed_actions() -> void
    {
        auto now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now().time_since_epoch()).count();

        actions_lock();

        m_delayed_actions.insert(m_delayed_actions.end(), std::make_move_iterator(m_pending_actions.begin()), std::make_move_iterator(m_pending_actions.end()));
        m_pending_actions.clear();

        actions_unlock();

        
        m_delayed_actions.erase(std::remove_if(m_delayed_actions.begin(), m_delayed_actions.end(),
            [&](AsyncAction& action) -> bool {
                auto passed = now - std::chrono::duration_cast<std::chrono::milliseconds>(action.created_at.time_since_epoch()).count();
                auto duration_since_creation = (action.type == Mod::ActionType::Immediate || passed >= action.delay);
                if (duration_since_creation)
                {
                    bool result = true;
                    try
                    {
                        async_lua()->registry().get_function_ref(action.lua_action_function_ref);
                        if (action.type == Mod::ActionType::Loop)
                        {
                            async_lua()->call_function(0, 1);
                            result = async_lua()->is_bool() && async_lua()->get_bool();
                            action.created_at = std::chrono::steady_clock::now();
                        }
                        else
                        {
                            async_lua()->call_function(0, 0);
                        }
                    }
                    catch (std::runtime_error& e)
                    {
                        Output::send(STR("[{}] {}\n"), to_wstring(action.type == Mod::ActionType::Loop ? "LoopAsync" : "DelayedAction"), to_wstring(e.what()));
                    }

                    return result;
                }
                else
                {
                    return false;
                }
            }), m_delayed_actions.end());
    }

    auto Mod::clear_delayed_actions() -> void
    {
        actions_lock();
        m_pending_actions.clear();
        m_delayed_actions.clear();
        actions_unlock();
    }
}

```

`src/ObjectDumper/ObjectToString.cpp`:

```cpp
#include <format>

#include <ObjectDumper/ObjectToString.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UObject.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FDelegateProperty.hpp>
#include <Unreal/Property/FFieldPathProperty.hpp>
#include <Unreal/Property/FInterfaceProperty.hpp>
#include <Unreal/Property/FMapProperty.hpp>
#include <Unreal/Property/FMulticastDelegateProperty.hpp>
#include <Unreal/Property/FMulticastInlineDelegateProperty.hpp>
#include <Unreal/Property/FMulticastSparseDelegateProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FNameProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FLazyObjectProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FTextProperty.hpp>
#include <Unreal/Property/FStrProperty.hpp>
#pragma warning(default: 4005)

namespace RC::ObjectDumper
{
    using namespace RC::Unreal;

    std::unordered_map<ToStringHash, ObjectToStringDecl> object_to_string_functions{};
    std::unordered_map<ToStringHash, ObjectToStringComplexDecl> object_to_string_complex_functions{};

    auto get_to_string(size_t hash) -> ObjectToStringDecl
    {
        return object_to_string_functions[hash];
    }

    auto get_to_string_complex(size_t hash) -> ObjectToStringComplexDecl
    {
        return object_to_string_complex_functions[hash];
    }

    auto to_string_exists(size_t hash) -> bool
    {
        return object_to_string_functions.contains(hash);
    }

    auto to_string_complex_exists(size_t hash) -> bool
    {
        return object_to_string_complex_functions.contains(hash);
    }

    auto object_trivial_dump_to_string(void* p_this, std::wstring& out_line, const wchar_t* post_delimiter) -> void
    {
        UObject* p_typed_this = static_cast<UObject*>(p_this);

        out_line.append(std::format(L"[{:016X}] ", reinterpret_cast<uintptr_t>(p_this)));
        out_line.append(p_typed_this->GetFullName());
        out_line.append(std::format(L" [n: {:X}] [c: {:016X}] [or: {:016X}]",
                                    p_typed_this->GetNamePrivate().GetComparisonIndex(),
                                    reinterpret_cast<uintptr_t>(p_typed_this->GetClassPrivate()),
                                    reinterpret_cast<uintptr_t>(p_typed_this->GetOuterPrivate())));
    }

    auto object_to_string(void* p_this, std::wstring& out_line) -> void
    {
        object_trivial_dump_to_string(p_this, out_line);
    }

    auto property_trivial_dump_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FProperty* p_typed_this = static_cast<FProperty*>(p_this);

        out_line.append(std::format(L"[{:016X}] ", reinterpret_cast<uintptr_t>(p_this)));
        out_line.append(p_typed_this->GetFullName());
        out_line.append(std::format(L" [o: {:X}] ", p_typed_this->GetOffset_Internal()));

        auto property_class = p_typed_this->GetClass();
        out_line.append(std::format(L"[n: {:X}] [c: {:016X}]", p_typed_this->GetFName().GetComparisonIndex(), property_class.HashObject()));

        if (Version::IsAtLeast(4, 25))
        {
            out_line.append(std::format(L" [owr: {:016X}]", p_typed_this->GetOwnerVariant().HashObject()));
        }
    }

    auto property_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);
    }

    auto arrayproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        FArrayProperty* p_typed_this = static_cast<FArrayProperty*>(p_this);
        out_line.append(std::format(L" [ai: {:016X}]", reinterpret_cast<uintptr_t>(p_typed_this->GetInner())));
    }

    auto arrayproperty_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void
    {
        FProperty* array_inner = static_cast<FArrayProperty*>(p_this)->GetInner();
        auto array_inner_class = array_inner->GetClass().HashObject();

        if (to_string_exists(array_inner_class))
        {
            get_to_string(array_inner_class)(array_inner, out_line);

            if (to_string_complex_exists(array_inner_class))
            {
                // If this code is executed then we'll be having another line before we return to the dumper, so we need to explicitly add a new line
                // If this code is not executed then we'll not be having another line and the dumper will add the new line
                out_line.append(L"\n");

                get_to_string_complex(array_inner_class)(array_inner, out_line, [&]([[maybe_unused]]void* prop) {
                    // It's possible that a new line is supposed to be appended here
                });
            }

            callable(array_inner);
        }
        else
        {
            out_line.append(array_inner->GetFullName());
            callable(array_inner);
        }
    }

    auto mapproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        FMapProperty* typed_this = static_cast<FMapProperty*>(p_this);
        FProperty* key_property = typed_this->GetKeyProp();
        FProperty* value_property = typed_this->GetValueProp();
        out_line.append(std::format(L" [kp: {:016X}] [vp: {:016X}]", reinterpret_cast<uintptr_t>(key_property), reinterpret_cast<uintptr_t>(value_property)));
    }

    auto mapproperty_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void
    {
        FMapProperty* typed_this = static_cast<FMapProperty*>(p_this);
        FProperty* key_property = typed_this->GetKeyProp();
        FProperty* value_property = typed_this->GetValueProp();
        auto key_property_class = key_property->GetClass().HashObject();
        auto value_property_class = value_property->GetClass().HashObject();

        auto dump_property = [&](FProperty* property, ToStringHash property_class) {
            if (to_string_exists(property_class))
            {
                get_to_string(property_class)(property, out_line);

                if (to_string_complex_exists(property_class))
                {
                    // If this code is executed then we'll be having another line before we return to the dumper, so we need to explicitly add a new line
                    // If this code is not executed then we'll not be having another line and the dumper will add the new line
                    out_line.append(L"\n");

                    get_to_string_complex(property_class)(property, out_line, [&]([[maybe_unused]]void* prop) {
                    });
                }

                callable(property);
            }
            else
            {
                out_line.append(property->GetFullName());
                callable(property);
            }
        };

        dump_property(key_property, key_property_class);
        dump_property(value_property, value_property_class);
    }

    auto classproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FClassProperty* typed_this = static_cast<FClassProperty*>(p_this);

        property_trivial_dump_to_string(p_this, out_line);
        // mc = MetaClass
        out_line.append(std::format(L" [mc: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetMetaClass())));
    }

    auto delegateproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        FDelegateProperty* p_typed_this = static_cast<FDelegateProperty*>(p_this);
        out_line.append(std::format(L" [df: {:016X}]", reinterpret_cast<uintptr_t>(p_typed_this->GetFunctionSignature())));
    }

    auto fieldpathproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FFieldPathProperty* typed_this = static_cast<FFieldPathProperty*>(p_this);

        property_trivial_dump_to_string(p_this, out_line);
        out_line.append(std::format(L" [pc: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetPropertyClass())));
    }

    auto interfaceproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FInterfaceProperty* typed_this = static_cast<FInterfaceProperty*>(p_this);

        property_trivial_dump_to_string(p_this, out_line);
        out_line.append(std::format(L" [ic: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetInterfaceClass())));
    }

    auto multicastdelegateproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        FMulticastDelegateProperty* p_typed_this = static_cast<FMulticastDelegateProperty*>(p_this);
        out_line.append(std::format(L" [df: {:016X}]", reinterpret_cast<uintptr_t>(p_typed_this->GetFunctionSignature())));
    }

    auto objectproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FObjectProperty* typed_this = static_cast<FObjectProperty*>(p_this);

        property_trivial_dump_to_string(p_this, out_line);
        out_line.append(std::format(L" [pc: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetPropertyClass())));
    }

    auto structproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        FStructProperty* typed_this = static_cast<FStructProperty*>(p_this);

        property_trivial_dump_to_string(p_this, out_line);
        out_line.append(std::format(L" [ss: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetStruct())));
    }

    auto enumproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        auto* typed_this = static_cast<FEnumProperty*>(p_this);
        out_line.append(std::format(L" [em: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetEnum())));
    }

    auto boolproperty_to_string(void* p_this, std::wstring& out_line) -> void
    {
        property_trivial_dump_to_string(p_this, out_line);

        auto* typed_this = static_cast<FBoolProperty*>(p_this);
        if (typed_this->GetFieldMask() != 255)
        {
            out_line.append(std::format(L" [fm: {:X}] [bm: {:X}]", typed_this->GetFieldMask(), typed_this->GetByteMask()));
        }
    }

    auto enum_to_string(void* p_this, std::wstring& out_line) -> void
    {
        object_trivial_dump_to_string(p_this, out_line);

        auto* typed_this = static_cast<UEnum*>(p_this);

        typed_this->ForEachName([&](Unreal::FName name, int64_t value) {
            out_line.append(std::format(L"\n[{:016X}] {} [n: {:X}] [v: {}]", 0, name.ToString(), name.GetComparisonIndex(), static_cast<uint8_t>(value)));
            return LoopAction::Continue;
        });
    }

    auto class_to_string(void* p_this, std::wstring& out_line) -> void
    {
        UClass* typed_this = static_cast<UClass*>(p_this);

        object_trivial_dump_to_string(p_this, out_line);
        out_line.append(std::format(L" [sps: {:016X}]", reinterpret_cast<uintptr_t>(typed_this->GetSuperStruct())));
    }

    auto function_to_string(void* p_this, std::wstring& out_line) -> void
    {
        object_trivial_dump_to_string(p_this, out_line, L":");
    }

    auto scriptstruct_to_string_complex(void* p_this, std::wstring& out_line, ObjectToStringComplexDeclCallable callable) -> void
    {
        UScriptStruct* script_struct = static_cast<UScriptStruct*>(p_this);

        script_struct->ForEachProperty([&](FProperty* prop) {
            callable(prop);
            return LoopAction::Continue;
        });
    }

    auto init() -> void
    {
        object_to_string_functions[UEnum::StaticClass()->HashObject()] = &enum_to_string;
        object_to_string_functions[UUserDefinedEnum::StaticClass()->HashObject()] = &enum_to_string;
        object_to_string_functions[UClass::StaticClass()->HashObject()] = &class_to_string;
        object_to_string_functions[UBlueprintGeneratedClass::StaticClass()->HashObject()] = &class_to_string;
        object_to_string_functions[UWidgetBlueprintGeneratedClass::StaticClass()->HashObject()] = &class_to_string;
        object_to_string_functions[UAnimBlueprintGeneratedClass::StaticClass()->HashObject()] = &class_to_string;
        object_to_string_functions[UFunction::StaticClass()->HashObject()] = &function_to_string;
        //object_to_string_functions[UDelegateFunction::StaticClass()->HashObject()] = &function_to_string;
        //object_to_string_functions[USparseDelegateFunction::StaticClass()->HashObject()] = &function_to_string;
        object_to_string_functions[UScriptStruct::StaticClass()->HashObject()] = &object_to_string;
        object_to_string_complex_functions[UScriptStruct::StaticClass()->HashObject()] = &scriptstruct_to_string_complex;
        object_to_string_functions[FObjectProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        object_to_string_functions[FObjectPtrProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        object_to_string_functions[FAssetObjectProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        object_to_string_functions[FAssetClassProperty::StaticClass().HashObject()] = &classproperty_to_string;
        object_to_string_functions[FInt8Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FInt16Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FIntProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FInt64Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FByteProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FUInt16Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FUInt32Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FUInt64Property::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FNameProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FFloatProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FBoolProperty::StaticClass().HashObject()] = &boolproperty_to_string;
        object_to_string_functions[FArrayProperty::StaticClass().HashObject()] = &arrayproperty_to_string;
        object_to_string_complex_functions[FArrayProperty::StaticClass().HashObject()] = &arrayproperty_to_string_complex;
        object_to_string_functions[FMapProperty::StaticClass().HashObject()] = &mapproperty_to_string;
        object_to_string_complex_functions[FMapProperty::StaticClass().HashObject()] = &mapproperty_to_string_complex;
        object_to_string_functions[FStructProperty::StaticClass().HashObject()] = &structproperty_to_string;
        object_to_string_functions[FClassProperty::StaticClass().HashObject()] = &classproperty_to_string;
        if (Version::IsAtLeast(4, 18))
        {
            object_to_string_functions[FSoftClassProperty::StaticClass().HashObject()] = &classproperty_to_string;
            object_to_string_functions[FSoftObjectProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        }
        object_to_string_functions[FWeakObjectProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        object_to_string_functions[FLazyObjectProperty::StaticClass().HashObject()] = &objectproperty_to_string;
        if (Version::IsAtLeast(4, 15))
        {
            object_to_string_functions[FEnumProperty::StaticClass().HashObject()] = &enumproperty_to_string;
        }
        object_to_string_functions[FTextProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FStrProperty::StaticClass().HashObject()] = &property_to_string;
        object_to_string_functions[FDelegateProperty::StaticClass().HashObject()] = &delegateproperty_to_string;
        object_to_string_functions[FMulticastDelegateProperty::StaticClass().HashObject()] = &multicastdelegateproperty_to_string;
        if (Version::IsAtLeast(4,23))
        {
            object_to_string_functions[FMulticastInlineDelegateProperty::StaticClass().HashObject()] = &multicastdelegateproperty_to_string;
            object_to_string_functions[FMulticastSparseDelegateProperty::StaticClass().HashObject()] = &multicastdelegateproperty_to_string;
        }
        object_to_string_functions[FInterfaceProperty::StaticClass().HashObject()] = &interfaceproperty_to_string;
        if (Version::IsAtLeast(4, 25))
        {
            object_to_string_functions[FFieldPathProperty::StaticClass().HashObject()] = &fieldpathproperty_to_string;
        }
    }
}

```

`src/SDKGenerator/Common.cpp`:

```cpp
#include <SDKGenerator/Common.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UClass.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/UInterface.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FLazyObjectProperty.hpp>
#include <Unreal/Property/FSoftObjectProperty.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>
#include <Unreal/Property/FInterfaceProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FDelegateProperty.hpp>
#include <Unreal/Property/FMulticastInlineDelegateProperty.hpp>
#include <Unreal/Property/FMulticastSparseDelegateProperty.hpp>
#include <Unreal/Property/FFieldPathProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FSetProperty.hpp>
#include <Unreal/Property/FMapProperty.hpp>
#include <Unreal/UPackage.hpp>
#pragma warning(default: 4005)

#define DELEGATE_SIGNATURE_POSTFIX STR("__DelegateSignature")

namespace RC::UEGenerator
{
    using UObject = Unreal::UObject;
    using UClass = Unreal::UClass;
    using AActor = Unreal::AActor;
    using UEnum = Unreal::UEnum;
    using UScriptStruct = Unreal::UScriptStruct;
    using UFunction = Unreal::UFunction;
    using UInterface = Unreal::UInterface;
    using FProperty = Unreal::FProperty;
    using FByteProperty = Unreal::FByteProperty;
    using FEnumProperty = Unreal::FEnumProperty;
    using FNumericProperty = Unreal::FNumericProperty;
    using FBoolProperty = Unreal::FBoolProperty;
    using FObjectProperty = Unreal::FObjectProperty;
    using FObjectPtrProperty = Unreal::FObjectPtrProperty;
    using FWeakObjectProperty = Unreal::FWeakObjectProperty;
    using FLazyObjectProperty = Unreal::FLazyObjectProperty;
    using FSoftObjectProperty = Unreal::FSoftObjectProperty;
    using FClassProperty = Unreal::FClassProperty;
    using FClassPtrProperty = Unreal::FClassPtrProperty;
    using FSoftClassProperty = Unreal::FSoftClassProperty;
    using FInterfaceProperty = Unreal::FInterfaceProperty;
    using FStructProperty = Unreal::FStructProperty;
    using FDelegateProperty = Unreal::FDelegateProperty;
    using FMulticastInlineDelegateProperty = Unreal::FMulticastInlineDelegateProperty;
    using FMulticastSparseDelegateProperty = Unreal::FMulticastSparseDelegateProperty;
    using FFieldPathProperty = Unreal::FFieldPathProperty;
    using FArrayProperty = Unreal::FArrayProperty;
    using FSetProperty = Unreal::FSetProperty;
    using FMapProperty = Unreal::FMapProperty;

    auto get_native_class_name(UClass* uclass, bool interface_name) -> File::StringType
    {
        File::StringType result_string;

        if (interface_name)
        {
            result_string.append(STR("I"));
        }
        else if (uclass->IsChildOf<AActor>())
        {
            result_string.append(STR("A"));
        }
        else
        {
            result_string.append(STR("U"));
        }
        if ((uclass->GetClassFlags() & Unreal::CLASS_Deprecated) != 0)
        {
            result_string.append(STR("DEPRECATED_"));
        }

        result_string.append(uclass->GetName());
        return result_string;
    }

    auto is_integral_type(FProperty* property) -> bool
    {
        if (property->IsA<FNumericProperty>())
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    auto get_native_enum_name(UEnum* uenum, bool include_type) -> File::StringType
    {
        std::wstring result_string;

        //Seems to be not needed, because enum objects, unlike classes or structs, retain their normal E prefix
        //ResultString.append(STR("E"));
        result_string.append(uenum->GetName());

        //Namespaced enums need to have ::Type appended for the type
        if (uenum->GetCppForm() == UEnum::ECppForm::Namespaced && include_type)
        {
            result_string.append(STR("::Type"));
        }
        return result_string;
    }

    auto get_native_struct_name(UScriptStruct* script_struct) -> File::StringType
    {
        std::wstring result_string;

        result_string.append(STR("F"));
        result_string.append(script_struct->GetName());

        return result_string;
    }

    auto sanitize_property_name(const File::StringType& property_name) -> File::StringType
    {
        std::wstring resulting_name = property_name;

        //Remove heading underscore, used by private variables in some games
        if (resulting_name.length() >= 2 && resulting_name[0] == '_')
        {
            resulting_name.erase(0, 1);
        }
        //Remove heading m if it is followed by uppercase letter, used by variables in some games
        if (resulting_name.length() >= 2 && resulting_name[0] == 'm' && towupper(resulting_name[1]) == resulting_name[1])
        {
            resulting_name.erase(0, 1);
        }

        //Make sure first character is uppercase
        if (resulting_name.length() >= 1)
        {
            resulting_name[0] = towupper(resulting_name[0]);
        }
        return resulting_name;
    }

    auto generate_delegate_name(FProperty* property, const File::StringType& context_name) -> File::StringType
    {
        const std::wstring property_name = sanitize_property_name(property->GetName());
        return fmt::format(STR("F{}{}"), context_name, property_name);
    }

    auto generate_property_cxx_name(FProperty* property, bool is_top_level_declaration, UObject* class_context, EnableForwardDeclarations enable_forward_declarations) -> File::StringType
    {
        const std::wstring field_class_name = property->GetClass().GetName();

        //Byte Property
        if (field_class_name == STR("ByteProperty"))
        {
            FByteProperty* byte_property = static_cast<FByteProperty*>(property);
            UEnum* enum_value = byte_property->GetEnum();

            if (enum_value != NULL)
            {
                //Non-EnumClass enumerations should be wrapped into TEnumAsByte according to UHT
                const std::wstring enum_type_name = get_native_enum_name(enum_value);
                return fmt::format(STR("TEnumAsByte<{}>"), enum_type_name);
            }
            return STR("uint8");
        }

        //Enum Property
        if (field_class_name == STR("EnumProperty"))
        {
            FEnumProperty* enum_property = static_cast<FEnumProperty*>(property);
            FNumericProperty* underlying_property = enum_property->GetUnderlyingProperty();
            UEnum* uenum = enum_property->GetEnum();

            if (uenum == NULL)
            {
                throw std::runtime_error(RC::fmt("EnumProperty %S does not have a valid Enum value", property->GetName().c_str()));
            }

            const std::wstring enum_type_name = get_native_enum_name(uenum);
            return enum_type_name;
        }

        //Bool Property
        if (field_class_name == STR("BoolProperty"))
        {
            FBoolProperty* bool_property = static_cast<FBoolProperty*>(property);
            if (is_top_level_declaration && bool_property->GetFieldMask() != 255)
            {
                return STR("uint8");
            }
            return STR("bool");
        }

        //Standard Numeric Properties
        if (field_class_name == STR("Int8Property"))
        {
            return STR("int8");
        }
        else if (field_class_name == STR("Int16Property"))
        {
            return STR("int16");
        }
        else if (field_class_name == STR("IntProperty"))
        {
            return STR("int32");
        }
        else if (field_class_name == STR("Int64Property"))
        {
            return STR("int64");
        }
        else if (field_class_name == STR("UInt16Property"))
        {
            return STR("uint16");
        }
        else if (field_class_name == STR("UInt32Property"))
        {
            return STR("uint32");
        }
        else if (field_class_name == STR("UInt64Property"))
        {
            return STR("uint64");
        }
        else if (field_class_name == STR("FloatProperty"))
        {
            return STR("float");
        }
        else if (field_class_name == STR("DoubleProperty"))
        {
            return STR("double");
        }

        //Object Properties
        // TODO: Verify that the syntax for 'AssetObjectProperty' is the same as for 'ObjectProperty'.
        //       If it's not, then add another branch here after you figure out what the syntax should be.
        if (field_class_name == STR("ObjectProperty") || field_class_name == STR("AssetObjectProperty"))
        {
            FObjectProperty* object_property = static_cast<FObjectProperty*>(property);
            UClass* property_class = object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("UObject*");
            }

            const std::wstring property_class_name = get_native_class_name(property_class, false);
            return fmt::format(STR("{}*"), property_class_name);
        }

        if (auto* object_property = CastField<FObjectPtrProperty>(property); object_property)
        {
            auto* property_class = object_property->GetPropertyClass();

            if (!property_class)
            {
                return STR("TObjectPtr<UObject>");
            }
            else
            {
                const auto property_class_name = get_native_class_name(property_class, false);
                return std::format(STR("TObjectPtr<{}>"), property_class_name);
            }
        }

        if (field_class_name == STR("WeakObjectProperty"))
        {
            FWeakObjectProperty* weak_object_property = static_cast<FWeakObjectProperty*>(property);
            UClass* property_class = weak_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TWeakObjectPtr<UObject>");
            }

            File::StringType property_class_name{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes)
            {
                property_class_name = std::format(STR("class "));
            }
            property_class_name.append(get_native_class_name(property_class, false));
            return fmt::format(STR("TWeakObjectPtr<{}>"), property_class_name);
        }

        if (field_class_name == STR("LazyObjectProperty"))
        {
            FLazyObjectProperty* lazy_object_property = static_cast<FLazyObjectProperty*>(property);
            UClass* property_class = lazy_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TLazyObjectPtr<UObject>");
            }

            File::StringType property_class_name{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes)
            {
                property_class_name = STR("class ");
            }
            property_class_name.append(get_native_class_name(property_class, false));
            return fmt::format(STR("TLazyObjectPtr<{}>"), property_class_name);
        }

        if (field_class_name == STR("SoftObjectProperty"))
        {
            FSoftObjectProperty* soft_object_property = static_cast<FSoftObjectProperty*>(property);
            UClass* property_class = soft_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TSoftObjectPtr<UObject>");
            }

            const std::wstring property_class_name = get_native_class_name(property_class, false);
            return fmt::format(STR("TSoftObjectPtr<{}>"), property_class_name);
        }

        //Class Properties
        if (field_class_name == STR("ClassProperty") || field_class_name == STR("AssetClassProperty"))
        {
            FClassProperty* class_property = static_cast<FClassProperty*>(property);
            UClass* meta_class = class_property->GetMetaClass();

            if (meta_class == NULL || meta_class == UObject::StaticClass())
            {
                return STR("UClass*");
            }

            File::StringType meta_class_name{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes)
            {
                meta_class_name = STR("class ");
            }
            meta_class_name.append(get_native_class_name(meta_class, false));
            return fmt::format(STR("TSubclassOf<{}>"), meta_class_name);
        }

        if (auto* class_property = CastField<FClassPtrProperty>(property); class_property)
        {
            // TODO: Confirm that this is accurate
            return STR("TObjectPtr<UClass>");
        }

        if (field_class_name == STR("SoftClassProperty"))
        {
            FSoftClassProperty* soft_class_property = static_cast<FSoftClassProperty*>(property);
            UClass* meta_class = soft_class_property->GetMetaClass();

            if (meta_class == NULL || meta_class == UObject::StaticClass())
            {
                return STR("TSoftClassPtr<UObject>");
            }

            const std::wstring meta_class_name = get_native_class_name(meta_class, false);
            return fmt::format(STR("TSoftClassPtr<{}>"), meta_class_name);
        }

        //Interface Property
        if (field_class_name == STR("InterfaceProperty"))
        {
            FInterfaceProperty* interface_property = static_cast<FInterfaceProperty*>(property);
            UClass* interface_class = interface_property->GetInterfaceClass();

            if (interface_class == NULL || interface_class == UInterface::StaticClass())
            {
                return STR("FScriptInterface");
            }

            File::StringType interface_class_name{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes)
            {
                interface_class_name = STR("class ");
            }
            interface_class_name.append(get_native_class_name(interface_class, true));
            return fmt::format(STR("TScriptInterface<{}>"), interface_class_name);
        }

        //Struct Property
        if (field_class_name == STR("StructProperty"))
        {
            FStructProperty* struct_property = static_cast<FStructProperty*>(property);
            UScriptStruct* script_struct = struct_property->GetStruct();

            if (script_struct == NULL)
            {
                throw std::runtime_error(RC::fmt("Struct is NULL for StructProperty %S", property->GetName().c_str()));
            }

            const std::wstring native_struct_name = get_native_struct_name(script_struct);
            return native_struct_name;
        }

        //Delegate Properties
        if (field_class_name == STR("DelegateProperty"))
        {
            FDelegateProperty* delegate_property = static_cast<FDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            const std::wstring delegate_type_name = generate_delegate_name(delegate_property, class_context->GetName());
            return delegate_type_name;
        }

        // In 4.23, they replaced 'MulticastDelegateProperty' with 'Inline' & 'Sparse' variants
        // It looks like the delegate macro might be the same as the 'Inline' variant in later versions, so we'll use the same branch here
        if (field_class_name == STR("MulticastInlineDelegateProperty") || field_class_name == STR("MulticastDelegateProperty"))
        {
            FMulticastInlineDelegateProperty* delegate_property = static_cast<FMulticastInlineDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            const std::wstring delegate_type_name = generate_delegate_name(delegate_property, class_context->GetName());
            return delegate_type_name;
        }

        if (field_class_name == STR("MulticastSparseDelegateProperty"))
        {
            FMulticastSparseDelegateProperty* delegate_property = static_cast<FMulticastSparseDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            const std::wstring delegate_type_name = generate_delegate_name(delegate_property, class_context->GetName());
            return delegate_type_name;
        }

        //Field path property
        if (field_class_name == STR("FieldPathProperty"))
        {
            FFieldPathProperty* field_path_property = static_cast<FFieldPathProperty*>(property);
            const std::wstring property_class_name = field_path_property->GetPropertyClass()->GetName();
            return fmt::format(STR("TFieldPath<F{}>"), property_class_name);
        }

        //Collection and Map Properties
        // TODO: This is missing support for freeze image array properties because XArrayProperty is incomplete. (low priority)
        if (field_class_name == STR("ArrayProperty"))
        {
            FArrayProperty* array_property = static_cast<FArrayProperty*>(property);
            FProperty* inner_property = array_property->GetInner();

            File::StringType inner_property_type{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes && !is_integral_type(inner_property))
            {
                if (inner_property->IsA<FObjectProperty>())
                {
                    inner_property_type = STR("class ");
                }
            }
            inner_property_type.append(generate_property_cxx_name(inner_property, is_top_level_declaration, class_context));
            return fmt::format(STR("TArray<{}>"), inner_property_type);
        }

        if (field_class_name == STR("SetProperty"))
        {
            FSetProperty* set_property = static_cast<FSetProperty*>(property);
            FProperty* element_prop = set_property->GetElementProp();

            const std::wstring element_property_type = generate_property_cxx_name(element_prop, is_top_level_declaration, class_context);
            return fmt::format(STR("TSet<{}>"), element_property_type);
        }

        // TODO: This is missing support for freeze image map properties because XMapProperty is incomplete. (low priority)
        if (field_class_name == STR("MapProperty"))
        {
            FMapProperty* map_property = static_cast<FMapProperty*>(property);
            FProperty* key_property = map_property->GetKeyProp();
            FProperty* value_property = map_property->GetValueProp();

            File::StringType key_type{};
            File::StringType value_type{};
            if (enable_forward_declarations == EnableForwardDeclarations::Yes && !is_integral_type(key_property) && !is_integral_type(value_property))
            {
                if (!key_property->IsA<FClassPtrProperty>())
                {
                    key_type = STR("class ");
                }

                if (!value_property->IsA<FClassPtrProperty>())
                {
                    value_type = STR("class ");
                }
            }
            key_type.append(generate_property_cxx_name(key_property, is_top_level_declaration, class_context));
            value_type.append(generate_property_cxx_name(value_property, is_top_level_declaration, class_context));

            return fmt::format(STR("TMap<{}, {}>"), key_type, value_type);
        }

        //Standard properties that do not have any special attributes
        if (field_class_name == STR("NameProperty"))
        {
            return STR("FName");
        }
        else if (field_class_name == STR("StrProperty"))
        {
            return STR("FString");
        }
        else if (field_class_name == STR("TextProperty"))
        {
            return STR("FText");
        }
        throw std::runtime_error(RC::fmt("Unsupported property class %S", field_class_name.c_str()));
    }

    auto get_native_delegate_type_name(Unreal::UFunction* signature_function, Unreal::UClass* current_class, bool strip_outer_name) -> File::StringType {
        if (!is_delegate_signature_function(signature_function)) {
           throw std::runtime_error(RC::fmt("Function %S is not a delegate signature function", signature_function->GetName().c_str()));
        }

        //Delegate names always start with F and have __DelegateSignature postfix
        File::StringType delegate_type_name = strip_delegate_signature_postfix(signature_function);
        delegate_type_name.insert(0, STR("F"));

        //Return the delegate name without the outer name if we have been requested to strip it
        if (strip_outer_name) {
            return delegate_type_name;
        }

        UObject* delegate_outer = signature_function->GetOuterPrivate();

        //If delegate is declared inside the class, we need to retrieve the class name and use it as the outer type
        if (UClass* delegate_outer_class = Unreal::Cast<UClass>(delegate_outer)) {

            //Skip the scope declaration if delegate is declared inside the current class
            if (delegate_outer_class != current_class) {
                //For interface, delegates are declared inside the interface definition
                bool is_class_interface = delegate_outer_class->IsChildOf<UInterface>();
                const File::StringType outer_class_name = get_native_class_name(delegate_outer_class, is_class_interface);

                delegate_type_name.insert(0, STR("::"));
                delegate_type_name.insert(0, outer_class_name);

            }
        } else if (!delegate_outer->IsA<Unreal::UPackage>()) {
            //Delegate signature functions should never exist outside the UPackage or UClass
            throw std::runtime_error(RC::fmt("Delegate signature function %S does not have class or package as outer", delegate_outer->GetName().c_str()));
        }
        return delegate_type_name;
    }

    auto is_delegate_signature_function(Unreal::UFunction* function) -> bool {
        return (function->GetFunctionFlags() & Unreal::FUNC_Delegate) != 0 && function->GetName().ends_with(DELEGATE_SIGNATURE_POSTFIX);
    }

    auto strip_delegate_signature_postfix(Unreal::UFunction* signature_function) -> File::StringType {
        if (!is_delegate_signature_function(signature_function)) {
            throw std::runtime_error(RC::fmt("Function %S is not a delegate signature function", signature_function->GetName().c_str()));
        }

        //Delegate names always start with F and have __DelegateSignature postfix
        const File::StringType delegate_signature_postfix = DELEGATE_SIGNATURE_POSTFIX;

        File::StringType delegate_name = signature_function->GetName();
        delegate_name.erase(delegate_name.length() - delegate_signature_postfix.length());
        return delegate_name;
    }
}
```

`src/SDKGenerator/Generator.cpp`:

```cpp
#include <format>
#include <cwctype>

#include <SDKGenerator/Generator.hpp>
#include <SDKGenerator/Common.hpp>
#include <UE4SSProgram.hpp>
#pragma warning(disable: 4005)
#include <Unreal/TypeChecker.hpp>
#include <Unreal/UObjectGlobals.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UInterface.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FMapProperty.hpp>
#include <Unreal/Property/FDelegateProperty.hpp>
#include <Unreal/Property/FMulticastInlineDelegateProperty.hpp>
#include <Unreal/Property/FMulticastSparseDelegateProperty.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#pragma warning(default: 4005)

namespace RC::UEGenerator
{
    using TypeChecker = RC::Unreal::TypeChecker;
    namespace UObjectGlobals = RC::Unreal::UObjectGlobals;
    using EObjectFlags = RC::Unreal::EObjectFlags;
    using FName = RC::Unreal::FName;
    using UObject = RC::Unreal::UObject;
    using UClass = RC::Unreal::UClass;
    using UInterface = RC::Unreal::UInterface;
    using UScriptStruct = RC::Unreal::UScriptStruct;
    using UFunction = RC::Unreal::UFunction;
    using XProperty = RC::Unreal::FProperty;
    using UStruct = RC::Unreal::UStruct;
    using UEnum = Unreal::UEnum;
    using FObjectProperty = RC::Unreal::FObjectProperty;
    using FClassProperty = RC::Unreal::FClassProperty;
    using FStructProperty = RC::Unreal::FStructProperty;
    using FArrayProperty = RC::Unreal::FArrayProperty;
    using FMapProperty = RC::Unreal::FMapProperty;
    using FDelegateProperty = RC::Unreal::FDelegateProperty;
    using FMulticastInlineDelegateProperty = RC::Unreal::FMulticastInlineDelegateProperty;
    using FMulticastSparseDelegateProperty = RC::Unreal::FMulticastSparseDelegateProperty;

    CXXGenerator::CXXGenerator(const std::filesystem::path directory_to_generate_in) : m_directory_to_generate_in(directory_to_generate_in)
    {
        m_files.reserve(512);
    }

    auto CXXGenerator::create_all_files() -> void
    {
        Output::send(STR("Creating all files...\n"));
        for (auto&[comparison_index, generated_file] : m_files)
        {
            if (!generated_file.primary_file_has_no_contents)
            {
                generated_file.primary_file = File::open(generated_file.primary_file_name, File::OpenFor::Appending, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
                generate_header_start(generated_file, generated_file.package_name);
                generated_file.primary_file.write_string_to_file(generated_file.primary_file_contents);
                generate_header_end(generated_file);
                generated_file.primary_file.close();
            }

            if (!generated_file.secondary_file_has_no_contents)
            {
                generated_file.secondary_file = File::open(generated_file.secondary_file_name, File::OpenFor::Appending, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
                generated_file.secondary_file.write_string_to_file(generated_file.secondary_file_content);
                generated_file.secondary_file.close();
            }
        }
    }

    auto CXXGenerator::object_is_package(UObject* object) -> bool
    {
        return object->GetClassPrivate()->GetNamePrivate().Equals(Unreal::GPackageName);
    }

    auto CXXGenerator::generate_offset_comment(XProperty* property, File::StringType& line) -> File::StringType
    {
        if (UE4SSProgram::settings_manager.CXXHeaderGenerator.DumpOffsetsAndSizes)
        {
            return std::format(STR("{:85} // 0x{:04X} (size: 0x{:X})"), line, property->GetOffset_Internal(), property->GetSize());
        }
        else
        {
            return line;
        }
    }

    auto CXXGenerator::generate_header_start(GeneratedFile& generated_file, File::StringViewType file_name) -> void
    {
        generated_file.primary_file.write_string_to_file(std::format(STR("#ifndef UE4SS_SDK_{}_HPP\n#define UE4SS_SDK_{}_HPP\n\n"), file_name, file_name));

        if (!generated_file.secondary_file_has_no_contents)
        {
            generated_file.primary_file.write_string_to_file(std::format(STR("#include \"{}\"\n\n"), generated_file.secondary_file_name.filename().c_str()));
        }
    }

    auto CXXGenerator::generate_header_end(GeneratedFile& generated_file) -> void
    {
        generated_file.primary_file.write_string_to_file(std::format(STR("#endif\n")));
    }

    auto CXXGenerator::generate_tab(size_t num_tabs) -> File::StringType
    {
        File::StringType tab_storage{};
        for (int i = 0; i < num_tabs; ++i)
        {
            for (int space = 0; space < 4; ++space)
            {
                tab_storage += STR(" ");
            }
        }

        return tab_storage;
    }

    auto CXXGenerator::generate_function_declaration(ObjectInfo& owner, const FunctionInfo& function_info, GeneratedFile& generated_file, File::StringType& current_class_content, IsDelegateFunction is_delegate_function) -> void
    {
        std::optional<PropertyInfo> return_property_info = [&]() -> std::optional<PropertyInfo> {
            for (const auto& property_info : function_info.params)
            {
                if (property_info.property->HasAnyPropertyFlags(Unreal::CPF_ReturnParm))
                {
                    return property_info;
                }
            }

            return {};
        }();

        XProperty* return_property = [&]() {
            return return_property_info.has_value() ? return_property_info.value().property : nullptr;
        }();

        File::StringType function_name{function_info.function->GetName()};
        if (is_delegate_function == IsDelegateFunction::Yes)
        {
            // Remove the last 19 characters, which is always '__DelegateSignature' for delegates
            function_name.erase(function_name.size() - 19, 19);
        }

        File::StringType function_type_name{};
        if (return_property)
        {
            function_type_name = generate_property_cxx_name(return_property, true, function_info.function, EnableForwardDeclarations::Yes);
            if (return_property_info.value().should_forward_declare)
            {
                bool ignore_forward_declare{};
                if (return_property->IsA<FStructProperty>())
                {
                    // Can StructProperty even be forward declared ? I don't know if it's ever a pointer to a struct
                    auto* script_struct = static_cast<FStructProperty*>(return_property)->GetStruct();
                    if (m_classes_dumped.contains(script_struct))
                    {
                        auto& property_class_info = m_classes_dumped[script_struct];
                        if (property_class_info.first_encountered_at)
                        {
                            ignore_forward_declare = property_class_info.first_encountered_at->object == owner.object;
                        }
                    }
                }
                else if (return_property->IsA<FClassProperty>())
                {
                    // Can ClassProperty be forward declared ? Maybe ?
                    auto* meta_class = static_cast<FClassProperty*>(return_property)->GetMetaClass();
                    if (m_classes_dumped.contains(meta_class))
                    {
                        auto& property_class_info = m_classes_dumped[meta_class];
                        if (property_class_info.first_encountered_at)
                        {
                            ignore_forward_declare = property_class_info.first_encountered_at->object == owner.object;
                        }
                    }
                }
                else if (return_property->IsA<FObjectProperty>())
                {
                    auto* property_class = static_cast<FObjectProperty*>(return_property)->GetPropertyClass();
                    if (m_classes_dumped.contains(property_class))
                    {
                        auto& property_class_info = m_classes_dumped[property_class];
                        if (property_class_info.first_encountered_at)
                        {
                            ignore_forward_declare = property_class_info.first_encountered_at->object == owner.object;
                        }
                    }
                }

                if (!ignore_forward_declare)
                {
                    function_type_name.insert(0, STR("class "));
                }
            }
        }
        else
        {
            function_type_name = STR("void");
        }

        current_class_content.append(std::format(STR("{}{} {}("), generate_tab(), function_type_name, function_name));

        for (size_t i = 0; i < function_info.params.size(); ++i)
        //for (const auto& param_info : function_info.params)
        {
            const auto& param_info = function_info.params[i];
            if (!param_info.property->HasAnyPropertyFlags(Unreal::CPF_ReturnParm))
            {
                current_class_content.append(std::format(STR("{}{}{}{} {}"),
                                                                        param_info.property->HasAnyPropertyFlags(Unreal::CPF_ConstParm) ? STR("const ") : STR(""),
                                                                        param_info.should_forward_declare ? STR("class ") : STR(""),
                                                                        generate_property_cxx_name(param_info.property, true, function_info.function, EnableForwardDeclarations::Yes),
                                                                        param_info.property->HasAnyPropertyFlags(Unreal::CPF_ReferenceParm | Unreal::CPF_OutParm) ? STR("&") : STR(""),
                                                                        param_info.property->GetName()));

                if (i + 1 < function_info.params.size())
                {
                    auto* next_param = function_info.params[i + 1].property;
                    if (next_param && (!next_param->HasAnyPropertyFlags(Unreal::CPF_ReturnParm) || i + 2 < function_info.params.size()))
                    {
                        current_class_content.append(STR(", "));
                    }
                }
            }
        }

        current_class_content.append(STR(");"));
        // Commenting out this code because all network replicated functions are events
        // Therefore this is not an accurate way to check if a function is an event
        /*
        if ((function->get_function_flags() & Unreal::EFunctionFlags::FUNC_Event) != 0)
        {
            current_class_content.append(STR(" // EVENT"));
        }
        //*/
        current_class_content.append(STR("\n"));
    }

    auto CXXGenerator::generate_prefix(UStruct* obj) -> File::StringType
    {
        UClass* obj_class = obj->GetClassPrivate();
        if (obj_class->IsChildOf<UScriptStruct>())
        {
            return STR("struct");
        }
        else
        {
            return STR("class");
        }
    }

    auto CXXGenerator::generate_class_dependency(ObjectInfo& owner, UStruct* inherited_class, File::StringType& current_class_content) -> void
    {
        if (!inherited_class) { return; }

        if (!m_classes_dumped.contains(inherited_class))
        {
            GeneratedFile* package_file_for_inherited_class = generate_package_if_non_existent(inherited_class);
            if (package_file_for_inherited_class)
            {
                auto& inherited_object_info = m_classes_dumped.emplace(inherited_class, ObjectInfo{inherited_class, &owner}).first->second;
                File::StringType new_class_content{};
                generate_class(inherited_object_info, *package_file_for_inherited_class, new_class_content);
                if (!package_file_for_inherited_class->primary_file_has_no_contents)
                {
                    package_file_for_inherited_class->primary_file_contents.append(new_class_content);
                }
            }

            return;
        }
    }

    auto CXXGenerator::generate_class_dependency_from_property(ObjectInfo& owner, XProperty* property, File::StringType& current_class_content) -> bool
    {
        if (property->IsA<FStructProperty>())
        {
            generate_class_dependency(owner, static_cast<FStructProperty*>(property)->GetStruct(), current_class_content);
            return false;
        }
        else if (property->IsA<FClassProperty>())
        {
            //return generate_class_dependency(owner, static_cast<XClassProperty*>(property)->get_meta_class());
            return false;
        }
        else if (property->IsA<FObjectProperty>())
        {
            //return generate_class_dependency(owner, static_cast<XObjectProperty*>(property)->get_property_class());
            return true;
        }
        else if (property->IsA<FArrayProperty>())
        {
            //return generate_class_dependency_from_property(owner, static_cast<XArrayProperty*>(property)->get_inner());
            //if (static_cast<XArrayProperty*>(property)->get_inner()->is_child_of<XObjectProperty>())
            //{
            //    return true;
            //}
            XProperty* inner = static_cast<FArrayProperty*>(property)->GetInner();
            if (inner->IsA<FStructProperty>())
            {
                generate_class_dependency(owner, static_cast<FStructProperty*>(inner)->GetStruct(), current_class_content);
                return false;
            }
        }
        else if (property->IsA<FMapProperty>())
        {
            XProperty* key_property = static_cast<FMapProperty*>(property)->GetKeyProp();
            XProperty* value_property = static_cast<FMapProperty*>(property)->GetValueProp();

            if (key_property->IsA<FStructProperty>())
            {
                generate_class_dependency(owner, static_cast<FStructProperty*>(key_property)->GetStruct(), current_class_content);
            }

            if (value_property->IsA<FStructProperty>())
            {
                generate_class_dependency(owner, static_cast<FStructProperty*>(value_property)->GetStruct(), current_class_content);
            }

            return false;
        }

        return false;
    }

    auto CXXGenerator::make_function_info(ObjectInfo& owner, UFunction* function, File::StringType& current_class_content) -> FunctionInfo
    {
        FunctionInfo function_info{
            .function = function,
            .owner = owner,
        };

        function->ForEachProperty([&](XProperty* param) {
            if (!param->HasAnyPropertyFlags(Unreal::CPF_Parm | Unreal::CPF_ReturnParm)) { return LoopAction::Continue; }

            function_info.params.emplace_back(PropertyInfo{param, generate_class_dependency_from_property(owner, param, current_class_content)});
            return LoopAction::Continue;
        });

        return function_info;
    }

    auto CXXGenerator::generate_class(ObjectInfo object_info, GeneratedFile& generated_file, File::StringType& current_class_content) -> XProperty*
    {
        UStruct* native_class = static_cast<UStruct*>(object_info.object);
        generated_file.primary_file_has_no_contents = false;
        File::StringType content_buffer{};

        UStruct* inherits_from_class = native_class->GetSuperStruct();

        // Make sure that the base class is defined
        generate_class_dependency(object_info, inherits_from_class, current_class_content);

        // If any properties have dependencies, make sure that they are defined
        // This makes sure that we don't have member variables with undefined types (if the types are local, otherwise we need to include the file that the struct exists in)
        std::vector<PropertyInfo> properties_to_generate{};
        native_class->ForEachProperty([&](XProperty* property) {
            properties_to_generate.emplace_back(PropertyInfo{property, generate_class_dependency_from_property(object_info, property, current_class_content)});
            return LoopAction::Continue;
        });

        std::vector<FunctionInfo> functions_to_generate{};
        native_class->ForEachFunction([&](UFunction* function) {
            auto& function_info = functions_to_generate.emplace_back(FunctionInfo{function, object_info});

            function->ForEachProperty([&](XProperty* param) {
                if (!param->HasAnyPropertyFlags(Unreal::CPF_Parm | Unreal::CPF_ReturnParm)) { return LoopAction::Continue; }

                function_info.params.emplace_back(PropertyInfo{param, generate_class_dependency_from_property(object_info, param, current_class_content)});
                return LoopAction::Continue;
            });
            return LoopAction::Continue;
        });

        auto generate_class_name = [](UStruct* class_to_generate) {
            if (class_to_generate->GetClassPrivate()->IsChildOf<UScriptStruct>())
            {
                return get_native_struct_name(std::bit_cast<UScriptStruct*>(class_to_generate));
            }
            else if (class_to_generate->IsChildOf<UInterface>())
            {
                return get_native_class_name(static_cast<UClass*>(class_to_generate), true);
            }
            else
            {
                // Assume that it's a UClass
                return get_native_class_name(static_cast<UClass*>(class_to_generate));
            }
        };

        auto class_name = generate_class_name(native_class);

        if (inherits_from_class)
        {
            content_buffer.append(std::format(STR("{} {} : public {}\n{{\n"), generate_prefix(native_class), class_name, generate_class_name(inherits_from_class)));
        }
        else
        {
            content_buffer.append(std::format(STR("{} {}\n{{\n"), generate_prefix(native_class), class_name));
        }

        int32_t num_padding_elements{0};
        XProperty* last_property_in_this_class{nullptr};

        for (const auto& property_info : properties_to_generate)
        {
            XProperty* property = property_info.property;
            int32_t current_property_offset = property->GetOffset_Internal();
            int32_t current_property_size = property->GetSize();

            auto part_one = std::format(STR("{}{}{} {};"),
                                        generate_tab(),
                                        property_info.should_forward_declare ? STR("class ") : STR(""),
                                        generate_property_cxx_name(property, true, native_class, EnableForwardDeclarations::Yes),
                                        property->GetName());
            content_buffer.append(std::format(STR("{}\n"), generate_offset_comment(property, part_one)));

            FName property_type_name = property->GetClass().GetFName();
            if (property->IsA<FDelegateProperty>())
            {
                generate_function_declaration(object_info, make_function_info(object_info, static_cast<FDelegateProperty*>(property)->GetFunctionSignature(), current_class_content), generated_file, content_buffer, IsDelegateFunction::Yes);
            }
            else if (property->IsA<FMulticastInlineDelegateProperty>())
            {
                generate_function_declaration(object_info, make_function_info(object_info, static_cast<FMulticastInlineDelegateProperty*>(property)->GetFunctionSignature(), current_class_content), generated_file, content_buffer, IsDelegateFunction::Yes);
            }
            else if (property->IsA<FMulticastSparseDelegateProperty>())
            {
                generate_function_declaration(object_info, make_function_info(object_info, static_cast<FMulticastSparseDelegateProperty*>(property)->GetFunctionSignature(), current_class_content), generated_file, content_buffer, IsDelegateFunction::Yes);
            }

            if (UE4SSProgram::settings_manager.CXXHeaderGenerator.KeepMemoryLayout)
            {
                // Check if next member-var is reflected
                // If it's not, add padding so that everything in the struct is aligned properly
                auto* next_property = property->GetNextFieldAsProperty();
                if (next_property)
                {
                    int32_t current_property_end_location = current_property_offset + current_property_size;
                    auto test = current_property_end_location % current_property_size;

                    int32_t next_property_offset = next_property->GetOffset_Internal();

                    if (current_property_offset != next_property_offset &&
                        current_property_end_location != next_property_offset)
                    {
                        // Add padding
                        int32_t padding_property_offset = current_property_end_location;
                        int32_t padding_property_size = next_property_offset - padding_property_offset;

                        auto padding_part_one = std::format(STR("{}char {}[0x{:X}];"), generate_tab(), std::format(STR("padding_{}"), num_padding_elements++), padding_property_size);
                        content_buffer.append(std::format(STR("{:85} // 0x{:04X} (size: 0x{:X})\n"), padding_part_one, padding_property_offset, padding_property_size));
                    }
                }
            }

            last_property_in_this_class = property;
        }

        int32_t class_size = native_class->GetPropertiesSize();

        if (UE4SSProgram::settings_manager.CXXHeaderGenerator.KeepMemoryLayout)
        {
            if (last_property_in_this_class)
            {
                // TODO: Fix this, the padding is required for alignment when using the SDK for code injection
                // This commented-out code was here to provide the correct padding between classes so that everything would line up correctly
                // But it no longer works because it was dependent on the "generate_class_chain" function that no longer eixsts
                /*
                int32_t last_property_offset = last_property_in_this_class->get_offset_for_internal();
                if (first_property)
                {
                    int32_t first_property_offset = first_property->get_offset_for_internal();
                    if (last_property_offset != first_property_offset)
                    {
                        int32_t last_property_size = last_property_in_this_class->get_size();
                        int32_t padding_size = first_property_offset - (last_property_offset + last_property_size);
                        printf_s("class_size: %X\n", class_size);
                        printf_s("first_property->get_size(): %X\n", first_property->get_size());
                        printf_s("last_property_offset: %X\n", last_property_offset);
                        printf_s("first_property_offset: %X\n", first_property_offset);

                        auto padding_part_one = std::format(STR("{}char {}[0x{:X}];"), generate_tab(), std::format(STR("padding_{}"), num_padding_elements), padding_size);
                        out.append(std::format(STR("{:85} // 0x{:04X} (size: 0x{:X})\n"), padding_part_one, last_property_offset + last_property_size, padding_size));
                    }
                }
                //*/
            }
            else if (class_size > 0)
            {
                // No reflected member variables exist but there are non-reflected member variables
                // Add padding for non-reflected member variables, for alignment purposes
                auto padding_part_one = std::format(STR("{}char {}[0x{:X}];"), generate_tab(), std::format(STR("padding_{}"), num_padding_elements), class_size);
                content_buffer.append(std::format(STR("{:85} // 0x0000 (size: 0x{:X})\n"), padding_part_one, 0x0));
            }
}

        // Functions
        if (native_class->HasChildren())
        {
            content_buffer.append(STR("\n"));
            for (const auto& function_info : functions_to_generate)
            {
                generate_function_declaration(object_info, function_info, generated_file, content_buffer);
            }
        }

        if (UE4SSProgram::settings_manager.CXXHeaderGenerator.DumpOffsetsAndSizes)
        {
            content_buffer.append(std::format(STR("}}; // Size: 0x{:X}\n\n"), class_size));
        }
        else
        {
            content_buffer.append(STR("};\n\n"));
        }

        current_class_content.append(content_buffer);
        return native_class->GetFirstProperty();
    }

    auto CXXGenerator::generate_enum(UObject* native_object, GeneratedFile& generated_file) -> void
    {
        generated_file.secondary_file_has_no_contents = false;

        UEnum* uenum = static_cast<UEnum*>(native_object);
        auto& enum_names = uenum->GetEnumNames();

        const auto cpp_form = uenum->GetCppForm();
        if (cpp_form == UEnum::ECppForm::Regular)
        {
            generated_file.secondary_file_content.append(std::format(STR("enum {} {{\n"), get_native_enum_name(uenum, false)));
        }
        else if (cpp_form == UEnum::ECppForm::Namespaced)
        {
            generated_file.secondary_file_content.append(std::format(STR("namespace {} {{\n{}enum Type {{\n"), get_native_enum_name(uenum, false), generate_tab()));
        }
        else if (cpp_form == UEnum::ECppForm::EnumClass)
        {
            generated_file.secondary_file_content.append(std::format(STR("enum class {} {{\n"), get_native_enum_name(uenum, false)));
        }

        enum_names.ForEach([&](Unreal::FEnumNamePair* elem, size_t index) {
            auto enum_value_full_name = elem->Key.ToString();
            size_t colon_pos = enum_value_full_name.rfind(STR(":"));
            auto enum_value_name = colon_pos == enum_value_full_name.npos ? enum_value_full_name : enum_value_full_name.substr(colon_pos + 1);
            generated_file.secondary_file_content.append(std::format(STR("{}{}{} = {},\n"), generate_tab(), cpp_form == UEnum::ECppForm::Namespaced ? generate_tab() : STR(""), enum_value_name, elem->Value));

            return LoopAction::Continue;
        });

        generated_file.secondary_file_content.append(std::format(STR("{}}};"), cpp_form == UEnum::ECppForm::Namespaced ? generate_tab() : STR("")));

        if (cpp_form == UEnum::ECppForm::Namespaced)
        {
            generated_file.secondary_file_content.append(STR("\n}"));
        }

        generated_file.secondary_file_content.append(STR("\n\n"));
    }

    auto CXXGenerator::generate_package(UObject* package, File::StringType& out) -> void
    {
        UObjectGlobals::ForEachUObject([&](void* object, [[maybe_unused]]int32_t chunk_index, [[maybe_unused]]int32_t object_index) {
            return LoopAction::Continue;
        });
    }

    auto CXXGenerator::generate_package_if_non_existent(UObject* object) -> GeneratedFile*
    {
        UObject* package{};
        UObject* outer = object;
        if (!outer) { return nullptr; }

        do
        {
            if (object_is_package(outer))
            {
                package = outer;
                break;
            }

            outer = outer->GetOuterPrivate();
        } while (outer);

        if (!package)
        {
            throw std::runtime_error{"[generate_package_if_non_existent] Was unable to find UPackage for this object"};
        }

        FName package_fname = package->GetNamePrivate();
        if (m_files.contains(package_fname))
        {
            return &m_files.at(package_fname);
        }
        else
        {
            // Get rid of everything before the last slash + the last slash, leaving only the actual name
            File::StringType package_name = package->GetNamePrivate().ToString();
            package_name = package_name.substr(package_name.rfind(STR("/")) + 1);
            File::StringType package_name_all_lower = package_name;
            std::transform(package_name_all_lower.begin(), package_name_all_lower.end(), package_name_all_lower.begin(), [](File::CharType c) {
                return std::towlower(c);
            });

            if (m_file_names.contains(package_name_all_lower))
            {
                // File name collision
                auto& file_name = m_file_names[package_name_all_lower];
                package_name.append(std::format(STR("_DUPL_{}"), ++file_name.num_collisions));
                Output::send(STR("File name collision, renamed to '{}'\n"), package_name);
            }
            else
            {
                m_file_names.emplace(package_name_all_lower, FileName{});
            }

            // The '\\?\' at the beginning of the string unlocks path size restriction from MAX_PATH to 32k
            std::filesystem::path directory_to_generate_in = std::filesystem::path("\\\\?\\");
            directory_to_generate_in += (m_directory_to_generate_in);

            std::filesystem::path primary_file_path_and_name = directory_to_generate_in;
            primary_file_path_and_name.append(package_name);
            primary_file_path_and_name.replace_extension(".hpp");

            std::filesystem::path secondary_file_path_and_name = directory_to_generate_in;
            secondary_file_path_and_name.append(package_name + STR("_enums"));
            secondary_file_path_and_name.replace_extension(".hpp");

            GeneratedFile generated_file{
                .primary_file_name = primary_file_path_and_name,
                .secondary_file_name = secondary_file_path_and_name,
                .primary_file_contents = {},
                .secondary_file_content = {},
                .package_name = package_name,
                .primary_file = {},
                .secondary_file = {},
                .primary_file_has_no_contents = true,
                .secondary_file_has_no_contents = true,
            };

            auto& file_in_map = m_files.emplace(std::move(package_fname), std::move(generated_file)).first->second;
            return &file_in_map;
        }
    }

    auto CXXGenerator::cleanup_old_sdk() -> void
    {
        if (!std::filesystem::exists(m_directory_to_generate_in)) { return; }

        for (const auto& item : std::filesystem::directory_iterator(m_directory_to_generate_in))
        {
            if (item.is_directory()) { continue; }
            if (item.path().extension() != STR(".hpp")) { continue; }

            File::delete_file(item.path());
        }
    }

    auto CXXGenerator::generate() -> void
    {
        Output::send(STR("Cleaning up old SDK files...\n"));
        cleanup_old_sdk();
        Output::send(STR("Generating SDK...\n"));

        // 400k should be enough for most games, and it's highly unlikely to cause more than one reallocation even if the game is huge
        m_classes_dumped.reserve(400000);

        size_t num_objects_generated{};
        UObjectGlobals::ForEachUObject([&](void* untyped_object, [[maybe_unused]]int32_t chunk_index, [[maybe_unused]]int32_t object_index) {
            UObject* object = static_cast<UObject*>(untyped_object);
            UClass* object_class = object->GetClassPrivate();

            // Generate file for package if it doesn't already exist
            GeneratedFile* package_file = generate_package_if_non_existent(object);

            if (!package_file)
            {
                // Object should not be dumped
                return LoopAction::Continue;
            }
            else if (object->IsA<UEnum>())
            {
                generate_enum(object, *package_file);
                ++num_objects_generated;

                return LoopAction::Continue;
            }
            else if ((object_class->IsChildOf<UClass>() ||
                      object_class->IsChildOf<UScriptStruct>()) &&
                     !m_classes_dumped.contains(object))
            {
                // Generate a class for this object
                auto& object_info = m_classes_dumped.emplace(object, ObjectInfo{object}).first->second;
                File::StringType class_content{};
                generate_class(object_info, *package_file, class_content);
                if (!package_file->primary_file_has_no_contents)
                {
                    package_file->primary_file_contents.append(class_content);
                }
                ++num_objects_generated;

                return LoopAction::Continue;
            }
            else
            {
                // Object should not be dumped
                return LoopAction::Continue;
            }
        });

        create_all_files();
    }
}

```

`src/SDKGenerator/JSONDumper.cpp`:

```cpp
#include <SDKGenerator/JSONDumper.hpp>
#include <SDKGenerator/Common.hpp>
#include <Timer/ScopedTimer.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <UE4SSProgram.hpp>
#include <JSON/JSON.hpp>
#pragma warning(disable: 4005)
#include <Unreal/UClass.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/UAssetRegistry.hpp>
#pragma warning(default: 4005)

namespace RC::UEGenerator::JSONDumper
{
    using namespace ::RC::Unreal;

    auto static is_valid_class_to_dump(File::StringViewType class_name, UObject* object) -> bool
    {
        static bool is_below_425 = Unreal::Version::IsBelow(4, 25);
        if (is_below_425 && Unreal::TypeChecker::is_property(object))
        {
            // Ignore properties in GUObjectArray
            return false;
        }

        UClass* object_class = object->GetClassPrivate();
        if (!object_class->IsChildOf<Unreal::UBlueprintGeneratedClass>() ||
            object_class->IsChildOf<Unreal::UAnimBlueprintGeneratedClass>())
        {
            return false;
        }

        UClass* object_as_class = static_cast<UClass*>(object);
        if (object_as_class->HasAnyClassFlags(EClassFlags::CLASS_Native))
        {
            return false;
        }

        if (object_as_class->HasAnyFlags(static_cast<EObjectFlags>(EObjectFlags::RF_DefaultSubObject | EObjectFlags::RF_ArchetypeObject)))
        {
            return false;
        }

        if (class_name.find(STR("BP_")) != class_name.npos) { return true; }
        if (class_name.find(STR("ENE_")) != class_name.npos) { return true; }
        if (class_name.find(STR("BPL_")) != class_name.npos) { return true; }
        if (class_name.find(STR("OBJ_")) != class_name.npos) { return true; }
        if (class_name.find(STR("LIB_")) != class_name.npos) { return true; }
        if (class_name.find(STR("PRJ_")) != class_name.npos) { return true; }
        if (class_name.find(STR("WPN_")) != class_name.npos) { return true; }

        return false;
    }

    auto static should_skip_property(FProperty* property) -> bool
    {
        static FName uber_graph_frame_name = FName(STR("UberGraphFrame"));
        static FName default_scene_root_name = FName(STR("DefaultSceneRoot"));

        if (property->HasAnyPropertyFlags(Unreal::EPropertyFlags::CPF_ReturnParm))
        {
            return false;
        }

        FName property_fname = property->GetFName();
        if (property_fname.Equals(uber_graph_frame_name)) { return true; }
        if (property_fname.Equals(default_scene_root_name)) { return true; }

        auto property_name = property_fname.ToString();
        if (property_name.find(STR("CallFunc")) != property_name.npos) { return true; }

        return false;
    }

    auto static should_skip_general_function(UFunction* function) -> bool
    {
        static FName receive_name = FName(STR("Receive"));
        static FName receive_typo_name = FName(STR("Recieve"));
        static FName receive_begin_play_name = FName(STR("ReceiveBeginPlay"));
        static FName receive_destroyed_name = FName(STR("ReceiveDestroyedPlay"));
        static FName receive_tick_name = FName(STR("ReceiveTick"));
        static FName user_construction_script_name = FName(STR("UserConstructionScript"));

        FName function_fname = function->GetNamePrivate();
        if (function_fname.Equals(receive_name)) { return true; }
        if (function_fname.Equals(receive_typo_name)) { return true; }
        if (function_fname.Equals(receive_begin_play_name)) { return true; }
        if (function_fname.Equals(receive_destroyed_name)) { return true; }
        if (function_fname.Equals(receive_tick_name)) { return true; }
        if (function_fname.Equals(user_construction_script_name)) { return true; }

        auto function_name = function_fname.ToString();
        if (function_name.find(STR("Ubergraph")) != function_name.npos) { return true; }
        if (function_name.find(STR("OnTick_")) != function_name.npos) { return true; }
        if (function_name.find(STR("OnLoaded")) != function_name.npos) { return true; }

        return false;
    }

    auto static is_event(UFunction* function) -> bool
    {
        auto function_name = function->GetName();
        return function_name.starts_with(STR("On")) && !function_name.starts_with(STR("OnRep_"));
    }

    auto static should_skip_function(UFunction* function) -> bool
    {
        if ((function->GetFunctionFlags() & EFunctionFlags::FUNC_Delegate) != 0) { return true; }
        // Can't use FUNC_Event or FUNC_BlueprintEvent because it seems that everything has these flag
        //if ((function->get_function_flags() & EFunctionFlags::FUNC_Event) != 0) { return true; }
        //if ((function->get_function_flags() & EFunctionFlags::FUNC_BlueprintEvent) != 0) { return true; }
        if (is_event(function)) { return true; }

        return should_skip_general_function(function);
    }

    auto static should_skip_event(File::StringViewType event_name) -> bool
    {
        if (event_name.find(STR("BndEvt")) != event_name.npos) { return true; }
        return false;
    }

    auto dump_to_json(File::StringViewType file_name) -> void
    {
        Output::send(STR("Loading all assets...\n"));
        UAssetRegistry::LoadAllAssets();

        Output::send(STR("Dumping to JSON file\n"));
        auto json = JSON::Array{};

        // For now this is for 4.25+ only
        bool is_below_425 = Unreal::Version::IsBelow(4, 25);
        UObjectGlobals::ForEachUObject([&](void* raw_object, int32_t chunk_index, int32_t object_index) {
            if (!raw_object) { return LoopAction::Continue; }
            UObject* object = static_cast<UObject*>(raw_object);

            auto object_name = object->GetName();
            if (!is_valid_class_to_dump(object_name, object)) { return LoopAction::Continue; }
            UClass* object_as_class = static_cast<UClass*>(object);

            object_name.erase(object_name.size() - 2, 2);

            auto& bp_class = json.new_object();
            bp_class.new_string(STR("bp_class"), object_name);
            if (auto* super_struct = object_as_class->GetSuperStruct(); super_struct)
            {
                bp_class.new_string(STR("inherits"), super_struct->GetName());
            }
            else
            {
                bp_class.new_null(STR("inherits"));
            }

            auto& events = bp_class.new_array(STR("events"));
            object_as_class->ForEachFunction([&](UFunction* event_function) {
                if (should_skip_general_function(event_function)) { return LoopAction::Continue; }
                if (!is_event(event_function)) { return LoopAction::Continue; }

                auto event_name = event_function->GetName();
                if (should_skip_event(event_name)) { return LoopAction::Continue; }

                auto& bp_events = events.new_object();
                bp_events.new_string(STR("name"), event_name);

                auto& bp_event_args = bp_events.new_array(STR("args"));
                event_function->ForEachProperty([&](FProperty* param) {
                    if (should_skip_property(param)) { return LoopAction::Continue; }

                    auto& bp_event_arg = bp_event_args.new_object();
                    bp_event_arg.new_string(STR("name"), param->GetName());
                    bp_event_arg.new_string(STR("type"), generate_property_cxx_name(param, true, event_function));
                    bool is_out = param->HasAnyPropertyFlags(EPropertyFlags::CPF_OutParm) && !param->HasAnyPropertyFlags(EPropertyFlags::CPF_ConstParm);
                    bp_event_arg.new_bool(STR("is_out"), is_out);
                    bp_event_arg.new_bool(STR("is_return"), param->HasAnyPropertyFlags(Unreal::EPropertyFlags::CPF_ReturnParm));
                    return LoopAction::Continue;
                });

                return LoopAction::Continue;
            });

            auto& functions = bp_class.new_array(STR("functions"));
            object_as_class->ForEachFunction([&](UFunction* function) {
                if (should_skip_function(function)) { return LoopAction::Continue; }

                auto& bp_function = functions.new_object();
                bp_function.new_string(STR("name"), function->GetName());

                auto& bp_function_args = bp_function.new_array(STR("args"));
                function->ForEachProperty([&](FProperty* param) {
                    if (should_skip_property(param)) { return LoopAction::Continue; }

                    auto& bp_function_arg = bp_function_args.new_object();
                    bp_function_arg.new_string(STR("name"), param->GetName());
                    bp_function_arg.new_string(STR("type"), generate_property_cxx_name(param, true, function));
                    bool is_out = param->HasAnyPropertyFlags(EPropertyFlags::CPF_OutParm) && !param->HasAnyPropertyFlags(EPropertyFlags::CPF_ConstParm);
                    bp_function_arg.new_bool(STR("is_out"), is_out);
                    bp_function_arg.new_bool(STR("is_return"), param->HasAnyPropertyFlags(Unreal::EPropertyFlags::CPF_ReturnParm));
                    return LoopAction::Continue;
                });

                return LoopAction::Continue;
            });

            auto& properties = bp_class.new_array(STR("properties"));
            object_as_class->ForEachProperty([&](FProperty* property) {
                if (should_skip_property(property)) { return LoopAction::Continue; }

                auto& bp_property = properties.new_object();
                bp_property.new_string(STR("name"), property->GetName());
                bp_property.new_string(STR("type"), generate_property_cxx_name(property, true, object_as_class));

                return LoopAction::Continue;
            });

            auto& delegates = bp_class.new_array(STR("delegates"));
            object_as_class->ForEachFunction([&](UFunction* delegate_function) {
                if (should_skip_general_function(delegate_function)) { return LoopAction::Continue; }
                if ((delegate_function->GetFunctionFlags() & EFunctionFlags::FUNC_Delegate) == 0) { return LoopAction::Continue; }

                auto& bp_delegate = delegates.new_object();
                bp_delegate.new_string(STR("name"), delegate_function->GetName());

                auto& bp_delegate_args = bp_delegate.new_array(STR("args"));
                delegate_function->ForEachProperty([&](FProperty* param) {
                    if (should_skip_property(param)) { return LoopAction::Continue; }

                    auto& bp_delegate_arg = bp_delegate_args.new_object();
                    bp_delegate_arg.new_string(STR("name"), param->GetName());
                    bp_delegate_arg.new_string(STR("type"), generate_property_cxx_name(param, true, delegate_function));
                    bool is_out = param->HasAnyPropertyFlags(EPropertyFlags::CPF_OutParm) && !param->HasAnyPropertyFlags(EPropertyFlags::CPF_ConstParm);
                    bp_delegate_arg.new_bool(STR("is_out"), is_out);
                    bp_delegate_arg.new_bool(STR("is_return"), param->HasAnyPropertyFlags(Unreal::EPropertyFlags::CPF_ReturnParm));
                    return LoopAction::Continue;
                });

                return LoopAction::Continue;
            });

            return LoopAction::Continue;
        });

        auto json_file = File::open(file_name, File::OpenFor::Writing, File::OverwriteExistingFile::Yes, File::CreateIfNonExistent::Yes);
        int32_t indent_level{};
        json_file.write_string_to_file(json.serialize(JSON::ShouldFormat::Yes, &indent_level));
        json_file.close();

        Output::send(STR("Unloading all forcefully loaded assets\n"));
        UAssetRegistry::FreeAllForcefullyLoadedAssets();
    }
}

```

`src/SDKGenerator/UEHeaderGenerator.cpp`:

```cpp
#define NOMINMAX
#include <Windows.h>
#ifdef TEXT
#undef TEXT
#endif

#include <set>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <format>
#include <fstream>

#include <SDKGenerator/UEHeaderGenerator.hpp>
#pragma warning(disable: 4005)
#include <DynamicOutput/DynamicOutput.hpp>
#include <UE4SSProgram.hpp>
#include <Unreal/FScriptArray.hpp>
#include <Unreal/FString.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/UEnum.hpp>
#include <Unreal/UInterface.hpp>
#include <Unreal/UActorComponent.hpp>
#include <Unreal/UnrealFlags.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/FText.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/UPackage.hpp>
#include <Unreal/Property/NumericPropertyTypes.hpp>
#include <Unreal/Property/FBoolProperty.hpp>
#include <Unreal/Property/FObjectProperty.hpp>
#include <Unreal/Property/FWeakObjectProperty.hpp>
#include <Unreal/Property/FLazyObjectProperty.hpp>
#include <Unreal/Property/FSoftObjectProperty.hpp>
#include <Unreal/Property/FSoftClassProperty.hpp>
#include <Unreal/Property/FClassProperty.hpp>
#include <Unreal/Property/FStructProperty.hpp>
#include <Unreal/Property/FDelegateProperty.hpp>
#include <Unreal/Property/FMulticastInlineDelegateProperty.hpp>
#include <Unreal/Property/FMulticastSparseDelegateProperty.hpp>
#include <Unreal/Property/FEnumProperty.hpp>
#include <Unreal/Property/FArrayProperty.hpp>
#include <Unreal/Property/FMapProperty.hpp>
#include <Unreal/Property/FInterfaceProperty.hpp>
#include <Unreal/Property/FFieldPathProperty.hpp>
#include <Unreal/Property/FSetProperty.hpp>
#pragma warning(default: 4005)

namespace RC::UEGenerator
{
    using namespace RC::Unreal;

    std::unordered_map<File::StringType, UniqueName> UEHeaderGenerator::m_used_file_names{};
    std::unordered_map<UObject*, int32_t> UEHeaderGenerator::m_dependency_object_to_unique_id{};

    auto static is_subtype_struct_valid(UScriptStruct* subtype) -> bool
    {
        static FName float_interval_name = FName(STR("FloatInterval"), FNAME_Add);
        static FName spline_curves_name = FName(STR("SplineCurves"), FNAME_Add);
        static FName int32_interval_name = FName(STR("Int32Interval"), FNAME_Add);
        static FName bone_reference_name = FName(STR("BoneReference"), FNAME_Add);
        static FName overlap_result_name = FName(STR("OverlapResult"), FNAME_Add);
        static FName rich_curve_name = FName(STR("RichCurve"), FNAME_Add);

        auto subtype_name = subtype->GetNamePrivate();
        if (subtype_name == float_interval_name ||
            subtype_name == spline_curves_name ||
            subtype_name == int32_interval_name ||
            subtype_name == bone_reference_name ||
            subtype_name == overlap_result_name||
            subtype_name == rich_curve_name)
        {
            return false;
        }
        else
        {
            return true;
        }
    };

    auto static is_subtype_valid(FProperty* subtype) -> bool
    {
        if ((subtype->IsA<FNumericProperty>() && !subtype->IsA<FIntProperty>() && !subtype->IsA<FFloatProperty>()) ||
            subtype->IsA<FWeakObjectProperty>())
        {
            return false;
        }
        else if (auto* as_array = CastField<FArrayProperty>(subtype); as_array)
        {
            return is_subtype_valid(as_array->GetInner());
        }
        else if (auto* as_map = CastField<FMapProperty>(subtype); as_map)
        {
            return is_subtype_valid(as_map->GetKeyProp()) && is_subtype_valid(as_map->GetValueProp());
        }
        else if (auto* as_struct = CastField<FStructProperty>(subtype); as_struct)
        {
            return is_subtype_struct_valid(as_struct->GetStruct());
        }
        else if (auto* as_enum = CastField<FEnumProperty>(subtype); as_enum)
        {
            return as_enum->GetUnderlyingProperty()->IsA<FByteProperty>();
        }
        else
        {
            return true;
        }
    };

    auto string_to_uppercase(std::wstring s) -> std::wstring
    {
        std::transform(s.begin(), s.end(), s.begin(), [](wchar_t c) {
            return towupper(c);
        });
        return s;
    }

    class FlagFormatHelper
    {
        std::set<std::wstring> m_switches;
        std::map<std::wstring, std::set<std::wstring>> m_parameters;
        std::shared_ptr<FlagFormatHelper> m_meta_helper;

        FlagFormatHelper(bool is_root_helper)
        {
            if (is_root_helper)
            {
                m_meta_helper = std::shared_ptr<FlagFormatHelper>(new FlagFormatHelper(false));
            }
        }
    public:
        FlagFormatHelper() : FlagFormatHelper(true)
        {
        }

        auto add_switch(const std::wstring& switch_name) -> void
        {
            m_switches.insert(switch_name);
        }

        auto add_parameter(const std::wstring& parameter_name, const std::wstring& parameter_value) -> void
        {
            if (parameter_name == STR("meta"))
            {
                throw std::invalid_argument("Use get_meta() to add metadata to the flag declaration");
            }

            auto map_iterator = m_parameters.find(parameter_name);
            if (map_iterator != m_parameters.end())
            {
                map_iterator->second.insert(parameter_name);
            }
            else
            {
                m_parameters.insert({parameter_name, {parameter_value}});
            }
        }

        auto get_meta() const -> FlagFormatHelper*
        {
            return m_meta_helper.get();
        }

        auto build_flag_string() const -> std::wstring
        {
            std::wstring resulting_string;

            for (const std::wstring& switch_name : m_switches)
            {
                resulting_string.append(switch_name);
                resulting_string.append(STR(", "));
            }

            for (const std::pair<std::wstring, std::set<std::wstring>>& parameter_pair : m_parameters)
            {
                resulting_string.append(parameter_pair.first);
                resulting_string.append(STR("="));
                const std::set<std::wstring>& parameter_values = parameter_pair.second;

                if (parameter_values.size() != 1)
                {
                    resulting_string.append(STR("("));

                    for (const std::wstring& parameter_value : parameter_values)
                    {
                        resulting_string.append(parameter_value);
                        resulting_string.append(STR(", "));
                    }

                    if (parameter_values.size() != 0)
                    {
                        resulting_string.erase(resulting_string.size() - 1, 1);
                    }
                    resulting_string.append(STR(")"));
                }
                else
                {
                    resulting_string.append(*parameter_values.begin());
                }
                resulting_string.append(STR(", "));
            }

            if (m_meta_helper)
            {
                const std::wstring meta_flag_string = m_meta_helper->build_flag_string();
                if (!meta_flag_string.empty())
                {
                    resulting_string.append(STR("meta=("));
                    resulting_string.append(meta_flag_string);
                    resulting_string.append(STR(")"));
                    resulting_string.append(STR(", "));
                }
            }

            if (!resulting_string.empty())
            {
                resulting_string.erase(resulting_string.size() - 2, 2);
            }
            return resulting_string;
        }
    };

    auto UEHeaderGenerator::generate_module_build_file(const std::wstring& module_name) -> void
    {
        const FFilePath module_file_path = m_root_directory / module_name / fmt::format(STR("{}.Build.cs"), module_name);
        GeneratedFile module_build_file = GeneratedFile(module_file_path);

        module_build_file.append_line(STR("using UnrealBuildTool;"));
        module_build_file.append_line(STR(""));

        module_build_file.append_line(fmt::format(STR("public class {} : ModuleRules {{"), module_name));
        module_build_file.begin_indent_level();

        module_build_file.append_line(fmt::format(STR("public {}(ReadOnlyTargetRules Target) : base(Target) {{"), module_name));
        module_build_file.begin_indent_level();

        module_build_file.append_line(STR("PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;"));

        if (Version::IsAtLeast(4, 24))
        {
            module_build_file.append_line(STR("bLegacyPublicIncludePaths = false;"));
            module_build_file.append_line(STR("ShadowVariableWarningLevel = WarningLevel.Warning;"));
        }

        module_build_file.append_line(STR(""));
        module_build_file.append_line(STR("PublicDependencyModuleNames.AddRange(new string[] {"));
        module_build_file.begin_indent_level();

        std::set<std::wstring> all_module_dependencies = this->m_forced_module_dependencies;
        add_module_and_sub_module_dependencies(all_module_dependencies, module_name, false);

        for (const std::wstring& other_module_name : all_module_dependencies)
        {
            module_build_file.append_line(fmt::format(STR("\"{}\","), other_module_name));
        }

        module_build_file.end_ident_level();
        module_build_file.append_line(STR("});"));

        module_build_file.end_ident_level();
        module_build_file.append_line(STR("}"));

        module_build_file.end_ident_level();
        module_build_file.append_line(STR("}"));

        module_build_file.serialize_file_content_to_disk();
    }

    auto UEHeaderGenerator::generate_module_implementation_file(const std::wstring& module_name) -> void
    {
        const FFilePath module_file_path = m_root_directory / module_name / STR("Private") / fmt::format(STR("{}Module.cpp"), module_name);
        GeneratedFile module_impl_file = GeneratedFile(module_file_path);

        module_impl_file.append_line(STR("#include \"Modules/ModuleManager.h\""));
        module_impl_file.append_line(STR(""));
        if (module_name != m_primary_module_name) {
            module_impl_file.append_line(fmt::format(STR("IMPLEMENT_MODULE(FDefaultGameModuleImpl, {});"), module_name));
        } else {
            module_impl_file.append_line(fmt::format(STR("IMPLEMENT_PRIMARY_GAME_MODULE(FDefaultGameModuleImpl, {}, {});"), module_name, module_name));
        }

        module_impl_file.serialize_file_content_to_disk();
    }

    auto UEHeaderGenerator::generate_interface_definition(UClass* uclass, GeneratedSourceFile& header_data) -> void
    {
        const std::wstring interface_class_native_name = get_native_class_name(uclass);
        const std::wstring interface_flags_string = generate_interface_flags(uclass);

        std::wstring maybe_api_name;
        if ((uclass->GetClassFlags() & CLASS_RequiredAPI) != 0)
        {
            maybe_api_name.append(convert_module_name_to_api_name(header_data.get_header_module_name()));
            maybe_api_name.append(STR(" "));
        }

        UClass* super_class = uclass->GetSuperClass();
        header_data.add_dependency_object(super_class, DependencyLevel::Include);

        std::wstring parent_interface_class_name = get_native_class_name(super_class);

        //Generate interface UCLASS declaration
        header_data.append_line(fmt::format(STR("UINTERFACE({})"), interface_flags_string));
        header_data.append_line(fmt::format(STR("class {}{} : public {} {{"), maybe_api_name, interface_class_native_name, parent_interface_class_name));

        header_data.begin_indent_level();
        header_data.append_line(STR("GENERATED_BODY()"));
        header_data.end_ident_level();

        header_data.append_line(STR("};"));
        header_data.append_line(STR(""));

        //Generate interface real class declaration
        const std::wstring interface_native_name = get_native_class_name(uclass, true);
        const std::wstring parent_interface_name = get_native_class_name(super_class, true);

        header_data.append_line(fmt::format(STR("class {}{} : public {} {{"), maybe_api_name, interface_native_name, parent_interface_name));
        header_data.begin_indent_level();

        header_data.append_line(STR("GENERATED_BODY()"));

        AccessModifier current_access_modifier = AccessModifier::None;
        append_access_modifier(header_data, AccessModifier::Public, current_access_modifier);

        //Generate delegate type declarations for the current class
        int32_t NumDelegatesGenerated = 0;
        uclass->ForEachFunction([&](UFunction* function) {
            if (is_delegate_signature_function(function))
            {
                generate_delegate_type_declaration(function, header_data);
                NumDelegatesGenerated++;
            }
            return RC::LoopAction::Continue;
        });
        if (NumDelegatesGenerated) {
            header_data.append_line(STR(""));
        }

        //Generate interface functions
        uclass->ForEachFunction([&](UFunction* function) {
            if (!is_delegate_signature_function(function))
            {
                append_access_modifier(header_data, get_function_access_modifier(function), current_access_modifier);
                generate_function(uclass, function, header_data, true, CaseInsensitiveSet{});
            }
            return RC::LoopAction::Continue;
        });

        header_data.end_ident_level();
        header_data.append_line(STR("};"));
    }

    auto UEHeaderGenerator::generate_object_definition(UClass* uclass, GeneratedSourceFile& header_data) -> void
    {
        const std::wstring class_native_name = get_native_class_name(uclass);
        const std::wstring class_flags_string = generate_class_flags(uclass);

        std::wstring maybe_api_name;
        if ((uclass->GetClassFlags() & CLASS_RequiredAPI) != 0)
        {
            maybe_api_name.append(convert_module_name_to_api_name(header_data.get_header_module_name()));
            maybe_api_name.append(STR(" "));
        }

        UClass* super_class = uclass->GetSuperClass();
        std::wstring parent_class_name;
        if (super_class)
        {
            parent_class_name = get_native_class_name(super_class);
        }
        else
        {
            parent_class_name = STR("UObjectBaseUtility");
        }

        if (super_class)
        {
            header_data.add_dependency_object(super_class, DependencyLevel::Include);
        }

        std::wstring interface_list_string;
        auto implemented_interfaces = uclass->GetInterfaces();

        implemented_interfaces.ForEach([&](const RC::Unreal::FImplementedInterface* uinterface) {
            header_data.add_dependency_object(uinterface->Class, DependencyLevel::Include);
            const std::wstring interface_name = get_native_class_name(uinterface->Class, true);

            interface_list_string.append(STR(", public "));
            interface_list_string.append(interface_name);
            return RC::LoopAction::Continue;
        });

        header_data.append_line(fmt::format(STR("UCLASS({})"), class_flags_string));
        header_data.append_line(fmt::format(STR("class {}{} : public {}{} {{"), maybe_api_name, class_native_name, parent_class_name, interface_list_string));
        header_data.begin_indent_level();

        header_data.append_line(STR("GENERATED_BODY()"));

        AccessModifier current_access_modifier = AccessModifier::None;
        append_access_modifier(header_data, AccessModifier::Public, current_access_modifier);

        CaseInsensitiveSet blacklisted_property_names = collect_blacklisted_property_names(uclass);
        bool encountered_replicated_properties = false;

        //Generate delegate type declarations for the current class
        int32_t NumDelegatesGenerated = 0;
        uclass->ForEachFunction([&](UFunction* function) {
            if (is_delegate_signature_function(function))
            {
                generate_delegate_type_declaration(function, header_data);
                NumDelegatesGenerated++;
            }
            return RC::LoopAction::Continue;
        });
        if (NumDelegatesGenerated) {
            header_data.append_line(STR(""));
        }

        //Generate properties
        uclass->ForEachProperty([&](FProperty* property) {
            encountered_replicated_properties |= (property->GetPropertyFlags() & CPF_Net) != 0;
            append_access_modifier(header_data, get_property_access_modifier(property), current_access_modifier);
            generate_property(uclass, property, header_data);
            return RC::LoopAction::Continue;
        });

        //Make sure constructor and replicated properties methods are public
        append_access_modifier(header_data, AccessModifier::Public, current_access_modifier);

        //Generate constructor
        header_data.append_line(fmt::format(STR("{}();"), class_native_name));

        //Generate GetLifetimeReplicatedProps override if we have encountered replicated properties
        if (encountered_replicated_properties)
        {
            header_data.append_line(STR("virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;"));
            header_data.append_line(STR(""));
        }

        //Generate functions
        std::unordered_set<FName> implemented_functions;
        uclass->ForEachFunction([&](UFunction* function) {
            if (!is_delegate_signature_function(function))
            {
                append_access_modifier(header_data, get_function_access_modifier(function), current_access_modifier);
                generate_function(uclass, function, header_data, false, blacklisted_property_names);
                implemented_functions.emplace(function->GetNamePrivate());
            }
            return RC::LoopAction::Continue;
        });

        // Generate overrides for all inherited virtual functions
        if (implemented_interfaces.Num() > 0)
        {
            header_data.append_line(STR(""));
            header_data.append_line(STR("// Fix for true pure virtual functions not being implemented"));
        }
        implemented_interfaces.ForEach([&](const RC::Unreal::FImplementedInterface* uinterface) {
            uinterface->Class->ForEachFunction([&](UFunction* interface_function) {
                bool should_skip = (interface_function->GetFunctionFlags() & FUNC_BlueprintEvent);

                if (!implemented_functions.contains(interface_function->GetNamePrivate()) && !should_skip)
                {
                    append_access_modifier(header_data, get_function_access_modifier(interface_function), current_access_modifier);
                    generate_function(uclass, interface_function, header_data, false, blacklisted_property_names, true);
                }
                return LoopAction::Continue;
            });

            return LoopAction::Continue;
        });

        header_data.end_ident_level();
        header_data.append_line(STR("};"));
    }

    auto UEHeaderGenerator::generate_struct_definition(UScriptStruct* script_struct, GeneratedSourceFile& header_data) -> void
    {
        const std::wstring struct_native_name = get_native_struct_name(script_struct);
        const std::wstring struct_flags_string = generate_struct_flags(script_struct);

        std::wstring api_macro_name = convert_module_name_to_api_name(header_data.get_header_module_name());
        api_macro_name.append(STR(" "));
        bool is_struct_exported = (script_struct->GetStructFlags() & STRUCT_RequiredAPI) != 0;

        UScriptStruct* super_struct = script_struct->GetSuperScriptStruct();
        std::wstring parent_struct_declaration;
        if (super_struct)
        {
            header_data.add_dependency_object(super_struct, DependencyLevel::Include);

            const std::wstring super_struct_native_name = get_native_struct_name(super_struct);
            parent_struct_declaration.append(fmt::format(STR(" : public {}"), super_struct_native_name));
        }

        header_data.append_line(fmt::format(STR("USTRUCT({})"), struct_flags_string));
        header_data.append_line(fmt::format(STR("struct {}{}{} {{"), is_struct_exported ? api_macro_name : STR(""), struct_native_name, parent_struct_declaration));
        header_data.begin_indent_level();

        header_data.append_line(STR("GENERATED_BODY()"));

        AccessModifier current_access_modifier = AccessModifier::None;
        append_access_modifier(header_data, AccessModifier::Public, current_access_modifier);

        //Generate struct properties
        script_struct->ForEachProperty([&](FProperty* property) {
            append_access_modifier(header_data, get_property_access_modifier(property), current_access_modifier);
            generate_property(script_struct, property, header_data);
            return RC::LoopAction::Continue;
        });

        //Generate constructor and make sure it's public
        append_access_modifier(header_data, AccessModifier::Public, current_access_modifier);
        header_data.append_line(fmt::format(STR("{}{}();"), !is_struct_exported ? api_macro_name : STR(""), struct_native_name));

        header_data.end_ident_level();
        header_data.append_line(STR("};"));
    }

    auto UEHeaderGenerator::generate_enum_definition(UEnum* uenum, GeneratedSourceFile& header_data) -> void
    {
        const std::wstring native_enum_name = get_native_enum_name(uenum, false);
        const std::wstring enum_flags_string = generate_enum_flags(uenum);

        UEnum::ECppForm cpp_form = uenum->GetCppForm();

        header_data.append_line(fmt::format(STR("UENUM({})"), enum_flags_string));

        if (cpp_form == UEnum::ECppForm::Namespaced)
        {
            header_data.append_line(fmt::format(STR("namespace {} {{"), native_enum_name));
            header_data.begin_indent_level();
            header_data.append_line(STR("enum Type {"));
        }
        else if (cpp_form == UEnum::ECppForm::Regular)
        {
            header_data.append_line(fmt::format(STR("enum {} {{"), native_enum_name));
        }
        else if (cpp_form == UEnum::ECppForm::EnumClass)
        {
            const auto underlying_type = m_underlying_enum_types.find(native_enum_name);

            if (underlying_type == m_underlying_enum_types.end())
            {
                if (UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeEnumClassesBlueprintType)
                {
                    header_data.append_line(fmt::format(STR("enum class {} : uint8 {{"), native_enum_name));
                }
                else
                {
                    //Enum has never been used in any native classes or structures, go with implicit type
                    header_data.append_line(fmt::format(STR("enum class {} {{"), native_enum_name));
                }
            }
            else
            {
                std::wstring underlying_type_string = underlying_type->second;

                //If this enum is blueprint visible, it should totally be uint8 and nothing else, no matter what the underlying property says
                if (m_blueprint_visible_enums.contains(native_enum_name))
                {
                    underlying_type_string = STR("uint8");
                }
                header_data.append_line(fmt::format(STR("enum class {} : {} {{"), native_enum_name, underlying_type_string));
            }
        }

        header_data.begin_indent_level();

        int64_t expected_next_enum_value = 0;
        uenum->ForEachName([&](Unreal::FName Name, int64_t Value) {
            std::wstring result_enumeration_line = sanitize_enumeration_name(Name.ToString());
            bool enum_constant_has_explicit_number = false;

            if (Value != expected_next_enum_value)
            {
                const std::wstring MinusSign = Value < 0 ? STR("-") : STR("");
                result_enumeration_line.append(fmt::format(STR(" = {}0x{:X}"), MinusSign, std::abs(Value)));
                enum_constant_has_explicit_number = true;
            }
            expected_next_enum_value = Value + 1;

            if (result_enumeration_line.ends_with(STR("_MAX")))
            {
                const std::wstring expected_full_constant_name = fmt::format(STR("{}_MAX"), uenum->GetName());

                //Skip enum _MAX constant if it has the following number and matching name, which means it has been autogenerated
                if (result_enumeration_line == expected_full_constant_name && !enum_constant_has_explicit_number)
                {
                    return RC::LoopAction::Continue;
                }
                //Otherwise, just make sure it's hidden and not visible to the end user
                result_enumeration_line.append(STR(" UMETA(Hidden)"));
            }

            result_enumeration_line.append(STR(","));
            header_data.append_line(result_enumeration_line);
            return RC::LoopAction::Continue;
        });

        header_data.end_ident_level();
        header_data.append_line(STR("};"));

        if (cpp_form == UEnum::ECppForm::Namespaced)
        {
            header_data.end_ident_level();
            header_data.append_line(STR("}"));
        }
    }

    auto UEHeaderGenerator::generate_delegate_type_declaration(UFunction* signature_function, GeneratedSourceFile& header_data) -> void
    {
        auto function_flags = signature_function->GetFunctionFlags();
        if ((function_flags & Unreal::FUNC_Delegate) == 0) {
            throw std::runtime_error(RC::fmt("Delegate Signature function %S is missing FUNC_Delegate flag", signature_function->GetName().c_str()));
        }

        //TODO not particularly nice or reliable, but will do for now
        const bool is_sparse = signature_function->GetClassPrivate()->GetName() == STR("SparseDelegateFunction");

        const bool is_multicast = (function_flags & Unreal::FUNC_MulticastDelegate) != 0;
        const bool declared_const = (function_flags & FUNC_Const) != 0;

        const std::wstring delegate_type_name = get_native_delegate_type_name(signature_function, nullptr, true);
        FProperty* return_value_property = signature_function->GetReturnProperty();

        std::wstring delegate_macro_string;

        //Delegate macro declaration is only allowed on the top level delegates, class-based types are limited to being implicit
        if (signature_function->GetOuterPrivate()->IsA<UPackage>()) {
            delegate_macro_string.append(STR("UDELEGATE("));
            delegate_macro_string.append(generate_function_flags(signature_function));
            delegate_macro_string.append(STR(") "));
        }

        PropertyTypeDeclarationContext context(delegate_type_name, &header_data);

        int32_t num_delegate_parameters = 0;
        std::wstring delegate_parameter_list = generate_function_parameter_list(nullptr, signature_function, header_data, true, context.context_name, {}, &num_delegate_parameters);
        if (num_delegate_parameters > 0)
        {
            delegate_parameter_list.insert(0, STR(", "));
        }

        std::wstring return_value_declaration;
        if (return_value_property != NULL)
        {
            return_value_declaration = generate_property_type_declaration(return_value_property, context);
            return_value_declaration.append(STR(", "));
        }

        std::wstring delegate_declaration_string = fmt::format(STR("{}DECLARE_DYNAMIC{}{}_DELEGATE{}{}{}({}{}{});"),
                                                               delegate_macro_string,
                                                               is_multicast ? STR("_MULTICAST") : STR(""),
                                                               is_sparse ? STR("_SPARSE") : STR(""),
                                                               return_value_property ? STR("_RetVal") : STR(""),
                                                               generate_parameter_count_string(num_delegate_parameters),
                                                               declared_const ? STR("_Const") : STR(""),
                                                               return_value_declaration,
                                                               delegate_type_name,
                                                               delegate_parameter_list);

        header_data.append_line(delegate_declaration_string);
    }

    auto UEHeaderGenerator::generate_object_implementation(UClass* uclass, GeneratedSourceFile& implementation_file) -> void
    {
        const std::wstring class_native_name = get_native_class_name(uclass);
        CaseInsensitiveSet blacklisted_property_names = collect_blacklisted_property_names(uclass);

        //Generate functions
        uclass->ForEachFunction([&](UFunction* function) {
            if (!is_delegate_signature_function(function))
            {
                generate_function_implementation(uclass, function, implementation_file, false, blacklisted_property_names);
                implementation_file.append_line(STR(""));
            }
            return RC::LoopAction::Continue;
        });

        bool encountered_replicated_properties = false;

        uclass->ForEachProperty([&](FProperty* property) {
            encountered_replicated_properties |= (property->GetPropertyFlags() & CPF_Net) != 0;
            return RC::LoopAction::Continue;
        });

        //Generate replicated properties implementation if we really need it
        if (encountered_replicated_properties)
        {
            implementation_file.add_extra_include(STR("Net/UnrealNetwork.h"));

            implementation_file.append_line(fmt::format(STR("void {}::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {{"), class_native_name));
            implementation_file.begin_indent_level();

            implementation_file.append_line(STR("Super::GetLifetimeReplicatedProps(OutLifetimeProps);"));
            implementation_file.append_line(STR(""));

            uclass->ForEachProperty([&](FProperty* property) {
                if ((property->GetPropertyFlags() & CPF_Net) != 0)
                {
                    implementation_file.append_line(fmt::format(STR("DOREPLIFETIME({}, {});"), class_native_name, property->GetName()));
                }
                return RC::LoopAction::Continue;
            });

            implementation_file.end_ident_level();
            implementation_file.append_line(STR("}"));
            implementation_file.append_line(STR(""));
        }

        std::wstring constructor_postfix_string;
        UClass* super_class = uclass->GetSuperClass();
        const std::wstring native_parent_class_name = super_class ? get_native_class_name(super_class) : STR("UObjectUtility");

        //If parent class contains the UObjectInitializer constructor without default value,
        //we need to create the explicit call to such constructor and pass UObjectInitializer::Get() as the argument
        if (m_classes_with_object_initializer.contains(native_parent_class_name))
        {
            constructor_postfix_string.append(fmt::format(STR(" : {}(FObjectInitializer::Get())"), native_parent_class_name));
        }

        //Generate constructor implementation and initialize properties inside
        implementation_file.append_line(fmt::format(STR("{}::{}(){} {{"), class_native_name, class_native_name, constructor_postfix_string));
        implementation_file.begin_indent_level();

        //Generate properties
        UObject* class_default_object = uclass->GetClassDefaultObject();

        uclass->ForEachProperty([&](FProperty* property) {
            generate_property_value(property, class_default_object, implementation_file, STR("this->"));
            return RC::LoopAction::Continue;
        });

        implementation_file.end_ident_level();
        implementation_file.append_line(STR("}"));
    }

    auto UEHeaderGenerator::generate_struct_implementation(UScriptStruct* script_struct, GeneratedSourceFile& implementation_file) -> void
    {
        const std::wstring struct_native_name = get_native_struct_name(script_struct);

        //Generate constructor implementation and initialize properties inside
        implementation_file.append_line(fmt::format(STR("{}::{}() {{"), struct_native_name, struct_native_name));
        implementation_file.begin_indent_level();

        //Generate properties
        void* struct_default_object = malloc(script_struct->GetPropertiesSize());

        //TODO: ScriptStruct->InitializeStruct(StructDefaultObject);
        memset(struct_default_object, 0, script_struct->GetPropertiesSize());

        script_struct->ForEachProperty([&](FProperty* property) {
            generate_property_value(property, struct_default_object, implementation_file, STR("this->"));
            return RC::LoopAction::Continue;
        });

        //TODO: ScriptStruct->DestroyStruct(StructDefaultObject);
        free(struct_default_object);

        implementation_file.end_ident_level();
        implementation_file.append_line(STR("}"));
    }

    auto UEHeaderGenerator::generate_property(UObject* uclass, FProperty* property, GeneratedSourceFile& header_data) -> void
    {
        const std::wstring property_flags_string = generate_property_flags(property);

        bool is_bitmask_bool = false;
        PropertyTypeDeclarationContext Context(uclass->GetName(), &header_data, true, &is_bitmask_bool);

        const std::wstring property_type_string = generate_property_type_declaration(property, Context);

        std::wstring property_extra_declaration;
        if (property->GetArrayDim() != 1)
        {
            property_extra_declaration.append(STR("["));
            property_extra_declaration.append(std::to_wstring(property->GetArrayDim()));
            property_extra_declaration.append(STR("]"));
        }
        else if (is_bitmask_bool)
        {
            property_extra_declaration.append(STR(": 1"));
        }

        header_data.append_line(fmt::format(STR("UPROPERTY({})"), property_flags_string));
        header_data.append_line(fmt::format(STR("{} {}{};"), property_type_string, property->GetName(), property_extra_declaration));
        header_data.append_line(STR(""));
    }

//TODO FUNC_Final is not properly handled (should be always set except some weird cases)
    auto UEHeaderGenerator::generate_function(UClass* uclass, UFunction* function, GeneratedSourceFile& header_data, bool is_generating_interface, const CaseInsensitiveSet& blacklisted_property_names, bool generate_as_override) -> void
    {
        auto function_flags = function->GetFunctionFlags();
        const std::wstring context_name = uclass->GetName();
        bool is_function_pure_virtual = generate_as_override;

        std::wstring function_modifier_string;
        if ((function_flags & FUNC_Static) != 0)
        {
            function_modifier_string.append(STR("static "));
        }
        else if ((function_flags & FUNC_BlueprintEvent) == 0 && is_generating_interface)
        {
            //When we have a blueprint function that is not blueprint event inside the interface,
            //it means we are dealing with the native interface that cannot be implemented via blueprints
            //and uses pure virtual functions implemented through native code
            function_modifier_string.append(STR("virtual "));
            is_function_pure_virtual = true;
        }

        FProperty* return_property = function->GetReturnProperty();
        std::wstring return_property_string;
        if (return_property != NULL)
        {
            PropertyTypeDeclarationContext context(uclass->GetName(), &header_data);
            return_property_string = generate_property_type_declaration(return_property, context);
        }
        else
        {
            return_property_string = STR("void");
        }

        std::wstring function_extra_postfix_string;
        if ((function_flags & FUNC_Const) != 0)
        {
            function_extra_postfix_string.append(STR(" const"));
        }
        if (is_function_pure_virtual)
        {
            std::wstring return_statement_string;
            if (return_property != NULL)
            {
                const std::wstring default_property_value = generate_default_property_value(return_property, header_data, context_name);
                return_statement_string = fmt::format(STR(" return {};"), default_property_value);
            }

            if (generate_as_override)
            {
                function_extra_postfix_string.append(STR(" override"));
            }
            function_extra_postfix_string.append(fmt::format(STR(" PURE_VIRTUAL({},{})"), function->GetName(), return_statement_string));
        }

        std::wstring function_argument_list = generate_function_parameter_list(uclass, function, header_data, false, context_name, blacklisted_property_names);

        const std::wstring function_flags_string = generate_function_flags(function, is_function_pure_virtual);
        header_data.append_line(fmt::format(STR("UFUNCTION({})"), function_flags_string));
        // Format for virtual functions
        // virtual <return type> <function_name>(<params>) PURE_VIRTUAL(<function name>, <return statement>)
        header_data.append_line(fmt::format(STR("{}{} {}({}){};"), function_modifier_string, return_property_string, function->GetName(), function_argument_list, function_extra_postfix_string));
        header_data.append_line(STR(""));
    }

    auto UEHeaderGenerator::generate_enum_value(UEnum* uenum, int64_t enum_value) -> std::wstring
    {
        UEnum::ECppForm cpp_form = uenum->GetCppForm();
        const std::wstring enum_native_name = get_native_enum_name(uenum, false);

        std::wstring enum_constant_name;
        uenum->ForEachName([&](FName Name, int64_t Value) {
            if (Value == enum_value)
            {
                enum_constant_name = sanitize_enumeration_name(Name.ToString());
            }
            return RC::LoopAction::Continue;
        });
        if (enum_constant_name.empty())
        {
            Output::send(STR("Warning: Invalid value for enum '{}', casting instead of using enum name. Value '{}' will be cast to the enum.\n"), enum_native_name, enum_value);
            return fmt::format(STR("({}){}"), enum_native_name, enum_value);
        }
        else
        {
            //Regular enumerations do not really need an enum name prefix
            if (cpp_form == UEnum::ECppForm::Regular)
            {
                return enum_constant_name;
            }
            return fmt::format(STR("{}::{}"), enum_native_name, enum_constant_name);
        }
    }

    auto UEHeaderGenerator::generate_simple_assignment_expression(FProperty* property, const std::wstring& value, GeneratedSourceFile& implementation_file, const std::wstring& property_scope) -> void
    {
        const std::wstring field_class_name = property->GetName();
        if (property->GetArrayDim() == 1)
        {
            implementation_file.append_line(fmt::format(STR("{}{} = {};"), property_scope, field_class_name, value));
        }
        else
        {
            for (int32_t i = 0; i < property->GetArrayDim(); i++)
            {
                implementation_file.append_line(fmt::format(STR("{}{}[{}] = {};"), property_scope, field_class_name, i, value));
            }
        }
    }

    auto UEHeaderGenerator::generate_property_value(FProperty* property, void* object, GeneratedSourceFile& implementation_file, const std::wstring& property_scope) -> void
    {
        const std::wstring field_class_name = property->GetClass().GetName();

        //Byte Property
        if (field_class_name == STR("ByteProperty"))
        {
            FByteProperty* byte_property = static_cast<FByteProperty*>(property);
            uint8_t* byte_property_value = byte_property->ContainerPtrToValuePtr<uint8_t>(object);

            UEnum* uenum = byte_property->GetEnum();
            std::wstring result_property_value;
            if (uenum != NULL)
            {
                result_property_value = generate_enum_value(uenum, *byte_property_value);
            }
            else
            {
                result_property_value = std::to_wstring(*byte_property_value);
            }
            generate_simple_assignment_expression(property, result_property_value, implementation_file, property_scope);
            return;
        }

        //Enum Property
        if (field_class_name == STR("EnumProperty"))
        {
            FEnumProperty* p_enum_property = static_cast<FEnumProperty*>(property);
            UEnum* uenum = p_enum_property->GetEnum();
            if (uenum == NULL)
            {
                throw std::runtime_error(RC::fmt("EnumProperty %S does not have a valid Enum value", property->GetName().c_str()));
            }

            implementation_file.add_dependency_object(uenum, DependencyLevel::Include);
            FNumericProperty* underlying_property = p_enum_property->GetUnderlyingProperty();
             int64 value = underlying_property->GetSignedIntPropertyValue(p_enum_property->ContainerPtrToValuePtr<int64>(object));
            std::wstring result_property_value = generate_enum_value(uenum, value);

            generate_simple_assignment_expression(property, result_property_value, implementation_file, property_scope);
            return;
        }

        //Bool Property
        if (field_class_name == STR("BoolProperty"))
        {
            FBoolProperty* bool_property = static_cast<FBoolProperty*>(property);
            uint8_t* RawPropertyValue = bool_property->ContainerPtrToValuePtr<uint8>(object);

            uint8_t field_mask = bool_property->GetFieldMask();
            uint8_t byte_offset = bool_property->GetByteOffset();

            uint8_t* byte_value = RawPropertyValue + byte_offset;
            bool result_bool_value = !!(*byte_value & field_mask);

            const std::wstring result_property_value = result_bool_value ? STR("true") : STR("false");
            generate_simple_assignment_expression(property, result_property_value, implementation_file, property_scope);
            return;
        }

        //Name property is generated as normal string assignment
        if (field_class_name == STR("NameProperty"))
        {
            FName* name_value = property->ContainerPtrToValuePtr<FName>(object);
            const std::wstring name_value_string = name_value->ToString();

            if (name_value_string != STR("None"))
            {
                const std::wstring result_value = fmt::format(STR("TEXT(\"{}\")"), name_value_string);
                generate_simple_assignment_expression(property, result_value, implementation_file, property_scope);
            }
            return;
        }

        //String properties are just normal strings
        if (field_class_name == STR("StrProperty"))
        {
            FString* string_value = property->ContainerPtrToValuePtr<FString>(object);
            const std::wstring string_value_string = string_value->GetCharArray();

            if (string_value_string != STR(""))
            {
                const std::wstring result_value = create_string_literal(string_value_string);
                generate_simple_assignment_expression(property, result_value, implementation_file, property_scope);
            }
            return;
        }

        //Text properties are treated as FText::FromString, although it's not ideal
        if (field_class_name == STR("TextProperty"))
        {
            FText* text_value = property->ContainerPtrToValuePtr<FText>(object);
            const std::wstring text_value_string = text_value->ToString();

            if (text_value_string != STR(""))
            {
                const std::wstring ResultValue = fmt::format(STR("FText::FromString({})"), create_string_literal(text_value_string));
                generate_simple_assignment_expression(property, ResultValue, implementation_file, property_scope);
            }
        }

        //Object Properties are handled either as NULL, default subobjects, or UClass objects
        if (field_class_name == STR("ObjectProperty"))
        {
            FObjectProperty* object_property = static_cast<FObjectProperty*>(property);
            UObject* sub_object_value = *object_property->ContainerPtrToValuePtr<UObject*>(object);

            if (sub_object_value == NULL)
            {
                //If object value is NULL, generate a simple NULL constant
                generate_simple_assignment_expression(property, STR("NULL"), implementation_file, property_scope);

            }
            else if (sub_object_value->HasAnyFlags(EObjectFlags::RF_DefaultSubObject))
            {
                //Generate a CreateDefaultSubobject function call
                UClass* object_class_type = sub_object_value->GetClassPrivate();
                implementation_file.add_dependency_object(object_class_type, DependencyLevel::Include);

                const std::wstring object_class_name = get_native_class_name(object_class_type);
                const std::wstring object_name = sub_object_value->GetName();
                const std::wstring initializer = fmt::format(STR("CreateDefaultSubobject<{}>(TEXT(\"{}\"))"), object_class_name, object_name);

                generate_simple_assignment_expression(property, initializer, implementation_file, property_scope);
            }
            else if (UClass* sub_object_as_class = Cast<UClass>(sub_object_value))
            {
                //Generate a ::StaticClass call if this object represents a class
                implementation_file.add_dependency_object(sub_object_as_class, DependencyLevel::Include);

                const std::wstring object_class_name = get_native_class_name(sub_object_as_class);
                const std::wstring initializer = fmt::format(STR("{}::StaticClass()"), object_class_name);

                generate_simple_assignment_expression(property, initializer, implementation_file, property_scope);
            }
            else
            {
                //Unhandled case, might be some external object reference
                Output::send(STR("Unhandled default value of the FObjectProperty {}: {}\n"), property->GetFullName(), sub_object_value->GetFullName());
            }
            return;
        }

        //Class Properties are handled either as NULL or StaticClass references
        if (field_class_name == STR("ClassProperty"))
        {
            FClassProperty* class_property = static_cast<FClassProperty*>(property);
            UClass* class_value = *class_property->ContainerPtrToValuePtr<UClass*>(object);

            if (class_value == NULL)
            {
                //If class value is NULL, generate a simple NULL assignment
                generate_simple_assignment_expression(property, STR("NULL"), implementation_file, property_scope);

            }
            else if ((class_value->GetClassFlags() & CLASS_Native) != 0)
            {
                implementation_file.add_dependency_object(class_value, DependencyLevel::Include);

                //Otherwise, generate StaticClass call, assuming the class is native
                const std::wstring object_class_name = get_native_class_name(class_value);
                const std::wstring initializer = fmt::format(STR("{}::StaticClass()"), object_class_name);

                generate_simple_assignment_expression(property, initializer, implementation_file, property_scope);
            }
            else
            {
                //Unhandled case, reference to the non-native blueprint class potentially?
                Output::send(STR("Unhandled default value of the FClassProperty {}: {}\n"), property->GetFullName(), class_value->GetFullName());
            }
            return;
        }

        //Struct properties are serialization as normal struct constructors with custom scope
        //TODO there are a lot of issues with that regarding member access, unnecessary assignments and so on
        /*if (FieldClassName == STR("StructProperty")) {
            XStructProperty* StructProperty = static_cast<XStructProperty*>(Property);
            UScriptStruct* ScriptStruct = StructProperty->get_script_struct();

            if (ScriptStruct == NULL) {
                throw std::runtime_error(RC::fmt("Struct is NULL for StructProperty %S", Property->GetName().c_str()));
            }

            void* StructDataPointer = StructProperty->container_ptr_to_value_ptr<void>(Object);
            const std::wstring NewPropertyScope = fmt::format(STR("{}{}."), PropertyScope, StructProperty->GetName());

            //Generate values for each struct property
            //TODO we do not really need to generate assignments for each struct member, we only really need members that are different from the constructor set defaults
            ScriptStruct->ForEachProperty([&](FProperty* NestedStructProperty) {
                GeneratePropertyValue(NestedStructProperty, StructDataPointer, ImplementationFile, NewPropertyScope);
                return RC::LoopAction::Continue;
            });
            return;
        }*/

        if (field_class_name == STR("ArrayProperty"))
        {
            FScriptArray* property_value = property->ContainerPtrToValuePtr<FScriptArray>(object);

            //Reserve the needed amount of elements
            if (property_value->Num() > 0)
            {
                implementation_file.append_line(fmt::format(STR("{}{}.AddDefaulted({});"), property_scope, property->GetName(), property_value->Num()));
            }
            return;
        }

        //TODO: Support collection/map properties initialization later
        if (field_class_name == STR("ArrayProperty"))
        {
            return;
        }
        if (field_class_name == STR("SetProperty"))
        {
            return;
        }
        if (field_class_name == STR("MapProperty"))
        {
            return;
        }

        // Used to be 'property->is_child_of'
        if (property->IsA<FNumericProperty>())
        {
            FNumericProperty* numeric_property = static_cast<FNumericProperty*>(property);

            std::wstring number_constant_string;
            if (!numeric_property->IsFloatingPoint())
            {
                int64 value = numeric_property->GetSignedIntPropertyValue(numeric_property->ContainerPtrToValuePtr<int64>(object));
                number_constant_string = std::to_wstring(value);
            }
            else
            {
                double value = numeric_property->GetFloatingPointPropertyValue(numeric_property->ContainerPtrToValuePtr<double>(object));
                number_constant_string = fmt::format(STR("{:.2f}f"), value);
            }
            generate_simple_assignment_expression(property, number_constant_string, implementation_file, property_scope);
            return;
        }
    }

    auto UEHeaderGenerator::generate_function_implementation(UClass* uclass, UFunction* function, GeneratedSourceFile& implementation_file, bool is_generating_interface, const CaseInsensitiveSet& blacklisted_property_names) -> void
    {
        const std::wstring class_native_name = get_native_class_name(uclass, is_generating_interface);
        const std::wstring raw_function_name = function->GetName();
        auto function_flags = function->GetFunctionFlags();
        PropertyTypeDeclarationContext context(uclass->GetName(), &implementation_file);

        std::wstring function_implementation_name;
        std::wstring net_validate_function_name;
        bool is_input_function_const = ((function_flags) & FUNC_Const) != 0;

        if ((function_flags & FUNC_Net) != 0)
        {
            //Network functions always have the implementation inside the _Implementation function
            function_implementation_name = fmt::format(STR("{}::{}_Implementation"), class_native_name, raw_function_name);

            //Validated network functions by default have their validation function name set to _Validate
            if ((function_flags & FUNC_NetValidate) != 0)
            {
                net_validate_function_name = fmt::format(STR("{}::{}_Validate"), class_native_name, raw_function_name);
            }
        }
        else if ((function_flags & FUNC_BlueprintEvent) != 0)
        {
            //Blueprint Events use _Implementation by default too, but only BlueprintNativeEvents.
            //BlueprintImplementableEvents do not have any native functions at all, they're just thunks
            if ((function_flags & FUNC_Native) != 0)
            {
                function_implementation_name = fmt::format(STR("{}::{}_Implementation"), class_native_name, raw_function_name);
            }
        }
        else
        {
            //Otherwise, normal UFunctions get a standard name matching the function in question
            function_implementation_name = fmt::format(STR("{}::{}"), class_native_name, raw_function_name);
        }

        std::wstring function_parameter_list;
        if (!function_implementation_name.empty() || !net_validate_function_name.empty())
        {
            function_parameter_list = generate_function_parameter_list(uclass, function, implementation_file, false, context.context_name, blacklisted_property_names);
        }

        if (!function_implementation_name.empty())
        {
            FProperty* return_value_property = function->GetReturnProperty();

            const std::wstring return_value_type = return_value_property ?
                                                   generate_property_type_declaration(return_value_property, context) : STR("void");

            implementation_file.append_line(fmt::format(STR("{} {}({}){} {{"), return_value_type, function_implementation_name,
                                                        function_parameter_list, is_input_function_const ? STR(" const") : STR("")));
            implementation_file.begin_indent_level();

            if (return_value_property != NULL)
            {
                const std::wstring default_value = generate_default_property_value(return_value_property, implementation_file, context.context_name);
                implementation_file.append_line(fmt::format(STR("return {};"), default_value));
            }

            implementation_file.end_ident_level();
            implementation_file.append_line(STR("}"));
        }

        if (!net_validate_function_name.empty())
        {
            implementation_file.append_line(fmt::format(STR("bool {}({}) {{"), net_validate_function_name, function_parameter_list));
            implementation_file.begin_indent_level();

            implementation_file.append_line(STR("return true;"));

            implementation_file.end_ident_level();
            implementation_file.append_line(STR("}"));
        }
    }

    auto UEHeaderGenerator::generate_parameter_count_string(int32_t parameter_count) -> std::wstring
    {
        switch (parameter_count)
        {
            case 0:
                return STR("");
            case 1:
                return STR("_OneParam");
            case 2:
                return STR("_TwoParams");
            case 3:
                return STR("_ThreeParams");
            case 4:
                return STR("_FourParams");
            case 5:
                return STR("_FiveParams");
            case 6:
                return STR("_SixParams");
            case 7:
                return STR("_SevenParams");
            case 8:
                return STR("_EightParams");
            case 9:
                return STR("_NineParams");
            default:
                throw std::invalid_argument("Invalid delegate parameter count");
        }
    }

    auto UEHeaderGenerator::append_access_modifier(GeneratedSourceFile& header_data, AccessModifier needed_access, AccessModifier& current_access) -> void
    {
        if (current_access != needed_access)
        {
            current_access = needed_access;

            if (needed_access == AccessModifier::Public)
            {
                header_data.append_line_no_indent(STR("public:"));
            }
            else if (needed_access == AccessModifier::Protected)
            {
                header_data.append_line_no_indent(STR("protected:"));
            }
            else if (needed_access == AccessModifier::Private)
            {
                header_data.append_line_no_indent(STR("private:"));
            }
        }
    }

    auto UEHeaderGenerator::get_function_access_modifier(UFunction* function) -> AccessModifier
    {
        auto function_flags = function->GetFunctionFlags();

        if ((function_flags & FUNC_Private) != 0)
        {
            return AccessModifier::Private;
        }
        else if ((function_flags & FUNC_Protected) != 0)
        {
            return AccessModifier::Protected;
        }
        else if ((function_flags & FUNC_Public) != 0)
        {
            return AccessModifier::Public;
        }
        return AccessModifier::Public;
    }

    auto UEHeaderGenerator::get_property_access_modifier(FProperty* property) -> AccessModifier
    {
        auto property_flags = property->GetPropertyFlags();

        if ((property_flags & CPF_NativeAccessSpecifierPublic) != 0)
        {
            return AccessModifier::Public;
        }
        else if ((property_flags & CPF_NativeAccessSpecifierProtected) != 0)
        {
            return AccessModifier::Protected;
        }
        else if ((property_flags & CPF_NativeAccessSpecifierPrivate) != 0)
        {
            return AccessModifier::Private;
        }
        return AccessModifier::Public;
    }

    auto UEHeaderGenerator::create_string_literal(const std::wstring& string) -> std::wstring
    {
        std::wstring result;
        result.append(STR("TEXT(\""));

        bool previous_character_was_hex = false;

        const wchar_t* ptr = string.c_str();
        while (wchar_t ch = *ptr++)
        {
            switch (ch)
            {
                case STR('\r'):
                {
                    continue;
                }
                case STR('\n'):
                {
                    result.append(STR("\\n"));
                    previous_character_was_hex = false;
                    break;
                }
                case STR('\\'):
                {
                    result.append(STR("\\\\"));
                    previous_character_was_hex = false;
                    break;
                }
                case STR('\"'):
                {
                    result.append(STR("\\\""));
                    previous_character_was_hex = false;
                    break;
                }
                default:
                {
                    if (ch < 31 || ch >= 128)
                    {
                        result.append(fmt::format(STR("\\x{:04X}"), ch));
                        previous_character_was_hex = true;
                    }
                    else
                    {
                        // We close and open the literal (with TEXT) here in order to ensure that successive hex characters aren't
                        // appended to the hex sequence, causing a different number
                        if (previous_character_was_hex && iswxdigit(ch) != 0)
                        {
                            result.append(STR("\")TEXT(\""));
                        }
                        previous_character_was_hex = false;
                        result.push_back(ch);
                    }
                    break;
                }
            }
        }
        result.append(STR("\")"));
        return result;
    }

    auto UEHeaderGenerator::convert_module_name_to_api_name(const std::wstring& module_name) -> std::wstring
    {
        std::wstring uppercase_string = string_to_uppercase(module_name);
        uppercase_string.append(STR("_API"));
        return uppercase_string;
    }

    auto UEHeaderGenerator::add_module_and_sub_module_dependencies(std::set<std::wstring>& out_module_dependencies, const std::wstring& module_name, bool add_self_module) -> void
    {
        if (add_self_module)
        {
            out_module_dependencies.insert(module_name);
        }
        const auto iterator = m_module_dependencies.find(module_name);
        if (iterator != m_module_dependencies.end())
        {
            for (const std::wstring& DependencyModuleName : *iterator->second)
            {
                add_module_and_sub_module_dependencies(out_module_dependencies, DependencyModuleName);
            }
        }
    }

    auto UEHeaderGenerator::collect_blacklisted_property_names(UObject* uclass) -> CaseInsensitiveSet
    {
        CaseInsensitiveSet result_set;

        if (uclass->GetClassPrivate()->IsChildOf(UClass::StaticClass()))
        {
            UClass* class_object = static_cast<UClass*>(uclass);

            class_object->ForEachProperty([&](FProperty* property) {
                result_set.insert(property->GetName());
                return RC::LoopAction::Continue;
            });

            class_object->ForEachFunction([&](UFunction* function) {
                result_set.insert(function->GetName());
                return RC::LoopAction::Continue;
            });
        }
        else if (uclass->GetClassPrivate()->IsChildOf(UScriptStruct::StaticClass()))
        {
            UScriptStruct* script_struct = static_cast<UScriptStruct*>(uclass);

            script_struct->ForEachProperty([&](FProperty* property) {
                result_set.insert(property->GetName());
                return RC::LoopAction::Continue;
            });
        }
        return result_set;
    }

//TODO CannotImplementInterfaceInBlueprint is not exactly right,
//TODO you can have interface with no implementable blueprint methods but that you can still implement in blueprint
    auto UEHeaderGenerator::generate_interface_flags(UClass* uinterface) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};

        auto class_flags = uinterface->GetClassFlags();
        UClass* super_interface = uinterface->GetSuperClass();
        auto parent_class_flags = super_interface->GetClassFlags();

        auto class_own_flags = (EClassFlags)(class_flags & (~(parent_class_flags & CLASS_Inherit)));

        if ((class_own_flags & CLASS_MinimalAPI) != 0)
        {
            flag_format_helper.add_switch(STR("MinimalAPI"));
        }

        ClassBlueprintInfo blueprint_info = get_class_blueprint_info(uinterface);
        ClassBlueprintInfo parent_blueprint_info = get_class_blueprint_info(super_interface);

        if (blueprint_info.is_blueprintable)
        {
            if (!parent_blueprint_info.is_blueprintable)
            {
                flag_format_helper.add_switch(STR("Blueprintable"));
            }
        }
        else if (blueprint_info.is_blueprint_type)
        {
            if (!parent_blueprint_info.is_blueprint_type)
            {
                flag_format_helper.add_switch(STR("BlueprintType"));
            }
            flag_format_helper.get_meta()->add_switch(STR("CannotImplementInterfaceInBlueprint"));
        }

        return flag_format_helper.build_flag_string();
    }

    auto UEHeaderGenerator::generate_class_flags(UClass* uclass) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};

        auto class_flags = uclass->GetClassFlags();
        UClass* super_class = uclass->GetSuperClass();
        auto parent_class_flags = super_class ? super_class->GetClassFlags() : EClassFlags::CLASS_None;

        auto class_own_flags = (EClassFlags)(class_flags & (~(parent_class_flags & CLASS_Inherit)));

        if ((class_own_flags & CLASS_MinimalAPI) != 0)
        {
            flag_format_helper.add_switch(STR("MinimalAPI"));
        }

        ClassBlueprintInfo blueprint_info = get_class_blueprint_info(uclass);
        ClassBlueprintInfo parent_blueprint_info{};
        if (super_class != NULL)
        {
            parent_blueprint_info = get_class_blueprint_info(super_class);
        }

        if (UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeAllPropertyBlueprintsReadWrite)
        {
            flag_format_helper.add_switch(STR("Blueprintable"));
        }
        else
        {
            if (blueprint_info.is_blueprintable)
            {
                if (!parent_blueprint_info.is_blueprintable)
                {
                    flag_format_helper.add_switch(STR("Blueprintable"));
                }
            }
            else if (blueprint_info.is_blueprint_type)
            {
                if (!parent_blueprint_info.is_blueprint_type)
                {
                    flag_format_helper.add_switch(STR("BlueprintType"));
                }
            }
        }

        if ((class_own_flags & CLASS_Deprecated) != 0)
        {
            flag_format_helper.add_switch(STR("Deprecated"));
        }
        if ((class_own_flags & CLASS_Abstract) != 0)
        {
            flag_format_helper.add_switch(STR("Abstract"));
        }

        if ((class_own_flags & CLASS_MinimalAPI) != 0)
        {
            flag_format_helper.add_switch(STR("MinimalAPI"));
        }
        if ((class_own_flags & CLASS_NoExport) != 0)
        {
            flag_format_helper.add_switch(STR("NoExport"));
        }
        //TODO not quite the case, because UHT boilerplate implicitly marks every native class as CLASS_Intrinsic
        //if ((ClassOwnFlags & CLASS_Intrinsic) != 0) {
        //    FlagFormatHelper.AddSwitch(STR("Intrinsic"));
        //}

        if ((class_own_flags & CLASS_Const) != 0)
        {
            flag_format_helper.add_switch(STR("Const"));
        }
        if ((class_own_flags & CLASS_DefaultToInstanced) != 0)
        {
            flag_format_helper.add_switch(STR("DefaultToInstanced"));
        }

        UClass* class_within = uclass->GetClassWithin();
        if (class_within != NULL && class_within != UObject::StaticClass() &&
            (super_class == NULL || class_within != super_class->GetClassWithin()))
        {
            flag_format_helper.add_parameter(STR("Within"), class_within->GetName());
        }

        if ((class_own_flags & CLASS_Transient) != 0)
        {
            flag_format_helper.add_switch(STR("Transient"));
        }
        else if ((parent_class_flags & CLASS_Transient) != 0)
        {
            flag_format_helper.add_switch(STR("NonTransient"));
        }

        if ((class_own_flags & CLASS_EditInlineNew) != 0)
        {
            flag_format_helper.add_switch(STR("EditInlineNew"));
        }
        else if ((class_flags & CLASS_EditInlineNew) == 0 && (parent_class_flags & CLASS_EditInlineNew) != 0)
        {
            flag_format_helper.add_switch(STR("NotEditInlineNew"));
        }

        if ((class_own_flags & CLASS_NotPlaceable) != 0)
        {
            flag_format_helper.add_switch(STR("NotPlaceable"));
        }
        else if ((class_flags & CLASS_NotPlaceable) == 0 && (parent_class_flags & CLASS_NotPlaceable) != 0)
        {
            flag_format_helper.add_switch(STR("Placeable"));
        }

        const std::wstring class_config_name = uclass->GetClassConfigName().ToString();
        if (super_class == NULL || class_config_name != super_class->GetClassConfigName().ToString())
        {
            flag_format_helper.add_parameter(STR("Config"), class_config_name);
        }

        if ((class_own_flags & CLASS_DefaultConfig) != 0)
        {
            flag_format_helper.add_switch(STR("DefaultConfig"));
        }
        if ((class_own_flags & CLASS_GlobalUserConfig) != 0)
        {
            flag_format_helper.add_switch(STR("GlobalUserConfig"));
        }
        if ((class_own_flags & CLASS_ProjectUserConfig) != 0)
        {
            flag_format_helper.add_switch(STR("ProjectUserConfig"));
        }

        if ((class_own_flags & CLASS_PerObjectConfig) != 0)
        {
            flag_format_helper.add_switch(STR("PerObjectConfig"));
        }
        if ((class_own_flags & CLASS_ConfigDoNotCheckDefaults) != 0)
        {
            flag_format_helper.add_switch(STR("ConfigDoNotCheckDefaults"));
        }

        if ((class_own_flags & CLASS_HideDropDown) != 0)
        {
            flag_format_helper.add_switch(STR("HideDropdown"));
        }

        if ((class_own_flags & CLASS_CollapseCategories) != 0)
        {
            flag_format_helper.add_switch(STR("CollapseCategories"));
        }
        else if ((parent_class_flags & CLASS_CollapseCategories) != 0)
        {
            flag_format_helper.add_switch(STR("DontCollapseCategories"));
        }

        //Mark all UActorComponent derived classes as BlueprintSpawnableComponent by default
        //This will allow using them inside the Simple Construction Script of the blueprint assets
        if (uclass->IsChildOf<UActorComponent>())
        {
            flag_format_helper.get_meta()->add_switch(STR("BlueprintSpawnableComponent"));
            flag_format_helper.add_parameter(STR("ClassGroup"), STR("Custom"));
        }

        return flag_format_helper.build_flag_string();
    }

    /**/
    auto UEHeaderGenerator::generate_property_type_declaration(FProperty* property, const PropertyTypeDeclarationContext& context) -> std::wstring
    {
        UClass* current_class = Unreal::Cast<UClass>(property->GetOutermostOwner());
        const std::wstring field_class_name = property->GetClass().GetName();

        //Byte Property
        if (field_class_name == STR("ByteProperty"))
        {
            FByteProperty* byte_property = static_cast<FByteProperty*>(property);
            UEnum* enum_value = byte_property->GetEnum();

            if (enum_value != NULL)
            {
                if (context.source_file != NULL)
                {
                    context.source_file->add_dependency_object(enum_value, DependencyLevel::Include);
                }

                const std::wstring enum_type_name = get_native_enum_name(enum_value);

                if ((property->GetPropertyFlags() & CPF_BlueprintVisible) != 0)
                {
                    this->m_blueprint_visible_enums.insert(enum_type_name);
                }

                //Non-EnumClass enumerations should be wrapped into TEnumAsByte according to UHT
                return fmt::format(STR("TEnumAsByte<{}>"), enum_type_name);
            }
            return STR("uint8");
        }

        //Enum Property
        if (field_class_name == STR("EnumProperty"))
        {
            FEnumProperty* enum_property = static_cast<FEnumProperty*>(property);
            FNumericProperty* underlying_property = enum_property->GetUnderlyingProperty();
            UEnum* uenum = enum_property->GetEnum();

            if (uenum == NULL)
            {
                throw std::runtime_error(RC::fmt("EnumProperty %S does not have a valid Enum value", property->GetName().c_str()));
            }
            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(uenum, DependencyLevel::Include);
            }
            const std::wstring enum_type_name = get_native_enum_name(uenum);

            if ((property->GetPropertyFlags() & CPF_BlueprintVisible) != 0)
            {
                this->m_blueprint_visible_enums.insert(enum_type_name);
            }

            const std::wstring underlying_enum_type = generate_property_type_declaration(underlying_property, context);
            this->m_underlying_enum_types.insert({enum_type_name, underlying_enum_type});
            return enum_type_name;
        }

        //Bool Property
        if (field_class_name == STR("BoolProperty"))
        {
            FBoolProperty* bool_property = static_cast<FBoolProperty*>(property);
            if (context.is_top_level_declaration && context.out_is_bitmask_bool != NULL)
            {
                if (bool_property->GetFieldMask() != 255)
                {
                    *context.out_is_bitmask_bool = true;
                    return STR("uint8");
                }
            }
            return STR("bool");
        }

        //Standard Numeric Properties
        if (field_class_name == STR("Int8Property"))
        {
            return STR("int8");
        }
        else if (field_class_name == STR("Int16Property"))
        {
            return STR("int16");
        }
        else if (field_class_name == STR("IntProperty"))
        {
            return STR("int32");
        }
        else if (field_class_name == STR("Int64Property"))
        {
            return STR("int64");
        }
        else if (field_class_name == STR("UInt16Property"))
        {
            return STR("uint16");
        }
        else if (field_class_name == STR("UInt32Property"))
        {
            return STR("uint32");
        }
        else if (field_class_name == STR("UInt64Property"))
        {
            return STR("uint64");
        }
        else if (field_class_name == STR("FloatProperty"))
        {
            return STR("float");
        }
        else if (field_class_name == STR("DoubleProperty"))
        {
            return STR("double");
        }

        //Object Properties
        // TODO: Verify that the syntax for 'AssetObjectProperty' is the same as for 'ObjectProperty'.
        //       If it's not, then add another branch here after you figure out what the syntax should be.
        if (field_class_name == STR("ObjectProperty") || field_class_name == STR("AssetObjectProperty"))
        {
            FObjectProperty* object_property = static_cast<FObjectProperty*>(property);
            UClass* property_class = object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("UObject*");
            }
            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(property_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring property_class_name = get_native_class_name(property_class, false);

            return fmt::format(STR("{}*"), property_class_name);
        }

        if (auto* object_property = CastField<FObjectPtrProperty>(property); object_property)
        {
            auto* property_class = object_property->GetPropertyClass();

            if (!property_class)
            {
                return STR("TObjectPtr<UObject>");
            }
            else
            {
                if (context.source_file)
                {
                    context.source_file->add_dependency_object(property_class, DependencyLevel::PreDeclaration);
                }

                const auto property_class_name = get_native_class_name(property_class, false);
                return std::format(STR("TObjectPtr<{}>"), property_class_name);
            }
        }

        if (field_class_name == STR("WeakObjectProperty"))
        {
            FWeakObjectProperty* weak_object_property = static_cast<FWeakObjectProperty*>(property);
            UClass* property_class = weak_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TWeakObjectPtr<UObject>");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(property_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring property_class_name = get_native_class_name(property_class, false);

            return fmt::format(STR("TWeakObjectPtr<{}>"), property_class_name);
        }

        if (field_class_name == STR("LazyObjectProperty"))
        {
            FLazyObjectProperty* lazy_object_property = static_cast<FLazyObjectProperty*>(property);
            UClass* property_class = lazy_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TLazyObjectPtr<UObject>");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(property_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring property_class_name = get_native_class_name(property_class, false);

            return fmt::format(STR("TLazyObjectPtr<{}>"), property_class_name);
        }

        if (field_class_name == STR("SoftObjectProperty"))
        {
            FSoftObjectProperty* soft_object_property = static_cast<FSoftObjectProperty*>(property);
            UClass* property_class = soft_object_property->GetPropertyClass();

            if (property_class == NULL)
            {
                return STR("TSoftObjectPtr<UObject>");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(property_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring property_class_name = get_native_class_name(property_class, false);

            return fmt::format(STR("TSoftObjectPtr<{}>"), property_class_name);
        }

        //Class Properties
        if (field_class_name == STR("ClassProperty") || field_class_name == STR("AssetClassProperty"))
        {
            FClassProperty* class_property = static_cast<FClassProperty*>(property);
            UClass* meta_class = class_property->GetMetaClass();

            if (meta_class == NULL || meta_class == UObject::StaticClass())
            {
                return STR("UClass*");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(meta_class, DependencyLevel::PreDeclaration);
                context.source_file->add_extra_include(STR("Templates/SubclassOf.h"));
            }
            const std::wstring meta_class_name = get_native_class_name(meta_class, false);

            return fmt::format(STR("TSubclassOf<{}>"), meta_class_name);
        }

        if (auto* class_property = CastField<FClassPtrProperty>(property); class_property)
        {
            // TODO: Confirm that this is accurate
            return STR("TObjectPtr<UClass>");
        }

        if (field_class_name == STR("SoftClassProperty"))
        {
            FSoftClassProperty* soft_class_property = static_cast<FSoftClassProperty*>(property);
            UClass* meta_class = soft_class_property->GetMetaClass();

            if (meta_class == NULL || meta_class == UObject::StaticClass())
            {
                return STR("TSoftClassPtr<UObject>");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(meta_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring meta_class_name = get_native_class_name(meta_class, false);

            return fmt::format(STR("TSoftClassPtr<{}>"), meta_class_name);
        }

        //Interface Property
        if (field_class_name == STR("InterfaceProperty"))
        {
            FInterfaceProperty* interface_property = static_cast<FInterfaceProperty*>(property);
            UClass* interface_class = interface_property->GetInterfaceClass();

            if (interface_class == NULL || interface_class == UInterface::StaticClass())
            {
                return STR("FScriptInterface");
            }

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(interface_class, DependencyLevel::PreDeclaration);
            }
            const std::wstring interface_class_name = get_native_class_name(interface_class, true);

            return fmt::format(STR("TScriptInterface<{}>"), interface_class_name);
        }

        //Struct Property
        if (field_class_name == STR("StructProperty"))
        {
            FStructProperty* struct_property = static_cast<FStructProperty*>(property);
            UScriptStruct* script_struct = struct_property->GetStruct();

            if (script_struct == NULL)
            {
                throw std::runtime_error(RC::fmt("Struct is NULL for StructProperty %S", property->GetName().c_str()));
            }
            const std::wstring native_struct_name = get_native_struct_name(script_struct);

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(script_struct, DependencyLevel::Include);
            }
            this->m_blueprint_visible_structs.insert(native_struct_name);

            return native_struct_name;
        }

        //Delegate Properties
        if (field_class_name == STR("DelegateProperty"))
        {
            FDelegateProperty* delegate_property = static_cast<FDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(delegate_signature_function, DependencyLevel::Include);
            }
            return get_native_delegate_type_name(delegate_signature_function, current_class);
        }

        // In 4.23, they replaced 'MulticastDelegateProperty' with 'Inline' & 'Sparse' variants
        // It looks like the delegate macro might be the same as the 'Inline' variant in later versions, so we'll use the same branch here
        if (field_class_name == STR("MulticastInlineDelegateProperty") || field_class_name == STR("MulticastDelegateProperty"))
        {
            FMulticastInlineDelegateProperty* delegate_property = static_cast<FMulticastInlineDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(delegate_signature_function, DependencyLevel::Include);
            }
            return get_native_delegate_type_name(delegate_signature_function, current_class);
        }

        if (field_class_name == STR("MulticastSparseDelegateProperty"))
        {
            FMulticastSparseDelegateProperty* delegate_property = static_cast<FMulticastSparseDelegateProperty*>(property);
            UFunction* delegate_signature_function = delegate_property->GetFunctionSignature();

            if (context.source_file != NULL)
            {
                context.source_file->add_dependency_object(delegate_signature_function, DependencyLevel::Include);
            }
            return get_native_delegate_type_name(delegate_signature_function, current_class);
        }

        //Field path property
        if (field_class_name == STR("FieldPathProperty"))
        {
            FFieldPathProperty* field_path_property = static_cast<FFieldPathProperty*>(property);
            const std::wstring property_class_name = field_path_property->GetPropertyClass()->GetName();
            return fmt::format(STR("TFieldPath<F{}>"), property_class_name);
        }

        //Collection and Map Properties
        // TODO: This is missing support for freeze image array properties because XArrayProperty is incomplete. (low priority)
        if (field_class_name == STR("ArrayProperty"))
        {
            FArrayProperty* array_property = static_cast<FArrayProperty*>(property);
            FProperty* inner_property = array_property->GetInner();

            const std::wstring inner_property_type = generate_property_type_declaration(inner_property, context.inner_context());
            return fmt::format(STR("TArray<{}>"), inner_property_type);
        }

        if (field_class_name == STR("SetProperty"))
        {
            FSetProperty* set_property = static_cast<FSetProperty*>(property);
            FProperty* element_prop = set_property->GetElementProp();

            const std::wstring element_property_type = generate_property_type_declaration(element_prop, context.inner_context());
            return fmt::format(STR("TSet<{}>"), element_property_type);
        }

        // TODO: This is missing support for freeze image map properties because XMapProperty is incomplete. (low priority)
        if (field_class_name == STR("MapProperty"))
        {
            FMapProperty* map_property = static_cast<FMapProperty*>(property);
            FProperty* key_property = map_property->GetKeyProp();
            FProperty* value_property = map_property->GetValueProp();

            const std::wstring key_type = generate_property_type_declaration(key_property, context.inner_context());
            const std::wstring value_type = generate_property_type_declaration(value_property, context.inner_context());

            return fmt::format(STR("TMap<{}, {}>"), key_type, value_type);
        }

        //Standard properties that do not have any special attributes
        if (field_class_name == STR("NameProperty"))
        {
            return STR("FName");
        }
        else if (field_class_name == STR("StrProperty"))
        {
            return STR("FString");
        }
        else if (field_class_name == STR("TextProperty"))
        {
            return STR("FText");
        }
        throw std::runtime_error(RC::fmt("[generate_property_type_declaration] Unsupported property class '%S', full name: '%S'", field_class_name.c_str(), property->GetFullName().c_str()));
    }
    //*/

    auto UEHeaderGenerator::generate_function_argument_flags(FProperty* property) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};
        auto property_flags = property->GetPropertyFlags();

        //CPF_ConstParm is handled explicitly in the parameter list generator, it will generate const before parameter
        //if ((PropertyFlags & CPF_ConstParm) != 0) {
        //    FlagFormatHelper.AddSwitch(STR("Const"));
        //}

        //We only want to add UPARAM(Ref) when parameter is marked as reference AND output,
        //while not being marked as constant, because if it's marked as constant, it might be a parameter passed by const reference
        if ((property_flags & CPF_ReferenceParm) != 0 && (property_flags & CPF_OutParm) != 0 && (property_flags & CPF_ConstParm) == 0)
        {
            flag_format_helper.add_switch(STR("Ref"));
        }

        if ((property_flags & CPF_RepSkip) != 0)
        {
            flag_format_helper.add_switch(STR("NotReplicated"));
        }
        return flag_format_helper.build_flag_string();
    }

    auto UEHeaderGenerator::generate_property_flags(FProperty* property) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};
        auto property_flags = property->GetPropertyFlags();

        if (UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeAllPropertyBlueprintsReadWrite)
        {
            flag_format_helper.add_switch(STR("EditAnywhere"));
        }
        else if ((property_flags & CPF_Edit) != 0)
        {
            if ((property_flags & CPF_EditConst) != 0)
            {
                if ((property_flags & CPF_DisableEditOnTemplate) != 0)
                {
                    flag_format_helper.add_switch(STR("VisibleInstanceOnly"));
                }
                else if ((property_flags & CPF_DisableEditOnInstance) != 0)
                {
                    flag_format_helper.add_switch(STR("VisibleDefaultsOnly"));
                }
                else
                {
                    flag_format_helper.add_switch(STR("VisibleAnywhere"));
                }
            }
            else
            {
                if ((property_flags & CPF_DisableEditOnTemplate) != 0)
                {
                    flag_format_helper.add_switch(STR("EditInstanceOnly"));
                }
                else if ((property_flags & CPF_DisableEditOnInstance) != 0)
                {
                    flag_format_helper.add_switch(STR("EditDefaultsOnly"));
                }
                else
                {
                    flag_format_helper.add_switch(STR("EditAnywhere"));
                }
            }
        }

        if ((property_flags & CPF_NoClear) != 0)
        {
            flag_format_helper.add_switch(STR("NoClear"));
        }
        if ((property_flags & CPF_EditFixedSize) != 0)
        {
            flag_format_helper.add_switch(STR("EditFixedSize"));
        }
        if ((property_flags & CPF_SimpleDisplay) != 0)
        {
            flag_format_helper.add_switch(STR("SimpleDisplay"));
        }
        if ((property_flags & CPF_AdvancedDisplay) != 0)
        {
            flag_format_helper.add_switch(STR("AdvancedDisplay"));
        }

        if (UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeAllPropertyBlueprintsReadWrite)
        {
            if (property->GetArrayDim() == 1 && is_subtype_valid(property))
            {
                flag_format_helper.add_switch(STR("BlueprintReadWrite"));
                flag_format_helper.get_meta()->add_parameter(STR("AllowPrivateAccess"), STR("true"));
            }
        }
        else if ((property_flags & CPF_BlueprintVisible) != 0)
        {
            if ((property_flags & CPF_BlueprintReadOnly) != 0)
            {
                flag_format_helper.add_switch(STR("BlueprintReadOnly"));
            }
            else
            {
                flag_format_helper.add_switch(STR("BlueprintReadWrite"));
            }
            if ((property_flags & CPF_NativeAccessSpecifierPrivate) != 0)
            {
                flag_format_helper.get_meta()->add_parameter(STR("AllowPrivateAccess"), STR("true"));
            }
        }

        if ((property_flags & CPF_BlueprintAssignable) != 0)
        {
            flag_format_helper.add_switch(STR("BlueprintAssignable"));
        }
        if ((property_flags & CPF_BlueprintCallable) != 0)
        {
            flag_format_helper.add_switch(STR("BlueprintCallable"));
        }
        if ((property_flags & CPF_BlueprintAuthorityOnly) != 0)
        {
            flag_format_helper.add_switch(STR("BlueprintAuthorityOnly"));
        }

        if ((property_flags & CPF_Config) != 0)
        {
            if ((property_flags & CPF_GlobalConfig) != 0)
            {
                flag_format_helper.add_switch(STR("GlobalConfig"));
            }
            else
            {
                flag_format_helper.add_switch(STR("Config"));
            }
        }

        if ((property_flags & CPF_Net) != 0)
        {
            if ((property_flags & CPF_RepNotify) != 0)
            {
                const std::wstring rep_notify_func_name = property->GetRepNotifyFunc().ToString();
                flag_format_helper.add_parameter(STR("ReplicatedUsing"), rep_notify_func_name);
            }
            else
            {
                flag_format_helper.add_switch(STR("Replicated"));
            }
        }
        if ((property_flags & CPF_RepSkip) != 0)
        {
            flag_format_helper.add_switch(STR("NotReplicated"));
        }

        if ((property_flags & CPF_AssetRegistrySearchable) != 0)
        {
            flag_format_helper.add_switch(STR("AssetRegistrySearchable"));
        }
        if ((property_flags & CPF_Interp) != 0)
        {
            flag_format_helper.add_switch(STR("Interp"));
        }
        if ((property_flags & CPF_SaveGame) != 0)
        {
            flag_format_helper.add_switch(STR("SaveGame"));
        }
        if ((property_flags & CPF_NonTransactional) != 0)
        {
            flag_format_helper.add_switch(STR("NonTransactional"));
        }

        if ((property_flags & CPF_Transient) != 0)
        {
            flag_format_helper.add_switch(STR("Transient"));
        }
        if ((property_flags & CPF_DuplicateTransient) != 0)
        {
            flag_format_helper.add_switch(STR("DuplicateTransient"));
        }
        if ((property_flags & CPF_TextExportTransient) != 0)
        {
            flag_format_helper.add_switch(STR("TextExportTransient"));
        }
        if ((property_flags & CPF_NonPIEDuplicateTransient) != 0)
        {
            flag_format_helper.add_switch(STR("NonPIEDuplicateTransient"));
        }
        if ((property_flags & CPF_SkipSerialization) != 0)
        {
            flag_format_helper.add_switch(STR("SkipSerialization"));
        }

        //Need to have all of these flags, otherwise we might accidentally get Instanced of delegate properties; CPF_ExportObject is not set for delegate properties
        uint64_t instanced_flags = CPF_ExportObject | CPF_InstancedReference;
        
        // Instanced Arrays use CPF_ContainsInstancedReference instead of CPF_InstancedReference
        uint64_t instanced_array_flags = CPF_ExportObject | CPF_ContainsInstancedReference;

        if (((property_flags & instanced_flags) == instanced_flags || (property_flags & instanced_array_flags) == instanced_array_flags) &&
            (property->IsA<FObjectProperty>() || (property->IsA<FArrayProperty>() && static_cast<FArrayProperty*>(property)->GetInner()->IsA<FObjectProperty>())))
        {
            flag_format_helper.add_switch(STR("Instanced"));
        }
        else if ((property_flags & CPF_ExportObject) != 0)
        {
            flag_format_helper.add_switch(STR("Export"));
        }
        return flag_format_helper.build_flag_string();
    }

    auto UEHeaderGenerator::generate_struct_flags(UScriptStruct* script_struct) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};

        UScriptStruct* super_struct = script_struct->GetSuperScriptStruct();
        EStructFlags parent_struct_flags = (EStructFlags)(super_struct ? (super_struct->GetStructFlags() & (~STRUCT_ComputedFlags)) : STRUCT_NoFlags);
        EStructFlags struct_flags = (EStructFlags)(script_struct->GetStructFlags() & (~STRUCT_ComputedFlags));

        EStructFlags struct_own_flags = (EStructFlags)(struct_flags & (~(parent_struct_flags & STRUCT_Inherit)));

        const std::wstring native_struct_name = get_native_struct_name(script_struct);
        if (is_struct_blueprint_type(script_struct) || m_blueprint_visible_structs.contains(native_struct_name) || UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeAllPropertyBlueprintsReadWrite)
        {
            flag_format_helper.add_switch(STR("BlueprintType"));
        }

        if ((struct_own_flags & STRUCT_NoExport) != 0)
        {
            flag_format_helper.add_switch(STR("NoExport"));
        }
        if ((struct_own_flags & STRUCT_Atomic) != 0)
        {
            flag_format_helper.add_switch(STR("Atomic"));
        }
        if ((struct_own_flags & STRUCT_Immutable) != 0)
        {
            flag_format_helper.add_switch(STR("Immutable"));
        }
        return flag_format_helper.build_flag_string();
    }

    auto UEHeaderGenerator::generate_enum_flags(UEnum* uenum) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};

        auto enum_flags = uenum->GetEnumFlags();

        if ((((int32_t)enum_flags) & ((int32_t)EEnumFlags::Flags)) != 0)
        {
            flag_format_helper.add_switch(STR("Flags"));
        }

        const std::wstring enum_native_name = get_native_enum_name(uenum);
        if (m_blueprint_visible_enums.contains(enum_native_name))
        {
            flag_format_helper.add_switch(STR("BlueprintType"));
        }
        else if (UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeEnumClassesBlueprintType)
        {
            auto cpp_form = uenum->GetCppForm();
            if (cpp_form == UEnum::ECppForm::EnumClass)
            {
                const auto underlying_type = m_underlying_enum_types.find(enum_native_name);
                if (underlying_type == m_underlying_enum_types.end() || underlying_type->second == STR("uint8"))
                {
                    // Underlying type is implicit or explicitly uint8.
                    flag_format_helper.add_switch(STR("BlueprintType"));
                }
            }
            else
            {
                flag_format_helper.add_switch(STR("BlueprintType"));
            }
        }
        return flag_format_helper.build_flag_string();
    }
        
    auto UEHeaderGenerator::generate_function_flags(UFunction* function, bool is_function_pure_virtual) const -> std::wstring
    {
        FlagFormatHelper flag_format_helper{};

        auto function_flags = function->GetFunctionFlags();

        UObject* outer_object = function->GetOuterPrivate();
        bool is_interface_function = false;

        if (outer_object->GetClassPrivate()->IsChildOf(UClass::StaticClass()))
        {
            UClass* outer_class = (UClass*)outer_object;
            is_interface_function = (outer_class->GetClassFlags() & CLASS_Interface) != 0;
        }

        bool blueprint_callable_added = false;
        if ((function_flags & FUNC_BlueprintCallable) != 0)
        {
            //Interface functions cannot be BlueprintPure
            if ((function_flags & FUNC_BlueprintPure) != 0 && !is_interface_function)
            {
                flag_format_helper.add_switch(STR("BlueprintPure"));
            }
            else
            {
                //If function is marked as FUNC_Const but not as BlueprintPure,
                //it has been explicitly marked as blueprint impure, and we need to preserve this behavior
                if ((function_flags & FUNC_Const) != 0 && !is_interface_function)
                {
                    flag_format_helper.add_parameter(STR("BlueprintPure"), STR("false"));
                }
                flag_format_helper.add_switch(STR("BlueprintCallable"));
                blueprint_callable_added = true;
            }
        }
        if (!blueprint_callable_added && UE4SSProgram::settings_manager.UHTHeaderGenerator.MakeAllFunctionsBlueprintCallable && !is_function_pure_virtual)
        {
            bool has_invalid_param{};
            function->ForEachProperty([&](FProperty* param) {
                if (!is_subtype_valid(param))
                {
                    has_invalid_param = true;
                    return LoopAction::Break;
                }
                else
                {
                    return LoopAction::Continue;
                }
            });

            if (!has_invalid_param)
            {
                flag_format_helper.add_switch(STR("BlueprintCallable"));
            }
        }

        if ((function_flags & FUNC_BlueprintEvent) != 0)
        {
            if ((function_flags & FUNC_Native) != 0)
            {
                flag_format_helper.add_switch(STR("BlueprintNativeEvent"));
            }
            else
            {
                flag_format_helper.add_switch(STR("BlueprintImplementableEvent"));
            }
        }

        if ((function_flags & FUNC_Net) != 0)
        {
            if ((function_flags & FUNC_NetServer) != 0)
            {
                flag_format_helper.add_switch(STR("Server"));
            }
            else if ((function_flags & FUNC_NetClient) != 0)
            {
                flag_format_helper.add_switch(STR("Client"));
            }
            else if ((function_flags & FUNC_NetMulticast) != 0)
            {
                flag_format_helper.add_switch(STR("NetMulticast"));
            }
            else if ((function_flags & FUNC_NetRequest) != 0)
            {
                flag_format_helper.add_switch(STR("ServiceRequest"));
            }
            else if ((function_flags & FUNC_NetResponse) != 0)
            {
                flag_format_helper.add_switch(STR("ServiceResponse"));
            }

            if ((function_flags & FUNC_NetReliable) != 0)
            {
                flag_format_helper.add_switch(STR("Reliable"));
            }
            else
            {
                flag_format_helper.add_switch(STR("Unreliable"));
            }
            if ((function_flags & FUNC_NetValidate) != 0)
            {
                flag_format_helper.add_switch(STR("WithValidation"));
            }
        }

        if ((function_flags & FUNC_Exec) != 0)
        {
            flag_format_helper.add_switch(STR("Exec"));
        }
        if ((function_flags & FUNC_BlueprintAuthorityOnly) != 0)
        {
            flag_format_helper.add_switch(STR("BlueprintAuthorityOnly"));
        }
        if ((function_flags & FUNC_BlueprintCosmetic) != 0)
        {
            flag_format_helper.add_switch(STR("BlueprintCosmetic"));
        }
        
        static auto latent_action_info = UObjectGlobals::StaticFindObject<UClass*>(nullptr, nullptr, STR("/Script/Engine.LatentActionInfo"));
        bool bWCFound = false;
        bool bLAFound = false;
        function->ForEachProperty([&](FProperty* param) {
            auto param_name = param->GetName();
            auto param_uc_name = string_to_uppercase(param_name);
            if (param_uc_name.find(STR("WORLDCONTEXT")) != param_uc_name.npos)
            {
                flag_format_helper.get_meta()->add_parameter(STR("WorldContext"), std::format(STR("\"{}\""), param_name));
                bWCFound = true;
            }
            if (auto as_struct_property = CastField<FStructProperty>(param); as_struct_property)
            {
                // We now know this is a StructProperty.
                if (as_struct_property->GetStruct()->IsChildOf(latent_action_info))
                {
                  flag_format_helper.get_meta()->add_parameter(STR("LatentInfo"), std::format(STR("\"{}\""), param_name));
                  flag_format_helper.get_meta()->add_switch(STR("Latent"));
                  bLAFound = true;
                }
            }
            if (bWCFound && bLAFound)
            {
                return LoopAction::Break;
            }
            return LoopAction::Continue;
        });
        
        return flag_format_helper.build_flag_string();
    }

    auto UEHeaderGenerator::generate_function_parameter_list(UClass* uclass, UFunction* function, GeneratedSourceFile& header_data, bool generate_comma_before_name, const std::wstring& context_name, const CaseInsensitiveSet& blacklisted_property_names, int32_t* out_num_params) -> std::wstring
    {
        auto function_flags = function->GetFunctionFlags();
        std::wstring function_arguments_string;

        function->ForEachProperty([&](FProperty* property) {
            auto property_flags = property->GetPropertyFlags();
            if ((property_flags & CPF_Parm) != 0 && (property_flags & CPF_ReturnParm) == 0)
            {
                std::wstring param_declaration;

                //We only generate UPARAM declarations if we are not generating the implementation file
                if (!header_data.is_implementation_file())
                {
                    const std::wstring parameter_flags_string = generate_function_argument_flags(property);
                    if (!parameter_flags_string.empty())
                    {
                        param_declaration.append(STR("UPARAM("));
                        param_declaration.append(parameter_flags_string);
                        param_declaration.append(STR(") "));
                    }
                }

                //Force const reference when we're dealing with strings, and they are not passed by reference
                //UHT for whatever reason completely strips const and reference flags from string properties, but happily generates them in boilerplate code
                const bool should_force_const_ref =
                        ((property_flags & (CPF_ReferenceParm | CPF_OutParm)) == 0) &&
                        (property->GetClass().GetName() == STR("StrProperty"));

                //Append const keyword to the parameter declaration if it is marked as const parameter
                if ((property_flags & CPF_ConstParm) != 0 || should_force_const_ref)
                {
                    param_declaration.append(STR("const "));
                }

                PropertyTypeDeclarationContext context(context_name, &header_data);
                param_declaration.append(generate_property_type_declaration(property, context));

                //Reference will be appended if the parameter has a CPF_ReferenceParm flag set,
                //which would also be always set for output parameters
                if ((property_flags & (CPF_ReferenceParm | CPF_OutParm)) != 0 || should_force_const_ref)
                {
                    param_declaration.append(STR("&"));
                }

                if (generate_comma_before_name)
                {
                    param_declaration.append(STR(","));
                }
                param_declaration.append(STR(" "));

                std::wstring property_name = property->GetName();

                //If property name is blacklisted, capitalize first letter and prepend New
                if ((uclass && is_function_parameter_shadowing(uclass, property)) || blacklisted_property_names.contains(property_name))
                {
                    property_name[0] = towupper(property_name[0]);
                    property_name.insert(0, STR("New"));
                }
                param_declaration.append(property_name);

                function_arguments_string.append(param_declaration);
                function_arguments_string.append(STR(", "));
                if (out_num_params) { (*out_num_params)++; }
            }
            return RC::LoopAction::Continue;
        });

        //remove trailing comma and space from the arguments string
        if (!function_arguments_string.empty())
        {
            function_arguments_string.erase(function_arguments_string.size() - 2);
        }
        return function_arguments_string;
    }

    auto UEHeaderGenerator::generate_default_property_value(FProperty* property, GeneratedSourceFile& header_data, const std::wstring& ContextName) -> std::wstring
    {
        const std::wstring field_class_name = property->GetClass().GetName();
        PropertyTypeDeclarationContext context(ContextName, &header_data);

        //Byte Property
        if (field_class_name == STR("ByteProperty"))
        {
            FByteProperty* byte_property = static_cast<FByteProperty*>(property);
            UEnum* Enum = byte_property->GetEnum();

            if (Enum != NULL)
            {
                const int64_t first_enum_constant_value = Enum->GetEnumNameByIndex(0).Value;
                return generate_enum_value(Enum, first_enum_constant_value);
            }
            return STR("0");
        }

        //Enum Property
        if (field_class_name == STR("EnumProperty"))
        {
            FEnumProperty* enum_property = static_cast<FEnumProperty*>(property);
            FNumericProperty* underlying_type = enum_property->GetUnderlyingProperty();
            UEnum* uenum = enum_property->GetEnum();

            if (uenum == NULL)
            {
                throw std::runtime_error(RC::fmt("EnumProperty %S does not have a valid Enum value", property->GetName().c_str()));
            }
            const int64_t first_enum_constant_value = uenum->GetEnumNameByIndex(0).Value;
            return generate_enum_value(uenum, first_enum_constant_value);
        }

        //Bool Property
        if (field_class_name == STR("BoolProperty"))
        {
            return STR("false");
        }
        //Standard Numeric Properties
        if (field_class_name == STR("Int8Property") ||
            field_class_name == STR("Int16Property") ||
            field_class_name == STR("IntProperty") ||
            field_class_name == STR("Int64Property") ||
            field_class_name == STR("UInt16Property") ||
            field_class_name == STR("UInt32Property") ||
            field_class_name == STR("UInt64Property"))
        {
            return STR("0");
        }
        if (field_class_name == STR("FloatProperty"))
        {
            return STR("0.0f");
        }
        if (field_class_name == STR("DoubleProperty"))
        {
            return STR("0.0");
        }

        //Object Properties
        if (field_class_name == STR("ObjectProperty") ||
            field_class_name == STR("WeakObjectProperty") ||
            field_class_name == STR("LazyObjectProperty") ||
            field_class_name == STR("SoftObjectProperty") ||
            field_class_name == STR("AssetObjectProperty") ||
            property->IsA<FObjectPtrProperty>())
        {
            return STR("NULL");
        }

        //Class Properties
        if (field_class_name == STR("ClassProperty") ||
            field_class_name == STR("SoftClassProperty") ||
            field_class_name == STR("InterfaceProperty") ||
            field_class_name == STR("AssetClassProperty") ||
            property->IsA<FClassPtrProperty>())
        {
            return STR("NULL");
        }

        //Struct Property
        if (field_class_name == STR("StructProperty"))
        {
            FStructProperty* struct_property = static_cast<FStructProperty*>(property);
            UScriptStruct* script_struct = struct_property->GetStruct();

            if (script_struct == NULL)
            {
                throw std::runtime_error(RC::fmt("Struct is NULL for StructProperty %S", property->GetName().c_str()));
            }
            const std::wstring native_struct_name = get_native_struct_name(script_struct);
            return fmt::format(STR("{}{{}}"), native_struct_name);
        }

        //Delegate Properties
        if (field_class_name == STR("DelegateProperty") ||
            field_class_name == STR("MulticastInlineDelegateProperty") ||
            field_class_name == STR("MulticastSparseDelegateProperty"))
        {
            const std::wstring delegate_type_name = generate_delegate_name(property, context.context_name);
            return fmt::format(STR("{}()"), delegate_type_name);
        }

        //Field path property
        if (field_class_name == STR("FieldPathProperty"))
        {
            return STR("FFieldPath()");
        }

        //Collection and Map Properties
        if (field_class_name == STR("ArrayProperty"))
        {
            FArrayProperty* array_property = static_cast<FArrayProperty*>(property);
            FProperty* inner_property = array_property->GetInner();

            const std::wstring inner_property_type = generate_property_type_declaration(inner_property, context);
            return fmt::format(STR("TArray<{}>()"), inner_property_type);
        }

        if (field_class_name == STR("SetProperty"))
        {
            FSetProperty* set_property = static_cast<FSetProperty*>(property);
            FProperty* element_prop = set_property->GetElementProp();

            const std::wstring element_property_type = generate_property_type_declaration(element_prop, context);
            return fmt::format(STR("TSet<{}>()"), element_property_type);
        }

        if (field_class_name == STR("MapProperty"))
        {
            FMapProperty* map_property = static_cast<FMapProperty*>(property);
            FProperty* key_property = map_property->GetKeyProp();
            FProperty* value_property = map_property->GetValueProp();

            const std::wstring key_type = generate_property_type_declaration(key_property, context);
            const std::wstring value_type = generate_property_type_declaration(value_property, context);

            return fmt::format(STR("TMap<{}, {}>()"), key_type, value_type);
        }

        //Various string, name and textp roperties
        if (field_class_name == STR("NameProperty"))
        {
            return STR("NAME_None");
        }
        if (field_class_name == STR("StrProperty"))
        {
            return STR("TEXT(\"\")");
        }
        if (field_class_name == STR("TextProperty"))
        {
            return STR("FText::GetEmpty()");
        }
        throw std::runtime_error(RC::fmt("[generate_default_property_value] Unsupported property class '%S', full name: '%S'", field_class_name.c_str(), property->GetFullName().c_str()));
    }

    auto UEHeaderGenerator::get_class_blueprint_info(UClass* uclass) -> ClassBlueprintInfo
    {
        //These 3 classes are "Intrinsically" blueprintable - they are blueprintable and BlueprintType themselves,
        //but this modifier is not passed through the class hierarchy like normally done
        //So to force generation of correct Blueprintable/BlueprintType statements, we report them as non-blueprint-types
        if (uclass == UObject::StaticClass() || uclass == UActorComponent::StaticClass() || uclass == USceneComponent::StaticClass())
        {
            return ClassBlueprintInfo();
        }

        ClassBlueprintInfo blueprint_info{};
        UClass* super_class = uclass->GetSuperClass();
        if (super_class != NULL)
        {
            blueprint_info = get_class_blueprint_info(super_class);
        }

        uclass->ForEachProperty([&](FProperty* property) {
            auto property_flags = property->GetPropertyFlags();

            if ((property_flags & CPF_BlueprintVisible) != 0)
            {
                blueprint_info.is_blueprint_type = true;
                return RC::LoopAction::Break;
            }
            return RC::LoopAction::Continue;
        });

        uclass->ForEachFunction([&](UFunction* function) {
            auto function_flags = function->GetFunctionFlags();

            if ((function_flags & FUNC_BlueprintEvent) != 0)
            {
                blueprint_info.is_blueprintable = true;
                blueprint_info.is_blueprint_type = true;
                return RC::LoopAction::Break;
            }
            if ((function_flags & FUNC_BlueprintCallable) != 0)
            {
                blueprint_info.is_blueprint_type = true;
            }
            return RC::LoopAction::Continue;
        });
        return blueprint_info;
    }

    auto UEHeaderGenerator::is_struct_blueprint_type(UScriptStruct* script_struct) -> bool
    {
        UScriptStruct* super_struct = script_struct->GetSuperScriptStruct();
        if (super_struct != NULL)
        {
            bool is_super_struct_blueprint_type = is_struct_blueprint_type(super_struct);
            if (is_super_struct_blueprint_type)
            {
                return true;
            }
        }
        bool is_blueprint_type = false;

        script_struct->ForEachProperty([&](FProperty* property) {
            auto property_flags = property->GetPropertyFlags();

            if ((property_flags & CPF_BlueprintVisible) != 0)
            {
                is_blueprint_type = true;
                return RC::LoopAction::Break;
            }
            return RC::LoopAction::Continue;
        });
        return is_blueprint_type;
    }

    auto UEHeaderGenerator::is_function_parameter_shadowing(UClass* uclass, FProperty* function_parameter) -> bool
    {
        bool is_shadowing = false;
        uclass->ForEachPropertyInChain([&](FProperty* property) {
            if (property->GetFName().Equals(function_parameter->GetFName()))
            {
                is_shadowing = true;
                return LoopAction::Break;
            }
            else
            {
                return LoopAction::Continue;
            }
        });

        return is_shadowing;
    }

    auto UEHeaderGenerator::sanitize_enumeration_name(const std::wstring& enumeration_name) -> std::wstring
    {
        std::wstring result_enum_name = enumeration_name;

        //Remove enumeration name from the string
        size_t enum_name_string_split = enumeration_name.find(STR("::"));
        if (enum_name_string_split != std::wstring::npos)
        {
            result_enum_name.erase(0, enum_name_string_split + 2);
        }
        return result_enum_name;
    }

    auto UEHeaderGenerator::get_module_name_for_package(UObject* package) -> std::wstring
    {
        if (package->GetOuterPrivate() != NULL)
        {
            throw std::invalid_argument("Encountered a package with an outer object set");
        }
        std::wstring package_name = package->GetName();
        if (!package_name.starts_with(STR("/Script/")))
        {
            return STR("");
        }
        package_name.erase(0, wcslen(STR("/Script/")));
        return package_name;
    }

    UEHeaderGenerator::UEHeaderGenerator(const FFilePath& root_directory)
    {
        this->m_root_directory = root_directory;
        this->m_primary_module_name = determine_primary_game_module_name();

        //Force inclusion of Core and CoreUObject into all the generated module build files
        this->m_forced_module_dependencies.insert(STR("Core"));
        this->m_forced_module_dependencies.insert(STR("CoreUObject"));
        //TODO not optimal, but still needed for the majority of the cases
        this->m_forced_module_dependencies.insert(STR("Engine"));

        //Add few classes that require explicit UObjectInitializer constructor call
        this->m_classes_with_object_initializer.insert(STR("UUserWidget"));
        this->m_classes_with_object_initializer.insert(STR("UMovieSceneTrack"));
        this->m_classes_with_object_initializer.insert(STR("APlayerStart"));
        this->m_classes_with_object_initializer.insert(STR("URichTextBlock"));
        this->m_classes_with_object_initializer.insert(STR("URichTextBlockImageDecorator"));
        this->m_classes_with_object_initializer.insert(STR("URichTextBlockDecorator"));
    }

    auto UEHeaderGenerator::ignore_selected_modules() -> void
    {
        //Never generate CoreUObject, since it contains a lot of intrinsic classes and is generally always the same
        //Also skip engine initially because engine contents should not change much either

        // Skip "Engine" and "CoreUObject" if requested
        if (UE4SSProgram::settings_manager.UHTHeaderGenerator.IgnoreEngineAndCoreUObject ||
            UE4SSProgram::settings_manager.UHTHeaderGenerator.IgnoreAllCoreEngineModules)
        {
            this->m_ignored_module_names.insert(STR("Engine"));
            this->m_ignored_module_names.insert(STR("CoreUObject"));
        }

        // Skip all core engine packages if requested
        if (UE4SSProgram::settings_manager.UHTHeaderGenerator.IgnoreAllCoreEngineModules)
        {
            this->m_ignored_module_names.insert(STR("ActorLayerUtilities"));
            this->m_ignored_module_names.insert(STR("ActorSequence"));
            this->m_ignored_module_names.insert(STR("AIModule"));
            this->m_ignored_module_names.insert(STR("AndroidPermission"));
            this->m_ignored_module_names.insert(STR("AnimationCore"));
            this->m_ignored_module_names.insert(STR("AnimationSharing"));
            this->m_ignored_module_names.insert(STR("AnimGraphRuntime"));
            this->m_ignored_module_names.insert(STR("AppleImageUtils"));
            this->m_ignored_module_names.insert(STR("ArchVisCharacter"));
            this->m_ignored_module_names.insert(STR("AssetRegistry"));
            this->m_ignored_module_names.insert(STR("AssetTags"));
            this->m_ignored_module_names.insert(STR("AudioAnalyzer"));
            this->m_ignored_module_names.insert(STR("AudioCapture"));
            this->m_ignored_module_names.insert(STR("AudioExtensions"));
            this->m_ignored_module_names.insert(STR("AudioMixer"));
            this->m_ignored_module_names.insert(STR("AudioPlatformConfiguration"));
            this->m_ignored_module_names.insert(STR("AudioSynesthesia"));
            this->m_ignored_module_names.insert(STR("AugmentedReality"));
            this->m_ignored_module_names.insert(STR("AutomationUtils"));
            this->m_ignored_module_names.insert(STR("AvfMediaFactory"));
            this->m_ignored_module_names.insert(STR("BuildPatchServices"));
            this->m_ignored_module_names.insert(STR("CableComponent"));
            this->m_ignored_module_names.insert(STR("Chaos"));
            this->m_ignored_module_names.insert(STR("ChaosCloth"));
            this->m_ignored_module_names.insert(STR("ChaosNiagara"));
            this->m_ignored_module_names.insert(STR("ChaosSolvers"));
            this->m_ignored_module_names.insert(STR("ChaosSolverEngine"));
            this->m_ignored_module_names.insert(STR("CinematicCamera"));
            this->m_ignored_module_names.insert(STR("ClothingSystemRuntimeCommon"));
            this->m_ignored_module_names.insert(STR("ClothingSystemRuntimeInterface"));
            this->m_ignored_module_names.insert(STR("ClothingSystemRuntimeNv"));
            this->m_ignored_module_names.insert(STR("CustomMeshComponent"));
            this->m_ignored_module_names.insert(STR("DatasmithContent"));
            this->m_ignored_module_names.insert(STR("DeveloperSettings"));
            this->m_ignored_module_names.insert(STR("EditableMesh"));
            this->m_ignored_module_names.insert(STR("EngineMessages"));
            this->m_ignored_module_names.insert(STR("EngineSettings"));
            this->m_ignored_module_names.insert(STR("EyeTracker"));
            this->m_ignored_module_names.insert(STR("FacialAnimation"));
            this->m_ignored_module_names.insert(STR("FieldSystemCore"));
            this->m_ignored_module_names.insert(STR("FieldSystemEngine"));
            this->m_ignored_module_names.insert(STR("Foliage"));
            this->m_ignored_module_names.insert(STR("GameplayTags"));
            this->m_ignored_module_names.insert(STR("GameplayTasks"));
            this->m_ignored_module_names.insert(STR("GeometryCache"));
            this->m_ignored_module_names.insert(STR("GeometryCacheTracks"));
            this->m_ignored_module_names.insert(STR("GeometryCollectionCore"));
            this->m_ignored_module_names.insert(STR("GeometryCollectionSimulationCore"));
            this->m_ignored_module_names.insert(STR("GeometryCollectionEngine"));
            this->m_ignored_module_names.insert(STR("GeometryCollectionTracks"));
            this->m_ignored_module_names.insert(STR("GooglePAD"));
            this->m_ignored_module_names.insert(STR("HeadMountedDisplay"));
            this->m_ignored_module_names.insert(STR("ImageWrapper"));
            this->m_ignored_module_names.insert(STR("ImageWriteQueue"));
            this->m_ignored_module_names.insert(STR("ImgMedia"));
            this->m_ignored_module_names.insert(STR("ImgMediaFactory"));
            this->m_ignored_module_names.insert(STR("InputCore"));
            this->m_ignored_module_names.insert(STR("InteractiveToolsFramework"));
            this->m_ignored_module_names.insert(STR("JsonUtilities"));
            this->m_ignored_module_names.insert(STR("Landscape"));
            this->m_ignored_module_names.insert(STR("LevelSequence"));
            this->m_ignored_module_names.insert(STR("LightPropagationVolumeRuntime"));
            this->m_ignored_module_names.insert(STR("LiveLinkInterface"));
            this->m_ignored_module_names.insert(STR("LocationServicesBPLibrary"));
            this->m_ignored_module_names.insert(STR("LuminRuntimeSettings"));
            this->m_ignored_module_names.insert(STR("MagicLeap"));
            this->m_ignored_module_names.insert(STR("MagicLeapAR"));
            this->m_ignored_module_names.insert(STR("MagicLeapARPin"));
            this->m_ignored_module_names.insert(STR("MagicLeapAudio"));
            this->m_ignored_module_names.insert(STR("MagicLeapController"));
            this->m_ignored_module_names.insert(STR("MagicLeapEyeTracker"));
            this->m_ignored_module_names.insert(STR("MagicLeapHandMeshing"));
            this->m_ignored_module_names.insert(STR("MagicLeapHandTracking"));
            this->m_ignored_module_names.insert(STR("MagicLeapIdentity"));
            this->m_ignored_module_names.insert(STR("MagicLeapImageTracker"));
            this->m_ignored_module_names.insert(STR("MagicLeapLightEstimation"));
            this->m_ignored_module_names.insert(STR("MagicLeapPlanes"));
            this->m_ignored_module_names.insert(STR("MagicLeapPrivileges"));
            this->m_ignored_module_names.insert(STR("MagicLeapSecureStorage"));
            this->m_ignored_module_names.insert(STR("MagicLeapSharedWorld"));
            this->m_ignored_module_names.insert(STR("MaterialShaderQualitySettings"));
            this->m_ignored_module_names.insert(STR("MediaAssets"));
            this->m_ignored_module_names.insert(STR("MediaCompositing"));
            this->m_ignored_module_names.insert(STR("MediaUtils"));
            this->m_ignored_module_names.insert(STR("MeshDescription"));
            this->m_ignored_module_names.insert(STR("MobilePatchingUtils"));
            this->m_ignored_module_names.insert(STR("MotoSynth"));
            this->m_ignored_module_names.insert(STR("MoviePlayer"));
            this->m_ignored_module_names.insert(STR("MovieScene"));
            this->m_ignored_module_names.insert(STR("MovieSceneCapture"));
            this->m_ignored_module_names.insert(STR("MovieSceneTracks"));
            this->m_ignored_module_names.insert(STR("MRMesh"));
            this->m_ignored_module_names.insert(STR("NavigationSystem"));
            this->m_ignored_module_names.insert(STR("NetCore"));
            this->m_ignored_module_names.insert(STR("Niagara"));
            this->m_ignored_module_names.insert(STR("NiagaraAnimNotifies"));
            this->m_ignored_module_names.insert(STR("NiagaraCore"));
            this->m_ignored_module_names.insert(STR("NiagaraShader"));
            this->m_ignored_module_names.insert(STR("OculusHMD"));
            this->m_ignored_module_names.insert(STR("OculusInput"));
            this->m_ignored_module_names.insert(STR("OculusMR"));
            this->m_ignored_module_names.insert(STR("OnlineSubsystem"));
            this->m_ignored_module_names.insert(STR("OnlineSubsystemUtils"));
            this->m_ignored_module_names.insert(STR("Overlay"));
            this->m_ignored_module_names.insert(STR("PacketHandler"));
            this->m_ignored_module_names.insert(STR("Paper2D"));
            this->m_ignored_module_names.insert(STR("PhysicsCore"));
            this->m_ignored_module_names.insert(STR("PhysXVehicles"));
            this->m_ignored_module_names.insert(STR("ProceduralMeshComponent"));
            this->m_ignored_module_names.insert(STR("PropertyAccess"));
            this->m_ignored_module_names.insert(STR("PropertyPath"));
            this->m_ignored_module_names.insert(STR("Renderer"));
            this->m_ignored_module_names.insert(STR("Serialization"));
            this->m_ignored_module_names.insert(STR("SessionMessages"));
            this->m_ignored_module_names.insert(STR("SignificanceManager"));
            this->m_ignored_module_names.insert(STR("Slate"));
            this->m_ignored_module_names.insert(STR("SlateCore"));
            this->m_ignored_module_names.insert(STR("SoundFields"));
            this->m_ignored_module_names.insert(STR("StaticMeshDescription"));
            this->m_ignored_module_names.insert(STR("SteamVR"));
            this->m_ignored_module_names.insert(STR("SteamVRInputDevice"));
            this->m_ignored_module_names.insert(STR("Synthesis"));
            this->m_ignored_module_names.insert(STR("TcpMessaging"));
            this->m_ignored_module_names.insert(STR("TemplateSequence"));
            this->m_ignored_module_names.insert(STR("TimeManagement"));
            this->m_ignored_module_names.insert(STR("UdpMessaging"));
            this->m_ignored_module_names.insert(STR("UMG"));
            this->m_ignored_module_names.insert(STR("UObjectPlugin"));
            this->m_ignored_module_names.insert(STR("VariantManagerContent"));
            this->m_ignored_module_names.insert(STR("VectorVM"));
            this->m_ignored_module_names.insert(STR("WmfMediaFactory"));
        }
    }

    auto UEHeaderGenerator::dump_native_packages() -> void
    {
        ignore_selected_modules();

        Output::send(STR("Cleaning up previously generated SDK (if one exists)\n"));
        if (std::filesystem::exists(m_root_directory))
        {
            std::filesystem::remove_all(m_root_directory);
        }

        Output::send(STR("Initializing native packages dump\n"));

        std::vector<UClass*> native_classes_to_dump;
        std::vector<UScriptStruct*> native_structs_to_dump;
        std::vector<UEnum*> native_enums_to_dump;
        std::vector<UFunction*> native_delegates_to_dump;

        Output::send(STR("Gathering native objects for dumping\n"));
        UObjectGlobals::ForEachUObject([&](void* raw_object, int32_t chunk_index, int32_t object_index) {
            UObject* typed_object = static_cast<UObject*>(raw_object);

            if (UClass* casted_object = Cast<UClass>(typed_object))
            {
                if ((casted_object->GetClassFlags() & CLASS_Native) != 0)
                {
                    native_classes_to_dump.push_back(casted_object);
                }
            }
            else if (UScriptStruct* casted_struct = Cast<UScriptStruct>(typed_object))
            {
                if ((casted_struct->GetStructFlags() & STRUCT_Native) != 0)
                {
                    native_structs_to_dump.push_back(casted_struct);
                }
            }
            else if (UEnum* uenum = Cast<UEnum>(typed_object))
            {
                if (!typed_object->IsA<UUserDefinedEnum>())
                {
                    native_enums_to_dump.push_back(uenum);
                }
            }
            else if (UFunction* function = Cast<UFunction>(typed_object))
            {
                //We are looking for delegate signature functions located inside the native packages
                //When they are located directly on the top level, they will result in a separate header, otherwise they will
                //be included into their respective outer header
                if (is_delegate_signature_function(function) && function->GetOuterPrivate()->IsA<UPackage>())
                {
                    UPackage* outer_package = Cast<UPackage>(function->GetOuterPrivate());

                    //Make sure the function package actually corresponds to the real native module
                    if (!get_module_name_for_package(outer_package).empty()) {
                        native_delegates_to_dump.push_back(function);
                    }
                }
            }

            return RC::LoopAction::Continue;
        });

        Output::send(STR("Attempting to dump {} native classes\n"), native_classes_to_dump.size());

        for (UFunction* delegate_signature_function : native_delegates_to_dump)
        {
            //Output::send(STR("Dumping native delegate type {}\n"), global_delegate_signature->GetName());
            generate_object_description_file(delegate_signature_function);
        }

        for (UClass* class_to_dump : native_classes_to_dump)
        {
            //Output::send(STR("Dumping native class {}\n"), class_to_dump->GetName());
            generate_object_description_file(class_to_dump);
        }

        Output::send(STR("Attempting to dump {} native structs\n"), native_structs_to_dump.size());

        for (UScriptStruct* struct_to_dump : native_structs_to_dump)
        {
            //Output::send(STR("Dumping native struct {}\n"), struct_to_dump->GetName());
            generate_object_description_file(struct_to_dump);
        }

        Output::send(STR("Attempting to dump {} native enums\n"), native_enums_to_dump.size());

        for (UEnum* enum_to_dump : native_enums_to_dump)
        {
            //Output::send(STR("Dumping native enum {}\n"), enum_to_dump->GetName());
            generate_object_description_file(enum_to_dump);
        }

        Output::send(STR("Writing stub module build files for {} modules\n"), m_module_dependencies.size());
        for (const auto& module_pair : m_module_dependencies)
        {
            generate_module_implementation_file(module_pair.first);
            generate_module_build_file(module_pair.first);
        }

        Output::send(STR("Done!\n"));
    }

    auto UEHeaderGenerator::generate_object_description_file(UObject* object) -> bool
    {
        const std::wstring module_name = get_module_name_for_package(object->GetOutermost());
        const std::wstring file_base_name = get_header_name_for_object(object);

        if (module_name.empty())
        {
            return false;
        }
        if (m_ignored_module_names.contains(module_name))
        {
            return false;
        }

        GeneratedSourceFile header_file = GeneratedSourceFile::create_source_file(m_root_directory, module_name, file_base_name, false);
        GeneratedSourceFile implementation_file = GeneratedSourceFile::create_source_file(m_root_directory, module_name, file_base_name, true);
        implementation_file.set_header_file(&header_file);

        if (UClass* uclass = Cast<UClass>(object))
        {
            if (uclass->IsChildOf<UInterface>())
            {
                generate_interface_definition(uclass, header_file);
            }
            else
            {
                generate_object_definition(uclass, header_file);
                generate_object_implementation(uclass, implementation_file);
            }
        }
        else if (UScriptStruct* script_struct = Cast<UScriptStruct>(object))
        {
            generate_struct_definition(script_struct, header_file);
            generate_struct_implementation(script_struct, implementation_file);
        }
        else if (UEnum* uenum = Cast<UEnum>(object))
        {
            generate_enum_definition(uenum, header_file);
        }
        else if (UFunction* function = Cast<UFunction>(object))
        {
            if (!is_delegate_signature_function(function))
            {
                throw std::runtime_error(RC::fmt("Function %S is not a delegate signature function", function->GetName().c_str()));
            }
            if (!function->GetOuterPrivate()->IsA<UPackage>())
            {
                throw std::runtime_error(RC::fmt("Delegate Signature Function %S does not have a UPackage as it's owner", function->GetName().c_str()));
            }
            generate_global_delegate_declaration(function, header_file);
        }
        else
        {
            throw std::runtime_error(RC::fmt("Provided object %S is not of a supported type: %S", object->GetName().c_str(), object->GetClassPrivate()->GetName().c_str()));
        }

        auto iterator = this->m_module_dependencies.find(module_name);
        if (iterator == this->m_module_dependencies.end())
        {
            iterator = this->m_module_dependencies.insert({module_name, std::make_shared<std::set<std::wstring>>()}).first;
        }

        if (!header_file.serialize_file_content_to_disk())
        {
            return false;
        }
        implementation_file.serialize_file_content_to_disk();

        //Record module names used in the headers
        std::shared_ptr<std::set<std::wstring>> out_dependency_module_names = iterator->second;
        header_file.copy_dependency_module_names(*out_dependency_module_names);
        implementation_file.copy_dependency_module_names(*out_dependency_module_names);

        return true;
    }

    auto UEHeaderGenerator::generate_object_pre_declaration(UObject* object, std::wstring& out_extra_declaration) -> std::wstring
    {
        UClass* object_class = object->GetClassPrivate();

        if (object_class->IsChildOf(UClass::StaticClass()))
        {
            UClass* uclass = static_cast<UClass*>(object);

            if (uclass->IsChildOf(UInterface::StaticClass()))
            {
                out_extra_declaration = fmt::format(STR("class {};"), get_native_class_name(uclass, true));
            }
            return fmt::format(STR("class {};"), get_native_class_name(uclass, false));

        }
        else if (object_class->IsChildOf(UScriptStruct::StaticClass()))
        {
            UScriptStruct* script_struct = static_cast<UScriptStruct*>(object);

            return fmt::format(STR("struct {};"), get_native_struct_name(script_struct));

        }
        else if (object_class->IsChildOf(UEnum::StaticClass()))
        {
            UEnum* uenum = static_cast<UEnum*>(object);

            //TODO do we want them? They're not that easy since we do not know enum types precisely in advance
            throw std::invalid_argument("Enum pre-declarations are not supported");
        }
        else
        {
            throw std::invalid_argument("Provided object is not of a supported type, should be UClass/UScriptStruct/UEnum");
        }
    }

    auto UEHeaderGenerator::get_header_name_for_object(UObject* object, bool get_existing_header) -> std::wstring {
        File::StringType header_name{};
        UObject* final_object{};

        if (object->IsA<UClass>() || object->IsA<UScriptStruct>()) {
            //Class and struct headers follow the relevant object name
            header_name = object->GetName();
            final_object = object;
        } else if (object->IsA<UEnum>()) {
            //Enumeration usually have the E prefix which will be present in the header names
            //We do not strip it because there are some broken headers that do not follow that convention (e.g. funny Wwise)
            header_name = object->GetName();
            final_object = object;
        } else {
            //Delegate signature functions need to have their postfix removed
            UFunction* signature_function = Unreal::Cast<UFunction>(object);
            if (signature_function != nullptr && is_delegate_signature_function(signature_function))
            {

                //If delegate is not declared inside the package, it is declared in the header of it's outer
                if (!signature_function->GetOuterPrivate()->IsA<UPackage>())
                {
                    final_object = signature_function->GetOuterPrivate();
                    header_name = get_header_name_for_object(final_object, get_existing_header);
                }
                else
                {
                    //Otherwise, remove the postfix and use the function name as the header name
                    //Also append the delegate postfix because apparently there can be conflicts
                    std::wstring DelegateName = strip_delegate_signature_postfix(signature_function);
                    DelegateName.append(STR("Delegate"));
                    header_name = DelegateName;
                    final_object = object;
                }
            }
        }

        if (header_name.empty())
        {
            //Unsupported dependency object type
            throw std::runtime_error(RC::fmt("Unsupported dependency object type %S: %S", object->GetClassPrivate()->GetName().c_str(), object->GetName().c_str()));
        }

        if (get_existing_header)
        {
            if (auto it2 = m_dependency_object_to_unique_id.find(final_object); it2 != m_dependency_object_to_unique_id.end())
            {
                header_name.append(std::format(STR("{}"), it2->second));
            }
        }
        else
        {
            if (auto it = m_used_file_names.find(header_name); it != m_used_file_names.end())
            {
                header_name.append(std::format(STR("{}"), ++it->second.usable_id));
                m_dependency_object_to_unique_id.emplace(final_object, it->second.usable_id);
            }
            else
            {
                m_used_file_names.emplace(header_name, UniqueName{header_name});
            }
        }

        return header_name;
    }

    auto UEHeaderGenerator::generate_global_delegate_declaration(UFunction* signature_function, GeneratedSourceFile& header_data) -> void {
        generate_delegate_type_declaration(signature_function, header_data);
    }

    auto UEHeaderGenerator::determine_primary_game_module_name() -> std::wstring {
        HMODULE primary_executable_module = GetModuleHandleW(NULL);
        wchar_t module_name_buffer[1024] {'\0'};
        GetModuleFileNameW(primary_executable_module, module_name_buffer, ARRAYSIZE(module_name_buffer));

        //Retrieve the filename from the full path, strip down the extension
        FFilePath root_executable_path((std::wstring(module_name_buffer)));
        std::wstring filename = root_executable_path.filename().replace_extension().wstring();

        //Remove the shipping file postfix
        std::wstring shipping_postfix = STR("-Win64-Shipping");
        if (filename.ends_with(shipping_postfix)) {
            filename.erase(filename.length() - shipping_postfix.length());
        }
        return filename;
    }

    auto UEHeaderGenerator::generate_cross_module_include(UObject* object, const std::wstring& module_name, const std::wstring& fallback_name) -> std::wstring {
        //Retrieve the most top level object located inside the native package
        UObject* top_level_object = object;

        while (!top_level_object->GetOuterPrivate()->IsA<UPackage>()) {
            top_level_object = top_level_object->GetOuterPrivate();
        }

        const std::wstring object_name = top_level_object->GetName();
        return fmt::format(STR("//CROSS-MODULE INCLUDE V2: -ModuleName={} -ObjectName={} -FallbackName={}\n"), module_name, object_name, fallback_name);
    }

    GeneratedFile::GeneratedFile(const FFilePath& full_file_path)
    {
        this->m_full_file_path = full_file_path;
        this->m_file_base_name = full_file_path.filename().replace_extension().wstring();
        this->m_current_indent_count = 0;
    }

    auto GeneratedFile::append_line(const std::wstring& line) -> void
    {
        for (int32_t i = 0; i < m_current_indent_count; i++)
        {
            m_file_contents_buffer.append(STR("    "));
        }
        m_file_contents_buffer.append(line);
        m_file_contents_buffer.append(STR("\n"));
    }

    auto GeneratedFile::append_line_no_indent(const std::wstring& line) -> void
    {
        m_file_contents_buffer.append(line);
        m_file_contents_buffer.append(STR("\n"));
    }

    auto GeneratedFile::begin_indent_level() -> void
    {
        m_current_indent_count++;
    }

    auto GeneratedFile::end_ident_level() -> void
    {
        m_current_indent_count--;
        if (m_current_indent_count < 0)
        {
            throw std::invalid_argument("Attempt to pop empty ident level stack");
        }
    }

    auto GeneratedFile::serialize_file_content_to_disk() -> bool
    {
        if (!has_content_to_save())
        {
            return false;
        }
        //TODO might be slow, maybe move it out into the header generator?
        std::filesystem::create_directories(this->m_full_file_path.parent_path());

        std::wofstream file_output_stream;
        file_output_stream.open(m_full_file_path);
        if (!file_output_stream.is_open())
        {
            throw std::invalid_argument("Failed to open the header file");
        }
        file_output_stream << generate_file_contents();
        file_output_stream.close();
        return true;
    }

    auto GeneratedFile::generate_file_contents() -> std::wstring
    {
        return m_file_contents_buffer;
    }

    auto GeneratedFile::has_content_to_save() const -> bool
    {
        return !m_file_contents_buffer.empty();
    }

    auto GeneratedSourceFile::create_source_file(const FFilePath& root_dir, const std::wstring& module_name, const std::wstring& base_name, bool is_implementation_file) -> GeneratedSourceFile
    {
        FFilePath full_file_path;
        if (is_implementation_file)
        {
            full_file_path = root_dir / module_name / STR("Private") / (base_name + STR(".cpp"));
        }
        else
        {
            full_file_path = root_dir / module_name / STR("Public") / (base_name + STR(".h"));
        }
        return GeneratedSourceFile(full_file_path, module_name, is_implementation_file);
    }

    GeneratedSourceFile::GeneratedSourceFile(const FFilePath& file_path, const std::wstring& file_module_name, bool is_implementation_file) : GeneratedFile(file_path)
    {
        this->m_file_module_name = file_module_name;
        this->m_is_implementation_file = is_implementation_file;
    }

    auto GeneratedSourceFile::set_header_file(GeneratedSourceFile* header_file) -> void
    {
        this->m_header_file = header_file;
    }

    auto GeneratedSourceFile::add_extra_include(const std::wstring& included_file_name) -> void
    {
        this->m_extra_includes.insert(included_file_name);
    }

    auto GeneratedSourceFile::add_dependency_object(UObject* object, DependencyLevel dependency_level) -> void
    {
        const auto iterator = m_dependencies.find(object);

        //Only add the dependency if we don't have one already or requested level is higher than the current one
        if (iterator == m_dependencies.end() || (int32_t)iterator->second <= (int32_t)dependency_level)
        {
            m_dependencies.insert_or_assign(object, dependency_level);
        }
    }

    auto GeneratedSourceFile::generate_file_contents() -> std::wstring
    {
        std::wstring result_header_contents;
        result_header_contents.append(generate_includes_string());
        result_header_contents.append(STR("\n"));

        std::wstring pre_declarations_string = generate_pre_declarations_string();
        if (!pre_declarations_string.empty())
        {
            result_header_contents.append(pre_declarations_string);
            result_header_contents.append(STR("\n"));
        }

        if (!m_file_contents_buffer.empty())
        {
            result_header_contents.append(m_file_contents_buffer);
            result_header_contents.append(STR("\n"));
        }
        return result_header_contents;
    }

    auto GeneratedSourceFile::generate_includes_string() const -> std::wstring
    {
        std::wstring result_include_string;

        //For the header file, we generate the pragma and minimal core includes
        if (!m_is_implementation_file)
        {
            result_include_string.append(STR("#pragma once\n"));
            result_include_string.append(STR("#include \"CoreMinimal.h\"\n"));
        }
        //For CPP implementation file, we need to generate the header include
        if (m_is_implementation_file)
        {
            if (m_header_file != NULL)
            {
                //Generate it if we have the correct header file set
                result_include_string.append(fmt::format(STR("#include \"{}.h\"\n"), m_header_file->m_file_base_name));
            }
            else
            {
                //Otherwise, we generate a simple minimal core include
                result_include_string.append(STR("#include \"CoreMinimal.h\"\n"));
            }
        }

        //Generate extra includes we might need that do not represent objects
        for (const std::wstring& extra_included_file : m_extra_includes)
        {
            result_include_string.append(fmt::format(STR("#include \"{}\"\n"), extra_included_file));
        }

        //Generate includes for the relevant object files
        for (const auto& dependency_pair : m_dependencies)
        {
            UObject* dependency_object = dependency_pair.first;

            //Only want to generate include dependencies
            if (dependency_pair.second != DependencyLevel::Include)
            {
                continue;
            }

            const std::wstring object_header_name = UEHeaderGenerator::get_header_name_for_object(dependency_object, true);

            //Definitely skip include if object in question is placed into this header
            if (object_header_name == m_file_base_name)
            {
                continue;
            }

            //Skip includes that have already been generated on the header file
            if (m_is_implementation_file && m_header_file != NULL)
            {
                if (m_header_file->has_dependency(dependency_object, DependencyLevel::Include))
                {
                    continue;
                }
            }
            UObject* package = dependency_object->GetOutermost();
            std::wstring native_module_name = UEHeaderGenerator::get_module_name_for_package(package);

            if (!native_module_name.empty())
            {
                //If this package corresponds to the file inside this module, we generate the normal include,
                //since generated headers are always located in the module root and follow one file per object convention
                if (m_file_module_name == native_module_name)
                {
                    result_include_string.append(fmt::format(STR("#include \"{}.h\"\n"), object_header_name));
                }
                else
                {
                    //Otherwise, we generate an include stub which will be handled by the unreal engine commandlet later
                    m_dependency_module_names.insert(native_module_name);
                    result_include_string.append(UEHeaderGenerator::generate_cross_module_include(dependency_object, native_module_name, object_header_name));
                }
            }
        }

        //Last include of the header file should always be a generated one
        if (!m_is_implementation_file)
        {
            result_include_string.append(fmt::format(STR("#include \"{}.generated.h\"\n"), m_file_base_name));
        }
        return result_include_string;
    }

    auto GeneratedSourceFile::generate_pre_declarations_string() const -> std::wstring
    {
        std::wstring result_declarations;

        //Generate pre-declarations for the relevant object files
        for (const auto& dependency_pair : m_dependencies)
        {
            UObject* dependency_object = dependency_pair.first;

            //Only want to generate pre-declarations
            if (dependency_pair.second != DependencyLevel::PreDeclaration)
            {
                continue;
            }

            //We still need to reference the object's owner module
            UObject* package = dependency_object->GetOutermost();
            std::wstring native_module_name = UEHeaderGenerator::get_module_name_for_package(package);

            if (!native_module_name.empty() && m_file_module_name != native_module_name)
            {
                m_dependency_module_names.insert(native_module_name);
            }

            std::wstring extra_declaration_string;
            std::wstring declaration_string = UEHeaderGenerator::generate_object_pre_declaration(dependency_object, extra_declaration_string);

            if (!declaration_string.empty())
            {
                result_declarations.append(declaration_string);
                result_declarations.append(STR("\n"));
            }
            if (!extra_declaration_string.empty())
            {
                result_declarations.append(extra_declaration_string);
                result_declarations.append(STR("\n"));
            }
        }
        return result_declarations;
    }

    auto GeneratedSourceFile::has_content_to_save() const -> bool
    {
        return !m_file_contents_buffer.empty();
    }

    auto GeneratedSourceFile::has_dependency(UObject* object, DependencyLevel dependency_level) -> bool
    {
        const auto iterator = m_dependencies.find(object);
        return iterator != m_dependencies.end() &&
               ((int32_t)iterator->second >= (int32_t)dependency_level);
    }
}

```

`src/SettingsManager.cpp`:

```cpp
#include <SettingsManager.hpp>
#include <IniParser/Ini.hpp>

#define REGISTER_STRING_SETTING(member_var, section_name, key)          \
try                                                                     \
{                                                                       \
    (member_var) = parser.get_string(section_name, STR(#key));          \
}                                                                       \
catch (std::exception&) {}

#define REGISTER_INT64_SETTING(member_var, section_name, key)           \
try                                                                     \
{                                                                       \
    (member_var) = parser.get_int64(section_name, STR(#key));           \
}                                                                       \
catch (std::exception&) {}

#define REGISTER_BOOL_SETTING(member_var, section_name, key)            \
try                                                                     \
{                                                                       \
    (member_var) = parser.get_bool(section_name, STR(#key));            \
}                                                                       \
catch (std::exception&) {}

namespace RC
{
    auto SettingsManager::deserialize(std::filesystem::path& file_name) -> void
    {
        auto file = File::open(file_name, File::OpenFor::Reading, File::OverwriteExistingFile::No, File::CreateIfNonExistent::Yes);
        Ini::Parser parser;
        parser.parse(file);
        file.close();

        constexpr static File::CharType section_overrides[] = STR("Overrides");
        REGISTER_STRING_SETTING(Overrides.ModsFolderPath, section_overrides, ModsFolderPath)

        constexpr static File::CharType section_general[] = STR("General");
        REGISTER_BOOL_SETTING(General.EnableHotReloadSystem, section_general, EnableHotReloadSystem)
        REGISTER_BOOL_SETTING(General.InvalidateCacheIfDLLDiffers, section_general, InvalidateCacheIfDLLDiffers)
        REGISTER_BOOL_SETTING(General.EnableDebugKeyBindings, section_general, EnableDebugKeyBindings)
        REGISTER_INT64_SETTING(General.MaxScanAttemptsNormal, section_general, MaxScanAttemptsNormal)
        REGISTER_INT64_SETTING(General.MaxScanAttemptsModular, section_general, MaxScanAttemptsModular)
        REGISTER_BOOL_SETTING(General.UseUObjectArrayCache, section_general, UseUObjectArrayCache)

        constexpr static File::CharType section_engine_version_override[] = STR("EngineVersionOverride");
        REGISTER_INT64_SETTING(EngineVersionOverride.MajorVersion, section_engine_version_override, MajorVersion)
        REGISTER_INT64_SETTING(EngineVersionOverride.MinorVersion, section_engine_version_override, MinorVersion)

        constexpr static File::CharType section_object_dumper[] = STR("ObjectDumper");
        REGISTER_BOOL_SETTING(ObjectDumper.LoadAllAssetsBeforeDumpingObjects, section_object_dumper, LoadAllAssetsBeforeDumpingObjects)

        constexpr static File::CharType section_cxx_header_generator[] = STR("CXXHeaderGenerator");
        REGISTER_BOOL_SETTING(CXXHeaderGenerator.DumpOffsetsAndSizes, section_cxx_header_generator, DumpOffsetsAndSizes)
        REGISTER_BOOL_SETTING(CXXHeaderGenerator.KeepMemoryLayout, section_cxx_header_generator, KeepMemoryLayout)
        REGISTER_BOOL_SETTING(CXXHeaderGenerator.LoadAllAssetsBeforeGeneratingCXXHeaders, section_cxx_header_generator, LoadAllAssetsBeforeGeneratingCXXHeaders)

        constexpr static File::CharType section_uht_header_generator[] = STR("UHTHeaderGenerator");
        REGISTER_BOOL_SETTING(UHTHeaderGenerator.IgnoreAllCoreEngineModules, section_uht_header_generator, IgnoreAllCoreEngineModules)
        REGISTER_BOOL_SETTING(UHTHeaderGenerator.IgnoreEngineAndCoreUObject, section_uht_header_generator, IgnoreEngineAndCoreUObject)
        REGISTER_BOOL_SETTING(UHTHeaderGenerator.MakeAllFunctionsBlueprintCallable, section_uht_header_generator, MakeAllFunctionsBlueprintCallable)
        REGISTER_BOOL_SETTING(UHTHeaderGenerator.MakeAllPropertyBlueprintsReadWrite, section_uht_header_generator, MakeAllPropertyBlueprintsReadWrite)
        REGISTER_BOOL_SETTING(UHTHeaderGenerator.MakeEnumClassesBlueprintType, section_uht_header_generator, MakeEnumClassesBlueprintType)

        constexpr static File::CharType section_debug[] = STR("Debug");
        REGISTER_BOOL_SETTING(Debug.SimpleConsoleEnabled, section_debug, ConsoleEnabled)
        REGISTER_BOOL_SETTING(Debug.DebugConsoleEnabled , section_debug, GuiConsoleEnabled)
        REGISTER_BOOL_SETTING(Debug.DebugConsoleVisible, section_debug, GuiConsoleVisible)

        constexpr static File::CharType section_threads[] = STR("Threads");
        REGISTER_INT64_SETTING(Threads.SigScannerNumThreads, section_threads, SigScannerNumThreads)
        REGISTER_INT64_SETTING(Threads.SigScannerMultithreadingModuleSizeThreshold, section_threads, SigScannerMultithreadingModuleSizeThreshold)

        constexpr static File::CharType section_memory[] = STR("Memory");
        REGISTER_INT64_SETTING(Memory.MaxMemoryUsageDuringAssetLoading, section_memory, MaxMemoryUsageDuringAssetLoading)
    }
}

```

`src/Signatures.cpp`:

```cpp
#include <filesystem>
#include <Signatures.hpp>
#include <SigScanner/SinglePassSigScanner.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <LuaMadeSimple/LuaMadeSimple.hpp>
#include <LuaLibrary.hpp>
#include <Unreal/UnrealInitializer.hpp>
#include <Unreal/Signatures.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/UObjectArray.hpp>
#include <Unreal/FString.hpp>
#include <Unreal/FMemory.hpp>

namespace RC
{
    auto scan_complete_default_func(DidLuaScanSucceed) -> void {}

    auto scan_from_lua_script(std::wstring& script_file_path_and_name, std::vector<SignatureContainer>& signature_containers, LuaScriptMatchFoundFunc& match_found_func, LuaScriptScanCompleteFunc& scan_complete_func) -> void
    {
        const LuaMadeSimple::Lua& lua = LuaMadeSimple::new_state();

        lua.open_all_libs();
        lua.register_function("Print", LuaLibrary::global_print);
        lua.register_function("print", LuaLibrary::global_print);
        lua.register_function("DerefToInt32", LuaLibrary::deref_to_int32);
        lua.register_function("dereftoint32", LuaLibrary::deref_to_int32);

        lua.execute_file(script_file_path_and_name);

        constexpr const char* global_register_func_name = "Register";
        constexpr const char* global_on_match_found_func_name = "OnMatchFound";

        if (!lua.is_global_function(global_register_func_name) || !lua.is_global_function(global_on_match_found_func_name))
        {
            Output::send(STR("Lua functions 'Register' and 'OnMatchFound' must be present in {}\n"), script_file_path_and_name);
            throw std::runtime_error{"See error message above"};
        }

        lua.call_function(global_register_func_name, 0, 1);

        if (!lua.is_string())
        {
            throw std::runtime_error{"Lua function 'Register' must return a string that contains the signature to scan for"};
        }

        signature_containers.emplace_back(SignatureContainer{
                {
                        {
                                lua.get_string().data()
                        },
                },
                // On Match Found
                [&lua, match_found_func](SignatureContainer& self) -> bool {
                    lua.prepare_function_call(global_on_match_found_func_name);
                    lua.set_integer(reinterpret_cast<uintptr_t>(static_cast<void*>(self.get_match_address())));
                    lua.call_function(1, 1);

                    if (!lua.is_integer())
                    {
                        return false;
                    }

                    void* found_address = reinterpret_cast<void*>(lua.get_integer());
                    if (!found_address)
                    {
                        return false;
                    }

                    DidLuaScanSucceed did_lua_scan_succeed = match_found_func(found_address);

                    if (did_lua_scan_succeed == DidLuaScanSucceed::Yes)
                    {
                        self.get_did_succeed() = true;
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                },
                // On Scan Completed
                [&lua, scan_complete_func]([[maybe_unused]]const SignatureContainer& self) {
                    scan_complete_func(self.get_did_succeed() ? DidLuaScanSucceed::Yes : DidLuaScanSucceed::No);
                }
        });

        //lua_close(lua.get_lua_state());
    }

    auto setup_lua_scan_overrides(std::filesystem::path& working_directory, Unreal::UnrealInitializer::Config& config) -> void
    {
        std::wstring lua_guobjectarray_scan_script = working_directory / "UE4SS_Signatures/GUObjectArray.lua";
        if (std::filesystem::exists(lua_guobjectarray_scan_script))
        {
            config.ScanOverrides.guobjectarray = [lua_guobjectarray_scan_script](std::vector<SignatureContainer>& signature_containers, Unreal::Signatures::ScanResult& scan_result) mutable {
                scan_from_lua_script(lua_guobjectarray_scan_script, signature_containers, [](void* address) {
                    Output::send(STR("GUObjectArray address: {} <- Lua Script\n"), address);
                    Unreal::UObjectArray::SetupGUObjectArrayAddress(address);
                    return DidLuaScanSucceed::Yes;
                }, [&](DidLuaScanSucceed did_lua_scan_succeed) {
                    if (did_lua_scan_succeed == DidLuaScanSucceed::No)
                    {
                        scan_result.Errors.emplace_back("Was unable to find AOB for 'GUObjectArray' via Lua script");
                    }
                });
            };
        }

        std::wstring lua_fts_scan_script = working_directory / "UE4SS_Signatures/FName_ToString.lua";
        if (std::filesystem::exists(lua_fts_scan_script))
        {
            config.ScanOverrides.fname_to_string = [lua_fts_scan_script](std::vector<SignatureContainer>& signature_containers, Unreal::Signatures::ScanResult& scan_result) mutable {
                scan_from_lua_script(lua_fts_scan_script, signature_containers, [](void* address) {
                    Output::send(STR("FName::ToString address: {} <- Lua Script\n"), address);
                    Unreal::FName::ToStringInternal.assign_address(address);
                    return DidLuaScanSucceed::Yes;
                }, [&](DidLuaScanSucceed did_lua_scan_succeed) {
                    if (did_lua_scan_succeed == DidLuaScanSucceed::No)
                    {
                        scan_result.Errors.emplace_back("Was unable to find AOB for 'FName::ToString' via Lua script");
                    }
                });
            };
        }

        std::wstring lua_fnc_scan_script = working_directory / "UE4SS_Signatures/FName_Constructor.lua";
        if (std::filesystem::exists(lua_fnc_scan_script))
        {
            config.ScanOverrides.fname_constructor = [lua_fnc_scan_script](std::vector<SignatureContainer>& signature_containers, Unreal::Signatures::ScanResult& scan_result) mutable {
                scan_from_lua_script(lua_fnc_scan_script, signature_containers, [&scan_result](void* address) {
                    Unreal::FName name = Unreal::FName(L"bCanBeDamaged", Unreal::FNAME_Find, address);

                    if (name == L"bCanBeDamaged")
                    {
                        Output::send(STR("FName::FName address: {} <- Lua Script\n"), address);
                        Unreal::FName::ConstructorInternal.assign_address(address);
                        return DidLuaScanSucceed::Yes;
                    }
                    else
                    {
                        scan_result.Errors.emplace_back("Lua script 'FName_Constructor.lua' did not return a valid address for FName::FName.");
                        return DidLuaScanSucceed::No;
                    }
                }, [&scan_result]([[maybe_unused]]DidLuaScanSucceed did_lua_scan_succeed) {
                    if (!Unreal::FName::ConstructorInternal.get_function_address())
                    {
                        scan_result.Errors.emplace_back("Lua script 'FName_Constructor.lua' did not return a valid address for FName::FName.");
                    }
                });
            };
        }

        // For compatibility, we look for 'FMemory_Free.lua' if 'GMalloc.lua' doesn't exist.
        std::wstring lua_ffree_scan_script_new = working_directory / "UE4SS_Signatures/GMalloc.lua";
        std::wstring lua_ffree_scan_script_compat = working_directory / "UE4SS_Signatures/FMemory_Free.lua";
        auto lua_ffree_scan_script = std::filesystem::exists(lua_ffree_scan_script_new) ? lua_ffree_scan_script_new : lua_ffree_scan_script_compat;
        if (std::filesystem::exists(lua_ffree_scan_script))
        {
            config.ScanOverrides.fmemory_free = [lua_ffree_scan_script](std::vector<SignatureContainer>& signature_containers, Unreal::Signatures::ScanResult& scan_result) mutable {
                scan_from_lua_script(lua_ffree_scan_script, signature_containers, [](void* address) {
                    Output::send(STR("GMalloc address: {} <- Lua Script\n"), address);
                    Unreal::FMalloc::UnrealStaticGMalloc = static_cast<Unreal::FMalloc**>(address);
                    Unreal::GMalloc = *Unreal::FMalloc::UnrealStaticGMalloc;
                    return DidLuaScanSucceed::Yes;
                }, [&](DidLuaScanSucceed did_lua_scan_succeed) {
                    if (did_lua_scan_succeed == DidLuaScanSucceed::No)
                    {
                        scan_result.Errors.emplace_back("Was unable to find AOB for 'GMalloc' via Lua script");
                    }
                });
            };
        }

        std::wstring lua_sco_scan_script = working_directory / "UE4SS_Signatures/StaticConstructObject.lua";
        if (std::filesystem::exists(lua_sco_scan_script))
        {
            config.ScanOverrides.static_construct_object = [lua_sco_scan_script](std::vector<SignatureContainer>& signature_containers, Unreal::Signatures::ScanResult& scan_result) mutable {
                scan_from_lua_script(lua_sco_scan_script, signature_containers, [](void* address) {
                    Output::send(STR("StaticConstructObject_Internal address: {} <- Lua Script\n"), address);
                    Unreal::UObjectGlobals::SetupStaticConstructObjectInternalAddress(address);
                    return DidLuaScanSucceed::Yes;
                }, [&](DidLuaScanSucceed did_lua_scan_succeed) {
                    if (did_lua_scan_succeed == DidLuaScanSucceed::No)
                    {
                        scan_result.Errors.emplace_back("Was unable to find AOB for 'StaticConstructObject' via Lua script");
                    }
                });
            };
        }
    }
}


```

`src/UE4SSProgram.cpp`:

```cpp
#define NOMINMAX

#include <Windows.h>

#ifdef TEXT
#undef TEXT
#endif

#include <cwctype>
#include <limits>
#include <unordered_set>
#include <algorithm>
#include <fstream>
#include <format>

#include <UE4SSProgram.hpp>
#include <build_number.hpp>
#include <Signatures.hpp>
#include <Helpers/ASM.hpp>
#include <Helpers/String.hpp>
#include <Unreal/TypeChecker.hpp>
#include <Helpers/Format.hpp>
#include <Helpers/Integer.hpp>
#include <UnrealDef.hpp>
#include <DynamicOutput/DynamicOutput.hpp>
#include <GUI/GUI.hpp>
#include <GUI/LiveView.hpp>
#include <GUI/ConsoleOutputDevice.hpp>
#include <Timer/ScopedTimer.hpp>
#include <Timer/FunctionTimer.hpp>
#include <SigScanner/SinglePassSigScanner.hpp>
#include <Mod.hpp>
#include <LuaType/LuaUObject.hpp>
#include <LuaType/LuaCustomProperty.hpp>
#include <LuaLibrary.hpp>
#include <SDKGenerator/Generator.hpp>
#include <SDKGenerator/UEHeaderGenerator.hpp>
#include <ExceptionHandling.hpp>
#include <ObjectDumper/ObjectToString.hpp>
#include <IniParser/Ini.hpp>
#include <Unreal/GameplayStatics.hpp>
#include <Unreal/World.hpp>
#include <Unreal/UObjectArray.hpp>
#include <Unreal/Searcher/ObjectSearcher.hpp>
#include <Unreal/UPackage.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UObjectArray.hpp>

//#include <LuaBindings/States/MainState/Main.hpp>
//#include <LuaBindings/LuaSetup.hpp>

// LuaLate params: LuaState, ClassOrFreeFunction, FullyQualifiedClassOrFunctionName, ImportIntoFullyQualifiedScope (optional)
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::GlobalClassTest, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::MyFirstClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC2::MyFirstClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC2::RC3::RC4::MyFirstClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FOutputDevice, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFrame, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FString, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FName, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UObjectBase, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UObjectBaseUtility, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UObject, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UStruct, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UField, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UWorld, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UScriptStruct, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FVector, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FRotator, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FQuat, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FObjectInstancingGraph, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::TMulticastScriptDelegate, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFeedbackContext, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::TScriptDelegate, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::ITargetPlatform, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FOutParmRec, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UFunction, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FGuid, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FScriptArray, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FTransform, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FUObjectItem, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FWeakObjectPtr, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FText, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::UEnum, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::ObjectSearcher, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FField, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFieldVariant, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFieldClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFieldClassVariant, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FObjectPropertyBase, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FObjectProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaAddBaseToClass(::RC::Unreal::TFObjectPropertyBase, ::RC::Unreal::FObjectPropertyBase)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FLazyObjectProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FSoftObjectProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FWeakObjectProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FClassProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FSoftClassProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FByteProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FInt8Property, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FInt16Property, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FIntProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FUInt16Property, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FUInt32Property, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FUInt64Property, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFloatProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FDoubleProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaAddBaseToClass(::RC::Unreal::TProperty_Numeric, ::RC::Unreal::FNumericProperty)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FArrayProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FBoolProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FDelegateProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FEnumProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FFieldPathProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FInterfaceProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FMapProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FMulticastDelegateProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FMulticastInlineDelegateProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FMulticastSparseDelegateProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FNameProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FNumericProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FSetProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FStrProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FStructProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FTextProperty, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::UnrealRuntimeTypes::ArrayTest, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::UnrealRuntimeTypes::LuaUScriptStruct, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::Version, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::GlobalFunctionTest, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetWorldTest, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetMyFirstClass, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetMyFirstClass2, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetMyFirstClass3, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Unreal::UObjectGlobals::FindFirstOf, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Unreal::UObjectGlobals::ForEachUObject, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::Unreal::UObjectGlobals::FindAllOf, ::RC::lua_FindAllOf_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::RegisterKeyBind, ::RC::lua_RegisterKeyBind_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::warn, ::RC::lua_warn_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::print, ::RC::lua_print_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

// There is no non-templated 'StaticFindObject' function and that should change at some point.
// For now we're using 'FindObject' instead which is what the templated 'StaticFindObject' variants wrap.
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Unreal::UObjectGlobals::FindObject, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

// LuaMemberFunctionRedirector params: Class, FunctionName, FullyQualifiedLuaWrapper
// Injecting a completely new member function into a struct.
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::UObjectBase, MyTestFunc, ::RC::UObjectBase_memberr_function_wrapper_MyTestFunc)] */

// Redirecting an existing member function in a struct to your own wrapper.
// Primarily used for injecting custom code before or after the original function.
// The code for the original function won't be generated so you'll have to rewrite it or copy before you override the original.
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::UObjectBase, GetNamePrivate, ::RC::UObjectBase_member_function_wrapper_GetNamePrivate)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::UObjectBase, Cast, ::RC::UObjectBase_member_function_wrapper_Cast)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::FField, CastField, ::RC::FField_member_function_wrapper_CastField)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::UEnum, ForEachName, ::RC::UEnum_member_function_wrapper_ForEachName)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::UnrealRuntimeTypes::ArrayTest, GetElementAtIndex, ::RC::ArrayTest_member_function_wrapper_GetElementAtIndex)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::UnrealRuntimeTypes::ArrayTest, ForEach, ::RC::ArrayTest_member_function_wrapper_ForEach)] */
/** CUSTOM_ATTRIBUTE[LuaStaticMemberFunctionRedirector(::RC::Unreal::UClass, StaticClass, ::RC::UClass_member_function_wrapper_StaticClass)] */

// LuaAddMetamethod params: FullyQualifiedClass, MetamethodName, FullyQualifiedLuaWrapper
// Adding metamethods to a struct.
// It doesn't account for future inheritance, meaning that if you add a metamethod to 'Derived', it won't get triggered from 'Base'.
// It accounts for past inheritance, meaning that if you add a metamethod to 'Base', it will get triggered from 'Derived' if 'Derived' doesn't have its own.
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::Unreal::UObjectBase, __index, ::RC::UObjectBase_metamethod_wrapper_Index)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::Unreal::UObjectBase, __newindex, ::RC::UObjectBase_metamethod_wrapper_NewIndex)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::Unreal::UFunction, __call, ::RC::UFunction_metamethod_wrapper_Call)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::UnrealRuntimeTypes::ArrayTest, __gc, ::RC::ArrayTest_metamethod_wrapper_GC)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::UnrealRuntimeTypes::LuaUScriptStruct, __index, ::RC::LuaUScriptStruct_metamethod_wrapper_Index)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::UnrealRuntimeTypes::LuaUScriptStruct, __newindex, ::RC::LuaUScriptStruct_metamethod_wrapper_NewIndex)] */
/** CUSTOM_ATTRIBUTE[LuaAddMetamethod(::RC::UnrealRuntimeTypes::LuaUScriptStruct, __gc, ::RC::LuaUScriptStruct_metamethod_wrapper_GC)] */

/** CUSTOM_ATTRIBUTE[LuaMapTemplateClass(::RC::Unreal::TArray, ::RC::UnrealRuntimeTypes::Array)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetArrayTest, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetArrayTest2, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::GetArrayTest3, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

// Low-level memory
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::Unreal::FMemory, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Class, ::RC::MemoryItem, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::AllocateMemory, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::FreeMemory, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadBytes, ::RC::lua_Test_ReadBytes_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadUInt8, ::RC::lua_Test_ReadUInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadUInt16, ::RC::lua_Test_ReadUInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadUInt32, ::RC::lua_Test_ReadUInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadUInt64, ::RC::lua_Test_ReadUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadInt8, ::RC::lua_Test_ReadInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadInt16, ::RC::lua_Test_ReadInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadInt32, ::RC::lua_Test_ReadInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::ReadInt64, ::RC::lua_Test_ReadInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteBytes, ::RC::lua_Test_WriteBytes_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteUInt8, ::RC::lua_Test_WriteUInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteUInt16, ::RC::lua_Test_WriteUInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteUInt32, ::RC::lua_Test_WriteUInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteUInt64, ::RC::lua_Test_WriteUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteInt8, ::RC::lua_Test_WriteInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteInt16, ::RC::lua_Test_WriteInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteInt32, ::RC::lua_Test_WriteInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::WriteInt64, ::RC::lua_Test_WriteInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

// CE aliases
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readBytes, ::RC::lua_Test_ReadBytes_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readByte, ::RC::lua_Test_ReadUInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readSmallInteger, ::RC::lua_Test_ReadUInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readInteger, ::RC::lua_Test_ReadUInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readQword, ::RC::lua_Test_ReadUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::readPointer, ::RC::lua_Test_ReadUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writeBytes, ::RC::lua_Test_WriteBytes_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writeByte, ::RC::lua_Test_WriteUInt8_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writeSmallInteger, ::RC::lua_Test_WriteUInt16_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writeInteger, ::RC::lua_Test_WriteUInt32_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writeQword, ::RC::lua_Test_WriteUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::writePointer, ::RC::lua_Test_WriteUInt64_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Test_GetUnsignedMemorySetup, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Test_GetSignedMemorySetup, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Test_GetPlayerControllerVTablePointer, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::Test_Get_UObject_Nullptr, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

/** CUSTOM_ATTRIBUTE[LuaLate(Enum, ::RC::LoopAction, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Enum, ::RC::Unreal::EObjectFlags, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Enum, ::RC::Input::Key, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(Enum, ::RC::Input::ModifierKey, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */

// UE4SS 1.3 compatibility
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::LuaBackCompat::StaticFindObject, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(CustomFreeFunction, ::RC::LuaBackCompat::RegisterHook, ::RC::LuaBackCompat::lua_RegisterHook_wrapper, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaLate(FreeFunction, ::RC::LuaBackCompat::NotifyOnNewObject, ::), LuaStateTypes(MainState, AsyncState, AOBState)] */
/** CUSTOM_ATTRIBUTE[LuaMemberFunctionRedirector(::RC::Unreal::UObjectBase, IsA, ::RC::LuaBackCompat::lua_UObjectBase_IsA_wrapper)] */

auto GlobalFunctionTest() -> GlobalClassTest
{
    printf_s("GlobalFunctionTest\n");
    return GlobalClassTest{};
}

namespace RC
{
    auto GetPlayerControllerTest2() -> Unreal::UObjectBase*
    {
        return UObjectGlobals::FindFirstOf(STR("PlayerController"));
    }
    auto GetPlayerControllerTest3() -> Unreal::UObjectBaseUtility*
    {
        return UObjectGlobals::FindFirstOf(STR("PlayerController"));
    }
    auto GetMyFirstClass() -> MyFirstClass
    {
        return MyFirstClass{};
    }
    auto GetMyFirstClass2() -> ::RC2::MyFirstClass
    {
        return ::RC2::MyFirstClass{};
    }
    auto GetMyFirstClass3() -> ::RC2::RC3::RC4::MyFirstClass
    {
        return ::RC2::RC3::RC4::MyFirstClass{};
    }

    // Commented out because this system (turn off hotkeys when in-game console is open) it doesn't work properly.
    /*
    struct RC_UE_API FUEDeathListener : public Unreal::FUObjectCreateListener
    {
        static FUEDeathListener UEDeathListener;

        void NotifyUObjectCreated(const Unreal::UObjectBase* object, int32_t index) override {}
        void OnUObjectArrayShutdown() override
        {
            UE4SSProgram::unreal_is_shutting_down = true;
            Unreal::UObjectArray::RemoveUObjectCreateListener(this);
        }
    };
    FUEDeathListener FUEDeathListener::UEDeathListener{};

    auto get_player_controller() -> UObject*
    {
        std::vector<Unreal::UObject*> player_controllers{};
        UObjectGlobals::FindAllOf(STR("PlayerController"), player_controllers);
        if (!player_controllers.empty())
        {
            return player_controllers.back();
        }
        else
        {
            return nullptr;
        }
    }
    //*/

    SettingsManager UE4SSProgram::settings_manager{};

#define OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(StructName) \
    for (const auto&[name, offset] : Unreal::StructName::MemberOffsets) \
    {                                      \
        Output::send(STR(#StructName "::{} = 0x{:X}\n"), name, offset); \
    }

    auto output_all_member_offsets() -> void
    {
        Output::send(STR("\n##### MEMBER OFFSETS START #####\n\n"));
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UObjectBase);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UScriptStruct);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UScriptStruct::ICppStructOps);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FField);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FOutputDevice);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FEnumProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UStruct);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UFunction);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UField);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UWorld);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UClass);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(UEnum);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FObjectPropertyBase);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FDelegateProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FMulticastDelegateProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FSetProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FStructProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FArrayProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FMapProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FBoolProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FByteProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FClassProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FSoftClassProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FInterfaceProperty);
        OUTPUT_MEMBER_OFFSETS_FOR_STRUCT(FFieldPathProperty);
        Output::send(STR("\n##### MEMBER OFFSETS END #####\n\n"));
    }

    UE4SSProgram::UE4SSProgram(const std::wstring& moduleFilePath, std::initializer_list<BinaryOptions> options) : MProgram(options)
    {
        TIME_FUNCTION()

        s_program = this;

        try
        {
            setup_paths(moduleFilePath);

            try
            {
                settings_manager.deserialize(m_settings_path_and_file);
            }
            catch (std::exception& e)
            {
                create_emergency_console_for_early_error(std::format(STR("The IniParser failed to parse: {}"), to_wstring(e.what())));
                return;
            }

            // Setup the log file
            auto& file_device = Output::set_default_devices<Output::NewFileDevice>();
            //auto& file_device = Output::get_device<Output::NewFileDevice>();
            file_device.set_file_name_and_path(m_log_directory / m_log_file_name);

            m_simple_console_enabled = settings_manager.Debug.SimpleConsoleEnabled;
            m_debug_console_enabled = settings_manager.Debug.DebugConsoleEnabled;
            m_debug_console_visible = settings_manager.Debug.DebugConsoleVisible;

            create_debug_console();
            setup_output_devices();

            // This is experimental code that's here only for future reference
            /*
            Unreal::UnrealInitializer::SetupUnrealModules();

            constexpr const wchar_t* str_to_find = STR("Allocator: %s");
            void* string_address = SinglePassScanner::string_scan(str_to_find, ScanTarget::Core);
            Output::send(STR("\n\nFound string '{}' at {}\n\n"), std::wstring_view{str_to_find}, string_address);
            //*/

            Output::send(STR("Console created\n"));
            Output::send(STR("UE4SS - v{}.{}.{}{}{} - Build #{}\n"),
                         UE4SS_LIB_VERSION_MAJOR,
                         UE4SS_LIB_VERSION_MINOR,
                         UE4SS_LIB_VERSION_HOTFIX,
                         std::format(L"{}", UE4SS_LIB_VERSION_PRERELEASE == 0 ? L"" : std::format(L" PreRelease #{}", UE4SS_LIB_VERSION_PRERELEASE)),
                         std::format(L"{}", UE4SS_LIB_BETA_STARTED == 0 ? L"" : (UE4SS_LIB_IS_BETA == 0 ? L" Beta #?" : std::format(L" Beta #{}", UE4SS_LIB_VERSION_BETA))),
                         UE4SS_LIB_BUILD_NUMBER);
#ifdef WITH_CASE_PRESERVING_NAME
            Output::send(STR("WITH_CASE_PRESERVING_NAME: Yes\n\n"));
#else
            Output::send(STR("WITH_CASE_PRESERVING_NAME: No\n\n"));
#endif

            setup_mod_directory_path();

            if (m_has_game_specific_config)
            {
                Output::send(STR("Found configuration for game: {}\n"), m_mods_directory.parent_path().filename().c_str());
            }
            else
            {
                Output::send(STR("No specific game configuration found, using default configuration file\n"));
            }

            Output::send(STR("Config: {}\n\n"), m_settings_path_and_file.c_str());
            Output::send(STR("root directory: {}\n"), m_root_directory.c_str());
            Output::send(STR("working directory: {}\n"), m_working_directory.c_str());
            Output::send(STR("game executable directory: {}\n"), m_game_executable_directory.c_str());
            Output::send(STR("mods directory: {}\n"), m_mods_directory.c_str());
            Output::send(STR("log directory: {}\n"), m_log_directory.c_str());
            Output::send(STR("object dumper directory: {}\n\n\n"), m_object_dumper_output_directory.c_str());

            setup_unreal();
            setup_unreal_properties();
            UAssetRegistry::SetMaxMemoryUsageDuringAssetLoading(settings_manager.Memory.MaxMemoryUsageDuringAssetLoading);

            output_all_member_offsets();

            share_lua_functions();

            // Only deal with the event loop thread here if the 'Test' constructor doesn't need to be called
#ifndef RUN_TESTS
            // Program is now fully setup
            // Start event loop
            m_event_loop = std::jthread{&UE4SSProgram::update, this};

            // Wait for thread
            // There's a loop inside the thread that only exits when you hit the 'End' key on the keyboard
            // As long as you don't do that the thread will stay open and accept further inputs
            m_event_loop.join();
#endif
        }
        catch (std::runtime_error& e)
        {
            // Returns to main from here which checks, displays & handles whether to close the program or not
            // If has_error() returns false that means that set_error was not called
            // In that case we need to copy the exception message to the error buffer before we return to main
            if (!m_error_object->has_error())
            {
                copy_error_into_message(e.what());

            }
            return;
        }
    }

    UE4SSProgram::~UE4SSProgram()
    {
        // Shut down the event loop
        m_processing_events = false;

        // It's possible that main() will destroy the default devices (they are static)
        // However it's also possible that this program object is constructed in a context where main() is not gonna immediately exit
        // Because of that and because the default devices are created in the constructor, it's preferred to explicitly close all default devices in the destructor
        Output::close_all_default_devices();
    }

    auto UE4SSProgram::setup_paths(const std::wstring& moduleFilePathString) -> void
    {
        const std::filesystem::path moduleFilePath = std::filesystem::path(moduleFilePathString);
        m_root_directory = moduleFilePath.parent_path().wstring();
        m_module_file_path = moduleFilePath.wstring();

        // The default working directory is the root directory
        // Can be changed by creating a <GameName> directory in the root directory
        // At that point, the working directory will be "root/<GameName>"
        m_working_directory = m_root_directory;

        // Default file to open if there is no game specific config
        m_default_settings_path_and_file = m_root_directory / m_settings_file_name;

        wchar_t exe_path_buffer[1024];
        GetModuleFileNameW(GetModuleHandle(nullptr), exe_path_buffer, 1023);
        std::filesystem::path game_exe_path = exe_path_buffer;
        std::filesystem::path game_directory_path = game_exe_path.parent_path();
        m_working_directory = m_root_directory;
        m_mods_directory = m_working_directory / "Mods";
        m_game_executable_directory = game_directory_path/*game_exe_path.parent_path()*/;
        m_settings_path_and_file = m_root_directory;
        m_game_path_and_exe_name = game_exe_path;
        m_object_dumper_output_directory = m_game_executable_directory;

        bool has_game_specific_config{};
        for (const auto& item : std::filesystem::directory_iterator(m_root_directory))
        {
            if (!item.is_directory()) { continue; }

            if (item.path().filename() == game_directory_path.parent_path().parent_path().parent_path().filename())
            {
                m_has_game_specific_config = true;
                m_working_directory = item.path();
                m_mods_directory = item.path().wstring() + L"\\Mods";
                m_settings_path_and_file = std::move(item.path());
                m_log_directory = m_working_directory;
                m_object_dumper_output_directory = m_working_directory;
                break;
            }
        }

        m_log_directory = m_working_directory;
        m_settings_path_and_file.append(m_settings_file_name);
    }

    auto UE4SSProgram::create_emergency_console_for_early_error(File::StringViewType error_message) -> void
    {
        m_simple_console_enabled = true;
        create_debug_console();
        printf_s("%S\n", error_message.data());
    }

    auto UE4SSProgram::setup_mod_directory_path() -> void
    {
        // Mods folder path, typically '<m_working_directory>\Mods'
        // Can be customized via UE4SS-settings.ini
        if (settings_manager.Overrides.ModsFolderPath.empty())
        {
            m_mods_directory = m_mods_directory.empty() ? m_working_directory / "Mods" : m_mods_directory;
        }
        else
        {
            m_mods_directory = settings_manager.Overrides.ModsFolderPath;
        }
    }

    auto UE4SSProgram::create_debug_console() -> void
    {
        if (m_simple_console_enabled)
        {
            if (AllocConsole())
            {
                FILE* stdin_filename;
                FILE* stdout_filename;
                FILE* stderr_filename;
                freopen_s(&stdin_filename, "CONIN$", "r", stdin);
                freopen_s(&stdout_filename, "CONOUT$", "w", stdout);
                freopen_s(&stderr_filename, "CONOUT$", "w", stderr);
            }

        }
        if (m_debug_console_enabled && m_debug_console_visible)
        {
            m_render_thread = std::jthread{ &GUI::gui_thread, &m_debugging_gui };
        }
    }

    auto UE4SSProgram::load_unreal_offsets_from_file() -> void
    {
        std::filesystem::path file_path = m_working_directory / "MemberVariableLayout.ini";
        if (std::filesystem::exists(file_path))
        {
            auto file = File::open(file_path);
            if (auto file_contents = file.read_all(); !file_contents.empty())
            {
                Ini::Parser parser;
                parser.parse(file_contents);
                file.close();

                // The following code is auto-generated.
#include <MacroSetter.hpp>
            }
        }
    }

    auto UE4SSProgram::setup_unreal() -> void
    {
        // Retrieve offsets from the config file
        const std::wstring offset_overrides_section{L"OffsetOverrides"};
        using MemberOffsets = Unreal::StaticOffsetFinder::MemberOffsets;

        load_unreal_offsets_from_file();

        Unreal::UnrealInitializer::Config config;
        config.CachePath = m_root_directory / "cache";
        config.bInvalidateCacheIfSelfChanged = settings_manager.General.InvalidateCacheIfDLLDiffers;
        config.bEnableCache = true;
        config.NumScanAttemptsNormal = settings_manager.General.MaxScanAttemptsNormal;
        config.NumScanAttemptsModular = settings_manager.General.MaxScanAttemptsModular;
        config.bUseUObjectArrayCache = settings_manager.General.UseUObjectArrayCache;

        // Retrieve from the config file the number of threads to be used for aob scanning
        {
            // The config system only directly supports signed 64-bit integers
            // I'm using '-1' for the default and then only proceeding with using the value from the config file if it's within the
            // range of an unsigned 32-bit integer (which is what the SinglePassScanner uses)
            // The variables for these settings are default initialized with valid values so no need to set them if the config value
            // was either missing or invalid
            int64_t num_threads_for_scanner_from_config = settings_manager.Threads.SigScannerNumThreads;

            // The scanner is expecting a uint32_t so lets make sure we can safely convert to a uint32_t
            if (num_threads_for_scanner_from_config <= std::numeric_limits<uint32_t>::max() && num_threads_for_scanner_from_config >= 1)
            {
                config.NumScanThreads = static_cast<uint32_t>(num_threads_for_scanner_from_config);
            }
        }

        {
            int64_t multithreading_module_size_threshold_from_config = settings_manager.Threads.SigScannerMultithreadingModuleSizeThreshold;

            if (multithreading_module_size_threshold_from_config <= std::numeric_limits<uint32_t>::max() && multithreading_module_size_threshold_from_config >= std::numeric_limits<uint32_t>::min())
            {
                config.MultithreadingModuleSizeThreshold = static_cast<uint32_t>(multithreading_module_size_threshold_from_config);
            }
        }

        // Version override from ini file
        {
            int64_t major_version = settings_manager.EngineVersionOverride.MajorVersion;
            int64_t minor_version = settings_manager.EngineVersionOverride.MinorVersion;

            if (major_version != -1 && minor_version != -1)
            {
                // clang-format off
                if (major_version < std::numeric_limits<uint32_t>::min() ||
                    major_version > std::numeric_limits<uint32_t>::max() ||
                    minor_version < std::numeric_limits<uint32_t>::min() ||
                    minor_version > std::numeric_limits<uint32_t>::max())
                {
                    throw std::runtime_error{
                            "Was unable to override engine version from ini file; The number in the ini file must be in range of a uint32"};
                }
                // clang-format on

                Unreal::Version::Major = static_cast<uint32_t>(major_version);
                Unreal::Version::Minor = static_cast<uint32_t>(minor_version);

                config.ScanOverrides.version_finder = [&]([[maybe_unused]]auto&, Unreal::Signatures::ScanResult&) {};
            }
        }

        // If any Lua scripts are found, add overrides so that the Lua script can perform the aob scan instead of the Unreal API itself
        setup_lua_scan_overrides(m_working_directory, config);

        // Virtual function offset overrides
        TRY([&]() {
            static File::StringType virtual_function_offset_override_file{(m_working_directory / STR("VTableLayout.ini")).wstring()};
            if (std::filesystem::exists(virtual_function_offset_override_file))
            {
                auto file = File::open(virtual_function_offset_override_file, File::OpenFor::Reading, File::OverwriteExistingFile::No, File::CreateIfNonExistent::No);
                Ini::Parser parser;
                parser.parse(file);

                Output::send(STR("Getting ordered lists from ini file\n"));

                auto calculate_virtual_function_offset = []<typename... BaseSizes>(uint32_t current_index, BaseSizes... base_sizes) -> uint32_t {
                    return current_index == 0 ? 0 : (current_index + (base_sizes + ...)) * 8;
                };

                auto retrieve_vtable_layout_from_ini = [&](const File::StringType& section_name, auto callable) -> uint32_t {
                    auto list = parser.get_ordered_list(section_name);
                    uint32_t vtable_size = list.size() - 1;
                    list.for_each([&](uint32_t index, File::StringType& item) {
                        callable(index, item);
                    });
                    return vtable_size;
                };

                Output::send(STR("UObjectBase\n"));
                uint32_t uobjectbase_size = retrieve_vtable_layout_from_ini(STR("UObjectBase"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, 0);
                    Output::send(STR("UObjectBase::{} = 0x{:X}\n"), item, offset);
                    Unreal::UObjectBase::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("UObjectBaseUtility\n"));
                uint32_t uobjectbaseutility_size = retrieve_vtable_layout_from_ini(STR("UObjectBaseUtility"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, uobjectbase_size);
                    Output::send(STR("UObjectBaseUtility::{} = 0x{:X}\n"), item, offset);
                    Unreal::UObjectBaseUtility::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("UObject\n"));
                uint32_t uobject_size = retrieve_vtable_layout_from_ini(STR("UObject"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, uobjectbase_size, uobjectbaseutility_size);
                    Output::send(STR("UObject::{} = 0x{:X}\n"), item, offset);
                    Unreal::UObject::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("UField\n"));
                uint32_t ufield_size = retrieve_vtable_layout_from_ini(STR("UField"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, uobjectbase_size, uobjectbaseutility_size, uobject_size);
                    Output::send(STR("UField::{} = 0x{:X}\n"), item, offset);
                    Unreal::UStruct::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("UScriptStruct::ICppStructOps\n"));
                retrieve_vtable_layout_from_ini(STR("UScriptStruct::ICppStructOps"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, 0);
                    Output::send(STR("UScriptStruct::ICppStructOps::{} = 0x{:X}\n"), item, offset);
                    Unreal::UScriptStruct::ICppStructOps::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FField\n"));
                uint32_t ffield_size = retrieve_vtable_layout_from_ini(STR("FField"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, 0);
                    Output::send(STR("FField::{} = 0x{:X}\n"), item, offset);
                    Unreal::FField::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FProperty\n"));
                uint32_t fproperty_size = retrieve_vtable_layout_from_ini(STR("FProperty"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset{};
                    if (Unreal::Version::IsBelow(4, 25))
                    {
                        offset = calculate_virtual_function_offset(index, uobjectbase_size, uobjectbaseutility_size, uobject_size, ufield_size);
                    }
                    else
                    {
                        offset = calculate_virtual_function_offset(index, ffield_size);
                    }
                    Output::send(STR("FProperty::{} = 0x{:X}\n"), item, offset);
                    Unreal::FProperty::VTableLayoutMap.emplace(item, offset);
                });

                // If the engine version is <4.25 then the inheritance is different and we must take that into consideration.
                if (Unreal::Version::IsBelow(4, 25))
                {
                    fproperty_size = uobjectbase_size + uobjectbaseutility_size + uobject_size + ufield_size + fproperty_size;
                }
                else
                {
                    fproperty_size = ffield_size + fproperty_size;
                }

                Output::send(STR("FNumericProperty\n"));
                retrieve_vtable_layout_from_ini(STR("FNumericProperty"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, fproperty_size);
                    Output::send(STR("FNumericProperty::{} = 0x{:X}\n"), item, offset);
                    Unreal::FNumericProperty::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FMulticastDelegateProperty\n"));
                retrieve_vtable_layout_from_ini(STR("FMulticastDelegateProperty"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, fproperty_size);
                    Output::send(STR("FMulticastDelegateProperty::{} = 0x{:X}\n"), item, offset);
                    Unreal::FMulticastDelegateProperty::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FObjectPropertyBase\n"));
                retrieve_vtable_layout_from_ini(STR("FObjectPropertyBase"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, fproperty_size);
                    Output::send(STR("FObjectPropertyBase::{} = 0x{:X}\n"), item, offset);
                    Unreal::FObjectPropertyBase::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("UStruct\n"));
                uint32_t ustruct_size = retrieve_vtable_layout_from_ini(STR("UStruct"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, uobjectbase_size, uobjectbaseutility_size, uobject_size, ufield_size);
                    Output::send(STR("UStruct::{} = 0x{:X}\n"), item, offset);
                    Unreal::UField::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FOutputDevice\n"));
                retrieve_vtable_layout_from_ini(STR("FOutputDevice"), [&](uint32_t index, File::StringType& item) {
                    uint32_t offset = calculate_virtual_function_offset(index, 0);
                    Output::send(STR("FOutputDevice::{} = 0x{:X}\n"), item, offset);
                    Unreal::FOutputDevice::VTableLayoutMap.emplace(item, offset);
                });

                Output::send(STR("FMalloc\n"));
                retrieve_vtable_layout_from_ini(STR("FMalloc"), [&](uint32_t index, File::StringType& item) {
                    // We don't support FExec, so we're manually telling it the size.
                    static constexpr uint32_t fexec_size = 1;
                    uint32_t offset = calculate_virtual_function_offset(index, fexec_size);
                    Output::send(STR("FMalloc::{} = 0x{:X}\n"), item, offset);
                    Unreal::FMalloc::VTableLayoutMap.emplace(item, offset);
                });

                file.close();
            }
        });

        Unreal::UnrealInitializer::Initialize(config);
    }

    auto UE4SSProgram::share_lua_functions() -> void
    {
        m_shared_functions.set_script_variable_int32_function = &LuaLibrary::set_script_variable_int32;
        m_shared_functions.set_script_variable_default_data_function = &LuaLibrary::set_script_variable_default_data;
        m_shared_functions.call_script_function_function = &LuaLibrary::call_script_function;
        m_shared_functions.is_ue4ss_initialized_function = &LuaLibrary::is_ue4ss_initialized;
        Output::send(STR("m_shared_functions: {}\n"), static_cast<void*>(&m_shared_functions));
    }

    static FName g_player_controller_name{};

    auto UE4SSProgram::on_program_start() -> void
    {
        using namespace Unreal;

        // Commented out because this system (turn off hotkeys when in-game console is open) it doesn't work properly.
        /*
        UObjectArray::AddUObjectCreateListener(&FUEDeathListener::UEDeathListener);
        //*/

        if (m_debug_console_enabled)
        {
            m_debugging_gui.get_live_view().set_listeners();

            m_input_handler.register_keydown_event(Input::Key::O, { Input::ModifierKey::CONTROL }, [&]() {
                TRY([&] {
                    if (!get_debugging_ui().is_open())
                    {
                        if (m_render_thread.joinable())
                        {
                            m_render_thread.request_stop();
                            m_render_thread.join();
                        }
                        m_render_thread = std::jthread{ &GUI::gui_thread, &m_debugging_gui };
                    }
                    });
                });
        }

#ifdef TIME_FUNCTION_MACRO_ENABLED
        m_input_handler.register_keydown_event(Input::Key::Y, { Input::ModifierKey::CONTROL }, [&]() {
            if (FunctionTimerFrame::s_timer_enabled)
            {
                FunctionTimerFrame::stop_profiling();
                FunctionTimerFrame::dump_profile();
                Output::send(STR("Profiler stopped & dumped\n"));
            }
            else
            {
                FunctionTimerFrame::start_profiling();
                Output::send(STR("Profiler started\n"));
            }
        });
#endif

        /*
        m_input_handler.register_keydown_event(Input::Key::I, {Input::ModifierKey::CONTROL}, [&]() {
            TRY([&] {
                auto AssetRegistry = Cast<UAssetRegistry>(UAssetRegistryHelpers::GetAssetRegistry().ObjectPointer);
                if (!AssetRegistry)
                {
                    Output::send(STR("AssetRegistry was nullptr\n"));
                }
                else
                {
                    auto& interfaces = AssetRegistry->GetClassPrivate()->GetInterfaces();
                    interfaces.ForEach([&](const RC::Unreal::FImplementedInterface* the_interface) {
                        Output::send(STR("Interface: {}\n"), the_interface->Class->GetFullName());
                        return LoopAction::Continue;
                    });
                    auto f = AssetRegistry->GetFunctionByNameInChain(STR("GetAllAssets"));
                    Output::send(STR("Function: {}\n"), f ? f->GetFullName() : STR("None"));

                    ::RC::Unreal::TArray<FAssetData> AllAssets{nullptr, 0, 0};
                    AssetRegistry->GetAllAssets2(AllAssets, false);
                }
            });
        });
        //*/

        TRY([&] {
            ObjectDumper::init();

            if (settings_manager.General.EnableHotReloadSystem)
            {
                m_input_handler.register_keydown_event(Input::Key::R, {Input::ModifierKey::CONTROL}, [&]() {
                    TRY([&] { reinstall_mods(); });
                });
            }

            if ((settings_manager.ObjectDumper.LoadAllAssetsBeforeDumpingObjects || settings_manager.CXXHeaderGenerator.LoadAllAssetsBeforeGeneratingCXXHeaders) && Unreal::Version::IsBelow(4, 17))
            {
                Output::send<LogLevel::Warning>(STR("FAssetData not available in <4.17, ignoring 'LoadAllAssetsBeforeDumpingObjects' & 'LoadAllAssetsBeforeGeneratingCXXHeaders'."));
            }

            m_input_handler.register_keydown_event(Input::Key::Y, {Input::ModifierKey::CONTROL}, [&]() {
                TRY([&] {
                    AActor* character = Unreal::Cast<AActor>(UObjectGlobals::FindFirstOf(STR("Character")));
                    Output::send(STR("Name from auto-generated getter: {}\n"), character->GetNamePrivate().ToString());
                    // UObjectGlobals::StaticFindObject<UGameplayStatics*>(nullptr, nullptr, STR("/Script/Engine.Default__GameplayStatics"));
                    UClass* to_spawn{};
                    if (Unreal::Version::IsBelow(5, 0))
                    {
                        to_spawn = Unreal::Cast<UClass>(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Game/FirstPersonCPP/Blueprints/FirstPersonProjectile.FirstPersonProjectile_C")));
                    }
                    else
                    {
                        to_spawn = Unreal::Cast<UClass>(UObjectGlobals::FindObject(nullptr, nullptr, STR("/Game/FirstPerson/Blueprints/BP_FirstPersonProjectile.BP_FirstPersonProjectile_C")));
                    }

                    Output::send(STR("500+{:X}, Pre500{:X}\n"), sizeof(Unreal::FTransform_As500Plus), sizeof(Unreal::FTransform_AsPre500));

                    Output::send(STR("to_spawn: {}\n"), to_spawn->GetFullName());
                    Unreal::FTransform transform = character->GetTransform();
                    //AActor* actor = Unreal::UGameplayStatics::BeginDeferredActorSpawnFromClass(character->GetWorld(), to_spawn, transform);
                    //Loc: -351.000366 -99.000000 268.373718
                    //RotatorAsVector.X: 0.996715
                    //RotatorAsVector.Y: -0.079046
                    //RotatorAsVector.Z: 0.017607
                    //Final X: -278.083986
                    //Final Y: 2.134236
                    //Final Z: 5111.598653
                    float X = -351.000366f;
                    X += (72.f * 0.996715 + 0.f) * 15.f;
                    float Y = -99.000000f;
                    Y += (72.f * -0.079046 + 0.f) * 15.f;
                    float Z = 268.373718f;
                    Z += 72.f * 0.017607 + 1.f * 15.f;
                    Output::send(STR("X test: {}\n"), X);
                    Output::send(STR("Y test: {}\n"), Y);
                    Output::send(STR("Z test: {}\n"), Z);
                    AActor* actor = character->GetWorld()->SpawnActor(to_spawn, &transform);
                    if (actor)
                    {
                        Output::send(STR("actor: {} {}\n"), (void*)actor, actor->GetFullName());
                        Unreal::FTransform t = actor->GetTransform();
                        Output::send(STR("actor loc: {} {} {}\n"), t.Translation().X(), t.Translation().Y(), t.Translation().Z());
                    }
                    else
                    {
                        Output::send(STR("actor was nullptr\n"));
                    }

                    /*
                    actor = Unreal::UGameplayStatics::FinishSpawningActor(actor, transform);
                    if (actor)
                    {
                        Output::send(STR("actor: {} {}\n"), (void*)actor, actor->GetFullName());
                    }
                    else
                    {
                        Output::send(STR("actor was nullptr\n"));
                    }
                    //*/
                });
            });

            setup_mods();
            Mod::on_program_start();
            start_mods();

            FName fname{STR("Controller")};
            FStringOut fstring{};
            FName::ToStringInternal(&fname, fstring);
            const Unreal::TArray<TCHAR>& tarray = fstring.GetCharTArray();
            Unreal::FScriptArray* fscriptarray = std::bit_cast<Unreal::FScriptArray*>(&tarray);
            printf_s("Data: %p\n", fscriptarray->GetData());
            printf_s("Num: %i\n", fscriptarray->Num());
            printf_s("Max: %i\n", fscriptarray->Max());
        });

        if (settings_manager.General.EnableDebugKeyBindings)
        {
            m_input_handler.register_keydown_event(Input::Key::NUM_NINE, {Input::ModifierKey::CONTROL}, [&]() {
                generate_uht_compatible_headers();
            });
        }
    }

    auto UE4SSProgram::update() -> void
    {
        on_program_start();

        Output::send(STR("Event loop start\n"));
        for (m_processing_events = true; m_processing_events;)
        {
            if (m_pause_events_processing || UE4SSProgram::unreal_is_shutting_down) { continue; }

            if (!is_queue_empty())
            {
                static constexpr size_t max_events_executed_per_frame = 5;
                size_t num_events_executed{};
                std::lock_guard<std::mutex> guard(m_event_queue_mutex);
                m_queued_events.erase(std::remove_if(m_queued_events.begin(), m_queued_events.end(), [&](Event& event) -> bool {
                    if (num_events_executed >= max_events_executed_per_frame) { return false; }
                    ++num_events_executed;
                    event.callable(event.data);
                    return true;
                }), m_queued_events.end());
            }

            // Commented out because this system (turn off hotkeys when in-game console is open) it doesn't work properly.
            /*
            auto* player_controller = get_player_controller();
            if (player_controller)
            {
                auto** player = player_controller->GetValuePtrByPropertyName<UObject*>(STR("Player"));
                if (player && *player)
                {
                    auto** viewportclient = (*player)->GetValuePtrByPropertyName<UObject*>(STR("ViewportClient"));
                    if (viewportclient && *viewportclient)
                    {
                        auto** console = (*viewportclient)->GetValuePtrByPropertyName<UObject*>(STR("ViewportConsole"));
                        if (console && *console)
                        {
                            auto* console_state = std::bit_cast<FName*>(static_cast<uint8_t*>((*console)->GetValuePtrByPropertyNameInChain(STR("HistoryBuffer"))) + 0x70);
                            m_input_handler.set_allow_input(console_state && *console_state == Unreal::NAME_None);
                        }
                    }
                }
            }
            //*/

            m_input_handler.process_event();
            Mod::update();

            std::this_thread::sleep_for(std::chrono::milliseconds(5));
        }
        Output::send(STR("Event loop end\n"));
    }

    auto UE4SSProgram::setup_unreal_properties() -> void
    {
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"ObjectProperty").GetComparisonIndex(), &LuaType::push_objectproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"ClassProperty").GetComparisonIndex(), &LuaType::push_classproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"Int8Property").GetComparisonIndex(), &LuaType::push_int8property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"Int16Property").GetComparisonIndex(), &LuaType::push_int16property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"IntProperty").GetComparisonIndex(), &LuaType::push_intproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"Int64Property").GetComparisonIndex(), &LuaType::push_int64property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"ByteProperty").GetComparisonIndex(), &LuaType::push_byteproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"UInt16Property").GetComparisonIndex(), &LuaType::push_uint16property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"UInt32Property").GetComparisonIndex(), &LuaType::push_uint32property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"UInt64Property").GetComparisonIndex(), &LuaType::push_uint64property);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"StructProperty").GetComparisonIndex(), &LuaType::push_structproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"ArrayProperty").GetComparisonIndex(), &LuaType::push_arrayproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"FloatProperty").GetComparisonIndex(), &LuaType::push_floatproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"DoubleProperty").GetComparisonIndex(), &LuaType::push_doubleproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"BoolProperty").GetComparisonIndex(), &LuaType::push_boolproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"EnumProperty").GetComparisonIndex(), &LuaType::push_enumproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"WeakObjectProperty").GetComparisonIndex(), &LuaType::push_weakobjectproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"NameProperty").GetComparisonIndex(), &LuaType::push_nameproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"TextProperty").GetComparisonIndex(), &LuaType::push_textproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"StrProperty").GetComparisonIndex(), &LuaType::push_strproperty);
        LuaType::StaticState::m_property_value_pushers.emplace(FName(L"SoftClassProperty").GetComparisonIndex(), &LuaType::push_softclassproperty);
    }

    auto UE4SSProgram::setup_mods() -> void
    {
        Output::send(STR("Setting up mods...\n"));

        if (!std::filesystem::exists(m_mods_directory))
        {
            set_error("Mods directory doesn't exist, please create it: <%S>", m_mods_directory.c_str());
        }

        for (const auto& sub_directory : std::filesystem::directory_iterator(m_mods_directory))
        {
            std::error_code ec;

            // Ignore all non-directories
            if (!sub_directory.is_directory()) { continue; }
            if (ec.value() != 0) { set_error("is_directory ran into error %d", ec.value()); }

            std::wstring directory_lowercase = sub_directory.path().stem().wstring();
            std::transform(directory_lowercase.begin(), directory_lowercase.end(), directory_lowercase.begin(), std::towlower);

            if (directory_lowercase == L"shared")
            {
                // Do stuff when shared libraries have been implemented
            }
            else
            {
                // Create the mod but don't install it yet
                m_mods.emplace_back(std::make_unique<Mod>(*this, std::move(sub_directory.path().stem().wstring()), std::move(sub_directory.path().wstring())));
            }
        }

        install_mods();
    }

    auto UE4SSProgram::setup_output_devices() -> void
    {
        // Setup DynamicOutput
        if (m_simple_console_enabled)
        {
            m_debug_console_device = &Output::set_default_devices<Output::DebugConsoleDevice>();
            Output::set_default_log_level<LogLevel::Normal>();
            m_debug_console_device->set_formatter([](File::StringViewType string) -> File::StringType {
                return std::format(STR("[{}] {}"), std::format(STR("{:%X}"), std::chrono::system_clock::now()), string);
            });
        }

        if (m_debug_console_enabled)
        {
            m_console_device = &Output::set_default_devices<Output::ConsoleDevice>();
            m_console_device->set_formatter([](File::StringViewType string) -> File::StringType {
                return std::format(STR("[{}] {}"), std::format(STR("{:%X}"), std::chrono::system_clock::now()), string);
            });
        }
    }

    auto UE4SSProgram::install_mods() -> void
    {
        for (auto& mod : m_mods)
        {
            bool mod_name_is_taken = std::find_if(m_mods.begin(), m_mods.end(), [&](auto& elem) {
                return elem->get_name() == mod->get_name();
            }) == m_mods.end();

            if (mod_name_is_taken)
            {
                mod->set_installable(false);
                Output::send(STR("Mod name '{}' is already in use.\n"), mod->get_name());
                continue;
            }

            if (mod->is_installed())
            {
                Output::send(STR("Tried to install a mod that was already installed, Mod: '{}'\n"), mod->get_name());
                continue;
            }

            if (!mod->is_installable())
            {
                Output::send(STR("Was unable to install mod '{}' for unknown reasons. Mod is not installable.\n"), mod->get_name());
                continue;
            }

            mod->set_installed(true);
        }
    }

    auto UE4SSProgram::start_mods() -> void
    {
        // Part #1: Start all mods that are enabled in mods.txt.
        Output::send(STR("Starting mods (from mods.txt load order)...\n"));

        std::wstring enabled_mods_file{m_mods_directory / "mods.txt"};
        if (!std::filesystem::exists(enabled_mods_file))
        {
            Output::send(STR("No mods.txt file found...\n"));
        }
        else
        {
            // 'mods.txt' exists, lets parse it
            std::wifstream mods_stream{enabled_mods_file};

            size_t mod_count{};

            std::wstring current_line;
            while (std::getline(mods_stream, current_line))
            {
                // Don't parse any lines with ';'
                if (current_line.find(L";") != current_line.npos) { continue; }

                // Don't parse if the line is impossibly short (empty lines for example)
                if (current_line.size() <= 4) { continue; }

                // Increasing the mod counter but only after a valid line has been found
                ++mod_count;

                // Remove all spaces
                auto end = std::remove(current_line.begin(), current_line.end(), L' ');
                current_line.erase(end, current_line.end());

                // Parse the line into something that can be converted into proper data
                std::wstring mod_name = explode_by_occurrence(current_line, L':', 1);
                std::wstring mod_enabled = explode_by_occurrence(current_line, L':', ExplodeType::FromEnd);

                Mod* mod = find_mod_by_name(mod_name, IsInstalled::Yes);

                if (mod_enabled == L"1")
                {
                    if (!mod)
                    {
                        Output::send(STR("Tried to start non-existent mod '{}'\n"), mod_name);
                        continue;
                    }

                    Output::send(STR("Starting mod '{}'\n"), mod->get_name().data());
                    mod->start_mod();
                }
                else
                {
                    Output::send(STR("Mod '{}' disabled in mods.txt.\n"), mod_name);
                }
            }
        }

        // Part #2: Start all mods that have enabled.txt present in the mod directory.
        Output::send(STR("Starting mods (from enabled.txt, no defined load order)...\n"));

        for (const auto& mod_directory : std::filesystem::directory_iterator(m_mods_directory))
        {
            std::error_code ec{};

            if (!mod_directory.is_directory(ec)) { continue; }
            if (ec.value() != 0) { set_error("is_directory ran into error %d", ec.value()); }

            if (!std::filesystem::exists(mod_directory.path() / "enabled.txt", ec)) { continue; }
            if (ec.value() != 0) { set_error("exists ran into error %d", ec.value()); }

            auto mod = find_mod_by_name(mod_directory.path().stem().c_str(), IsInstalled::Yes);
            if (!mod)
            {
                Output::send<LogLevel::Warning>(STR("Found a mod with enabled.txt but mod has not been installed properly.\n"));
                continue;
            }
            
            if (mod->is_started()) { continue; }

            Output::send(STR("Mod '{}' has enabled.txt, starting mod.\n"), mod->get_name().data());
            mod->start_mod();
        }
    }

    auto UE4SSProgram::uninstall_mods() -> void
    {
        for (const auto& mod : m_mods)
        {
            // Remove any actions, or we'll get an internal error as the lua ref won't be valid
            mod->clear_delayed_actions();
            mod->uninstall();
        }

        m_mods.clear();
        Mod::m_static_construct_object_lua_callbacks.clear();
        Mod::m_global_command_lua_callbacks.clear();
        Mod::m_custom_command_lua_pre_callbacks.clear();
    }

    auto UE4SSProgram::reinstall_mods() -> void
    {
        Output::send(STR("Re-installing all mods\n"));

        // Stop processing events while stuff isn't properly setup
        m_pause_events_processing = true;

        uninstall_mods();

        // Remove key binds that were set from Lua scripts
        for (auto& input_event : m_input_handler.get_events())
        {
            for (auto&[key, vector_of_key_data] : input_event.key_data)
            {
                std::erase_if(vector_of_key_data, [](Input::KeyData& key_data) -> bool {
                    return key_data.custom_data == 1;
                });
            }
        }

        // Remove all custom properties
        // Uncomment when custom properties are working
        LuaType::LuaCustomProperty::StaticStorage::property_list.clear();

        // Reset the Lua callbacks for the global Lua function 'NotifyOnNewObject'
        Mod::m_static_construct_object_lua_callbacks.clear();

        // Start processing events again as everything is now properly setup
        // Do this before mods are started or else you won't be able to use the hot-reload key bind if there's an error from Lua
        m_pause_events_processing = false;

        setup_mods();
        start_mods();
        Output::send(STR("All mods re-installed\n"));
    }

    auto UE4SSProgram::get_working_directory() -> File::StringViewType
    {
        return m_working_directory.c_str();
    }

    auto UE4SSProgram::get_mods_directory() -> File::StringViewType
    {
        return m_mods_directory.c_str();
    }

    auto UE4SSProgram::generate_uht_compatible_headers() -> void
    {
        Output::send(STR("Generating UHT compatible headers...\n"));

        double generator_duration{};
        {
            ScopedTimer generator_timer{&generator_duration};

            const std::filesystem::path DumpRootDirectory = m_working_directory / "UHTHeaderDump";
            UEGenerator::UEHeaderGenerator HeaderGenerator = UEGenerator::UEHeaderGenerator(DumpRootDirectory);
            HeaderGenerator.dump_native_packages();
        }

        Output::send(STR("Generating UHT compatible headers took {} seconds\n"), generator_duration);
    }

    auto UE4SSProgram::generate_cxx_headers(const std::filesystem::path& output_dir) -> void
    {
        if (settings_manager.CXXHeaderGenerator.LoadAllAssetsBeforeGeneratingCXXHeaders)
        {
            Output::send(STR("Loading all assets...\n"));
            double asset_loading_duration{};
            {
                ScopedTimer loading_timer{&asset_loading_duration};

                UAssetRegistry::LoadAllAssets();
            }
            Output::send(STR("Loading all assets took {} seconds\n"), asset_loading_duration);
        }

        double generator_duration;
        {
            ScopedTimer generator_timer{&generator_duration};

            UEGenerator::CXXGenerator cxx_generator{output_dir};
            cxx_generator.generate();

            Output::send(STR("Unloading all forcefully loaded assets\n"));
        }

        UAssetRegistry::FreeAllForcefullyLoadedAssets();
        Output::send(STR("SDK generated in {} seconds.\n"), generator_duration);
    }

    auto UE4SSProgram::stop_render_thread() -> void
    {
        if (m_render_thread.joinable())
        {
            m_render_thread.request_stop();
            m_render_thread.join();
        }
    }

    auto UE4SSProgram::queue_event(EventCallable callable, void* data) -> void
    {
        if (!can_process_events()) { return; }
        std::lock_guard<std::mutex> guard(m_event_queue_mutex);
        m_queued_events.emplace_back(Event{callable, data});
    }

    auto UE4SSProgram::is_queue_empty() -> bool
    {
        // Not locking here because if the worst that could happen as far as I know is that the event loop processes the event slightly late.
        return m_queued_events.empty();
    }

    auto UE4SSProgram::register_keydown_event(Input::Key key, const Input::EventCallbackCallable& callback, uint8_t custom_data) -> void
    {
        m_input_handler.register_keydown_event(key, callback, custom_data);
    }

    auto UE4SSProgram::register_keydown_event(Input::Key key, const Input::Handler::ModifierKeyArray& modifier_keys, const Input::EventCallbackCallable& callback, uint8_t custom_data) -> void
    {
        m_input_handler.register_keydown_event(key, modifier_keys, callback, custom_data);
    }

    auto UE4SSProgram::find_mod_by_name(std::wstring_view mod_name, IsInstalled is_installed, IsStarted is_started) -> Mod*
    {
        auto mod_exists_with_name = std::find_if(m_mods.begin(), m_mods.end(), [&](auto& elem) -> bool {
            bool found = true;

            if (mod_name != elem->get_name()) { found = false; }
            if (is_installed == IsInstalled::Yes && !elem->is_installable()) { found = false; }
            if (is_started == IsStarted::Yes && !elem->is_started()) { found = false; }

            return found;
        });

        // clang-format off
        if (mod_exists_with_name == m_mods.end())
        {
            return nullptr;
        }
        // clang-format on
        else
        {
            return mod_exists_with_name->get();
        }
    }

    auto UE4SSProgram::find_mod_by_name(std::string_view mod_name, UE4SSProgram::IsInstalled installed_only, IsStarted is_started) -> Mod*
    {
        return find_mod_by_name(to_wstring(mod_name), installed_only, is_started);
    }

    auto UE4SSProgram::get_object_dumper_output_directory() -> const File::StringType
    {
        return m_object_dumper_output_directory.c_str();
    }

    auto UE4SSProgram::dump_all_objects_and_properties(const File::StringType& output_path_and_file_name) -> void
    {
        /*
        Output::send(STR("Test msg with no fmt args, and no optional arg\n"));
        Output::send(STR("Test msg with no fmt args, and one optional arg [Normal]\n"), LogLevel::Normal);
        Output::send(STR("Test msg with no fmt args, and one optional arg [Verbose]\n"), LogLevel::Verbose);
        Output::send(STR("Test msg with one fmt arg [{}], and one optional arg [Warning]\n"), LogLevel::Warning, 33);
        Output::send(STR("Test msg with two fmt args [{}, {}], and one optional arg [Error]\n"), LogLevel::Error, 33, 44);
        //*/

        // Object & Property Dumper -> START
        if (settings_manager.ObjectDumper.LoadAllAssetsBeforeDumpingObjects)
        {
            Output::send(STR("Loading all assets...\n"));
            double asset_loading_duration{};
            {
                ScopedTimer loading_timer{&asset_loading_duration};

                UAssetRegistry::LoadAllAssets();
            }
            Output::send(STR("Loading all assets took {} seconds\n"), asset_loading_duration);
        }

        double dumper_duration{};
        {
            ScopedTimer dumper_timer{&dumper_duration};

            std::unordered_set<FField*> dumped_fields;
            // There will be tons of dumped fields so lets just reserve tons in order to speed things up a bit
            dumped_fields.reserve(100000);

            bool is_below_425 = Unreal::Version::IsBelow(4, 25);

            // The final outputted string shouldn't need be reformatted just to put a new line at the end
            // Instead the object/property implementations should add a new line in the last format that they do
            //
            // Optimizations done:
            // 1. The entire code-base has been changed to use 'wchar_t' instead of 'char'.
            // The effect of this is that there is no need to ever convert between types.
            // There's also no thinking about which type should be used since 'wchar_t' is now the standard for UE4SS.
            // The downside with wchar_t is that all files that get output to will be doubled in size.

            using ObjectDumperOutputDevice = Output::NewFileDevice;
            Output::Targets<ObjectDumperOutputDevice> scoped_dumper_out;
            auto& file_device = scoped_dumper_out.get_device<ObjectDumperOutputDevice>();
            file_device.set_file_name_and_path(output_path_and_file_name);
            file_device.set_formatter([](File::StringViewType string) -> File::StringType {
                return File::StringType{string};
            });

            // Make string & reserve massive amounts of space to hopefully not reach the end of the string and require more
            // dynamic allocations
            std::wstring out_line;
            out_line.reserve(200000000);

            auto dump_xproperty = [&](FProperty* property) -> void {
                auto typed_prop_class = property->GetClass().HashObject();

                if (ObjectDumper::to_string_exists(typed_prop_class))
                {
                    ObjectDumper::get_to_string(typed_prop_class)(property, out_line);
                    out_line.append(L"\n");

                    if (ObjectDumper::to_string_complex_exists(typed_prop_class))
                    {
                        ObjectDumper::get_to_string_complex(typed_prop_class)(property, out_line, [&]([[maybe_unused]]void* prop) {
                            out_line.append(L"\n");
                        });
                    }
                }
                else
                {
                    ObjectDumper::property_to_string(property, out_line);
                    out_line.append(L"\n");
                }
            };

            auto dump_uobject = [&](void* object) -> void {
                UObject* typed_obj = static_cast<UObject*>(object);

                if (is_below_425 && Unreal::TypeChecker::is_property(typed_obj) && !typed_obj->HasAnyFlags(static_cast<EObjectFlags>(EObjectFlags::RF_DefaultSubObject | EObjectFlags::RF_ArchetypeObject)))
                {
                    // We've verified that we're in <4.25 so this cast is safe but should be abstracted at some point
                    dump_xproperty(std::bit_cast<FProperty*>(typed_obj));
                }
                else
                {
                    auto typed_class = typed_obj->GetClassPrivate()->HashObject();
                    if (ObjectDumper::to_string_exists(typed_class))
                    {
                        // Call type-specific implementation to dump UObject
                        // The type is determined at runtime

                        // Dump UObject
                        ObjectDumper::get_to_string(typed_class)(object, out_line);
                        out_line.append(L"\n");

                        if (!is_below_425 && ObjectDumper::to_string_complex_exists(typed_class))
                        {
                            // Dump all properties that are directly owned by this UObject (not its UClass)
                            // UE 4.25+ (properties are part of GUObjectArray in earlier versions)
                            ObjectDumper::get_to_string_complex(typed_class)(object, out_line, [&](void* prop) {
                                if (dumped_fields.contains(static_cast<FField*>(prop))) { return; }

                                dump_xproperty(static_cast<FProperty*>(prop));
                                dumped_fields.emplace(static_cast<FField*>(prop));
                            });
                        }
                    }
                    else
                    {
                        // A type-specific implementation does not exist so lets call the default implementation for UObjects instead
                        ObjectDumper::object_to_string(object, out_line);
                        out_line.append(L"\n");
                    }

                    // If the UClass of the UObject has any properties then dump them
                    // UE 4.25+ (properties are part of GUObjectArray in earlier versions)
                    if (!is_below_425)
                    {
                        if (typed_obj->IsA<UStruct>())
                        {
                            static_cast<UClass*>(typed_obj)->ForEachProperty([&](FProperty* prop) {
                                if (dumped_fields.contains(prop)) { return LoopAction::Continue; }

                                dump_xproperty(prop);
                                dumped_fields.emplace(prop);

                                return LoopAction::Continue;
                            });
                        }
                    }
                }
            };

            Output::send(STR("Dumping all objects & properties in GUObjectArray\n"));
            UObjectGlobals::ForEachUObject([&](void* object, [[maybe_unused]]int32_t chunk_index, [[maybe_unused]]int32_t object_index) {
                dump_uobject(object);
                return LoopAction::Continue;
            });

            // Save to file
            scoped_dumper_out.send(out_line);

            // Reset the dumped_fields set, otherwise no fields will be dumped in subsequent dumps
            dumped_fields.clear();
            Output::send(STR("Done iterating GUObjectArray\n"));
        }

        UAssetRegistry::FreeAllForcefullyLoadedAssets();
        Output::send(STR("Dumping GUObjectArray took {} seconds\n"), dumper_duration);
        // Object & Property Dumper -> END
    }

    auto UE4SSProgram::static_cleanup() -> void
    {
        delete &get_program();

        // Do cleanup of static objects here
        // This function is called right before the DLL detaches from the game
        // Including when the player hits the 'X' button to exit the game
#if TIME_FUNCTION_MACRO_V2 == 0
        FunctionTimerCollection::dump();
#endif
    }
}


```

`src/UnrealCustom/CustomProperty.cpp`:

```cpp
#include <UnrealCustom/CustomProperty.hpp>
#include <Unreal/StaticOffsetFinder.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/Property/FArrayProperty.hpp>

namespace RC::Unreal
{
    CustomProperty::CustomProperty(int32_t offset_internal, int32_t element_size)
    {
        //set_member_variable(MemberOffsets::XProperty_Offset_Internal, this, offset_internal);
        //set_member_variable(MemberOffsets::Property_PropertyFlags, -4, this, element_size);
        GetOffset_Internal() = offset_internal;
        GetElementSize() = element_size;
    }

    auto CustomProperty::construct(int32_t offset_internal, UClass* belongs_to_class, UClass* inner_class, int32_t element_size) -> std::unique_ptr<CustomProperty>
    {
        std::unique_ptr<CustomProperty> custom_property = std::make_unique<CustomProperty>(offset_internal, element_size);

        //set_member_variable(MemberOffsets::FField_Class, custom_property.get(), inner_class);

        if (Version::IsAtLeast(4, 25))
        {
            custom_property->SetClass(inner_class);
            //set_member_variable(MemberOffsets::FField_Owner, custom_property.get(), belongs_to_class);
            custom_property->SetOwnerVariant(belongs_to_class);
        }
        else
        {
            std::bit_cast<UObject*>(custom_property.get())->GetClassPrivate() = inner_class;
            //set_member_variable(MemberOffsets::UObject_OuterPrivate, custom_property.get(), belongs_to_class);
            std::bit_cast<UObject*>(custom_property.get())->GetOuterPrivate() = belongs_to_class;
        }

        return custom_property;
    }

    CustomArrayProperty::CustomArrayProperty(int32_t offset_internal, int32_t element_size) : CustomProperty(offset_internal, element_size) {}

    auto CustomArrayProperty::construct(int32_t offset_internal, FProperty* array_inner, int32_t element_size) -> std::unique_ptr<CustomProperty>
    {
        std::unique_ptr<CustomArrayProperty> custom_array_property = std::make_unique<CustomArrayProperty>(offset_internal, element_size);
        //set_member_variable(MemberOffsets::ArrayProperty_Inner, custom_array_property.get(), array_inner);
        std::bit_cast<FArrayProperty*>(custom_array_property.get())->GetInner() = array_inner;

        return custom_array_property;
    }

    auto CustomArrayProperty::construct(int32_t offset_internal, UClass* belongs_to_class, UClass* inner_class, FProperty* array_inner, int32_t element_size) -> std::unique_ptr<CustomProperty>
    {
        // Create dummy property to act as the 'Inner' member variable for the ArrayProperty
        // Then we set the inner type for the array property as the 'FFieldClass' of this dummy property
        CustomProperty* array_inner_property = new CustomProperty{0x0, element_size};
        //set_member_variable(MemberOffsets::FField_Class, array_inner_property, array_inner);
        array_inner_property->SetClass(array_inner);

        std::unique_ptr<CustomProperty> custom_array_property = CustomProperty::construct(offset_internal, belongs_to_class, inner_class, element_size);
        //set_member_variable(MemberOffsets::ArrayProperty_Inner, custom_array_property.get(), array_inner_property);
        std::bit_cast<FArrayProperty*>(custom_array_property.get())->GetInner() = array_inner_property;

        return custom_array_property;
    }

    CustomStructProperty::CustomStructProperty(int32_t offset_internal, int32_t element_size) : CustomProperty(offset_internal, element_size) {}

    auto CustomStructProperty::construct(int32_t offset_internal, UScriptStruct* script_struct, int32_t element_size) -> std::unique_ptr<CustomProperty>
    {
        std::unique_ptr<CustomStructProperty> custom_struct_property = std::make_unique<CustomStructProperty>(offset_internal, element_size);
        //set_member_variable(MemberOffsets::StructProperty_Struct, custom_struct_property.get(), script_struct);
        std::bit_cast<FStructProperty*>(custom_struct_property.get())->GetStruct() = script_struct;

        return custom_struct_property;
    }
}
```

`src/main_ue4ss_rewritten.cpp`:

```cpp
#define NOMINMAX
#include <Windows.h>
#include <cstdio>
#include <iostream>
#include <future>
#include <memory>

#include <DynamicOutput/DynamicOutput.hpp>
#include <Helpers/String.hpp>
#include "UE4SSProgram.hpp"

#if UE4SS_LIB_BUILD_AS_XINPUT
#define WIN_API_FUNCTION_NAME DllMain_Wrapped
#else
#define WIN_API_FUNCTION_NAME DllMain
#endif

using namespace RC;

// We're outside DllMain here
auto thread_dll_start([[maybe_unused]]LPVOID thread_param) -> unsigned long
{
    // Wrapper for entire program
    // Everything must be channeled through MProgram
    // One of the purposes for this is to forward any errors to main so that we can close or keep the window/console open
    // There is atleast one more purpose but I forgot what it was...

    HMODULE moduleHandle = reinterpret_cast<HMODULE>(thread_param);
    wchar_t moduleFilenameBuffer[1024] {'\0'};
    GetModuleFileNameW(moduleHandle, moduleFilenameBuffer, sizeof(moduleFilenameBuffer) / sizeof(wchar_t));

    auto program = new UE4SSProgram(moduleFilenameBuffer, {});

    if (auto e = program->get_error_object(); e->has_error())
    {
        // If the output system errored out then use printf_s as a fallback
        // Logging will only happen to the debug console but it's something at least
        if (!Output::has_internal_error())
        {
            Output::send<LogLevel::Error>(STR("Fatal Error: {}\n"), to_wstring(e->get_message()));
        }
        else
        {
            printf_s("Error: %s\n", e->get_message());
        }
    }

    return 0;
}

// We're still inside DllMain so be careful what you do here
auto dll_process_attached(HMODULE moduleHandle) -> void
{
    if (HANDLE handle = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(thread_dll_start), moduleHandle, 0, nullptr); handle)
    {
        CloseHandle(handle);
    }

    std::cin.get();
}

auto WIN_API_FUNCTION_NAME(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      [[maybe_unused]] LPVOID lpReserved
) -> BOOL
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            dll_process_attached(hModule);
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            UE4SSProgram::static_cleanup();
            break;
    }
    return TRUE;
}
```

`xinput/xinput1_3.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

//Declared in main_ue4ss_rewritten.cpp when building as xinput
extern BOOL DllMain_Wrapped(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved);

HMODULE mHinstDLL = 0;
extern "C" UINT_PTR mProcs[12] = {0};

void load_original_dll();

LPCSTR mImportNames[] = {
        "DllMain",
        "XInputEnable",
        "XInputGetBatteryInformation",
        "XInputGetCapabilities",
        "XInputGetDSoundAudioDeviceGuids",
        "XInputGetKeystroke",
        "XInputGetState",
        "XInputSetState",
        (LPCSTR)100,
        (LPCSTR)101,
        (LPCSTR)102,
        (LPCSTR)103};

BOOL WINAPI DllMain(HMODULE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
	if (fdwReason == DLL_PROCESS_ATTACH) {
		load_original_dll();
		for (int i = 0; i < 12; i++) {
			mProcs[i] = (UINT_PTR)GetProcAddress(mHinstDLL, mImportNames[i]);
		}
	}
	else if (fdwReason == DLL_PROCESS_DETACH) {
		FreeLibrary(mHinstDLL);
	}

    //Give control to the original UE4SS DllMain
	return DllMain_Wrapped(hinstDLL, fdwReason, lpvReserved);
}

extern "C" void DllMain_wrapper();
extern "C" void XInputEnable_wrapper();
extern "C" void XInputGetBatteryInformation_wrapper();
extern "C" void XInputGetCapabilities_wrapper();
extern "C" void XInputGetDSoundAudioDeviceGuids_wrapper();
extern "C" void XInputGetKeystroke_wrapper();
extern "C" void XInputGetState_wrapper();
extern "C" void XInputSetState_wrapper();
extern "C" void ExportByOrdinal100();
extern "C" void ExportByOrdinal101();
extern "C" void ExportByOrdinal102();
extern "C" void ExportByOrdinal103();


//Loads the original DLL from the default system directory
//Function originally written by Michael Koch
void load_original_dll() {
	char buffer[MAX_PATH];

	// Get path to system dir and to xinput1_3.dll
	GetSystemDirectoryA(buffer, MAX_PATH);

	// Append DLL name
	strcat_s(buffer, "\\xinput1_3.dll");

	// Try to load the system's xinput1_3.dll, if pointer empty
	if (!mHinstDLL) {
		mHinstDLL = LoadLibraryA(buffer);
	}

	// Debug
	if (!mHinstDLL) {
		OutputDebugStringA("PROXYDLL: Original xinput1_3.dll not loaded ERROR ****\r\n");
		ExitProcess(0); // Exit the hard way
	}
}


```

`xinput/xinput1_3.def`:

```def
LIBRARY xinput1_3.dll
EXPORTS
	DllMain=DllMain_wrapper @1
	XInputEnable=XInputEnable_wrapper @5
	XInputGetBatteryInformation=XInputGetBatteryInformation_wrapper @7
	XInputGetCapabilities=XInputGetCapabilities_wrapper @4
	XInputGetDSoundAudioDeviceGuids=XInputGetDSoundAudioDeviceGuids_wrapper @6
	XInputGetKeystroke=XInputGetKeystroke_wrapper @8
	XInputGetState=XInputGetState_wrapper @2
	XInputSetState=XInputSetState_wrapper @3
	ExportByOrdinal100 @100 NONAME
	ExportByOrdinal101 @101 NONAME
	ExportByOrdinal102 @102 NONAME
	ExportByOrdinal103 @103 NONAME

```

`xinput/xinput1_3_asm.asm`:

```asm
.code
extern mProcs:QWORD
DllMain_wrapper proc
	jmp mProcs[0*8]
DllMain_wrapper endp
XInputEnable_wrapper proc
	jmp mProcs[1*8]
XInputEnable_wrapper endp
XInputGetBatteryInformation_wrapper proc
	jmp mProcs[2*8]
XInputGetBatteryInformation_wrapper endp
XInputGetCapabilities_wrapper proc
	jmp mProcs[3*8]
XInputGetCapabilities_wrapper endp
XInputGetDSoundAudioDeviceGuids_wrapper proc
	jmp mProcs[4*8]
XInputGetDSoundAudioDeviceGuids_wrapper endp
XInputGetKeystroke_wrapper proc
	jmp mProcs[5*8]
XInputGetKeystroke_wrapper endp
XInputGetState_wrapper proc
	jmp mProcs[6*8]
XInputGetState_wrapper endp
XInputSetState_wrapper proc
	jmp mProcs[7*8]
XInputSetState_wrapper endp
ExportByOrdinal100 proc
	jmp mProcs[8*8]
ExportByOrdinal100 endp
ExportByOrdinal101 proc
	jmp mProcs[9*8]
ExportByOrdinal101 endp
ExportByOrdinal102 proc
	jmp mProcs[10*8]
ExportByOrdinal102 endp
ExportByOrdinal103 proc
	jmp mProcs[11*8]
ExportByOrdinal103 endp
end

```