Project Path: arc_gmh5225_pe-sieve_96m39up9

Source Tree:

```txt
arc_gmh5225_pe-sieve_96m39up9
├── CMakeLists.txt
├── Doxyfile
├── LICENSE
├── README.md
├── color_scheme.h
├── dll_main.cpp
├── include
│   ├── pe_sieve_api.h
│   ├── pe_sieve_return_codes.h
│   ├── pe_sieve_types.h
│   └── pe_sieve_version.h
├── libpeconv
├── logo
│   ├── 128X128.ico
│   ├── 128X128.png
│   ├── 16X16.ico
│   ├── 24X24.ico
│   ├── 32X32.ico
│   ├── 48X48.ico
│   ├── 64X64.ico
│   ├── PE SIEVE-icon.png
│   ├── PE-SIEVE.png
│   ├── PE-SIEVE_small.png
│   └── favicon.ico
├── main.cpp
├── main.def
├── mingw_build.sh
├── paramkit
├── params.h
├── params_info
│   ├── pe_sieve_params_info.cpp
│   └── pe_sieve_params_info.h
├── pe_sieve.cpp
├── pe_sieve.h
├── pe_sieve_api.cpp
├── postprocessors
│   ├── dump_report.cpp
│   ├── dump_report.h
│   ├── imp_rec
│   │   ├── iat_block.cpp
│   │   ├── iat_block.h
│   │   ├── iat_finder.h
│   │   ├── imp_reconstructor.cpp
│   │   ├── imp_reconstructor.h
│   │   ├── import_table_finder.cpp
│   │   └── import_table_finder.h
│   ├── pe_buffer.cpp
│   ├── pe_buffer.h
│   ├── pe_reconstructor.cpp
│   ├── pe_reconstructor.h
│   ├── report_formatter.cpp
│   ├── report_formatter.h
│   ├── results_dumper.cpp
│   └── results_dumper.h
├── resources.h
├── resources.rc
├── scanners
│   ├── artefact_scanner.cpp
│   ├── artefact_scanner.h
│   ├── code_scanner.cpp
│   ├── code_scanner.h
│   ├── headers_scanner.cpp
│   ├── headers_scanner.h
│   ├── hook_targets_resolver.cpp
│   ├── hook_targets_resolver.h
│   ├── iat_scanner.cpp
│   ├── iat_scanner.h
│   ├── mapping_scanner.cpp
│   ├── mapping_scanner.h
│   ├── mempage_data.cpp
│   ├── mempage_data.h
│   ├── module_cache.cpp
│   ├── module_cache.h
│   ├── module_data.cpp
│   ├── module_data.h
│   ├── module_scan_report.h
│   ├── module_scanner.h
│   ├── patch_analyzer.cpp
│   ├── patch_analyzer.h
│   ├── patch_list.cpp
│   ├── patch_list.h
│   ├── pe_section.h
│   ├── process_feature_scanner.h
│   ├── scan_report.cpp
│   ├── scan_report.h
│   ├── scanned_modules.cpp
│   ├── scanned_modules.h
│   ├── scanner.cpp
│   ├── scanner.h
│   ├── thread_scanner.cpp
│   ├── thread_scanner.h
│   ├── workingset_scanner.cpp
│   └── workingset_scanner.h
└── utils
    ├── artefacts_util.cpp
    ├── artefacts_util.h
    ├── console_color.cpp
    ├── console_color.h
    ├── format_util.cpp
    ├── format_util.h
    ├── modules_enum.cpp
    ├── modules_enum.h
    ├── ntddk.h
    ├── path_converter.cpp
    ├── path_converter.h
    ├── path_util.cpp
    ├── path_util.h
    ├── process_minidump.cpp
    ├── process_minidump.h
    ├── process_privilege.cpp
    ├── process_privilege.h
    ├── process_reflection.cpp
    ├── process_reflection.h
    ├── process_util.cpp
    ├── process_util.h
    ├── strings_util.cpp
    ├── strings_util.h
    ├── threads_util.cpp
    ├── threads_util.h
    ├── workingset_enum.cpp
    └── workingset_enum.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required (VERSION 3.12.4)
project (pe-sieve)

option(PESIEVE_BUILD_TESTING "Enable testing for PE-sieve" OFF)
option(PESIEVE_AS_DLL "Build PE-sieve as a DLL" OFF)
option(PESIEVE_AS_STATIC_LIB "Build PE-Sieve as a static library" OFF)

include_directories (
	include
)
if (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")

	option(LINK_STATICALLY "Link PE-Sieve with static versions of linked libraries" ON)

	add_compile_options(
		-fpermissive
	)

	add_compile_definitions(
		_WIN32_WINNT=1536 # 0x600 aka Windows Vista required
	)

	if(LINK_STATICALLY)
		add_link_options(
			-static
			-static-libgcc
			-static-libstdc++
		)
	endif()

endif()

set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")

# modules:
set ( M_PARSER "libpeconv/libpeconv" )

# modules paths:
set (PECONV_DIR "${PROJECT_SOURCE_DIR}/${M_PARSER}" CACHE PATH "PEConv main path")

# modules headers:
include_directories ( ${PECONV_DIR}/include )
# libs
add_subdirectory (libpeconv/libpeconv)
set ( PECONV_LIB $<TARGET_FILE:libpeconv> CACHE PATH "PEConvLib library path" )

if( NOT PESIEVE_AS_STATIC_LIB AND NOT PESIEVE_AS_DLL)
	set ( M_PARAMKIT_LIB "paramkit" )

	set (PARAMKIT_DIR "${CMAKE_SOURCE_DIR}/${M_PARAMKIT_LIB}/${M_PARAMKIT_LIB}" CACHE PATH "ParamKit main path" )
	# modules headers:
	include_directories ( ${PARAMKIT_DIR}/include )
	# libs
	add_subdirectory ( ${PARAMKIT_DIR} )
	set ( PARAMKIT_LIB $<TARGET_FILE:paramkit> CACHE PATH "ParamKit library path" )
endif()

set (scanners_srcs
	scanners/mapping_scanner.cpp
	scanners/headers_scanner.cpp
	scanners/code_scanner.cpp
	scanners/workingset_scanner.cpp
	scanners/artefact_scanner.cpp
	scanners/iat_scanner.cpp
	scanners/scanner.cpp
	scanners/module_data.cpp
	scanners/module_cache.cpp
	scanners/mempage_data.cpp
	scanners/patch_list.cpp
	scanners/patch_analyzer.cpp
	scanners/scan_report.cpp
	scanners/scanned_modules.cpp
	scanners/hook_targets_resolver.cpp
	scanners/thread_scanner.cpp
)

set (scanners_hdrs
	scanners/process_feature_scanner.h
	scanners/mapping_scanner.h
	scanners/headers_scanner.h
	scanners/code_scanner.h
	scanners/module_scanner.h
	scanners/workingset_scanner.h
	scanners/artefact_scanner.h
	scanners/iat_scanner.h
	scanners/scanner.h
	scanners/module_scan_report.h
	scanners/scan_report.h
	scanners/module_cache.h
	scanners/module_data.h
	scanners/mempage_data.h
	scanners/pe_section.h
	scanners/patch_list.h
	scanners/patch_analyzer.h
	scanners/scanned_modules.h
	scanners/hook_targets_resolver.h
	scanners/thread_scanner.h
)

set (imprec_hdrs
	postprocessors/imp_rec/imp_reconstructor.h
	postprocessors/imp_rec/iat_block.h
	postprocessors/imp_rec/iat_finder.h
	postprocessors/imp_rec/import_table_finder.h
)

set (postprocessors_hdrs
	postprocessors/report_formatter.h
	postprocessors/results_dumper.h
	postprocessors/dump_report.h
	postprocessors/pe_buffer.h
	postprocessors/pe_reconstructor.h
)

set (imprec_srcs
	postprocessors/imp_rec/imp_reconstructor.cpp
	postprocessors/imp_rec/iat_block.cpp
	postprocessors/imp_rec/import_table_finder.cpp
)

set (postprocessors_srcs
	postprocessors/report_formatter.cpp
	postprocessors/results_dumper.cpp
	postprocessors/dump_report.cpp
	postprocessors/pe_buffer.cpp
	postprocessors/pe_reconstructor.cpp
)

set (utils_srcs
	utils/format_util.cpp
	utils/process_util.cpp
	utils/threads_util.cpp
	utils/process_privilege.cpp
	utils/process_minidump.cpp
	utils/path_util.cpp
	utils/path_converter.cpp
	utils/workingset_enum.cpp
	utils/modules_enum.cpp
	utils/artefacts_util.cpp
	utils/process_reflection.cpp
	utils/console_color.cpp
	utils/strings_util.cpp
)

set (utils_hdrs
	utils/format_util.h
	utils/path_util.h
	utils/path_converter.h
	utils/process_util.h
	utils/threads_util.h
	utils/process_privilege.h
	utils/process_minidump.h
	utils/workingset_enum.h
	utils/modules_enum.h
	utils/artefacts_util.h
	utils/process_reflection.h
	utils/console_color.h
	utils/strings_util.h
)

set (params_info_hdrs
	params_info/pe_sieve_params_info.h
)

set (params_info_srcs
	params_info/pe_sieve_params_info.cpp
)

set (srcs
	pe_sieve.cpp
	color_scheme.h
	${params_info_srcs}
	${scanners_srcs}
	${postprocessors_srcs}
	${imprec_srcs}
	${utils_srcs}
)

set (hdrs
	pe_sieve.h
	include/pe_sieve_types.h
	${params_info_hdrs}
	${scanners_hdrs}
	${postprocessors_hdrs}
	${imprec_hdrs}
	${utils_hdrs}
)

set (rsrc
	resources.h
	resources.rc
)

# set filters in Visual Studio project:

SOURCE_GROUP("Source Files\\scanners" FILES ${scanners_srcs} )
SOURCE_GROUP("Header Files\\scanners" FILES ${scanners_hdrs} )

SOURCE_GROUP("Source Files\\utils" FILES ${utils_srcs} )
SOURCE_GROUP("Header Files\\utils" FILES ${utils_hdrs} )

SOURCE_GROUP("Source Files\\params_info" FILES ${params_info_srcs} )
SOURCE_GROUP("Header Files\\params_info" FILES ${params_info_hdrs} )

SOURCE_GROUP("Source Files\\postprocessors" FILES ${postprocessors_srcs} )
SOURCE_GROUP("Header Files\\postprocessors" FILES ${postprocessors_hdrs} )

SOURCE_GROUP("Source Files\\postprocessors\\imp_rec" FILES ${imprec_srcs} )
SOURCE_GROUP("Header Files\\postprocessors\\imp_rec" FILES ${imprec_hdrs} )

include(GNUInstallDirs)
set (library_export_hdrs
	include/pe_sieve_types.h
	include/pe_sieve_version.h
	include/pe_sieve_api.h
	include/pe_sieve_return_codes.h
)
if(PESIEVE_AS_STATIC_LIB)
	set(LIBRARY_TYPE STATIC)
	# Install libpeconv as well since with static libraries a user has to link against both
	set(PECONV_LIB_INSTALL ON CACHE INTERNAL "")
elseif(PESIEVE_AS_DLL)
	set(LIBRARY_TYPE SHARED)
endif()

if (PESIEVE_AS_DLL AND PESIEVE_AS_STATIC_LIB)
	message(FATAL_ERROR "Choose either PESIEVE_AS_STATIC_LIB or PESIEVE_AS_DLL (or none of them, to build as an EXE)")
endif()

# Choose to build the library or EXE
if(PESIEVE_AS_STATIC_LIB OR PESIEVE_AS_DLL)
	set (lib_srcs
		pe_sieve_api.cpp
		${srcs}
	)
	if (PESIEVE_AS_DLL)
		set (lib_srcs
			dll_main.cpp
			main.def
			${lib_srcs}
		)
	endif()

	add_library ( ${PROJECT_NAME} ${LIBRARY_TYPE} ${library_export_hdrs} ${hdrs} ${lib_srcs} )

	set_source_files_properties(main.def PROPERTIES HEADER_FILE_ONLY TRUE)
	target_compile_definitions(${PROJECT_NAME} PUBLIC PESIEVE_${LIBRARY_TYPE}_LIB)
	INSTALL(FILES ${library_export_hdrs}
		DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
	)
	set_source_files_properties(main.def PROPERTIES HEADER_FILE_ONLY TRUE)
else()
	add_executable ( ${PROJECT_NAME} ${hdrs} ${srcs} ${rsrc} main.cpp params.h )
endif()

set (used_libs
	${PECONV_LIB}
	psapi.lib
	ntdll.lib
	shlwapi
)

# dependencies
add_dependencies(${PROJECT_NAME} libpeconv )

if(PESIEVE_AS_STATIC_LIB OR PESIEVE_AS_DLL)
	include(GNUInstallDirs)
	install(TARGETS ${PROJECT_NAME}
		ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
		LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
		RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
	)

	target_link_libraries ( ${PROJECT_NAME} ${used_libs} )

else()

	# add Paramkit only if build as an exe
	# dependencies
	add_dependencies(${PROJECT_NAME} paramkit )
	target_link_libraries ( ${PROJECT_NAME} ${used_libs} ${PARAMKIT_LIB} )

endif()

if (NOT PESIEVE_AS_STATIC_LIB)
	install(TARGETS ${PROJECT_NAME}
		DESTINATION ${CMAKE_INSTALL_PREFIX} COMPONENT ${PROJECT_NAME}
	)

	# Setup testing
	if(PESIEVE_BUILD_TESTING)
		enable_testing()
	
		# 0) does the application run
		add_test (TestRuns ${CMAKE_INSTALL_PREFIX}/pe-sieve -?)
		set_tests_properties(TestRuns PROPERTIES PASS_REGULAR_EXPRESSION "Version:")
	endif()
endif()


```

`Doxyfile`:

```
# Doxyfile 1.8.16

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the configuration
# file that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = PE-sieve

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         =

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "Scans all running processes. Recognizes and dumps a variety of potentially malicious implants (replaced/implanted PEs, shellcodes, hooks, in-memory patches)."

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           = ./logo/128X128.png

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = docs

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
# directories (in 2 levels) under the output directory of each output format and
# will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
# Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# The OUTPUT_TEXT_DIRECTION tag is used to specify the direction in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all generated output in the proper direction.
# Possible values are: None, LTR, RTL and Context.
# The default value is: None.

OUTPUT_TEXT_DIRECTION  = None

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the JAVADOC_BANNER tag is set to YES then doxygen will interpret a line
# such as
# /***************
# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
# Javadoc-style will behave just like regular comments and it will not be
# interpreted by doxygen.
# The default value is: NO.

JAVADOC_BANNER         = NO

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:\n"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". You can put \n's in the value part of an alias to insert
# newlines (in the resulting output). You can put ^^ in the value part of an
# alias to insert a newline as if a physical newline was in the original file.
# When you need a literal { or } or , in the value part of an alias you have to
# escape them by means of a backslash (\), this can lead to conflicts with the
# commands \{ and \} for these it is advised to use the version @{ and @} or use
# a double escape (\\{ and \\})

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding "class=itcl::class"
# will allow you to use the command class in the itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
# sources only. Doxygen will then generate output that is more tailored for that
# language. For instance, namespaces will be presented as modules, types will be
# separated into more groups, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_SLICE  = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
# Csharp (C#), C, C++, D, PHP, md (Markdown), Objective-C, Python, Slice,
# Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
# tries to guess whether the code is fixed or free formatted code, this is the
# default for Fortran type files), VHDL, tcl. For instance to make doxygen treat
# .inc files as Fortran files (default is PHP), and .f files as C (default is
# Fortran), use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See https://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 5.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 0

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
# methods of a class will be included in the documentation.
# The default value is: NO.

EXTRACT_PRIV_VIRTUAL   = NO

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# (class|struct|union) declarations. If set to NO, these declarations will be
# included in the documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
# names in lower-case letters. If set to YES, upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# (including Cygwin) ands Mac users are advised to set this option to NO.
# The default value is: system dependent.

CASE_SENSE_NAMES       = NO

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some parameters
# in a documented function, or documenting parameters that don't exist or using
# markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong or incomplete
# parameter documentation, but not about the absence of documentation. If
# EXTRACT_ALL is set to YES then this flag will automatically be disabled.
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
# a warning is encountered.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = . \
                         ./README.md

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
# possible encodings.
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by doxygen.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf, *.qsf and *.ice.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.idl \
                         *.ddl \
                         *.odl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.cs \
                         *.d \
                         *.php \
                         *.php4 \
                         *.php5 \
                         *.phtml \
                         *.inc \
                         *.m \
                         *.markdown \
                         *.md \
                         *.mm \
                         *.dox \
                         *.py \
                         *.pyw \
                         *.f90 \
                         *.f95 \
                         *.f03 \
                         *.f08 \
                         *.f \
                         *.for \
                         *.tcl \
                         *.vhd \
                         *.vhdl \
                         *.ucf \
                         *.qsf \
                         *.ice

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                = ./libpeconv \
                         ./utils/ntddk.h

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories use the pattern */test/*

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           = ./tests

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE = README.md

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = YES

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# entity all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see https://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
# cost of reduced performance. This can be particularly helpful with template
# rich C++ code for which doxygen's built-in parser lacks the necessary type
# information.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.
# The default value is: NO.

CLANG_ASSISTED_PARSING = NO

# If clang assisted parsing is enabled you can provide the compiler with command
# line options that you would normally use when invoking the compiler. Note that
# the include paths will already be set by doxygen for the files and directories
# specified with INPUT and INCLUDE_PATH.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_OPTIONS          =

# If clang assisted parsing is enabled you can provide the clang parser with the
# path to the compilation database (see:
# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) used when the files
# were built. This is equivalent to specifying the "-p" option to a clang tool,
# such as clang-check. These options will then be passed to the parser.
# Note: The availability of this option depends on whether or not doxygen was
# generated with the -Duse_libclang=ON option for CMake.

CLANG_DATABASE_PATH    =

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
# which the alphabetical index list will be split.
# Minimum value: 1, maximum value: 20, default value: 5.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all classes will
# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
# can be used to specify a prefix (or a list of prefixes) that should be ignored
# while generating the index headers.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list). For an example see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a colorwheel, see
# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use grayscales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting this
# to YES can help to show when doxygen was last run and thus if the
# documentation is up to date.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_TIMESTAMP         = NO

# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
# documentation will contain a main index with vertical navigation menus that
# are dynamically created via Javascript. If disabled, the navigation index will
# consists of multiple levels of tabs that are statically embedded in every HTML
# page. Disable this option to support browsers that do not have Javascript,
# like the Qt help browser.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_MENUS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see: https://developer.apple.com/xcode/), introduced with OSX
# 10.5 (Leopard). To create a documentation set, doxygen will generate a
# Makefile in the HTML output directory. Running make will produce the docset in
# that directory and running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
# genXcode/_index.html for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# (see: https://www.microsoft.com/en-us/download/details.aspx?id=21138) on
# Windows.
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the master .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-
# folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see: https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-
# filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location of Qt's
# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
# generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine-tune the look of the index. As an example, the default style
# sheet generated by doxygen has an example that shows how to put an image at
# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
# the same information as the tab index, you could consider setting
# DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are not
# supported properly for IE 6.0, but are supported on all modern browsers.
#
# Note that when changing this option you need to delete any form_*.png files in
# the HTML output directory before the changes have effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# https://www.mathjax.org) which uses client side Javascript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. See the MathJax site (see:
# http://docs.mathjax.org/en/latest/output.html) for more details.
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility), NativeMML (i.e. MathML) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from https://www.mathjax.org before deployment.
# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using Javascript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: https://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: https://xapian.org/). See the section "External Indexing and
# Searching" for details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when not enabling USE_PDFLATEX the default is latex when enabling
# USE_PDFLATEX the default is pdflatex and when in the later case latex is
# chosen this is overwritten by pdflatex. For specific output languages the
# default can have been set differently, this depends on the implementation of
# the output language.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         =

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# Note: This tag is used in the Makefile / make.bat.
# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
# (.tex).
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
# generate index for LaTeX. In case there is no backslash (\) as first character
# it will be automatically added in the LaTeX code.
# Note: This tag is used in the generated output file (.tex).
# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
# The default value is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_MAKEINDEX_CMD    = \makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
# generated LaTeX document. The header should contain everything until the first
# chapter. If it is left blank doxygen will generate a standard header. See
# section "Doxygen usage" for information on how to let doxygen write the
# default header to a separate file.
#
# Note: Only use a user-defined header if you know what you are doing! The
# following commands have a special meaning inside the header: $title,
# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
# string, for the replacement values of the other commands the user is referred
# to HTML_HEADER.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
# generated LaTeX document. The footer should contain everything after the last
# chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer.
#
# Note: Only use a user-defined footer if you know what you are doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
# the PDF file directly from the LaTeX files. Set this option to YES, to get a
# higher quality PDF documentation.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
# command to the generated LaTeX files. This will instruct LaTeX to keep running
# if errors occur, instead of asking the user for help. This option is also used
# when generating formulas in HTML.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
# code with syntax highlighting in the LaTeX output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
# page will contain the date and time when the page was generated. Setting this
# to NO can help when comparing the output of multiple runs.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_TIMESTAMP        = NO

# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
# path from which the emoji images will be read. If a relative path is entered,
# it will be relative to the LATEX_OUTPUT directory. If left blank the
# LATEX_OUTPUT directory will be used.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EMOJI_DIRECTORY  =

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's
# configuration file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's configuration file. A template extensions file can be
# generated using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
# with syntax highlighting in the RTF output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_SOURCE_CODE        = NO

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, doxygen will include
# namespace members in file scope as well, matching the HTML output.
# The default value is: NO.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_NS_MEMB_FILE_SCOPE = NO

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
# program listings (including syntax highlighting and cross-referencing
# information) to the DOCBOOK output. Note that enabling this will significantly
# increase the size of the DOCBOOK output.
# The default value is: NO.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_PROGRAMLISTING = NO

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
# the structure of the code including all documentation. Note that this feature
# is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
# the class index. If set to NO, only the inherited external classes will be
# listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
# NO turns the diagrams off. Note that this option also works with HAVE_DOT
# disabled, but it is recommended to install and use dot, since it yields more
# powerful graphs.
# The default value is: YES.

CLASS_DIAGRAMS         = NO

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = YES

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# When you want a differently looking font in the dot files that doxygen
# generates you can specify the font name using DOT_FONTNAME. You need to make
# sure dot is able to find the font, which can be done by putting it in a
# standard location or by setting the DOTFONTPATH environment variable or by
# setting DOT_FONTPATH to the directory containing the font.
# The default value is: Helvetica.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
# dot graphs.
# Minimum value: 4, maximum value: 24, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the default font as specified with
# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
# the path where dot can find it using this tag.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
# each documented class showing the direct and indirect inheritance relations.
# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = NO

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = NO

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = NO

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = YES

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# http://www.graphviz.org/)).
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
# png:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file. If left blank, it is assumed
# PlantUML is not used or called during a preprocessing step. Doxygen will
# generate a warning when it encounters a \startuml command in this case and
# will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for plantuml.

PLANTUML_CFG_FILE      =

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not seem
# to support this out of the box.
#
# Warning: Depending on the platform used, enabling this option may lead to
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
# read).
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
# files that are used to generate the various graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_CLEANUP            = YES

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2017-2022, @hasherezade
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
<img src="./logo/PE-SIEVE_small.png" alt="">

[![Build status](https://ci.appveyor.com/api/projects/status/crlo8iyvi4bm80yp?svg=true)](https://ci.appveyor.com/project/hasherezade/pe-sieve)
[![Codacy Badge](https://api.codacy.com/project/badge/Grade/b75fd4d95bd94629879381241e4a7c02)](https://app.codacy.com/gh/hasherezade/pe-sieve/dashboard?branch=master)
[![Commit activity](https://img.shields.io/github/commit-activity/m/hasherezade/pe-sieve)](https://github.com/hasherezade/pe-sieve/commits)
[![Last Commit](https://img.shields.io/github/last-commit/hasherezade/pe-sieve/master)](https://github.com/hasherezade/pe-sieve/commits)

[![GitHub release](https://img.shields.io/github/release/hasherezade/pe-sieve.svg)](https://github.com/hasherezade/pe-sieve/releases)
[![GitHub release date](https://img.shields.io/github/release-date/hasherezade/pe-sieve?color=blue)](https://github.com/hasherezade/pe-sieve/releases)
[![Github All Releases](https://img.shields.io/github/downloads/hasherezade/pe-sieve/total.svg)](https://github.com/hasherezade/pe-sieve/releases)
[![Github Latest Release](https://img.shields.io/github/downloads/hasherezade/pe-sieve/latest/total.svg)](https://github.com/hasherezade/pe-sieve/releases)

[![License](https://img.shields.io/badge/License-BSD%202--Clause-blue.svg)](https://github.com/hasherezade/pe-sieve/blob/master/LICENSE)
[![Platform Badge](https://img.shields.io/badge/Windows-0078D6?logo=windows)](https://github.com/hasherezade/pe-sieve)
[![Discussions](https://img.shields.io/badge/Ask%20me-anything-1abc9c.svg)](https://github.com/hasherezade/pe-sieve/discussions)

[![Twitter URL](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/intent/tweet?original_referer=https://github.com/hasherezade/pe-sieve&text=%23PEsieve%3A+an+open-source+process+scanner%2C+detecting+and+dumping+malicious+implants:%20https://github.com/hasherezade/pe-sieve)

❓ [FAQ - Frequently Asked Questions](https://github.com/hasherezade/pe-sieve/wiki/1.-FAQ)

📖 [Read Wiki](https://github.com/hasherezade/pe-sieve/wiki)

📦 Uses library: [libPEConv](https://github.com/hasherezade/libpeconv.git)

<b>PE-sieve</b> is a tool that helps to detect malware running on the system, as well as to collect the potentially malicious material for further analysis. Recognizes and dumps variety of implants within the scanned process: replaced/injected PEs, shellcodes, hooks, and other in-memory patches.<br/>
Detects inline hooks, Process Hollowing, Process Doppelgänging, Reflective DLL Injection, etc.

PE-sieve is meant to be a **light-weight engine** dedicated to scan **a single process** at the time. It can be built as an EXE or as a DLL. The DLL version exposes [a simple API](https://github.com/hasherezade/pe-sieve/wiki/5.-API) and can be easily integrated with other applications.

## PE-sieve tools family

There are few other tools that use PE-sieve as an engine, but focus on some specific usecases. They offer additional features and filters on the top of its base.

📌 [HollowsHunter](https://github.com/hasherezade/hollows_hunter) - if instead of scanning a single process you want to **scan multiple processes at once, or even the full system** with PE-sieve, this is the tool for you

📌 [MalUnpack](https://github.com/hasherezade/mal_unpack) - offers quick **unpacking** of supplied malware sample

## Clone

Use **recursive clone** to get the repo together with the submodule:

```console
git clone --recursive https://github.com/hasherezade/pe-sieve.git
```

## Builds

Download the latest [release](https://github.com/hasherezade/pe-sieve/releases), or [read more](https://github.com/hasherezade/pe-sieve/wiki/1.-FAQ#how-to-get-it).

![](https://community.chocolatey.org/favicon.ico) Available also via [Chocolatey](https://community.chocolatey.org/packages/pesieve)

<hr/>

logo by [Baran Pirinçal](https://github.com/baranpirincal)

```

`color_scheme.h`:

```h
#pragma once

namespace pesieve {

	const WORD ERROR_COLOR = 0x0c;
	const WORD WARNING_COLOR = 0x0c;
	const WORD HILIGHTED_COLOR = 0x0f;
};

```

`dll_main.cpp`:

```cpp
/**
* @file
* @brief   The main file of PE-sieve built as a DLL
*/

#include <windows.h>
#include <string>
#include <iostream>

#define PESIEVE_EXPORTS
#include <pe_sieve_api.h>

BOOL WINAPI DllMain (HANDLE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
	}
	return TRUE;
}


```

`include/pe_sieve_api.h`:

```h
/**
* @file
* @brief   The API: definitions of the exported elements that are accessible from PE-sieve DLL.
*/

#pragma once

#include <windows.h>
#include <pe_sieve_types.h>

#ifndef PESIEVE_STATIC_LIB
#ifdef PESIEVE_EXPORTS
#define PESIEVE_API __declspec(dllexport)
#else
#define PESIEVE_API __declspec(dllimport)
#endif
#else
#define PESIEVE_API
#endif

#define PESIEVE_API_FUNC PESIEVE_API __cdecl

#ifdef __cplusplus
extern "C" {
#endif


//! PE-sieve version in a DWORD form.
extern const DWORD PESIEVE_API PESieve_version;

//! Shows a MessageBox with the informations about PE-sieve.
void PESIEVE_API_FUNC PESieve_help(void);

#ifdef __cplusplus
typedef pesieve::t_report PEsieve_report;
typedef pesieve::t_params PEsieve_params;
#else
typedef t_report PEsieve_report;
typedef t_params PEsieve_params;
#endif

//! Performs a PE-sieve scan with a supplied set of parameters (defined as a structure t_params). Returns a summary of the scan in a variable of type t_report.
PEsieve_report PESIEVE_API_FUNC PESieve_scan(const PEsieve_params args);

#ifdef __cplusplus
};
#endif

```

`include/pe_sieve_return_codes.h`:

```h
/**
* @file
* @brief   The codes returned by the PE-sieve EXE
*/

#pragma once

// return codes for PE-sieve.exe:
typedef enum {
	PESIEVE_ERROR = (-1),   ///< the scan has failed, PE-sieve returned an error
	PESIEVE_INFO = 0,   ///< PE-sieve was deployed in the info mode (i.e. displaying help)
	PESIEVE_NOT_DETECTED = 1, ///< the process was scanned successfuly, and NO suspicious indicators are detected
	PESIEVE_DETECTED = 2   ///< the process was scanned successfuly, and some suspicious indicators are detected
} t_pesieve_res;

```

`include/pe_sieve_types.h`:

```h
/**
* @file
* @brief   The types used by PE-sieve API.
*/

#pragma once

#include <windows.h>
#include <pshpack4.h> // ensure 4 byte packing of the structures

#define PARAM_LIST_SEPARATOR ';'

#ifndef __cplusplus
typedef char bool;
#endif

#ifdef __cplusplus
namespace pesieve {
#endif

	//! the status returned if scanning has failed
	const DWORD ERROR_SCAN_FAILURE = (-1);

	typedef enum {
		OUT_FULL = 0, ///< no filter: dump everything (default)
		OUT_NO_DUMPS, ///< don't dump the modified PEs, but save the report
		OUT_NO_DIR, ///< don't dump any files
		OUT_FILTERS_COUNT
	} t_output_filter;

	typedef enum {
		PE_IMPREC_NONE = 0, ///< do not try to recover imports
		PE_IMPREC_AUTO,     ///< try to autodetect the most suitable mode
		PE_IMPREC_UNERASE,  ///< recover erased parts of the partialy damaged import table
		PE_IMPREC_REBUILD0,  ///< build the import table from the scratch, basing on the found IAT(s): use only terminated blocks (restrictive mode)
		PE_IMPREC_REBUILD1,  ///< build the import table from the scratch, basing on the found IAT(s): use terminated blocks, or blocks with more than 1 thunk
		PE_IMPREC_REBUILD2,  ///< build the import table from the scratch, basing on the found IAT(s): use all found blocks (aggressive mode)
		PE_IMPREC_MODES_COUNT
	} t_imprec_mode;

	typedef enum {
		PE_DUMP_AUTO = 0,   ///< autodetect which dump mode is the most suitable for the given input
		PE_DUMP_VIRTUAL,    ///< dump as it is in the memory (virtual)
		PE_DUMP_UNMAP,      ///< convert to the raw format: using raw sections' headers
		PE_DUMP_REALIGN,    ///< convert to the raw format: by realigning raw sections' headers to be the same as virtual (useful if the PE was unpacked in memory)
		PE_DUMP_MODES_COUNT
	} t_dump_mode;

	typedef enum {
		PE_IATS_NONE = 0,           ///< do not scan IAT
		PE_IATS_CLEAN_SYS_FILTERED, ///< scan IAT, filter hooks if they lead to unpatched system module
		PE_IATS_ALL_SYS_FILTERED,   ///< scan IAT, filter hooks if they lead to any system module
		PE_IATS_UNFILTERED,         ///< scan IAT, unfiltered
		PE_IATS_MODES_COUNT
	} t_iat_scan_mode;

	typedef enum {
		PE_DNET_NONE = 0,           ///< none: treat managed processes same as native
		PE_DNET_SKIP_MAPPING = 1,   ///< skip mapping mismatch (in .NET modules only)
		PE_DNET_SKIP_SHC,           ///< skip shellcodes (in all modules within the managed process)
		PE_DNET_SKIP_HOOKS,         ///< skip hooked modules (in all modules within the managed process)
		PE_DNET_SKIP_ALL,           ///< skip all above indicators (mapping, shellcodes, hooks) in modules within the managed process
		PE_DNET_COUNT
	} t_dotnet_policy;

	typedef enum {
		PE_DATA_NO_SCAN = 0,        ///< do not scan non-executable pages
		PE_DATA_SCAN_DOTNET,        ///< scan data in .NET applications
		PE_DATA_SCAN_NO_DEP,        ///< scan data if no DEP or in .NET applications
		PE_DATA_SCAN_ALWAYS,        ///< scan data unconditionally
		PE_DATA_SCAN_INACCESSIBLE,      ///< scan data unconditionally, and inaccessible pages (if running in reflection mode)
		PE_DATA_SCAN_INACCESSIBLE_ONLY, ///< scan inaccessible pages (if running in reflection mode)
		PE_DATA_COUNT
	} t_data_scan_mode;

	typedef enum {
		JSON_BASIC = 0,     ///< basic
		JSON_DETAILS = 1,   ///< include the basic list patches in the main JSON report
		JSON_DETAILS2,      ///< include the extended list patches in the main JSON report
		JSON_LVL_COUNT
	} t_json_level;

	//!  A wrapper for a dynamically allocated string.
	typedef struct _PARAM_STRING {
		ULONG length;
		char* buffer;
	} PARAM_STRING;

	//!  Input parameters for PE-sieve, defining the configuration.
	typedef struct {
		DWORD pid;                 ///< the PID of the process to be scanned
		t_dotnet_policy dotnet_policy; ///< policy for scanning .NET modules
		t_imprec_mode imprec_mode;  ///< import recovery mode
		bool quiet;                 ///<do not print log on the stdout
		t_output_filter out_filter; ///< level of details of the created output material
		bool no_hooks;           ///< don't scan for hooks
		bool shellcode;         ///< detect shellcode implants
		bool threads;           ///< scan threads
		t_iat_scan_mode iat;    ///< detect IAT hooking
		t_data_scan_mode data;  ///< should scan non-executable pages?
		bool minidump;          ///< make minidump of full process
		t_dump_mode dump_mode;  ///< in which mode the detected PE implants should be dumped
		bool json_output;       ///< display the final summary as the JSON report
		bool make_reflection;   ///< operate on a process reflection rather than on the live process (this allows i.e. to force-read inaccessible pages)
		bool use_cache;      ///< enable cache for the scanned modules
		t_json_level json_lvl;  ///< level of the details of the JSON report
		char output_dir[MAX_PATH + 1];  ///< the root directory where the output should be saved (default: current directory)
		PARAM_STRING modules_ignored; ///< a list of modules that will not be scanned, separated by PARAM_LIST_SEPARATOR
	} t_params;

	//!  Final summary about the scanned process.
	typedef struct {
		DWORD pid;              ///< pid of the process that was scanned
		bool is_managed;        ///< is process managed (.NET)
		bool is_64bit;          ///< is process 64 bit
		bool is_reflection;     ///< was the scan performed on process reflection
		DWORD scanned;          ///< number of all scanned modules
		DWORD suspicious;       ///< general summary of suspicious
		DWORD replaced;         ///< PE file replaced in memory (probably hollowed)
		DWORD hdr_mod;          ///< PE header is modified (but not replaced)
		DWORD unreachable_file; ///< cannot read the file corresponding to the module in memory
		DWORD patched;          ///< detected modifications in the code
		DWORD iat_hooked;       ///< detected IAT hooks
		DWORD implanted;        ///< all implants: shellcodes + PEs
		DWORD implanted_pe;     ///< the full PE was probably loaded manually
		DWORD implanted_shc;    ///< implanted shellcodes
		DWORD other;            ///< other indicators
		DWORD skipped;          ///< some of the modules must be skipped (i.e. dotNET managed code have different characteristics and this scan does not apply)
		DWORD errors;           ///< the number of elements that could not be scanned because of errors. If errors == ERROR_SCAN_FAILURE, no scan was performed.
	} t_report;

#ifdef __cplusplus
};
#endif

#include <poppack.h> //back to the previous structure packing

```

`include/pe_sieve_version.h`:

```h
#pragma once

#include <windows.h>

#ifdef __cplusplus
namespace pesieve {
#endif

	const char PESIEVE_VERSION[] = "0.3.4";
	const DWORD PESIEVE_VERSION_ID = 0x00030400; // 00 03 04 00
	const char PESIEVE_URL[] = "https://github.com/hasherezade/pe-sieve";

#ifdef __cplusplus
};
#endif

```

`main.cpp`:

```cpp
/**
* @file
* @brief   The main file of PE-sieve built as an EXE
*/

#include <windows.h>
#include <psapi.h>
#include <sstream>
#include <fstream>

#include "pe_sieve.h"
#include "params.h"

#include "utils/process_privilege.h"
#include "params_info/pe_sieve_params_info.h"
#include "utils/process_reflection.h"
#include "utils/console_color.h"
#include "color_scheme.h"


using namespace pesieve;
using namespace pesieve::util;


void print_report(const pesieve::ReportEx& report, const t_params args)
{
	if (!report.scan_report) return;

	std::string report_str;
	if (args.json_output) {
		report_str = scan_report_to_json(*report.scan_report, ProcessScanReport::REPORT_SUSPICIOUS_AND_ERRORS, args.json_lvl);
	} else {
		report_str = scan_report_to_string(*report.scan_report);
	}
	//summary:
	std::cout << report_str;
	if (!args.json_output) {
		std::cout << "---" << std::endl;
	}
}

void free_params(t_params &args)
{
	free_strparam(args.modules_ignored);
}

int main(int argc, char *argv[])
{
	bool info_req = false;
	t_params args = { 0 };

	PEsieveParams uParams(PESIEVE_VERSION);
	if (argc < 2) {
		uParams.printBanner();
		uParams.printBriefInfo();
		system("pause");
		return PESIEVE_INFO;
	}
	if (!uParams.parse(argc, argv)) {
		return PESIEVE_INFO;
	}
	uParams.fillStruct(args);
	//---
	// if scanning of inaccessible pages was requested, auto-enable reflection mode:
	if (args.data == pesieve::PE_DATA_SCAN_INACCESSIBLE || args.data == pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY) {
		if (!args.make_reflection) {
			args.make_reflection = true;
			if (!args.quiet) {
				paramkit::print_in_color(paramkit::WARNING_COLOR, "[WARNING] Scanning of inaccessible pages requested: auto-enabled reflection mode!\n");
			}
		}
	}
	//print info about current settings:
	if (!args.quiet) {
		std::cout << "PID: " << args.pid << std::endl;
		std::cout << "Output filter: " << translate_out_filter(args.out_filter) << std::endl;
		std::cout << "Dump mode: " << translate_dump_mode(args.dump_mode) << std::endl;
	}

	pesieve::ReportEx* report = pesieve::scan_and_dump(args);
	t_pesieve_res res = PESIEVE_ERROR;
	if (report != nullptr) {
		print_report(*report, args);

		pesieve::t_report summary = report->scan_report->generateSummary();
		if (summary.scanned > 0) {
			res = (summary.suspicious > 0) ? PESIEVE_DETECTED : PESIEVE_NOT_DETECTED;
		}
		delete report;
		report = nullptr;
	}

	free_params(args);
#ifdef _DEBUG
	system("pause");
#endif
	return res;
}

```

`main.def`:

```def
LIBRARY pe-sieve
EXPORTS PESieve_help
EXPORTS PESieve_scan
EXPORTS PESieve_version

```

`mingw_build.sh`:

```sh
#!/bin/sh

set -e

cmake . \
    -DCMAKE_C_COMPILER=x86_64-w64-mingw32-gcc \
    -DCMAKE_CXX_COMPILER=x86_64-w64-mingw32-g++ \
    -DCMAKE_SYSTEM_NAME=Windows-GNU \
    -DPESIEVE_AS_DLL=0 \
    -DPESIEVE_AS_STATIC_LIB=0 \
    -DLINK_STATICALLY=1

make

```

`params.h`:

```h
#pragma once
#include <sstream>

#include "pe_sieve.h"
#include "params_info/pe_sieve_params_info.h"

#include <paramkit.h>

using namespace paramkit;
using namespace pesieve;

//scan options:
#define PARAM_PID "pid"
#define PARAM_SHELLCODE "shellc"
#define PARAM_THREADS "threads"
#define PARAM_DATA "data"
#define PARAM_IAT "iat"
#define PARAM_MODULES_IGNORE "mignore"
#define PARAM_REFLECTION "refl"
#define PARAM_DOTNET_POLICY "dnet"

//dump options:
#define PARAM_IMP_REC "imp"
#define PARAM_DUMP_MODE "dmode"
//output options:
#define PARAM_OUT_FILTER "ofilter"
#define PARAM_QUIET "quiet"
#define PARAM_JSON "json"
#define PARAM_JSON_LVL "jlvl"
#define PARAM_DIR "dir"
#define PARAM_MINIDUMP "minidmp"


bool alloc_strparam(PARAM_STRING& strparam, ULONG len)
{
	if (strparam.buffer != nullptr) { // already allocated
		return false;
	}
	strparam.buffer = (char*)calloc(len + 1, sizeof(char));
	if (strparam.buffer) {
		strparam.length = len;
		return true;
	}
	return false;
}

void free_strparam(PARAM_STRING& strparam)
{
	free(strparam.buffer);
	strparam.buffer = nullptr;
	strparam.length = 0;
}

class PEsieveParams : public Params
{
public:
	PEsieveParams(const std::string &version)
		: Params(version)
	{
		this->addParam(new IntParam(PARAM_PID, true));
		this->setInfo(PARAM_PID, "Set the PID of the target process.");

		EnumParam *enumParam = new EnumParam(PARAM_IMP_REC, "imprec_mode", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_IMP_REC, "Set in which mode the ImportTable should be recovered");
			for (size_t i = 0; i < PE_IMPREC_MODES_COUNT; i++) {
				t_imprec_mode mode = (t_imprec_mode)(i);
				enumParam->addEnumValue(mode, imprec_mode_to_id(mode), translate_imprec_mode(mode));
			}
		}

		enumParam = new EnumParam(PARAM_OUT_FILTER, "ofilter_id", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_OUT_FILTER, "Filter the dumped output.");
			for (size_t i = 0; i < OUT_FILTERS_COUNT; i++) {
				t_output_filter mode = (t_output_filter)(i);
				enumParam->addEnumValue(mode, translate_out_filter(mode));
			}
		}

		this->addParam(new StringListParam(PARAM_MODULES_IGNORE, false, PARAM_LIST_SEPARATOR));
		{
			std::stringstream ss1;
			ss1 << "Do not scan module/s with given name/s.";
			std::stringstream ss2;
			ss2 << INFO_SPACER << "Example: kernel32.dll" << PARAM_LIST_SEPARATOR << "user32.dll";
			this->setInfo(PARAM_MODULES_IGNORE, ss1.str(), ss2.str());
		}
		
		this->addParam(new BoolParam(PARAM_QUIET, false));
		this->setInfo(PARAM_QUIET, "Print only the summary. Do not log on stdout during the scan.");

		this->addParam(new BoolParam(PARAM_JSON, false));
		this->setInfo(PARAM_JSON, "Print the JSON report as the summary.");
		//
		//PARAM_JSON_LVL
		enumParam = new EnumParam(PARAM_JSON_LVL, "json_lvl", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_JSON_LVL, "Level of details of the JSON report.");
			for (size_t i = 0; i < JSON_LVL_COUNT; i++) {
				t_json_level mode = (t_json_level)(i);
				enumParam->addEnumValue(mode, translate_json_level(mode));
			}
		}

		this->addParam(new BoolParam(PARAM_MINIDUMP, false));
		this->setInfo(PARAM_MINIDUMP, "Create a minidump of the full suspicious process.");

		//PARAM_SHELLCODE
		this->addParam(new BoolParam(PARAM_SHELLCODE, false));
		this->setInfo(PARAM_SHELLCODE, "Detect shellcode implants (by patterns). ");

		//PARAM_THREADS
		this->addParam(new BoolParam(PARAM_THREADS, false));
		this->setInfo(PARAM_THREADS, "Scan threads' callstack. Detect shellcodes, incl. 'sleeping beacons'.");

		//PARAM_REFLECTION
		this->addParam(new BoolParam(PARAM_REFLECTION, false));
		this->setInfo(PARAM_REFLECTION, 
			"Make a process reflection before scan.", 
			std::string(INFO_SPACER) + "This allows i.e. to force-read inaccessible pages."
		);

		//PARAM_IAT
		enumParam = new EnumParam(PARAM_IAT, "iat_scan_mode", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_IAT, "Scan for IAT hooks.");
			for (size_t i = 0; i < PE_IATS_MODES_COUNT; i++) {
				t_iat_scan_mode mode = (t_iat_scan_mode)(i);
				enumParam->addEnumValue(mode, translate_iat_scan_mode(mode));
			}
		}

		//PARAM_DOTNET_POLICY
		enumParam = new EnumParam(PARAM_DOTNET_POLICY, "dotnet_policy", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_DOTNET_POLICY, "Set the policy for scanning managed processes (.NET).");
			for (size_t i = 0; i < PE_DNET_COUNT; i++) {
				t_dotnet_policy mode = (t_dotnet_policy)(i);
				enumParam->addEnumValue(mode, translate_dotnet_policy(mode));
			}
		}

		//PARAM_DATA
		enumParam = new EnumParam(PARAM_DATA, "data_scan_mode", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_DATA, "Set if non-executable pages should be scanned.");
			for (size_t i = 0; i < PE_DATA_COUNT; i++) {
				t_data_scan_mode mode = (t_data_scan_mode)(i);
				enumParam->addEnumValue(mode, translate_data_mode(mode));
			}
		}

		//PARAM_DUMP_MODE
		enumParam = new EnumParam(PARAM_DUMP_MODE, "dump_mode", false);
		if (enumParam) {
			this->addParam(enumParam);
			this->setInfo(PARAM_DUMP_MODE, "Set in which mode the detected PE files should be dumped.");
			for (size_t i = 0; i < PE_DUMP_MODES_COUNT; i++) {
				peconv::t_pe_dump_mode mode = (peconv::t_pe_dump_mode)(i);
				enumParam->addEnumValue(mode, dump_mode_to_id(mode), translate_dump_mode(mode));
			}
		}

		//PARAM_DIR
		this->addParam(new StringParam(PARAM_DIR, false));
		this->setInfo(PARAM_DIR, "Set a root directory for the output (default: current directory).");

		//optional: group parameters
		std::string str_group = "5. output options";
		this->addGroup(new ParamGroup(str_group));
		this->addParamToGroup(PARAM_DIR, str_group);
		this->addParamToGroup(PARAM_JSON, str_group);
		this->addParamToGroup(PARAM_JSON_LVL, str_group);
		this->addParamToGroup(PARAM_OUT_FILTER, str_group);

		str_group = "1. scanner settings";
		this->addGroup(new ParamGroup(str_group));
		this->addParamToGroup(PARAM_QUIET, str_group);
		this->addParamToGroup(PARAM_REFLECTION, str_group);

		str_group = "3. scan options";
		this->addGroup(new ParamGroup(str_group));
		this->addParamToGroup(PARAM_DATA, str_group);
		this->addParamToGroup(PARAM_IAT, str_group);
		this->addParamToGroup(PARAM_SHELLCODE, str_group);
		this->addParamToGroup(PARAM_THREADS, str_group);

		str_group = "4. dump options";
		this->addGroup(new ParamGroup(str_group));
		this->addParamToGroup(PARAM_MINIDUMP, str_group);
		this->addParamToGroup(PARAM_IMP_REC, str_group);
		this->addParamToGroup(PARAM_DUMP_MODE, str_group);

		str_group = "2. scan exclusions";
		this->addGroup(new ParamGroup(str_group));
		this->addParamToGroup(PARAM_DOTNET_POLICY, str_group);
		this->addParamToGroup(PARAM_MODULES_IGNORE, str_group);
	}

	bool fillStringParam(const std::string &paramId, PARAM_STRING &strparam)
	{
		StringParam* myStr = dynamic_cast<StringParam*>(this->getParam(paramId));
		if (!myStr || !myStr->isSet()) {
			return false;
		}
		std::string val = myStr->valToString();
		const size_t len = val.length();
		if (!len) {
			return false;
		}
		alloc_strparam(strparam, len);
		bool is_copied = false;
		if (strparam.buffer) {
			is_copied = copyCStr<StringParam>(paramId, strparam.buffer, strparam.length);
		}
		return is_copied;
	}

	void fillStruct(t_params &ps)
	{
		copyVal<IntParam>(PARAM_PID, ps.pid);
		copyVal<EnumParam>(PARAM_IMP_REC, ps.imprec_mode);
		copyVal<EnumParam>(PARAM_OUT_FILTER, ps.out_filter);

		fillStringParam(PARAM_MODULES_IGNORE, ps.modules_ignored);

		copyVal<BoolParam>(PARAM_QUIET, ps.quiet);
		copyVal<BoolParam>(PARAM_JSON, ps.json_output);

		copyVal<EnumParam>(PARAM_JSON_LVL, ps.json_lvl);

		copyVal<BoolParam>(PARAM_MINIDUMP, ps.minidump);
		copyVal<BoolParam>(PARAM_SHELLCODE, ps.shellcode);
		copyVal<BoolParam>(PARAM_THREADS, ps.threads);
		copyVal<BoolParam>(PARAM_REFLECTION, ps.make_reflection);

		copyVal<EnumParam>(PARAM_IAT, ps.iat);
		copyVal<EnumParam>(PARAM_DOTNET_POLICY, ps.dotnet_policy);
		copyVal<EnumParam>(PARAM_DATA, ps.data);
		copyVal<EnumParam>(PARAM_DUMP_MODE, ps.dump_mode);

		copyCStr<StringParam>(PARAM_DIR, ps.output_dir, _countof(ps.output_dir));
	}

	void printBanner()
	{
		char logo[] = "\
.______    _______           _______. __   ___________    ____  _______ \n\
|   _  \\  |   ____|         /       ||  | |   ____\\   \\  /   / |   ____|\n\
|  |_)  | |  |__    ______ |   (----`|  | |  |__   \\   \\/   /  |  |__   \n\
|   ___/  |   __|  |______| \\   \\    |  | |   __|   \\      /   |   __|  \n\
|  |      |  |____      .----)   |   |  | |  |____   \\    /    |  |____ \n\
| _|      |_______|     |_______/    |__| |_______|   \\__/     |_______|\n";

		char logo2[] = "\
  _        _______       _______      __   _______     __       _______ \n";
		char logo3[] = "\
________________________________________________________________________\n";
		paramkit::print_in_color(DARK_GREEN, logo);
		paramkit::print_in_color(DARK_RED, logo2);
		paramkit::print_in_color(DARK_RED, logo3);
		std::cout << "\n";
		std::cout << pesieve::info();
	}

};

```

`params_info/pe_sieve_params_info.cpp`:

```cpp
#include "pe_sieve_params_info.h"

#include <windows.h>

using namespace pesieve;

std::string pesieve::translate_dump_mode(const DWORD dump_mode)
{
	switch (dump_mode) {
	case pesieve::PE_DUMP_AUTO:
		return "autodetect (default)";
	case pesieve::PE_DUMP_VIRTUAL:
		return "virtual (as is in the memory, no unmapping)";
	case pesieve::PE_DUMP_UNMAP:
		return "unmapped (converted to raw using sections' raw headers)";
	case pesieve::PE_DUMP_REALIGN:
		return "realigned raw (converted raw format to be the same as virtual)";
	}
	return "undefined";
}

std::string pesieve::dump_mode_to_id(const DWORD dump_mode)
{
	switch (dump_mode) {
	case pesieve::PE_DUMP_AUTO:
		return "A";
	case pesieve::PE_DUMP_VIRTUAL:
		return "V";
	case pesieve::PE_DUMP_UNMAP:
		return "U";
	case pesieve::PE_DUMP_REALIGN:
		return "R";
	}
	return "N";
}

std::string pesieve::translate_out_filter(const pesieve::t_output_filter o_filter)
{
	switch (o_filter) {
	case pesieve::OUT_FULL:
		return "no filter: dump everything (default)";
	case pesieve::OUT_NO_DUMPS:
		return "don't dump the modified PEs, but save the report";
	case pesieve::OUT_NO_DIR:
		return "don't dump any files";
	}
	return "undefined";
}

std::string pesieve::translate_imprec_mode(const pesieve::t_imprec_mode imprec_mode)
{
	switch (imprec_mode) {
	case pesieve::PE_IMPREC_NONE:
		return "none: do not recover imports (default)";
	case pesieve::PE_IMPREC_AUTO:
		return "try to autodetect the most suitable mode";
	case pesieve::PE_IMPREC_UNERASE:
		return "unerase the erased parts of the partialy damaged ImportTable";
	case pesieve::PE_IMPREC_REBUILD0:
		return "build the ImportTable from scratch, basing on the found IATs:\n\t         use only terminated blocks (restrictive mode)";
	case pesieve::PE_IMPREC_REBUILD1:
		return "build the ImportTable from scratch, basing on the found IATs:\n\t         use terminated blocks, or blocks with more than 1 thunk";
	case pesieve::PE_IMPREC_REBUILD2:
		return "build the ImportTable from scratch, basing on the found IATs:\n\t         use all found blocks (aggressive mode)";
	}
	return "undefined";
}


std::string pesieve::imprec_mode_to_id(const pesieve::t_imprec_mode imprec_mode)
{
	switch (imprec_mode) {
	case pesieve::PE_IMPREC_NONE:
		return "N";
	case pesieve::PE_IMPREC_AUTO:
		return "A";
	case pesieve::PE_IMPREC_UNERASE:
		return "U";
	case pesieve::PE_IMPREC_REBUILD0:
		return "R0";
	case pesieve::PE_IMPREC_REBUILD1:
		return "R1";
	case pesieve::PE_IMPREC_REBUILD2:
		return "R2";
	}
	return "N";
}


std::string pesieve::translate_dotnet_policy(const pesieve::t_dotnet_policy &mode)
{
	switch (mode) {
	case pesieve::PE_DNET_NONE:
		return "none: treat managed processes same as native";
	case pesieve::PE_DNET_SKIP_MAPPING:
		return "skip mapping mismatch (in .NET modules only)";
	case pesieve::PE_DNET_SKIP_SHC:
		return "skip shellcodes (in all modules within the managed process)";
	case pesieve::PE_DNET_SKIP_HOOKS:
		return "skip hooked modules (in all modules within the managed process)";
	case pesieve::PE_DNET_SKIP_ALL:
		return "skip all the above (mapping, shellcodes, hooks)";
	}
	return "undefined";
}

std::string pesieve::translate_data_mode(const pesieve::t_data_scan_mode &mode)
{
	switch (mode) {
	case pesieve::PE_DATA_NO_SCAN:
		return "none: do not scan non-executable pages"; 
	case pesieve::PE_DATA_SCAN_DOTNET:
		return ".NET: scan non-executable in .NET applications";
	case pesieve::PE_DATA_SCAN_NO_DEP:
		return "if no DEP: scan non-exec if DEP is disabled (or if is .NET)";
	case pesieve::PE_DATA_SCAN_ALWAYS:
		return "always: scan non-executable pages unconditionally";
	case pesieve::PE_DATA_SCAN_INACCESSIBLE:
		return "include inaccessible: scan non-executable pages unconditionally;\n\t    in reflection mode (/refl): scan also inaccessible pages";
	case pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY:
		return "scan inaccessible pages, but exclude other non-executable;\n\t    works in reflection mode (/refl) only";
	}
	return "undefined";
}

std::string pesieve::translate_json_level(const pesieve::t_json_level &mode)
{
	switch (mode) {
	case pesieve::JSON_BASIC:
		return "basic";
	case pesieve::JSON_DETAILS:
		return "details #1 (list patches)";
	case pesieve::JSON_DETAILS2:
		return "details #2 (list patches: extended)";
	}
	return "undefined";
}

std::string pesieve::translate_iat_scan_mode(const pesieve::t_iat_scan_mode mode)
{
	switch (mode) {
	case pesieve::PE_IATS_NONE:
		return "none: do not scan for IAT Hooks (default)";
	case pesieve::PE_IATS_CLEAN_SYS_FILTERED:
		return "scan IAT, filter hooks that lead to unpatched system module";
	case pesieve::PE_IATS_ALL_SYS_FILTERED:
		return "scan IAT, filter hooks that lead to ANY system module";
	case pesieve::PE_IATS_UNFILTERED:
		return "unfiltered: scan for IAT Hooks, report all";
	}
	return "undefined";
}

```

`params_info/pe_sieve_params_info.h`:

```h
#pragma once

#include <iostream>
#include <pe_sieve_types.h>

namespace pesieve {
	std::string translate_dump_mode(const DWORD dump_mode);
	std::string translate_out_filter(const pesieve::t_output_filter o_filter);
	std::string translate_data_mode(const pesieve::t_data_scan_mode &mode);
	std::string translate_imprec_mode(const pesieve::t_imprec_mode imprec_mode);
	std::string translate_dotnet_policy(const pesieve::t_dotnet_policy &mode);
	std::string translate_iat_scan_mode(const pesieve::t_iat_scan_mode mode);
	std::string translate_json_level(const pesieve::t_json_level &mode);

	std::string dump_mode_to_id(const DWORD dump_mode);
	std::string imprec_mode_to_id(const pesieve::t_imprec_mode imprec_mode);
};


```

`pe_sieve.cpp`:

```cpp
#include "pe_sieve.h"
#include <peconv.h>

#include <windows.h>
#include "scanners/scanner.h"

#include "utils/format_util.h"
#include "utils/process_util.h"
#include "utils/process_privilege.h"
#include "utils/process_minidump.h"
#include "utils/path_converter.h"
#include "postprocessors/results_dumper.h"
#include "utils/process_reflection.h"
#include "utils/console_color.h"
#include "color_scheme.h"

using namespace pesieve;
using namespace pesieve::util;

namespace pesieve {
	void check_access_denied(DWORD processID)
	{
		HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, processID);
		if (!hProcess) {
			std::cerr << "-> Access denied. Try to run the scanner as Administrator." << std::endl;
			return;
		}
		process_integrity_t level = get_integrity_level(hProcess);
		switch (level) {
		case INTEGRITY_UNKNOWN:
			std::cerr << "-> Access denied. Could not query the process token." << std::endl;
			break;
		case INTEGRITY_SYSTEM:
			std::cerr << "-> Access denied. Could not access the system process." << std::endl;
			break;
		default:
			break;
		}
		CloseHandle(hProcess);
		hProcess = NULL;
	}

	bool is_scanner_compatible(IN HANDLE hProcess)
	{
		BOOL isCurrWow64 = FALSE;
		is_process_wow64(GetCurrentProcess(), &isCurrWow64);
		
		BOOL isRemoteWow64 = FALSE;
		is_process_wow64(hProcess, &isRemoteWow64);

		if (isCurrWow64 && !isRemoteWow64) {
			return false;
		}
		return true;
	}

	// throws std::runtime_error if opening the process failed
	HANDLE open_process(DWORD processID, bool reflection, bool quiet)
	{
		const DWORD basic_access = SYNCHRONIZE | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION;
		DWORD access = basic_access;
		if (reflection) {
			access |= pesieve::util::reflection_access | PROCESS_VM_OPERATION;
		}

		HANDLE hProcess = OpenProcess(access, FALSE, processID);

		// if failed, try to open with the lower reflection access
		if (!hProcess && access != basic_access && access != pesieve::util::reflection_access1) {
			hProcess = OpenProcess(pesieve::util::reflection_access1, FALSE, processID);
		}

		// if failed, try to open with basic rights
		if (!hProcess && access != basic_access) {
			hProcess = OpenProcess( basic_access, FALSE, processID);
		}

		// check process compatibility
		if (hProcess && !is_scanner_compatible(hProcess) && !quiet) {
			util::print_in_color(WARNING_COLOR, "[!] Scanner mismatch! Try to use the 64bit version of the scanner!\n", true);
		}

		// opening succeeded, return the handle:
		if (hProcess) {
			return hProcess;
		}

		const DWORD last_err = GetLastError();

		if (last_err == ERROR_ACCESS_DENIED) {
			if (!quiet) {
				std::cerr << "[-][" << processID << "] Could not open the process Error: " << last_err << std::endl;
				//print more info:
				check_access_denied(processID);
			}

			SetLastError(ERROR_ACCESS_DENIED);
			throw std::runtime_error("Could not open the process: Access Denied");
			return nullptr;
		}
		if (last_err == ERROR_INVALID_PARAMETER) {
			if (!quiet) {
				std::cerr << "-> Is this process still running?" << std::endl;
			}
			SetLastError(ERROR_INVALID_PARAMETER);
			throw std::runtime_error("Could not open the process: Invalid Parameter");
		}
		return hProcess;
	}

	pesieve::ProcessDumpReport* make_dump(IN HANDLE hProcess, IN bool isRefl, IN const pesieve::t_params &args, IN ProcessScanReport &process_report)
	{
		if (!hProcess) {
			return nullptr;
		}
		if (args.out_filter == OUT_NO_DIR) {
			// dumping disabled
			return nullptr;
		}
		ProcessDumpReport* dumpReport = nullptr;
		ResultsDumper dumper(expand_path(args.output_dir), args.quiet);

		if (dumper.dumpJsonReport(process_report, ProcessScanReport::REPORT_SUSPICIOUS_AND_ERRORS, args.json_lvl) && !args.quiet) {
			std::cout << "[+] Report dumped to: " << dumper.getOutputDir() << std::endl;
		}
		
		if (args.out_filter != OUT_NO_DUMPS) {
			pesieve::t_dump_mode dump_mode = pesieve::PE_DUMP_AUTO;
			if (args.dump_mode < peconv::PE_DUMP_MODES_COUNT) {
				dump_mode = pesieve::t_dump_mode(args.dump_mode);
			}
			size_t dumped_modules = 0;
			dumpReport = dumper.dumpDetectedModules(hProcess, isRefl, process_report, dump_mode, args.imprec_mode);
			if (dumpReport && dumpReport->countDumped()) {
				dumped_modules = dumpReport->countDumped();
			}
			if (!args.quiet && dumped_modules) {
				std::cout << "[+] Dumped modified to: " << dumper.getOutputDir() << std::endl;
			}
		}
		if (args.minidump) {
			pesieve::t_report report = process_report.generateSummary();
			if (report.suspicious > 0) {
				if (!args.quiet) {
					std::cout << "[*] Creating minidump..." << std::endl;
				}
				std::string original_path = process_report.mainImagePath;
				std::string file_name = peconv::get_file_name(original_path);
				std::string dump_file = dumper.makeOutPath(file_name + ".dmp");
				if (make_minidump(process_report.getPid(), dump_file)) {
					if (!dumpReport) {
						dumpReport = new ProcessDumpReport(process_report.getPid());
					}
					dumpReport->minidumpPath = dump_file;
					if (!args.quiet) {
						std::cout << "[+] Minidump saved to: " << dumpReport->minidumpPath << std::endl;
					}
				}
				else if (!args.quiet) {
					std::cout << "[-] Creating minidump failed! " << std::endl;
				}
			}
		}
		if (dumpReport) {
			dumpReport->outputDir = dumper.getOutputDir();
			if (dumper.dumpJsonReport(*dumpReport) && !args.quiet) {
				std::cout << "[+] Report dumped to: " << dumper.getOutputDir() << std::endl;
			}
		}
		return dumpReport;
	}

}; //namespace pesieve


pesieve::ReportEx* pesieve::scan_and_dump(IN const pesieve::t_params args)
{
	ReportEx *report = new(std::nothrow) ReportEx();
	if (!report) {
		// should not happen
		return nullptr;
	}
	HANDLE orig_proc = nullptr; // original process handle
	HANDLE cloned_proc = nullptr; // process reflection handle

	if (!set_debug_privilege()) {
		if (!args.quiet) std::cerr << "[-] Could not set debug privilege" << std::endl;
	}

	try {
		orig_proc = open_process(args.pid, args.make_reflection, args.quiet);
		HANDLE target_proc = orig_proc;

		if (args.make_reflection) {
			cloned_proc = make_process_reflection(orig_proc);
			if (cloned_proc) {
				target_proc = cloned_proc;
			}
			else {
				if (!args.quiet) std::cerr << "[-] Failed to create the process reflection" << std::endl;
			}
		}

		if (!args.quiet) {
			if (cloned_proc) {
				std::cout << "[*] Using process reflection!\n";
			}
			else {
				std::cout << "[*] Using raw process!\n";
				if (args.data == pesieve::PE_DATA_SCAN_INACCESSIBLE || args.data == pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY) {
					print_in_color(WARNING_COLOR, "[WARNING] Scanning of inaccessible pages is possible only in reflection mode!\n");
				}
			}
		}

		const bool is_reflection = (cloned_proc) ? true : false;
		ProcessScanner scanner(target_proc, is_reflection, args);
		report->scan_report = scanner.scanRemote();

		// dump process
		if (report->scan_report) {
			report->dump_report = make_dump(target_proc, is_reflection, args, *report->scan_report);
		}
	}
	catch (std::exception &e) {
		delete report;
		report = nullptr;

		if (!args.quiet) {
			util::print_in_color(ERROR_COLOR, std::string("[ERROR] ") + e.what() + "\n", true);
		}
	}
	if (cloned_proc) {
		release_process_reflection(&cloned_proc);
	}
	CloseHandle(orig_proc);
	return report;
}

std::string pesieve::info()
{
	std::stringstream stream;
	stream << "Version:  " << PESIEVE_VERSION;
#ifdef _WIN64
	stream << " (x64)" << "\n";
#else
	stream << " (x86)" << "\n";
#endif
	stream << "Built on: " << __DATE__ << "\n\n";
	stream << "~ from hasherezade with love ~\n";
	stream << "Scans a given process, recognizes and dumps a variety of in-memory implants:\nreplaced/injected PEs, shellcodes, inline hooks, patches etc.\n";
	stream << "URL: " << PESIEVE_URL << "\n";
	return stream.str();
}

```

`pe_sieve.h`:

```h
/**
* @file
* @brief   The root of the PE-sieve scanner.
*/

#pragma once

#include <windows.h>
#include <iostream>
#include <stdexcept>

#include <pe_sieve_version.h>
#include <pe_sieve_types.h>
#include <pe_sieve_return_codes.h>

#include "scanners/scan_report.h"
#include "postprocessors/dump_report.h"
#include "postprocessors/report_formatter.h"

namespace pesieve {

	//! The final report about the actions performed on the process: scanning and dumping
	class ReportEx {
	public:
		ReportEx() :
			scan_report(nullptr), dump_report(nullptr)
		{
		}

		~ReportEx()
		{
			delete scan_report;
			delete dump_report;
		}

		ProcessScanReport* scan_report; ///< the report aggregating the results of the performed scans
		ProcessDumpReport* dump_report; ///< the report aggregating the results of the performed dumps
	};

	//! The string with the basic information about the scanner.
	std::string info();

	//! The main action performed by PE-sieve: scanning the process and dumping the detected material.
	/**
	\param args : the configuration of the scan (defined as t_params)
	\return A pointer to the generated report (of type ReportEx)
	*/
	ReportEx* scan_and_dump(IN const pesieve::t_params args);
};

```

`pe_sieve_api.cpp`:

```cpp
#include <windows.h>
#include <string>
#include <iostream>

#include "pe_sieve.h"

#define PESIEVE_EXPORTS
#include <pe_sieve_api.h>

#define LIB_NAME "PE-sieve"

PEsieve_report PESIEVE_API_FUNC PESieve_scan(const PEsieve_params args)
{
	const pesieve::ReportEx* report = pesieve::scan_and_dump(args);
	if (report == nullptr) {
		pesieve::t_report nullrep = { 0 };
		nullrep.pid = args.pid;
		nullrep.errors = pesieve::ERROR_SCAN_FAILURE;
		return nullrep;
	}
	pesieve::t_report summary = report->scan_report->generateSummary();
	delete report;
	return summary;
}

void PESIEVE_API_FUNC PESieve_help(void)
{
	std::string my_info = pesieve::info();

	std::cout << my_info;
	MessageBox(NULL, my_info.c_str(), LIB_NAME, MB_ICONINFORMATION);
}

extern const DWORD PESIEVE_API PESieve_version = pesieve::PESIEVE_VERSION_ID;

```

`postprocessors/dump_report.cpp`:

```cpp
#include "dump_report.h"

#include "../utils/format_util.h"

using namespace pesieve::util;

const bool pesieve::ModuleDumpReport::toJSON(std::stringstream &outs, size_t level)
{
	OUT_PADDED(outs, level, "\"module\" : ");
	outs << "\"" << std::hex << moduleStart << "\"" << ",\n";
	OUT_PADDED(outs, level, "\"module_size\" : ");
	outs << "\"" << std::hex << moduleSize << "\"" << ",\n";
	if (dumpFileName.length()) {
		OUT_PADDED(outs, level, "\"dump_file\" : ");
		outs << "\"" << peconv::get_file_name(dumpFileName) << "\"" << ",\n";
	}
	if (tagsFileName.length()) {
		OUT_PADDED(outs, level, "\"tags_file\" : ");
		outs << "\"" << peconv::get_file_name(tagsFileName) << "\"" << ",\n";
	}
	if (impListFileName.length()) {
		OUT_PADDED(outs, level, "\"imports_file\" : ");
		outs << "\"" << peconv::get_file_name(impListFileName) << "\"" << ",\n";
	}
	if (impRecMode.length()) {
		OUT_PADDED(outs, level, "\"imp_rec_result\" : ");
		outs << "\"" << impRecMode << "\"" << ",\n";
		if (notRecoveredFileName.length()) {
			OUT_PADDED(outs, level, "\"imp_not_recovered_file\" : ");
			outs << "\"" << peconv::get_file_name(notRecoveredFileName) << "\"" << ",\n";
		}
	}
	if (this->iatHooksFileName.length()) {
		OUT_PADDED(outs, level, "\"iat_hooks_file\" : ");
		outs << "\"" << peconv::get_file_name(iatHooksFileName) << "\"" << ",\n";
	}
	if (mode_info.length()) {
		OUT_PADDED(outs, level, "\"dump_mode\" : ");
		outs << "\"" << mode_info << "\"" << ",\n";
	}
	OUT_PADDED(outs, level, "\"is_shellcode\" : ");
	outs << std::dec << is_shellcode << ",\n";
	if (is_corrupt_pe) {
		OUT_PADDED(outs, level, "\"is_corrupt_pe\" : ");
		outs << std::dec << is_corrupt_pe << ",\n";
	}

	OUT_PADDED(outs, level, "\"status\" : ");
	outs << std::dec << this->isDumped;
	return true;
}

// ProcessDumpReport

const bool pesieve::ProcessDumpReport::toJSON(std::stringstream &stream, size_t level)
{
	stream << "{\n";
	OUT_PADDED(stream, level, "\"pid\" : ");
	stream << std::dec << getPid() << ",\n";

	OUT_PADDED(stream, level, "\"output_dir\" : \"");
	stream << escape_path_separators(outputDir) << "\",\n";
	if (minidumpPath.length()) {
		OUT_PADDED(stream, level, "\"minidump_path\" : \"");
		stream << escape_path_separators(this->minidumpPath) << "\",\n";
	}

	OUT_PADDED(stream, level, "\"dumped\" : \n");
	OUT_PADDED(stream, level, "{\n");
	//stream << " {\n";
	OUT_PADDED(stream, level + 1, "\"total\" : ");
	stream << std::dec << countTotal() << ",\n";
	OUT_PADDED(stream, level + 1, "\"dumped\" : ");
	stream << std::dec << countDumped() << "\n";
	OUT_PADDED(stream, level, "},\n"); // scanned
	stream << list_dumped_modules(level);
	stream << "}\n";

	return true;
}

std::string pesieve::ProcessDumpReport::list_dumped_modules(size_t level)
{
	std::stringstream stream;
	//summary:
	OUT_PADDED(stream, level, "\"dumps\" : [\n");
	bool is_first = true;
	std::vector<ModuleDumpReport*>::const_iterator itr;
	for (itr = moduleReports.begin(); itr != moduleReports.end(); ++itr) {
		ModuleDumpReport *mod = *itr;
		if (mod->isDumped || mod->isReportDumped) {
			if (!is_first) {
				stream << ",\n";
			}
			OUT_PADDED(stream, level + 1, "{\n");
			if (mod->toJSON(stream, level + 2)) {
				stream << "\n";
			}
			OUT_PADDED(stream, level + 1, "}");
			is_first = false;
		}
	}
	if (moduleReports.size()) {
		stream << "\n";
	}
	OUT_PADDED(stream, level, "]\n");
	return stream.str();
}

```

`postprocessors/dump_report.h`:

```h
#pragma once

#include <windows.h>

#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include <peconv.h>
#include "../utils/path_util.h"
#include "../utils/path_converter.h"

namespace pesieve {

	class ModuleDumpReport
	{
	public:

		ModuleDumpReport(ULONGLONG module_start, size_t module_size)
			: moduleStart(module_start), moduleSize(module_size),
			isDumped(false), isReportDumped(false),
			is_corrupt_pe(false),
			is_shellcode(false)
		{
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level);

		ULONGLONG moduleStart;
		size_t moduleSize;
		bool is_corrupt_pe;
		bool is_shellcode;
		std::string impRecMode;
		bool isReportDumped;
		bool isDumped;
		std::string mode_info;
		std::string dumpFileName;
		std::string tagsFileName;
		std::string impListFileName;
		std::string notRecoveredFileName;
		std::string iatHooksFileName;
	};

	//! The report aggregating the results of the performed dumps
	class ProcessDumpReport
	{
	public:
		ProcessDumpReport(DWORD _pid)
			: pid(_pid)
		{
		}

		~ProcessDumpReport()
		{
			deleteModuleReports();
		}

		void appendReport(ModuleDumpReport *report)
		{
			if (!report) return;
			moduleReports.push_back(report);
		}

		size_t countTotal() const
		{
			return moduleReports.size();
		}

		bool isFilled() const
		{
			if (countTotal()) return true;
			if (this->minidumpPath.length()) return true;
			return false;
		}

		size_t countDumped() const
		{
			size_t dumped = 0;
			std::vector<ModuleDumpReport*>::const_iterator itr = moduleReports.begin();
			for (; itr != moduleReports.end(); ++itr) {
				ModuleDumpReport* module = *itr;
				if (module->isDumped) {
					dumped++;
				}
			}
			return dumped;
		}

		const virtual bool toJSON(std::stringstream &stream, size_t level);

		DWORD getPid() const { return pid; }

		std::string outputDir;
		std::string minidumpPath;

	protected:

		std::string list_dumped_modules(size_t level);

		void deleteModuleReports()
		{
			std::vector<ModuleDumpReport*>::iterator itr = moduleReports.begin();
			for (; itr != moduleReports.end(); ++itr) {
				ModuleDumpReport* module = *itr;
				delete module;
			}
			moduleReports.clear();
		}

		DWORD pid;
		std::vector<ModuleDumpReport*> moduleReports;

		friend class ResultsDumper;
	};

};


```

`postprocessors/imp_rec/iat_block.cpp`:

```cpp
#include "iat_block.h"
#include <peconv.h>

namespace pesieve {
	size_t get_longest_func_name(std::map<ULONGLONG, std::set<peconv::ExportedFunc>> &addrToFunc)
	{
		size_t max_len = 0;
		std::map<ULONGLONG, std::set<peconv::ExportedFunc>>::iterator itr;
		for (itr = addrToFunc.begin(); itr != addrToFunc.end(); ++itr) {
			std::set<peconv::ExportedFunc> &expSet = itr->second;
			const peconv::ExportedFunc& exp = *(expSet.begin());
			if (exp.isByOrdinal) {
				continue;
			}
			if (exp.funcName.length() > max_len) {
				max_len = exp.funcName.length();
			}
		}
		return max_len;
	}
};

//---

bool pesieve::IATThunksSeries::makeCoverage(IN const peconv::ExportsMapper* exportsMap)
{
	delete cov; //delete previous
	cov = new peconv::ImportedDllCoverage(funcAddresses, *exportsMap);
	if (!cov->findCoveringDll()) {
		// DLL not found
		return false;
	}
	size_t covered_count = cov->mapAddressesToFunctions(cov->dllName);
	this->dllFullName = exportsMap->get_dll_fullname(cov->dllName);
	this->covered = (covered_count == this->funcAddresses.size());
	return this->covered;
}

bool pesieve::IATThunksSeries::fillNamesSpace(const BYTE* buf_start, size_t buf_size, DWORD bufRVA, bool is64b)
{
	if (!buf_start || !this->cov) return false;

	if (!this->cov->isMappingComplete()) {
		return false; //TODO: make a workaround for this case
	}

	const size_t longest_name = get_longest_func_name(this->cov->addrToFunc);
	const size_t field_size = is64b ? sizeof(ULONGLONG) : sizeof(DWORD);

	const size_t thunks_count = this->cov->addrToFunc.size();
	const size_t thunks_area_size = (thunks_count * field_size) + field_size;

	size_t names_rva = bufRVA + thunks_area_size;

	//fill thunks:
	BYTE *buf = const_cast<BYTE*>(buf_start);
	const BYTE *buf_end = buf_start + buf_size;
	std::map<ULONGLONG, std::set<peconv::ExportedFunc>>::iterator itr;
	for (itr = this->cov->addrToFunc.begin(); itr != cov->addrToFunc.end() && buf < buf_end; ++itr) {

		std::set<peconv::ExportedFunc> &expSet = itr->second;
		const peconv::ExportedFunc& exp = *(expSet.begin());
		if (is64b) {
			ULONGLONG *val = (ULONGLONG*)buf;
			*val = names_rva;
		}
		else {
			DWORD *val = (DWORD*)buf;
			*val = MASK_TO_DWORD(names_rva);
		}
		//no need to fill names, they will be autofilled during dumping
		buf += field_size;
		names_rva += sizeof(IMAGE_IMPORT_BY_NAME) + longest_name;
	}
	return true;
}

size_t pesieve::IATThunksSeries::sizeOfNamesSpace(bool is64b)
{
	if (!cov) return 0;

	size_t space_size = 0;
	if (!this->cov->isMappingComplete()) {
		return 0; //TODO: make a workaround for this case
	}
	const size_t longest_name = get_longest_func_name(this->cov->addrToFunc);
	const size_t field_size = is64b ? sizeof(ULONGLONG) : sizeof(DWORD);
	std::map<ULONGLONG, std::set<peconv::ExportedFunc>>::iterator itr;
	for (itr = this->cov->addrToFunc.begin(); itr != cov->addrToFunc.end(); ++itr) {
		std::set<peconv::ExportedFunc> &expSet = itr->second;
		const peconv::ExportedFunc& exp = *(expSet.begin());
		space_size += field_size;
		space_size += sizeof(IMAGE_IMPORT_BY_NAME) + longest_name;
	}
	if (space_size > 0) {
		space_size += sizeof(field_size);
	}
	return space_size;
}

std::string pesieve::IATThunksSeries::getDllName()
{
	return this->dllFullName;
}

//---

bool pesieve::IATBlock::makeCoverage(IN const peconv::ExportsMapper* exportsMap)
{
	if (!exportsMap) return false;

	IATThunksSeriesSet::iterator itr;
	std::set<IATThunksSeries*>to_split;

	for (itr = this->thunkSeries.begin(); itr != thunkSeries.end(); ++itr) {
		IATThunksSeries* series = *itr;
		if (!series->makeCoverage(exportsMap)) {
			to_split.insert(series);
		}
	}

	std::set<IATThunksSeries*>::iterator sItr;
	for (sItr = to_split.begin(); sItr != to_split.end(); ++sItr) {
		IATThunksSeries *series = *sItr;
		IATThunksSeriesSet splitted = splitSeries(series, *exportsMap);
		if (!splitted.size()) {
			continue;
		}
#ifdef _DEBUG
		std::cout << "Uncovered series splitted into: " << splitted.size() << " series\n";
#endif
		this->thunkSeries.erase(series);
		this->thunkSeries.insert(splitted.begin(), splitted.end());
		
		delete series; // delete the series that have been splitted
	}

	size_t covered_count = 0;
	for (itr = this->thunkSeries.begin(); itr != thunkSeries.end(); ++itr) {
		IATThunksSeries* series = *itr;
		
		if (series->isCovered() || series ->makeCoverage(exportsMap)) {
			covered_count++;
		}
	}

	isCoverageComplete = (covered_count == this->thunkSeries.size());
	return isCoverageComplete;
}

pesieve::IATThunksSeriesSet pesieve::IATBlock::splitSeries(IN IATThunksSeries* series, IN const peconv::ExportsMapper &exportsMap)
{
	IATThunksSeriesSet splitted;
	if (!series) return splitted;

	std::map<DWORD, ULONGLONG> addresses = series->getRvaToFuncMap();

	IATThunksSeries *new_series = nullptr;
	std::map<DWORD, ULONGLONG>::iterator itr;
	std::string last_dll = "";

	for (itr = addresses.begin(); itr != addresses.end(); ++itr) {
		ULONGLONG func_addr = itr->second;
		DWORD offset = itr->first;
		const peconv::ExportedFunc *func = exportsMap.find_export_by_va(func_addr);
		if (new_series && (!func || func->libName != last_dll)) {
			//close series
			splitted.insert(new_series);
			new_series = nullptr;
			last_dll = "";
		}
		if (!func) continue;

		if (!new_series) {
			new_series = new IATThunksSeries(offset);
			last_dll = func->libName;
#ifdef _DEBUG
			std::cout << std::hex << "addr:  " << offset << " set DLL: " << last_dll << "\n";
#endif
		}
		new_series->insert(offset, func_addr);
	}
	if (new_series) {
		splitted.insert(new_series);
	}
	return splitted;
}

size_t pesieve::IATBlock::maxDllLen()
{
	size_t max_size = 0;
	IATThunksSeriesSet::iterator itr;
	for (itr = this->thunkSeries.begin(); itr != thunkSeries.end(); ++itr) {
		IATThunksSeries* series = *itr;
		size_t curr_size = series->getDllName().length() + 1;
		if (curr_size > max_size) max_size = curr_size;
	}
	return max_size;
}

size_t pesieve::IATBlock::sizeOfDllsSpace()
{
	const size_t max_len = maxDllLen();
	return max_len * (thunkSeries.size() + 1);
}

std::string pesieve::IATBlock::toString()
{
	std::stringstream stream;
	stream << "---\nIAT at: " << std::hex << iatOffset << ", size: " << iatSize << ", thunks: "
		<< countThunks() << ", is_terminated: " << isTerminated << ", in_main: " << isInMain << "\n";

	if (this->importTableOffset) {
		stream << "ImportTable: " << std::hex << importTableOffset << "\n";
	}
	stream << "---\n";
	std::map<ULONGLONG, const peconv::ExportedFunc*>::const_iterator itr;
	for (itr = functions.begin(); itr != functions.end(); ++itr) {
		ULONGLONG offset = itr->first;
		const peconv::ExportedFunc* exp = itr->second;

		stream << std::hex << offset << "," << addrToFunctionVA[offset] << "," << exp->toString() << "\n";
	}
	return stream.str();
}

```

`postprocessors/imp_rec/iat_block.h`:

```h
#pragma once 

#include <peconv.h>

#include <sstream>
#include <map>
#include <set>

namespace pesieve {

	class IATThunksSeries
	{
	public:
		IATThunksSeries(DWORD start_offset)
			: startOffset(start_offset), cov(nullptr), covered(false)
		{
		}

		~IATThunksSeries()
		{
			delete cov;
		}

		bool operator<(const IATThunksSeries &other) const
		{
			return startOffset < other.startOffset;
		}

		bool insert(DWORD rva, ULONGLONG funcAddr)
		{
			rvaToFuncVA[rva] = funcAddr;
			funcAddresses.insert(funcAddr);
			return true;
		}

		bool makeCoverage(IN const peconv::ExportsMapper* exportsMap);

		bool isCovered()
		{
			return covered;
		}

		std::string getDllName();

		//calculate the number of bytes required for filling imports names
		size_t sizeOfNamesSpace(bool is64b);

		// fill the buffer with imports thunks and names
		bool fillNamesSpace(const BYTE* buf_start, size_t buf_size, DWORD bufRVA, bool is64b);

		std::map<DWORD, ULONGLONG> getRvaToFuncMap()
		{
			return rvaToFuncVA;
		}

		DWORD startOffset;

	private:
		bool covered;
		std::string dllFullName;
		std::set<ULONGLONG> funcAddresses;
		std::map<DWORD, ULONGLONG> rvaToFuncVA;

		peconv::ImportedDllCoverage *cov;
	};

	struct IATThunksSeriesPtrCompare
	{
		bool operator()(const IATThunksSeries* lhs, const IATThunksSeries* rhs) const
		{
			if (!lhs || !rhs) return false;
			return *lhs < *rhs;
		}
	};

	typedef std::set<IATThunksSeries*, IATThunksSeriesPtrCompare> IATThunksSeriesSet;

	class IATBlock
	{
	public:
		IATBlock(bool _is64bit, DWORD _iat_offset)
			: is64bit(_is64bit),
			iatOffset(_iat_offset), iatSize(0),
			isInMain(false), isTerminated(false), isCoverageComplete(false),
			importTableOffset(0)
		{
		}

		~IATBlock()
		{
			deleteThunkSeries();
		}

		bool operator<(const IATBlock &other) const
		{
			return iatOffset < other.iatOffset;
		}

		void appendSeries(IATThunksSeries* series)
		{
			thunkSeries.insert(series);
		}

		bool append(ULONGLONG offset, ULONGLONG functionVA, const peconv::ExportedFunc *exp)
		{
			if (!exp) return false;

			functions[offset] = exp;
			addrToFunctionVA[offset] = functionVA;
			return true;
		}

		bool isCovered() const
		{
			return isCoverageComplete;
		}

		bool isValid() const
		{
			//allow for every block with complete coverage
			return isCovered();
		}

		//how many functions the IAT has
		size_t countThunks() const
		{
			return functions.size();
		}

		std::string toString();

		void deleteThunkSeries()
		{
			IATThunksSeriesSet::iterator itr;
			for (itr = this->thunkSeries.begin(); itr != thunkSeries.end(); ++itr) {
				delete *itr;
			}
			thunkSeries.clear();
		}

		bool makeCoverage(IN const peconv::ExportsMapper* exportsMap);

		size_t maxDllLen();
		size_t sizeOfDllsSpace();

		bool isTerminated; // is the IAT finished by 0
		bool isInMain; // is the IAT included in the one set in the Data Directory

		DWORD iatOffset;
		size_t iatSize;

		DWORD importTableOffset;

	protected:
		IATThunksSeriesSet splitSeries(IN IATThunksSeries* notCoveredSeries, IN const peconv::ExportsMapper& exportsMap);

		IATThunksSeriesSet thunkSeries;

		bool is64bit;
		bool isCoverageComplete;

		std::map<ULONGLONG, const peconv::ExportedFunc*> functions;
		std::map<ULONGLONG, ULONGLONG> addrToFunctionVA;

		friend class ImpReconstructor;
	};

};

```

`postprocessors/imp_rec/iat_finder.h`:

```h
#pragma once

#include <windows.h>
#include <peconv.h>

#include "iat_block.h"

#ifndef MASK_TO_DWORD
#define MASK_TO_DWORD(val) (val & 0xffffffff)
#endif

namespace pesieve {

	//!  A class containing callbacks for functions: find_iat, fill_iat
	class ThunkFoundCallback
	{
	public:
		ThunkFoundCallback()
		{
		}

		//!  the callback that will be called for each candidate for the imported function VA
		virtual bool shouldProcessVA(ULONGLONG va) = 0;

		//!  the callback that will be called validly resolved import
		virtual bool shouldAcceptExport(ULONGLONG va, const peconv::ExportedFunc &exp) = 0;
	};
	//---

	template <typename FIELD_T>
	size_t fill_iat(BYTE* vBuf, size_t vBufSize, IN const peconv::ExportsMapper* exportsMap, IN OUT IATBlock &iat, IN ThunkFoundCallback *callback)
	{
		if (!vBuf || !exportsMap || !iat.iatOffset) return 0;

		size_t max_check = vBufSize - sizeof(FIELD_T);
		if (max_check < sizeof(FIELD_T)) {
			return 0; //size check failed
		}

		iat.isTerminated = true;
		const peconv::ExportedFunc *exp = nullptr;

		IATThunksSeries *series = nullptr;
		bool is_terminated = true;
		FIELD_T *imp = (FIELD_T*)(iat.iatOffset + (ULONG_PTR)vBuf);
		for (; imp < (FIELD_T*)(vBuf + max_check); imp++) {
			if (*imp == 0) {
				is_terminated = true;
				if (series) {
					iat.appendSeries(series); //add filled series
					series = nullptr;
				}
				continue;
			}

			const FIELD_T imp_va = (*imp);

			if (callback) {
				if (!callback->shouldProcessVA(imp_va)) break;
			}

			//std::cout << "checking: " << std::hex << possible_rva << std::endl;
			const peconv::ExportedFunc *exp = exportsMap->find_export_by_va(imp_va);
			if (!exp) break;

			if (callback) {
				if (!callback->shouldAcceptExport(imp_va, *exp)) break;
			}

			is_terminated = false;
			DWORD offset = MASK_TO_DWORD((BYTE*)imp - vBuf);
			iat.append(offset, imp_va, exp);

			if (!series) series = new IATThunksSeries(offset);
			if (series) {
				series->insert(offset, imp_va);
			}
		}
		if (series) {
			iat.appendSeries(series); //add filled series
			series = nullptr;
		}
		iat.isTerminated = is_terminated;
		if (!exp && iat.iatOffset && iat.countThunks() > 0) {
			BYTE *iat_ptr = (BYTE*)(iat.iatOffset + (ULONG_PTR)vBuf);
			size_t diff = (BYTE*)imp - iat_ptr;
			iat.iatSize = diff;
			return iat.iatSize;
		}
		return 0; // invalid IAT
	}

	template <typename FIELD_T>
	IATBlock* find_iat(BYTE* vBuf, size_t vBufSize, IN const peconv::ExportsMapper* exportsMap, IN size_t search_offset, IN ThunkFoundCallback *callback)
	{
		if (!vBuf || !vBufSize ||  !exportsMap) return nullptr;

		const bool is64bit = (sizeof(FIELD_T) == sizeof(DWORD)) ? false : true;

		size_t max_check = vBufSize - sizeof(FIELD_T);
		if (search_offset > vBufSize || max_check < sizeof(FIELD_T)) {
			return nullptr; //size check failed
		}

		for (BYTE* ptr = vBuf + search_offset; ptr < vBuf + max_check; ptr++) {
			FIELD_T *to_check = (FIELD_T*)ptr;
			if (!peconv::validate_ptr(vBuf, vBufSize, to_check, sizeof(FIELD_T))) break;
			FIELD_T possible_va = (*to_check);
			if (possible_va == 0) continue;

			if (callback) {
				if (!callback->shouldProcessVA(possible_va)) continue;
			}

			//std::cout << "checking: " << std::hex << possible_rva << std::endl;
			const peconv::ExportedFunc *exp = exportsMap->find_export_by_va(possible_va);
			if (!exp) continue;

			if (callback) {
				if (!callback->shouldAcceptExport(possible_va, *exp)) continue;
			}

			DWORD iat_offset = DWORD(ptr - vBuf);
			IATBlock *iat_block = new IATBlock(is64bit, iat_offset);
			//validate IAT:
			size_t _iat_size = fill_iat<FIELD_T>(vBuf, vBufSize, exportsMap, *iat_block, callback);
			if (_iat_size > 0) {
				iat_block->iatSize = _iat_size;
				return iat_block;
			}
			delete iat_block; iat_block = nullptr;
		}
		return nullptr;
	}

}; //namespace pesieve


```

`postprocessors/imp_rec/imp_reconstructor.cpp`:

```cpp
#include "imp_reconstructor.h"

#include "iat_finder.h"
#include "import_table_finder.h"

#include <fstream>

using namespace pesieve;

#define MIN_THUNKS_COUNT 2

namespace pesieve {
	BYTE* get_buffer_space_at(IN BYTE* buffer, IN const size_t buffer_size, IN const DWORD buffer_rva, IN const DWORD required_rva, IN const size_t required_size)
	{
		if (!buffer || buffer_rva > required_rva) return nullptr;
		size_t offset = required_rva - buffer_rva;

		BYTE* req_ptr = offset + buffer;
		if (peconv::validate_ptr(buffer, buffer_size, req_ptr, required_size)) {
			return req_ptr;
		}
		return nullptr;
	}
};

//---

BYTE* pesieve::ImportTableBuffer::getNamesSpaceAt(const DWORD rva, size_t required_size)
{
	return get_buffer_space_at(this->namesBuf, this->namesBufSize, this->namesRVA, rva, required_size);
}

BYTE* pesieve::ImportTableBuffer::getDllSpaceAt(const DWORD rva, size_t required_size)
{
	return get_buffer_space_at(this->dllsBuf, this->dllsBufSize, this->dllsRVA, rva, required_size);
}

//---

bool pesieve::ImpReconstructor::hasDynamicIAT() const
{
	size_t maxSize = getMaxDynamicIATSize(true);
	return (maxSize >= MIN_THUNKS_COUNT);
}

size_t pesieve::ImpReconstructor::getMainIATSize() const
{
	std::map<DWORD, IATBlock*>::const_iterator iats_itr;

	//the main IAT can be in chunks, so join them together...
	size_t totalIatSize = 0;
	for (iats_itr = foundIATs.cbegin(); iats_itr != foundIATs.cend(); ++iats_itr) {
		const IATBlock* iblock = iats_itr->second;
		const size_t currCount = iblock->countThunks();

		if (iblock->isInMain) {
			totalIatSize += currCount;
		}
	}
	return totalIatSize;
}

size_t pesieve::ImpReconstructor::getMaxDynamicIATSize(IN bool isIatTerminated) const
{
	std::map<DWORD, IATBlock*>::const_iterator iats_itr;

	size_t maxIATSize = 0;
	for (iats_itr = foundIATs.cbegin(); iats_itr != foundIATs.cend(); ++iats_itr) {
		const IATBlock* iblock = iats_itr->second;
		const size_t currCount = iblock->countThunks();

		if (!iblock->isInMain // is it a dynamic IAT
			&& (iblock->isTerminated == isIatTerminated))
		{
			if (currCount > maxIATSize) {
				maxIATSize = currCount;
			}
		}
	}
	return maxIATSize;
}

pesieve::ImpReconstructor::t_imprec_res pesieve::ImpReconstructor::_recreateImportTableFiltered(const IN peconv::ExportsMapper* exportsMap, IN const pesieve::t_imprec_mode& imprec_mode)
{
	// convert to filter:

	int filter = IMP_REC0;
	switch (imprec_mode) {
	case PE_IMPREC_REBUILD0:
		filter = IMP_REC0; break;
	case PE_IMPREC_REBUILD1:
		filter = IMP_REC1; break;
	case PE_IMPREC_REBUILD2:
		filter = IMP_REC2; break;
	}

	// in AUTO mode: chose higher filter if the unterminated IAT is bigger than the main IAT, or any terminated:

	if (imprec_mode == PE_IMPREC_AUTO) {

		const size_t untermIATSize = getMaxDynamicIATSize(false);
		if (untermIATSize > MIN_THUNKS_COUNT) {
			const size_t mainIATSize = getMainIATSize();
			const size_t termIATSize = getMaxDynamicIATSize(true);

			if ((untermIATSize > mainIATSize) && (untermIATSize > termIATSize)) {
				filter = IMP_REC1;
			}
		}
	}

	// Try to rebuild ImportTable for module

	while (!findIATsCoverage(exportsMap, (t_imprec_filter)filter)) {
		if (imprec_mode != PE_IMPREC_AUTO) {
			// no autodetect: don't try different modes
			return IMP_RECOVERY_ERROR;
		}
		// try next filter:
		filter++;
		//limit exceeded, quit with error:
		if (filter == IMP_REC_COUNT) {
			return IMP_RECOVERY_ERROR;
		}
	}

	//coverage found, try to rebuild:
	bool isOk = false;
	ImportTableBuffer* impBuf = constructImportTable();
	if (impBuf) {
		if (appendImportTable(*impBuf)) {
			isOk = true;
		}
	}
	delete impBuf;

	if (!isOk) {
		return IMP_RECOVERY_ERROR;
	}
	// convert results:
	switch (filter) {
	case IMP_REC0:
		return IMP_RECREATED_FILTER0;
	case IMP_REC1:
		return IMP_RECREATED_FILTER1;
	case IMP_REC2:
		return IMP_RECREATED_FILTER2;
	}
	return IMP_RECREATED_FILTER0;
}

pesieve::ImpReconstructor::t_imprec_res pesieve::ImpReconstructor::rebuildImportTable(const IN peconv::ExportsMapper* exportsMap, IN const pesieve::t_imprec_mode &imprec_mode)
{
	if (!exportsMap || imprec_mode == pesieve::PE_IMPREC_NONE) {
		return IMP_RECOVERY_SKIPPED;
	}

	if (!collectIATs(exportsMap)) {
		return IMP_NOT_FOUND;
	}

	if (!peBuffer.isValidPe()) {
		// this is possibly a shellcode, stop after collecting the IATs
		return IMP_RECOVERY_NOT_APPLICABLE;
	}
	if (!peconv::is_pe_raw_eq_virtual(peBuffer.vBuf, peBuffer.vBufSize)
		&& peconv::is_pe_raw(peBuffer.vBuf, peBuffer.vBufSize))
	{
		// Do not proceed, the PE is in a raw format
		return IMP_RECOVERY_NOT_APPLICABLE;
	}

	if (imprec_mode == PE_IMPREC_UNERASE || 
		(imprec_mode == PE_IMPREC_AUTO && !this->hasDynamicIAT()))
	{
		const bool is_default_valid = this->isDefaultImportValid(exportsMap);
		if (is_default_valid) {
			// Valid Import Table already set
			return pesieve::ImpReconstructor::IMP_ALREADY_OK;
		}
		if (findImportTable(exportsMap)) {
			// ImportTable found and set:
			return pesieve::ImpReconstructor::IMP_DIR_FIXED;
		}
	}
	const bool isDotnet = peconv::is_dot_net(peBuffer.vBuf, peBuffer.vBufSize);
	if (isDotnet && imprec_mode == PE_IMPREC_AUTO) {
		// Valid Import Table already set
		return pesieve::ImpReconstructor::IMP_ALREADY_OK;
	}

	// Try to rebuild ImportTable for module
	if ((imprec_mode == PE_IMPREC_REBUILD0 || imprec_mode == PE_IMPREC_REBUILD1 || imprec_mode == PE_IMPREC_REBUILD2)
		|| imprec_mode == PE_IMPREC_AUTO)
	{
		return _recreateImportTableFiltered(exportsMap, imprec_mode);
	}
	return IMP_RECOVERY_ERROR;
}

bool pesieve::ImpReconstructor::printFoundIATs(std::string reportPath)
{
	if (!foundIATs.size()) {
		return false;
	}
	std::ofstream report;
	report.open(reportPath);
	if (report.is_open() == false) {
		return false;
	}

	std::map<DWORD, IATBlock*>::iterator itr;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		report << itr->second->toString();
	}
	report.close();
	return true;
}

bool pesieve::ImpReconstructor::isDefaultImportValid(IN const peconv::ExportsMapper* exportsMap)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf || !vBufSize) return false;

	IMAGE_DATA_DIRECTORY *iat_dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IAT, true);
	if (!iat_dir) return false;

	IMAGE_DATA_DIRECTORY *imp_dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IMPORT, true);
	if (!imp_dir) return false;

	if (imp_dir->VirtualAddress == 0 && imp_dir->Size == 0 
		&& iat_dir->VirtualAddress == 0 && iat_dir->Size == 0)
	{
		// the PE has no Import Table, and no artefacts indicating that it was erased. Probably legit no-import PE.
		return false;
	}

	if (iat_dir->VirtualAddress != 0 && imp_dir->VirtualAddress == 0) {
		// the PE has IAT, but no Import Table. Import Table Address was probably erased.
		return false;
	}

	// verify if the Import Table that is currently set is fine:

	DWORD iat_offset = iat_dir->VirtualAddress;
	IATBlock* iat_block = this->findIATBlock(exportsMap, iat_offset);
	if (!iat_block) {
		//could not find any IAT Block at this IAT offset. The IAT offset may be incorrect.
		return false;
	}
	const size_t start_offset = peconv::get_hdrs_size(vBuf);
	const bool is64bit = peconv::is64bit(vBuf);
	size_t table_size = 0;
	IMAGE_IMPORT_DESCRIPTOR *import_table = find_import_table(
		is64bit,
		vBuf,
		vBufSize,
		exportsMap,
		iat_offset,
		table_size,
		start_offset
	);
	if (!import_table) {
		// could not find Import Table for this IAT offset
		return false;
	}
	// Import Table found and it fits the address that was already set
	DWORD imp_table_offset = DWORD((ULONG_PTR)import_table - (ULONG_PTR)vBuf);
	if (imp_dir->VirtualAddress == imp_table_offset) {
		return true;
	}
	return false;
}

IATBlock* pesieve::ImpReconstructor::findIATBlock(IN const peconv::ExportsMapper* exportsMap, size_t start_offset)
{
	if (!exportsMap) return nullptr;

	// filter calls to the own exports
	class ThunkFilterSelfCallback : public ThunkFoundCallback
	{
	public:
		ThunkFilterSelfCallback(const ULONGLONG mod_start, size_t mod_size)
			: startAddr(mod_start), endAddr(mod_start + mod_size)
		{
		}

		virtual bool shouldProcessVA(ULONGLONG va)
		{
			if (va >= startAddr && va < endAddr) {
				// the address is in the current module: this may be a call to module's own function
				return false;
			}
			return true;
		}

		virtual bool shouldAcceptExport(ULONGLONG va, const peconv::ExportedFunc &exp)
		{
			// accept any
			return true;
		}

	protected:
		const ULONGLONG startAddr;
		const ULONGLONG endAddr;
	};
	//---
	ThunkFilterSelfCallback filter = ThunkFilterSelfCallback(peBuffer.moduleBase, peBuffer.getBufferSize());

	IATBlock* iat_block = nullptr;
	if (this->is64bit) {
		iat_block = find_iat<ULONGLONG>(this->peBuffer.vBuf, this->peBuffer.vBufSize, exportsMap, start_offset, &filter);
	}
	else {
		iat_block = find_iat<DWORD>(this->peBuffer.vBuf, this->peBuffer.vBufSize, exportsMap, start_offset, &filter);
	}
	return iat_block;
}


void pesieve::ImpReconstructor::collectMainIatData()
{
	BYTE* vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return;

	if (!peconv::has_valid_import_table(vBuf, vBufSize)) {
		// No import table
		return;
	}
	peconv::collect_thunks(vBuf, vBufSize, mainIatThunks);
}

IATBlock* pesieve::ImpReconstructor::findIAT(IN const peconv::ExportsMapper* exportsMap, size_t start_offset)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return nullptr;

	IATBlock* iat_block = findIATBlock(exportsMap, start_offset);
	if (!iat_block) {
		return nullptr;
	}
	DWORD mainIatRVA = 0;
	DWORD mainIatSize = 0;
	IMAGE_DATA_DIRECTORY* dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IAT, true);
	if (dir) {
		mainIatRVA = dir->VirtualAddress;
		mainIatSize = dir->Size;
	}
	if ( (mainIatRVA != 0 && iat_block->iatOffset >= mainIatRVA && iat_block->iatOffset < (mainIatRVA + mainIatSize) )
		|| mainIatThunks.find(iat_block->iatOffset) != mainIatThunks.end() )
	{
		iat_block->isInMain = true;
	}
	return iat_block;
}

size_t pesieve::ImpReconstructor::collectIATs(IN const peconv::ExportsMapper* exportsMap)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return 0;

	size_t found = 0;
	const size_t pe_hdr_size = peconv::get_hdrs_size(vBuf); //if the buffer is not a valid PE, it will be 0

	for (size_t search_offset = pe_hdr_size; search_offset < vBufSize;) {

		IATBlock *currIAT = findIAT(exportsMap, search_offset);
		if (!currIAT) {
			//can't find any more IAT
			break;
		}
		found++;
		const DWORD iat_offset = currIAT->iatOffset;
		const size_t iat_end = iat_offset + currIAT->iatSize;
		if (!appendFoundIAT(iat_offset, currIAT)) {
			delete currIAT; //this IAT already exist in the map
		}
		// next search should be after thie current IAT:
		if (iat_end <= search_offset) {
			break; //this should never happen
		}
		search_offset = iat_end;
	}
	return found;
}

bool pesieve::ImpReconstructor::findImportTable(IN const peconv::ExportsMapper* exportsMap)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return false;

	IMAGE_DATA_DIRECTORY* imp_dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IMPORT, true);
	if (!imp_dir) {
		return false;
	}
	IMAGE_DATA_DIRECTORY *iat_dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IAT, true);
	if (!iat_dir) {
		return false;
	}
	IMAGE_IMPORT_DESCRIPTOR* import_table = nullptr;
	size_t table_size = 0;

	const size_t start_offset = peconv::get_hdrs_size(vBuf);
	
	std::map<DWORD, IATBlock*>::iterator itr;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock *currIAT = itr->second;

		const DWORD iat_offset = currIAT->iatOffset;
#ifdef _DEBUG
		std::cout << "[*] Searching import table for IAT: " << std::hex << iat_offset << ", size: " << currIAT->iatSize << std::endl;
#endif
		bool is64bit = peconv::is64bit(vBuf);
		import_table = find_import_table(
			is64bit,
			vBuf,
			vBufSize,
			exportsMap,
			iat_offset,
			table_size,
			start_offset
		);
		if (import_table) {
			//import table found, set it in the IATBlock:
			currIAT->importTableOffset = DWORD((ULONG_PTR)import_table - (ULONG_PTR)vBuf);
			//overwrite the Data Directory:
			iat_dir->VirtualAddress = iat_offset;
			iat_dir->Size = MASK_TO_DWORD(currIAT->iatSize);
			break;
		}
	}

	if (!import_table) return false;

	DWORD imp_offset = MASK_TO_DWORD((ULONG_PTR)import_table - (ULONG_PTR)vBuf);
	if (imp_dir->VirtualAddress == imp_offset && imp_dir->Size == table_size) {
		//std::cout << "[*] Validated Imports offset!\n";
		return true;
	}
#ifdef _DEBUG
	if (imp_dir->Size == table_size) {
		std::cout << "[*] Validated Imports size!\n";
	}
#endif
	//overwrite the Data Directory:
	imp_dir->VirtualAddress = imp_offset;
	imp_dir->Size = MASK_TO_DWORD(table_size);
	return true;
}

bool pesieve::ImpReconstructor::findIATsCoverage(IN const peconv::ExportsMapper* exportsMap, t_imprec_filter filter)
{
	size_t neededIATs = 0;
	size_t covered = 0;
	std::map<DWORD, IATBlock*>::iterator itr;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock* iat = itr->second;

		switch (filter) {
		case IMP_REC0:
			if (!iat->isInMain && !iat->isTerminated) {
				continue;
			}
		case IMP_REC1:
			if (!iat->isInMain && !iat->isTerminated && iat->countThunks() < MIN_THUNKS_COUNT) {
				continue;
			}
		}
		neededIATs++;

		if (iat->makeCoverage(exportsMap)) {
			covered++;
		}
		else {
			std::cout << "[-] Failed covering block: " << std::hex << itr->first << " series: " << iat->thunkSeries.size() << "\n";
		}
	}
	if (neededIATs == 0) {
		return false;
	}
	return (covered == neededIATs);
}

ImportTableBuffer* pesieve::ImpReconstructor::constructImportTable()
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf || !vBufSize) return nullptr;

	size_t ready_blocks = 0;
	std::map<DWORD, IATBlock*>::iterator itr;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock* iat = itr->second;
		if (iat->isValid()) {
			ready_blocks += iat->thunkSeries.size();
		}
	}
	if (ready_blocks == 0) {
		return nullptr;
	}
	const DWORD end_rva = MASK_TO_DWORD(vBufSize);
	ImportTableBuffer *importTableBuffer = new(std::nothrow) ImportTableBuffer(end_rva);
	if (!importTableBuffer) {
		return nullptr;
	}
	importTableBuffer->allocDesciptors(ready_blocks + 1);

	const DWORD names_start_rva = MASK_TO_DWORD(importTableBuffer->getRVA() + importTableBuffer->getDescriptorsSize());
	DWORD orig_thunk_rva = names_start_rva;
	size_t names_space = 0;
	size_t i = 0;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock* iat = itr->second;
		if (!iat->isValid()) {
			continue;
		}
		IATThunksSeriesSet::iterator sItr;
		for (sItr = iat->thunkSeries.begin(); sItr != iat->thunkSeries.end(); ++sItr, ++i) {
			IATThunksSeries *series = *sItr;
			importTableBuffer->descriptors[i].FirstThunk = series->startOffset;
			importTableBuffer->descriptors[i].OriginalFirstThunk = orig_thunk_rva;
			//calculate size for names
			const DWORD names_space_size = MASK_TO_DWORD(series->sizeOfNamesSpace(this->is64bit));
			names_space += names_space_size;
			orig_thunk_rva += names_space_size;
		}
	}
	//fill functions' names:
	importTableBuffer->allocNamesSpace(names_start_rva, names_space);
	const DWORD dlls_rva = MASK_TO_DWORD(names_start_rva + names_space);
	size_t dlls_area_size = 0;
	i = 0;
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock* iat = itr->second;
		if (!iat->isValid()) {
			continue;
		}
		IATThunksSeriesSet::iterator sItr;
		for (sItr = iat->thunkSeries.begin(); sItr != iat->thunkSeries.end(); ++sItr++, ++i) {
			IATThunksSeries *series = *sItr;
			DWORD name_rva = importTableBuffer->descriptors[i].OriginalFirstThunk;
			const size_t names_space_size = series->sizeOfNamesSpace(this->is64bit);
			BYTE *buf = importTableBuffer->getNamesSpaceAt(name_rva, names_space_size);
			if (!buf) {
				continue;
			}
			series->fillNamesSpace(buf, names_space_size, name_rva, this->is64bit);
		}
		dlls_area_size += iat->sizeOfDllsSpace();
	}
	//fill DLLs' names:
	importTableBuffer->allocDllsSpace(dlls_rva, dlls_area_size);
	DWORD dll_name_rva = dlls_rva;
	i = 0;
	//TODO: optimize it: write the repeating DLL names only once
	for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
		IATBlock* iat = itr->second;
		if (!iat->isValid()) {
			continue;
		}
		DWORD max_dll_name = MASK_TO_DWORD(iat->maxDllLen());
		IATThunksSeriesSet::iterator sItr;
		for (sItr = iat->thunkSeries.begin(); sItr != iat->thunkSeries.end(); ++sItr, ++i) {
			IATThunksSeries *series = *sItr;
			importTableBuffer->descriptors[i].Name = dll_name_rva;
			BYTE *buf = importTableBuffer->getDllSpaceAt(dll_name_rva, max_dll_name);
			if (buf) {
				//fill the name:
				memcpy(buf, series->getDllName().c_str(), series->getDllName().length() + 1);
			}
			dll_name_rva += max_dll_name;
		}
	}
	return importTableBuffer;
}

bool pesieve::ImpReconstructor::appendImportTable(ImportTableBuffer &importTable)
{
	const size_t import_table_size = importTable.getDescriptorsSize() + importTable.getNamesSize() + importTable.getDllNamesSize();
	const size_t new_size = peBuffer.vBufSize + import_table_size;

	if (!peBuffer.resizeBuffer(new_size)) {
		return false;
	}
	
	const DWORD imports_start_rva = importTable.getRVA();
	peBuffer.resizeLastSection(imports_start_rva + import_table_size);
	return importTable.setTableInPe(peBuffer.vBuf, peBuffer.vBufSize);
}

```

`postprocessors/imp_rec/imp_reconstructor.h`:

```h
#pragma once

#include <windows.h>
#include <map>

#include <peconv.h>
#include "pe_sieve_types.h"

#include "../pe_buffer.h"
#include "iat_block.h"
#include "../utils/artefacts_util.h"

namespace pesieve {

	class ImportTableBuffer
	{
	public:

		ImportTableBuffer(DWORD _descriptorsRVA)
			: descriptors(nullptr), descriptosCount(0),
			descriptorsRVA(_descriptorsRVA),
			namesRVA(0), namesBuf(nullptr), namesBufSize(0),
			dllsRVA(0), dllsBufSize(0), dllsBuf(nullptr)
		{
		}

		~ImportTableBuffer()
		{
			delete[]descriptors;
			delete[]namesBuf;
			delete[]dllsBuf;
		}

		bool allocDesciptors(size_t descriptors_count)
		{
			descriptors = new(std::nothrow) IMAGE_IMPORT_DESCRIPTOR[descriptors_count];
			if (!descriptors) {
				return false;
			}
			memset(descriptors, 0, descriptors_count);
			size_t size_bytes = sizeof(IMAGE_IMPORT_DESCRIPTOR) * descriptors_count;
			memset(descriptors, 0, size_bytes);
			descriptosCount = descriptors_count;
			return true;
		}

		bool allocNamesSpace(DWORD names_rva, size_t names_size)
		{
			delete[]namesBuf;
			this->namesBuf = new(std::nothrow) BYTE[names_size];
			if (!this->namesBuf) {
				this->namesBufSize = 0;
				return false;
			}
			memset(this->namesBuf, 0, names_size);
			this->namesBufSize = names_size;
			this->namesRVA = names_rva;
			return true;
		}

		bool allocDllsSpace(DWORD dlls_rva, size_t dlls_area_size)
		{
			delete[]dllsBuf;
			this->dllsBuf = new(std::nothrow) BYTE[dlls_area_size];
			if (!this->dllsBuf) {
				this->dllsBufSize = 0;
				return false;
			}
			memset(this->dllsBuf, 0, dlls_area_size);
			this->dllsBufSize = dlls_area_size;
			this->dllsRVA = dlls_rva;
			return true;
		}

		size_t getDescriptosCount()
		{
			return descriptosCount;
		}

		size_t getDescriptorsSize()
		{
			if (!descriptors) return 0;
			const size_t size_bytes = sizeof(IMAGE_IMPORT_DESCRIPTOR) * descriptosCount;
			return size_bytes;
		}

		size_t getNamesSize()
		{
			if (!this->namesBuf) return 0;
			return this->namesBufSize;
		}

		size_t getDllNamesSize()
		{
			return dllsBufSize;
		}

		DWORD getRVA()
		{
			return descriptorsRVA;
		}

		//copy table to the Virtual PE buffer
		bool setTableInPe(BYTE *vBuf, size_t vBufSize)
		{
			if (!descriptors || !namesBuf || !dllsBuf) {
				return false;
			}
			const size_t descriptors_size_b = getDescriptorsSize();
			if ((descriptorsRVA + descriptors_size_b) > vBufSize || (namesRVA + namesBufSize) > vBufSize) {
				// buffer too small
				return false;
			}
			IMAGE_DATA_DIRECTORY* imp_dir = peconv::get_directory_entry(vBuf, IMAGE_DIRECTORY_ENTRY_IMPORT, true);
			if (!imp_dir) {
				//cannot retrieve import directory
				return false;
			}

			const size_t import_table_size = getDescriptorsSize() + getNamesSize();

			//copy buffers into PE:
			memcpy(vBuf + descriptorsRVA, descriptors, descriptors_size_b);
			memcpy(vBuf + namesRVA, namesBuf, namesBufSize);
			memcpy(vBuf + dllsRVA, dllsBuf, dllsBufSize);

			//overwrite the Data Directory:
			imp_dir->VirtualAddress = descriptorsRVA;
			imp_dir->Size = MASK_TO_DWORD(import_table_size);
			return true;
		}

	protected:

		BYTE * getNamesSpaceAt(const DWORD rva, size_t required_size);

		BYTE* getDllSpaceAt(const DWORD rva, size_t required_size);

		IMAGE_IMPORT_DESCRIPTOR* descriptors;
		friend class ImpReconstructor;

	private:

		DWORD descriptorsRVA;
		size_t descriptosCount;

		DWORD namesRVA;
		BYTE* namesBuf;
		size_t namesBufSize;

		DWORD dllsRVA;
		BYTE* dllsBuf;
		size_t dllsBufSize;
	};

	class ImpReconstructor {

	public:

		ImpReconstructor(PeBuffer &_peBuffer)
			: peBuffer(_peBuffer), is64bit(false)
		{
			if (!peBuffer.vBuf) return;
			if (peBuffer.isValidPe()) {
				this->is64bit = peconv::is64bit(peBuffer.vBuf);
			}
			else {
				this->is64bit = pesieve::util::is_64bit_code(peBuffer.vBuf, peBuffer.vBufSize);
			}
			collectMainIatData();
		}

		~ImpReconstructor()
		{
			deleteFoundIATs();
		}

		typedef enum imprec_filter {
			IMP_REC0,
			IMP_REC1,
			IMP_REC2,
			IMP_REC_COUNT
		} t_imprec_filter;

		typedef enum imprec_res {
			IMP_NOT_FOUND = -3,
			IMP_RECOVERY_ERROR = -2,
			IMP_RECOVERY_NOT_APPLICABLE = -1,
			IMP_RECOVERY_SKIPPED = 0,
			IMP_ALREADY_OK = 1,
			IMP_DIR_FIXED = 2,
			IMP_FIXED = 3,
			IMP_RECREATED_FILTER0 = 4,
			IMP_RECREATED_FILTER1 = 5,
			IMP_RECREATED_FILTER2 = 6,
		} t_imprec_res;

		t_imprec_res rebuildImportTable(const IN peconv::ExportsMapper* exportsMap, IN const pesieve::t_imprec_mode &imprec_mode);

		bool printFoundIATs(std::string reportPath);

	private:

		t_imprec_res _recreateImportTableFiltered(const IN peconv::ExportsMapper* exportsMap, IN const pesieve::t_imprec_mode& imprec_mode);

		IATBlock* findIATBlock(IN const peconv::ExportsMapper* exportsMap, size_t start_offset);
		IATBlock* findIAT(IN const peconv::ExportsMapper* exportsMap, size_t start_offset);
		void collectMainIatData();

		//!  has a dynamic IAT in addition to the basic one (that is set in Data Directory)
		bool hasDynamicIAT() const;

		size_t getMainIATSize() const;

		size_t getMaxDynamicIATSize(IN bool isIatTerminated) const;

		bool findImportTable(IN const peconv::ExportsMapper* exportsMap);
		size_t collectIATs(IN const peconv::ExportsMapper* exportsMap);

		bool isDefaultImportValid(IN const peconv::ExportsMapper* exportsMap);

		bool findIATsCoverage(IN const peconv::ExportsMapper* exportsMap, t_imprec_filter filter);
		ImportTableBuffer* constructImportTable();
		bool appendImportTable(ImportTableBuffer &importTable);

		bool appendFoundIAT(DWORD iat_offset, IATBlock* found_block)
		{
			if (foundIATs.find(iat_offset) != foundIATs.end()) {
				return false; //already exist
			}
			foundIATs[iat_offset] = found_block;
			return true;
		}

		void deleteFoundIATs()
		{
			std::map<DWORD, IATBlock*>::iterator itr;
			for (itr = foundIATs.begin(); itr != foundIATs.end(); ++itr) {
				delete itr->second;
			}
			foundIATs.clear();
		}

		PeBuffer &peBuffer;
		bool is64bit;
		std::map<DWORD, IATBlock*> foundIATs;

		std::set<DWORD> mainIatThunks; //< RVAs of the Thunks of the main IAT
	};

}; // namespace pesieve

```

`postprocessors/imp_rec/import_table_finder.cpp`:

```cpp
#include "import_table_finder.h"

IMAGE_IMPORT_DESCRIPTOR* pesieve::find_import_table(
	IN bool is64bit,
	IN BYTE* vBuf,
	IN size_t vBufSize,
	IN const peconv::ExportsMapper* exportsMap,
	IN DWORD iat_offset,
	OUT size_t &table_size,
	IN OPTIONAL size_t search_offset
)
{
	IMAGE_IMPORT_DESCRIPTOR* import_table = nullptr;
	if (is64bit) {
		import_table = find_import_table_tpl<ULONGLONG>(
			vBuf,
			vBufSize,
			exportsMap,
			iat_offset,
			table_size,
			search_offset
			);
	}
	else {
		import_table = find_import_table_tpl<DWORD>(
			vBuf,
			vBufSize,
			exportsMap,
			iat_offset,
			table_size,
			search_offset
			);
	}
	return import_table;
}

```

`postprocessors/imp_rec/import_table_finder.h`:

```h
#pragma once
#include <peconv.h>

namespace pesieve {

	template <typename FIELD_T>
	bool is_valid_import_descriptor(BYTE* vBuf, size_t vBufSize, IN const peconv::ExportsMapper* exportsMap, IMAGE_IMPORT_DESCRIPTOR* desc)
	{
		if (!peconv::validate_ptr(vBuf, vBufSize, desc, sizeof(IMAGE_IMPORT_DESCRIPTOR))) {
			return false; //buffer finished
		}
		if (desc->TimeDateStamp != 0 && desc->TimeDateStamp != (-1)) {
			return false; // candidate doesn't fit
		}
		char* name_ptr = (char*)vBuf + desc->Name;
		if (!peconv::validate_ptr(vBuf, vBufSize, name_ptr, sizeof(char))) {
			return false; // candidate doesn't fit
		}
		if (desc->Name) {
			if (!peconv::is_valid_import_name(vBuf, vBufSize, name_ptr)) return 0; //invalid name, validation failed
#ifdef _DEBUG
			std::cout << "DLL: " << name_ptr << "\n";
#endif
		}
		if (desc->FirstThunk == 0 && desc->OriginalFirstThunk == 0) {
			//probably the last chunk
			return true;
		}
		FIELD_T* orig_thunk_ptr = (FIELD_T*)(vBuf + desc->OriginalFirstThunk);
		if (!peconv::validate_ptr(vBuf, vBufSize, orig_thunk_ptr, sizeof(FIELD_T))) {
			return false; // candidate doesn't fit
		}
		FIELD_T *thunk_ptr = (FIELD_T*)(vBuf + desc->FirstThunk);
		if (!peconv::validate_ptr(vBuf, vBufSize, thunk_ptr, sizeof(FIELD_T))) {
			return false; // candidate doesn't fit
		}
		const peconv::ExportedFunc *exp = exportsMap->find_export_by_va(*thunk_ptr);
		if (!exp) {
			return false; //no such import: validation failed
		}
		return true;
	}

	template <typename FIELD_T>
	size_t calc_import_table_size(BYTE* vBuf, size_t vBufSize, IN const peconv::ExportsMapper* exportsMap, IMAGE_IMPORT_DESCRIPTOR* first_desc)
	{
		if (!vBuf || !exportsMap || !first_desc) return 0;

		IMAGE_IMPORT_DESCRIPTOR *desc = nullptr;
		for (desc = first_desc; ; desc++) {
			if (!peconv::validate_ptr(vBuf, vBufSize, desc, sizeof(IMAGE_IMPORT_DESCRIPTOR))) {
				break; //buffer finished
			}
			if (!is_valid_import_descriptor<FIELD_T>(vBuf, vBufSize, exportsMap, desc)) {
				return 0;
			}
			if (desc->FirstThunk == 0 && desc->OriginalFirstThunk == 0) {
				//probably the last chunk
				break;
			}
		}
		size_t diff = (BYTE*)desc - (BYTE*)first_desc;
		return diff + sizeof(IMAGE_IMPORT_DESCRIPTOR);
	}

	template <typename FIELD_T>
	IMAGE_IMPORT_DESCRIPTOR* find_first_import_descriptor(BYTE* vBuf, size_t vBufSize, IN const peconv::ExportsMapper* exportsMap, IMAGE_IMPORT_DESCRIPTOR* found_desc)
	{
		if (!vBuf || !exportsMap || !found_desc) return nullptr;

		IMAGE_IMPORT_DESCRIPTOR *first_desc = nullptr;
		size_t prev_table_size = 0;

		for (IMAGE_IMPORT_DESCRIPTOR *desc = found_desc; ; desc--) {
			size_t table_size = calc_import_table_size<FIELD_T>(vBuf, vBufSize, exportsMap, desc);
			if (table_size == 0 || table_size < prev_table_size) {
				break; // if it is valid, the table size should grow
			}
			prev_table_size = table_size;
			first_desc = desc;
			//std::cout << "!!! Valid DESC: " << std::hex << (ULONGLONG)((BYTE*)desc - vBuf) << std::endl;
		}
		return first_desc;
	}

	template <typename FIELD_T>
	IMAGE_IMPORT_DESCRIPTOR* find_import_table_tpl(IN BYTE* vBuf,
		IN size_t vBufSize,
		IN const peconv::ExportsMapper* exportsMap,
		IN DWORD iat_offset,
		OUT size_t &table_size,
		IN OPTIONAL size_t search_offset)
	{
		table_size = 0;
		if (!vBuf || !iat_offset) return nullptr;
		if (search_offset > vBufSize || (vBufSize - search_offset) < sizeof(DWORD)) {
			return nullptr; //size check failed
		}
		size_t max_check = vBufSize - sizeof(DWORD);
		for (BYTE* ptr = vBuf + search_offset; ptr < vBuf + max_check; ptr++) {
			DWORD *to_check = (DWORD*)ptr;
			if (*to_check != iat_offset) {
				continue; //candidate not found
			}
			size_t offset = (BYTE*)to_check - vBuf;
			//std::cout << "Found IAT offset in the binary: " << std::hex << offset << "\n";
			size_t desc_diff = sizeof(IMAGE_IMPORT_DESCRIPTOR) - sizeof(DWORD);
			IMAGE_IMPORT_DESCRIPTOR *desc = (IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)to_check - desc_diff);
			if (!peconv::validate_ptr(vBuf, vBufSize, desc, sizeof(IMAGE_IMPORT_DESCRIPTOR))) {
				continue; // candidate doesn't fit
			}
			//now try to find the first one in the table:
			IMAGE_IMPORT_DESCRIPTOR* first_desc = find_first_import_descriptor<FIELD_T>(vBuf, vBufSize, exportsMap, desc);
			size_t _table_size = calc_import_table_size<FIELD_T>(vBuf, vBufSize, exportsMap, first_desc);
			if (_table_size > 0) {
				table_size = _table_size;
				return first_desc;
			}
		}
		//std::cout << "Import table not found\n";
		return nullptr;
	}

	IMAGE_IMPORT_DESCRIPTOR* find_import_table(
		IN bool is64bit,
		IN BYTE* vBuf,
		IN size_t vBufSize,
		IN const peconv::ExportsMapper* exportsMap,
		IN DWORD iat_offset,
		OUT size_t &table_size,
		IN OPTIONAL size_t search_offset
	);

}; //namespace pesieve


```

`postprocessors/pe_buffer.cpp`:

```cpp
#include "pe_buffer.h"

#include <iostream>
#include "../scanners/artefact_scanner.h"

size_t pesieve::PeBuffer::calcRemoteImgSize(ULONGLONG modBaseAddr) const
{
	const size_t hdr_buffer_size = PAGE_SIZE;
	BYTE hdr_buffer[hdr_buffer_size] = { 0 };
	size_t pe_vsize = 0;

	PIMAGE_SECTION_HEADER hdr_ptr = NULL;
	if (peconv::read_remote_pe_header(this->processHndl, (BYTE*)modBaseAddr, hdr_buffer, hdr_buffer_size)) {
		hdr_ptr = peconv::get_section_hdr(hdr_buffer, hdr_buffer_size, 0);
	}
	if (!hdr_ptr) {
		pe_vsize = peconv::fetch_region_size(this->processHndl, (PBYTE)modBaseAddr);
		//std::cout << "[!] Image size at: " << std::hex << modBaseAddr << " undetermined, using region size instead: " << pe_vsize << std::endl;
		return pe_vsize;
	}
	pe_vsize = ArtefactScanner::calcImgSize(this->processHndl, (HMODULE)modBaseAddr, hdr_buffer, hdr_buffer_size, hdr_ptr);
	//std::cout << "[!] Image size at: " << std::hex << modBaseAddr << " undetermined, using calculated img size: " << pe_vsize << std::endl;
	return pe_vsize;
}

bool pesieve::PeBuffer::readRemote(ULONGLONG module_base, size_t pe_vsize)
{
	if (pe_vsize == 0) {
		// if not size supplied, try with the size fetched from the header
		pe_vsize = peconv::get_remote_image_size(processHndl, (BYTE*)module_base);
	}
	if (_readRemote(module_base, pe_vsize)) {
		return true; //success
	}
	// try with the calculated size
	pe_vsize = calcRemoteImgSize(module_base);
	std::cout << "[!] Image size at: " << std::hex << module_base << " undetermined, using calculated size: " << pe_vsize << std::endl;
	return _readRemote(module_base, pe_vsize);
}

bool  pesieve::PeBuffer::_readRemote(const ULONGLONG module_base, size_t pe_vsize)
{
	if (pe_vsize == 0) {
		return false;
	}
	if (!allocBuffer(pe_vsize)) {
		return false;
	}

	// store the base no matter if reading succeeded or failed
	this->moduleBase = module_base;
	this->relocBase = module_base; //by default set the same as module base

	const bool can_force_access = this->isRefl ? true : false;
	size_t read_size = peconv::read_remote_area(processHndl, (BYTE*)this->moduleBase, vBuf, pe_vsize, can_force_access);
	if (read_size != pe_vsize) {
		std::cout << "[!] Failed reading Image at: " << std::hex << this->moduleBase << " img size: " << pe_vsize << std::endl;
		freeBuffer();
		return false;
	}
	return true;
}

bool pesieve::PeBuffer::resizeBuffer(size_t new_size)
{
	if (!vBuf) return false;

	BYTE *new_buf = peconv::alloc_aligned(new_size, PAGE_READWRITE);
	if (!new_buf) {
		return false;
	}

	size_t smaller_size = (vBufSize < new_size) ? vBufSize : new_size;
	memcpy(new_buf, this->vBuf, smaller_size);
	freeBuffer();

	this->vBuf = new_buf;
	this->vBufSize = new_size;
	return true;
}

bool  pesieve::PeBuffer::resizeLastSection(size_t new_img_size)
{
	if (!vBuf) return false;

	PIMAGE_SECTION_HEADER last_sec = peconv::get_last_section(vBuf, vBufSize, false);
	if (!last_sec) {
		return false;
	}

	if (new_img_size < last_sec->VirtualAddress) {
		return false;
	}

	const size_t new_sec_vsize = new_img_size - last_sec->VirtualAddress;
	const size_t new_sec_rsize = new_sec_vsize;

	if (last_sec->VirtualAddress + new_sec_vsize > this->vBufSize) {
		//buffer too small
		return false;
	}

	if (!peconv::update_image_size(vBuf, MASK_TO_DWORD(new_img_size))) {
		return false;
	}

	last_sec->Misc.VirtualSize = MASK_TO_DWORD(new_sec_vsize);
	last_sec->SizeOfRawData = MASK_TO_DWORD(new_sec_rsize);
	return true;
}

bool pesieve::PeBuffer::dumpPeToFile(
	IN std::string dumpFileName,
	IN OUT peconv::t_pe_dump_mode &dumpMode,
	IN OPTIONAL const peconv::ExportsMapper* exportsMap,
	OUT OPTIONAL peconv::ImpsNotCovered *notCovered
)
{
	if (!vBuf || !isValidPe()) return false;
#ifdef _DEBUG
	std::cout << "Dumping using relocBase: " << std::hex << relocBase << "\n";
#endif
	if (exportsMap != nullptr) {
		if (!peconv::fix_imports(this->vBuf, this->vBufSize, *exportsMap, notCovered)) {
			std::cerr << "[-] Unable to fix imports!" << std::endl;
		}
	}
	if (dumpMode == peconv::PE_DUMP_AUTO) {
		bool is_raw_alignment_valid = peconv::is_valid_sectons_alignment(vBuf, vBufSize, true);
		bool is_virtual_alignment_valid = peconv::is_valid_sectons_alignment(vBuf, vBufSize, false);
#ifdef _DEBUG
		std::cout << "Is raw alignment valid: " << is_raw_alignment_valid << std::endl;
		std::cout << "Is virtual alignment valid: " << is_virtual_alignment_valid << std::endl;
#endif
		if (!is_raw_alignment_valid && is_virtual_alignment_valid) {
			//in case if raw alignment is invalid and virtual valid, try to dump using Virtual Alignment first
			dumpMode = peconv::PE_DUMP_REALIGN;
			bool is_dumped = peconv::dump_pe(dumpFileName.c_str(), this->vBuf, this->vBufSize, this->relocBase, dumpMode);
			if (is_dumped) {
				return is_dumped;
			}
			dumpMode = peconv::PE_DUMP_AUTO; //revert and try again
		}
	}
	// dump PE in a given dump mode:
	return peconv::dump_pe(dumpFileName.c_str(), this->vBuf, this->vBufSize, this->relocBase, dumpMode);
}

bool pesieve::PeBuffer::dumpToFile(IN std::string dumpFileName)
{
	if (!vBuf) return false;
	return peconv::dump_to_file(dumpFileName.c_str(), vBuf, vBufSize);
}

```

`postprocessors/pe_buffer.h`:

```h
#pragma once

#include <peconv.h>

namespace pesieve {

	class PeBuffer {
	public:
		PeBuffer(HANDLE _process_hndl, bool _is_refl)
			: processHndl(_process_hndl), isRefl(_is_refl),
			vBuf(nullptr), vBufSize(0), moduleBase(0), relocBase(0)
		{
		}

		~PeBuffer()
		{
			freeBuffer();
		}

		bool isFilled()
		{
			return (vBuf && vBufSize > 0);
		}

		bool isValidPe()
		{
			if (!vBuf) return false;
			if (peconv::get_nt_hdrs(vBuf, vBufSize)) {
				return true;
			}
			return false;
		}

		// Returns the size of the internal buffer
		size_t getBufferSize() const
		{
			return vBufSize;
		}

		// Reads content from the remote process into a buffer. Automatically allocates sutiable buffer.
		bool readRemote(ULONGLONG module_base, size_t pe_vsize);

		// Resizes internal buffer into a new size.
		// The internal buffer must be non empty.
		bool resizeBuffer(size_t new_size);

		// Requires the internal buffer to contain a valid PE. Resizes the last section of the PE, to make it fit the new Image Size.
		// The internal buffer must be non empty, and not smaller than the new Image Size.
		bool resizeLastSection(size_t new_img_size);

		// Requires the internal buffer to contain a valid PE. 
		// Dumps the PE into a file with a given name.
		bool dumpPeToFile(IN std::string dumpFileName,
			IN OUT peconv::t_pe_dump_mode &dumpMode,
			IN OPTIONAL const peconv::ExportsMapper* exportsMap = NULL,
			OUT OPTIONAL peconv::ImpsNotCovered *notCovered = NULL
		);

		bool dumpToFile(IN std::string dumpFileName);

		ULONGLONG getModuleBase() const
		{
			return moduleBase;
		}

		ULONGLONG getRelocBase() const
		{
			return relocBase;
		}

		void setRelocBase(ULONGLONG reloc_base)
		{
			relocBase = reloc_base;
		}

	protected:
		bool _readRemote(ULONGLONG module_base, size_t pe_vsize);

		size_t calcRemoteImgSize(ULONGLONG module_base) const;

		bool allocBuffer(const size_t pe_vsize)
		{
			freeBuffer();
			vBuf = peconv::alloc_aligned(pe_vsize, PAGE_READWRITE);
			if (!vBuf) {
				return false;
			}
			vBufSize = pe_vsize;
			return true;
		}

		void freeBuffer()
		{
			peconv::free_aligned(vBuf);
			vBuf = nullptr;
			vBufSize = 0;
		}

		HANDLE processHndl;
		bool isRefl;
		BYTE *vBuf;
		size_t vBufSize;
		ULONGLONG moduleBase;
		ULONGLONG relocBase;

		friend class ImpReconstructor;
		friend class PeReconstructor;
	};

}; //namespace pesieve

```

`postprocessors/pe_reconstructor.cpp`:

```cpp
#include "pe_reconstructor.h"

#include "../utils/workingset_enum.h"

#include <fstream>

namespace pesieve {
	inline bool shift_artefacts(PeArtefacts& artefacts, size_t shift_size)
	{
		artefacts.ntFileHdrsOffset += shift_size;
		artefacts.secHdrsOffset += shift_size;
		return true;
	}
}; //namespace pesieve


//WARNING: this function shifts also offsets saved in the artefacts
size_t pesieve::PeReconstructor::shiftPeHeader()
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (vBuf == nullptr) return 0;

	if (!this->artefacts.hasNtHdrs()) return 0;

	const size_t dos_pe_size = sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_SIGNATURE);
	const size_t nt_offset = this->artefacts.dropPeBase(this->artefacts.ntFileHdrsOffset);
	if (nt_offset == INVALID_OFFSET || nt_offset >= dos_pe_size) {
		return 0;
	}
	//TODO: shift the header
	if (!this->artefacts.hasSectionHdrs()) return 0; //cannot proceed

	size_t shift_size = dos_pe_size - nt_offset;
	size_t hdrs_end = this->artefacts.secHdrsOffset + (this->artefacts.secCount + 1)* sizeof(IMAGE_SECTION_HEADER);
	if (!peconv::is_padding(vBuf + hdrs_end, shift_size, 0)) {
		return 0; // no empty space, cannot proceed
	}
	size_t hdrs_size = this->artefacts.dropPeBase(hdrs_end);
	BYTE *new_nt_ptr = vBuf + this->artefacts.peBaseOffset + shift_size;
	if (!peconv::validate_ptr(vBuf, vBufSize, new_nt_ptr, hdrs_size)) {
		return 0;
	}
	if (nt_offset < sizeof(IMAGE_NT_SIGNATURE)) {
		return 0;
	}
	const size_t pe_offset = nt_offset - sizeof(IMAGE_NT_SIGNATURE);
	IMAGE_DOS_HEADER dos_template = { 0 };
	dos_template.e_magic = IMAGE_DOS_SIGNATURE;
	dos_template.e_lfanew = LONG(pe_offset + shift_size);

	//check mz signature:
	BYTE *mz_ptr = vBuf + this->artefacts.peBaseOffset;
	if (!peconv::validate_ptr(vBuf, vBufSize, mz_ptr, sizeof(IMAGE_DOS_HEADER))) {
		return 0;
	}
	//check PE signature:
	DWORD* pe_ptr = (DWORD*)(vBuf + this->artefacts.peBaseOffset + dos_template.e_lfanew);
	if (!peconv::validate_ptr(vBuf, vBufSize, pe_ptr, sizeof(DWORD))) {
		return 0;
	}
	//all checks passed, do the actual headers shift:
	memmove(new_nt_ptr, (vBuf + this->artefacts.peBaseOffset), hdrs_size);

	//write the DOS header:
	memcpy(mz_ptr, &dos_template, sizeof(IMAGE_DOS_HEADER));

	//write the PE signature:
	*pe_ptr = IMAGE_NT_SIGNATURE;

	shift_artefacts(this->artefacts, shift_size);
	return shift_size;
}

bool pesieve::PeReconstructor::reconstruct()
{
	this->artefacts = origArtefacts;

	ULONGLONG moduleBase = artefacts.regionStart + artefacts.peBaseOffset;
	if (!peBuffer.readRemote(moduleBase, artefacts.calculatedImgSize)) {
		return false;
	}
	size_t shift_size = shiftPeHeader();
	if (shift_size) {
		std::cout << "[!] The PE header was shifted by: " << std::hex << shift_size << std::endl;
	}
	bool is_pe_hdr = false;
	if (this->artefacts.hasNtHdrs() && reconstructFileHdr()) {
		is_pe_hdr = reconstructPeHdr();
	}
	if (!is_pe_hdr) {
		return false;
	}
	//do not modify section headers if the PE is in raw format, or no unmapping requested
	if (!peconv::is_pe_raw(peBuffer.vBuf, peBuffer.vBufSize)) {
		if (!fixSectionsVirtualSize(peBuffer.processHndl) || !fixSectionsCharacteristics(peBuffer.processHndl)) {
			return false;
		}
	}
	return peBuffer.isValidPe();
}

bool pesieve::PeReconstructor::fixSectionsVirtualSize(HANDLE processHandle)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return false;

	if (!this->artefacts.hasSectionHdrs()) {
		return false;
	}
	ULONGLONG sec_offset = this->artefacts.dropPeBase(this->artefacts.secHdrsOffset);
	BYTE *hdr_ptr = (sec_offset + vBuf);

	size_t max_sec_size = 0;

	IMAGE_SECTION_HEADER* prev_sec = nullptr;
	IMAGE_SECTION_HEADER* curr_sec = (IMAGE_SECTION_HEADER*)(hdr_ptr);

	const ULONGLONG pe_img_base = (ULONGLONG)artefacts.peImageBase();

	const size_t hdr_sec_count = peconv::get_sections_count(vBuf, vBufSize);
	const size_t sec_count = artefacts.secCount > hdr_sec_count ? artefacts.secCount : hdr_sec_count;

	size_t i = 0;
	for (i = 0; i < sec_count; i++, curr_sec++) {
		if (!peconv::validate_ptr(vBuf, vBufSize, curr_sec, sizeof(IMAGE_SECTION_HEADER))) {
			// buffer finished
			break;
		}
		const DWORD sec_rva = curr_sec->VirtualAddress;
		const DWORD sec_size = curr_sec->Misc.VirtualSize;

		const ULONGLONG sec_va = pe_img_base + sec_rva;
		size_t real_sec_size = peconv::fetch_region_size(processHandle, (PBYTE)sec_va);

		// if the RVA is out of scope, and the calculated size is 0:
		if (!peconv::validate_ptr(vBuf, vBufSize, vBuf + sec_rva, sizeof(BYTE)) && !real_sec_size) {
#ifdef _DEBUG
			std::cout << i << "# Invalid section found: " << std::hex
				<< sec_rva << " of size: " << sec_size << std::endl;
#endif
			break;
		}

		if (sec_size > real_sec_size) {
			curr_sec->Misc.VirtualSize = DWORD(real_sec_size);
#ifdef _DEBUG
			std::cout << i << "# Fixed section " << std::hex << sec_rva  << " size: " << std::hex
				<< sec_size << " vs real: " << real_sec_size << std::endl;
#endif
		}

		max_sec_size = (real_sec_size > max_sec_size) ? real_sec_size : max_sec_size;

		if (prev_sec && curr_sec->Misc.VirtualSize > 0) {
			ULONGLONG prev_sec_end = prev_sec->VirtualAddress + prev_sec->Misc.VirtualSize;
			if (prev_sec_end > curr_sec->VirtualAddress) {
				if (curr_sec->VirtualAddress > prev_sec->VirtualAddress) {
					DWORD diff = curr_sec->VirtualAddress - prev_sec->VirtualAddress;
					prev_sec->Misc.VirtualSize = diff;
#ifdef _DEBUG
					std::cout << "Trimmed section: " << std::dec << i << std::endl;
#endif
				}
			}
		}
		if (curr_sec->Misc.VirtualSize > 0) {
			prev_sec = curr_sec;
		}
	}
	
	IMAGE_FILE_HEADER* file_hdr = const_cast<IMAGE_FILE_HEADER*>(peconv::get_file_hdr(vBuf, vBufSize));
	if (file_hdr && (i > 0)) {
		// set the actual number of valid sections:
		file_hdr->NumberOfSections = MASK_TO_WORD(i);
	}

	if (max_sec_size == 0) {
		return false;
	}
	return true;
}

bool pesieve::PeReconstructor::fixSectionsCharacteristics(HANDLE processHandle)
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return false;

	if (!this->artefacts.hasSectionHdrs()) {
		return false;
	}

	ULONGLONG sec_offset = this->artefacts.dropPeBase(this->artefacts.secHdrsOffset);
	const BYTE *hdr_ptr = (sec_offset + vBuf);
	IMAGE_SECTION_HEADER* curr_sec = (IMAGE_SECTION_HEADER*)(hdr_ptr);

	const DWORD sec_all_flags = IMAGE_SCN_TYPE_NO_PAD
		| IMAGE_SCN_CNT_CODE | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA
		| IMAGE_SCN_LNK_NRELOC_OVFL | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_NOT_CACHED
		| IMAGE_SCN_MEM_NOT_PAGED | IMAGE_SCN_MEM_SHARED | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ
		| IMAGE_SCN_MEM_WRITE
		| IMAGE_SCN_NO_DEFER_SPEC_EXC | IMAGE_SCN_GPREL;

	for (size_t i = 0; i < artefacts.secCount; i++, curr_sec++) {
		if (!is_valid_section(vBuf, vBufSize, (BYTE*)curr_sec, 0)) {
			break;
		}
		//leave only the flags that are valid
		const DWORD charact = curr_sec->Characteristics;
		curr_sec->Characteristics = charact & sec_all_flags;
#ifdef DEBUG
		if (charact != curr_sec->Characteristics) {
			std::cout << "Section characteristics overwriten\n";
		}
#endif
	}
	return true;
}

bool pesieve::PeReconstructor::reconstructFileHdr()
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return false;

	if (!this->artefacts.hasNtHdrs()) {
		return false;
	}
	size_t nt_offset = this->artefacts.dropPeBase(this->artefacts.ntFileHdrsOffset);
	BYTE* nt_ptr = (BYTE*)((ULONGLONG)vBuf + nt_offset);
	if (is_valid_file_hdr(vBuf, vBufSize, nt_ptr, 0)) {
		return true;
	}
	IMAGE_FILE_HEADER* hdr_candidate = (IMAGE_FILE_HEADER*)nt_ptr;
	if (!peconv::validate_ptr(vBuf, vBufSize, hdr_candidate, sizeof(IMAGE_FILE_HEADER))) {
		// probably buffer finished
		return false;
	}

	size_t opt_hdr_size = 0;
	if (artefacts.is64bit) {
		hdr_candidate->Machine = IMAGE_FILE_MACHINE_AMD64;
		opt_hdr_size = sizeof(IMAGE_OPTIONAL_HEADER64);
	}
	else {
		hdr_candidate->Machine = IMAGE_FILE_MACHINE_I386;
		opt_hdr_size = sizeof(IMAGE_OPTIONAL_HEADER32);
	}
	if (this->artefacts.secHdrsOffset) {
		const size_t sec_offset = this->artefacts.dropPeBase(this->artefacts.secHdrsOffset);
		size_t calc_offset = sec_offset - (nt_offset + sizeof(IMAGE_FILE_HEADER));

		if (calc_offset != opt_hdr_size) {
			std::cout << "[WARNING] Calculated sections header offset is different than the saved one!\n";
		}
		hdr_candidate->NumberOfSections = WORD(this->artefacts.secCount);
		hdr_candidate->SizeOfOptionalHeader = WORD(calc_offset);
	}
	hdr_candidate->NumberOfSymbols = 0;
	hdr_candidate->PointerToSymbolTable = 0;
	return true;
}

bool pesieve::PeReconstructor::reconstructPeHdr()
{
	BYTE *vBuf = this->peBuffer.vBuf;
	const size_t vBufSize = this->peBuffer.vBufSize;
	if (!vBuf) return false;

	if (!this->artefacts.hasNtHdrs()) {
		return false;
	}
	ULONGLONG nt_offset = this->artefacts.dropPeBase(this->artefacts.ntFileHdrsOffset);
	BYTE* nt_ptr = (BYTE*)((ULONGLONG)vBuf + nt_offset);
	BYTE *pe_ptr = nt_ptr - sizeof(DWORD);

	if (!peconv::validate_ptr(vBuf, vBufSize, pe_ptr, sizeof(DWORD))) {
		return false;
	}
	IMAGE_NT_HEADERS32 *nt32 = (IMAGE_NT_HEADERS32*)pe_ptr;
	//write signature:
	nt32->Signature = IMAGE_NT_SIGNATURE;
	IMAGE_FILE_HEADER *file_hdr = &nt32->FileHeader;

	bool is64bit = (file_hdr->Machine == IMAGE_FILE_MACHINE_AMD64) ? true : false;

	if (nt32->FileHeader.SizeOfOptionalHeader == 0) {
		nt32->FileHeader.SizeOfOptionalHeader = is64bit ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32);
	}
	LONG pe_offset = LONG((ULONGLONG)pe_ptr - (ULONGLONG)vBuf);
	IMAGE_DOS_HEADER* dosHdr = (IMAGE_DOS_HEADER*) vBuf;
	dosHdr->e_magic = IMAGE_DOS_SIGNATURE;
	dosHdr->e_lfanew = pe_offset;

	bool is_fixed = false;
	if (is64bit) {
		is_fixed = overwrite_opt_hdr<IMAGE_OPTIONAL_HEADER64>(vBuf, vBufSize, (IMAGE_OPTIONAL_HEADER64*)&nt32->OptionalHeader, this->artefacts);
	}
	else {
		is_fixed = overwrite_opt_hdr<IMAGE_OPTIONAL_HEADER32>(vBuf, vBufSize, &nt32->OptionalHeader, this->artefacts);
	}
	if (!is_fixed) {
		return false;
	}
	if (!peconv::get_nt_hdrs(vBuf, vBufSize)) {
		return false;
	}
	return true;
}


```

`postprocessors/pe_reconstructor.h`:

```h
#pragma once

#include <windows.h>
#include <psapi.h>
#include <map>
#include <peconv.h>

#include "pe_buffer.h"
#include "../scanners/artefact_scanner.h"

namespace pesieve {

	template <typename IMAGE_OPTIONAL_HEADER_T>
	bool overwrite_opt_hdr(BYTE* vBuf, size_t vBufSize, IMAGE_OPTIONAL_HEADER_T* opt_hdr_ptr, PeArtefacts &artefacts)
	{
#ifdef _DEBUG
		std::cout << "Trying to overwrite the optional header\n";
#endif
		if (!vBuf || !opt_hdr_ptr) return false;
		if (!peconv::validate_ptr(vBuf, vBufSize, opt_hdr_ptr, sizeof(IMAGE_OPTIONAL_HEADER_T))) {
			return false;
		}
		if (artefacts.is64bit) {
			opt_hdr_ptr->Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
		}
		else {
			opt_hdr_ptr->Magic = IMAGE_NT_OPTIONAL_HDR32_MAGIC;
		}
		//set typical values for the fields that has been erased:
		if (opt_hdr_ptr->SectionAlignment == 0) {
			opt_hdr_ptr->SectionAlignment = PAGE_SIZE;
		}
		if (opt_hdr_ptr->FileAlignment == 0) {
			opt_hdr_ptr->FileAlignment = 0x200; // typical file alignment
		}
		if (opt_hdr_ptr->SizeOfHeaders == 0) {
			opt_hdr_ptr->SizeOfHeaders = 0x400; //typical header size
		}
		if (opt_hdr_ptr->SizeOfImage < artefacts.calculatedImgSize) {
			opt_hdr_ptr->SizeOfImage = MASK_TO_DWORD(artefacts.calculatedImgSize);
		}
		return true;
	}

	class PeReconstructor {
	public:
		PeReconstructor(PeArtefacts _artefacts, PeBuffer &_peBuffer)
			: origArtefacts(_artefacts), peBuffer(_peBuffer)
		{
		}

		bool reconstruct();

	protected:
		bool reconstructFileHdr();
		bool reconstructPeHdr();
		bool fixSectionsVirtualSize(HANDLE processHandle);
		bool fixSectionsCharacteristics(HANDLE processHandle);

		size_t shiftPeHeader();

		const PeArtefacts origArtefacts;
		PeArtefacts artefacts;
		PeBuffer &peBuffer;
	};

}; //mamespace pesieve


```

`postprocessors/report_formatter.cpp`:

```cpp
#include "report_formatter.h"
#include <string>
#include <sstream>

using namespace pesieve;

std::string pesieve::scan_report_to_string(const ProcessScanReport &process_report)
{
	const t_report report = process_report.generateSummary();
	std::stringstream stream;
	//summary:
	size_t other = report.other;
	stream << "---" << std::endl;
	stream << "PID: " << std::dec << report.pid << "\n";
	stream << "---" << std::endl;
	stream << "SUMMARY: \n" << std::endl;
	stream << "Total scanned:      " << std::dec << report.scanned << "\n";
	stream << "Skipped:            " << std::dec << report.skipped << "\n";
	stream << "-\n";
	stream << "Hooked:             " << std::dec << report.patched << "\n";
	stream << "Replaced:           " << std::dec << report.replaced << "\n";
	stream << "Hdrs Modified:      " << std::dec << report.hdr_mod << "\n";
	stream << "IAT Hooks:          " << std::dec << report.iat_hooked << "\n";
	stream << "Implanted:          " << std::dec << report.implanted << "\n";
	if (report.implanted) {
		stream << "Implanted PE:       " << std::dec << report.implanted_pe << "\n";
		stream << "Implanted shc:      " << std::dec << report.implanted_shc << "\n";
	}
	stream << "Unreachable files:  " << std::dec << report.unreachable_file << "\n";
	stream << "Other:              " << std::dec << other << "\n";
	stream << "-\n";
	stream << "Total suspicious:   " << std::dec << report.suspicious << "\n";
	if (report.errors) {
		stream << "[!] Errors:         " << std::dec << report.errors << "\n";
	}
	return stream.str();
}

std::string pesieve::scan_report_to_json(
	const ProcessScanReport &process_report,
	ProcessScanReport::t_report_filter filter,
	const pesieve::t_json_level &jdetails
)
{
	//summary:
	std::stringstream stream;
	size_t level = 1;

	if (!process_report.toJSON(stream, level, filter, jdetails)) {
		return "";
	}
	std::string report_all = stream.str();
	if (report_all.length() == 0) {
		return "";
	}
	return report_all;
}

```

`postprocessors/report_formatter.h`:

```h
#pragma once

#include <windows.h>
#include <iostream>

#include "pe_sieve_types.h"
#include "../scanners/scan_report.h"
#include "../postprocessors/dump_report.h"

namespace pesieve {

	std::string scan_report_to_string(const ProcessScanReport &report);
	std::string scan_report_to_json(const ProcessScanReport &process_report, ProcessScanReport::t_report_filter filter, const pesieve::t_json_level &jdetails);

}; // namespace pesieve


```

`postprocessors/results_dumper.cpp`:

```cpp
#include "results_dumper.h"

#include <windows.h>
#include <psapi.h>

#include <fstream>

#include "../utils/format_util.h"
#include "../utils/workingset_enum.h"
#include "pe_reconstructor.h"
#include "imp_rec/imp_reconstructor.h"
#include "../scanners/iat_scanner.h"
#include "../scanners/code_scanner.h"

#define DIR_SEPARATOR "\\"

//---
namespace pesieve {

	std::string get_payload_ext(const ArtefactScanReport& artefactRepot)
	{
		if (!artefactRepot.has_pe) {
			return "shc";
		}
		if (artefactRepot.artefacts.isDll) {
			return "dll";
		}
		return "exe";
	}

	std::string get_dump_mode_name(peconv::t_pe_dump_mode dump_mode)
	{
		switch (dump_mode) {
		case peconv::PE_DUMP_VIRTUAL:
			return "VIRTUAL";
		case peconv::PE_DUMP_UNMAP:
			return "UNMAPPED";
		case peconv::PE_DUMP_REALIGN:
			return "REALIGNED";
		}
		return "";
	}

	std::string get_imprec_res_name(const ImpReconstructor::t_imprec_res &res)
	{
		switch (res) {
		case ImpReconstructor::IMP_NOT_FOUND:
			return "IMP_NOT_FOUND";
		case ImpReconstructor::IMP_RECOVERY_ERROR:
			return "IMP_RECOVERY_ERROR";
		case ImpReconstructor::IMP_RECOVERY_NOT_APPLICABLE:
			return "IMP_RECOVERY_NOT_APPLICABLE";
		case ImpReconstructor::IMP_RECOVERY_SKIPPED:
			return "";
		case ImpReconstructor::IMP_ALREADY_OK:
			return "IMP_ALREADY_OK";
		case ImpReconstructor::IMP_DIR_FIXED:
			return "IMP_DIR_FIXED";
		case ImpReconstructor::IMP_FIXED:
			return "IMP_FIXED";
		case ImpReconstructor::IMP_RECREATED_FILTER0:
			return "IMP_RECREATED_FILTER0";
		case ImpReconstructor::IMP_RECREATED_FILTER1:
			return "IMP_RECREATED_FILTER1";
		case ImpReconstructor::IMP_RECREATED_FILTER2:
			return "IMP_RECREATED_FILTER2";
		}
		return "Undefined";
	}

	peconv::t_pe_dump_mode convert_to_peconv_dump_mode(const pesieve::t_dump_mode dump_mode)
	{
		switch (dump_mode) {
		case pesieve::PE_DUMP_AUTO:
			return peconv::PE_DUMP_AUTO;

		case pesieve::PE_DUMP_VIRTUAL:
			return peconv::PE_DUMP_VIRTUAL;

		case pesieve::PE_DUMP_UNMAP:
			return peconv::PE_DUMP_UNMAP;

		case pesieve::PE_DUMP_REALIGN:
			return peconv::PE_DUMP_REALIGN;
		}
		return peconv::PE_DUMP_AUTO;
	}

	bool make_dump_dir(const std::string& directory)
	{
		if (directory.length() == 0) {
			return true;
		}
		return util::create_dir_recursively(directory);
	}

	std::string get_module_file_name(HANDLE processHandle, const ModuleScanReport& mod)
	{
		if (mod.moduleFile.length() > 0) {
			return peconv::get_file_name(mod.moduleFile);
		}

		char szModName[MAX_PATH] = { 0 };
		memset(szModName, 0, MAX_PATH);

		std::string modulePath = "";
		if (GetModuleFileNameExA(processHandle, (HMODULE)mod.module, szModName, MAX_PATH)) {
			modulePath = peconv::get_file_name(szModName);
		}
		return modulePath;
	}
	//---
}; //namespace pesieve


bool pesieve::ResultsDumper::dumpJsonReport(pesieve::ProcessScanReport &process_report, const ProcessScanReport::t_report_filter &filter, const pesieve::t_json_level &jdetails)
{
	std::stringstream stream;
	size_t level = 1;

	if (!process_report.hasAnyShownType(filter)) {
		return false;
	}
	if (!process_report.toJSON(stream, level, filter, jdetails)) {
		return false;
	}
	std::string report_all = stream.str();
	if (report_all.length() == 0) {
		return false;
	}
	//ensure that the directory is created:
	this->dumpDir = pesieve::ResultsDumper::makeDirName(process_report.getPid());

	std::ofstream json_report;
	std::string report_path = makeOutPath("scan_report.json");
	json_report.open(report_path);
	if (json_report.is_open() == false) {
		return false;
	}
	json_report << report_all;
	if (json_report.is_open()) {
		json_report.close();
		return true;
	}
	return false;
}

bool pesieve::ResultsDumper::dumpJsonReport(ProcessDumpReport &process_report)
{
	if (!process_report.isFilled()) {
		return false;
	}
	std::stringstream stream;
	size_t level = 1;
	process_report.toJSON(stream, level);
	std::string report_all = stream.str();
	if (report_all.length() == 0) {
		return false;
	}
	//ensure that the directory is created:
	this->dumpDir = pesieve::ResultsDumper::makeDirName(process_report.getPid());

	std::ofstream json_report;
	std::string report_path = makeOutPath("dump_report.json");
	json_report.open(report_path);
	if (json_report.is_open() == false) {
		return false;
	}
	json_report << report_all;
	if (json_report.is_open()) {
		json_report.close();
		return true;
	}
	return false;
}

pesieve::ProcessDumpReport* pesieve::ResultsDumper::dumpDetectedModules(
	HANDLE processHandle,
	bool isRefl,
	ProcessScanReport &process_report, 
	const pesieve::t_dump_mode dump_mode, 
	const t_imprec_mode imprec_mode)
{
	if (processHandle == nullptr) {
		return nullptr;
	}
	ProcessDumpReport *dumpReport = new ProcessDumpReport(process_report.getPid());
	this->dumpDir = pesieve::ResultsDumper::makeDirName(process_report.getPid());

	std::vector<ModuleScanReport*>::iterator itr;
	for (itr = process_report.moduleReports.begin();
		itr != process_report.moduleReports.end();
		++itr)
	{
		ModuleScanReport* mod = *itr;
		if (mod->status != SCAN_SUSPICIOUS) {
			continue;
		}
		dumpModule(processHandle,
			isRefl,
			process_report.modulesInfo,
			mod,
			process_report.exportsMap,
			dump_mode,
			imprec_mode,
			*dumpReport
		);
	}
	return dumpReport;
}

bool pesieve::ResultsDumper::dumpModule(IN HANDLE processHandle,
	IN bool isRefl,
	IN const ModulesInfo &modulesInfo,
	IN ModuleScanReport* mod,
	IN const peconv::ExportsMapper *exportsMap,
	IN const pesieve::t_dump_mode dump_mode,
	IN const t_imprec_mode imprec_mode,
	OUT ProcessDumpReport &dumpReport
)
{
	if (!mod) return false;

	const bool save_imp_report = true;
	bool is_dumped = false;

	peconv::t_pe_dump_mode curr_dump_mode = convert_to_peconv_dump_mode(dump_mode);

	bool dump_shellcode = false;
	std::string payload_ext = "";

	PeBuffer module_buf(processHandle, isRefl);
	bool is_corrupt_pe = false;
	ArtefactScanReport* artefactReport = dynamic_cast<ArtefactScanReport*>(mod);
	if (artefactReport) {
		payload_ext = get_payload_ext(*artefactReport);
		//whenever the artefactReport is available, use it to reconstruct a PE
		if (artefactReport->has_shellcode) {
			dump_shellcode = true;
		}
		if (artefactReport->has_pe) {
			ULONGLONG found_pe_base = artefactReport->artefacts.peImageBase();
			PeReconstructor peRec(artefactReport->artefacts, module_buf);
			if (!peRec.reconstruct()) {
				is_corrupt_pe = true;
				payload_ext = "corrupt_" + payload_ext;
				if (!this->quiet) {
					std::cout << "[-] Reconstructing PE at: " << std::hex << (ULONGLONG)found_pe_base << " failed." << std::endl;
				}
			}
		}
	}
	// if it is not an artefact report, or reconstructing by artefacts failed, read it from the memory:
	if (!artefactReport || is_corrupt_pe) {
		module_buf.readRemote((ULONGLONG)mod->module, mod->moduleSize);
	}
	//if no extension selected yet, do it now:
	if (payload_ext.length() == 0) {
		payload_ext = module_buf.isValidPe() ? "dll" : "shc";
	}
	const std::string module_name = get_module_file_name(processHandle, *mod);

	ModuleDumpReport *modDumpReport = new ModuleDumpReport(module_buf.getModuleBase(), module_buf.getBufferSize());
	dumpReport.appendReport(modDumpReport);

	modDumpReport->dumpFileName = makeModuleDumpPath(module_buf.getModuleBase(), module_name, payload_ext);
	modDumpReport->is_corrupt_pe = is_corrupt_pe;
	modDumpReport->is_shellcode = !module_buf.isValidPe();
	
	peconv::ImpsNotCovered notCovered;

	if (module_buf.isFilled()) {

		// Try to fix imports:
		ImpReconstructor impRec(module_buf);
		ImpReconstructor::t_imprec_res imprec_res = impRec.rebuildImportTable(exportsMap, imprec_mode);
		modDumpReport->impRecMode = get_imprec_res_name(imprec_res);


		module_buf.setRelocBase(mod->getRelocBase());
		if (imprec_mode == pesieve::PE_IMPREC_NONE) {
			modDumpReport->isDumped = module_buf.dumpPeToFile(modDumpReport->dumpFileName, curr_dump_mode);
		}
		else {
			modDumpReport->isDumped = module_buf.dumpPeToFile(modDumpReport->dumpFileName, curr_dump_mode, exportsMap, &notCovered);
		}
		

		if (!modDumpReport->isDumped) {
			modDumpReport->isDumped = module_buf.dumpToFile(modDumpReport->dumpFileName);
			curr_dump_mode = peconv::PE_DUMP_VIRTUAL;
		}
		modDumpReport->mode_info = get_dump_mode_name(curr_dump_mode);
		bool iat_not_rebuilt = (imprec_res == ImpReconstructor::IMP_RECOVERY_ERROR) || (imprec_res = ImpReconstructor::IMP_RECOVERY_NOT_APPLICABLE);
		if (iat_not_rebuilt || save_imp_report) {
			std::string imports_file = modDumpReport->dumpFileName + ".imports.txt";
			if (impRec.printFoundIATs(imports_file)) {
				modDumpReport->impListFileName = imports_file;
			}
		}
		std::string imports_not_rec_file = modDumpReport->dumpFileName + ".not_fixed_imports.txt";
		if (IATScanReport::saveNotRecovered(imports_not_rec_file, processHandle, nullptr, notCovered, modulesInfo, exportsMap)) {
			modDumpReport->notRecoveredFileName = imports_not_rec_file;
		}
	}

	if (!modDumpReport->isDumped || dump_shellcode)
	{
		if (dump_shellcode) {
			payload_ext = "shc";
		}
		module_buf.readRemote((ULONGLONG)mod->module, mod->moduleSize);

		modDumpReport = new ModuleDumpReport(module_buf.getModuleBase(), module_buf.getBufferSize());
		dumpReport.appendReport(modDumpReport);

		modDumpReport->is_shellcode = dump_shellcode;
		modDumpReport->dumpFileName = makeModuleDumpPath(module_buf.getModuleBase(), module_name, payload_ext);
		modDumpReport->isDumped = module_buf.dumpToFile(modDumpReport->dumpFileName);
		curr_dump_mode = peconv::PE_DUMP_VIRTUAL;
		modDumpReport->mode_info = get_dump_mode_name(curr_dump_mode);
	}
	if (modDumpReport->isDumped) {
		is_dumped = true;
		if (!this->quiet) {
			std::string mode_info = modDumpReport->mode_info;
			if (mode_info.length() > 0) mode_info = " as " + mode_info;
			std::cout << "[*] Dumped module to: " + modDumpReport->dumpFileName + mode_info << "\n";
		}
	}
	else {
		std::cerr << "[-] Failed dumping module!" << std::endl;
		is_dumped = false;
	}

	pesieve::CodeScanReport *codeScanReport = dynamic_cast<pesieve::CodeScanReport*>(mod);
	if (codeScanReport) {
		std::string tags_file = modDumpReport->dumpFileName + ".tag";

		if (codeScanReport->generateTags(tags_file)) {
			modDumpReport->tagsFileName = tags_file;
			modDumpReport->isReportDumped = true;
		}
	}

	IATScanReport* iatHooksReport = dynamic_cast<IATScanReport*>(mod);
	if (iatHooksReport) {
		std::string imports_not_rec_file = modDumpReport->dumpFileName + ".iat_hooks.txt";

		if (iatHooksReport->generateList(imports_not_rec_file, processHandle, modulesInfo, exportsMap)) {
			modDumpReport->iatHooksFileName = imports_not_rec_file;
			modDumpReport->isReportDumped = true;
		}
	}
	return is_dumped;
}

void pesieve::ResultsDumper::makeAndJoinDirectories(std::stringstream& stream)
{
	if (!make_dump_dir(this->baseDir)) {
		this->baseDir = ""; // reset path
	}
	std::string inner_dir = this->dumpDir;
	if (baseDir.length() > 0) {
		inner_dir = this->baseDir + DIR_SEPARATOR + this->dumpDir;
	}
	if (!make_dump_dir(inner_dir)) {
		this->dumpDir = ""; // reset path
	}
	if (baseDir.length() > 0) {
		stream << baseDir;
		stream << DIR_SEPARATOR;
	}
	if (this->dumpDir.length() > 0) {
		stream << this->dumpDir;
		stream << DIR_SEPARATOR;
	}
}

std::string pesieve::ResultsDumper::makeModuleDumpPath(ULONGLONG modBaseAddr, std::string fname, const std::string &default_extension)
{
	std::stringstream stream;
	makeAndJoinDirectories(stream);
	stream << std::hex << modBaseAddr;
	if (fname.length() > 0) {
		stream << ".";
		stream << fname;
	} else {
		stream << "." << default_extension;
	}
	return stream.str();
}

std::string pesieve::ResultsDumper::makeOutPath(std::string fname, const std::string& default_extension)
{
	std::stringstream stream;
	makeAndJoinDirectories(stream);

	if (fname.length() > 0) {
		stream << fname;
	}
	else {
		stream << std::dec << time(nullptr);
		stream << default_extension;
	}
	return stream.str();
}

std::string pesieve::ResultsDumper::makeDirName(const DWORD process_id)
{
	std::stringstream stream;
	stream << "process_";
	stream << process_id;
	return stream.str();
}

```

`postprocessors/results_dumper.h`:

```h
#pragma once

#include <windows.h>

#include "report_formatter.h"
#include "dump_report.h"

namespace pesieve {

	class ResultsDumper
	{
	public:

		ResultsDumper(std::string _baseDir, bool _quiet)
			: baseDir(_baseDir), quiet(_quiet)
		{
		}

		// dump all modules detected as suspicious during the process scan
		ProcessDumpReport* dumpDetectedModules(HANDLE hProcess, bool isRefl, ProcessScanReport &process_report, const pesieve::t_dump_mode dump_mode, const pesieve::t_imprec_mode imprec_mode);

		// dump JSON report from the process scan
		bool dumpJsonReport(ProcessScanReport &process_report, const ProcessScanReport::t_report_filter &filter, const pesieve::t_json_level &jdetails);

		bool dumpJsonReport(ProcessDumpReport &process_report);

		std::string getOutputDir()
		{
			return this->dumpDir;
		}

		std::string makeOutPath(std::string fname, const std::string& defaultExtension = "");

	protected:
		/**
		\param processHandle : handle of the target process (from which the artefacts will be dumped)
		\param isRefl : a flag indicating if this is a process reflection
		\param modulesInfo : list the scanned modules, with their statuses
		\param modReport : ModuleScanReport defining artefacts to be dumped
		\param exportsMap : mapping of all the exported APIs available within the process (for imports reconstruction)
		\param imprec_mode : mode in which imports reconstruction will be attempted
		\param dumpReport : ProcessDumpReport to which reports from the current dump will be appended
		*/
		bool dumpModule(
			IN HANDLE processHandle,
			IN bool isRefl,
			IN const ModulesInfo &modulesInfo,
			IN ModuleScanReport* modReport,
			IN const peconv::ExportsMapper *exportsMap,
			IN const pesieve::t_dump_mode dump_mode,
			IN const pesieve::t_imprec_mode imprec_mode,
			OUT ProcessDumpReport &dumpReport
		);

		/**
		\param modBaseAddr : base address where this module was mapped
		\param fname : known name of this module
		\param defaultExtension : default extension - it will be used if no other extension was detected from the previous name
		*/
		std::string makeModuleDumpPath(ULONGLONG modBaseAddr, std::string fname, const std::string &defaultExtension);

		std::string makeDirName(const DWORD process_id);

		void makeAndJoinDirectories(std::stringstream& name_stream);

		std::string dumpDir; // dump directory
		std::string baseDir; // base directory
		bool quiet;
	};

}; //namespace pesieve

```

`resources.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resources.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resources.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "logo/favicon.ico"
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`scanners/artefact_scanner.cpp`:

```cpp
#include "artefact_scanner.h"

#include "../utils/artefacts_util.h"
#include "../utils/workingset_enum.h"

#include <peconv.h>

using namespace pesieve;
using namespace pesieve::util;

namespace pesieve {
	namespace util {

		size_t calc_offset(MemPageData &memPage, LPVOID field)
		{
			if (!field) return INVALID_OFFSET;

			BYTE* loadedData = memPage.getLoadedData();
			size_t loadedSize = memPage.getLoadedSize();
			if (!peconv::validate_ptr(loadedData, loadedSize, field, sizeof(BYTE))) {
				return INVALID_OFFSET;
			}
			return size_t((ULONG_PTR)field - (ULONG_PTR)loadedData);
		}

		size_t calc_sec_hdrs_offset(MemPageData &memPage, IMAGE_FILE_HEADER* nt_file_hdr)
		{
			size_t opt_hdr_size = nt_file_hdr->SizeOfOptionalHeader;
			if (opt_hdr_size == 0) {
				//try casual values
				bool is64bit = (nt_file_hdr->Machine == IMAGE_FILE_MACHINE_AMD64) ? true : false;
				opt_hdr_size = is64bit ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32);
			}
			const size_t headers_size = opt_hdr_size + sizeof(IMAGE_FILE_HEADER);
			size_t nt_offset = calc_offset(memPage, nt_file_hdr);
			size_t sec_hdr_offset = headers_size + nt_offset;
			return sec_hdr_offset;
		}

		size_t calc_nt_hdr_offset(MemPageData &memPage, IMAGE_SECTION_HEADER* first_sec, bool is64bit = true)
		{
			size_t sec_hdr_offset = calc_offset(memPage, first_sec);
			if (sec_hdr_offset == INVALID_OFFSET) {
				return INVALID_OFFSET;
			}
			size_t opt_hdr_size = is64bit ? sizeof(IMAGE_OPTIONAL_HEADER64) : sizeof(IMAGE_OPTIONAL_HEADER32);
			const size_t headers_size = opt_hdr_size + sizeof(IMAGE_FILE_HEADER);
			size_t nt_offset = sec_hdr_offset - headers_size;
			return nt_offset;
		}

		bool validate_hdrs_alignment(MemPageData &memPage, IMAGE_FILE_HEADER *nt_file_hdr, IMAGE_SECTION_HEADER* _sec_hdr)
		{
			if (!_sec_hdr) return false;
			if (!nt_file_hdr) return false;

			size_t sec_offset_hdrs = calc_sec_hdrs_offset(memPage, nt_file_hdr);
			size_t sec_offset = calc_offset(memPage, _sec_hdr);
			if (sec_offset_hdrs != sec_offset) {
				std::cout << std::hex << "sec_offset_hdrs: " << sec_offset_hdrs << " vs: " << sec_offset << "\n";

				return false;
			}
			return true;
		}

		size_t count_section_hdrs(BYTE *loadedData, size_t loadedSize, IMAGE_SECTION_HEADER *hdr_ptr)
		{
			if (!loadedData || !hdr_ptr) {
				return 0;
			}
			size_t counter = 0;
			IMAGE_SECTION_HEADER* curr_sec = hdr_ptr;
			do {
				if (!is_valid_section(loadedData, loadedSize, (BYTE*)curr_sec, IMAGE_SCN_MEM_READ)) {
					break;
				}
				curr_sec++;
				counter++;
			} while (true);

			return counter;
		}

		IMAGE_SECTION_HEADER* get_first_section(BYTE *loadedData, size_t loadedSize, IMAGE_SECTION_HEADER *hdr_ptr)
		{
			IMAGE_SECTION_HEADER* prev_sec = hdr_ptr;
			do {
				if (!is_valid_section(loadedData, loadedSize, (BYTE*)prev_sec, IMAGE_SCN_MEM_READ)) {
					break;
				}
				hdr_ptr = prev_sec;
				prev_sec--;
			} while (true);

			return hdr_ptr;
		}

	}; //namespace util
}; // namespace pesieve

bool pesieve::is_valid_section(BYTE *loadedData, size_t loadedSize, BYTE *hdr_ptr, DWORD charact)
{
	PIMAGE_SECTION_HEADER hdr_candidate = (PIMAGE_SECTION_HEADER) hdr_ptr;
	if (!peconv::validate_ptr(loadedData, loadedSize, hdr_candidate, sizeof(IMAGE_SECTION_HEADER))) {
		// probably buffer finished
		return false;
	}
	if (hdr_candidate->PointerToRelocations != 0
		|| hdr_candidate->NumberOfRelocations != 0
		|| hdr_candidate->PointerToLinenumbers != 0)
	{
		//values that should be NULL are not
		return false;
	}
	if (charact != 0 && (hdr_candidate->Characteristics & charact) == 0) {
		// required characteristics not found
		////std::cout << "The section " << hdr_candidate->Name << " NOT  valid, charact:" << std::hex << hdr_candidate->Characteristics << std::endl;
		return false;
	}
	////std::cout << "The section " << hdr_candidate->Name << " is valid!" << std::endl;
	return true;
}

ULONGLONG pesieve::ArtefactScanner::_findMZoffset(MemPageData &memPage, LPVOID sec_hdr)
{
	size_t hdrs_offset = calc_offset(memPage, sec_hdr);
	if (hdrs_offset == INVALID_OFFSET) {
		return INVALID_OFFSET;
	}
	
	const BYTE mz_sig[] = "MZ\x90";

	BYTE *min_search = memPage.getLoadedData();
	BYTE *start_ptr = min_search + hdrs_offset - sizeof(mz_sig);
	size_t space = PAGE_SIZE;
	//std::cout << "Searching the MZ header starting from: " << std::hex << hdrs_offset << "\n";
	for (BYTE *search_ptr = start_ptr; search_ptr >= min_search && space > 0; search_ptr--, space--) {
		if ((search_ptr[0] == mz_sig[0] && search_ptr[1] == mz_sig[1] )
			&& (search_ptr[2] == mz_sig[2] || search_ptr[2] == 0))
		{
			//std::cout << "MZ header found!\n";
			return calc_offset(memPage, search_ptr);
		}
	}
	//std::cout << "MZ header not found :(\n";
	return INVALID_OFFSET;
}

ULONGLONG pesieve::ArtefactScanner::calcPeBase(MemPageData &memPage, LPVOID sec_hdr)
{
	ULONGLONG found_mz = _findMZoffset(memPage, sec_hdr);
	if (found_mz != INVALID_OFFSET) {
		return memPage.region_start + found_mz;
	}
	
	size_t hdrs_offset = calc_offset(memPage, sec_hdr);
	if (hdrs_offset == INVALID_OFFSET) {
		//std::cout << "Invalid sec_hdr_offset\n";
		return 0;
	}
	//search by stub patterns
	size_t search_start = (hdrs_offset > PAGE_SIZE) ? hdrs_offset - PAGE_SIZE: 0;
	IMAGE_DOS_HEADER *dos_hdr = findDosHdrByPatterns(memPage, search_start, hdrs_offset);
	size_t dos_offset = calc_offset(memPage, dos_hdr);
	if (dos_offset != INVALID_OFFSET) {
		return memPage.region_start + dos_offset;
	}

	//WARNING: this will be inacurate in cases if the PE is not aligned to the beginning of the page
	size_t full_pages = hdrs_offset / PAGE_SIZE;
	//std::cout << "Full pages: " << std::dec << full_pages << std::endl;
	return memPage.region_start + (full_pages * PAGE_SIZE);
}

size_t pesieve::ArtefactScanner::calcImgSize(HANDLE processHandle, HMODULE modBaseAddr, BYTE* headerBuffer, size_t headerBufferSize, IMAGE_SECTION_HEADER *hdr_ptr)
{
	if (!hdr_ptr) {
		hdr_ptr = peconv::get_section_hdr(headerBuffer, headerBufferSize, 0);
		if (!hdr_ptr) return peconv::fetch_region_size(processHandle, (PBYTE)modBaseAddr);
	}

	DWORD max_addr = 0;

	const ULONGLONG main_base = peconv::fetch_alloc_base(processHandle, (PBYTE)modBaseAddr);
	for (IMAGE_SECTION_HEADER* curr_sec = hdr_ptr; ; curr_sec++)
	{
		//we don't know the number of sections, so we should validate each one
		if (!is_valid_section(headerBuffer, headerBufferSize, (BYTE*)curr_sec, 0)) {
			break;
		}
		if (curr_sec->Misc.VirtualSize == 0 || curr_sec->VirtualAddress == 0) {
			continue; //skip empty sections
		}

		const DWORD sec_rva = curr_sec->VirtualAddress;

		MEMORY_BASIC_INFORMATION page_info = { 0 };
		if (!peconv::fetch_region_info(processHandle, (PBYTE)((ULONG_PTR)modBaseAddr + sec_rva), page_info)) {
			break;
		}
		if ((ULONG_PTR)page_info.AllocationBase != main_base) {
			//it can happen if the PE is in a RAW format instead of Virtual
#ifdef _DEBUG
			std::cout << "[!] Mismatch: region_base : " << std::hex << page_info.AllocationBase << " while main base: " << main_base << "\n";
#endif
			break; // out of scope
		}
		if (page_info.Type == 0 || page_info.Protect == 0) {
			break; //invalid type, skip it
		}
		if ((page_info.State & MEM_COMMIT) == 0) {
			continue; //skip non-commited pages
		}
		if (sec_rva > max_addr) {
			max_addr = sec_rva;
		}
	}

	size_t last_sec_size = peconv::fetch_region_size(processHandle, (PBYTE)((ULONG_PTR)modBaseAddr + max_addr));
	size_t total_size = max_addr + last_sec_size;
#ifdef _DEBUG
	std::cout << "Image: " << std::hex << (ULONGLONG)modBaseAddr << " Size:" << std::hex << total_size << " max_addr: " << max_addr << std::endl;
#endif
	return total_size;
}

//calculate image size basing on the sizes of sections
size_t pesieve::ArtefactScanner::calcImageSize(MemPageData &memPage, IMAGE_SECTION_HEADER *hdr_ptr, ULONGLONG pe_image_base)
{
	return ArtefactScanner::calcImgSize(this->processHandle, (HMODULE)pe_image_base, memPage.getLoadedData(), memPage.getLoadedSize(), hdr_ptr);
}

IMAGE_DOS_HEADER* pesieve::ArtefactScanner::findDosHdrByPatterns(MemPageData &memPage, const size_t start_offset, size_t hdrs_offset)
{
	BYTE *search_ptr = memPage.getLoadedData() + start_offset;
	BYTE *max_search = search_ptr + hdrs_offset;

	size_t max_search_size = max_search - search_ptr;
	if (!memPage.validatePtr(search_ptr, max_search_size)) {
		return nullptr;
	}
	IMAGE_DOS_HEADER* dos_hdr = _findDosHdrByPatterns(search_ptr, max_search_size);
	const bool is_dos_valid = memPage.validatePtr(dos_hdr, sizeof(IMAGE_DOS_HEADER));
	if (is_dos_valid) {
		return dos_hdr;
	}
	return nullptr;
}

IMAGE_DOS_HEADER* pesieve::ArtefactScanner::_findDosHdrByPatterns(BYTE *search_ptr, const size_t max_search_size)
{
	if (!memPage.load()) {
		return nullptr;
	}

	const size_t patterns_count = 2;
	const size_t pattern_size = 14;
	BYTE stub_patterns[patterns_count][pattern_size] = { // common beginnnig of DOS stubs
		{
			0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4,
			0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C,
			0xCD, 0x21
		},
		{
			0xBA, 0x10, 0x00, 0x0E, 0x1F, 0xB4, 
			0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C,
			0xCD, 0x21
		}
	};

	const size_t dos_hdr_size = sizeof(IMAGE_DOS_HEADER);

	BYTE *stub_ptr = nullptr;
	IMAGE_DOS_HEADER *dos_ptr = nullptr;
	for (size_t i = 0; i < patterns_count; i++) {
		BYTE *pattern = stub_patterns[i];
		stub_ptr = find_pattern(search_ptr, max_search_size, pattern, pattern_size);
		if (!stub_ptr) {
			continue;
		}
		size_t offset_to_bgn = sizeof(IMAGE_DOS_HEADER);
		if ((ULONG_PTR)stub_ptr < offset_to_bgn) {
			return nullptr;
		}
		dos_ptr = (IMAGE_DOS_HEADER*)((ULONG_PTR)stub_ptr - offset_to_bgn);
		if (!peconv::validate_ptr(search_ptr, max_search_size, dos_ptr, sizeof(IMAGE_DOS_HEADER))) {
			continue;
		}
		return dos_ptr;
	}
	return nullptr;
}

bool pesieve::ArtefactScanner::_validateSecRegions(MemPageData &memPage, LPVOID sec_hdr, size_t sec_count, ULONGLONG pe_image_base, bool is_virtual)
{
	if (!sec_hdr || !sec_count) {
		return false;
	}
	MEMORY_BASIC_INFORMATION module_start_info = { 0 };
	if (!peconv::fetch_region_info(processHandle, (BYTE*)pe_image_base, module_start_info)) {
		return false;
	}
	IMAGE_SECTION_HEADER* curr_sec = (IMAGE_SECTION_HEADER*)sec_hdr;

	bool fetched_any = false;
	for (size_t i = 0; i < sec_count; i++, curr_sec++) {
		if (curr_sec->VirtualAddress == 0) continue;

		ULONG sec_start = is_virtual ? curr_sec->VirtualAddress : curr_sec->PointerToRawData;
		ULONGLONG last_sec_addr = pe_image_base + sec_start;

		MEMORY_BASIC_INFORMATION page_info = { 0 };
		if (!peconv::fetch_region_info(processHandle, (BYTE*)last_sec_addr, page_info)) {
#ifdef _DEBUG
			std::cout << std::hex << last_sec_addr << " couldn't fetch module info" << std::endl;
#endif
			return false;
		}
		if (page_info.AllocationBase != module_start_info.AllocationBase) {
#ifdef _DEBUG
			std::cout << "[-] SecBase mismatch: ";
			if (curr_sec->Name) {
				std::cout << curr_sec->Name;
			}
			std::cout << std::hex << i << " section: " << last_sec_addr << " alloc base: " << page_info.AllocationBase << " with module base: " << module_start_info.AllocationBase << std::endl;
#endif
			return false;
		}
	}
	return true;
}

bool pesieve::ArtefactScanner::_validateSecRegions(MemPageData &memPage, LPVOID sec_hdr, size_t sec_count)
{
	if (!memPage.getLoadedData() || !sec_hdr) {
		return 0;
	}
	ULONGLONG pe_image_base = this->calcPeBase(memPage, sec_hdr);
	bool has_non_zero = false;

	IMAGE_SECTION_HEADER* curr_sec = (IMAGE_SECTION_HEADER*)sec_hdr;
	for (size_t i = 0; i < sec_count; i++, curr_sec++) {
		if (curr_sec->VirtualAddress && curr_sec->Misc.VirtualSize) {
			has_non_zero = true;
		}
	}
	if (!has_non_zero) return false;

	//validate Virtual Sections alignment
	bool is_ok = _validateSecRegions(memPage, sec_hdr, sec_count, pe_image_base, true);
	if (!is_ok) {
		//maybe it is raw?
		is_ok = _validateSecRegions(memPage, sec_hdr, sec_count, pe_image_base, false);
#ifdef _DEBUG
		if (!is_ok) {
			std::cout << "[-] Raw failed!\n";
		}
		else {
			std::cout << "[+] Raw OK!\n";
		}
#endif
	}
#ifdef _DEBUG
	else {
		std::cout << "[+] Virtual OK!\n";
	}
#endif
	return is_ok;
}

BYTE* pesieve::ArtefactScanner::_findSecByPatterns(BYTE *search_ptr, const size_t max_search_size)
{
	if (!memPage.load()) {
		return nullptr;
	}
	const DWORD charact = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_EXECUTE;
	//find sections table
	char sec_name[] = ".text";
	BYTE *hdr_ptr = find_pattern(search_ptr, max_search_size, (BYTE*)sec_name, strlen(sec_name));
	if (hdr_ptr) {
		// if the section was found by name, check if it has valid characteristics:
		if (is_valid_section(search_ptr, max_search_size, hdr_ptr, charact)) {
			return hdr_ptr;
		}
		hdr_ptr = nullptr;
	}

	// try another pattern
	const size_t patterns_count = 2;
	const size_t pattern_size = sizeof(DWORD) * 4;
	BYTE charact_patterns[patterns_count][pattern_size] = { // common characteristics
		{
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x20, 0x00, 0x00, 0x60
		},
		{
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0xC0
		}
	};

	for (size_t i = 0; i < patterns_count; i++) {
		BYTE *sec_ending = charact_patterns[i];
		const size_t sec_ending_size = pattern_size;
		hdr_ptr = find_pattern(search_ptr, max_search_size, sec_ending, sec_ending_size);
		if (!hdr_ptr) {
			continue;
		}
		size_t offset_to_bgn = sizeof(IMAGE_SECTION_HEADER) - sec_ending_size;
		hdr_ptr -= offset_to_bgn;
		if (!peconv::validate_ptr(search_ptr, max_search_size, hdr_ptr, sizeof(IMAGE_SECTION_HEADER))) {
			continue;
		}
		if (is_valid_section(search_ptr, max_search_size, hdr_ptr, charact)) {
			return hdr_ptr;
		}
	}
	return nullptr;
}

IMAGE_SECTION_HEADER* pesieve::ArtefactScanner::findSecByPatterns(MemPageData &memPage, const size_t max_search_size, const size_t search_offset)
{
	BYTE *search_ptr = search_offset + memPage.getLoadedData();
	if (!memPage.validatePtr(search_ptr, max_search_size)) {
		return nullptr;
	}
	BYTE *hdr_ptr = _findSecByPatterns(search_ptr, max_search_size);
	if (!hdr_ptr) {
		return nullptr;
	}
	// is it really the first section?
	IMAGE_SECTION_HEADER *first_sec = get_first_section(memPage.getLoadedData(), memPage.getLoadedSize(), (IMAGE_SECTION_HEADER*) hdr_ptr);
	if (!first_sec) {
		return nullptr;
	}
	size_t count = count_section_hdrs(memPage.getLoadedData(), memPage.getLoadedSize(), first_sec);
	if (!_validateSecRegions(memPage, first_sec, count)) {
#ifdef _DEBUG
		const ULONGLONG diff = (ULONGLONG)first_sec - (ULONGLONG)memPage.getLoadedData();
		std::cout << "[!] section header: " << std::hex << (ULONGLONG)memPage.region_start << " hdr at: " << diff << " : validation failed!\n";
#endif
		return nullptr;
	}
	return (IMAGE_SECTION_HEADER*)first_sec;
}

bool pesieve::is_valid_file_hdr(BYTE *loadedData, size_t loadedSize, BYTE *hdr_ptr, DWORD charact)
{
	IMAGE_FILE_HEADER* hdr_candidate = (IMAGE_FILE_HEADER*)hdr_ptr;
	if (!peconv::validate_ptr(loadedData, loadedSize, hdr_candidate, sizeof(IMAGE_FILE_HEADER))) {
		// probably buffer finished
		return false;
	}
	if (hdr_candidate->NumberOfSections > 100) {
		return false;
	}
	if (hdr_candidate->NumberOfSymbols != 0 || hdr_candidate->PointerToSymbolTable != 0) {
		return false;
	}
	//sanity checks of machine and optional header size:
	size_t opt_hdr_size = 0;
	if (hdr_candidate->Machine == IMAGE_FILE_MACHINE_I386) {
		opt_hdr_size = sizeof(IMAGE_OPTIONAL_HEADER32);
	}
	else if (hdr_candidate->Machine == IMAGE_FILE_MACHINE_AMD64) {
		opt_hdr_size = sizeof(IMAGE_OPTIONAL_HEADER64);
	}
	else {
		// wrong machine ID
		return false;
	}
	if (hdr_candidate->SizeOfOptionalHeader > PAGE_SIZE) {
		return false;
	}
	if (!peconv::validate_ptr(loadedData, loadedSize, hdr_candidate, 
		sizeof(IMAGE_FILE_HEADER) + opt_hdr_size))
	{
		return false;
	}
	if (hdr_candidate->SizeOfOptionalHeader == opt_hdr_size) {
		return true;
	}
	//check characteristics:
	if (charact != 0 && (hdr_candidate->Characteristics & charact) == 0) {
		return false;
	}
	return true;
}

IMAGE_FILE_HEADER* pesieve::ArtefactScanner::findNtFileHdr(MemPageData &memPage, const size_t start_offset, size_t stop_offset)
{
	BYTE* const loadedData  = memPage.getLoadedData();
	size_t const loadedSize = memPage.getLoadedSize();
	size_t max_iter = 0; //UNLIMITED

	if (!loadedData) return nullptr;
	//std::cout << "Searching NT header, starting_offset = " << std::hex << start_offset << "\n";
	//normalize the stop_offset:
	if (stop_offset == INVALID_OFFSET || stop_offset == 0) {
		stop_offset = loadedSize;
		max_iter = 1;
	}
	if (stop_offset > loadedSize) {
		stop_offset = loadedSize;
	}
	//check the constraints:
	if (start_offset == INVALID_OFFSET
		|| start_offset >= loadedSize || stop_offset <= start_offset)
	{
		return nullptr;
	}

	BYTE* search_ptr = loadedData + start_offset;
	size_t search_size = loadedSize - start_offset;

	typedef enum {
		ARCH_32B = 0,
		ARCH_64B = 1,
		ARCHS_COUNT
	} t_archs;

	WORD archs[ARCHS_COUNT] = { 0 };
	archs[ARCH_32B] = IMAGE_FILE_MACHINE_I386;
	archs[ARCH_64B] = IMAGE_FILE_MACHINE_AMD64;

	BYTE *arch_ptr = nullptr;
	size_t my_arch = 0;
	for (my_arch = ARCH_32B; my_arch < ARCHS_COUNT; my_arch++) {
		arch_ptr = find_pattern(search_ptr, search_size, (BYTE*)&archs[my_arch], sizeof(WORD), max_iter);
		if (arch_ptr) {
			break;
		}
	}
	if (!arch_ptr) {
		//std::cout << "No architecture pattern found...\n";
		return nullptr;
	}
	DWORD charact = IMAGE_FILE_EXECUTABLE_IMAGE;
	if (my_arch == ARCH_32B) {
		charact |= IMAGE_FILE_32BIT_MACHINE;
	}
	else {
		charact |= IMAGE_FILE_LARGE_ADDRESS_AWARE;
	}
	//std::cout << "Found NT header, validating...\n";
	if (!is_valid_file_hdr(loadedData, loadedSize, arch_ptr, charact)) {
		return nullptr;
	}
	return reinterpret_cast<IMAGE_FILE_HEADER*>(arch_ptr);
}


IMAGE_DOS_HEADER* pesieve::ArtefactScanner::findMzPeHeader(MemPageData &memPage, const size_t search_offset)
{
	if (!memPage.load()) {
		return nullptr;
	}
	if (memPage.getLoadedSize() <= search_offset) {
		return nullptr;
	}
	const size_t scan_size = memPage.getLoadedSize() - search_offset;
	BYTE* buffer_ptr = memPage.getLoadedData() + search_offset;
	if (!memPage.validatePtr(buffer_ptr, scan_size)) {
		return nullptr;
	}
	const size_t minimal_size = sizeof(IMAGE_DOS_HEADER)
		+ sizeof(IMAGE_FILE_HEADER)
		+ sizeof(IMAGE_OPTIONAL_HEADER32);

	//scan only one page, not the full area
	for (size_t i = 0; i < scan_size; i++) {
		const size_t remaining_size = scan_size - i;
		if (remaining_size < minimal_size) {
			break;
		}
		const BYTE* pe_candidate = buffer_ptr + i;
		BYTE *nt_hdr = peconv::get_nt_hdrs(pe_candidate, remaining_size);
		if (nt_hdr != nullptr) {
			//it was possible to retrieve the NT header, so the PE candidate passed validation
			return (IMAGE_DOS_HEADER*)(pe_candidate);
		}
	}
	return nullptr;
}

bool pesieve::ArtefactScanner::findMzPe(ArtefactScanner::ArtefactsMapping &aMap, const size_t search_offset)
{
	IMAGE_DOS_HEADER* dos_hdr = findMzPeHeader(aMap.memPage, search_offset);
	if (!dos_hdr) {
		return false;
	}
	if (!aMap.memPage.validatePtr(dos_hdr, sizeof(IMAGE_DOS_HEADER))) {
		return false;
	}
	if (setMzPe(aMap, dos_hdr)) {
		aMap.isMzPeFound = true;
	}
	return true;
}

bool pesieve::ArtefactScanner::setMzPe(ArtefactsMapping &aMap, IMAGE_DOS_HEADER* _dos_hdr)
{
	if (!_dos_hdr) return false;

	aMap.dos_hdr = _dos_hdr;

	size_t dos_hdr_offset = calc_offset(aMap.memPage, aMap.dos_hdr);
	aMap.pe_image_base = aMap.memPage.region_start + dos_hdr_offset;

	IMAGE_NT_HEADERS32* pe_hdrs = (IMAGE_NT_HEADERS32*)((ULONGLONG)_dos_hdr + _dos_hdr->e_lfanew);
	if (!aMap.memPage.validatePtr(pe_hdrs, sizeof(IMAGE_NT_HEADERS32)))
	{
		return false;
	}
	setNtFileHdr(aMap, &pe_hdrs->FileHeader);
	return true;
}

bool pesieve::ArtefactScanner::setSecHdr(ArtefactScanner::ArtefactsMapping &aMap, IMAGE_SECTION_HEADER* _sec_hdr)
{
	if (_sec_hdr == nullptr) return false;
	const size_t sec_hdr_offset = calc_offset(aMap.memPage, _sec_hdr);
	if (sec_hdr_offset == INVALID_OFFSET) {
		return false;
	}
	MemPageData &memPage = aMap.memPage;
	BYTE* loadedData = aMap.memPage.getLoadedData();
	size_t loadedSize = aMap.memPage.getLoadedSize();

	//validate by counting the sections:
	size_t count = count_section_hdrs(loadedData, loadedSize, _sec_hdr);
	if (count == 0) {
		//std::cout << "Sections header didn't passed validation\n";
		// sections header didn't passed validation
		return false;
	}
	//if NT headers not found, search before sections header:
	if (!aMap.nt_file_hdr) {
		// try to find NT header relative to the sections header:
		size_t suggested_nt_offset = calc_nt_hdr_offset(aMap.memPage, _sec_hdr, this->isProcess64bit);
		if (suggested_nt_offset != INVALID_OFFSET && (sec_hdr_offset >= suggested_nt_offset)) {
			aMap.nt_file_hdr = findNtFileHdr(aMap.memPage, suggested_nt_offset, sec_hdr_offset);
		}
	}
	if (aMap.nt_file_hdr && (ULONG_PTR)aMap.nt_file_hdr > (ULONG_PTR)_sec_hdr) {
		return false; //misaligned
	}
	aMap.sec_hdr = _sec_hdr;
	aMap.sec_count = count;
	if (!aMap.pe_image_base) {
		aMap.pe_image_base = calcPeBase(aMap.memPage, (BYTE*)aMap.sec_hdr);
	}
	return true;
}

bool pesieve::ArtefactScanner::setNtFileHdr(ArtefactScanner::ArtefactsMapping &aMap, IMAGE_FILE_HEADER* _nt_hdr)
{
	if (!_nt_hdr) return false;

	aMap.nt_file_hdr = _nt_hdr;
	
	MemPageData &memPage = aMap.memPage;
	BYTE* loadedData = aMap.memPage.getLoadedData();

	//calculate sections header offset from FileHeader:
	if (!aMap.sec_hdr) {
		// set sections headers basing on File Header, do not validate yet
		size_t sec_hdr_offset = calc_sec_hdrs_offset(aMap.memPage, aMap.nt_file_hdr);
		aMap.sec_hdr = (IMAGE_SECTION_HEADER*)((ULONGLONG)loadedData + sec_hdr_offset);
		return true;
	}
	// sections headers were set before, validate if they match NT header:
	if (!validate_hdrs_alignment(aMap.memPage, aMap.nt_file_hdr, aMap.sec_hdr)) {
		aMap.nt_file_hdr = nullptr; // do not allow setting mismatching NT header

		std::cout << "[WARNING] Sections header misaligned with FileHeader." << std::endl;
		return false;
	}
	//validation passed:
	return true;
}

PeArtefacts* pesieve::ArtefactScanner::generateArtefacts(ArtefactScanner::ArtefactsMapping &aMap)
{
	MemPageData &memPage = aMap.memPage;
	BYTE* loadedData = aMap.memPage.getLoadedData();
	size_t loadedSize = aMap.memPage.getLoadedSize();

	if (!aMap.sec_hdr) {
		// if sections headers not found, don't continue
		return nullptr;
	}

	PeArtefacts *peArt = new PeArtefacts();
	peArt->regionStart =  memPage.region_start;
	peArt->isMzPeFound = aMap.isMzPeFound;

	peArt->secHdrsOffset = calc_offset(memPage, aMap.sec_hdr);
	peArt->secCount = count_section_hdrs(loadedData, loadedSize, aMap.sec_hdr);

	// if File Header found, use it to validate or find sections headers:
	peArt->ntFileHdrsOffset = calc_offset(memPage, aMap.nt_file_hdr);
	//std::cout << "NT offset: " << std::hex << peArt->ntFileHdrsOffset << std::endl;
	if (!aMap.pe_image_base) {
		aMap.pe_image_base = calcPeBase(aMap.memPage, (BYTE*)aMap.sec_hdr);
	}
	peArt->peBaseOffset = size_t(aMap.pe_image_base - memPage.region_start);
	peArt->calculatedImgSize = calcImageSize(memPage, aMap.sec_hdr, aMap.pe_image_base);

	if (aMap.nt_file_hdr) {
		peArt->isDll = ((aMap.nt_file_hdr->Characteristics & IMAGE_FILE_DLL) != 0);
	}

	if (aMap.nt_file_hdr && aMap.nt_file_hdr->Machine == IMAGE_FILE_MACHINE_I386) {
		aMap.is64bit = false;
	}
	else if (aMap.nt_file_hdr && aMap.nt_file_hdr->Machine == IMAGE_FILE_MACHINE_AMD64) {
		aMap.is64bit = true;
	}
	else {
		aMap.is64bit = this->isProcess64bit;
	}
	peArt->is64bit = aMap.is64bit;
	return peArt;
}

PeArtefacts* pesieve::ArtefactScanner::findArtefacts(MemPageData &memPage, size_t start_offset)
{
	if (!memPage.load()) {
		return nullptr;
	}

	ArtefactsMapping bestMapping(memPage, this->isProcess64bit);

	for (size_t min_offset = start_offset; min_offset < memPage.getLoadedSize(); min_offset++)
	{
		//std::cout << "Searching DOS header, min_offset: " << std::hex << min_offset << std::endl;

		ArtefactsMapping aMap(memPage, this->isProcess64bit);
		//try to find the DOS header
		if (findMzPe(aMap, min_offset)) {
			const size_t dos_offset = calc_offset(memPage, aMap.dos_hdr);
			min_offset = (dos_offset != INVALID_OFFSET) ? dos_offset : min_offset;
#ifdef _DEBUG
			std::cout << std::hex << "Page: " << aMap.memPage.start_va << " Found DOS Header at: " << dos_offset << "\n";
#endif
		}
		else {
#ifdef _DEBUG
			std::cout << std::hex << "Page: " << aMap.memPage.start_va << " Searching NT Header at: " << min_offset << "\n";
#endif
			IMAGE_FILE_HEADER *nt_hdr = findNtFileHdr(aMap.memPage, min_offset, memPage.getLoadedSize());
			setNtFileHdr(aMap, nt_hdr);
		}

		//adjust constraints for further searches:
		size_t max_section_search = memPage.getLoadedSize();
		if (aMap.nt_file_hdr) {
			const size_t nt_offset = calc_offset(memPage, aMap.nt_file_hdr);
			if (nt_offset != INVALID_OFFSET && nt_offset > min_offset) {
				min_offset = nt_offset;
			}
			//don't search sections in full module, only in the first mem page after the NT header:
			max_section_search = (PAGE_SIZE < memPage.getLoadedSize()) ? PAGE_SIZE : memPage.getLoadedSize();
			if (max_section_search + min_offset <= memPage.getLoadedSize()) {
				max_section_search += min_offset; //move the search window
			}
		}

		if (!setSecHdr(aMap, aMap.sec_hdr)) {
			//search sections by pattens:
			if (max_section_search > min_offset) {
				const size_t diff = max_section_search - min_offset;
				IMAGE_SECTION_HEADER *sec_hdr = findSecByPatterns(memPage, diff, min_offset);
				setSecHdr(aMap, sec_hdr);
			}
		}
		if (aMap.sec_hdr) {
			const size_t sec_offset = calc_offset(memPage, aMap.sec_hdr);
			if (sec_offset != INVALID_OFFSET && sec_offset > min_offset) {
				const size_t sections_area_size = aMap.sec_count * sizeof(IMAGE_SECTION_HEADER);
				min_offset = (sec_offset + sections_area_size);
#ifdef _DEBUG
				std::cout << "Setting minOffset to SecHdr end offset: " << std::hex << min_offset << "\n";
#endif
			}

			if (!aMap.dos_hdr) {
				const size_t start = (sec_offset > PAGE_SIZE) ? (sec_offset - PAGE_SIZE) : 0;
				//std::cout << "Searching DOS header by patterns " << std::hex << start << "\n";
				aMap.dos_hdr = findDosHdrByPatterns(aMap.memPage, start, sec_offset);
				if (aMap.dos_hdr && !aMap.nt_file_hdr) {
					IMAGE_NT_HEADERS32 *nt_ptr = (IMAGE_NT_HEADERS32*)((ULONG_PTR)aMap.dos_hdr + aMap.dos_hdr->e_lfanew);
#ifdef _DEBUG
					const size_t nt_offset = calc_offset(memPage, nt_ptr);
					std::cout << "Found PE offset: " << std::hex << aMap.dos_hdr->e_lfanew << " NT offset: " << nt_offset << "\n";
#endif
					if (aMap.memPage.validatePtr(nt_ptr, sizeof(IMAGE_NT_HEADERS32))) {
						setNtFileHdr(aMap, &nt_ptr->FileHeader);
					}
				}
			}
		}
		if (!setSecHdr(aMap, aMap.sec_hdr)) {
			aMap.sec_hdr = nullptr;
		}
		bestMapping = (bestMapping < aMap) ? aMap : bestMapping;

		//do not continue the search if no artefacts found:
		if (!aMap.foundAny()) break;
	}
	//use the best found set of artefacts:
	return generateArtefacts(bestMapping);
}

PeArtefacts* pesieve::ArtefactScanner::findInPrevPages(ULONGLONG addr_start, ULONGLONG addr_stop)
{
	deletePrevPage();
	PeArtefacts* peArt = nullptr;
	ULONGLONG next_addr = addr_stop - PAGE_SIZE;
	do {
		if (next_addr < addr_start) {
			break;
		}
		const size_t area_size = size_t(addr_stop - next_addr);
		if (this->processReport.hasModuleContaining((ULONGLONG)next_addr, area_size)) {
			//std::cout << "Aready scanned: " << std::hex << next_addr << " size: " << area_size << "\n";
			break;
		}
		this->prevMemPage = new MemPageData(this->processHandle, this->isReflection, next_addr, addr_stop);
		peArt = findArtefacts(*prevMemPage, 0);
		if (peArt) {
			break;
		}
		next_addr -= (this->prevMemPage->region_start - PAGE_SIZE);
		deletePrevPage();
	} while (true);

	return peArt;
}

bool pesieve::ArtefactScanner::hasShellcode(HMODULE region_start, size_t region_size, PeArtefacts &peArt)
{
	bool is_shellcode = false;
	if (peArt.peBaseOffset > 0) {
		// the total region is bigger than the PE
		is_shellcode = true;
	}
	if (region_size > peArt.calculatedImgSize) {
		// the total region is bigger than the PE
		is_shellcode = true;
	}
	return is_shellcode;
}

ArtefactScanReport* pesieve::ArtefactScanner::scanRemote()
{
	deletePrevPage();

	// it may still contain a damaged PE header...
	ULONGLONG region_start = memPage.region_start;
	this->artPagePtr = &memPage;

	PeArtefacts *peArt = findArtefacts(memPage, 0);
	if (!peArt && (region_start > memPage.alloc_base)) {
		peArt = findInPrevPages(memPage.alloc_base, memPage.region_start);
		if (prevMemPage) {
			this->artPagePtr = prevMemPage;
			region_start = prevMemPage->region_start;
		}
	}
	if (!peArt) {
		//no artefacts found
		return nullptr;
	}
	const size_t region_size = size_t(memPage.region_end - region_start);

	ArtefactScanReport *my_report = new ArtefactScanReport((HMODULE)region_start, region_size, SCAN_SUSPICIOUS, *peArt);
	my_report->protection = memPage.protection;
	my_report->has_shellcode = hasShellcode((HMODULE)region_start, region_size, *peArt);
	delete peArt;
	return my_report;
}

```

`scanners/artefact_scanner.h`:

```h
#pragma once

#include <windows.h>
#include <psapi.h>
#include <map>

#include <peconv.h>
#include "module_scan_report.h"
#include "workingset_scanner.h"
#include "../utils/process_util.h"

#define INVALID_OFFSET (-1)
#define PE_NOT_FOUND 0

namespace pesieve {

	bool is_valid_file_hdr(BYTE *loadedData, size_t loadedSize, BYTE *hdr_ptr, DWORD charact);
	bool is_valid_section(BYTE *loadedData, size_t loadedSize, BYTE *hdr_ptr, DWORD charact);

	//!  A report about the PE artefact detected in the workingset
	class PeArtefacts {
	public:
		static const size_t JSON_LEVEL = 1;

		PeArtefacts() {
			regionStart = INVALID_OFFSET;
			peBaseOffset = INVALID_OFFSET;
			ntFileHdrsOffset = INVALID_OFFSET;
			secHdrsOffset = INVALID_OFFSET;
			secCount = 0;
			calculatedImgSize = 0;
			isMzPeFound = false;
			isDll = true;
			is64bit = false;
		}

		bool hasNtHdrs()
		{
			return (ntFileHdrsOffset != INVALID_OFFSET);
		}

		bool hasSectionHdrs()
		{
			return (secHdrsOffset != INVALID_OFFSET);
		}

		ULONGLONG peImageBase()
		{
			if (peBaseOffset == INVALID_OFFSET) {
				return INVALID_OFFSET;
			}
			return this->peBaseOffset + this->regionStart;
		}

		ULONGLONG dropPeBase(const ULONGLONG offset_with_pe_base) const
		{
			if (peBaseOffset == INVALID_OFFSET || offset_with_pe_base == INVALID_OFFSET) {
				return INVALID_OFFSET;
			}
			if (offset_with_pe_base < peBaseOffset) {
				return INVALID_OFFSET;
			}
			return offset_with_pe_base - peBaseOffset;
		}

		const virtual bool fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"pe_base_offset\" : ");
			outs << "\"" << std::hex << peBaseOffset << "\"";
			if (hasNtHdrs()) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"nt_file_hdr\" : ");
				outs << "\"" << std::hex << ntFileHdrsOffset << "\"";
			}
			outs << ",\n";
			OUT_PADDED(outs, level, "\"sections_hdrs\" : ");
			outs << "\"" << std::hex << secHdrsOffset << "\"";
			outs << ",\n";
			OUT_PADDED(outs, level, "\"sections_count\" : ");
			outs << std::dec << secCount;
			outs << ",\n";
#ifdef _DEBUG
			OUT_PADDED(outs, level, "\"calculated_image_size\" : ");
			outs << std::hex << this->calculatedImgSize;
			outs << ",\n";
#endif
			OUT_PADDED(outs, level, "\"is_dll\" : ");
			outs << std::dec << isDll;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"is_64_bit\" : ");
			outs << std::dec << this->is64bit;
			return true;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"pe_artefacts\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		LONGLONG regionStart;
		size_t peBaseOffset; //offset from the regionStart (PE may not start at the first page of the region)
		size_t ntFileHdrsOffset; //offset from the regionStart
		size_t secHdrsOffset; //offset from the regionStart
		size_t secCount;
		size_t calculatedImgSize;
		bool isMzPeFound;
		bool isDll;
		bool is64bit;
	};

	//!  A report from the artefacts scan, generated by ArtefactScanner
	class ArtefactScanReport : public WorkingSetScanReport
	{
	public:
		ArtefactScanReport(HMODULE _module, size_t _moduleSize, t_scan_status status, PeArtefacts &peArt)
			: WorkingSetScanReport(_module, _moduleSize, status),
			artefacts(peArt),
			initialRegionSize(_moduleSize)
		{
			is_executable = true;
			protection = 0;
			has_pe = true;
			has_shellcode = false;

			size_t total_region_size = peArt.calculatedImgSize + peArt.peBaseOffset;
			if (total_region_size > this->moduleSize) {
				this->moduleSize = total_region_size;
			}
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			WorkingSetScanReport::fieldsToJSON(outs, level, jdetails);
			outs << ",\n";
			artefacts.toJSON(outs, level, jdetails);
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"workingset_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		PeArtefacts artefacts;
		size_t initialRegionSize;
	};

	//!  A scanner for detection of artefacts related to PE implants in the process workingset.
	class ArtefactScanner : public ProcessFeatureScanner {
	public:

		static size_t calcImgSize(HANDLE processHandle, HMODULE modBaseAddr, BYTE* headerBuffer, size_t headerBufferSize, IMAGE_SECTION_HEADER *hdr_ptr = NULL);

		ArtefactScanner(HANDLE _procHndl, bool _isProcRefl, MemPageData &_memPageData, ProcessScanReport& _process_report)
			: ProcessFeatureScanner(_procHndl), isReflection(_isProcRefl),
			processReport(_process_report), isProcess64bit(false),
			memPage(_memPageData), prevMemPage(nullptr), artPagePtr(nullptr)
		{
			isProcess64bit = pesieve::util::is_process_64bit(this->processHandle);
		}

		virtual ~ArtefactScanner()
		{
			deletePrevPage();
		}

		virtual ArtefactScanReport* scanRemote();

	protected:
		class ArtefactsMapping
		{
		public:
			ArtefactsMapping(MemPageData &_memPage, bool _is64bit) :
				memPage(_memPage)
			{
				pe_image_base = PE_NOT_FOUND;
				dos_hdr = nullptr;
				nt_file_hdr = nullptr;
				sec_hdr = nullptr;
				isMzPeFound = false;
				sec_count = 0;
				is64bit = _is64bit;
			}

			bool foundAny()
			{
				if (sec_hdr || nt_file_hdr) {
					return true;
				}
				return false;
			}

			size_t getScore() const
			{
				size_t score = 0;
				if (sec_hdr) score += 3;
				if (nt_file_hdr) score += 2;
				if (dos_hdr) score++;
				return score;
			}

			bool operator < (const ArtefactsMapping& map2) const {
				return getScore() < map2.getScore();
			}

			ArtefactsMapping& operator = (const ArtefactsMapping& other) {
				this->pe_image_base = other.pe_image_base;
				this->dos_hdr = other.dos_hdr;
				this->nt_file_hdr = other.nt_file_hdr;
				this->sec_hdr = other.sec_hdr;
				this->sec_count = other.sec_count;
				this->isMzPeFound = other.isMzPeFound;
				this->is64bit = other.is64bit;
				return *this;
			}

			MemPageData &memPage;
			ULONGLONG pe_image_base;
			IMAGE_DOS_HEADER *dos_hdr;
			IMAGE_FILE_HEADER* nt_file_hdr;
			IMAGE_SECTION_HEADER* sec_hdr;
			size_t sec_count;
			bool isMzPeFound;
			bool is64bit;
		};

		void deletePrevPage()
		{
			delete this->prevMemPage;
			this->prevMemPage = nullptr;
			this->artPagePtr = nullptr;
		}

		bool hasShellcode(HMODULE region_start, size_t region_size, PeArtefacts &peArt);

		bool findMzPe(ArtefactsMapping &mapping, const size_t search_offset);
		bool setMzPe(ArtefactsMapping &mapping, IMAGE_DOS_HEADER* _dos_hdr);
		bool setSecHdr(ArtefactsMapping &mapping, IMAGE_SECTION_HEADER* _sec_hdr);
		bool setNtFileHdr(ArtefactScanner::ArtefactsMapping &aMap, IMAGE_FILE_HEADER* _nt_hdr);
		PeArtefacts *generateArtefacts(ArtefactsMapping &aMap);

		PeArtefacts* findArtefacts(MemPageData &memPage, size_t start_offset);
		PeArtefacts* findInPrevPages(ULONGLONG addr_start, ULONGLONG addr_stop);

		ULONGLONG _findMZoffset(MemPageData &memPage, LPVOID hdr_ptr);
		ULONGLONG calcPeBase(MemPageData &memPage, LPVOID hdr_ptr);
		size_t calcImageSize(MemPageData &memPage, IMAGE_SECTION_HEADER *hdr_ptr, ULONGLONG pe_image_base);

		IMAGE_FILE_HEADER* findNtFileHdr(MemPageData &memPage, const size_t start_offset, size_t stop_offset = INVALID_OFFSET);

		bool _validateSecRegions(MemPageData &memPage, LPVOID sec_hdr, size_t sec_count, ULONGLONG pe_image_base, bool is_virtual);
		bool _validateSecRegions(MemPageData &memPage, LPVOID sec_hdr, size_t sec_count);
		BYTE* _findSecByPatterns(BYTE *search_ptr, const size_t max_search_size);
		IMAGE_SECTION_HEADER* findSecByPatterns(MemPageData &memPageData, const size_t max_search_size, const size_t search_offset);

		IMAGE_DOS_HEADER* findMzPeHeader(MemPageData &memPage, const size_t search_offset);
		IMAGE_DOS_HEADER* _findDosHdrByPatterns(BYTE *search_ptr, const size_t max_search_size);
		IMAGE_DOS_HEADER* findDosHdrByPatterns(MemPageData &memPage, const size_t start_offset, size_t stop_offset = INVALID_OFFSET);

		MemPageData &memPage;
		MemPageData *prevMemPage;
		MemPageData *artPagePtr; //pointer to the page where the artefacts were found: either to memPage or to prevMemPage
		bool isProcess64bit;
		const bool isReflection;
		ProcessScanReport& processReport;
	};

}; //namespace pe-sieve

```

`scanners/code_scanner.cpp`:

```cpp
#include "code_scanner.h"

#include <peconv.h>

#include "patch_analyzer.h"
#include "../utils/artefacts_util.h"
//---
#include <iostream>

using namespace pesieve;
using namespace pesieve::util;

size_t pesieve::CodeScanReport::generateTags(std::string reportPath)
{
	if (patchesList.size() == 0) {
		return 0;
	}
	std::ofstream patch_report;
	patch_report.open(reportPath);
	if (patch_report.is_open() == false) {
		return 0;
	}
	size_t patches = patchesList.toTAGs(patch_report, ';');
	if (patch_report.is_open()) {
		patch_report.close();
	}
	return patches;
}
//---

bool pesieve::CodeScanner::clearIAT(PeSection &originalSec, PeSection &remoteSec)
{
	// collect IAT fields:
	std::set<DWORD> impThunkRVAs;
	moduleData.loadImportThunks(impThunkRVAs);
	if (impThunkRVAs.size() == 0) {
		return false;
	}

	const size_t thunk_size = moduleData.is64bit() ? sizeof(ULONGLONG) : sizeof(DWORD);
	std::set<DWORD>::iterator itr;
	for (itr = impThunkRVAs.begin(); itr != impThunkRVAs.end(); ++itr) {
		const DWORD iat_field = *itr;
		// clear fields one by one:
		if (originalSec.isContained(iat_field, thunk_size)) {
			const DWORD offset = iat_field - originalSec.rva;
			memset(originalSec.loadedSection + offset, 0, thunk_size);
			memset(remoteSec.loadedSection + offset, 0, thunk_size);
		}
	}
	return true;
}

bool pesieve::CodeScanner::clearLoadConfig(PeSection &originalSec, PeSection &remoteSec)
{
	// check if the Guard flag is enabled:
	WORD charact = peconv::get_dll_characteristics(moduleData.original_module);
	if ((charact & 0x4000) == 0) {
		return false; //no guard flag
	}
	BYTE *ldconf_ptr = peconv::get_load_config_ptr(moduleData.original_module, moduleData.original_size);
	if (!ldconf_ptr) return false;

	peconv::t_load_config_ver ver = peconv::get_load_config_version(moduleData.original_module, moduleData.original_size, ldconf_ptr);
	if (ver != peconv::LOAD_CONFIG_W8_VER && ver != peconv::LOAD_CONFIG_W10_VER) {
		return false; // nothing to cleanup
	}
	ULONGLONG cflag_va = 0;
	size_t field_size = 0;
	if (this->moduleData.is64bit()) {
		peconv::IMAGE_LOAD_CONFIG_DIR64_W8* ldc = (peconv::IMAGE_LOAD_CONFIG_DIR64_W8*) ldconf_ptr;
		cflag_va = ldc->GuardCFCheckFunctionPointer;
		field_size = sizeof(ULONGLONG);
	}
	else {
		peconv::IMAGE_LOAD_CONFIG_DIR32_W8* ldc = (peconv::IMAGE_LOAD_CONFIG_DIR32_W8*) ldconf_ptr;
		cflag_va = ldc->GuardCFCheckFunctionPointer;
		field_size = sizeof(DWORD);
	}
	if (cflag_va == 0) return false;

	const ULONGLONG module_base = (ULONG_PTR)moduleData.moduleHandle;
	const ULONGLONG cflag_rva = cflag_va - module_base;
	if (!originalSec.isContained(cflag_rva, field_size)) {
		return false;
	}
	//clear the field:
	size_t sec_offset = size_t(cflag_rva - originalSec.rva);
	memset(originalSec.loadedSection + sec_offset, 0, field_size);
	memset(remoteSec.loadedSection + sec_offset, 0, field_size);
	return true;
}

bool pesieve::CodeScanner::clearExports(PeSection &originalSec, PeSection &remoteSec)
{
	IMAGE_DATA_DIRECTORY* dir = peconv::get_directory_entry(moduleData.original_module, IMAGE_DIRECTORY_ENTRY_EXPORT);
	if (!dir) {
		return false;
	}
	DWORD iat_rva = dir->VirtualAddress;
	DWORD iat_size = dir->Size;

	if (originalSec.isContained(iat_rva, iat_size))
	{
#ifdef _DEBUG
		std::cout << "Exports are in the Code section!" << std::endl;
#endif
		DWORD offset = iat_rva - originalSec.rva;
		IMAGE_EXPORT_DIRECTORY *exports = (IMAGE_EXPORT_DIRECTORY*) ((ULONGLONG)originalSec.loadedSection + offset);
		if (!peconv::validate_ptr(originalSec.loadedSection, originalSec.loadedSize, exports, sizeof(IMAGE_EXPORT_DIRECTORY))) {
			return false;
		}
		DWORD functions_offset = exports->AddressOfFunctions - originalSec.rva;
		DWORD functions_count = exports->NumberOfFunctions;

		const size_t func_area_size = functions_count * sizeof(DWORD);
		if (!peconv::validate_ptr(originalSec.loadedSection, originalSec.loadedSize, 
			originalSec.loadedSection + functions_offset, 
			func_area_size))
		{
			return false;
		}
		memset(originalSec.loadedSection + functions_offset, 0, func_area_size);
		memset(remoteSec.loadedSection + functions_offset, 0, func_area_size);
	}
	return true;
}

size_t pesieve::CodeScanner::collectPatches(DWORD section_rva, PBYTE orig_code, PBYTE patched_code, size_t code_size, OUT PatchList &patchesList)
{
	PatchAnalyzer analyzer(moduleData, section_rva, patched_code, code_size);
	PatchList::Patch *currPatch = nullptr;

	for (DWORD i = 0; i < (DWORD) code_size; i++) {
		if (orig_code[i] == patched_code[i]) {
			if (currPatch != nullptr) {
				// close the patch
				currPatch->setEnd(section_rva + i);
				currPatch = nullptr;
			}
			continue;
		}
		if (currPatch == nullptr) {
			//open a new patch
			currPatch = new(std::nothrow) PatchList::Patch(moduleData.moduleHandle, patchesList.size(), (DWORD) section_rva + i);
			if (!currPatch) continue;
			patchesList.insert(currPatch);
			DWORD parsed_size = (DWORD) analyzer.analyze(*currPatch);
			if (parsed_size > 0) {
				currPatch->setEnd(section_rva + i + parsed_size);
				currPatch = nullptr; // close this patch
				i += (parsed_size - 1); //substract 1 because of i++ executed after continue
				continue;
			}
		}
	}
	// if there is still unclosed patch, close it now:
	if (currPatch != nullptr) {
		//this happens if the patch lasts till the end of code, so, its end is the end of code
		currPatch->setEnd(section_rva + (DWORD) code_size);
		currPatch = nullptr;
	}
	return patchesList.size();
}

namespace pesieve {
	inline BYTE* first_different(const BYTE *buf_ptr, size_t bif_size, const BYTE padding)
	{
		for (size_t i = 0; i < bif_size; i++) {
			if (buf_ptr[i] != padding) {
				return (BYTE*)(buf_ptr + i);
			}
		}
		return nullptr;
	}
};

CodeScanReport::t_section_status pesieve::CodeScanner::scanSection(PeSection &originalSec, PeSection &remoteSec, OUT PatchList &patchesList)
{
	if (!originalSec.isInitialized() || !remoteSec.isInitialized()) {
		return CodeScanReport::SECTION_SCAN_ERR;
	}
	clearIAT(originalSec, remoteSec);
	clearExports(originalSec, remoteSec);
	clearLoadConfig(originalSec, remoteSec);
	//TODO: handle sections that have inside Delayed Imports (they give false positives)

	const size_t smaller_size = originalSec.loadedSize > remoteSec.loadedSize ? remoteSec.loadedSize : originalSec.loadedSize;
#ifdef _DEBUG
	std::cout << "Code RVA: " 
		<< std::hex << originalSec.rva
		<< " to "
		<< std::hex << originalSec.loadedSize
		<< std::endl;
#endif
	//check if the code of the loaded module is same as the code of the module on the disk:
	int res = memcmp(remoteSec.loadedSection, originalSec.loadedSection, smaller_size);

	if ((originalSec.rawSize == 0 || peconv::is_padding(originalSec.loadedSection, smaller_size, 0))
		&& !peconv::is_padding(remoteSec.loadedSection, smaller_size, 0))
	{
		return pesieve::CodeScanReport::SECTION_UNPACKED; // modified
	}

	if (res != 0) {
		collectPatches(originalSec.rva, originalSec.loadedSection, remoteSec.loadedSection, smaller_size, patchesList);
	}

	if (remoteSec.loadedSize > originalSec.loadedSize) {
		
		const size_t diff = remoteSec.loadedSize - originalSec.loadedSize;
		const BYTE *diff_bgn = remoteSec.loadedSection + originalSec.loadedSize;
		
		BYTE *not_padding = first_different(diff_bgn, diff, 0);
		if (not_padding) {
			const DWORD found_offset = MASK_TO_DWORD((ULONG_PTR)not_padding - (ULONG_PTR)remoteSec.loadedSection);
			const DWORD found_rva = remoteSec.rva + found_offset;
			PatchList::Patch* currPatch = new(std::nothrow) PatchList::Patch(moduleData.moduleHandle, patchesList.size(), found_rva);
			if (currPatch) {
				currPatch->setEnd(MASK_TO_DWORD(remoteSec.rva + remoteSec.loadedSize));
				patchesList.insert(currPatch);
			}
		}
	}
	if (patchesList.size()) {
		return pesieve::CodeScanReport::SECTION_PATCHED; // modified
	}
	if (res == 0) {
		return pesieve::CodeScanReport::SECTION_NOT_MODIFIED; //not modified
	}
	return pesieve::CodeScanReport::SECTION_UNPACKED; // modified
}

size_t pesieve::CodeScanner::collectExecutableSections(RemoteModuleData &_remoteModData, std::map<size_t, PeSection*> &sections, CodeScanReport &my_report)
{
	size_t initial_size = sections.size();
	const size_t sec_count = peconv::get_sections_count(_remoteModData.headerBuffer, _remoteModData.getHeaderSize());
	for (DWORD i = 0; i < sec_count; i++) {
		PIMAGE_SECTION_HEADER section_hdr = peconv::get_section_hdr(_remoteModData.headerBuffer, _remoteModData.getHeaderSize(), i);
		if (section_hdr == nullptr) {
			continue;
		}

		const bool is_entry = _remoteModData.isSectionEntry(i);

		if (!is_entry // entry section may be set as non executable, but it will still be executed
			&& !(section_hdr->Characteristics & IMAGE_SCN_MEM_EXECUTE)
			&& !_remoteModData.isSectionExecutable(i, this->isScanData, this->isScanInaccessible))
		{
			//not executable, skip it
			continue;
		}

		//get the code section from the remote module:
		PeSection *remoteSec = new(std::nothrow) PeSection(_remoteModData, i);
		if (remoteSec && remoteSec->isInitialized()) {
			if (is_entry // always scan section containing Entry Point
				|| is_code(remoteSec->loadedSection, remoteSec->loadedSize))
			{
				sections[i] = remoteSec;
				continue;
			}
		}
		else {
			// report about failed initialization
			my_report.sectionToResult[i] = CodeScanReport::SECTION_SCAN_ERR;
		}
		// the section was not added to the list, delete it instead:
		delete remoteSec;
	}
	//corner case: PEs without sections
	if (sec_count == 0) {
		PeSection *remoteSec = new(std::nothrow) PeSection(_remoteModData, 0);
		if (remoteSec && remoteSec->isInitialized()) {
			sections[0] = remoteSec;
		}
		else {
			// report about failed initialization
			my_report.sectionToResult[0] = CodeScanReport::SECTION_SCAN_ERR;
			// the section was not added to the list, delete it instead:
			delete remoteSec;
		}
	}
	return sections.size() - initial_size;
}

void pesieve::CodeScanner::freeExecutableSections(std::map<size_t, PeSection*> &sections)
{
	std::map<size_t, PeSection*>::iterator itr;
	for (itr = sections.begin(); itr != sections.end(); ++itr) {
		PeSection *sec = itr->second;
		delete sec;
	}
	sections.clear();
}

t_scan_status pesieve::CodeScanner::scanUsingBase(
	IN ULONGLONG load_base,
	IN std::map<size_t, PeSection*> &remote_code,
	OUT std::map<DWORD, CodeScanReport::t_section_status> &sectionToResult,
	OUT PatchList &patchesList)
{
	t_scan_status last_res = SCAN_NOT_SUSPICIOUS;

	// before scanning, ensure that the original module is relocated to the base where it was loaded
	if (!moduleData.relocateToBase(load_base)) {
		return SCAN_ERROR;
	}

	size_t errors = 0;
	size_t modified = 0;
	std::map<size_t, PeSection*>::iterator itr;

	for (itr = remote_code.begin(); itr != remote_code.end(); ++itr) {
		size_t sec_indx = itr->first;
		PeSection *remoteSec = itr->second;

		PeSection originalSec(moduleData, sec_indx);

		CodeScanReport::t_section_status sec_status = scanSection(originalSec, *remoteSec, patchesList);
		sectionToResult[originalSec.rva] = sec_status; //save the status for the section

		if (sec_status == pesieve::CodeScanReport::SECTION_SCAN_ERR) errors++;
		else if (sec_status != pesieve::CodeScanReport::SECTION_NOT_MODIFIED) {
			modified++;
		}
	}

	if (modified > 0) {
		last_res = SCAN_SUSPICIOUS; //the highest priority for modified
	}
	else if (errors > 0) {
		last_res = SCAN_ERROR;
	}
	return last_res;
}

pesieve::CodeScanReport* pesieve::CodeScanner::scanRemote()
{
	if (!moduleData.isInitialized()) {
		std::cerr << "[-] Module not initialized" << std::endl;
		return nullptr;
	}
	if (!remoteModData.isInitialized()) {
		std::cerr << "[-] Failed to read the module header" << std::endl;
		return nullptr;
	}
	CodeScanReport *my_report = new(std::nothrow) CodeScanReport(moduleData.moduleHandle, remoteModData.getModuleSize());
	if (!my_report) return nullptr; //this should not happen...

	my_report->isDotNetModule = moduleData.isDotNet();
	
	t_scan_status last_res = SCAN_NOT_SUSPICIOUS;
	std::map<size_t, PeSection*> remote_code;

	if (!collectExecutableSections(remoteModData, remote_code, *my_report)) {
		my_report->status = last_res;
		if (my_report->countInaccessibleSections() > 0) {
			my_report->status = SCAN_ERROR;
		}
		return my_report;
	}
	ULONGLONG load_base = (ULONGLONG)moduleData.moduleHandle;
	ULONGLONG hdr_base = remoteModData.getHdrImageBase();

	my_report->relocBase = load_base;
	last_res = scanUsingBase(load_base, remote_code, my_report->sectionToResult, my_report->patchesList);
	
	if (load_base != hdr_base && my_report->patchesList.size() > 0) {
#ifdef _DEBUG
		std::cout << "[WARNING] Load Base: " << std::hex << load_base << " is different than the Hdr Base: " << hdr_base << "\n";
#endif
		PatchList list2;
		std::map<DWORD, CodeScanReport::t_section_status> section_to_result;
		t_scan_status scan_res2 = scanUsingBase(hdr_base, remote_code, section_to_result, list2);
		if (list2.size() < my_report->patchesList.size()) {
			my_report->relocBase = hdr_base;
			my_report->patchesList = list2;
			my_report->sectionToResult = section_to_result;
			last_res = scan_res2;
		}
#ifdef _DEBUG
		std::cout << "Using patches list for the base: " << my_report->relocBase << " list size: " << my_report->patchesList.size() << "\n";
#endif
	}

	this->freeExecutableSections(remote_code);
	//post-process collected patches:
	postProcessScan(*my_report);

	my_report->status = last_res;
	return my_report; // last result
}

bool pesieve::CodeScanner::postProcessScan(IN OUT CodeScanReport &report)
{
	// we need only exports from the current module, not the global mapping
	if (report.patchesList.size() == 0) {
		return false;
	}
	peconv::ExportsMapper local_mapper;
	local_mapper.add_to_lookup(moduleData.szModName, (HMODULE) moduleData.original_module, (ULONGLONG) moduleData.moduleHandle);
	report.patchesList.checkForHookedExports(local_mapper);
	return true;
}

```

`scanners/code_scanner.h`:

```h
#pragma once
#include <windows.h>
#include <vector>
#include <fstream>

#include "module_scanner.h"
#include "pe_section.h"
#include "patch_list.h"

namespace pesieve {

	//!  A report from the code scan, generated by CodeScanner
	class CodeScanReport : public ModuleScanReport
	{
	public:
		
		typedef enum section_status {
			SECTION_SCAN_ERR = -1,
			SECTION_NOT_MODIFIED = 0,
			SECTION_PATCHED = 1,
			SECTION_UNPACKED = 2
		} t_section_status;

		CodeScanReport(HMODULE _module, size_t _moduleSize)
			: ModuleScanReport(_module, _moduleSize), relocBase(0)
		{
		}

		size_t countSectionsWithStatus(const t_section_status neededStatus)
		{
			size_t counter = 0;
			std::map<DWORD, t_section_status>::iterator itr;
			for (itr = sectionToResult.begin(); itr != sectionToResult.end(); ++itr) {
				const t_section_status status = itr->second;
				if (status == neededStatus) {
					counter++;
				}
			}
			return counter;
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			const size_t inaccessibleCount = countInaccessibleSections();
			const size_t scannedCount = sectionToResult.size() - inaccessibleCount;
			ModuleScanReport::_toJSON(outs, level);
			if (sectionToResult.size() > 0) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"scanned_sections\" : ");
				outs << std::dec << scannedCount;
			}
			if (inaccessibleCount > 0) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"inaccessible_sections\" : ");
				outs << std::dec << inaccessibleCount;
			}
			const size_t unpacked = countUnpackedSections();
			if (unpacked > 0) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"unpacked_sections\" : ");
				outs << std::dec << unpacked;
			}
			if (patchesList.size() > 0) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"patches\" : ");
				outs << std::dec << patchesList.size();

				if (jdetails >= JSON_DETAILS) {
					outs << ",\n";
					const bool is_short = (jdetails < JSON_DETAILS2) ? true : false;
					patchesList.toJSON(outs, level, is_short);
				}
			}
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"code_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		virtual ULONGLONG getRelocBase()
		{
			return this->relocBase;
		}

		size_t countUnpackedSections()
		{
			return countSectionsWithStatus(SECTION_UNPACKED);
		}

		size_t countInaccessibleSections()
		{
			return countSectionsWithStatus(SECTION_SCAN_ERR);
		}

		size_t generateTags(std::string reportPath);

		ULONGLONG relocBase;
		std::map<DWORD, t_section_status> sectionToResult;
		PatchList patchesList;
	};


	//!  A scanner for detection of patches in the code.
	class CodeScanner : public ModuleScanner {
	public:

		CodeScanner(HANDLE hProc, ModuleData &moduleData, RemoteModuleData &remoteModData)
			: ModuleScanner(hProc, moduleData, remoteModData),
			isScanData(false), isScanInaccessible(false)
		{
		}

		virtual CodeScanReport* scanRemote();

		void setScanData(bool enable) { this->isScanData = enable; }
		void setScanInaccessible(bool enable) { this->isScanInaccessible = enable; }

	private:

		size_t collectExecutableSections(RemoteModuleData &remoteModData, std::map<size_t, PeSection*> &sections, CodeScanReport &my_report);

		void freeExecutableSections(std::map<size_t, PeSection*> &sections);

		bool postProcessScan(IN OUT CodeScanReport &report);

		t_scan_status scanUsingBase(IN ULONGLONG load_base, IN std::map<size_t, PeSection*> &remote_code, OUT std::map<DWORD, CodeScanReport::t_section_status> &sectionToResult, OUT PatchList &patchesList);

		CodeScanReport::t_section_status scanSection(PeSection &originalSec, PeSection &remoteSec, OUT PatchList &patchesList);

		bool clearIAT(PeSection &originalSec, PeSection &remoteSec);

		bool clearExports(PeSection &originalSec, PeSection &remoteSec);

		bool clearLoadConfig(PeSection &originalSec, PeSection &remoteSec);

		size_t collectPatches(DWORD section_rva, PBYTE orig_code, PBYTE patched_code, size_t code_size, OUT PatchList &patchesList);

		bool isScanData;
		bool isScanInaccessible;
	};

}; //namespace pesieve


```

`scanners/headers_scanner.cpp`:

```cpp
#include "headers_scanner.h"
#include <peconv.h>

using namespace pesieve;

HeadersScanReport* pesieve::HeadersScanner::scanRemote()
{
	if (!moduleData.isInitialized() && !moduleData.loadOriginal()) {
		std::cerr << "[-] Module not initialized" << std::endl;
		return nullptr;
	}
	if (!remoteModData.isInitialized()) {
		std::cerr << "[-] Failed to read the module header" << std::endl;
		return nullptr;
	}

	HeadersScanReport *my_report = new HeadersScanReport(moduleData.moduleHandle, remoteModData.getModuleSize());

	BYTE hdr_buffer1[peconv::MAX_HEADER_SIZE] = { 0 };
	memcpy(hdr_buffer1, remoteModData.headerBuffer, peconv::MAX_HEADER_SIZE);
	my_report->is64 = peconv::is64bit(hdr_buffer1);
	my_report->isDotNetModule = moduleData.isDotNet();

	size_t hdrs_size = peconv::get_hdrs_size(hdr_buffer1);
	if (hdrs_size > peconv::MAX_HEADER_SIZE) {
		hdrs_size = peconv::MAX_HEADER_SIZE;
	}

	BYTE hdr_buffer2[peconv::MAX_HEADER_SIZE] = { 0 };
	memcpy(hdr_buffer2, moduleData.original_module, hdrs_size);

	// some .NET modules overwrite their own headers, so at this point they should be excluded from the comparison
	const DWORD ep1 = peconv::get_entry_point_rva(hdr_buffer1);
	const DWORD ep2 = peconv::get_entry_point_rva(hdr_buffer2);
	if (ep1 != ep2) {
		my_report->epModified = true;
	}
	const DWORD arch1 = peconv::get_nt_hdr_architecture(hdr_buffer1);
	const DWORD arch2 = peconv::get_nt_hdr_architecture(hdr_buffer2);
	if (arch1 != arch2) {
		// this often happend in .NET modules
		//if there is an architecture mismatch it may indicate that a different version of the app was loaded (possibly legit)
		my_report->archMismatch = true;
	}

	//normalize before comparing:
	peconv::update_image_base(hdr_buffer1, 0);
	peconv::update_image_base(hdr_buffer2, 0);

	zeroUnusedFields(hdr_buffer1, hdrs_size);
	zeroUnusedFields(hdr_buffer2, hdrs_size);

	//compare:
	if (memcmp(hdr_buffer1, hdr_buffer2, hdrs_size) == 0) {
		my_report->status = SCAN_NOT_SUSPICIOUS;
		return my_report;
	}
	//modifications detected, now find more details:
	my_report->dosHdrModified = isDosHdrModified(hdr_buffer1, hdr_buffer2, hdrs_size);
	my_report->fileHdrModified = isFileHdrModified(hdr_buffer1, hdr_buffer2, hdrs_size);
	my_report->ntHdrModified = isNtHdrModified(hdr_buffer1, hdr_buffer2, hdrs_size);
	my_report->secHdrModified = isSecHdrModified(hdr_buffer1, hdr_buffer2, hdrs_size);

	if (moduleData.isDotNet()) {
		const bool dotNetFileHdrModif = isFileHdrModified(hdr_buffer1, hdr_buffer2, hdrs_size, my_report->archMismatch);
#ifdef _DEBUG
		std::cout << "[#] .NET module detected as SUSPICIOUS\n";
#endif
		if (!my_report->isHdrReplaced()
			&& !my_report->dosHdrModified
			&& !dotNetFileHdrModif
			&& (my_report->epModified || (my_report->archMismatch && my_report->ntHdrModified))
			)
		{
			//.NET modules may overwrite some parts of their own headers
#ifdef _DEBUG
			std::cout << "[#] Filtered out modifications typical for .NET files, setting as not suspicious\n";
#endif
			my_report->status = SCAN_NOT_SUSPICIOUS;
			return my_report;
		}
	}
	my_report->status = SCAN_SUSPICIOUS;
	return my_report;
}

bool pesieve::HeadersScanner::zeroUnusedFields(PBYTE hdr_buffer, size_t hdrs_size)
{
	bool is_modified = false;
	const size_t section_num = peconv::get_sections_count(hdr_buffer, hdrs_size);

	for (size_t i = 0; i < section_num; i++) {
		PIMAGE_SECTION_HEADER sec_hdr = peconv::get_section_hdr(hdr_buffer, hdrs_size, i);
		if (sec_hdr == nullptr) continue;

		if (sec_hdr->SizeOfRawData == 0) {
			sec_hdr->PointerToRawData = 0;
			is_modified = true;
		}
	}
	return is_modified;
}

bool pesieve::HeadersScanner::isDosHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size)
{
	if (hdrs_size < sizeof(IMAGE_DOS_HEADER)) { //should never happen
		return false;
	}
	IMAGE_DOS_HEADER* hdr1 = (IMAGE_DOS_HEADER*)hdr_buffer1;
	IMAGE_DOS_HEADER* hdr2 = (IMAGE_DOS_HEADER*)hdr_buffer2;
	if (memcmp(hdr1, hdr2, sizeof(IMAGE_DOS_HEADER)) != 0) {
		return true;
	}

	LONG new_hdr = hdr2->e_lfanew;
	if (memcmp(hdr1, hdr2, new_hdr) != 0) {
		return true;
	}
	return false;
}

bool pesieve::HeadersScanner::isSecHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size)
{
	size_t section_num1 = peconv::get_sections_count(hdr_buffer1, hdrs_size);
	size_t section_num2 = peconv::get_sections_count(hdr_buffer2, hdrs_size);
	if (section_num1 != section_num2) {
		return true;
	}

	for (size_t i = 0; i < section_num1; i++) {
		PIMAGE_SECTION_HEADER sec_hdr1 = peconv::get_section_hdr(hdr_buffer1, hdrs_size, i);
		PIMAGE_SECTION_HEADER sec_hdr2 = peconv::get_section_hdr(hdr_buffer2, hdrs_size, i);
		if (!sec_hdr1 && !sec_hdr2) {
			continue;
		}
		else if (!sec_hdr1 || !sec_hdr2) {
			return true; //modified
		}

		if (sec_hdr1->VirtualAddress != sec_hdr2->VirtualAddress) {
			return true;
		}
		if (sec_hdr1->Misc.VirtualSize != sec_hdr2->Misc.VirtualSize) {
			return true;
		}
		if (sec_hdr1->PointerToRawData != sec_hdr2->PointerToRawData) {
			return true;
		}
	}
	return false;
}

bool pesieve::HeadersScanner::isFileHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size, bool mask_arch_mismatch)
{
	const IMAGE_FILE_HEADER *file_hdr1 = peconv::get_file_hdr(hdr_buffer1, hdrs_size);
	const IMAGE_FILE_HEADER *file_hdr2 = peconv::get_file_hdr(hdr_buffer2, hdrs_size);

	if (!file_hdr1 && !file_hdr2) return false;
	if (!file_hdr1 || !file_hdr2) return true;

	if (memcmp(file_hdr1, file_hdr2, sizeof(IMAGE_FILE_HEADER)) == 0) {
		return false;
	}
	if (mask_arch_mismatch) {
		if (file_hdr1->Machine == file_hdr2->Machine
			&& file_hdr1->Characteristics == file_hdr2->Characteristics
			&& file_hdr1->NumberOfSections == file_hdr2->NumberOfSections
			&& file_hdr1->TimeDateStamp == file_hdr2->TimeDateStamp
			&& file_hdr1->SizeOfOptionalHeader != file_hdr2->SizeOfOptionalHeader)
		{
			// only the SizeOfOptionalHeader has changed
			return false;
		}
	}
	return true;
}

bool pesieve::HeadersScanner::isNtHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size)
{
	const bool is64 = peconv::is64bit(hdr_buffer1);
	if (peconv::is64bit(hdr_buffer2) != is64) {
		return true;
	}
	const BYTE *nt1 = peconv::get_nt_hdrs(hdr_buffer1, hdrs_size);
	const BYTE *nt2 = peconv::get_nt_hdrs(hdr_buffer2, hdrs_size);
	if (!nt1 && !nt2) return false;
	if (!nt1 || !nt2) return true;

	const size_t nt_hdr_size = is64 ? sizeof(IMAGE_NT_HEADERS64) : sizeof(IMAGE_NT_HEADERS32);
	if (memcmp(nt1, nt2, nt_hdr_size) == 0) {
		return false;
	}
	return true;
}

```

`scanners/headers_scanner.h`:

```h
#pragma once

#include <windows.h>

#include "module_scanner.h"

namespace pesieve {

	//!  A report from the headers scan, generated by HeadersScanner
	class HeadersScanReport : public ModuleScanReport
	{
	public:
		HeadersScanReport(HMODULE _module, size_t _moduleSize)
			: ModuleScanReport(_module, _moduleSize),
			dosHdrModified(false), fileHdrModified(false), ntHdrModified(false),
			secHdrModified(false),
			epModified(false), archMismatch(false), is64(false)
		{
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			bool is_replaced = isHdrReplaced();
			ModuleScanReport::_toJSON(outs, level);
			outs << ",\n";
			OUT_PADDED(outs, level, "\"is_connected_to_peb\" : ");
			outs << isInPEB;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"is_pe_replaced\" : ");
			outs << is_replaced;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"dos_hdr_modified\" : ");
			outs << dosHdrModified;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"file_hdr_modified\" : ");
			outs << fileHdrModified;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"nt_hdr_modified\" : ");
			outs << ntHdrModified;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"ep_modified\" : ");
			outs << epModified;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"sec_hdr_modified\" : ");
			outs << secHdrModified;
			if (archMismatch) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"arch_mismatch\" : ");
				outs << archMismatch;
				outs << ",\n";
				OUT_PADDED(outs, level, "\"is64b\" : ");
				outs << is64;
			}
		}

		const virtual bool toJSON(std::stringstream& outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"headers_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		bool isHdrReplaced()
		{
			return secHdrModified;
		}

		bool epModified;
		bool dosHdrModified;
		bool fileHdrModified;
		bool ntHdrModified;
		bool secHdrModified;
		bool archMismatch; // the loaded module is of different architecture than the module read from the corresponding path
		DWORD is64; // is the remote module 64bit
		bool isInPEB;
	};


	//!  A scanner for detection of PE header's modifications.
	class HeadersScanner : public ModuleScanner {
	public:
		HeadersScanner(HANDLE hProc, ModuleData &moduleData, RemoteModuleData &remoteModData)
			: ModuleScanner(hProc, moduleData, remoteModData)
		{
		}

		virtual HeadersScanReport* scanRemote();

	private:
		bool zeroUnusedFields(PBYTE hdr_buffer, size_t hdrs_size);
		bool isSecHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size);
		bool isDosHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size);
		bool isFileHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size, bool mask_arch_mismatch = false);
		bool isNtHdrModified(const PBYTE hdr_buffer1, const PBYTE hdr_buffer2, const size_t hdrs_size);
	};

}; //namespace pesieve


```

`scanners/hook_targets_resolver.cpp`:

```cpp
#include "hook_targets_resolver.h"
#include "scanned_modules.h"

#include "scan_report.h"
#include "code_scanner.h"

using namespace pesieve;

bool pesieve::HookTargetResolver::resolveTarget(PatchList::Patch* currPatch)
{
	if (!currPatch) return false;

	const ULONGLONG searchedAddr = currPatch->getHookTargetVA();
	const ScannedModule* foundMod = processReport.getModuleContaining(searchedAddr);
	if (!foundMod) return false;

	if (processReport.exportsMap) {
		const peconv::ExportedFunc* expFunc = processReport.exportsMap->find_export_by_va(searchedAddr);
		if (expFunc) {
			const std::string targetName = foundMod->getModName() + "." + expFunc->nameToString();
			currPatch->setHookTargetInfo(foundMod->getStart(), foundMod->isSuspicious(), targetName);
			return true;
		}
	}
	currPatch->setHookTargetInfo(foundMod->getStart(), foundMod->isSuspicious(), foundMod->getModName());
	return true;
}

size_t pesieve::HookTargetResolver::resolveAllHooks(IN OUT std::set<ModuleScanReport*> &code_reports)
{
	size_t resolved = 0;
	std::set<ModuleScanReport*>::iterator cItr;
	for (cItr = code_reports.begin(); cItr != code_reports.end(); ++cItr) {
		ModuleScanReport* modrep = *cItr;
		CodeScanReport *coderep = dynamic_cast<CodeScanReport*>(modrep);
		if (!coderep) continue;

		std::vector<PatchList::Patch*>::iterator patchItr;
		for (patchItr = coderep->patchesList.patches.begin();
			patchItr != coderep->patchesList.patches.end();
			++patchItr)
		{
			PatchList::Patch* currPatch = *patchItr;
			if (resolveTarget(currPatch)) {
				resolved++;
			}
		}
	}
	return resolved;
}

```

`scanners/hook_targets_resolver.h`:

```h
#pragma once

#include "scan_report.h"
#include "code_scanner.h"

namespace pesieve {

	//!  Processes the list of the collected patches (preprocessed by PatchAnalyzer), and for those of them that were detected as hooks, it resolves information about to which modules do they lead to.
	class HookTargetResolver
	{
	public:
		HookTargetResolver(IN ProcessScanReport& process_report)
			: processReport(process_report)
		{
		}

		//!  Resolves all the hooks collected within the given set of reports
		size_t resolveAllHooks(IN OUT std::set<ModuleScanReport*> &code_reports);

		//!  Resolves the information about the target of the provided hook, and fills it back into the object.
		bool resolveTarget(IN OUT PatchList::Patch* currPatch);

	protected:
		ProcessScanReport& processReport;
	};

}; //namespace pesieve



```

`scanners/iat_scanner.cpp`:

```cpp
#include "iat_scanner.h"

#include <peconv.h>

#include <string>
#include <fstream>
#include <iostream>

using namespace pesieve;

const bool IATScanReport::hooksToJSON(std::stringstream &outs, size_t level)
{
	if (notCovered.count() == 0) {
		return false;
	}
	bool is_first = true;
	OUT_PADDED(outs, level, "\"hooks_list\" : [\n");

	std::map<DWORD, ULONGLONG>::iterator itr;
	for (itr = notCovered.thunkToAddr.begin(); itr != notCovered.thunkToAddr.end(); ++itr) {
		const DWORD thunk_rva = itr->first;
		const ULONGLONG addr = itr->second;
		if (!is_first) {
			outs << ",\n";
		}
		is_first = false;
		OUT_PADDED(outs, level, "{\n");

		OUT_PADDED(outs, (level + 1), "\"thunk_rva\" : ");
		outs << "\"" << std::hex << thunk_rva << "\"" << ",\n";

		std::map<DWORD, peconv::ExportedFunc*>::const_iterator found = storedFunc.thunkToFunc.find(thunk_rva);
		if (found != storedFunc.thunkToFunc.end()) {
			const peconv::ExportedFunc *func = found->second;
			if (func) {
				OUT_PADDED(outs, (level + 1), "\"func_name\" : ");
				outs << "\"" << func->toString() << "\"" << ",\n";
			}
		}
		OUT_PADDED(outs, (level + 1), "\"target_va\" : ");
		outs << "\"" << std::hex << (ULONGLONG)addr << "\"";
		outs << "\n";
		OUT_PADDED(outs, level, "}");
	}
	outs << "\n";
	OUT_PADDED(outs, level, "]");
	return true;
}

std::string IATScanReport::formatTargetName(IN const peconv::ExportsMapper* exportsMap, IN const ModulesInfo& modulesInfo, IN const ULONGLONG module_start, IN ULONGLONG addr)
{
	if (addr == 0) {
		return "(invalid)";
	}
	if (!exportsMap) {
		return "";
	}
	const peconv::ExportedFunc* func = exportsMap->find_export_by_va(addr);
	if (func) {
		return func->toString();
	}
	const ScannedModule* modExp = modulesInfo.findModuleContaining(addr);
	if (!modExp) {
		if (module_start == 0) {
			return "(invalid)";
		}
		return "(unknown)";
	}
	std::stringstream report;
	report << peconv::get_dll_shortname(modExp->getModName());
	report << ".(unknown_func)";
	return report.str();
}

std::string IATScanReport::formatHookedFuncName(IN peconv::ImportsCollection* storedFunc, DWORD thunk_rva)
{
	if (!storedFunc) {
		return "(unknown)";
	}
	std::map<DWORD, peconv::ExportedFunc*>::const_iterator found = storedFunc->thunkToFunc.find(thunk_rva);
	if (found != storedFunc->thunkToFunc.end()) {
		const peconv::ExportedFunc* func = found->second;
		if (!func) {
			return ""; //this should not happen
		}
		return func->toString();
	}
	return "(unknown)";
	
}

bool IATScanReport::saveNotRecovered(IN std::string fileName,
	IN HANDLE hProcess,
	IN peconv::ImportsCollection *storedFunc,
	IN peconv::ImpsNotCovered &notCovered,
	IN const ModulesInfo &modulesInfo,
	IN const peconv::ExportsMapper *exportsMap)
{
	const char delim = ';';
	const char internal_delim = ':';

	if (notCovered.count() == 0) {
		return false;
	}
	std::ofstream report;
	report.open(fileName);
	if (report.is_open() == false) {
		return false;
	}

	std::map<DWORD,ULONGLONG>::iterator itr;
	for (itr = notCovered.thunkToAddr.begin(); itr != notCovered.thunkToAddr.end(); ++itr)
	{
		const DWORD thunk_rva = itr->first;
		const ULONGLONG addr = itr->second;
		report << std::hex << thunk_rva << delim;
		if (storedFunc) {
			report << "[" << formatHookedFuncName(storedFunc, thunk_rva) << "]";
			report << "->";
		}
		const ScannedModule* modExp = modulesInfo.findModuleContaining(addr);
		const ULONGLONG module_start = (modExp) ? modExp->getStart() : peconv::fetch_alloc_base(hProcess, (BYTE*)addr);
		const ULONGLONG offset = addr - module_start;
		report << std::hex << addr;
		report << "["
			<< std::hex << module_start << "+" << offset
			<< internal_delim
			<< formatTargetName(exportsMap, modulesInfo, module_start, addr);
		report << internal_delim;
		if (modExp) {
			report << modExp->isSuspicious();
		}
		else {
			report << true; // module not found, assume suspicious
		}
		report  << "]";
		report << std::endl;
	}
	report.close();
	return true;
}

bool IATScanReport::generateList(IN const std::string &fileName, IN HANDLE hProcess, IN const ModulesInfo &modulesInfo, IN const peconv::ExportsMapper *exportsMap)
{
	return saveNotRecovered(fileName,
		hProcess,
		&storedFunc,
		notCovered,
		modulesInfo,
		exportsMap);
}


template <typename FIELD_T>
FIELD_T get_thunk_at_rva(BYTE *mod_buf, size_t mod_size, DWORD rva)
{
	if (!mod_buf || !mod_size) {
		return 0;
	}
	if (!peconv::validate_ptr(mod_buf, mod_size, (BYTE*)((ULONG_PTR)mod_buf + rva), sizeof(FIELD_T))) {
		return 0;
	}

	FIELD_T* field_ptr = (FIELD_T*)((ULONG_PTR)mod_buf + rva);
	return (*field_ptr);
}

bool pesieve::IATScanner::isValidFuncFilled(ULONGLONG filled_val, const peconv::ExportedFunc& definedFunc, const peconv::ExportedFunc &possibleFunc)
{
	if (!peconv::ExportedFunc::isTheSameFuncName(possibleFunc, definedFunc)) {
		return false;
	}
	if (peconv::ExportedFunc::isTheSameDllName(possibleFunc, definedFunc)) {
		return true;
	}
	ULONGLONG dll_base = this->exportsMap.find_dll_base_by_func_va(filled_val);
	if (!dll_base) {
		return false; //could not find a DLL by this function value
	}
	// check for a common redirection to another system DLL:
	const std::string fullName = exportsMap.get_dll_path(dll_base);
	//std::cout << std::hex << filled_val << " : " << dll_base << " : " << fullName << " : " << definedFunc.toString() << " : " << defined_short  << " vs " << possible_short << "\n";
	if (isInSystemDir(fullName)) {
		return true;
	}
	return false;
}

bool pesieve::IATScanner::scanByOriginalTable(peconv::ImpsNotCovered &not_covered)
{
	if (!remoteModData.isInitialized()) {
		std::cerr << "[-] Failed to initialize remote module header" << std::endl;
		return false;
	}
	if (!moduleData.isInitialized() && !moduleData.loadOriginal()) {
		std::cerr << "[-] Failed to initialize module data: " << moduleData.szModName << std::endl;
		return false;
	}

	// first try to find by the Import Table in the original file:
	peconv::ImportsCollection collection;
	if (!listAllImports(collection)) {
		return false;
	}
	if (collection.size() == 0) {
		return true; //nothing to scan...
	}

	// load full remote for the IAT scan:
	if (!remoteModData.loadFullImage()) {
		std::cerr << "[-] Failed to initialize remote module" << std::endl;
		return false;
	}
	std::map<DWORD, peconv::ExportedFunc*>::iterator itr;
	// get filled thunks from the mapped module (remote):

	for (itr = collection.thunkToFunc.begin(); itr != collection.thunkToFunc.end(); ++itr) {
		DWORD thunk_rva = itr->first;

		//std::cout << "Thunk: " << std::hex << *itr << "\n";
		ULONGLONG filled_val = 0;
		if (moduleData.is64bit()) {
			filled_val = get_thunk_at_rva<ULONGLONG>(remoteModData.imgBuffer, remoteModData.imgBufferSize, thunk_rva);
		}
		else {
			filled_val = get_thunk_at_rva<DWORD>(remoteModData.imgBuffer, remoteModData.imgBufferSize, thunk_rva);
		}
		peconv::ExportedFunc* defined_func = itr->second;
		if (!defined_func) {
			// cannot retrieve the origial import
			continue;
		}

		const std::set<peconv::ExportedFunc>* possibleExports = exportsMap.find_exports_by_va(filled_val);
		// no export at this thunk:
		if (!possibleExports || possibleExports->size() == 0) {

			//filter out .NET: mscoree._CorExeMain
			const std::string dShortName = peconv::get_dll_shortname(defined_func->libName);
			if (dShortName == "mscoree" 
				&& (defined_func->funcName == "_CorExeMain" || defined_func->funcName == "_CorDllMain") )
			{
				continue; //this is normal, skip it
			}

			not_covered.insert(thunk_rva, filled_val);
#ifdef _DEBUG
			std::cout << "Function not covered: " << std::hex << thunk_rva << " [" << dShortName << "] func: [" << defined_func->funcName << "] val: " << std::hex << filled_val << "\n";
#endif
			continue;
		}

		// check if the defined import matches the possible ones:
		bool is_covered = false;
		std::set<peconv::ExportedFunc>::const_iterator cItr;
		for (cItr = possibleExports->begin(); cItr != possibleExports->end(); ++cItr) {
			const peconv::ExportedFunc possibleFunc = *cItr;
			if (isValidFuncFilled(filled_val, *defined_func, possibleFunc)){
				is_covered = true;
				break;
			}
		}

		if (!is_covered) {
			not_covered.insert(thunk_rva, filled_val);
#ifdef _DEBUG
			std::cout << "Mismatch at RVA: " << std::hex << thunk_rva << " " << defined_func->libName<< " func: " << defined_func->toString() << "\n";

			for (cItr = possibleExports->begin(); cItr != possibleExports->end(); ++cItr) {
				const peconv::ExportedFunc possibleFunc = *cItr;
				std::cout << "\t proposed: " << possibleFunc.libName << " : " << possibleFunc.toString() << "\n";
			}
#endif
		}
	}
	return true;
}

IATScanReport* pesieve::IATScanner::scanRemote()
{
	if (!remoteModData.isInitialized()) {
		std::cerr << "[-] Failed to initialize remote module header" << std::endl;
		return nullptr;
	}

	peconv::ImpsNotCovered not_covered;
	t_scan_status status = SCAN_NOT_SUSPICIOUS;

	if (!scanByOriginalTable(not_covered)) {
		// IAT scan failed:
		status = SCAN_ERROR;
	}

	if (not_covered.count() > 0) {
#ifdef _DEBUG
		std::cout << "[*] IAT: " << moduleData.szModName << " hooked: " << not_covered.count() << "\n";
#endif
		status = SCAN_SUSPICIOUS;
	}
	
	IATScanReport *report = new(std::nothrow) IATScanReport(remoteModData.modBaseAddr, remoteModData.getModuleSize(), moduleData.szModName);
	if (!report) {
		return nullptr;
	}

	if (not_covered.count()) {
		listAllImports(report->storedFunc);
	}
	if (this->hooksFilter != PE_IATS_UNFILTERED) {
		filterResults(not_covered, *report);
	}
	else {
		report->notCovered = not_covered;
	}
	report->status = status;
	if (report->countHooked() == 0) {
		report->status = SCAN_NOT_SUSPICIOUS;
	}
	return report;
}
///-------

void pesieve::IATScanner::initExcludedPaths()
{
	char sysWow64Path[MAX_PATH] = { 0 };
	ExpandEnvironmentStringsA("%SystemRoot%\\SysWoW64", sysWow64Path, MAX_PATH);
	this->m_sysWow64Path_str = sysWow64Path;
	std::transform(m_sysWow64Path_str.begin(), m_sysWow64Path_str.end(), m_sysWow64Path_str.begin(), tolower);

	char system32Path[MAX_PATH] = { 0 };
	ExpandEnvironmentStringsA("%SystemRoot%\\system32", system32Path, MAX_PATH);
	this->m_system32Path_str = system32Path;
	std::transform(m_system32Path_str.begin(), m_system32Path_str.end(), m_system32Path_str.begin(), tolower);
}

bool pesieve::IATScanner::isInSystemDir(const std::string &moduleName)
{
	std::string dirName = peconv::get_directory_name(moduleName);
	std::transform(dirName.begin(), dirName.end(), dirName.begin(), tolower);

	if (dirName == m_system32Path_str || dirName == m_sysWow64Path_str) {
		return true;
	}
	return false;
}

bool pesieve::IATScanner::filterResults(peconv::ImpsNotCovered &notCovered, IATScanReport &report)
{
	std::map<DWORD, ULONGLONG>::iterator itr;
	for (itr = notCovered.thunkToAddr.begin(); itr != notCovered.thunkToAddr.end(); ++itr)
	{
		const DWORD thunk = itr->first;
		const ULONGLONG addr = itr->second;

		ScannedModule *modExp = modulesInfo.findModuleContaining(addr);
		ULONGLONG module_start = (modExp) ? modExp->getStart() : peconv::fetch_alloc_base(this->processHandle, (BYTE*)addr);
		if (module_start == 0) {
			// invalid address of the hook
			report.notCovered.insert(thunk, addr);
			continue;
		}
		if (this->hooksFilter == PE_IATS_CLEAN_SYS_FILTERED) {
			// insert hooks leading to suspicious modules:
			if (modExp && modExp->isSuspicious()) {
				report.notCovered.insert(thunk, addr);
				continue;
			}
		}
		// filter out hooks leading to system DLLs
		std::string moduleName = this->exportsMap.get_dll_path(module_start);
		if (isInSystemDir(moduleName)) {
#ifdef _DEBUG
			std::cout << "Skipped: " << moduleName << "\n";
#endif
			continue;
		}
		// insert hooks leading to non-system modules:
		report.notCovered.insert(thunk, addr);
	}
	return true;
}

bool pesieve::IATScanner::listAllImports(peconv::ImportsCollection &_storedFunc)
{
	return moduleData.loadImportsList(_storedFunc);
}


```

`scanners/iat_scanner.h`:

```h
#pragma once

#include <windows.h>

#include "module_scanner.h"
#include "scanned_modules.h"

namespace pesieve {

	//!  A report from an IAT scan, generated by IATScanner
	class IATScanReport : public ModuleScanReport
	{
	public:

		static bool saveNotRecovered(IN std::string fileName,
			IN HANDLE hProcess,
			IN peconv::ImportsCollection *storedFunc,
			IN peconv::ImpsNotCovered &notCovered,
			IN const ModulesInfo &modulesInfo,
			IN const peconv::ExportsMapper *exportsMap);

		IATScanReport(HMODULE _module, size_t _moduleSize, std::string _moduleFile)
			: ModuleScanReport(_module, _moduleSize, SCAN_SUSPICIOUS)
		{
			moduleFile = _moduleFile;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			size_t hooks = countHooked();
			OUT_PADDED(outs, level, "\"iat_scan\" : ");
			outs << "{\n";
			ModuleScanReport::_toJSON(outs, level + 1);
			outs << ",\n";
			OUT_PADDED(outs, level + 1, "\"hooks\" : ");
			outs << std::dec << hooks;
			if (jdetails >= JSON_DETAILS && hooks) {
				outs << ",\n";
				this->hooksToJSON(outs, level + 1);
			}
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		bool generateList(IN const std::string &fileName, IN HANDLE hProcess, IN const ModulesInfo &modulesInfo, IN const peconv::ExportsMapper *exportsMap);

		const bool hooksToJSON(std::stringstream &outs, size_t level);
		size_t countHooked() { return notCovered.count(); }

		peconv::ImportsCollection storedFunc;
		peconv::ImpsNotCovered notCovered;

	protected:
		static std::string formatHookedFuncName(IN peconv::ImportsCollection* storedFunc, DWORD thunk_rva);
		static std::string formatTargetName(IN const peconv::ExportsMapper* exportsMap, IN const ModulesInfo& modulesInfo, IN const ULONGLONG module_start, IN ULONGLONG addr);
	};

	//---

	//!  A scanner for detection of IAT hooking.
	class IATScanner : public ModuleScanner {
	public:

		IATScanner::IATScanner(
			HANDLE hProc,
			ModuleData &moduleData,
			RemoteModuleData &remoteModData,
			const peconv::ExportsMapper &_exportsMap,
			IN const ModulesInfo &_modulesInfo,
			t_iat_scan_mode _hooksFilter
		)
			: ModuleScanner(hProc, moduleData, remoteModData),
			exportsMap(_exportsMap), modulesInfo(_modulesInfo),
			hooksFilter(_hooksFilter)
		{
			initExcludedPaths();
		}

		virtual IATScanReport* scanRemote();

	private:
		bool scanByOriginalTable(peconv::ImpsNotCovered &not_covered);
		bool isValidFuncFilled(ULONGLONG filled_val, const peconv::ExportedFunc &definedFunc, const peconv::ExportedFunc& possibleFunc);

		void initExcludedPaths();
		bool isInSystemDir(const std::string &moduleName);

		bool filterResults(peconv::ImpsNotCovered &not_covered, IATScanReport &report);

		//! get addresses of the thunks from the original module (file)
		bool listAllImports(peconv::ImportsCollection &collection);

		const peconv::ExportsMapper &exportsMap;
		const ModulesInfo &modulesInfo;

		t_iat_scan_mode hooksFilter;
		
		//excluded paths:
		std::string m_sysWow64Path_str;
		std::string m_system32Path_str;
	};

}; //namespace pesieve


```

`scanners/mapping_scanner.cpp`:

```cpp
#include "mapping_scanner.h"

#include "../utils/path_converter.h"

using namespace pesieve;
using namespace pesieve::util;

MappingScanReport* pesieve::MappingScanner::scanRemote()
{
	MappingScanReport *my_report = new MappingScanReport(moduleData.moduleHandle, moduleData.original_size);

	std::string mapped_name = RemoteModuleData::getMappedName(processHandle, moduleData.moduleHandle);
	std::string module_name = moduleData.szModName;
	bool is_same = (to_lowercase(mapped_name) == to_lowercase(module_name));
	
	my_report->mappedFile = mapped_name;
	my_report->moduleFile = module_name;
	my_report->isDotNetModule = moduleData.isDotNet();

	size_t mod_name_len = module_name.length();
	if (!is_same && mod_name_len > 0) {
		//check Wow64
		char path_copy[MAX_PATH] = { 0 };
		memcpy(path_copy, moduleData.szModName, mod_name_len);
		convert_to_wow64_path(path_copy);
		is_same = (to_lowercase(mapped_name) == to_lowercase(path_copy));
		if (is_same) {
			moduleData.switchToWow64Path();
		}
	}
	if (!is_same) {
		my_report->status = SCAN_SUSPICIOUS;
		return my_report;
	}
	my_report->status = SCAN_NOT_SUSPICIOUS;
	return my_report;
}

```

`scanners/mapping_scanner.h`:

```h

#pragma once

#include <windows.h>

#include "module_scanner.h"
#include "../utils/path_util.h"
#include "process_feature_scanner.h"

namespace pesieve {

	class MappingScanReport : public ModuleScanReport
	{
	public:
		MappingScanReport(HMODULE _module, size_t _moduleSize)
			: ModuleScanReport(_module, _moduleSize)
		{
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"module\" : ");
			outs << "\"" << std::hex << (ULONGLONG)module << "\"" << ",\n";

			OUT_PADDED(outs, level, "\"module_file\" : \"" << pesieve::util::escape_path_separators(this->moduleFile) << "\"");
			outs << ",\n";
			OUT_PADDED(outs, level, "\"mapped_file\" : \"" << pesieve::util::escape_path_separators(this->mappedFile) << "\"");

			outs << ",\n";
			OUT_PADDED(outs, level, "\"status\" : ");
			outs << std::dec << status;
		}

		const virtual bool toJSON(std::stringstream& outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"mapping_scan\" : ");
			outs << "{\n";
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		std::string mappedFile;
	};


	//!  A scanner for detection of inconsistencies in mapping. Checks if the mapped file name is different than the module file name.
	class MappingScanner : public ProcessFeatureScanner {
	public:
		MappingScanner(HANDLE hProc, ModuleData &moduleData)
			: ProcessFeatureScanner(hProc), moduleData(moduleData)
		{
		}

		virtual MappingScanReport* scanRemote();

		ModuleData &moduleData;
	};

}; //namespace pesieve

```

`scanners/mempage_data.cpp`:

```cpp
#include "mempage_data.h"
#include "module_data.h"

using namespace pesieve;

bool pesieve::MemPageData::fillInfo()
{
	MEMORY_BASIC_INFORMATION page_info = { 0 };
	SIZE_T out = VirtualQueryEx(this->processHandle, (LPCVOID) start_va, &page_info, sizeof(page_info));
	if (out != sizeof(page_info)) {
		if (GetLastError() == ERROR_INVALID_PARAMETER) {
			return false;
		}
#ifdef _DEBUG
		std::cout << "Could not query page: " << std::hex << start_va << ". Error: " << GetLastError() << std::endl;
#endif
		return false;
	}
	initial_protect = page_info.AllocationProtect;
	mapping_type = page_info.Type;
	protection = page_info.Protect;
	alloc_base = (ULONGLONG) page_info.AllocationBase;
	region_start = (ULONGLONG) page_info.BaseAddress;
	region_end = region_start + page_info.RegionSize;
	is_info_filled = true;
	return true;
}

bool pesieve::MemPageData::loadModuleName()
{
	const HMODULE mod_base = (HMODULE)this->alloc_base;
	std::string module_name = RemoteModuleData::getModuleName(processHandle, mod_base);
	if (module_name.length() == 0) {
#ifdef _DEBUG
		std::cerr << "Could not retrieve module name" << std::endl;
#endif
		return false;
	}
	this->module_name = module_name;
	return true;
}

bool pesieve::MemPageData::loadMappedName()
{
	if (!isInfoFilled() && !fillInfo()) {
		return false;
	}
	std::string mapped_filename = RemoteModuleData::getMappedName(this->processHandle, (HMODULE)this->alloc_base);
	if (mapped_filename.length() == 0) {
#ifdef _DEBUG
		std::cerr << "Could not retrieve name" << std::endl;
#endif
		return false;
	}
	this->mapped_name = mapped_filename;
	return true;
}

bool pesieve::MemPageData::isRealMapping()
{
	if (this->loadedData == nullptr && !fillInfo()) {
#ifdef _DEBUG
		std::cerr << "Not loaded!" << std::endl;
#endif
		return false;
	}
	if (!loadMappedName()) {
#ifdef _DEBUG
		std::cerr << "Could not retrieve name" << std::endl;
#endif
		return false;
	}
	HANDLE file = CreateFileA(this->mapped_name.c_str(), GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if(file == INVALID_HANDLE_VALUE) {
#ifdef _DEBUG
		std::cerr << "Could not open file!" << std::endl;
#endif
		return false;
	}
	HANDLE mapping = CreateFileMapping(file, 0, PAGE_READONLY, 0, 0, 0);
	if (!mapping) {
#ifdef _DEBUG
		std::cerr << "Could not create mapping!" << std::endl;
#endif
		CloseHandle(file);
		return false;
	}
	BYTE *rawData = (BYTE*) MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
	if (rawData == nullptr) {
#ifdef _DEBUG
		std::cerr << "Could not map view of file" << std::endl;
#endif
		CloseHandle(mapping);
		CloseHandle(file);
		return false;
	}

	bool is_same = false;
	size_t r_size = GetFileSize(file, 0);
	size_t smaller_size = this->loadedSize > r_size ? r_size : this->loadedSize;
	if (memcmp(this->loadedData, rawData, smaller_size) == 0) {
		is_same = true;
	}
	UnmapViewOfFile(rawData);
	CloseHandle(mapping);
	CloseHandle(file);
	return is_same;
}

bool pesieve::MemPageData::_loadRemote()
{
	_freeRemote();
	size_t region_size = size_t(this->region_end - this->start_va);
	if (stop_va && ( stop_va >= start_va  && stop_va < this->region_end)) {
		region_size = size_t(this->stop_va - this->start_va);
	}
	
	if (region_size == 0) {
		return false;
	}
	loadedData = peconv::alloc_aligned(region_size, PAGE_READWRITE);
	if (loadedData == nullptr) {
		return false;
	}
	this->loadedSize = region_size;
	const bool can_force_access = is_process_refl ? true : false;
	const size_t size_read = peconv::read_remote_region(this->processHandle, (BYTE*)this->start_va, loadedData, loadedSize, can_force_access);
	if (size_read == 0) {
		_freeRemote();
#ifdef _DEBUG
		std::cerr << "Cannot read remote memory!" << std::endl;
#endif
		return false;
	}
	return true;
}


```

`scanners/mempage_data.h`:

```h
#pragma once

#include <windows.h>

#include <peconv.h>

namespace pesieve {

	class MemPageData
	{
	public:
		MemPageData(HANDLE _process, bool _is_process_refl, ULONGLONG _start_va, ULONGLONG _stop_va)
			: processHandle(_process), start_va(_start_va), stop_va(_stop_va),
			is_listed_module(false),
			is_info_filled(false), loadedData(nullptr), loadedSize(0),
			is_dep_enabled(false), is_process_refl(_is_process_refl)
		{
			fillInfo();
		}

		virtual ~MemPageData()
		{
			_freeRemote();
		}
		bool isRefl() const { return is_process_refl; }
		bool fillInfo();
		bool isInfoFilled() { return is_info_filled; }
		size_t getLoadedSize() { return loadedSize; }
		const PBYTE getLoadedData() { return loadedData; }

		bool validatePtr(const LPVOID field_bgn, size_t field_size)
		{
			return peconv::validate_ptr(this->loadedData, this->loadedSize, field_bgn, field_size);
		}

		ULONGLONG start_va; ///< VA that was requested. May not be beginning of the region.
		ULONGLONG stop_va; ///< the VA at which the read will stop
		DWORD protection; ///< page protection
		DWORD initial_protect;
		bool is_private;
		DWORD mapping_type;
		bool is_listed_module;
		bool is_dep_enabled;


		ULONGLONG alloc_base;
		ULONGLONG region_start;
		ULONGLONG region_end;

		std::string mapped_name; ///< if the region is mapped from a file, stores its file name
		std::string module_name; ///< if the region is on the list of loaded PEs, stores its module name

		bool load()
		{
			if (loadedData) {
				return true;
			}
			if (!_loadRemote()) {
				return false;
			}
			//check again:
			if (loadedData) {
				return true;
			}
			return false;
		}

		bool loadMappedName();
		bool loadModuleName();
		// checks if the memory area is mapped 1-to-1 from the file on the disk
		bool isRealMapping();

	protected:
		bool _loadRemote();

		void _freeRemote()
		{
			if (!loadedData) {
				loadedSize = 0;
				return;
			}
			peconv::free_aligned(loadedData, loadedSize);
			loadedData = nullptr;
			loadedSize = 0;
		}

		PBYTE loadedData;
		size_t loadedSize;

		bool is_info_filled;
		const bool is_process_refl;
		HANDLE processHandle;
	};

}; //namespace pesieve


```

`scanners/module_cache.cpp`:

```cpp
#include "module_cache.h"

BYTE* pesieve::ModulesCache::loadCached(LPSTR szModName, size_t& module_size)
{
	BYTE *mapped_pe = getMappedCached(szModName, module_size);
	if (mapped_pe) {
		return mapped_pe; // retrieved from cache
	}
	size_t raw_size = 0;
	BYTE* raw_buf = peconv::load_file(szModName, raw_size);
	if (!raw_buf) {
		return nullptr; // failed to load the file
	}

	bool force_free_cache = false;
	// Add to cache if needed...
	{
		util::MutexLocker guard(cacheMutex);
		size_t currCntr = usageBeforeCounter[szModName]++;
		const size_t cachedModulesCntr = cachedModules.size();
		const bool is_cache_available = cachedModulesCntr < MaxCachedModules;
		if (raw_buf && currCntr >= MinUsageCntr && is_cache_available) {
			bool is_cached = false;
			CachedModule* mod_cache = new(std::nothrow) CachedModule(raw_buf, raw_size);
			if (mod_cache) {
				if (mod_cache->moduleData) {
					cachedModules[szModName] = mod_cache;
					is_cached = true;
#ifdef _DEBUG
					std::cout << "Added to cache: " << szModName << " Total cached: " << cachedModulesCntr << "\n";
#endif
				}
			}
			if (!is_cached) {
				delete mod_cache;
				// possibly running out of memory, make sure to free some cache:
				force_free_cache = true;
			}
		}
	}

	// after adding file to the cache, wipe out the old ones:
	prepareCacheSpace(force_free_cache);

	// return the mapped module:
	mapped_pe = peconv::load_pe_module(raw_buf, raw_size, module_size, false, false);
	peconv::free_file(raw_buf);
	return mapped_pe;
}

```

`scanners/module_cache.h`:

```h
#pragma once

#include <peconv.h>
#include <string>
#include <map>

namespace pesieve
{
	namespace util {
		struct Mutex {
		public:
			Mutex()
			{
				InitializeCriticalSection(&cs);
			}

			void Lock()
			{
				EnterCriticalSection(&cs);
			}

			void Unlock()
			{
				LeaveCriticalSection(&cs);
			}

			~Mutex()
			{
				DeleteCriticalSection(&cs);
			}

		private:
			CRITICAL_SECTION cs;
		};

		struct MutexLocker
		{
		public:
			MutexLocker(Mutex& _mutex)
				: mutex(_mutex)
			{
				mutex.Lock();
			}

			~MutexLocker()
			{
				mutex.Unlock();
			}

		private:
			Mutex& mutex;
		};
	};

	struct CachedModule {
	public:
		CachedModule() 
			: moduleData(nullptr), moduleSize(0), lastUsage(0)
		{
		}

		CachedModule(BYTE* _moduleData, size_t _moduleSize)
			: moduleData(nullptr), moduleSize(0), lastUsage(0)
		{
			moduleData = peconv::alloc_unaligned(_moduleSize);
			if (!moduleData) return;

			memcpy(moduleData, _moduleData, _moduleSize);
			moduleSize = _moduleSize;
			lastUsage = GetTickCount64();
		}

		BYTE* mapFromCached(size_t &mappedSize) const
		{
			if (!this->moduleData || !this->moduleSize) return nullptr;

			BYTE* my_pe = peconv::load_pe_module(moduleData, moduleSize, mappedSize, false, false);
			return my_pe;
		}

		~CachedModule()
		{
#ifdef _DEBUG
			std::cout << "Deleting cached module...\n";
#endif
			peconv::free_unaligned(moduleData);
			moduleData = nullptr;
			moduleSize = 0;
		}
		
		BYTE* moduleData;
		size_t moduleSize;
		ULONGLONG lastUsage;
	};


	class ModulesCache {

	public:
		
		static const size_t MinUsageCntr = 2; ///< how many times loading of the module must be requested before the module is added to cache
		static const size_t MaxCachedModules = 255; ///< how many modules can be stored in the cache at the time

		ModulesCache()
		{
#ifdef _DEBUG
			std::cout << "Cache initialized\n";
#endif
		}

		~ModulesCache()
		{
			deleteCache();
		}

		BYTE* loadCached(LPSTR szModName, size_t& original_size);

	protected:
		BYTE* getMappedCached(const std::string &modName, size_t& mappedSize)
		{
			util::MutexLocker guard(cacheMutex);

			std::map<std::string, CachedModule*>::iterator itr = cachedModules.find(modName);
			if (itr != cachedModules.end()) {
				CachedModule* cached = itr->second;
				if (!cached) return nullptr;
				
				cached->lastUsage = GetTickCount64();
				return cached->mapFromCached(mappedSize);
			}
			return nullptr;
		}

		bool prepareCacheSpace(bool force_free = false)
		{
			util::MutexLocker guard(cacheMutex);
			const bool is_cache_available = cachedModules.size() < MaxCachedModules;
			if (is_cache_available && !force_free) {
				return true;
			}
			return _deleteLeastRecent();
		}

		bool _deleteLeastRecent()
		{
			ULONGLONG lTimestamp = 0;
			ULONGLONG gTimestamp = 0;
			std::map<std::string, CachedModule*>::iterator foundItr = cachedModules.end();

			std::map<std::string, CachedModule*>::iterator itr;
			for (itr = cachedModules.begin(); itr != cachedModules.end(); ++itr) {
				CachedModule* mod = itr->second;
				if (!mod) continue;

				if ((lTimestamp == 0) || (mod->lastUsage < lTimestamp)) {
					lTimestamp = mod->lastUsage;
					foundItr = itr;
				}

				if ((gTimestamp == 0) || (mod->lastUsage > gTimestamp)) {
					gTimestamp = mod->lastUsage;
				}
			}

			if ((gTimestamp == lTimestamp) || (foundItr == cachedModules.end())) {
				return false; // nothing to remove
			}
#ifdef _DEBUG
			std::cout << "Deleting the least recent module: " << foundItr->first << " timestamp: " << lTimestamp << "\n";
#endif
			// remove the module that was used the least recently:
			usageBeforeCounter[foundItr->first] = 0;
			CachedModule* mod1 = foundItr->second;
			delete mod1;
			cachedModules.erase(foundItr);
			return true;
		}

		void deleteCache()
		{
			util::MutexLocker guard(cacheMutex);

			std::map<std::string, CachedModule*>::iterator itr;
#ifdef _DEBUG
			size_t i = 0;
#endif
			for (itr = cachedModules.begin(); itr != cachedModules.end(); ++itr) {
#ifdef _DEBUG
				std::cout << "[" << i++ << "] Deleting cached module: " << itr->first << "\n";
#endif
				CachedModule* cached = itr->second;
				delete cached;
			}
			cachedModules.clear();
			usageBeforeCounter.clear();
#ifdef _DEBUG
			std::cout << "Cache deleted. Total: " << i << " modules.\n";
#endif
		}

		std::map<std::string, size_t> usageBeforeCounter; ///< how many times loading of the same module was requested before it was cached

		std::map<std::string, CachedModule*> cachedModules; ///< the list of all the cached modules

		util::Mutex cacheMutex;
	};

};

```

`scanners/module_data.cpp`:

```cpp
#include "module_data.h"

#include "../utils/format_util.h"
#include "../utils/path_converter.h"
#include "../utils/process_util.h"
#include "../utils/artefacts_util.h"
#include "artefact_scanner.h"

#include <psapi.h>
#pragma comment(lib,"psapi.lib")

using namespace pesieve::util;

pesieve::ModulesCache cache;
//---
bool pesieve::ModuleData::loadModuleName()
{
	std::string my_name = pesieve::RemoteModuleData::getModuleName(processHandle, this->moduleHandle);
	if (my_name.length() == 0 || my_name.length() > MAX_PATH) {
		//invalid length
		return false;
	}
	memcpy(this->szModName, my_name.c_str(), my_name.length());

	// autoswitch the path to Wow64 mode if needed:
	autoswichIfWow64Mapping();
	return true;
}

bool pesieve::ModuleData::loadOriginal()
{
	//disable FS redirection by default
	bool is_ok = _loadOriginal(true);
	if (!is_ok) {
		//if loading with FS redirection has failed, try without
		is_ok = _loadOriginal(false);
	}
	return is_ok;
}

bool pesieve::ModuleData::_loadOriginal(bool disableFSredir)
{
	if (strlen(this->szModName) == 0) {
		loadModuleName();
	}
	//just in case if something was loaded before...
	peconv::free_pe_buffer(original_module, original_size);

	BOOL isRedirDisabled = FALSE;
	PVOID old_val;
	if (disableFSredir) {
		isRedirDisabled = wow64_disable_fs_redirection(&old_val);
		// try to load with FS redirection disabled
	}
	if (this->useCache) {
		original_module = cache.loadCached(szModName, original_size);
	}
	else {
		original_module = peconv::load_pe_module(szModName, original_size, false, false);
	}

	if (isRedirDisabled) {
		wow64_revert_fs_redirection(old_val);
	}
	if (!original_module) {
		return false;
	}
	this->is_dot_net = isDotNetManagedCode();
	return true;
}


bool pesieve::ModuleData::loadRelocatedFields(std::set<DWORD>& fields_rvas)
{
	if (!original_module || !original_size) {
		return false;
	}
	//---
	class CollectRelocField : public peconv::RelocBlockCallback
	{
	public:
		CollectRelocField(ModuleData &_mod, std::set<DWORD>& _fields)
			: RelocBlockCallback(_mod.is64bit()), mod(_mod), fields(_fields)
		{
		}

		virtual bool processRelocField(ULONG_PTR relocField)
		{
			DWORD reloc_rva = mod.vaToRva(relocField, (ULONG_PTR)mod.original_module);
			fields.insert(reloc_rva);
			return true;
		}

		std::set<DWORD> &fields;
		ModuleData &mod;
	};
	//---
	if (!peconv::has_valid_relocation_table(original_module, original_size)) {
		// No reloc table
		return false;
	}
	CollectRelocField collector(*this, fields_rvas);
	if (!peconv::process_relocation_table(original_module, original_size, &collector)) {
		// Could not collect relocations
		return false;
	}
	if (fields_rvas.size()) {
		return true;
	}
	return false;
}

bool pesieve::ModuleData::loadImportThunks(std::set<DWORD>& thunk_rvas)
{
	if (!original_module || !original_size) {
		return false;
	}
	if (!peconv::has_valid_import_table(original_module, original_size)) {
		// No import table
		return false;
	}
	if (!peconv::collect_thunks(original_module, original_size, thunk_rvas)) {
		// Could not collect thunks
		return false;
	}
	if (thunk_rvas.size()) {
		return true;
	}
	return false;
}

bool pesieve::ModuleData::loadImportsList(peconv::ImportsCollection &collection)
{
	if (!original_module || !original_size) {
		return false;
	}
	if (!peconv::has_valid_import_table(original_module, original_size)) {
		// No import table
		return false;
	}
	if (!peconv::collect_imports(original_module, original_size, collection)) {
		// Could not collect imports
		return false;
	}
	return true;
}

bool pesieve::ModuleData::relocateToBase(ULONGLONG new_base)
{
	if (!original_module) return false;

	ULONGLONG original_base = peconv::get_image_base(original_module);
	if (original_base == new_base) {
		return true; // already relocated
	}
	if (peconv::has_relocations(original_module) 
		&& !peconv::relocate_module(original_module, original_size, new_base, original_base))
	{
#ifdef _DEBUG
		std::cerr << "[!] Relocating module failed!" << std::endl;
#endif
		return false;
	}
	peconv::update_image_base(original_module, new_base);
	return true;
}


bool pesieve::ModuleData::autoswichIfWow64Mapping()
{
	std::string mapped_name = pesieve::RemoteModuleData::getMappedName(processHandle, this->moduleHandle);
	std::string module_name = this->szModName;
	bool is_same = (to_lowercase(mapped_name) == to_lowercase(module_name));

	size_t mod_name_len = module_name.length();
	if (!is_same && mod_name_len > 0) {
		//check Wow64
		char path_copy[MAX_PATH] = { 0 };
		memcpy(path_copy, this->szModName, mod_name_len);
		convert_to_wow64_path(path_copy);
		is_same = (to_lowercase(mapped_name) == to_lowercase(path_copy));
		if (is_same) {
			this->switchToWow64Path();
			return true;
		}
	}
	return false;
}

bool pesieve::ModuleData::switchToWow64Path()
{
	BOOL isWow64 = FALSE;
	if (!is_process_wow64(this->processHandle, &isWow64)) {
		//failed to retrieve the info...
		return false;
	}
	if (isWow64) {
		if (pesieve::util::convert_to_wow64_path(szModName)) return true;
	}
	return false;
}

bool pesieve::ModuleData::reloadWow64()
{
	if (!switchToWow64Path()) return false;

	//reload it and check again...
	peconv::free_pe_buffer(original_module, original_size);
	if (this->useCache) {
		original_module = cache.loadCached(szModName, original_size);
	}
	else {
		original_module = peconv::load_pe_module(szModName, original_size, false, false);
	}
	if (!original_module) {
		std::cout << "[-] Failed to reload: " << szModName << "\n";
		return false;
	}
	std::cout << "[+] Reloaded: " << szModName << "\n";
	return true;
}

bool pesieve::ModuleData::isDotNetManagedCode()
{
	//has a directory entry for .NET header
	IMAGE_DATA_DIRECTORY* dotNetDir = peconv::get_directory_entry(this->original_module, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR);
	if (dotNetDir == nullptr) {
		//does not have .NET directory
		return false;
	}
	
	if (!peconv::get_dotnet_hdr(this->original_module, this->original_size, dotNetDir)){
		return false;
	}
#ifdef _DEBUG
	std::cout << "This is a .NET module" << std::endl;
#endif
	return true;
}

//----

std::string pesieve::RemoteModuleData::getModuleName(HANDLE processHandle, HMODULE modBaseAddr)
{
	char filename[MAX_PATH] = { 0 };
	if (!GetModuleFileNameExA(processHandle, modBaseAddr, filename, MAX_PATH)) {
		return "";
	}
	std::string basic_filename = pesieve::util::convert_to_win32_path(filename);
	std::string expanded = pesieve::util::expand_path(basic_filename);
	if (expanded.length() == 0) {
		return filename;
	}
	return expanded;
}

std::string pesieve::RemoteModuleData::getMappedName(HANDLE processHandle, LPVOID modBaseAddr)
{
	char filename[MAX_PATH] = { 0 };
	if (!GetMappedFileNameA(processHandle, modBaseAddr, filename, MAX_PATH) != 0) {
		return "";
	}
	std::string expanded = pesieve::util::expand_path(filename);
	if (expanded.length() == 0) {
		return filename;
	}
	return expanded;
}

bool pesieve::RemoteModuleData::loadImportsList(peconv::ImportsCollection& collection)
{
	if (!isFullImageLoaded()) {
		return false;
	}
	if (!peconv::has_valid_import_table(imgBuffer, imgBufferSize)) {
		// No import table
		return false;
	}
	if (!peconv::collect_imports(imgBuffer, imgBufferSize, collection)) {
		// Could not collect imports
		return false;
	}
	return true;
}

bool pesieve::RemoteModuleData::init()
{
	this->isHdrReady = false;
	if (!loadHeader()) {
		return false;
	}
	this->isHdrReady = true;
	return true;
}

bool pesieve::RemoteModuleData::_loadFullImage(size_t mod_size)
{
	if (this->isFullImageLoaded()) {
		return true;
	}
	this->imgBuffer = peconv::alloc_pe_buffer(mod_size, PAGE_READWRITE);
	this->imgBufferSize = peconv::read_remote_pe(this->processHandle, (PBYTE)this->modBaseAddr, mod_size, this->imgBuffer, mod_size);
	if (this->imgBufferSize == mod_size) {
		return true;
	}
	this->freeFullImage();
	return false;
}

bool pesieve::RemoteModuleData::loadFullImage()
{
	if (this->isFullImageLoaded()) {
		return true;
	}
	size_t mod_size = this->getHdrImageSize();
	if (_loadFullImage(mod_size)) {
		return true;
	}
	//try again with calculated size:
	mod_size = calcImgSize();
	return _loadFullImage(mod_size);
}

bool pesieve::RemoteModuleData::loadHeader()
{
	if (!peconv::read_remote_pe_header(this->processHandle, (PBYTE)this->modBaseAddr, this->headerBuffer, peconv::MAX_HEADER_SIZE, this->isReflection)) {
		return false;
	}
	return true;
}

ULONGLONG pesieve::RemoteModuleData::getRemoteSectionVa(const size_t section_num)
{
	if (!this->isInitialized()) return NULL;

	PIMAGE_SECTION_HEADER section_hdr = peconv::get_section_hdr(headerBuffer, peconv::MAX_HEADER_SIZE, section_num);
	if ((section_hdr == NULL) || section_hdr->SizeOfRawData == 0) {
		return NULL;
	}
	return (ULONGLONG) modBaseAddr + section_hdr->VirtualAddress;
}

bool pesieve::RemoteModuleData::isSectionEntry(const size_t section_number)
{
	if (!this->isInitialized()) {
		return false;
	}
	const DWORD ep_va = peconv::get_entry_point_rva(this->headerBuffer);
	if (ep_va == 0) {
		return false;
	}
	PIMAGE_SECTION_HEADER sec_hdr = peconv::get_section_hdr(this->headerBuffer, peconv::MAX_HEADER_SIZE, section_number);
	if (!sec_hdr) {
		return false;
	}
	if (ep_va >= sec_hdr->VirtualAddress 
		&& ep_va < (sec_hdr->VirtualAddress + sec_hdr->Misc.VirtualSize))
	{
		return true;
	}
	return false;
}

bool pesieve::RemoteModuleData::isSectionExecutable(const size_t section_number, bool allow_data, bool allow_inaccessible)
{
	//for special cases when the section is not set executable in headers, but in reality is executable...
	//get the section header from the module:
	ULONGLONG start_va = getRemoteSectionVa(section_number);
	if (start_va == NULL) {
		return false;
	}
	MEMORY_BASIC_INFORMATION page_info = { 0 };
	
	SIZE_T out = VirtualQueryEx(processHandle, (LPCVOID) start_va, &page_info, sizeof(page_info));
	if (out != sizeof(page_info)) {
#ifdef _DEBUG
		std::cerr << "Cannot retrieve remote section info" << std::endl;
#endif
		return false;
	}
#ifdef _DEBUG
	std::cout << std::hex << "Sec: " << section_number << " VA: " << start_va << " t: " << page_info.Type << " p: " << page_info.Protect << std::endl;
#endif

	if (pesieve::util::is_executable(page_info.Type, page_info.Protect)) {
		//std::cout << std::hex << "p1 Sec: " << section_number << " VA: " << start_va << " t: " << page_info.Type << " p: " << page_info.Protect << std::endl;
		return true;
	}
	if (allow_data) {
		if (pesieve::util::is_readable(page_info.Type, page_info.Protect)) {
			//std::cout << std::hex << "p1 Sec: " << section_number << " VA: " << start_va << " t: " << page_info.Type << " p: " << page_info.Protect << std::endl;
			return true;
		}
	}
	if (allow_inaccessible) {
		if (pesieve::util::is_normal_inaccessible(page_info.State, page_info.Type, page_info.Protect)) {
			//std::cout << "[" << section_number << "] Inaccessible section found!\n";
			return true;
		}
	}
	return false;
}

bool pesieve::RemoteModuleData::hasExecutableSection(bool allow_data, bool allow_inaccessible)
{
	size_t sec_count = peconv::get_sections_count(this->headerBuffer, peconv::MAX_HEADER_SIZE);
	for (size_t i = 0; i < sec_count ; i++) {
		if (isSectionExecutable(i, allow_data, allow_inaccessible)) {
			return true;
		}
	}
	return false;
}

//calculate image size basing on the sizes of sections
size_t pesieve::RemoteModuleData::calcImgSize()
{
	if (!isHdrReady) return 0;

	return ArtefactScanner::calcImgSize(this->processHandle, this->modBaseAddr, this->headerBuffer, peconv::MAX_HEADER_SIZE);
}

```

`scanners/module_data.h`:

```h
#pragma once

#include <windows.h>
#include <psapi.h>
#include <map>
#include <set>

#include <peconv.h>
#include "../utils/format_util.h"
#include "module_cache.h"

namespace pesieve {

	//! Loads a module from the disk, corresponding to the module in the scanned process' memory.
	class ModuleData {

	public:
		ModuleData(HANDLE _processHandle, HMODULE _module, bool _isPEBConnected, bool _useCache)
			: processHandle(_processHandle), moduleHandle(_module),
			isPEBConnected(_isPEBConnected), useCache(_useCache),
			is_module_named(false), original_size(0), original_module(nullptr),
			is_dot_net(false)
		{
			memset(szModName, 0, MAX_PATH);
			loadModuleName();
		}

		ModuleData(HANDLE _processHandle, HMODULE _module, std::string module_name, bool _useCache)
			: processHandle(_processHandle), moduleHandle(_module), useCache(_useCache),
			is_module_named(false), original_size(0), original_module(nullptr),
			is_dot_net(false)
		{
			memset(szModName, 0, MAX_PATH);
			memcpy(this->szModName, module_name.c_str(), module_name.length());
		}

		~ModuleData()
		{
			peconv::free_pe_buffer(original_module, original_size);
		}

		bool is64bit()
		{
			if (original_module == nullptr) {
				return false;
			}
			return peconv::is64bit(original_module);
		}

		bool isDotNet() { return this->is_dot_net; }

		ULONGLONG rvaToVa(DWORD rva, ULONGLONG module_base = 0)
		{
			if (module_base == 0) {
				module_base = reinterpret_cast<ULONGLONG>(this->moduleHandle);
			}
			return module_base + rva;
		}

		DWORD vaToRva(ULONGLONG va, ULONGLONG module_base = 0)
		{
			if (module_base == 0) {
				module_base = reinterpret_cast<ULONGLONG>(this->moduleHandle);
			}
			if (va < module_base) {
				return 0; // not this module
			}
			if (va > module_base + this->original_size) {
				return 0; // not this module
			}
			ULONGLONG diff = (va - module_base);
			return static_cast<DWORD>(diff);
		}

		bool isModuleInPEBList()
		{
			return isPEBConnected;
		}

		bool isInitialized()
		{
			return original_module != nullptr;
		}

		ULONGLONG getHdrImageBase()
		{
			if (!original_module) return 0;
			return peconv::get_image_base((const BYTE*)original_module);
		}

		bool loadOriginal();

		bool switchToWow64Path();
		bool reloadWow64();
		bool relocateToBase(ULONGLONG new_base);
		bool loadRelocatedFields(std::set<DWORD>& fields_rvas);
		bool loadImportThunks(std::set<DWORD>& fields_rvas);
		bool loadImportsList(peconv::ImportsCollection &collection);

		HANDLE processHandle;
		HMODULE moduleHandle;
		char szModName[MAX_PATH];
		bool is_module_named;

		PBYTE original_module;
		size_t original_size;

	protected:
		bool _loadOriginal(bool disableFSredir);
		bool loadModuleName();
		bool autoswichIfWow64Mapping();
		bool isDotNetManagedCode();

		bool is_dot_net;
		bool isPEBConnected;
		bool useCache;

		friend class PeSection;
	};

	//! Buffers the data from the module loaded in the scanned process into the local memory.
	class RemoteModuleData
	{
	public:
		static std::string getModuleName(HANDLE _processHandle, HMODULE _modBaseAddr);
		static std::string getMappedName(HANDLE _processHandle, LPVOID _modBaseAddr);

		RemoteModuleData(HANDLE _processHandle, bool _isRefl, HMODULE _modBaseAddr)
			: processHandle(_processHandle), isReflection(_isRefl), modBaseAddr(_modBaseAddr),
			imgBuffer(nullptr), imgBufferSize(0)
		{
			isHdrReady = false;
			memset(headerBuffer, 0, peconv::MAX_HEADER_SIZE);
			init();
		}

		virtual ~RemoteModuleData()
		{
			freeFullImage();
		}

		bool isSectionEntry(const size_t section_number);
		bool isSectionExecutable(const size_t section_number, bool allow_data, bool allow_inaccessible);
		bool hasExecutableSection(bool allow_data, bool allow_inaccessible);
		bool isInitialized()
		{
			if (!isHdrReady && !init()) {
				return false;
			}
			return true;
		}

		bool is64bit()
		{
			if (!isHdrReady) return false;
			return peconv::is64bit(headerBuffer);
		}

		size_t getHdrImageSize()
		{
			if (!isHdrReady) return 0;
			return peconv::get_image_size((const BYTE*)headerBuffer);
		}

		ULONGLONG getHdrImageBase()
		{
			if (!isHdrReady) return 0;
			return peconv::get_image_base((const BYTE*)headerBuffer);
		}

		size_t getModuleSize()
		{
			if (imgBufferSize) {
				return imgBufferSize;
			}
			return getHdrImageSize();
		}

		size_t getHeaderSize()
		{
			return peconv::MAX_HEADER_SIZE;
		}

		bool loadFullImage();
		bool isFullImageLoaded() { return (imgBuffer != nullptr) && (imgBufferSize != 0); }
		ULONGLONG getRemoteSectionVa(const size_t section_num);
		bool loadImportsList(peconv::ImportsCollection& collection);

		ULONGLONG getModuleBase()
		{
			return (ULONGLONG)modBaseAddr;
		}

		BYTE headerBuffer[peconv::MAX_HEADER_SIZE];

	protected:
		bool init();
		bool loadHeader();
		size_t calcImgSize();

		bool _loadFullImage(size_t v_size);

		void freeFullImage()
		{
			peconv::free_pe_buffer(imgBuffer);
			imgBuffer = nullptr;
			imgBufferSize = 0;
		}

		HANDLE processHandle;
		const bool isReflection;
		HMODULE modBaseAddr;

		BYTE *imgBuffer;
		size_t imgBufferSize;

	private:
		bool isHdrReady;

		friend class PeSection;
		friend class IATScanner;
	};

}; //namespace pesieve


```

`scanners/module_scan_report.h`:

```h
#pragma once

#include <windows.h>

#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include <peconv.h>
#include "pe_sieve_types.h"

#include "../utils/path_util.h"
#include "../utils/format_util.h"

namespace pesieve {

	typedef enum module_scan_status {
		SCAN_ERROR = -1,
		SCAN_NOT_SUSPICIOUS = 0,
		SCAN_SUSPICIOUS = 1
	} t_scan_status;

	//!  A base class of all the reports detailing on the output of the performed module's scan.
	class ModuleScanReport
	{
	public:
		static const size_t JSON_LEVEL = 1;

		static t_scan_status get_scan_status(const ModuleScanReport *report)
		{
			if (report == nullptr) {
				return SCAN_ERROR;
			}
			return report->status;
		}

		ModuleScanReport(HMODULE _module, size_t _moduleSize, t_scan_status _status)
		{
			this->module = _module;
			this->moduleSize = _moduleSize;
			this->status = _status;
			this->isDotNetModule = false;
		}

		ModuleScanReport(HMODULE _module, size_t _moduleSize)
		{
			this->module = _module;
			this->moduleSize = _moduleSize;
			this->isDotNetModule = false;
			this->status = SCAN_NOT_SUSPICIOUS;
		}

		virtual ~ModuleScanReport() {}

		virtual ULONGLONG getRelocBase()
		{
			return (ULONGLONG)this->module;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level = JSON_LEVEL, const pesieve::t_json_level &jdetails = JSON_BASIC) = 0;

		HMODULE module;
		size_t moduleSize;
		bool isDotNetModule;
		std::string moduleFile;
		t_scan_status status;

	protected:
		const virtual bool _toJSON(std::stringstream& outs, size_t level = JSON_LEVEL, const pesieve::t_json_level& jdetails = JSON_BASIC)
		{
			OUT_PADDED(outs, level, "\"module\" : ");
			outs << "\"" << std::hex << (ULONGLONG)module << "\"" << ",\n";
			if (moduleSize){
				OUT_PADDED(outs, level, "\"module_size\" : ");
				outs << "\"" << std::hex << (ULONGLONG)moduleSize << "\"" << ",\n";
			}
			if (moduleFile.length()) {
				OUT_PADDED(outs, level, "\"module_file\" : ");
				outs << "\"" << pesieve::util::escape_path_separators(moduleFile) << "\"" << ",\n";
			}
			OUT_PADDED(outs, level, "\"status\" : ");
			outs << std::dec << status;
			if (isDotNetModule) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"is_dot_net\" : \"");
				outs << isDotNetModule << "\"";
			}
			return true;
		}

	};

	class UnreachableModuleReport : public ModuleScanReport
	{
	public:
		UnreachableModuleReport(HMODULE _module, size_t _moduleSize, std::string _moduleFile)
			: ModuleScanReport(_module, _moduleSize, SCAN_ERROR)
		{
			moduleFile = _moduleFile;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level = JSON_LEVEL, const pesieve::t_json_level &jdetails = JSON_BASIC)
		{
			OUT_PADDED(outs, level, "\"unreachable_scan\" : ");
			outs << "{\n";
			ModuleScanReport::_toJSON(outs, level + 1);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}
	};

	class SkippedModuleReport : public ModuleScanReport
	{
	public:
		SkippedModuleReport(HMODULE _module, size_t _moduleSize, std::string _moduleFile)
			: ModuleScanReport(_module, _moduleSize, SCAN_NOT_SUSPICIOUS)
		{
			moduleFile = _moduleFile;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level = JSON_LEVEL, const pesieve::t_json_level &jdetails = JSON_BASIC)
		{
			OUT_PADDED(outs, level, "\"skipped_scan\" : ");
			outs << "{\n";
			ModuleScanReport::_toJSON(outs, level + 1);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}
	};

	class MalformedHeaderReport : public ModuleScanReport
	{
	public:
		MalformedHeaderReport(HMODULE _module, size_t _moduleSize, std::string _moduleFile)
			: ModuleScanReport(_module, _moduleSize, SCAN_SUSPICIOUS)
		{
			moduleFile = _moduleFile;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level = JSON_LEVEL, const pesieve::t_json_level &jdetails = JSON_BASIC)
		{
			OUT_PADDED(outs, level, "\"malformed_header\" : ");
			outs << "{\n";
			ModuleScanReport::_toJSON(outs, level + 1);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}
	};

}; //namespace pesieve

```

`scanners/module_scanner.h`:

```h
#pragma once

#include <windows.h>
#include <psapi.h>
#include <map>

#include <peconv.h>
#include "module_scan_report.h"
#include "module_data.h"

#include "../utils/format_util.h"
#include "process_feature_scanner.h"

namespace pesieve {

	//!  A base class for all the scanners operating on module data.
	class ModuleScanner : public ProcessFeatureScanner {
	public:
		ModuleScanner(HANDLE _procHndl, ModuleData &_moduleData, RemoteModuleData &_remoteModData)
			: ProcessFeatureScanner(_procHndl),
			moduleData(_moduleData), remoteModData(_remoteModData)
		{
		}

		virtual ~ModuleScanner() {}

		virtual ModuleScanReport* scanRemote() = 0;

	protected:
		ModuleData &moduleData;
		RemoteModuleData &remoteModData;
	};

}; //namespace pesieve

```

`scanners/patch_analyzer.cpp`:

```cpp
#include "patch_analyzer.h"
//---
using namespace pesieve;

template <typename DELTA_T>
ULONGLONG pesieve::PatchAnalyzer::getJmpDestAddr(ULONGLONG currVA, int instrLen, DELTA_T lVal)
{
	int delta = instrLen + int(lVal);
	ULONGLONG addr = currVA + delta;
	return addr;
}

size_t pesieve::PatchAnalyzer::parseShortJmp(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va)
{
	const size_t instr_size = 2;
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, instr_size)) {
		return 0;
	}
	BYTE *lval = (BYTE*)((ULONGLONG)patch_ptr + 1);
	ULONGLONG addr = getJmpDestAddr<BYTE>(patch_va, instr_size, (*lval));

	patch.setHookTarget(addr);
	return instr_size;
}

size_t pesieve::PatchAnalyzer::parseJmp(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va)
{
	const size_t instr_size = 5;
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, instr_size)) {
		return 0;
	}
	DWORD *lval = (DWORD*)((ULONGLONG) patch_ptr + 1);
	ULONGLONG addr = getJmpDestAddr<DWORD>(patch_va, instr_size, (*lval));

	patch.setHookTarget(addr);
	return instr_size;
}

size_t pesieve::PatchAnalyzer::parseJmpViaAddr(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va)
{
	const size_t instr_size = 6;
	ULONGLONG addr = NULL;

	DWORD *lval = (DWORD*)((ULONGLONG)patch_ptr + 2);
	if (!isModule64bit) { //32bit
		patch.setHookTarget(*lval, false);
	}
	else { //64bit
		ULONGLONG addr = getJmpDestAddr<DWORD>(patch_va, instr_size, (*lval));
		patch.setHookTarget(addr, false);
	}
	return instr_size;
}

size_t pesieve::PatchAnalyzer::parseMovJmp(PatchList::Patch &patch, PBYTE patch_ptr, bool is_long)
{
	size_t mov_instr_len = is_long ? 9 : 5;
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, mov_instr_len + 2)) {
		return 0;
	}

	PBYTE jmp_ptr = patch_ptr + mov_instr_len; // next instruction
	if (is64Modifier(*patch_ptr)) {
		patch_ptr++;
		jmp_ptr++;
		mov_instr_len++; // add length of modifier
	}
	
	DWORD reg_id0 = patch_ptr[0] - 0xB8;

	// before call/jmp there can be also the modifier...
	if (is64Modifier(*jmp_ptr)) {
		jmp_ptr++;
		mov_instr_len++; // add length of modifier
	}
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, jmp_ptr, 2)) {
		return 0;
	}
	DWORD reg_id1 = 0;
	if (jmp_ptr[0] == 0xFF && jmp_ptr[1] >= 0xE0 && jmp_ptr[1] <= 0xEF ) { // jmp reg
		//jmp reg
		reg_id1 = jmp_ptr[1] - 0xE0;
	} else if (jmp_ptr[0] == 0xFF && jmp_ptr[1] >= 0xD0 && jmp_ptr[1] <= 0xDF ) { // call reg
		//jmp reg
		reg_id1 = jmp_ptr[1] - 0xD0;
	} else {
#ifdef _DEBUG
		std::cerr << "It is not MOV->JMP" << std::hex << (DWORD)jmp_ptr[0] << std::endl;
#endif
		return NULL;
	}
	//TODO: take into account also modifiers
	if (reg_id1 != reg_id0) {
#ifdef _DEBUG
		std::cerr << "MOV->JMP : reg mismatch" << std::endl;
#endif
		return NULL;
	}
	size_t patch_size = mov_instr_len;
	ULONGLONG addr = NULL;
	if (!is_long) { //32bit
		DWORD *lval = (DWORD*)((ULONGLONG) patch_ptr + 1);
		addr = *lval;
	} else { //64bit
		ULONGLONG *lval = (ULONGLONG*)((ULONGLONG) patch_ptr + 1);
		addr = *lval;
	}
	patch_size += 2; //add jump reg size
	patch.setHookTarget(addr);
#ifdef _DEBUG
	std::cout << "----> Target: " << std::hex << addr << std::endl;
#endif
	return patch_size;
}

size_t pesieve::PatchAnalyzer::parsePushRet(PatchList::Patch &patch, PBYTE patch_ptr)
{
	size_t instr_size = 5;
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, instr_size + 1)) {
		return 0;
	}
	PBYTE ret_ptr = patch_ptr + instr_size; // next instruction
	if (ret_ptr[0] != 0xC3) {
		return NULL; // this is not push->ret
	}
	instr_size++;
	DWORD *lval = (DWORD*)((ULONGLONG) patch_ptr + 1);
	patch.setHookTarget(*lval);
	return instr_size;
}

bool pesieve::PatchAnalyzer::is64Modifier(BYTE op)
{
	if (!isModule64bit) return false;
	if (op >= 0x40 && op <= 0x4F) { // modifier
		return true;
	}
	return false;
}

bool pesieve::PatchAnalyzer::isLongModifier(BYTE op)
{
	if (!isModule64bit) return false;
	if (op >= 0x48 && op <= 0x4F) { // modifier
		return true;
	}
	return false;
}

size_t pesieve::PatchAnalyzer::_analyze(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va)
{
	BYTE op = patch_ptr[0];
	if (op == OP_JMP || op == OP_CALL_DWORD) {
		return parseJmp(patch, patch_ptr, patch_va);
	}
	if (op == OP_SHORTJMP) {
		return parseShortJmp(patch, patch_ptr, patch_va);
	}
	if (op == OP_PUSH_DWORD) {
		return parsePushRet(patch, patch_ptr);
	}
	if (op == OP_JMP_VIA_ADDR_B1 && patch_ptr[1] == OP_JMP_VIA_ADDR_B2) {
		return parseJmpViaAddr(patch, patch_ptr, patch_va);
	}

	bool is_long = false;
	if (is64Modifier(op)) { // mov modifier
		if (isLongModifier(op)) {
			is_long = true;
		}
		op = patch_ptr[1];
	}

	if (op >= 0xB8 && op <= 0xBF) { // is mov
		return parseMovJmp(patch, patch_ptr, is_long);
	}
	return 0;
}

size_t pesieve::PatchAnalyzer::_analyzeRelocated(PatchList::Patch &patch, BYTE* patch_ptr)
{
	if (this->relocs.find(patch.startRva) == this->relocs.end()) {
		return 0;
	}
	// This patch is a relocated field
	const size_t fieldSize = (this->moduleData.is64bit()) ? sizeof(ULONGLONG) : sizeof(DWORD);
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, fieldSize)) {
		return 0;
	}
	ULONGLONG field = (this->moduleData.is64bit()) ? *((ULONGLONG*)patch_ptr) : *((DWORD*)patch_ptr);
	patch.setHookTarget(field, true, pesieve::HOOK_ADDR_REPLACEMENT);
	return fieldSize;
}

size_t pesieve::PatchAnalyzer::analyze(PatchList::Patch &patch)
{
	const ULONGLONG patch_va = moduleData.rvaToVa(patch.startRva);
	const size_t patch_offset = patch.startRva - sectionRVA;
	BYTE* patch_ptr = this->patchedCode + patch_offset;

	size_t size = _analyzeRelocated(patch, patch_ptr);
	if (size) {
		return size;
	}
	const size_t kMinSize = 3;
	if (!peconv::validate_ptr(this->patchedCode, this->codeSize, patch_ptr, kMinSize)) {
		return 0;
	}
	size = _analyze(patch, patch_ptr, patch_va);
	if (size == 0 && patch_offset > 0) {
		//it may happen that the address of an existing JMP/CALL was replaced
		//try to parse a byte before the patch...
		size = _analyze(patch, patch_ptr -1, patch_va - 1);
		if (size > 0) {
			// substract the added position:
			size--;
		}
	}
	return size;
}


```

`scanners/patch_analyzer.h`:

```h
#pragma once

#include "module_data.h"
#include "patch_list.h"

namespace pesieve {

	//! A postprocessor of the detected code patches. Detects if the patch is a hook, and if so, tries to indentify the address where it leads to.
	class PatchAnalyzer
	{
	public:
		typedef enum {
			OP_SHORTJMP = 0xEB,
			OP_JMP = 0xE9,
			OP_CALL_DWORD = 0xE8,
			OP_PUSH_DWORD = 0x68,
			OP_JMP_VIA_ADDR_B1 = 0xFF,
			OP_JMP_VIA_ADDR_B2 = 0x25
		} t_hook_opcode;

		PatchAnalyzer(ModuleData &_moduleData, DWORD _sectionRVA, PBYTE patched_code, size_t code_size)
			: moduleData(_moduleData), sectionRVA(_sectionRVA), patchedCode(patched_code), codeSize(code_size)
		{
			isModule64bit = moduleData.is64bit();
			moduleData.loadRelocatedFields(relocs);
		}

		size_t analyze(PatchList::Patch &patch);

	protected:
		size_t _analyze(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va);
		size_t _analyzeRelocated(PatchList::Patch &patch, BYTE* patch_ptr);

		size_t parseJmpViaAddr(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va);
		size_t parseShortJmp(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va);
		size_t parseJmp(PatchList::Patch &patch, PBYTE patch_ptr, ULONGLONG patch_va);
		size_t parseMovJmp(PatchList::Patch &patch, PBYTE patch_ptr, bool is_long);
		size_t parsePushRet(PatchList::Patch &patch, PBYTE patch_ptr);

		template <typename DELTA_T>
		ULONGLONG getJmpDestAddr(ULONGLONG currVA, int instrLen, DELTA_T lVal);

		bool is64Modifier(BYTE op);
		bool isLongModifier(BYTE op);

		bool isModule64bit;

		ModuleData &moduleData;
		DWORD sectionRVA;
		PBYTE patchedCode;
		size_t codeSize;

		std::set<DWORD> relocs;
	};

}; //namespace pesieve


```

`scanners/patch_list.cpp`:

```cpp
#include "patch_list.h"

#include <iostream>
#include <sstream>

#include "../utils/format_util.h"

std::string  pesieve::PatchList::Patch::getFormattedName()
{
	std::stringstream stream;

	if (this->hooked_func.length() > 0) {
		stream << hooked_func;
	} else {
		switch (this->type) {
		case pesieve::HOOK_INLINE:
			stream << "hook_"; break;
		case pesieve::HOOK_ADDR_REPLACEMENT:
			stream << "addr_replaced_"; break;
		default:
			stream << "patch_"; break;
		}
		stream << id;
	}
	if (this->type != pesieve::HOOK_NONE) {
		stream << "->";
		if (this->isDirect) {
			stream << std::hex << hookTargetVA;
		}
		else {
			stream << "via:" << std::hex << hookTargetVA;
		}
	}
	if (this->hookTargetModule) {
		ULONGLONG diff = hookTargetVA - hookTargetModule;
		stream << "[";
		stream << std::hex << hookTargetModule;
		stream << "+" << diff << ":";
		if (hookTargetModName.length() > 0) {
			stream << hookTargetModName;
		}
		else {
			stream << "(unnamed)";
		}
		stream << ":" << isTargetSuspicious;
		stream << "]";
	}
	return stream.str();
}

const bool pesieve::PatchList::Patch::toTAG(std::ofstream &patch_report, const char delimiter)
{
	if (patch_report.is_open()) {
		patch_report << std::hex << startRva;
		patch_report << delimiter;
		patch_report << getFormattedName();
		patch_report << delimiter;
		patch_report << (endRva - startRva);

		patch_report << std::endl;
	} else {
		std::cout << std::hex << startRva << std::endl;
	}
	return true;
}

const bool pesieve::PatchList::Patch::toJSON(std::stringstream &outs, size_t level, bool short_info)
{
	OUT_PADDED(outs, level, "{\n");

	OUT_PADDED(outs, (level + 1), "\"rva\" : ");
	outs << "\"" << std::hex << (ULONGLONG)startRva << "\"" << ",\n";

	OUT_PADDED(outs, (level + 1), "\"size\" : ");
	outs << std::dec << (ULONGLONG)(endRva - startRva);

	if (short_info) {
		outs << ",\n";
		OUT_PADDED(outs, (level + 1), "\"info\" : ");
		outs << "\"" << getFormattedName() << "\"";
	}
	else {
		outs << ",\n";
		const bool isHook = (this->type != pesieve::HOOK_NONE);
		OUT_PADDED(outs, (level + 1), "\"is_hook\" : ");
		outs << std::dec << isHook;

		if (this->hooked_func.length() > 0) {
			outs << ",\n";
			OUT_PADDED(outs, (level + 1), "\"func_name\" : ");
			outs << "\"" << hooked_func << "\"";
		}
		if (isHook) {
			outs << ",\n";
			OUT_PADDED(outs, (level + 1), "\"hook_target\" : {\n");
			if (hookTargetModName.length() > 0) {
				OUT_PADDED(outs, (level + 2), "\"module_name\" : ");
				outs << "\"" << hookTargetModName << "\"" << ",\n";
			}
			OUT_PADDED(outs, (level + 2), "\"module\" : ");
			outs << "\"" << std::hex << (ULONGLONG)hookTargetModule << "\"" << ",\n";
			OUT_PADDED(outs, (level + 2), "\"rva\" : ");
			outs << "\"" << std::hex << (ULONGLONG)(hookTargetVA - hookTargetModule) << "\"" << ",\n";
			OUT_PADDED(outs, (level + 2), "\"status\" : ");
			outs << std::dec << (ULONGLONG)this->isTargetSuspicious << "\n";
			OUT_PADDED(outs, (level + 1), "}");
		}
	}

	outs << "\n";
	OUT_PADDED(outs, level, "}");
	return true;
}

bool  pesieve::PatchList::Patch::resolveHookedExport(peconv::ExportsMapper &expMap)
{
	ULONGLONG patch_va = (ULONGLONG) this->moduleBase + this->startRva;
	const peconv::ExportedFunc *func = expMap.find_export_by_va(patch_va);
	if (func == nullptr) {
		return false; // not found
	}
	this->hooked_func = func->nameToString();
	return true;
}

const size_t pesieve::PatchList::toTAGs(std::ofstream &patch_report, const char delimiter)
{
	std::vector<Patch*>::iterator itr;
	for (itr = patches.begin(); itr != patches.end(); ++itr) {
		Patch *patch = *itr;
		patch->toTAG(patch_report, delimiter);
	}
	return patches.size();
}

const bool pesieve::PatchList::toJSON(std::stringstream &outs, size_t level, bool short_info)
{
	if (patches.size() == 0) {
		return false;
	}
	bool is_first = true;
	OUT_PADDED(outs, level, "\"patches_list\" : [\n");
	std::vector<Patch*>::iterator itr;
	size_t id = 0;
	for (itr = patches.begin(); itr != patches.end(); ++itr, ++id) {
		if (!is_first) {
			outs << ",\n";
		}
		Patch *patch = *itr;
		patch->toJSON(outs, level + 1, short_info);
		is_first = false;
	}
	outs << "\n";
	OUT_PADDED(outs, level, "]");
	return true;
}

size_t  pesieve::PatchList::checkForHookedExports(peconv::ExportsMapper &expMap)
{
	size_t hookes_exports = 0;
	std::vector<Patch*>::iterator itr;
	for (itr = patches.begin(); itr != patches.end(); ++itr) {
		Patch *patch = *itr;
		if (patch->resolveHookedExport(expMap)) {
			hookes_exports++;
		}
	}
	return hookes_exports;
}

void  pesieve::PatchList::deletePatches()
{
	std::vector<Patch*>::iterator itr;
	for (itr = patches.begin(); itr != patches.end(); ++itr) {
		Patch *patch = *itr;
		delete patch;
	}
	this->patches.clear();
}

```

`scanners/patch_list.h`:

```h
#pragma once

#include <windows.h>
#include <vector>
#include <fstream>

#include <peconv.h>

namespace pesieve {

	typedef enum {
		HOOK_NONE,
		HOOK_INLINE,
		HOOK_ADDR_REPLACEMENT,
		COUNT_HOOK_TYPES
	} t_hook_type;

	class PatchList {
	public:
		class Patch
		{
		public:
			Patch(HMODULE module_base, size_t patch_id, DWORD start_rva)
				: moduleBase(module_base), id(patch_id), startRva(start_rva), endRva(start_rva),
				type(pesieve::HOOK_NONE),
				isDirect(true), 
				hookTargetVA(0), hookTargetModule(0), isTargetSuspicious(false)
			{
			}

			Patch(const Patch& other)
			{
				id = other.id;
				startRva = other.startRva;
				endRva = other.endRva;
				moduleBase = other.moduleBase;

				isDirect = other.isDirect;
				type = other.type;
				hookTargetVA = other.hookTargetVA;
				hooked_func = other.hooked_func;

				hookTargetModule = other.hookTargetModule;
				isTargetSuspicious = other.isTargetSuspicious;
				hookTargetModName = other.hookTargetModName;
			}

			void setEnd(DWORD end_rva)
			{
				endRva = end_rva;
			}

			void setHookTarget(ULONGLONG target_va, bool is_direct = true, t_hook_type hook_type = pesieve::HOOK_INLINE)
			{
				hookTargetVA = target_va;
				isDirect = is_direct;
				this->type = hook_type;
			}

			ULONGLONG getHookTargetVA()
			{
				return hookTargetVA;
			}

			bool setHookTargetInfo(ULONGLONG targetModuleBase, bool isSuspiocious, std::string targetModuleName)
			{
				if (type == pesieve::HOOK_NONE || targetModuleBase == 0 || targetModuleBase > this->hookTargetVA) {
					return false;
				}
				this->hookTargetModule = targetModuleBase;
				this->isTargetSuspicious = isSuspiocious;
				this->hookTargetModName = targetModuleName;
				return true;
			}

			const bool toTAG(std::ofstream &patch_report, const char delimiter);
			const bool toJSON(std::stringstream &outs, size_t level, bool short_info);

		protected:
			bool resolveHookedExport(peconv::ExportsMapper &expMap);

			std::string getFormattedName();

			size_t id;
			DWORD startRva;
			DWORD endRva;
			HMODULE moduleBase;

			t_hook_type type;
			bool isDirect;
			ULONGLONG hookTargetVA;
			std::string hooked_func;

			ULONGLONG hookTargetModule;
			bool isTargetSuspicious;
			std::string hookTargetModName;

			friend class PatchList;
			friend class PatchAnalyzer;
		};

		PatchList & operator=(const PatchList &other)
		{
			deletePatches();
			std::vector<Patch*>::const_iterator itr;
			for (itr = other.patches.begin(); itr != other.patches.end(); ++itr) {
				Patch* next = *itr;
				Patch* nextCopy = new Patch(*next);
				patches.push_back(nextCopy);
			}
			return *this;
		}

		//constructor:
		PatchList() {}

		//destructor:
		virtual ~PatchList() {
			deletePatches();
		}

		void insert(Patch *p)
		{
			patches.push_back(p);
		}

		size_t size()
		{
			return patches.size();
		}

		const size_t toTAGs(std::ofstream &patch_report, const char delimiter);

		const bool toJSON(std::stringstream &outs, size_t level, bool short_info);

		//checks what are the names of the functions that have been hooked
		size_t checkForHookedExports(peconv::ExportsMapper &expMap);

		void deletePatches();

		// variables:
		std::vector<Patch*> patches;
	};

}; //namespace pesieve


```

`scanners/pe_section.h`:

```h
#pragma once

#include <windows.h>

#include <peconv.h>
#include "module_data.h"

namespace pesieve {

	//! Buffers the defined PE section belonging to the module loaded in the scanned process into the local memory.
	class PeSection
	{
	public:
		PeSection(RemoteModuleData& remoteModData, size_t section_number)
			: loadedSection(nullptr), loadedSize(0), rva(0), rawSize(0)
		{
			loadRemote(remoteModData, section_number);
		}

		PeSection(ModuleData& modData, size_t section_number)
			: loadedSection(nullptr), loadedSize(0), rva(0), rawSize(0)
		{
			loadOriginal(modData, section_number);
		}

		~PeSection()
		{
			unload();
		}

		bool isInitialized()
		{
			return (loadedSection && loadedSize > 0) ? true : false;
		}

		bool isContained(ULONGLONG field_start, size_t field_size)
		{
			ULONGLONG field_end = field_start + field_size;

			bool isInside = (field_start >= this->rva && (field_start < (this->rva + this->loadedSize)))
				|| (field_end >= this->rva && (field_end < (this->rva + this->loadedSize)));

			return isInside;
		}

		size_t rawSize;
		size_t loadedSize;
		PBYTE loadedSection;
		DWORD rva;

	protected:

		bool loadRemote(RemoteModuleData& remoteModData, size_t section_number)
		{
			unload(); //ensure that buffers are empty

			//corner case: if no sections in PE
			const size_t hdr_sec_num = peconv::get_sections_count(remoteModData.headerBuffer, remoteModData.getHeaderSize());
			if (hdr_sec_num == 0 && section_number == 0) {
				return loadRemoteImageAsSection(remoteModData);
			}
			//normal case: if PE has sections
			PIMAGE_SECTION_HEADER section_hdr = peconv::get_section_hdr(remoteModData.headerBuffer, peconv::MAX_HEADER_SIZE, section_number);
			if ((!section_hdr) || section_hdr->Misc.VirtualSize == 0) {
				return false;
			}
			this->rawSize = section_hdr->SizeOfRawData;
			this->rva = section_hdr->VirtualAddress;
			//get the code section from the module:
			this->loadedSize = 0;
			this->loadedSection = peconv::get_remote_pe_section(remoteModData.processHandle, (PBYTE)remoteModData.modBaseAddr, section_number, loadedSize, true, remoteModData.isReflection);
			if (loadedSection == nullptr) {
				return false;
			}
			return true;
		}

		bool loadOriginal(ModuleData& modData, size_t section_number)
		{
			unload(); //ensure that buffers are empty

			//corner case: if no sections in PE
			const size_t hdr_sec_num = peconv::get_sections_count(modData.original_module, modData.original_size);
			if (hdr_sec_num == 0 && section_number == 0) {
				return loadOriginalImageAsSection(modData);
			}
			PIMAGE_SECTION_HEADER section_hdr = peconv::get_section_hdr(modData.original_module, modData.original_size, section_number);
			if (section_hdr == nullptr) {
				return false;
			}
			this->rawSize = section_hdr->SizeOfRawData;
			const size_t raw_code_size = section_hdr->SizeOfRawData;
			const size_t orig_code_size = section_hdr->Misc.VirtualSize > raw_code_size ? section_hdr->Misc.VirtualSize : raw_code_size;

			loadedSection = peconv::alloc_unaligned(orig_code_size);
			if (loadedSection == nullptr) {
				return false;
			}
			this->rva = section_hdr->VirtualAddress;
			//make a copy of the section:
			BYTE *orig_code = modData.original_module + section_hdr->VirtualAddress;
			memcpy(loadedSection, orig_code, raw_code_size);
			loadedSize = orig_code_size;
			return true;
		}

		void unload()
		{
			if (!loadedSection) {
				return;
			}
			peconv::free_unaligned(loadedSection);
			loadedSection = nullptr;
			loadedSize = 0;
		}

	private:
		bool loadOriginalImageAsSection(ModuleData& modData)
		{
#ifdef _DEBUG
			std::cout << "PE with no sections! Loading original image as section\n";
#endif
			if (!modData.isInitialized()) {
				return false;
			}
			peconv::UNALIGNED_BUF buf = peconv::alloc_unaligned(modData.original_size);
			if (!buf) {
#ifdef _DEBUG
				std::cout << "Could not alloc: " << std::hex << modData.original_size << "\n";
#endif
				return false;
			}
			memcpy(buf, modData.original_module, modData.original_size);
			loadedSection = buf;
			loadedSize = modData.original_size;
			rawSize = modData.original_size;
			rva = 0;
#ifdef _DEBUG
			std::cout << "Copied local: " << std::hex << modData.original_size << "\n";
#endif
			return true;
		}

		bool _loadRemoteImageAsSection(RemoteModuleData& remoteModData, size_t image_size)
		{
			peconv::UNALIGNED_BUF buf = peconv::alloc_unaligned(image_size);
			if (!buf) {
				return false;
			}
			size_t read_size = peconv::read_remote_pe(remoteModData.processHandle, (PBYTE)remoteModData.modBaseAddr, image_size, buf, image_size);
			if (read_size != image_size) {
				//std::cout << "Read size: " << std::hex << read_size << " vs " << image_size << "\n";
				peconv::free_unaligned(buf);
				return false;
			}
			this->loadedSection = buf;
			this->loadedSize = read_size;
			this->rawSize = 0; // TODO: unknown?
			this->rva = 0;
			return true;
		}

		bool loadRemoteImageAsSection(RemoteModuleData& remoteModData)
		{
#ifdef _DEBUG
			std::cout << "PE with no sections! Loading remote image as section\n";
#endif
			if (_loadRemoteImageAsSection(remoteModData, remoteModData.getModuleSize())) {
				return true;
			}
			// if failed, try again with calculated size
			return _loadRemoteImageAsSection(remoteModData, remoteModData.calcImgSize());
		}
	};

}; //namespace pesieve


```

`scanners/process_feature_scanner.h`:

```h
#pragma once

#include <windows.h>
#include <map>

#include <peconv.h>
#include "scan_report.h"

namespace pesieve {

	//!  A base class for all the scanners checking appropriate process' features.
	class ProcessFeatureScanner {

	public:
		ProcessFeatureScanner(HANDLE _processHandle)
			: processHandle(_processHandle)
		{
		}

		virtual ~ProcessFeatureScanner() {}

		/**
		Perform the scan on the remote process
		\return a pointer to an object of the class inherited from ModuleScanReport
		*/
		virtual ModuleScanReport* scanRemote() = 0;

	protected:
		HANDLE processHandle;
	};

}; //namespace pesieve

```

`scanners/scan_report.cpp`:

```cpp
#include "scan_report.h"

#include "headers_scanner.h"
#include "code_scanner.h"
#include "iat_scanner.h"
#include "workingset_scanner.h"
#include "artefact_scanner.h"
#include "mapping_scanner.h"
#include "thread_scanner.h"

#include "../utils/format_util.h"

using namespace pesieve;
using namespace pesieve::util;

namespace pesieve {

	bool is_shown_type(t_scan_status status, ProcessScanReport::t_report_filter filter)
	{
		if (filter == ProcessScanReport::REPORT_ALL) {
			return true;
		}
		if (filter & ProcessScanReport::REPORT_ERRORS) {
			if (status == SCAN_ERROR) return true;
		}
		if (filter & ProcessScanReport::REPORT_SUSPICIOUS) {
			if (status == SCAN_SUSPICIOUS) return true;
		}
		if (filter & ProcessScanReport::REPORT_NOT_SUSPICIOUS) {
			if (status == SCAN_NOT_SUSPICIOUS) return true;
		}
		return false;
	}

}; //namespace pesieve

bool pesieve::ProcessScanReport::hasAnyShownType(const pesieve::ProcessScanReport::t_report_filter &filter)
{
	t_report summary = this->generateSummary();
	t_scan_status aggregated_status = summary.suspicious > 0 ? SCAN_SUSPICIOUS : SCAN_NOT_SUSPICIOUS;
	if (is_shown_type(aggregated_status, filter)) {
		return true;
	}
	aggregated_status = summary.errors > 0 ? SCAN_ERROR : SCAN_NOT_SUSPICIOUS;
	if (is_shown_type(aggregated_status, filter)) {
		return true;
	}
	return false;
}
//----

pesieve::ProcessScanReport::t_report_type pesieve::ProcessScanReport::getReportType(ModuleScanReport *report)
{
	if (!report) {
		return pesieve::ProcessScanReport::REPORT_TYPES_COUNT;
	}
	if (dynamic_cast<HeadersScanReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_HEADERS_SCAN;
	}
	if (dynamic_cast<WorkingSetScanReport*>(report)) {
		if (dynamic_cast<ArtefactScanReport*>(report)) {
			return pesieve::ProcessScanReport::REPORT_ARTEFACT_SCAN;
		}
		return pesieve::ProcessScanReport::REPORT_MEMPAGE_SCAN;
	}
	if (dynamic_cast<MappingScanReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_MAPPING_SCAN;
	}
	if (dynamic_cast<CodeScanReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_CODE_SCAN;
	}
	if (dynamic_cast<IATScanReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_IAT_SCAN;
	}
	if (dynamic_cast<UnreachableModuleReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_UNREACHABLE_SCAN;
	}
	if (dynamic_cast<SkippedModuleReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_SKIPPED_SCAN;
	}
	if (dynamic_cast<ThreadScanReport*>(report)) {
		return pesieve::ProcessScanReport::REPORT_THREADS_SCAN;
	}
	return pesieve::ProcessScanReport::REPORT_TYPES_COUNT;
}

size_t pesieve::ProcessScanReport::countResultsPerType(const t_report_type type, const t_scan_status result) const
{
	if (type >= REPORT_TYPES_COUNT) {
		return 0; //invalid type
	}
	size_t counter = 0;
	std::set<ModuleScanReport*>::iterator itr;
	for (itr = this->reportsByType[type].begin(); itr != this->reportsByType[type].end(); ++itr) {
		ModuleScanReport* report = *itr;
		if (ModuleScanReport::get_scan_status(report) == result) {
			counter++;
		}
	}
	return counter;
}

void pesieve::ProcessScanReport::appendToType(ModuleScanReport *report)
{
	if (report == nullptr) return;

	t_report_type type = pesieve::ProcessScanReport::getReportType(report);
	if (type >= REPORT_TYPES_COUNT) {
		return;
	}
	this->reportsByType[type].insert(report);
}

bool pesieve::ProcessScanReport::isModuleReplaced(HMODULE module_base)
{
	if (!hasModule((ULONGLONG)module_base)) {
		return false;
	}
	std::set<ModuleScanReport*>::const_iterator itr;
	for (itr = reportsByType[REPORT_HEADERS_SCAN].begin(); itr != reportsByType[REPORT_HEADERS_SCAN].end(); ++itr) {
		HeadersScanReport* report = dynamic_cast<HeadersScanReport*>(*itr);
		if (report && report->module == module_base) {
			if (report->isHdrReplaced()) {
				return true;
			}
		}
	}
	return false;
}

size_t pesieve::ProcessScanReport::countHdrsReplaced() const
{
	size_t replaced = 0;
	const t_report_type type = REPORT_HEADERS_SCAN;

	std::set<ModuleScanReport*>::iterator itr;
	for (itr = this->reportsByType[type].begin(); itr != this->reportsByType[type].end(); ++itr) {
		ModuleScanReport* report = *itr;
		if (ModuleScanReport::get_scan_status(report) == SCAN_SUSPICIOUS) {
			HeadersScanReport *hdrRep = dynamic_cast<HeadersScanReport*>(report);
			if (!hdrRep) continue; //it should not happen

			if (hdrRep->isHdrReplaced()) {
				replaced++;
			}
		}
	}
	return replaced;
}

pesieve::t_report pesieve::ProcessScanReport::generateSummary() const
{
	t_report summary = { 0 };
	summary.pid = this->pid;
	summary.is_64bit = this->is64bit;
	summary.is_managed = this->isManaged;
	summary.is_reflection = this->isReflection;
	summary.errors = static_cast<DWORD>(this->errorsCount);
	summary.skipped = static_cast<DWORD>(this->reportsByType[REPORT_SKIPPED_SCAN].size());
	summary.scanned = static_cast<DWORD>(this->reportsByType[REPORT_HEADERS_SCAN].size());

	std::vector<ModuleScanReport*>::const_iterator itr = moduleReports.begin();
	for (; itr != moduleReports.end(); ++itr) {
		ModuleScanReport* report = *itr;
		if (ModuleScanReport::get_scan_status(report) == SCAN_SUSPICIOUS) {
			summary.suspicious++;
		}
		if (ModuleScanReport::get_scan_status(report) == SCAN_ERROR) {
			summary.errors++;
		}
	}
	summary.replaced = MASK_TO_DWORD(countHdrsReplaced());
	summary.patched = MASK_TO_DWORD(countSuspiciousPerType(REPORT_CODE_SCAN));
	summary.iat_hooked = MASK_TO_DWORD(countSuspiciousPerType(REPORT_IAT_SCAN));
	summary.implanted_shc = MASK_TO_DWORD(countSuspiciousPerType(REPORT_MEMPAGE_SCAN) + countSuspiciousPerType(REPORT_THREADS_SCAN));
	summary.implanted_pe = MASK_TO_DWORD(countSuspiciousPerType(REPORT_ARTEFACT_SCAN));
	summary.implanted = MASK_TO_DWORD(summary.implanted_shc + summary.implanted_pe);
	summary.hdr_mod = MASK_TO_DWORD(countSuspiciousPerType(REPORT_HEADERS_SCAN) - summary.replaced);
	summary.unreachable_file = MASK_TO_DWORD(countSuspiciousPerType(REPORT_UNREACHABLE_SCAN) + countResultsPerType(REPORT_UNREACHABLE_SCAN, pesieve::SCAN_ERROR));
	summary.other = MASK_TO_DWORD(summary.suspicious - (summary.patched + summary.replaced + summary.implanted + summary.hdr_mod + summary.iat_hooked));
	return summary;
}

std::string pesieve::ProcessScanReport::listModules(size_t level, const pesieve::ProcessScanReport::t_report_filter &filter, const t_json_level &jdetails) const
{
	std::stringstream stream;
	//summary:
	OUT_PADDED(stream, level, "\"scans\" : [\n");
	bool is_first = true;
	std::vector<ModuleScanReport*>::const_iterator itr;
	for (itr = this->moduleReports.begin(); itr != this->moduleReports.end(); ++itr) {
		ModuleScanReport *mod = *itr;
		if (is_shown_type(mod->status, filter)) {
			if (!is_first) {
				stream << ",\n";
			}
			OUT_PADDED(stream, level + 1, "{\n");
			mod->toJSON(stream, level + 2, jdetails);
			stream << "\n";
			OUT_PADDED(stream, level + 1, "}");
			is_first = false;
		}
	}
	if (moduleReports.size()) {
		stream << "\n";
	}
	OUT_PADDED(stream, level, "]\n");
	return stream.str();
}

const bool pesieve::ProcessScanReport::toJSON(
	std::stringstream &stream, size_t level, 
	const pesieve::ProcessScanReport::t_report_filter &filter, 
	const pesieve::t_json_level &jdetails) const
{
	const t_report report = this->generateSummary();
	//summary:
	size_t other = report.other;
	stream << "{\n";
	OUT_PADDED(stream, level, "\"pid\" : ");
	stream << std::dec << report.pid << ",\n";
	OUT_PADDED(stream, level, "\"is_64_bit\" : ");
	stream << std::dec << report.is_64bit << ",\n";
	OUT_PADDED(stream, level, "\"is_managed\" : ");
	stream << std::dec << report.is_managed << ",\n";
	OUT_PADDED(stream, level, "\"main_image_path\" : \"");
	stream << escape_path_separators(this->mainImagePath) << "\",\n";
	OUT_PADDED(stream, level, "\"used_reflection\" : ");
	stream << std::dec << report.is_reflection << ",\n";
	OUT_PADDED(stream, level, "\"scanned\" : \n");
	OUT_PADDED(stream, level, "{\n");
	//stream << " {\n";
	OUT_PADDED(stream, level + 1, "\"total\" : ");
	stream << std::dec << report.scanned << ",\n";
	OUT_PADDED(stream, level + 1, "\"skipped\" : ");
	stream << std::dec << report.skipped << ",\n";
	OUT_PADDED(stream, level + 1, "\"modified\" : \n");
	OUT_PADDED(stream, level + 1, "{\n");
	//stream << "  {\n";
	OUT_PADDED(stream, level + 2, "\"total\" : ");
	stream << std::dec << report.suspicious << ",\n";
	OUT_PADDED(stream, level + 2, "\"patched\" : ");
	stream << std::dec << report.patched << ",\n";
	OUT_PADDED(stream, level + 2, "\"iat_hooked\" : ");
	stream << std::dec << report.iat_hooked << ",\n";
	OUT_PADDED(stream, level + 2, "\"replaced\" : ");
	stream << std::dec << report.replaced << ",\n";
	OUT_PADDED(stream, level + 2, "\"hdr_modified\" : ");
	stream << std::dec << report.hdr_mod << ",\n";
	OUT_PADDED(stream, level + 2, "\"implanted_pe\" : ");
	stream << std::dec << report.implanted_pe << ",\n";
	OUT_PADDED(stream, level + 2, "\"implanted_shc\" : ");
	stream << std::dec << report.implanted_shc << ",\n";
	OUT_PADDED(stream, level + 2, "\"unreachable_file\" : ");
	stream << std::dec << report.unreachable_file << ",\n";
	OUT_PADDED(stream, level + 2, "\"other\" : ");
	stream << std::dec << other << "\n";
	OUT_PADDED(stream, level + 1, "},\n"); // modified
	OUT_PADDED(stream, level + 1, "\"errors\" : ");
	stream << std::dec << report.errors << "\n";
	OUT_PADDED(stream, level, "},\n"); // scanned
	stream << listModules(level, filter, jdetails);
	stream << "}\n";
	return true;
}


```

`scanners/scan_report.h`:

```h
#pragma once

#include <windows.h>

#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include <peconv.h>
#include "pe_sieve_types.h"
#include "module_scan_report.h"
#include "scanned_modules.h"

namespace pesieve {

	//! The report aggregating the results of the performed scan
	class ProcessScanReport
	{
	public:
		typedef enum {
			REPORT_MAPPING_SCAN,
			REPORT_HEADERS_SCAN,
			REPORT_CODE_SCAN,
			REPORT_MEMPAGE_SCAN,
			REPORT_ARTEFACT_SCAN,
			REPORT_UNREACHABLE_SCAN,
			REPORT_SKIPPED_SCAN,
			REPORT_IAT_SCAN,
			REPORT_THREADS_SCAN,
			REPORT_TYPES_COUNT
		} t_report_type;

		typedef enum {
			REPORT_ERRORS = 1,
			REPORT_NOT_SUSPICIOUS = 2,
			REPORT_SUSPICIOUS = 4,
			REPORT_SUSPICIOUS_AND_ERRORS = REPORT_ERRORS | REPORT_SUSPICIOUS,
			REPORT_ALL = REPORT_ERRORS | REPORT_NOT_SUSPICIOUS | REPORT_SUSPICIOUS
		} t_report_filter;

		static t_report_type getReportType(ModuleScanReport *report);

		ProcessScanReport(DWORD _pid, bool _is64bit, bool _isReflection)
			: pid(_pid), exportsMap(nullptr), errorsCount(0), modulesInfo(pid), isManaged(false), is64bit(_is64bit), isReflection(_isReflection)
		{
		}

		~ProcessScanReport()
		{
			deleteModuleReports();
			delete exportsMap;
		}

		void appendReport(ModuleScanReport *report)
		{
			if (report == nullptr) return;
			moduleReports.push_back(report);
			if (ModuleScanReport::get_scan_status(report) == SCAN_ERROR) {
				this->errorsCount++;
			}
			appendToType(report);
			// if the scan was successful, append the module to the scanned modules:
			if (ModuleScanReport::get_scan_status(report) != SCAN_ERROR) {
				modulesInfo.appendToModulesList(report);
			}
		}

		size_t getScannedSize(ULONGLONG address) const
		{
			return modulesInfo.getScannedSize(address);
		}

		bool hasModule(ULONGLONG page_addr)
		{
			if (!modulesInfo.getModuleAt(page_addr)) {
				return false;
			}
			return true;
		}

		bool hasModuleContaining(ULONGLONG page_addr, size_t size)
		{
			if (!modulesInfo.findModuleContaining(page_addr, size)) {
				return false;
			}
			return true;
		}

		bool isModuleReplaced(HMODULE module_base);

		ScannedModule* getModuleContaining(ULONGLONG field_addr, size_t field_size = 0) const
		{
			return modulesInfo.findModuleContaining(field_addr, field_size);
		}

		const virtual bool toJSON(std::stringstream &stream, size_t level, const t_report_filter &filter, const pesieve::t_json_level &jdetails) const;

		pesieve::t_report generateSummary() const;
		DWORD getPid() { return pid; }
		bool isManagedProcess() { return this->isManaged; }

		std::string mainImagePath;
		std::vector<ModuleScanReport*> moduleReports; //TODO: make it protected
		peconv::ExportsMapper *exportsMap;

	protected:
		std::string listModules(size_t level, const ProcessScanReport::t_report_filter &filter, const t_json_level &jdetails) const;

		void deleteModuleReports()
		{
			std::vector<ModuleScanReport*>::iterator itr = moduleReports.begin();
			for (; itr != moduleReports.end(); ++itr) {
				ModuleScanReport* module = *itr;
				delete module;
			}
			moduleReports.clear();
		}
	
		void appendToType(ModuleScanReport *report);
		size_t countResultsPerType(const t_report_type type, const t_scan_status result) const;

		size_t countSuspiciousPerType(const t_report_type type) const
		{
			return countResultsPerType(type, SCAN_SUSPICIOUS);
		}

		size_t countHdrsReplaced() const;
		bool hasAnyShownType(const ProcessScanReport::t_report_filter &filter);

		DWORD pid;
		bool is64bit;
		bool isManaged;
		bool isReflection;
		size_t errorsCount;

		ModulesInfo modulesInfo;
		std::set<ModuleScanReport*> reportsByType[REPORT_TYPES_COUNT];

		friend class ProcessScanner;
		friend class ResultsDumper;
	};

}; //namespace pesieve

```

`scanners/scanned_modules.cpp`:

```cpp
#include "scanned_modules.h"

#include <string>
#include <iostream>
#include <windows.h>
#include <psapi.h>

using namespace pesieve;

bool pesieve::ModulesInfo::appendModule(ScannedModule* lModule)
{
	if (lModule == nullptr) {
		return false;
	}
	ULONGLONG start_addr = lModule->start;
	if (this->modulesMap.find(start_addr) != this->modulesMap.end()) {
		//already exist
		return false;
	}
	modulesMap[start_addr] = lModule;
	return true;
}

bool pesieve::ModulesInfo::appendToModulesList(ModuleScanReport *report)
{
	if (!report || report->moduleSize == 0) {
		return false; //skip
	}
	ULONGLONG module_start = (ULONGLONG)report->module;
	ScannedModule* mod = this->getModuleAt(module_start);
	if (mod == nullptr) {
		//create new only if it was not found
		mod = new ScannedModule(module_start, report->moduleSize);
		if (!this->appendModule(mod)) {
			delete mod; //delete the module as it was not appended
			return false;
		}
	}
	if (mod->moduleName == "") {
		mod->moduleName = peconv::get_file_name(report->moduleFile);
	}
	size_t old_size = mod->getSize();
	if (old_size < report->moduleSize) {
		mod->resize(report->moduleSize);
	}
	if (!mod->isSuspicious()) {
		//update the status
		mod->setSuspicious(report->status == SCAN_SUSPICIOUS);
	}
	return true;
}

ScannedModule* pesieve::ModulesInfo::findModuleContaining(ULONGLONG address, size_t size) const
{
	const ULONGLONG field_end = address + size;

	// the first element that is greater than the start address
	std::map<ULONGLONG, ScannedModule*>::const_iterator firstGreater = modulesMap.upper_bound(address);

	std::map<ULONGLONG, ScannedModule*>::const_iterator itr;
	for (itr = modulesMap.begin(); itr != firstGreater; ++itr) {
		ScannedModule *module = itr->second;
		if (!module) continue; //this should never happen

		if (address >= module->getStart() && field_end <= module->getEnd()) {
			// Address found in module:
			return module;
		}
	}
	return nullptr;
}

void pesieve::ModulesInfo::deleteAll()
{
	std::map<ULONGLONG, ScannedModule*>::iterator itr = modulesMap.begin();
	for (; itr != modulesMap.end(); ++itr ) {
		const ScannedModule *module = itr->second;
		delete module;
	}
	this->modulesMap.clear();
}

size_t pesieve::ModulesInfo::getScannedSize(ULONGLONG address) const
{
	std::map<ULONGLONG, ScannedModule*>::const_iterator start_itr = modulesMap.begin();
	std::map<ULONGLONG, ScannedModule*>::const_iterator stop_itr = modulesMap.upper_bound(address);
	std::map<ULONGLONG, ScannedModule*>::const_iterator itr = start_itr;

	size_t max_size = 0;

	for (; itr != stop_itr; ++itr) {
		ScannedModule *module = itr->second;
		if (address >= module->start && address < module->getEnd()) {
			ULONGLONG diff = module->getEnd() - address;
			if (diff > max_size) {
				max_size = diff;
			}
		}
	}
	return max_size;
}

ScannedModule* pesieve::ModulesInfo::getModuleAt(ULONGLONG address) const
{
	std::map<ULONGLONG, ScannedModule*>::const_iterator itr = modulesMap.find(address);
	if (itr != modulesMap.end()) {
		return itr->second;
	}
	return nullptr;
}


```

`scanners/scanned_modules.h`:

```h
#pragma once

#include <windows.h>

#include <map>
#include <string>
#include <iostream>

#include "module_scan_report.h"

namespace pesieve {

	//!  Represents a basic info about the scanned module, such as its base offset, size, and the status.
	class ScannedModule {

	public:

		ULONGLONG getStart() const
		{
			return start;
		}

		ULONGLONG getEnd() const
		{
			return moduleSize + start;
		}

		size_t getSize()
		{
			return moduleSize;
		}

		bool isSuspicious() const
		{
			return this->is_suspicious;
		}
		
		std::string getModName() const
		{
			return this->moduleName;
		}

	protected:
		ScannedModule(ULONGLONG _start, size_t _moduleSize)
			: start(_start), moduleSize(_moduleSize),
			is_suspicious(false)
		{
		}

		~ScannedModule()
		{
		}

		bool operator<(ScannedModule other) const
		{
			return this->start < other.start;
		}

		void setSuspicious(bool _is_suspicious) {
			this->is_suspicious = _is_suspicious;
		}

		bool resize(size_t newSize)
		{
			if (moduleSize < newSize) {
				//std::cout << "Resizing module from: " << std::hex << moduleSize << " to: " << newSize << "\n";
				moduleSize = newSize;
				return true;
			}
			return false;
		}

		const ULONGLONG start;

	private:
		size_t moduleSize;
		bool is_suspicious;
		std::string moduleName;

		friend class ModulesInfo;
	};

	//!  A container of all the process modules that were scanned.
	class ModulesInfo {

	public:
		ModulesInfo(DWORD _pid)
			: process_id(_pid)
		{
		}

		~ModulesInfo()
		{
			deleteAll();
		}

		bool appendToModulesList(ModuleScanReport *report);

		size_t count() { return modulesMap.size(); }

		size_t getScannedSize(ULONGLONG start_address) const;
		ScannedModule* findModuleContaining(ULONGLONG address, size_t size = 0) const;
		ScannedModule* getModuleAt(ULONGLONG address) const;

	protected:
		bool appendModule(ScannedModule* module);
		void deleteAll();

	private:
		std::map<ULONGLONG, ScannedModule*> modulesMap;
		const DWORD process_id;
	};

}; //namespace pesieve


```

`scanners/scanner.cpp`:

```cpp
#include "scanner.h"

#include <sstream>
#include <fstream>
#include <string>
#include <locale>
#include <codecvt>

#include <tlhelp32.h>

#include "../utils/format_util.h"
#include "../utils/path_converter.h"
#include "../utils/workingset_enum.h"
#include "../utils/modules_enum.h"
#include "../utils/process_privilege.h"
#include "../utils/process_util.h"

#include "headers_scanner.h"
#include "code_scanner.h"
#include "iat_scanner.h"
#include "workingset_scanner.h"
#include "mapping_scanner.h"
#include "hook_targets_resolver.h"
#include "thread_scanner.h"

using namespace pesieve;
using namespace pesieve::util;

namespace pesieve {

	bool validate_param_str(PARAM_STRING &strparam)
	{
		if (!strparam.buffer || strparam.length == 0) {
			return false;
		}
		if (IsBadReadPtr(strparam.buffer, strparam.length)) {
			return false;
		}
		return true;
	}
};

pesieve::ProcessScanner::ProcessScanner(HANDLE procHndl, bool is_reflection, pesieve::t_params _args)
	: args(_args), isDEP(false), isReflection(is_reflection)
{
	this->processHandle = procHndl;
	if (validate_param_str(args.modules_ignored)) {
		pesieve::util::string_to_list(args.modules_ignored.buffer, PARAM_LIST_SEPARATOR, ignoredModules);
	}
}

t_scan_status pesieve::ProcessScanner::scanForHollows(HANDLE processHandle, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report)
{
	BOOL isWow64 = FALSE;
#ifdef _WIN64
	is_process_wow64(processHandle, &isWow64);
#endif
	HeadersScanner scanner(processHandle, modData, remoteModData);
	HeadersScanReport *scan_report = scanner.scanRemote();
	if (!scan_report) {
		return SCAN_ERROR;
	}
	
	if (scan_report->archMismatch && isWow64) {
#ifdef _DEBUG
		std::cout << "Arch mismatch, reloading..." << std::endl;
#endif
		if (modData.reloadWow64()) {
			delete scan_report; // delete previous report
			scan_report = scanner.scanRemote();
		}
	}
	scan_report->moduleFile = modData.szModName;
	scan_report->isInPEB = modData.isModuleInPEBList();

	t_scan_status is_replaced = ModuleScanReport::get_scan_status(scan_report);
	if (is_replaced && !scan_report->isHdrReplaced()) {
		is_replaced = SCAN_NOT_SUSPICIOUS;
	}
	process_report.appendReport(scan_report);
	return is_replaced;
}

t_scan_status pesieve::ProcessScanner::scanForIATHooks(HANDLE processHandle, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report, t_iat_scan_mode filter)
{
	const peconv::ExportsMapper *expMap = process_report.exportsMap;
	if (!expMap) {
		return SCAN_ERROR;
	}

	if (process_report.isModuleReplaced(modData.moduleHandle)) {
		std::cout << "Cannot scan replaced module for IAT hooks!\n";
		return SCAN_ERROR;
	}
	IATScanner scanner(processHandle, modData, remoteModData, *expMap, process_report.modulesInfo, filter);
	IATScanReport *scan_report = scanner.scanRemote();
	if (!scan_report) {
		return SCAN_ERROR;
	}
	t_scan_status scan_res = ModuleScanReport::get_scan_status(scan_report);
	scan_report->moduleFile = modData.szModName;
	process_report.appendReport(scan_report);
	return scan_res;
}

t_scan_status pesieve::ProcessScanner::scanForHooks(HANDLE processHandle, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report, bool scan_data, bool scan_inaccessible)
{
	CodeScanner scanner(processHandle, modData, remoteModData);
	scanner.setScanData(scan_data);
	scanner.setScanInaccessible(scan_inaccessible);
	CodeScanReport *scan_report = scanner.scanRemote();
	if (!scan_report) {
		return SCAN_ERROR;
	}
	t_scan_status is_hooked = ModuleScanReport::get_scan_status(scan_report);

	scan_report->moduleFile = modData.szModName;
	process_report.appendReport(scan_report);
	return is_hooked;
}

bool pesieve::ProcessScanner::resolveHooksTargets(ProcessScanReport& process_report)
{
	HookTargetResolver hookResolver(process_report);
	std::set<ModuleScanReport*> &code_reports = process_report.reportsByType[ProcessScanReport::REPORT_CODE_SCAN];
	size_t resolved_count = hookResolver.resolveAllHooks(code_reports);
	return (resolved_count > 0);
}

inline bool set_non_suspicious(const std::set<ModuleScanReport*> &scan_reports, bool dnet_modules_only)
{
	bool is_set = false;
	std::set<ModuleScanReport*>::iterator itr;
	for (itr = scan_reports.begin(); itr != scan_reports.end(); ++itr) {
		ModuleScanReport* report = *itr;
		if (!report) {
			//this should never happen
			continue;
		}
		if (dnet_modules_only && !report->isDotNetModule) {
			continue;
		}
		if (report->status == SCAN_SUSPICIOUS) {
			report->status = SCAN_NOT_SUSPICIOUS;
			is_set = true;
		}
	}
	return is_set;
}

bool pesieve::ProcessScanner::filterDotNetReport(ProcessScanReport& process_report)
{
	if (!process_report.isManaged // Not a .NET process
		|| this->args.dotnet_policy == pesieve::PE_DNET_NONE) // .NET policy not set
	{
		return false; // no filtering needed
	}
	bool is_set = false;
	if (this->args.dotnet_policy == pesieve::PE_DNET_SKIP_MAPPING
		|| this->args.dotnet_policy == pesieve::PE_DNET_SKIP_ALL)
	{
		// set hook modules as not suspicious
		const std::set<ModuleScanReport*> &reports = process_report.reportsByType[ProcessScanReport::REPORT_MAPPING_SCAN];
		is_set = set_non_suspicious(reports, true);
	}
	if (this->args.dotnet_policy == pesieve::PE_DNET_SKIP_HOOKS
		|| this->args.dotnet_policy == pesieve::PE_DNET_SKIP_ALL)
	{
		// set hook modules as not suspicious
		const std::set<ModuleScanReport*> &reports = process_report.reportsByType[ProcessScanReport::REPORT_CODE_SCAN];
		is_set = set_non_suspicious(reports, false);
	}
	if (this->args.dotnet_policy == pesieve::PE_DNET_SKIP_SHC
		|| this->args.dotnet_policy == pesieve::PE_DNET_SKIP_ALL)
	{
		// set shellcodes detected by mempage scan as not suspicious
		const std::set<ModuleScanReport*> &reports = process_report.reportsByType[ProcessScanReport::REPORT_MEMPAGE_SCAN];
		const bool is_set1 = set_non_suspicious(reports, false);

		// set shellcodes detected by thread scan as not-suspicious
		const std::set<ModuleScanReport*>& reports2 = process_report.reportsByType[ProcessScanReport::REPORT_THREADS_SCAN];
		const bool is_set2 = set_non_suspicious(reports2, false);
		is_set = is_set1 || is_set2;
	}
	return is_set;
}

ProcessScanReport* pesieve::ProcessScanner::scanRemote()
{
	this->isDEP = is_DEP_enabled(this->processHandle);

	const bool is_64bit = pesieve::util::is_process_64bit(this->processHandle);

	ProcessScanReport *pReport = new ProcessScanReport(this->args.pid, is_64bit, this->isReflection);

	char image_buf[MAX_PATH] = { 0 };
	GetProcessImageFileNameA(this->processHandle, image_buf, MAX_PATH);
	pReport->mainImagePath = device_path_to_win32_path(image_buf);

	std::stringstream errorsStr;

	// scan modules
	size_t modulesScanned = 0;
	try {
		modulesScanned = scanModules(*pReport);
	} catch (std::exception &e) {
		modulesScanned = 0;
		errorsStr << e.what();
	}

	// scan working set
	size_t regionsScanned = 0;
	try {
		//dont't scan your own working set
		if (peconv::get_process_id(this->processHandle) != GetCurrentProcessId()) {
			regionsScanned = scanWorkingSet(*pReport);
		}
	} catch (std::exception &e) {
		regionsScanned = 0;
		errorsStr << e.what();
	}

	// scan IATs
	size_t iatsScanned = 0;
	if (args.iat) {
		try {
			iatsScanned = scanModulesIATs(*pReport);
		}
		catch (std::exception& e) {
			iatsScanned = 0;
			errorsStr << e.what();
		}
	}

	// scan threads
	size_t threadsScanned = 0;
	if (args.threads) {
		try {
			threadsScanned = scanThreads(*pReport);
		}
		catch (std::exception& e) {
			threadsScanned = 0;
			errorsStr << e.what();
		}
	}

	// throw error only if none of the scans was successful
	if (!modulesScanned && !iatsScanned && !regionsScanned) {
		throw std::runtime_error(errorsStr.str());
	}
	//post-process hooks
	resolveHooksTargets(*pReport);

	//post-process detection reports according to the .NET policy
	filterDotNetReport(*pReport);
	return pReport;
}

size_t pesieve::ProcessScanner::scanWorkingSet(ProcessScanReport &pReport) //throws exceptions
{
	if (!util::count_workingset_entries(this->processHandle)) {
		throw std::runtime_error("Could not query the working set. ");
		return 0;
	}
	ULONGLONG start_tick = GetTickCount64();
	std::set<ULONGLONG> region_bases;
	size_t pages_count = util::enum_workingset(processHandle, region_bases);
	if (!args.quiet) {
		std::cout << "Scanning workingset: " << std::dec << pages_count << " memory regions." << std::endl;
	}
	size_t counter = 0;
	//now scan all the nodes:
	std::set<ULONGLONG>::iterator set_itr;
	for (set_itr = region_bases.begin(); set_itr != region_bases.end(); ++set_itr, ++counter) {
		const ULONGLONG region_base = *set_itr;
		
		MemPageData memPage(this->processHandle, this->isReflection, region_base, 0);

		memPage.is_listed_module = pReport.hasModule(region_base);
		memPage.is_dep_enabled = this->isDEP;

		WorkingSetScanner scanner(this->processHandle, memPage, this->args, pReport);
		WorkingSetScanReport *my_report = scanner.scanRemote();
		if (!my_report) {
			continue;
		}
		my_report->is_listed_module = pReport.hasModule((ULONGLONG) my_report->module);
		// this is a code section inside a PE file that was already detected
		if (!my_report->has_pe 
			&& (pReport.hasModuleContaining((ULONGLONG)my_report->module, my_report->moduleSize))
			)
		{
			my_report->status = SCAN_NOT_SUSPICIOUS;
		}

		pReport.appendReport(my_report);
	}
	if (!args.quiet) {
		ULONGLONG total_time = GetTickCount64() - start_tick;
		std::cout << "[*] Workingset scanned in " << std::dec << total_time << " ms" << std::endl;
	}
	return counter;
}

ModuleScanReport* pesieve::ProcessScanner::scanForMappingMismatch(ModuleData& modData, ProcessScanReport& process_report)
{
	MappingScanner scanner(processHandle, modData);
	MappingScanReport *scan_report = scanner.scanRemote();

	process_report.appendReport(scan_report);
	return scan_report;
}

size_t pesieve::ProcessScanner::scanModules(ProcessScanReport &pReport)  //throws exceptions
{
	HMODULE hMods[1024] = { 0 };
	const size_t modules_count = enum_modules(this->processHandle, hMods, sizeof(hMods), LIST_MODULES_ALL);
	if (modules_count == 0) {
		return 0;
	}
	if (args.imprec_mode != PE_IMPREC_NONE || args.iat != pesieve::PE_IATS_NONE) {
		pReport.exportsMap = new peconv::ExportsMapper();
	}

	size_t counter = 0;
	for (counter = 0; counter < modules_count; counter++) {
		if (processHandle == nullptr) break;
		const HMODULE module_base = hMods[counter];
		//load module from file:
		ModuleData modData(processHandle, module_base, true, args.use_cache);
		ModuleScanReport *mappingScanReport = this->scanForMappingMismatch(modData, pReport);

		//load the original file to make the comparisons:
		if (!modData.loadOriginal()) {
			if (!args.quiet) {
				std::cout << "[!][" << args.pid << "] Suspicious: could not read the module file!" << std::endl;
			}
			//make a report that finding original module was not possible
			pReport.appendReport(new UnreachableModuleReport(module_base, 0, modData.szModName));
			continue;
		}
		if (modData.isDotNet()) {
			// the process contains at least one .NET module. Treat it as managed process:
			pReport.isManaged = true;
		}
		// Don't scan modules that are in the ignore list
		const std::string plainName = peconv::get_file_name(modData.szModName);
		if (is_in_list(plainName, this->ignoredModules)) {
			// ...but add such modules to the exports lookup:
			if (pReport.exportsMap) {
				pReport.exportsMap->add_to_lookup(modData.szModName, (HMODULE)modData.original_module, (ULONGLONG)modData.moduleHandle);
			}
			if (!args.quiet) {
				std::cout << "[*] Skipping ignored: " << std::hex << (ULONGLONG)modData.moduleHandle << " : " << modData.szModName << std::endl;
			}
			pReport.appendReport(new SkippedModuleReport(modData.moduleHandle, modData.original_size, modData.szModName));
			continue;
		}

		if (!args.quiet) {
			std::cout << "[*] Scanning: " << modData.szModName;
			if (modData.isDotNet()) {
				std::cout << " (.NET) ";
			}
			std::cout << std::endl;
		}
		//load data about the remote module
		RemoteModuleData remoteModData(processHandle, this->isReflection, module_base);
		if (!remoteModData.isInitialized()) {
			//make a report that initializing remote module was not possible
			pReport.appendReport(new MalformedHeaderReport(module_base, 0, modData.szModName));
			continue;
		}
		t_scan_status is_hollowed = scanForHollows(processHandle, modData, remoteModData, pReport);
		if (is_hollowed == SCAN_ERROR) {
			continue;
		}
		if (is_hollowed == SCAN_NOT_SUSPICIOUS) {
			//if the content does not differ, ignore the different name of the mapped file
			mappingScanReport->status = SCAN_NOT_SUSPICIOUS;
		}

		// the module is not hollowed, so we can add it to the exports lookup:
		if (pReport.exportsMap) {
			pReport.exportsMap->add_to_lookup(modData.szModName, (HMODULE) modData.original_module, (ULONGLONG) modData.moduleHandle);
		}

		if (!args.no_hooks //if hooks not disabled
			&& (is_hollowed == SCAN_NOT_SUSPICIOUS) // and process is not hollowed
			) 
		{
			const bool scan_data = ((this->args.data >= pesieve::PE_DATA_SCAN_ALWAYS) && (this->args.data != pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY))
				|| (!this->isDEP && (this->args.data == pesieve::PE_DATA_SCAN_NO_DEP));
			
			const bool scan_inaccessible = (this->isReflection && (this->args.data >= PE_DATA_SCAN_INACCESSIBLE));
			scanForHooks(processHandle, modData, remoteModData, pReport, scan_data, scan_inaccessible);
		}
	}
	return counter;
}

size_t pesieve::ProcessScanner::scanModulesIATs(ProcessScanReport &pReport) //throws exceptions
{
	if (!pReport.exportsMap) {
		return 0; // this feature cannot work without Exports Map
	}
	HMODULE hMods[1024];
	const size_t modules_count = enum_modules(this->processHandle, hMods, sizeof(hMods), LIST_MODULES_ALL);
	if (modules_count == 0) {
		return 0;
	}
	if (!args.quiet) {
		std::cout << "Scanning for IAT hooks: " << modules_count << " modules." << std::endl;
	}
	ULONGLONG start_tick = GetTickCount64();
	size_t counter = 0;
	for (counter = 0; counter < modules_count; counter++) {
		if (!processHandle) break; // this should never happen

		const HMODULE module_base = hMods[counter];
		//load module from file:
		ModuleData modData(processHandle, module_base, true, args.use_cache);

		// Don't scan modules that are in the ignore list
		std::string plainName = peconv::get_file_name(modData.szModName);
		if (is_in_list(plainName, this->ignoredModules)) {
			continue;
		}

		//load data about the remote module
		RemoteModuleData remoteModData(processHandle, this->isReflection, module_base);
		if (remoteModData.isInitialized() == false) {
			//make a report that initializing remote module was not possible
			pReport.appendReport(new MalformedHeaderReport(module_base, 0, modData.szModName));
			continue;
		}

		// do the IAT scan:
		scanForIATHooks(processHandle, modData, remoteModData, pReport, this->args.iat);
	}
	if (!args.quiet) {
		ULONGLONG total_time = GetTickCount64() - start_tick;
		std::cout << "[*] IATs scanned in " << std::dec << total_time << " ms" << std::endl;
	}
	return counter;
}


size_t pesieve::ProcessScanner::scanThreads(ProcessScanReport& pReport) //throws exceptions
{
	const DWORD pid = pReport.pid; //original PID, not a reflection!

	//dont't scan your own threads - it may give wrong results:
	if (pid == GetCurrentProcessId()) {
		return 0;
	}

	const bool is_64bit = pesieve::util::is_process_64bit(this->processHandle);
#ifndef _WIN64
	if (is_64bit) return 0;
#endif

	if (!args.quiet) {
		std::cout << "Scanning threads." << std::endl;
	}
	ULONGLONG start_tick = GetTickCount64();

	std::vector<thread_info> threads_info;
	if (!pesieve::util::fetch_threads_info(pid, threads_info)) { //extended info, but doesn't work on old Windows...

		if (!pesieve::util::fetch_threads_by_snapshot(pid, threads_info)) { // works on old Windows, but gives less data..

			if (!args.quiet) {
				std::cout << "[-] Failed enumerating threads." << std::endl;
			}
			return 0;
		}
	}

	ThreadScanner::InitSymbols(this->processHandle);
	std::vector<thread_info>::iterator itr;
	for (itr = threads_info.begin(); itr != threads_info.end(); ++itr) {
		const thread_info &info = *itr;
		ThreadScanner scanner(this->processHandle, info, pReport.modulesInfo, pReport.exportsMap);
		ThreadScanReport* report = scanner.scanRemote();
		pReport.appendReport(report);
	}
	ThreadScanner::FreeSymbols(this->processHandle);

	if (!args.quiet) {
		ULONGLONG total_time = GetTickCount64() - start_tick;
		std::cout << "[*] Threads scanned in " << std::dec << total_time << " ms" << std::endl;
	}
	return 0;
}

```

`scanners/scanner.h`:

```h
#pragma once

#include <windows.h>
#include <string>
#include <map>

#include <peconv.h>
#include "scan_report.h"
#include "module_data.h"

namespace pesieve {

	//!  The root scanner, responsible for enumerating all the elements to be scanned within a given process, and performing apropriate scans on them.
	class ProcessScanner {
	public:

		/**
		A constructor of ProcessScanner.
		\param procHndl : a HANDLE to the process to be scanned (must be opened with appropriate access rights)
		\param is_reflection : a flag indicating if the given handle (procHndl) leads to a raw process, or the process reflection
		\param args : the configuration of the scan (defined as t_params)
		*/
		ProcessScanner(HANDLE procHndl, bool is_reflection, pesieve::t_params _args);

		~ProcessScanner()
		{
		}

		//!  The main function of ProcessScanner, deploying the scan. Throws exceptions in case of a failure.
		/**
		\return pointer to the generated report of type ProcessScanReport
		*/
		ProcessScanReport* scanRemote(); //throws exceptions

		static t_scan_status scanForHollows(HANDLE hProcess, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report);
		static t_scan_status scanForHooks(HANDLE hProcess, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report, bool scan_data, bool scan_inaccessible);
		static t_scan_status scanForIATHooks(HANDLE hProcess, ModuleData& modData, RemoteModuleData &remoteModData, ProcessScanReport& process_report, t_iat_scan_mode filter);

	protected:
		size_t scanModules(ProcessScanReport &pReport); //throws exceptions
		size_t scanModulesIATs(ProcessScanReport &pReport); //throws exceptions
		size_t scanThreads(ProcessScanReport& pReport); //throws exceptions
		size_t scanWorkingSet(ProcessScanReport &pReport);  //throws exceptions

		ModuleScanReport* scanForMappingMismatch(ModuleData& modData, ProcessScanReport& process_report);

		bool resolveHooksTargets(ProcessScanReport& process_report);
		bool filterDotNetReport(ProcessScanReport& process_report);

		HANDLE processHandle;
		bool isDEP;
		const bool isReflection;
		size_t hModsMax;
		pesieve::t_params args;

		std::set<std::string> ignoredModules;
	};

}; //namespace pesieve

```

`scanners/thread_scanner.cpp`:

```cpp
#include "thread_scanner.h"
#include <peconv.h>
#include "../utils/process_util.h"
#include "../utils/ntddk.h"

#include <DbgHelp.h>
#pragma comment(lib, "dbghelp")

using namespace pesieve;

typedef struct _t_stack_enum_params {
	HANDLE hProcess;
	HANDLE hThread;
	LPVOID ctx;
	const pesieve::thread_ctx* c;
	std::vector<ULONGLONG> stack_frame;
	bool is_ok;

	_t_stack_enum_params()
		: hProcess(NULL), hThread(NULL), ctx(NULL), c(NULL), is_ok(false)
	{
	}

	_t_stack_enum_params(IN HANDLE hProcess, IN HANDLE hThread, IN LPVOID ctx, IN const pesieve::thread_ctx& c)
	{
		this->hProcess = hProcess;
		this->hThread = hThread;
		this->ctx = ctx;
		this->c = &c;
		this->is_ok = false;
	}
} t_stack_enum_params;


DWORD WINAPI enum_stack_thread(LPVOID lpParam)
{
	t_stack_enum_params* args = static_cast<t_stack_enum_params*>(lpParam);
	if (!args || !args->c || !args->ctx) {
		return STATUS_INVALID_PARAMETER;
	}
	size_t fetched = 0;
	bool in_shc = false;
	const pesieve::thread_ctx& c = *(args->c);
#ifdef _WIN64
	if (c.is64b) {
		STACKFRAME64 frame = { 0 };

		frame.AddrPC.Offset = c.rip;
		frame.AddrPC.Mode = AddrModeFlat;
		frame.AddrStack.Offset = c.rsp;
		frame.AddrStack.Mode = AddrModeFlat;
		frame.AddrFrame.Offset = c.rbp;
		frame.AddrFrame.Mode = AddrModeFlat;

		while (StackWalk64(IMAGE_FILE_MACHINE_AMD64, args->hProcess, args->hThread, &frame, args->ctx, NULL, SymFunctionTableAccess64, SymGetModuleBase64, NULL)) {
			//std::cout << "Next Frame start:" << std::hex << frame.AddrPC.Offset << "\n";
			const ULONGLONG next_addr = frame.AddrPC.Offset;
			args->stack_frame.push_back(next_addr);
			fetched++;
		}
	}
#endif
	if (!c.is64b) {
		STACKFRAME frame = { 0 };

		frame.AddrPC.Offset = c.rip;
		frame.AddrPC.Mode = AddrModeFlat;
		frame.AddrStack.Offset = c.rsp;
		frame.AddrStack.Mode = AddrModeFlat;
		frame.AddrFrame.Offset = c.rbp;
		frame.AddrFrame.Mode = AddrModeFlat;

		while (StackWalk(IMAGE_FILE_MACHINE_I386, args->hProcess, args->hThread, &frame, args->ctx, NULL, SymFunctionTableAccess, SymGetModuleBase, NULL)) {
			const ULONGLONG next_addr = frame.AddrPC.Offset;
			args->stack_frame.push_back(next_addr);
			fetched++;
		}
	}
	if (fetched) {
		args->is_ok = true;
		return STATUS_SUCCESS;
	}
	return STATUS_UNSUCCESSFUL;
}

size_t pesieve::ThreadScanner::enumStackFrames(IN HANDLE hProcess, IN HANDLE hThread, IN LPVOID ctx, IN OUT thread_ctx& c)
{
	// do it in a new thread to prevent stucking...
	t_stack_enum_params args(hProcess, hThread, ctx, c);
	const size_t max_wait = 1000;
	{
		HANDLE enumThread = CreateThread(
			NULL,                   // default security attributes
			0,                      // use default stack size  
			enum_stack_thread,       // thread function name
			&args,          // argument to thread function 
			0,                      // use default creation flags 
			0);   // returns the thread identifier

		DWORD wait_result = WaitForSingleObject(enumThread, max_wait);
		if (wait_result == WAIT_TIMEOUT) {
			std::cerr << "[!] Cannot retrieve stack frame: timeout passed!\n";
			TerminateThread(enumThread, 0);
			CloseHandle(enumThread);
			return 0;
		}
		CloseHandle(enumThread);
	}

	if (!args.is_ok) {
		return 0;
	}

	// filter:
	size_t cntr = 0;
	bool has_shellcode = false;
	c.is_managed = false;
	std::vector<ULONGLONG>::iterator itr;
	for (itr = args.stack_frame.begin(); itr != args.stack_frame.end(); ++itr) {
		cntr++;
		ULONGLONG next_addr = *itr;
#ifdef _DEBUG
		resolveAddr(next_addr);
#endif
		bool is_curr_shc = false;
		const ScannedModule* mod = modulesInfo.findModuleContaining(next_addr);
		const std::string mod_name = mod ? mod->getModName() : "";
		if (mod_name.length() == 0) {
			has_shellcode = is_curr_shc = true;
#ifdef _DEBUG
			std::cout << std::hex << next_addr << " <=== SHELLCODE\n";
#endif
		}
		if (!has_shellcode || is_curr_shc) {
			// store the last address, till the first called shellcode:
			c.ret_addr = next_addr;
		}
		// check if the found shellcode is a .NET JIT:
		if (mod_name == "clr.dll") {
			c.is_managed = true;
#ifdef _DEBUG
			std::cout << std::hex << next_addr << " <--- .NET\n";
#endif
			if (has_shellcode) break;
		}
	}
	return cntr;
}

bool pesieve::ThreadScanner::fetchThreadCtx(IN HANDLE hProcess, IN HANDLE hThread, OUT thread_ctx& c)
{
	bool is_ok = false;
	BOOL is_wow64 = FALSE;
#ifdef _WIN64
	pesieve::util::is_process_wow64(hProcess, &is_wow64);

	if (is_wow64) {
		WOW64_CONTEXT ctx = { 0 };
		ctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
		if (Wow64GetThreadContext(hThread, &ctx)) {
			is_ok = true;

			c.rip = ctx.Eip;
			c.rsp = ctx.Esp;
			c.rbp = ctx.Ebp;
			c.is64b = false;
			enumStackFrames(hProcess, hThread, &ctx, c);
		}
	}
#endif
	if (!is_ok) {

		CONTEXT ctx = { 0 };
		ctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;
		if (GetThreadContext(hThread, &ctx)) {
			is_ok = true;
#ifdef _WIN64
			c.rip = ctx.Rip;
			c.rsp = ctx.Rsp;
			c.rbp = ctx.Rbp;
			c.is64b = true;


#else
			c.rip = ctx.Eip;
			c.rsp = ctx.Esp;
			c.is64b = false;
#endif
			enumStackFrames(hProcess, hThread, &ctx, c);
		}
	}
	return is_ok;
}

bool pesieve::ThreadScanner::isAddrInShellcode(ULONGLONG addr)
{
	ScannedModule* mod = modulesInfo.findModuleContaining(addr);
	if (!mod) return true;

	//the module is named
	if (mod->getModName().length() > 0) {
		return false;
	}
	return true;
}

bool pesieve::ThreadScanner::resolveAddr(ULONGLONG addr)
{
	bool is_resolved = false;
	ScannedModule* mod = modulesInfo.findModuleContaining(addr);
	std::cout << " > " << std::hex << addr;
	if (mod) {
		std::cout << " : " << mod->getModName();
		is_resolved = true;
	}
	if (exportsMap && is_resolved) {
		bool search_name = false;
		if (mod->getModName() == "ntdll.dll" || mod->getModName() == "win32u.dll") {
			search_name = true;
		}
		for (size_t i = 0; i < 25; i++) {
			const peconv::ExportedFunc* exp = exportsMap->find_export_by_va(addr - i);
			if (exp) {
				std::cout << " : " << exp->toString();
				is_resolved = true;
				break;
			}
			if (!search_name) {
				break;
			}
		}
	}
	std::cout << std::endl;
	return is_resolved;
}

bool get_page_details(HANDLE processHandle, LPVOID start_va, MEMORY_BASIC_INFORMATION &page_info)
{
	size_t page_info_size = sizeof(MEMORY_BASIC_INFORMATION);
	const SIZE_T out = VirtualQueryEx(processHandle, (LPCVOID)start_va, &page_info, page_info_size);
	const bool is_read = (out == page_info_size) ? true : false;
	const DWORD error = is_read ? ERROR_SUCCESS : GetLastError();
	if (error != ERROR_SUCCESS) {
		//nothing to read
		return false;
	}
	return true;
}

bool pesieve::ThreadScanner::reportSuspiciousAddr(ThreadScanReport* my_report, ULONGLONG susp_addr, thread_ctx  &c)
{
	MEMORY_BASIC_INFORMATION page_info = { 0 };
	if (!get_page_details(processHandle, (LPVOID)susp_addr, page_info)) {
		return false;
	}
	if (page_info.State & MEM_FREE) {
		return false;
	}
	my_report->status = SCAN_SUSPICIOUS;
	ULONGLONG base = (ULONGLONG)page_info.BaseAddress;
	if (this->info.is_extended) {
		my_report->thread_state = info.ext.state;
		my_report->thread_wait_reason = info.ext.wait_reason;
	}
	my_report->module = (HMODULE)base;
	my_report->moduleSize = page_info.RegionSize;
	my_report->protection = page_info.AllocationProtect;

	my_report->thread_ip = susp_addr;
	return true;
}


bool pesieve::ThreadScanner::InitSymbols(HANDLE hProc)
{
	if (SymInitialize(hProc, NULL, TRUE)) {
		return true;
	}
	return false;
}

bool pesieve::ThreadScanner::FreeSymbols(HANDLE hProc)
{
	if (SymCleanup(hProc)) {
		return true;
	}
	return false;
}

// if extended info given, allow to filter out from the scan basing on the thread state and conditions
bool should_scan(const util::thread_info& info)
{
	if (!info.is_extended) {
		return true;
	}
	const KTHREAD_STATE state = (KTHREAD_STATE)info.ext.state;
	if (state == Running || state == Ready) {
		return true;
	}
	if (state == Terminated) {
		return false;
	}
	if (state == Waiting) {
		if (info.ext.start_addr == 0) {
			return true;
		}
		if (info.ext.wait_reason == DelayExecution
			|| info.ext.wait_reason == Suspended
			|| info.ext.wait_reason == Executive // the thread is waiting got the scheduler
			|| info.ext.wait_reason == UserRequest // i.e. WaitForSingleObject/WaitForMultipleObjects
			|| info.ext.wait_reason == WrUserRequest // i.e. when the thread calls GetMessage
			)
		{
			return true;
		}
	}
	return false;
}

ThreadScanReport* pesieve::ThreadScanner::scanRemote()
{
	HANDLE hThread = OpenThread(
		THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | SYNCHRONIZE,
		FALSE,
		info.tid
	);
	if (!hThread) {
#ifdef _DEBUG
		std::cerr << "[-] Could not OpenThread. Error: " << GetLastError() << std::endl;
#endif
		return nullptr;
	}
#ifdef _DEBUG
	std::cout << std::dec << "---\nTid: " << info.tid << "\n";
	if (info.is_extended) {
		std::cout << " Start: " << std::hex << info.ext.start_addr << std::dec << " State: " << info.ext.state;
		if (info.ext.state == Waiting) {
			std::cout << " WaitReason: " << info.ext.wait_reason 
				<< " WaitTime: " << info.ext.wait_time;
		}
		std::cout << "\n";
		resolveAddr(info.ext.start_addr);
	}
#endif
	ThreadScanReport* my_report = new ThreadScanReport(info.tid);
#ifndef _DEBUG
	// if NOT compiled in a debug mode, make this check BEFORE scan
	if (!should_scan(info)) {
		CloseHandle(hThread); // close the opened thread
		my_report->status = SCAN_NOT_SUSPICIOUS;
		return my_report;
	}
#endif
	thread_ctx c = { 0 };
	const bool is_ok = fetchThreadCtx(processHandle, hThread, c);

	DWORD exit_code = 0;
	GetExitCodeThread(hThread, &exit_code);
	CloseHandle(hThread);

	if (!is_ok) {
		// could not fetch the thread context and information
		my_report->status = SCAN_ERROR;
		return my_report;
	}
#ifdef _DEBUG
	std::cout << " b:" << c.is64b << std::hex << " Rip: " << c.rip << " Rsp: " << c.rsp; 
	if (exit_code != STILL_ACTIVE) 
		std::cout << " ExitCode: " << exit_code;

	if (c.ret_addr != 0) {
		std::cout << std::hex << " Ret: " << c.ret_addr;
	}
	std::cout << "\n";
#endif

	if (exit_code != STILL_ACTIVE) {
		my_report->status = SCAN_NOT_SUSPICIOUS;
		return my_report;
	}
#ifdef _DEBUG
	// if compiled in a debug mode, make this check AFTER scan
	// (so that we can see first what was skipped)
	if (!should_scan(info)) {
		my_report->status = SCAN_NOT_SUSPICIOUS;
		return my_report;
	}
#endif
	bool is_shc = isAddrInShellcode(c.rip);
	if (is_shc) {
		if (reportSuspiciousAddr(my_report, c.rip, c)) {
			return my_report;
		}
	}
	if ((c.ret_addr != 0) && (c.is_managed == false)) {
		is_shc = isAddrInShellcode(c.ret_addr);
		if (is_shc) {
			if (reportSuspiciousAddr(my_report, c.ret_addr, c)) {
				return my_report;
			}
		}
	}
	return my_report;
}

```

`scanners/thread_scanner.h`:

```h
#pragma once

#include <windows.h>

#include "module_scanner.h"
#include "../utils/threads_util.h"

namespace pesieve {

	//!  A report from the thread scan, generated by ThreadScanner
	class ThreadScanReport : public ModuleScanReport
	{
	public:
		static const DWORD THREAD_STATE_UNKNOWN = (-1);
		static const DWORD THREAD_STATE_WAITING = 5;

		ThreadScanReport(DWORD _tid)
			: ModuleScanReport(0, 0), 
			tid(_tid), thread_ip(0), protection(0),
			thread_state(THREAD_STATE_UNKNOWN), thread_wait_reason(0)
		{
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			ModuleScanReport::_toJSON(outs, level);
			outs << ",\n";

			OUT_PADDED(outs, level, "\"thread_id\" : ");
			outs << std::dec << tid;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"thread_ip\" : ");
			outs << "\"" << std::hex << thread_ip << "\"";
			outs << ",\n";
			if (thread_state != THREAD_STATE_UNKNOWN) {
				OUT_PADDED(outs, level, "\"thread_state\" : ");
				outs << std::dec << thread_state;
				outs << ",\n";

				if (thread_state == THREAD_STATE_WAITING) {
					OUT_PADDED(outs, level, "\"thread_wait_reason\" : ");
					outs << std::dec << thread_wait_reason;
					outs << ",\n";
				}
			}
			OUT_PADDED(outs, level, "\"protection\" : ");
			outs << "\"" << std::hex << protection << "\"";
		}

		const virtual bool toJSON(std::stringstream& outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"thread_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		ULONGLONG thread_ip;
		DWORD tid;
		DWORD protection;
		DWORD thread_state;
		DWORD thread_wait_reason;
	};

	//!  A custom structure keeping a fragment of a thread context
	typedef struct _thread_ctx {
		bool is64b;
		ULONGLONG rip;
		ULONGLONG rsp;
		ULONGLONG rbp;
		ULONGLONG ret_addr; // the last return address on the stack (or the address of the first shellcode)
		bool is_managed; // does it contain .NET modules
	} thread_ctx;

	//!  A scanner for threads
	//!  Stack-scan inspired by the idea presented here: https://github.com/thefLink/Hunt-Sleeping-Beacons
	class ThreadScanner : public ProcessFeatureScanner {
	public:
		// neccessery to validly recognize stack frame
		static bool InitSymbols(HANDLE hProc);
		static bool FreeSymbols(HANDLE hProc);

		ThreadScanner(HANDLE hProc, const util::thread_info& _info, ModulesInfo& _modulesInfo, peconv::ExportsMapper* _exportsMap)
			: ProcessFeatureScanner(hProc), 
			info(_info), modulesInfo(_modulesInfo), exportsMap(_exportsMap)
		{
		}

		virtual ThreadScanReport* scanRemote();

	protected:

		bool isAddrInShellcode(ULONGLONG addr);
		bool resolveAddr(ULONGLONG addr);
		bool fetchThreadCtx(IN HANDLE hProcess, IN HANDLE hThread, OUT thread_ctx& c);
		size_t enumStackFrames(IN HANDLE hProcess, IN HANDLE hThread, IN LPVOID ctx, IN OUT thread_ctx& c);
		bool reportSuspiciousAddr(ThreadScanReport* my_report, ULONGLONG susp_addr, thread_ctx& c);

		const util::thread_info& info;
		ModulesInfo& modulesInfo;
		peconv::ExportsMapper* exportsMap;
	};

}; //namespace pesieve


```

`scanners/workingset_scanner.cpp`:

```cpp
#include "workingset_scanner.h"
#include "module_data.h"
#include "artefact_scanner.h"
#include "scanner.h"

#include "../utils/path_converter.h"
#include "../utils/workingset_enum.h"
#include "../utils/artefacts_util.h"

using namespace pesieve;
using namespace pesieve::util;

bool pesieve::WorkingSetScanner::isCode(MemPageData &memPageData)
{
	if (!memPage.load()) {
		return false;
	}
	return is_code(memPageData.getLoadedData(), memPageData.getLoadedSize());
}

bool pesieve::WorkingSetScanner::isExecutable(MemPageData &memPageData)
{
	if (pesieve::util::is_executable(memPage.mapping_type, memPage.protection)) {
		return true;
	}
	return isPotentiallyExecutable(memPageData, this->args.data);
}

bool pesieve::WorkingSetScanner::isPotentiallyExecutable(MemPageData &memPageData, const t_data_scan_mode &mode)
{
	if (mode == pesieve::PE_DATA_NO_SCAN) {
		return false;
	}

	// check preconditions:
	const bool is_managed = this->processReport.isManagedProcess();
	if (mode == pesieve::PE_DATA_SCAN_NO_DEP 
		&& memPage.is_dep_enabled && !is_managed)
	{
		return false;
	}
	if (mode == pesieve::PE_DATA_SCAN_DOTNET
		&& !is_managed)
	{
		return false;
	}
	// preconditions are fulfilled, now check the access:
	const bool is_page_readable = pesieve::util::is_readable(memPage.mapping_type, memPage.protection);
	if (mode != pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY) {
		if (is_page_readable) {
			return true;
		}
	}
	if ((mode >= pesieve::PE_DATA_SCAN_INACCESSIBLE) || (mode == pesieve::PE_DATA_SCAN_INACCESSIBLE_ONLY)) {
		if (this->isReflection && (memPage.protection & PAGE_NOACCESS)) {
			return true;
		}
	}
	return false;
}

WorkingSetScanReport* pesieve::WorkingSetScanner::scanExecutableArea(MemPageData &memPageData)
{
	if (!memPage.load()) {
		return nullptr;
	}
	// check for PE artifacts (regardless if it has shellcode patterns):
	if (!isScannedAsModule(memPage)) {
		ArtefactScanner artefactScanner(this->processHandle, this->isReflection, memPage, this->processReport);
		WorkingSetScanReport *my_report1 = artefactScanner.scanRemote();
		if (my_report1) {
			//pe artefacts found
			return my_report1;
		}
	}
	if (!this->args.shellcode) {
		// not a PE file, and we are not interested in shellcode, so just finish it here
		return nullptr;
	}
	if (!isCode(memPage)) {
		// shellcode patterns not found
		return nullptr;
	}
	//report about shellcode:
	ULONGLONG region_start = memPage.region_start;
	const size_t region_size = size_t (memPage.region_end - region_start);
	WorkingSetScanReport *my_report = new WorkingSetScanReport((HMODULE)region_start, region_size, SCAN_SUSPICIOUS);
	my_report->has_pe = isScannedAsModule(memPage) && this->processReport.hasModule(memPage.region_start);
	my_report->has_shellcode = true;
	return my_report;
}

bool pesieve::WorkingSetScanner::isScannedAsModule(MemPageData &memPage)
{
	if (memPage.mapping_type != MEM_IMAGE) {
		return false;
	}
	if (this->processReport.hasModule((ULONGLONG)memPage.alloc_base)) {
		return true; // it was already scanned as a PE
	}
	return false;
}

bool pesieve::WorkingSetScanner::scanImg()
{
	if (!memPage.loadMappedName()) {
		//cannot retrieve the mapped name
		return false;
	}

	const HMODULE module_start = (HMODULE)memPage.alloc_base;

	if (!args.quiet) {
		std::cout << "[!] Scanning detached: " << std::hex << module_start << " : " << memPage.mapped_name << std::endl;
	}
	RemoteModuleData remoteModData(this->processHandle, this->isReflection, module_start);
	if (!remoteModData.isInitialized()) {
		if (!args.quiet) {
			std::cout << "[-] Could not read the remote PE at: " << std::hex << module_start << std::endl;
		}
		return false;
	}

	//load module from file:
	ModuleData modData(processHandle, module_start, memPage.mapped_name, args.use_cache);
	if (!modData.loadOriginal()) {
		if (!args.quiet) {
			std::cerr << "[-] [" << std::hex << modData.moduleHandle << "] Could not read the module file" << std::endl;
		}
		processReport.appendReport(new UnreachableModuleReport(module_start, 0, memPage.mapped_name));
		return false;
	}
	t_scan_status scan_status = ProcessScanner::scanForHollows(processHandle, modData, remoteModData, processReport);
#ifdef _DEBUG
	std::cout << "[*] Scanned for hollows. Status: " << scan_status << std::endl;
#endif
	if (scan_status == SCAN_ERROR) {
		// failed scanning it as a loaded PE module
		return false;
	}
	if (scan_status == SCAN_SUSPICIOUS) {
		// detected as hollowed, no need for further scans
		return true;
	}
	if (!args.no_hooks) {
		const bool scan_data = (this->args.data >= pesieve::PE_DATA_SCAN_ALWAYS && this->args.data != PE_DATA_SCAN_INACCESSIBLE_ONLY)
			|| (!memPage.is_dep_enabled && (this->args.data == pesieve::PE_DATA_SCAN_NO_DEP));
		const bool scan_inaccessible = (this->isReflection && (this->args.data >= pesieve::PE_DATA_SCAN_INACCESSIBLE));
		scan_status = ProcessScanner::scanForHooks(processHandle, modData, remoteModData, processReport, scan_data, scan_inaccessible);
#ifdef _DEBUG
		std::cout << "[*] Scanned for hooks. Status: " << scan_status << std::endl;
#endif
	}
	return true;
}

WorkingSetScanReport* pesieve::WorkingSetScanner::scanRemote()
{
	if (!memPage.isInfoFilled() && !memPage.fillInfo()) {
#ifdef _DEBUG
		std::cout << "[!] Could not fill: " << std::hex << memPage.start_va << " to: " << memPage.region_end << "\n";
#endif
		return nullptr;
	}
	// is the page executable?
	const bool is_any_exec = isExecutable(memPage);
	if (!is_any_exec) {
		// probably not interesting
		return nullptr;
	}

	if (memPage.mapping_type == MEM_MAPPED && memPage.isRealMapping()) {
		//probably legit
		return nullptr;
	}

	if (memPage.mapping_type == MEM_IMAGE) {
		memPage.loadModuleName();
		memPage.loadMappedName();
		if (!isScannedAsModule(memPage)) {
			scanImg();
		}
		const size_t region_size = (memPage.region_end) ? (memPage.region_end - memPage.region_start) : 0;
		if (this->processReport.hasModuleContaining(memPage.region_start, region_size)) {
			// the area was already scanned
			return nullptr;
		}
	}
#ifdef _DEBUG
	std::cout << std::hex << memPage.start_va << ": Scanning executable area" << std::endl;
#endif
	WorkingSetScanReport* my_report = this->scanExecutableArea(memPage);
	if (!my_report) {
		return nullptr;
	}
	my_report->is_executable = true;
	my_report->protection = memPage.protection;
	my_report->mapping_type = memPage.mapping_type;
	my_report->mapped_name = memPage.mapped_name;
	return my_report;
}

```

`scanners/workingset_scanner.h`:

```h
#pragma once

#include <windows.h>
#include <psapi.h>
#include <map>

#include <peconv.h>
#include "module_scan_report.h"
#include "mempage_data.h"
#include "scan_report.h"

#include "../utils/format_util.h"
#include "process_feature_scanner.h"

namespace pesieve {

	//!  A report from the working set scan, generated by WorkingSetScanner
	class WorkingSetScanReport : public ModuleScanReport
	{
	public:
		WorkingSetScanReport(HMODULE _module, size_t _moduleSize, t_scan_status status)
			: ModuleScanReport(_module, _moduleSize, status)
		{
			is_executable = false;
			is_listed_module = false;
			protection = 0;
			has_pe = false; //not a PE file
			has_shellcode = true;
			mapping_type = 0;
		}

		const virtual bool toJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			OUT_PADDED(outs, level, "\"workingset_scan\" : {\n");
			fieldsToJSON(outs, level + 1, jdetails);
			outs << "\n";
			OUT_PADDED(outs, level, "}");
			return true;
		}

		const virtual void fieldsToJSON(std::stringstream &outs, size_t level, const pesieve::t_json_level &jdetails)
		{
			ModuleScanReport::_toJSON(outs, level);
			outs << ",\n";
			OUT_PADDED(outs, level, "\"has_pe\" : ");
			outs << std::dec << has_pe;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"has_shellcode\" : ");
			outs << std::dec << has_shellcode;
			if (!is_executable) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"is_executable\" : ");
				outs << std::dec << is_executable;
			}
			outs << ",\n";
			OUT_PADDED(outs, level, "\"is_listed_module\" : ");
			outs << std::dec << is_listed_module;
			outs << ",\n";
			OUT_PADDED(outs, level, "\"protection\" : ");
			outs << "\"" << std::hex << protection << "\"";
			outs << ",\n";
			OUT_PADDED(outs, level, "\"mapping_type\" : ");
			outs << "\"" << translate_mapping_type(mapping_type) << "\"";
			if (mapping_type == MEM_IMAGE || mapping_type == MEM_MAPPED) {
				outs << ",\n";
				OUT_PADDED(outs, level, "\"mapped_name\" : ");
				outs << "\"" << pesieve::util::escape_path_separators(mapped_name) << "\"";
			}
		}

		bool is_executable;
		bool is_listed_module;
		bool has_pe;
		bool has_shellcode;
		DWORD protection;
		DWORD mapping_type;
		std::string mapped_name; //if the region is mapped from a file

	protected:
		static std::string translate_mapping_type(DWORD type)
		{
			switch (type) {
			case MEM_PRIVATE: return "MEM_PRIVATE";
			case MEM_MAPPED: return "MEM_MAPPED";
			case MEM_IMAGE: return "MEM_IMAGE";
			}
			return "unknown";
		}
	};


	//!  A scanner for detection of code implants in the process workingset.
	class WorkingSetScanner : public ProcessFeatureScanner {
	public:
		WorkingSetScanner(HANDLE _procHndl, MemPageData &_memPageDatal, pesieve::t_params _args, ProcessScanReport& _process_report)
			: ProcessFeatureScanner(_procHndl), memPage(_memPageDatal), 
			isReflection(_memPageDatal.isRefl()),
			args(_args),
			processReport(_process_report)
		{
		}

		virtual ~WorkingSetScanner() {}

		virtual WorkingSetScanReport* scanRemote();

	protected:
		bool scanImg();
		bool isScannedAsModule(MemPageData &memPageData);

		bool isExecutable(MemPageData &memPageData);
		bool isPotentiallyExecutable(MemPageData &memPageData, const t_data_scan_mode &mode);
		bool isCode(MemPageData &memPageData);
		WorkingSetScanReport* scanExecutableArea(MemPageData &memPageData);

		const bool isReflection;
		MemPageData &memPage;

		ProcessScanReport& processReport;
		pesieve::t_params args;
	};

}; //namespace pesieve

```

`utils/artefacts_util.cpp`:

```cpp
#include "artefacts_util.h"
#include <peconv.h>

#ifdef _DEBUG
	#include <iostream>
#endif

BYTE* pesieve::util::find_pattern(BYTE *buffer, size_t buf_size, BYTE* pattern_buf, size_t pattern_size, size_t max_iter)
{
	for (size_t i = 0; (i + pattern_size) < buf_size; i++) {
		if (max_iter != 0 && i > max_iter) break;
		if (memcmp(buffer + i, pattern_buf, pattern_size) == 0) {
			return (buffer + i);
		}
	}
	return nullptr;
}

namespace pesieve {
	typedef struct {
		BYTE *ptr;
		size_t size;
	} t_pattern;
};

bool pesieve::util::is_32bit_code(BYTE *loadedData, size_t loadedSize)
{
	BYTE prolog32_pattern[] = {
		0x55, // PUSH EBP
		0x8b, 0xEC // MOV EBP, ESP
	};

	BYTE prolog32_2_pattern[] = {
		0x55, // PUSH EBP
		0x89, 0xE5 // MOV EBP, ESP
	};

	BYTE prolog32_3_pattern[] = {
		0x60, // PUSHAD
		0x89, 0xE5 // MOV EBP, ESP
	};

	t_pattern patterns[] = {
		{ prolog32_pattern,   sizeof(prolog32_pattern) },
		{ prolog32_2_pattern, sizeof(prolog32_2_pattern) },
		{ prolog32_3_pattern, sizeof(prolog32_3_pattern) }
	};

	bool pattern_found = false;
	for (size_t i = 0; i < _countof(patterns); i++) {
		if (find_pattern(loadedData, loadedSize, patterns[i].ptr, patterns[i].size)) {
			pattern_found = true;
			//std::cout << "Found 32bit pattern: " << i << "\n";
			break;
		}
	}
	return pattern_found;
}

bool pesieve::util::is_64bit_code(BYTE *loadedData, size_t loadedSize)
{
	BYTE prolog64_pattern[] = {
		0x40, 0x53,       // PUSH RBX
		0x48, 0x83, 0xEC // SUB RSP, <BYTE>
	};
	BYTE prolog64_2_pattern[] = {
		0x55,            // PUSH RBP
		0x48, 0x8B, 0xEC // MOV RBP, RSP
	};
	BYTE prolog64_3_pattern[] = {
		0x40, 0x55,      // PUSH RBP
		0x48, 0x83, 0xEC // SUB RSP, <BYTE>
	};
	BYTE prolog64_4_pattern[] = {
		0x53,            // PUSH RBX
		0x48, 0x81, 0xEC // SUB RSP, <DWORD>
	};
	BYTE prolog64_5_pattern[] = {
		0x48, 0x83, 0xE4, 0xF0 // AND rsp, FFFFFFFFFFFFFFF0; Align RSP to 16 bytes
	};
	BYTE prolog64_6_pattern[] = {
		0x57,            // PUSH RDI
		0x48, 0x89, 0xE7 // MOV RDI, RSP
	};

	t_pattern patterns[] = {
		{ prolog64_pattern,   sizeof(prolog64_pattern) },
		{ prolog64_2_pattern, sizeof(prolog64_2_pattern) },
		{ prolog64_3_pattern, sizeof(prolog64_3_pattern) },
		{ prolog64_4_pattern, sizeof(prolog64_4_pattern) },
		{ prolog64_5_pattern, sizeof(prolog64_5_pattern) },
		{ prolog64_6_pattern, sizeof(prolog64_6_pattern) }
	};

	bool pattern_found = false;
	for (size_t i = 0; i < _countof(patterns); i++) {
		if (find_pattern(loadedData, loadedSize, patterns[i].ptr, patterns[i].size)) {
			pattern_found = true;
			//std::cout << "Found 64bit pattern: " << i << "\n";
			break;
		}
	}
	return pattern_found;
}

bool pesieve::util::is_code(BYTE *loadedData, size_t loadedSize)
{
	if (peconv::is_padding(loadedData, loadedSize, 0)) {
		return false;
	}
	if (is_32bit_code(loadedData, loadedSize)) {
		return true;
	}
	if (is_64bit_code(loadedData, loadedSize)) {
		return true;
	}
	return false;
}

bool pesieve::util::is_executable(DWORD mapping_type, DWORD protection)
{
	const bool is_any_exec = (protection & PAGE_EXECUTE_READWRITE)
		|| (protection & PAGE_EXECUTE_READ)
		|| (protection & PAGE_EXECUTE)
		|| (protection & PAGE_EXECUTE_WRITECOPY);
	return is_any_exec;
}

bool pesieve::util::is_readable(DWORD mapping_type, DWORD protection)
{
	const bool is_read = (protection & PAGE_READWRITE)
		|| (protection & PAGE_READONLY);
	return is_read;
}

bool pesieve::util::is_normal_inaccessible(DWORD state, DWORD mapping_type, DWORD protection)
{
	if ((state & MEM_COMMIT) == 0) {
		//not committed
		return false;
	}
	if (mapping_type != MEM_IMAGE && (mapping_type != MEM_MAPPED) && mapping_type != MEM_PRIVATE) {
		// invalid mapping type
		return false;
	}
	if (protection & PAGE_NOACCESS) {
		// inaccessible found
		return true;
	}
	return false;
}

```

`utils/artefacts_util.h`:

```h
#pragma once
#include <windows.h>

namespace pesieve {
	namespace util {
		/*
		Scans the buffer of given size, in a search of the supplied pattern.
		If the number of iterations is not specified (0) it scans full space, otherwise it takes only max_iter number of steps.
		Returns the pointer to the found pattern, or nullptr if not found.
		*/
		BYTE* find_pattern(BYTE *buffer, size_t buf_size, BYTE* pattern_buf, size_t pattern_size, size_t max_iter = 0);

		bool is_32bit_code(BYTE *loadedData, size_t loadedSize);
		bool is_64bit_code(BYTE *loadedData, size_t loadedSize);

		bool is_code(BYTE *loadedData, size_t loadedSize);

		bool is_executable(DWORD mapping_type, DWORD protection);

		bool is_readable(DWORD mapping_type, DWORD protection);

		bool is_normal_inaccessible(DWORD state, DWORD mapping_type, DWORD protection);
	};
}

```

`utils/console_color.cpp`:

```cpp
#include "console_color.h"
#include <iostream>

namespace pesieve {
	namespace util {

		bool get_current_color(int descriptor, WORD &color) {
			CONSOLE_SCREEN_BUFFER_INFO info;
			if (!GetConsoleScreenBufferInfo(GetStdHandle(descriptor), &info))
				return false;
			color = info.wAttributes;
			return true;
		}

	}
};

void pesieve::util::print_in_color(int color, const std::string &text, bool is_error)
{
	int descriptor = is_error ? STD_ERROR_HANDLE : STD_OUTPUT_HANDLE;
	std::ostream &stream = is_error ? std::cerr : std::cout;

	WORD old_color = 7; //default
	get_current_color(descriptor, old_color);

	HANDLE hConsole = GetStdHandle(descriptor);
	FlushConsoleInputBuffer(hConsole);
	SetConsoleTextAttribute(hConsole, color); // back to default color

	stream << text;

	FlushConsoleInputBuffer(hConsole);
	SetConsoleTextAttribute(hConsole, old_color); // back to default color
	FlushConsoleInputBuffer(hConsole);

	stream.flush();
}

```

`utils/console_color.h`:

```h
#pragma once

#include <windows.h>
#include <string>

namespace pesieve {
	namespace util {

		void print_in_color(int color, const std::string &text, bool is_error=false);
	};
};

```

`utils/format_util.cpp`:

```cpp
#include "format_util.h"

#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cctype>

namespace pesieve {
	namespace util {

		bool is_hex(const char *buf, size_t len)
		{
			for (size_t i = 0; i < len; i++) {
				if (buf[i] >= '0' && buf[i] <= '9') continue;
				if (buf[i] >= 'A' && buf[i] <= 'F') continue;
				if (buf[i] >= 'a' && buf[i] <= 'f') continue;
				return false;
			}
			return true;
		}

		bool is_dec(const char *buf, size_t len)
		{
			for (size_t i = 0; i < len; i++) {
				if (buf[i] >= '0' && buf[i] <= '9') continue;
				return false;
			}
			return true;
		}

	};
};

long pesieve::util::get_number(const char *my_buf)
{
	const char hex_pattern[] = "0x";
	size_t hex_pattern_len = strlen(hex_pattern);

	const size_t len = strlen(my_buf);
	if (len == 0) return 0;

	long out = 0;
	const size_t min_length = 1; //tolerate number with at least 1 character
	if (len > hex_pattern_len) {
		if (is_cstr_equal(my_buf, hex_pattern, hex_pattern_len)) {
			if (!is_hex(my_buf + hex_pattern_len, min_length)) return 0;

			std::stringstream ss;
			ss << std::hex << my_buf;
			ss >> out;
			return out;
		}
	}
	if (!is_dec(my_buf, min_length)) return 0;

	std::stringstream ss;
	ss << std::dec << my_buf;
	ss >> out;
	return out;
}

bool pesieve::util::is_number(const char* my_buf)
{
	const char hex_pattern[] = "0x";
	size_t hex_pattern_len = strlen(hex_pattern);

	const size_t len = strlen(my_buf);
	if (len == 0) return false;

	if (len > hex_pattern_len) {
		if (is_cstr_equal(my_buf, hex_pattern, hex_pattern_len)) {
			if (!is_hex(my_buf + hex_pattern_len, len - hex_pattern_len)) return false;

			return true;
		}
	}
	if (!is_dec(my_buf, len)) return false;
	return true;
}

bool pesieve::util::is_in_list(std::string searched_str, std::set<std::string>& string_list, bool to_lower)
{
	bool result = false;
	if (to_lower) {
		std::transform(searched_str.begin(), searched_str.end(), searched_str.begin(), std::tolower);
	}
	std::set<std::string>::iterator found = string_list.find(searched_str);
	if (found != string_list.end()) {
		result = true;
	}
	return result;
}

namespace pesieve {
	namespace util {

		std::string& ltrim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
		{
			str.erase(0, str.find_first_not_of(chars));
			return str;
		}

		std::string& rtrim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
		{
			str.erase(str.find_last_not_of(chars) + 1);
			return str;
		}

		std::string& trim(std::string& str, const std::string& chars = "\t\n\v\f\r ")
		{
			return ltrim(rtrim(str, chars), chars);
		}
	}
};

size_t pesieve::util::string_to_list(IN::std::string s, IN char _delim, OUT::std::set<::std::string>& elements_list, bool to_lower)
{
	std::string delim(std::string(1, _delim));
	size_t start = 0;
	size_t end = s.find(delim);
	while (end != std::string::npos)
	{
		std::string next_str = s.substr(start, end - start);
		trim(next_str);
		if (next_str.length() > 0) {
			if (to_lower) {
				std::transform(next_str.begin(), next_str.end(), next_str.begin(), std::tolower);
			}
			elements_list.insert(next_str);
		}
		start = end + delim.length();
		end = s.find(delim, start);
	}
	std::string next_str = s.substr(start, end);
	trim(next_str);
	if (next_str.length() > 0) {
		if (to_lower) {
			std::transform(next_str.begin(), next_str.end(), next_str.begin(), std::tolower);
		}
		elements_list.insert(next_str);
	}
	return elements_list.size();
}

```

`utils/format_util.h`:

```h
#pragma once

#include <windows.h>

#include <string>
#include <set>
#include <sstream>
#include <iomanip>

#include "strings_util.h"

#define OUT_PADDED(stream, field_size, str) \
std::cout.fill(' '); \
if (field_size) stream << std::setw(field_size) << ' '; \
stream << str;

namespace pesieve {

	namespace util {

		/*
		Get hexadecimal or decimal number from a string. Hexadecimal numbers should be prefixed with "0x".
		*/
		long get_number(const char *buf);

		/*
		Checks if the buffer is a number (hexadecimal or decimal ). Hexadecimal numbers should be prefixed with "0x".
		*/
		bool is_number(const char* buf);

		// Checks if the given string is in the given set
		bool is_in_list(std::string searched_string, std::set<std::string>& string_list, bool to_lower=true);

		size_t string_to_list(IN::std::string s, IN char _delim, OUT std::set<std::string>& elements_list, bool to_lower=true);

	};
};


```

`utils/modules_enum.cpp`:

```cpp
#include "modules_enum.h"

#include <psapi.h>
#pragma comment(lib,"psapi.lib")

size_t pesieve::util::enum_modules(IN HANDLE hProcess, IN OUT HMODULE hMods[], IN const DWORD hModsMax, IN DWORD filters) //throws exceptions
{
	if (hProcess == nullptr) {
		return 0;
	}
	const char err_msg[] = "Could not enumerate modules. ";
	DWORD cbNeeded;
#ifdef _WIN64
	if (!EnumProcessModulesEx(hProcess, hMods, hModsMax, &cbNeeded, filters)) {
		throw std::runtime_error(err_msg);
		return 0;
	}
#else
	/*
	Some old, 32-bit versions of Windows do not have EnumProcessModulesEx,
	but we can use EnumProcessModules for the 32-bit version: it will work the same and prevent the compatibility issues.
	*/
	if (!EnumProcessModules(hProcess, hMods, hModsMax, &cbNeeded)) {
		throw std::runtime_error(err_msg);
		return 0;
	}
#endif
	const size_t modules_count = cbNeeded / sizeof(HMODULE);
	return modules_count;
}

```

`utils/modules_enum.h`:

```h
#pragma once

#include <windows.h>
#include <stdexcept>

namespace pesieve {
	namespace util {

		size_t enum_modules(IN HANDLE hProcess, IN OUT HMODULE hMods[], IN const DWORD hModsMax, IN DWORD filters); //throws exceptions
	};
};

```

`utils/ntddk.h`:

```h
#ifndef __NTDLL_H__
#define __NTDLL_H__

#ifdef __cplusplus
extern "C" {
#endif
#include <windows.h>

#ifdef _NTDDK_
#error This header cannot be compiled together with NTDDK
#endif

//Do not insert the library. Only definitions.
/*
#ifndef _NTDLL_SELF_                            // Auto-insert the library
#pragma comment(lib, "Ntdll.lib")
#endif
*/
#pragma warning(disable: 4201)                  // nonstandard extension used : nameless struct/union

#pragma warning(push)
#pragma warning(disable:4005)
#include <ntstatus.h>
#pragma warning(pop)

//------------------------------------------------------------------------------
// Defines for NTSTATUS

typedef long NTSTATUS;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS       ((NTSTATUS)0x00000000L)
#endif

#ifndef STATUS_UNSUCCESSFUL
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#endif

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(x) assert(x)
#else
#define ASSERT(x) /* x */
#endif
#endif

//------------------------------------------------------------------------------
// Structures

typedef enum _EVENT_TYPE
{
    NotificationEvent,
    SynchronizationEvent

} EVENT_TYPE;

//
// ANSI strings are counted 8-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

#ifndef _NTSECAPI_
typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR  Buffer;

} STRING, *PSTRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;

} UNICODE_STRING, *PUNICODE_STRING;
#endif // _NTSECAPI_

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

typedef const UNICODE_STRING *PCUNICODE_STRING;

#define UNICODE_NULL ((WCHAR)0) // winnt

//
// Valid values for the Attributes field
//

#ifndef OBJ_CASE_INSENSITIVE
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE

} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;
#endif  // OBJ_CASE_INSENSITIVE

//
// IO_STATUS_BLOCK
//

typedef struct _IO_STATUS_BLOCK
{
    union
    {
        NTSTATUS Status;
        PVOID Pointer;
    };

    ULONG_PTR Information;

} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

//
// ClientId
//

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;

} CLIENT_ID, *PCLIENT_ID;


//
// CURDIR structure
//

typedef struct _CURDIR
{
    UNICODE_STRING DosPath;
    HANDLE Handle;

} CURDIR, *PCURDIR;


//------------------------------------------------------------------------------
// Macros

// INIT_UNICODE_STRING is a replacement of RtlInitUnicodeString
#ifndef INIT_UNICODE_STRING
#define INIT_UNICODE_STRING(us, wch)                 \
    us.MaximumLength = (USHORT)sizeof(wch);          \
    us.Length        = (USHORT)(wcslen(wch) * sizeof(WCHAR)); \
    us.Buffer        = wch
#endif


#ifndef InitializeObjectAttributes
#define InitializeObjectAttributes( p, n, a, r, s ) {   \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#endif


#ifndef InitializePortHeader
#define InitializeMessageHeader( ph, l, t ) {                  \
    (ph)->TotalLength    = (USHORT)(l);                        \
    (ph)->DataLength     = (USHORT)(l - sizeof(PORT_MESSAGE)); \
    (ph)->Type           = (USHORT)(t);                        \
    (ph)->VirtualRangesOffset = 0;                             \
    }
#endif

//-----------------------------------------------------------------------------
// Image functions

NTSYSAPI
PVOID
NTAPI
RtlImageNtHeader (
	IN PVOID BaseAddress
	);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData (
	IN PVOID Base,
	IN BOOLEAN MappedAsImage,
	IN USHORT DirectoryEntry,
	OUT PULONG Size
	);

//-----------------------------------------------------------------------------
// Unicode string functions

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID( 
	IN REFGUID Guid,
	OUT PUNICODE_STRING GuidString
	);


NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING Destination,
    IN PCSTR Source
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    IN  BOOLEAN AllocateNew,
    IN  PUNICODE_STRING SourceString,
    OUT PUNICODE_STRING TargetString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    IN OUT PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToInteger (
    IN PUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    IN PUNICODE_STRING GuidString,
    OUT GUID *Guid
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString (
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );


NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    IN  PUNICODE_STRING UnicodeString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString (
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlInitAnsiString (
    OUT PANSI_STRING DestinationString,
    IN PCHAR SourceString
    );


NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString (
    IN PANSI_STRING AnsiString
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    OUT PUNICODE_STRING CurrentUserKeyPath
    );


NTSYSAPI
VOID
NTAPI
RtlRaiseStatus (
    IN NTSTATUS Status
    );


NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID
    );


NTSYSAPI
ULONG
_cdecl
DbgPrint (
    PCH Format,
    ...
    );


NTSYSAPI
ULONG
NTAPI
RtlRandom(
    IN OUT PULONG Seed
    );

//-----------------------------------------------------------------------------
// Critical section functions

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    IN  PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
BOOL
NTAPI
RtlTryEnterCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    IN  PRTL_CRITICAL_SECTION CriticalSection
    );

//-----------------------------------------------------------------------------
// Object functions

//
// Object Manager Directory Specific Access Rights.
//

#ifndef DIRECTORY_QUERY
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)
#endif

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} POOL_TYPE;


//
// For NtQueryObject
//

typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,          // = 0
    ObjectNameInformation,          // = 1
    ObjectTypeInformation,          // = 2
    ObjectTypesInformation,         // = 3    //object handle is ignored
    ObjectHandleFlagInformation     // = 4
} OBJECT_INFORMATION_CLASS;

//
// NtQueryObject uses ObjectBasicInformation
//

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

//
// NtQueryObject uses ObjectNameInformation
//

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

//
// NtQueryObject uses ObjectTypeInformation
//

typedef struct _OBJECT_TYPE_INFORMATION {
   UNICODE_STRING TypeName;
   ULONG TotalNumberOfObjects;
   ULONG TotalNumberOfHandles;
   ULONG TotalPagedPoolUsage;
   ULONG TotalNonPagedPoolUsage;
   ULONG TotalNamePoolUsage;
   ULONG TotalHandleTableUsage;
   ULONG HighWaterNumberOfObjects;
   ULONG HighWaterNumberOfHandles;
   ULONG HighWaterPagedPoolUsage;
   ULONG HighWaterNonPagedPoolUsage;
   ULONG HighWaterNamePoolUsage;
   ULONG HighWaterHandleTableUsage;
   ULONG InvalidAttributes;
   GENERIC_MAPPING GenericMapping;
   ULONG ValidAccessMask;
   BOOLEAN SecurityRequired;
   BOOLEAN MaintainHandleCount;
   POOL_TYPE PoolType;
   ULONG DefaultPagedPoolCharge;
   ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

//
// NtQueryObject uses ObjectHandleFlagInformation
// NtSetInformationObject uses ObjectHandleFlagInformation
//

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

//
// NtQueryDirectoryObject uses this type
//

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;


NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject (
    IN HANDLE ObjectHandle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    OUT PVOID ObjectInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject (
    IN HANDLE ObjectHandle,
    IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
    IN PVOID ObjectInformation,
    IN ULONG Length
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject (
    IN HANDLE SourceProcessHandle,
    IN HANDLE SourceHandle,
    IN HANDLE TargetProcessHandle OPTIONAL,
    OUT PHANDLE TargetHandle OPTIONAL,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG HandleAttributes,
    IN ULONG Options
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject (
    IN HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG DescriptorLength,
    OUT PULONG ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject (
    IN HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


//-----------------------------------------------------------------------------
// Handle table RTL functions

#define LEVEL_HANDLE_ID         0x74000000
#define LEVEL_HANDLE_ID_MASK    0xFF000000
#define LEVEL_HANDLE_INDEX_MASK 0x00FFFFFF

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;


typedef struct _RTL_SPLAY_LINKS
{
  struct _RTL_SPLAY_LINKS *Parent;
  struct _RTL_SPLAY_LINKS *LeftChild;
  struct _RTL_SPLAY_LINKS *RightChild;
} RTL_SPLAY_LINKS, *PRTL_SPLAY_LINKS;


struct _RTL_GENERIC_TABLE;

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI * PRTL_GENERIC_COMPARE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

typedef
PVOID
(NTAPI *PRTL_GENERIC_ALLOCATE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    ULONG ByteSize
    );

typedef
VOID
(NTAPI *PRTL_GENERIC_FREE_ROUTINE) (
    struct _RTL_GENERIC_TABLE *Table,
    PVOID Buffer
    );


typedef struct _RTL_GENERIC_TABLE {
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_GENERIC_TABLE, *PRTL_GENERIC_TABLE;


typedef struct _RTL_HANDLE_TABLE_ENTRY
{
   struct _RTL_HANDLE_TABLE_ENTRY *Next;    /* pointer to next free handle */
   PVOID  Object;

} RTL_HANDLE_TABLE_ENTRY, *PRTL_HANDLE_TABLE_ENTRY;


typedef struct _RTL_HANDLE_TABLE
{
   ULONG MaximumNumberOfHandles;
   ULONG SizeOfHandleTableEntry;
   ULONG Unknown01;
   ULONG Unknown02;
   PRTL_HANDLE_TABLE_ENTRY FreeHandles;
   PRTL_HANDLE_TABLE_ENTRY CommittedHandles;
   PRTL_HANDLE_TABLE_ENTRY UnCommittedHandles;
   PRTL_HANDLE_TABLE_ENTRY MaxReservedHandles;
} RTL_HANDLE_TABLE, *PRTL_HANDLE_TABLE;


NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine,
    IN PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    IN PRTL_GENERIC_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    );


NTSYSAPI
VOID
NTAPI
RtlInitializeHandleTable(
    IN ULONG MaximumNumberOfHandles,
    IN ULONG SizeOfHandleTableEntry,
    OUT PRTL_HANDLE_TABLE HandleTable
    );


NTSYSAPI
PRTL_HANDLE_TABLE_ENTRY
NTAPI
RtlAllocateHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    OUT PULONG HandleIndex OPTIONAL
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN PRTL_HANDLE_TABLE_ENTRY Handle
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsValidIndexHandle(
    IN PRTL_HANDLE_TABLE HandleTable,
    IN ULONG HandleIndex,
    OUT PRTL_HANDLE_TABLE_ENTRY *Handle
    );


NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN LONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmpty (
    IN PRTL_GENERIC_TABLE Table
    );


NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTable (
    IN PRTL_GENERIC_TABLE Table,
    IN PVOID Buffer
    );


NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplaying(
    IN  PRTL_GENERIC_TABLE Table,
    IN  PVOID *RestartKey
    );


NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    IN  HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwClose(
    IN  HANDLE Handle
    );

//-----------------------------------------------------------------------------
// Environment functions

NTSYSAPI
NTSTATUS
NTAPI
RtlOpenCurrentUser(
    IN ULONG DesiredAccess,
    OUT PHANDLE CurrentUserKey
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    BOOLEAN CloneCurrentEnvironment,
    PVOID *Environment
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U (
    PVOID Environment,
    PUNICODE_STRING Name,
    PUNICODE_STRING Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetEnvironmentVariable(
    PVOID *Environment,
    PUNICODE_STRING Name,
    PUNICODE_STRING Value
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    PVOID Environment
    );

//-----------------------------------------------------------------------------
// Registry functions


typedef enum _KEY_INFORMATION_CLASS
{
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    MaxKeyInfoClass  // MaxKeyInfoClass should always be the last enum

} KEY_INFORMATION_CLASS;

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;


typedef struct _KEY_NODE_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;


typedef struct _KEY_FULL_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length

} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;


// end_wdm
typedef struct _KEY_NAME_INFORMATION
{
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_NAME_INFORMATION, *PKEY_NAME_INFORMATION;

typedef struct _KEY_CACHED_INFORMATION
{
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string

} KEY_CACHED_INFORMATION, *PKEY_CACHED_INFORMATION;


typedef struct _KEY_FLAGS_INFORMATION
{
    ULONG   UserFlags;

} KEY_FLAGS_INFORMATION, *PKEY_FLAGS_INFORMATION;



typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    MaxKeyValueInfoClass  // MaxKeyValueInfoClass should always be the last enum
} KEY_VALUE_INFORMATION_CLASS;


typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;


typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;



NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    IN  ULONG TitleIndex,
    IN  PUNICODE_STRING Class OPTIONAL,
    IN  ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
           IN HANDLE  KeyHandle,
           IN KEY_INFORMATION_CLASS  KeyInformationClass,
           OUT PVOID  KeyInformation,
           IN ULONG  Length,
           OUT PULONG  ResultLength
    );

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    IN HANDLE KeyHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    OUT PVOID KeyValueInformation,
    IN ULONG Length,
    OUT PULONG ResultLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    );

//-----------------------------------------------------------------------------
// RtlQueryRegistryValues

//
// The following flags specify how the Name field of a RTL_QUERY_REGISTRY_TABLE
// entry is interpreted.  A NULL name indicates the end of the table.
//

#define RTL_QUERY_REGISTRY_SUBKEY   0x00000001  // Name is a subkey and remainder of
                                                // table or until next subkey are value
                                                // names for that subkey to look at.

#define RTL_QUERY_REGISTRY_TOPKEY   0x00000002  // Reset current key to original key for
                                                // this and all following table entries.

#define RTL_QUERY_REGISTRY_REQUIRED 0x00000004  // Fail if no match found for this table
                                                // entry.

#define RTL_QUERY_REGISTRY_NOVALUE  0x00000008  // Used to mark a table entry that has no
                                                // value name, just wants a call out, not
                                                // an enumeration of all values.

#define RTL_QUERY_REGISTRY_NOEXPAND 0x00000010  // Used to suppress the expansion of
                                                // REG_MULTI_SZ into multiple callouts or
                                                // to prevent the expansion of environment
                                                // variable values in REG_EXPAND_SZ

#define RTL_QUERY_REGISTRY_DIRECT   0x00000020  // QueryRoutine field ignored.  EntryContext
                                                // field points to location to store value.
                                                // For null terminated strings, EntryContext
                                                // points to UNICODE_STRING structure that
                                                // that describes maximum size of buffer.
                                                // If .Buffer field is NULL then a buffer is
                                                // allocated.
                                                //

#define RTL_QUERY_REGISTRY_DELETE   0x00000040  // Used to delete value keys after they
                                                // are queried.


//
// The following values for the RelativeTo parameter determine what the
// Path parameter to RtlQueryRegistryValues is relative to.
//

#define RTL_REGISTRY_ABSOLUTE     0             // Path is a full path
#define RTL_REGISTRY_SERVICES     1             // \Registry\Machine\System\CurrentControlSet\Services
#define RTL_REGISTRY_CONTROL      2             // \Registry\Machine\System\CurrentControlSet\Control
#define RTL_REGISTRY_WINDOWS_NT   3             // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
#define RTL_REGISTRY_DEVICEMAP    4             // \Registry\Machine\Hardware\DeviceMap
#define RTL_REGISTRY_USER         5             // \Registry\User\CurrentUser
#define RTL_REGISTRY_MAXIMUM      6
#define RTL_REGISTRY_HANDLE       0x40000000    // Low order bits are registry handle
#define RTL_REGISTRY_OPTIONAL     0x80000000    // Indicates the key node is optional


typedef NTSTATUS (NTAPI * PRTL_QUERY_REGISTRY_ROUTINE)(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

typedef struct _RTL_QUERY_REGISTRY_TABLE
{
    PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine;
    ULONG Flags;
    PWSTR Name;
    PVOID EntryContext;
    ULONG DefaultType;
    PVOID DefaultData;
    ULONG DefaultLength;

} RTL_QUERY_REGISTRY_TABLE, *PRTL_QUERY_REGISTRY_TABLE;


NTSYSAPI
NTSTATUS
NTAPI
RtlQueryRegistryValues(
    IN ULONG  RelativeTo,
    IN PCWSTR  Path,
    IN PRTL_QUERY_REGISTRY_TABLE  QueryTable,
    IN PVOID  Context,
    IN PVOID  Environment OPTIONAL
    );


//-----------------------------------------------------------------------------
// Query system information

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation,                 // 0x00 SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation,             // 0x01 SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation,           // 0x02
    SystemTimeOfDayInformation,             // 0x03
    SystemPathInformation,                  // 0x04
    SystemProcessInformation,               // 0x05
    SystemCallCountInformation,             // 0x06
    SystemDeviceInformation,                // 0x07
    SystemProcessorPerformanceInformation,  // 0x08
    SystemFlagsInformation,                 // 0x09
    SystemCallTimeInformation,              // 0x0A
    SystemModuleInformation,                // 0x0B SYSTEM_MODULE_INFORMATION
    SystemLocksInformation,                 // 0x0C
    SystemStackTraceInformation,            // 0x0D
    SystemPagedPoolInformation,             // 0x0E
    SystemNonPagedPoolInformation,          // 0x0F
    SystemHandleInformation,                // 0x10
    SystemObjectInformation,                // 0x11
    SystemPageFileInformation,              // 0x12
    SystemVdmInstemulInformation,           // 0x13
    SystemVdmBopInformation,                // 0x14
    SystemFileCacheInformation,             // 0x15
    SystemPoolTagInformation,               // 0x16
    SystemInterruptInformation,             // 0x17
    SystemDpcBehaviorInformation,           // 0x18
    SystemFullMemoryInformation,            // 0x19
    SystemLoadGdiDriverInformation,         // 0x1A
    SystemUnloadGdiDriverInformation,       // 0x1B
    SystemTimeAdjustmentInformation,        // 0x1C
    SystemSummaryMemoryInformation,         // 0x1D
    SystemNextEventIdInformation,           // 0x1E
    SystemEventIdsInformation,              // 0x1F
    SystemCrashDumpInformation,             // 0x20
    SystemExceptionInformation,             // 0x21
    SystemCrashDumpStateInformation,        // 0x22
    SystemKernelDebuggerInformation,        // 0x23
    SystemContextSwitchInformation,         // 0x24
    SystemRegistryQuotaInformation,         // 0x25
    SystemExtendServiceTableInformation,    // 0x26
    SystemPrioritySeperation,               // 0x27
    SystemPlugPlayBusInformation,           // 0x28
    SystemDockInformation,                  // 0x29
    //SystemPowerInformation,               // 0x2A
    //SystemProcessorSpeedInformation,      // 0x2B
    //SystemCurrentTimeZoneInformation,     // 0x2C
    //SystemLookasideInformation            // 0x2D

} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

//
// Thread priority
//

typedef LONG KPRIORITY;

//
// Basic System information
// NtQuerySystemInformation with SystemBasicInformation
//

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG MinimumUserModeAddress;
    ULONG MaximumUserModeAddress;
    KAFFINITY ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

//
// Processor information
// NtQuerySystemInformation with SystemProcessorInformation
//

typedef struct _SYSTEM_PROCESSOR_INFORMATION {
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;
    USHORT Reserved;
    ULONG ProcessorFeatureBits;
} SYSTEM_PROCESSOR_INFORMATION, *PSYSTEM_PROCESSOR_INFORMATION;

//
// Performance information
// NtQuerySystemInformation with SystemPerformanceInformation
//

typedef struct _SYSTEM_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleProcessTime;
    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
    ULONG IoReadOperationCount;
    ULONG IoWriteOperationCount;
    ULONG IoOtherOperationCount;
    ULONG AvailablePages;
    ULONG CommittedPages;
    ULONG CommitLimit;
    ULONG PeakCommitment;
    ULONG PageFaultCount;
    ULONG CopyOnWriteCount;
    ULONG TransitionCount;
    ULONG CacheTransitionCount;
    ULONG DemandZeroCount;
    ULONG PageReadCount;
    ULONG PageReadIoCount;
    ULONG CacheReadCount;
    ULONG CacheIoCount;
    ULONG DirtyPagesWriteCount;
    ULONG DirtyWriteIoCount;
    ULONG MappedPagesWriteCount;
    ULONG MappedWriteIoCount;
    ULONG PagedPoolPages;
    ULONG NonPagedPoolPages;
    ULONG PagedPoolAllocs;
    ULONG PagedPoolFrees;
    ULONG NonPagedPoolAllocs;
    ULONG NonPagedPoolFrees;
    ULONG FreeSystemPtes;
    ULONG ResidentSystemCodePage;
    ULONG TotalSystemDriverPages;
    ULONG TotalSystemCodePages;
    ULONG NonPagedPoolLookasideHits;
    ULONG PagedPoolLookasideHits;
    ULONG Spare3Count;
    ULONG ResidentSystemCachePage;
    ULONG ResidentPagedPoolPage;
    ULONG ResidentSystemDriverPage;
    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadResourceMiss;
    ULONG CcFastReadNotPossible;
    ULONG CcFastMdlReadNoWait;
    ULONG CcFastMdlReadWait;
    ULONG CcFastMdlReadResourceMiss;
    ULONG CcFastMdlReadNotPossible;
    ULONG CcMapDataNoWait;
    ULONG CcMapDataWait;
    ULONG CcMapDataNoWaitMiss;
    ULONG CcMapDataWaitMiss;
    ULONG CcPinMappedDataCount;
    ULONG CcPinReadNoWait;
    ULONG CcPinReadWait;
    ULONG CcPinReadNoWaitMiss;
    ULONG CcPinReadWaitMiss;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;
    ULONG CcCopyReadWaitMiss;
    ULONG CcMdlReadNoWait;
    ULONG CcMdlReadWait;
    ULONG CcMdlReadNoWaitMiss;
    ULONG CcMdlReadWaitMiss;
    ULONG CcReadAheadIos;
    ULONG CcLazyWriteIos;
    ULONG CcLazyWritePages;
    ULONG CcDataFlushes;
    ULONG CcDataPages;
    ULONG ContextSwitches;
    ULONG FirstLevelTbFills;
    ULONG SecondLevelTbFills;
    ULONG SystemCalls;
} SYSTEM_PERFORMANCE_INFORMATION, *PSYSTEM_PERFORMANCE_INFORMATION;

//
// Time of Day information
// NtQuerySystemInformation with SystemTimeOfDayInformation
//

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;


/// <summary>
/// Thread information
/// </summary>

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, * PKTHREAD_STATE;


typedef enum _KWAIT_REASON
{
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    MaximumWaitReason
} KWAIT_REASON, * PKWAIT_REASON;


typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, * PSYSTEM_THREAD_INFORMATION;

//
// Process information
// NtQuerySystemInformation with SystemProcessInformation
//

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
    ULONG HardFaultCount; // since WIN7
    ULONG NumberOfThreadsHighWatermark; // since WIN7
    ULONGLONG CycleTime; // since WIN7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
    ULONG HandleCount;
    
    // Next part is platform dependent

    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation


} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

//
// Device information
// NtQuerySystemInformation with SystemDeviceInformation
//

typedef struct _SYSTEM_DEVICE_INFORMATION {
    ULONG NumberOfDisks;
    ULONG NumberOfFloppies;
    ULONG NumberOfCdRoms;
    ULONG NumberOfTapes;
    ULONG NumberOfSerialPorts;
    ULONG NumberOfParallelPorts;
} SYSTEM_DEVICE_INFORMATION, *PSYSTEM_DEVICE_INFORMATION;

//
// Processor performance information
// NtQuerySystemInformation with SystemProcessorPerformanceInformation
//

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    LARGE_INTEGER IdleTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER DpcTime;          // DEVL only
    LARGE_INTEGER InterruptTime;    // DEVL only
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION, *PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

//
// NT Global Flag information
// NtQuerySystemInformation with SystemFlagsInformation
//

typedef struct _SYSTEM_FLAGS_INFORMATION
{
    ULONG GlobalFlag;

} SYSTEM_FLAGS_INFORMATION, *PSYSTEM_FLAGS_INFORMATION;

//
// System Module information
// NtQuerySystemInformation with SystemModuleInformation
//

typedef struct _SYSTEM_MODULE
{
    ULONG  Reserved1;                   // Should be 0xBAADF00D
    ULONG  Reserved2;                   // Should be zero
    PVOID  Base;
    ULONG  Size;
    ULONG  Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR   ImageName[256];

} SYSTEM_MODULE, *PSYSTEM_MODULE;


typedef struct _SYSTEM_MODULE_INFORMATION
{
    ULONG         ModulesCount;
    SYSTEM_MODULE Modules[1];

} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

/*
typedef struct _SYSTEM_VDM_INSTEMUL_INFO {
    ULONG SegmentNotPresent ;
    ULONG VdmOpcode0F       ;
    ULONG OpcodeESPrefix    ;
    ULONG OpcodeCSPrefix    ;
    ULONG OpcodeSSPrefix    ;
    ULONG OpcodeDSPrefix    ;
    ULONG OpcodeFSPrefix    ;
    ULONG OpcodeGSPrefix    ;
    ULONG OpcodeOPER32Prefix;
    ULONG OpcodeADDR32Prefix;
    ULONG OpcodeINSB        ;
    ULONG OpcodeINSW        ;
    ULONG OpcodeOUTSB       ;
    ULONG OpcodeOUTSW       ;
    ULONG OpcodePUSHF       ;
    ULONG OpcodePOPF        ;
    ULONG OpcodeINTnn       ;
    ULONG OpcodeINTO        ;
    ULONG OpcodeIRET        ;
    ULONG OpcodeINBimm      ;
    ULONG OpcodeINWimm      ;
    ULONG OpcodeOUTBimm     ;
    ULONG OpcodeOUTWimm     ;
    ULONG OpcodeINB         ;
    ULONG OpcodeINW         ;
    ULONG OpcodeOUTB        ;
    ULONG OpcodeOUTW        ;
    ULONG OpcodeLOCKPrefix  ;
    ULONG OpcodeREPNEPrefix ;
    ULONG OpcodeREPPrefix   ;
    ULONG OpcodeHLT         ;
    ULONG OpcodeCLI         ;
    ULONG OpcodeSTI         ;
    ULONG BopCount          ;
} SYSTEM_VDM_INSTEMUL_INFO, *PSYSTEM_VDM_INSTEMUL_INFO;


typedef struct _SYSTEM_QUERY_TIME_ADJUST_INFORMATION {
    ULONG TimeAdjustment;
    ULONG TimeIncrement;
    BOOLEAN Enable;
} SYSTEM_QUERY_TIME_ADJUST_INFORMATION, *PSYSTEM_QUERY_TIME_ADJUST_INFORMATION;

typedef struct _SYSTEM_SET_TIME_ADJUST_INFORMATION {
    ULONG TimeAdjustment;
    BOOLEAN Enable;
} SYSTEM_SET_TIME_ADJUST_INFORMATION, *PSYSTEM_SET_TIME_ADJUST_INFORMATION;


typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    ULONG WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_MEMORY_INFO {
    PUCHAR StringOffset;
    USHORT ValidCount;
    USHORT TransitionCount;
    USHORT ModifiedCount;
    USHORT PageTableCount;
} SYSTEM_MEMORY_INFO, *PSYSTEM_MEMORY_INFO;

typedef struct _SYSTEM_MEMORY_INFORMATION {
    ULONG InfoSize;
    ULONG StringStart;
    SYSTEM_MEMORY_INFO Memory[1];
} SYSTEM_MEMORY_INFORMATION, *PSYSTEM_MEMORY_INFORMATION;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION {
    ULONG Length;
    ULONG NumberOfTables;
    //ULONG NumberOfEntries[NumberOfTables];
    //ULONG CallCounts[NumberOfTables][NumberOfEntries];
} SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_CRASH_DUMP_INFORMATION {
    HANDLE CrashDumpSection;
} SYSTEM_CRASH_DUMP_INFORMATION, *PSYSTEM_CRASH_DUMP_INFORMATION;

typedef struct _SYSTEM_EXCEPTION_INFORMATION {
    ULONG AlignmentFixupCount;
    ULONG ExceptionDispatchCount;
    ULONG FloatingEmulationCount;
    ULONG ByteWordEmulationCount;
} SYSTEM_EXCEPTION_INFORMATION, *PSYSTEM_EXCEPTION_INFORMATION;

typedef struct _SYSTEM_CRASH_STATE_INFORMATION {
    ULONG ValidCrashDump;
} SYSTEM_CRASH_STATE_INFORMATION, *PSYSTEM_CRASH_STATE_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {
    ULONG RegistryQuotaAllowed;
    ULONG RegistryQuotaUsed;
    ULONG PagedPoolSize;
} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;

typedef struct _SYSTEM_GDI_DRIVER_INFORMATION {
    UNICODE_STRING DriverName;
    PVOID ImageAddress;
    PVOID SectionPointer;
    PVOID EntryPoint;
    PIMAGE_EXPORT_DIRECTORY ExportSectionPointer;
} SYSTEM_GDI_DRIVER_INFORMATION, *PSYSTEM_GDI_DRIVER_INFORMATION;
*/

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength
    );

//------------------------------------------------------------------------------
// Shutdown system

typedef enum _SHUTDOWN_ACTION
{
    ShutdownNoReboot,
    ShutdownReboot,
    ShutdownPowerOff

} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;


NTSYSAPI
NTSTATUS
NTAPI
NtShutdownSystem(
    IN SHUTDOWN_ACTION Action
    );

//-----------------------------------------------------------------------------
// File functions

#ifndef OLD_DOS_VOLID
#define OLD_DOS_VOLID   0x00000008
#endif

#ifndef FILE_SUPERSEDE
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005
#endif  // File create flags


// Define the create/open option flags
#ifndef FILE_DIRECTORY_FILE
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008
#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080
#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800
#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000
#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000
#endif // FILE_DIRECTORY_FILE


//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
//

#ifndef FILE_SUPERSEDED
#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005
#endif


#ifndef PIO_APC_ROUTINE_DEFINED
typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );
#define PIO_APC_ROUTINE_DEFINED
#endif  // PIO_APC_ROUTINE_DEFINED


typedef enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation         = 1,
    FileFullDirectoryInformation,   // 2
    FileBothDirectoryInformation,   // 3
    FileBasicInformation,           // 4  wdm
    FileStandardInformation,        // 5  wdm
    FileInternalInformation,        // 6
    FileEaInformation,              // 7
    FileAccessInformation,          // 8
    FileNameInformation,            // 9
    FileRenameInformation,          // 10
    FileLinkInformation,            // 11
    FileNamesInformation,           // 12
    FileDispositionInformation,     // 13
    FilePositionInformation,        // 14 wdm
    FileFullEaInformation,          // 15
    FileModeInformation,            // 16
    FileAlignmentInformation,       // 17
    FileAllInformation,             // 18
    FileAllocationInformation,      // 19
    FileEndOfFileInformation,       // 20 wdm
    FileAlternateNameInformation,   // 21
    FileStreamInformation,          // 22
    FilePipeInformation,            // 23
    FilePipeLocalInformation,       // 24
    FilePipeRemoteInformation,      // 25
    FileMailslotQueryInformation,   // 26
    FileMailslotSetInformation,     // 27
    FileCompressionInformation,     // 28
    FileObjectIdInformation,        // 29
    FileCompletionInformation,      // 30
    FileMoveClusterInformation,     // 31
    FileQuotaInformation,           // 32
    FileReparsePointInformation,    // 33
    FileNetworkOpenInformation,     // 34
    FileAttributeTagInformation,    // 35
    FileTrackingInformation,        // 36
    FileIdBothDirectoryInformation, // 37
    FileIdFullDirectoryInformation, // 38
    FileValidDataLengthInformation, // 39
    FileShortNameInformation,       // 40
    FileIoCompletionNotificationInformation, // 41
    FileIoStatusBlockRangeInformation,       // 42
    FileIoPriorityHintInformation,           // 43
    FileSfioReserveInformation,              // 44
    FileSfioVolumeInformation,               // 45
    FileHardLinkInformation,                 // 46
    FileProcessIdsUsingFileInformation,      // 47
    FileMaximumInformation                   // 48
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;


typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;


typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;


typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;


typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;


typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;


typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;


typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;


typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;


typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;


typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;


typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;


typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;


typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;


typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;


typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;


typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;


typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;


typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;


typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;


typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_PIPE_INFORMATION {
     ULONG ReadMode;
     ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;


typedef struct _FILE_PIPE_LOCAL_INFORMATION {
     ULONG NamedPipeType;
     ULONG NamedPipeConfiguration;
     ULONG MaximumInstances;
     ULONG CurrentInstances;
     ULONG InboundQuota;
     ULONG ReadDataAvailable;
     ULONG OutboundQuota;
     ULONG WriteQuotaAvailable;
     ULONG NamedPipeState;
     ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;


typedef struct _FILE_PIPE_REMOTE_INFORMATION {
     LARGE_INTEGER CollectDataTime;
     ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;


typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;


typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;


typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;


typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;


typedef struct _FILE_OBJECTID_INFORMATION
{
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        } ;
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;


typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;


typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;


typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;


typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;


typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;


typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;


typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;


typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;


typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;


typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;



typedef enum _FSINFOCLASS {
    FileFsVolumeInformation       = 1,
    FileFsLabelInformation,      // 2
    FileFsSizeInformation,       // 3
    FileFsDeviceInformation,     // 4
    FileFsAttributeInformation,  // 5
    FileFsControlInformation,    // 6
    FileFsFullSizeInformation,   // 7
    FileFsObjectIdInformation,   // 8
    FileFsDriverPathInformation, // 9
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;


NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PLARGE_INTEGER AllocationSize,
    IN  ULONG FileAttributes,
    IN  ULONG ShareAccess,
    IN  ULONG CreateDisposition,
    IN  ULONG CreateOptions,
    IN  PVOID EaBuffer,
    IN  ULONG EaLength);


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PLARGE_INTEGER AllocationSize,
    IN  ULONG FileAttributes,
    IN  ULONG ShareAccess,
    IN  ULONG CreateDisposition,
    IN  ULONG CreateOptions,
    IN  PVOID EaBuffer,
    IN  ULONG EaLength);


NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN  ULONG Length,
    IN  BOOLEAN ReturnSingleEntry,
    IN  PVOID EaList OPTIONAL,
    IN  ULONG EaListLength,
    IN  PULONG EaIndex OPTIONAL,
    IN  BOOLEAN RestartScan);


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN  ULONG Length,
    IN  BOOLEAN ReturnSingleEntry,
    IN  PVOID EaList OPTIONAL,
    IN  ULONG EaListLength,
    IN  PULONG EaIndex OPTIONAL,
    IN  BOOLEAN RestartScan);


NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID Buffer,
    IN  ULONG Length);


NTSYSAPI
NTSTATUS
NTAPI
ZwSetEaFile(
    IN  HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID Buffer,
    IN  ULONG Length);


NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    IN  HANDLE FileHandle,
    IN  HANDLE Event,
    IN  PIO_APC_ROUTINE ApcRoutine,
    IN  PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  ULONG IoControlCode,
    IN  PVOID InputBuffer,
    IN  ULONG InputBufferLength,
    IN  PVOID OutputBuffer,
    IN  ULONG OutputBufferLength
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN  HANDLE FileHandle,
    IN  HANDLE Event,
    IN  PIO_APC_ROUTINE ApcRoutine,
    IN  PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  ULONG IoControlCode,
    IN  PVOID InputBuffer,
    IN  ULONG InputBufferLength,
    IN  PVOID OutputBuffer,
    IN  ULONG OutputBufferLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtCancelIoFile(
    IN HANDLE Filehandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCancelIoFile(
    IN HANDLE Filehandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U (
    IN  PWSTR DosPathName,
    OUT PUNICODE_STRING NtPathName,
    OUT PWSTR * NtFileNamePart OPTIONAL,
    OUT PCURDIR DirectoryInfo OPTIONAL
    );


//-----------------------------------------------------------------------------
// Process functions

#define GDI_HANDLE_BUFFER_SIZE      34

//
// Process Information Classes
//

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    ProcessDeviceMap,
    ProcessSessionInformation,
    ProcessForegroundInformation,
    ProcessWow64Information,
    ProcessImageFileName,
    ProcessLUIDDeviceMapsEnabled,
    ProcessBreakOnTermination,
    ProcessDebugObjectHandle,
    ProcessDebugFlags,
    ProcessHandleTracing,
    MaxProcessInfoClass                             // MaxProcessInfoClass should always be the last enum
} PROCESSINFOCLASS;

//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,                            // ??
    ThreadTimes,
    ThreadPriority,                                    // ??
    ThreadBasePriority,                                // ??
    ThreadAffinityMask,                                // ??
    ThreadImpersonationToken,                        // HANDLE
    ThreadDescriptorTableEntry,                        // ULONG Selector + LDT_ENTRY
    ThreadEnableAlignmentFaultFixup,                // ??
    ThreadEventPair,                                // ??
    ThreadQuerySetWin32StartAddress,                // ??
    ThreadZeroTlsCell,                                // ??
    ThreadPerformanceCount,                            // ??
    ThreadAmILastThread,                            // ??
    ThreadIdealProcessor,                            // ??
    ThreadPriorityBoost,                            // ??
    ThreadSetTlsArrayAddress,                        // ??
    MaxThreadInfoClass
} THREADINFOCLASS;


typedef struct _RTL_DRIVE_LETTER_CURDIR
{
    USHORT Flags;
    USHORT Length;
    ULONG  TimeStamp;
    STRING DosPath;

} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;


typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    ULONG MaximumLength;                            // Should be set before call RtlCreateProcessParameters
    ULONG Length;                                   // Length of valid structure
    ULONG Flags;                                    // Currently only PPF_NORMALIZED (1) is known:
                                                    //  - Means that structure is normalized by call RtlNormalizeProcessParameters
    ULONG DebugFlags;

    PVOID ConsoleHandle;                            // HWND to console window associated with process (if any).
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;                        // Specified in DOS-like symbolic link path, ex: "C:/WinNT/SYSTEM32"
    UNICODE_STRING DllPath;                         // DOS-like paths separated by ';' where system should search for DLL files.
    UNICODE_STRING ImagePathName;                   // Full path in DOS-like format to process'es file image.
    UNICODE_STRING CommandLine;                     // Command line
    PVOID Environment;                              // Pointer to environment block (see RtlCreateEnvironment)
    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;                            // Fill attribute for console window
    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;                     // Name of WindowStation and Desktop objects, where process is assigned
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectores[0x20];
    ULONG EnvironmentSize;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

//
// Process Environment Block
//

typedef struct _PEB_FREE_BLOCK
{
    struct _PEB_FREE_BLOCK *Next;
    ULONG Size;

} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;


typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;               // Points to the loaded modules (main EXE usually)
    LIST_ENTRY InMemoryOrderModuleList;             // Points to all modules (EXE and all DLLs)
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID      EntryInProgress;

} PEB_LDR_DATA, *PPEB_LDR_DATA;


typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;                             // Base address of the module
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG  Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    PVOID SectionPointer;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    PVOID LoadedImports;
    PVOID EntryPointActivationContext;
    PVOID PatchInformation;
    PVOID Unknown1;
    PVOID Unknown2;
    PVOID Unknown3;

} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


typedef struct _PEB
{
    BOOLEAN InheritedAddressSpace;      // These four fields cannot change unless the
    BOOLEAN ReadImageFileExecOptions;   //
    BOOLEAN BeingDebugged;              //
    BOOLEAN SpareBool;                  //
    HANDLE Mutant;                      // INITIAL_PEB structure is also updated.

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID FastPebLockRoutine;
    PVOID FastPebUnlockRoutine;
    ULONG EnvironmentUpdateCount;
    PVOID KernelCallbackTable;
    HANDLE SystemReserved;
    PVOID  AtlThunkSListPtr32;
    PPEB_FREE_BLOCK FreeList;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];         // relates to TLS_MINIMUM_AVAILABLE
    PVOID ReadOnlySharedMemoryBase;
    PVOID ReadOnlySharedMemoryHeap;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    //
    // Useful information for LdrpInitialize

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    //
    // Passed up from MmCreatePeb from Session Manager registry key
    //

    LARGE_INTEGER CriticalSectionTimeout;
    ULONG HeapSegmentReserve;
    ULONG HeapSegmentCommit;
    ULONG HeapDeCommitTotalFreeThreshold;
    ULONG HeapDeCommitFreeBlockThreshold;

    //
    // Where heap manager keeps track of all heaps created for a process
    // Fields initialized by MmCreatePeb.  ProcessHeaps is initialized
    // to point to the first free byte after the PEB and MaximumNumberOfHeaps
    // is computed from the page size used to hold the PEB, less the fixed
    // size of this data structure.
    //

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    //
    //
    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    PVOID GdiDCAttributeList;
    PVOID LoaderLock;

    //
    // Following fields filled in by MmCreatePeb from system values and/or
    // image header. These fields have changed since Windows NT 4.0,
    // so use with caution
    //

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG ImageProcessAffinityMask;
    ULONG GdiHandleBuffer[GDI_HANDLE_BUFFER_SIZE];

} PEB, *PPEB;


//
// Thread environment block
//

typedef struct _TEB
{
    NT_TIB NtTib;
    PVOID  EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    // Incomplete

} TEB, *PTEB;


typedef struct _PROCESS_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;

} PROCESS_BASIC_INFORMATION,*PPROCESS_BASIC_INFORMATION;



#define NtCurrentProcess() ((HANDLE) -1)
#define NtCurrentThread()  ((HANDLE) -2)

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

NTSYSCALLAPI
	NTSTATUS
	NTAPI
	NtSuspendProcess(
	IN HANDLE ProcessHandle
	);

NTSYSCALLAPI
	NTSTATUS
	NTAPI
	NtResumeProcess(
	IN HANDLE ProcessHandle
	);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread (
    OUT PHANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

NTSYSAPI
	NTSTATUS
	NTAPI
	NtQueryInformationThread(
	IN HANDLE  ThreadHandle,
	IN THREADINFOCLASS  ThreadInformationClass,
	OUT PVOID  ThreadInformation,
	IN ULONG  ThreadInformationLength,
	OUT PULONG  ReturnLength  OPTIONAL
	);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess (
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
    );

//------------------------------------------------------------------------------
// LPC Functions

#define MAX_LPC_DATA 0x130    // Maximum number of bytes that can be copied through LPC

// LPC connection types
typedef enum _LPC_TYPE
{
    LPC_NEW_MESSAGE,                    // (0) A new message
    LPC_REQUEST,                        // (1) A request message
    LPC_REPLY,                          // (2) A reply to a request message
    LPC_DATAGRAM,                       // (3)
    LPC_LOST_REPLY,                     // (4)
    LPC_PORT_CLOSED,                    // (5) Send when port is deleted
    LPC_CLIENT_DIED,                    // (6) Messages to thread termination ports
    LPC_EXCEPTION,                      // (7) Messages to thread exception ports
    LPC_DEBUG_EVENT,                    // (8) Messages to thread debug port
    LPC_ERROR_EVENT,                    // (9) Used by NtRaiseHardError
    LPC_CONNECTION_REQUEST              // (A) Used by NtConnectPort

} LPC_TYPE, *PLPC_TYPE;

//
// Define header for Port Message
//

typedef struct _PORT_MESSAGE
{
    USHORT DataLength;                  // Length of data following the header (bytes)
    USHORT TotalLength;                 // Length of data + sizeof(PORT_MESSAGE)
    USHORT Type;                        // Type of the message (See LPC_TYPE enum)
    USHORT VirtualRangesOffset;         // Offset of array of virtual address ranges
    CLIENT_ID ClientId;                 // Client identifier of the message sender
    ULONG  MessageId;                   // Identifier of the particular message instance
    union
    {
        ULONG  CallbackId;              //
        ULONG  ClientViewSize;          // Size, in bytes, of section created by the sender
    };

} PORT_MESSAGE, *PPORT_MESSAGE;

//
// Define structure for initializing shared memory on the caller's side of the port
//

typedef struct _PORT_VIEW {

    ULONG  Length;                      // Size of this structure
    HANDLE SectionHandle;               // Handle to section object with
                                        // SECTION_MAP_WRITE and SECTION_MAP_READ
    ULONG  SectionOffset;               // The offset in the section to map a view for
                                        // the port data area. The offset must be aligned
                                        // with the allocation granularity of the system.
    ULONG  ViewSize;                    // The size of the view (in bytes)
    PVOID  ViewBase;                    // The base address of the view in the creator
                                        //
    PVOID  ViewRemoteBase;              // The base address of the view in the process
                                        // connected to the port.
} PORT_VIEW, *PPORT_VIEW;

//
// Define structure for shared memory coming from remote side of the port
//

typedef struct _REMOTE_PORT_VIEW {

    ULONG Length;                       // Size of this structure
    ULONG ViewSize;                     // The size of the view (bytes)
    PVOID ViewBase;                     // Base address of the view

} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;

/*++

    NtCreatePort
    ============

    Creates a LPC port object. The creator of the LPC port becomes a server
    of LPC communication

    PortHandle - Points to a variable that will receive the
        port object handle if the call is successful.

    ObjectAttributes - Points to a structure that specifies the object s
        attributes. OBJ_KERNEL_HANDLE, OBJ_OPENLINK, OBJ_OPENIF, OBJ_EXCLUSIVE,
        OBJ_PERMANENT, and OBJ_INHERIT are not valid attributes for a port object.

    MaxConnectionInfoLength - The maximum size, in bytes, of data that can
        be sent through the port.

    MaxMessageLength - The maximum size, in bytes, of a message
        that can be sent through the port.

    MaxPoolUsage - Specifies the maximum amount of NonPaged pool that can be used for
        message storage. Zero means default value.

    ZwCreatePort verifies that (MaxDataSize <= 0x104) and (MaxMessageSize <= 0x148).

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    OUT PHANDLE PortHandle,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    IN  ULONG MaxConnectionInfoLength,
    IN  ULONG MaxMessageLength,
    IN  ULONG MaxPoolUsage
    );


/*++

    NtConnectPort
    =============

    Creates a port connected to a named port (cliend side).

    PortHandle - A pointer to a variable that will receive the client
        communication port object handle value.

    PortName - Points to a structure that specifies the name
        of the port to connect to.

    SecurityQos - Points to a structure that specifies the level
        of impersonation available to the port listener.

    ClientView - Optionally points to a structure describing
        the shared memory region used to send large amounts of data
        to the listener; if the call is successful, this will be updated.

    ServerView - Optionally points to a caller-allocated buffer
        or variable that receives information on the shared memory region
        used by the listener to send large amounts of data to the
        caller.

    MaxMessageLength - Optionally points to a variable that receives the size,
        in bytes, of the largest message that can be sent through the port.

    ConnectionInformation - Optionally points to a caller-allocated
        buffer or variable that specifies connect data to send to the listener,
        and receives connect data sent by the listener.

    ConnectionInformationLength - Optionally points to a variable that
        specifies the size, in bytes, of the connect data to send
        to the listener, and receives the size of the connect data
        sent by the listener.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    OUT PHANDLE PortHandle,
    IN  PUNICODE_STRING PortName,
    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN  OUT PPORT_VIEW ClientView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN  OUT PVOID ConnectionInformation OPTIONAL,
    IN  OUT PULONG ConnectionInformationLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN  PUNICODE_STRING PortName,
    IN  PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN  OUT PPORT_VIEW ClientView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN  OUT PVOID ConnectionInformation OPTIONAL,
    IN  OUT PULONG ConnectionInformationLength OPTIONAL
    );


/*++

    NtListenPort
    ============

    Listens on a port for a connection request message on the server side.

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ConnectionRequest - Points to a caller-allocated buffer
        or variable that receives the connect message sent to
        the port.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    IN  HANDLE PortHandle,
    OUT PPORT_MESSAGE RequestMessage
    );

/*++

    NtAcceptConnectPort
    ===================

    Accepts or rejects a connection request on the server side.

    PortHandle - Points to a variable that will receive the port object
        handle if the call is successful.

    PortContext - A numeric identifier to be associated with the port.

    ConnectionRequest - Points to a caller-allocated buffer or variable
        that identifies the connection request and contains any connect
        data that should be returned to requestor of the connection

    AcceptConnection - Specifies whether the connection should
        be accepted or not

    ServerView - Optionally points to a structure describing
        the shared memory region used to send large amounts of data to the
        requestor; if the call is successful, this will be updated

    ClientView - Optionally points to a caller-allocated buffer
        or variable that receives information on the shared memory
        region used by the requestor to send large amounts of data to the
        caller

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    OUT PHANDLE PortHandle,
    IN  PVOID PortContext OPTIONAL,
    IN  PPORT_MESSAGE ConnectionRequest,
    IN  BOOLEAN AcceptConnection,
    IN  OUT PPORT_VIEW ServerView OPTIONAL,
    OUT PREMOTE_PORT_VIEW ClientView OPTIONAL
    );

/*++

    NtCompleteConnectPort
    =====================

    Completes the port connection process on the server side.

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    IN  HANDLE PortHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCompleteConnectPort(
    IN  HANDLE PortHandle
    );


/*++

    NtRequestPort
    =============

    Sends a request message to a port (client side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    RequestMessage - Points to a caller-allocated buffer or variable
        that specifies the request message to send to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort (
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage
    );

/*++

    NtRequestWaitReplyPort
    ======================

    Sends a request message to a port and waits for a reply (client side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    RequestMessage - Points to a caller-allocated buffer or variable
        that specifies the request message to send to the port.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that receives the reply message sent to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwRequestWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    );


/*++

    NtReplyPort
    ===========

    Sends a reply message to a port (Server side)

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that specifies the reply message to send to the port.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    IN  HANDLE PortHandle,
    IN  PPORT_MESSAGE ReplyMessage
    );

/*++

    NtReplyWaitReplyPort
    ====================

    Sends a reply message to a port and waits for a reply message

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    ReplyMessage - Points to a caller-allocated buffer or variable
        that specifies the reply message to send to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    IN  HANDLE PortHandle,
    IN  OUT PPORT_MESSAGE ReplyMessage
    );


/*++

    NtReplyWaitReceivePort
    ======================

    Optionally sends a reply message to a port and waits for a
    message

    PortHandle - A handle to a port object. The handle doesn't need
        to grant any specific access.

    PortContext - Optionally points to a variable that receives
        a numeric identifier associated with the port.

    ReplyMessage - Optionally points to a caller-allocated buffer
        or variable that specifies the reply message to send to the port.

    ReceiveMessage - Points to a caller-allocated buffer or variable
        that receives the message sent to the port.

--*/

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    IN  HANDLE PortHandle,
    OUT PVOID *PortContext OPTIONAL,
    IN  PPORT_MESSAGE ReplyMessage OPTIONAL,
    OUT PPORT_MESSAGE ReceiveMessage
    );

//-----------------------------------------------------------------------------
// Heap functions

#define HEAP_NO_SERIALIZE               0x00000001
#define HEAP_GROWABLE                   0x00000002
#define HEAP_GENERATE_EXCEPTIONS        0x00000004
#define HEAP_ZERO_MEMORY                0x00000008
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020
#define HEAP_FREE_CHECKING_ENABLED      0x00000040
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080
#define HEAP_CREATE_ALIGN_16            0x00010000
#define HEAP_CREATE_ENABLE_TRACING      0x00020000
#define HEAP_MAXIMUM_TAG                0x0FFF
#define HEAP_PSEUDO_TAG_FLAG            0x8000

//
// Data structure for heap definition. This includes various
// sizing parameters and callback routines, which, if left NULL,
// result in default behavior
//

typedef struct RTL_HEAP_PARAMETERS {
    ULONG Length;        //sizeof(RTL_HEAP_PARAMETERS)
    ULONG SegmentReserve;
    ULONG SegmentCommit;
    ULONG DeCommitFreeBlockThreshold;
    ULONG DeCommitTotalFreeThreshold;
    ULONG MaximumAllocationSize;
    ULONG VirtualMemoryThreshold;
    ULONG InitialCommit;
    ULONG InitialReserve;
    PVOID CommitRoutine;
    ULONG Reserved;
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;


#define RtlProcessHeap() (HANDLE)(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessHeap)


NTSYSAPI
HANDLE
NTAPI
RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID BaseAddress OPTIONAL,
    IN ULONG SizeToReserve,
    IN ULONG SizeToCommit,
    IN BOOLEAN Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Definition OPTIONAL
    );


NTSYSAPI
ULONG
NTAPI
RtlDestroyHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN ULONG Size
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );


NTSYSAPI
ULONG
NTAPI
RtlCompactHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlLockHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlUnlockHeap (
    IN HANDLE HeapHandle
    );


NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG Size
    );


NTSYSAPI
ULONG
NTAPI
RtlSizeHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlValidateHeap (
    IN HANDLE HeapHandle,
    IN ULONG Flags,
    IN PVOID Address OPTIONAL
    );


//-----------------------------------------------------------------------------
// Virtual memory functions

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PULONG RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwFreeVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    );


NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    OUT PVOID Buffer,
    IN ULONG NumberOfBytesToRead,
    OUT PULONG NumberOfBytesRead OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress,
    IN PVOID Buffer,
    IN ULONG NumberOfBytesToWrite,
    OUT PULONG NumberOfBytesWritten OPTIONAL
    );


//-----------------------------------------------------------------------------
// Section functions

typedef enum _SECTION_INHERIT
{
    ViewShare = 1,
    ViewUnmap = 2

} SECTION_INHERIT;


typedef enum _SECTION_INFORMATION_CLASS
{
    SectionBasicInformation,
    SectionImageInformation

} SECTION_INFORMATION_CLASS, *PSECTION_INFORMATION_CLASS;


/*++

    NtCreateSection
    ===============

    Creates a section object.

    SectionHandle - Points to a variable that will receive the section
        object handle if the call is successful.

    DesiredAccess - Specifies the type of access that the caller requires
        to the section object. This parameter can be zero, or any combination
        of the following flags:

        SECTION_QUERY       - Query access
        SECTION_MAP_WRITE   - Can be written when mapped
        SECTION_MAP_READ    - Can be read when mapped
        SECTION_MAP_EXECUTE - Can be executed when mapped
        SECTION_EXTEND_SIZE - Extend access
        SECTION_ALL_ACCESS  - All of the preceding +
                              STANDARD_RIGHTS_REQUIRED

    ObjectAttributes - Points to a structure that specifies the object s attributes.
        OBJ_OPENLINK is not a valid attribute for a section object.

    MaximumSize - Optionally points to a variable that specifies the size,
        in bytes, of the section. If FileHandle is zero, the size must be
        specified; otherwise, it can be defaulted from the size of the file
        referred to by FileHandle.

    SectionPageProtection - The protection desired for the pages
        of the section when the section is mapped. This parameter can take
        one of the following values:

        PAGE_READONLY
        PAGE_READWRITE
        PAGE_WRITECOPY
        PAGE_EXECUTE
        PAGE_EXECUTE_READ
        PAGE_EXECUTE_READWRITE
        PAGE_EXECUTE_WRITECOPY

    AllocationAttributes - The attributes for the section. This parameter must
        be a combination of the following values:

        SEC_BASED     0x00200000    // Map section at same address in each process
        SEC_NO_CHANGE 0x00400000    // Disable changes to protection of pages
        SEC_IMAGE     0x01000000    // Map section as an image
        SEC_VLM       0x02000000    // Map section in VLM region
        SEC_RESERVE   0x04000000    // Reserve without allocating pagefile storage
        SEC_COMMIT    0x08000000    // Commit pages; the default behavior
        SEC_NOCACHE   0x10000000    // Mark pages as non-cacheable

    FileHandle - Identifies the file from which to create the section object.
        The file must be opened with an access mode compatible with the protection
        flags specified by the Protect parameter. If FileHandle is zero,
        the function creates a section object of the specified size backed
        by the paging file rather than by a named file in the file system.

--*/


NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    OUT PHANDLE SectionHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN  PLARGE_INTEGER MaximumSize OPTIONAL,
    IN  ULONG SectionPageProtection,
    IN  ULONG AllocationAttributes,
    IN  HANDLE FileHandle OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSection(
    OUT PHANDLE SectionHandle,
    IN  ACCESS_MASK DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN  PLARGE_INTEGER MaximumSize OPTIONAL,
    IN  ULONG SectionPageProtection,
    IN  ULONG AllocationAttributes,
    IN  HANDLE FileHandle OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenSection (
    OUT PHANDLE SectionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PULONG ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwMapViewOfSection (
    IN HANDLE SectionHandle,
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG ZeroBits,
    IN ULONG CommitSize,
    IN OUT PLARGE_INTEGER SectionOffset OPTIONAL,
    IN OUT PULONG ViewSize,
    IN SECTION_INHERIT InheritDisposition,
    IN ULONG AllocationType,
    IN ULONG Protect
    );


NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwUnmapViewOfSection (
    IN HANDLE ProcessHandle,
    IN PVOID BaseAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER SectionSize
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwExtendSection (
    IN HANDLE SectionHandle,
    IN OUT PLARGE_INTEGER SectionSize
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySection (
    IN HANDLE SectionHandle,
    IN SECTION_INFORMATION_CLASS SectionInformationClass,
    OUT PVOID SectionInformation,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


//-----------------------------------------------------------------------------
// Synchronization

//
// Wait type
//

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny
    } WAIT_TYPE;


NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handle[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwWaitForMultipleObjects (
    IN ULONG Count,
    IN HANDLE Handle[],
    IN WAIT_TYPE WaitType,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );


//-----------------------------------------------------------------------------
// Event support

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation    // = 0
} EVENT_INFORMATION_CLASS;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

//
// Event handling routines
//


NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN EVENT_TYPE EventType,
    IN BOOLEAN InitialState
    );


NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent (
    IN HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwClearEvent (
    IN HANDLE Handle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwPulseEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwResetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwSetEvent (
    IN HANDLE Handle,
    OUT PLONG PreviousState OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInfoClass,
    OUT PVOID EventInfo,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
ZwQueryEvent (
    IN HANDLE EventHandle,
    IN EVENT_INFORMATION_CLASS EventInfoClass,
    OUT PVOID EventInfo,
    IN ULONG Length,
    OUT PULONG ResultLength OPTIONAL
    );


//-----------------------------------------------------------------------------
// Security descriptor functions

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG Revision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN DaclPresent,
    IN PACL Dacl OPTIONAL,
    IN BOOLEAN DaclDefaulted OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PSID Owner OPTIONAL,
    IN BOOLEAN OwnerDefaulted OPTIONAL
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );


NTSYSAPI
ULONG
NTAPI
RtlLengthSid (
    IN PSID Sid
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid (
    IN PSID Sid1,
    IN PSID Sid2
    );


NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    IN PSID Sid
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG AceFlags,
    IN ULONG AccessMask,
    IN PSID Sid
    );

//-----------------------------------------------------------------------------
// Token functions

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    IN HANDLE  TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    OUT PVOID  TokenInformation,
    IN ULONG  TokenInformationLength,
    OUT PULONG  ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    IN HANDLE  TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN PVOID  TokenInformation,
    IN ULONG  TokenInformationLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );


NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    IN  HANDLE FirstTokenHandle,
    IN  HANDLE SecondTokenHandle,
    OUT PBOOLEAN IdenticalTokens
    );


//-----------------------------------------------------------------------------
// Symbolic links

//
// Object Manager Symbolic Link Specific Access Rights.
//

#ifndef SYMBOLIC_LINK_QUERY
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#endif

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSymbolicLinkObject (
    OUT PHANDLE SymbolicLinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );


NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject (
    IN HANDLE SymbolicLinkHandle,
    OUT PUNICODE_STRING NameString,
    OUT PULONG ResultLength OPTIONAL
    );

//-----------------------------------------------------------------------------
// Loader functions

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID * DllHandle
    );


NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    IN PVOID DllHandle,
    IN PANSI_STRING ProcedureName OPTIONAL,
    IN ULONG ProcedureNumber OPTIONAL,
    OUT PVOID *ProcedureAddress
    );


NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    IN PWSTR DllPath OPTIONAL,
    IN PULONG DllCharacteristics OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
	IN PVOID Address,
	OUT PLDR_DATA_TABLE_ENTRY *Module
	);

NTSYSAPI
VOID
NTAPI
	RtlGetCallersAddress(
	OUT PVOID  *CallersAddress,
	OUT PVOID  *CallersCaller
	);

//-----------------------------------------------------------------------------
// Functions dealing with NTSTATUS and Win32 error

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    NTSTATUS Status
    );


NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    NTSTATUS Status
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    );


NTSYSAPI
ULONG
NTAPI
RtlGetLastWin32Error(
    );


NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    ULONG WinError
    );


NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    NTSTATUS Status
    );


//-----------------------------------------------------------------------------
// I/O functions


NTSYSAPI
NTSTATUS
NTAPI
NtDisplayString(
    IN PUNICODE_STRING String
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // __NTDLL_H__

```

`utils/path_converter.cpp`:

```cpp
#include "path_converter.h"

#include <windows.h>

#include "ntddk.h"
#pragma comment(lib, "Ntdll.lib")

#include <shlwapi.h>
#pragma comment (lib, "shlwapi.lib")

#include <iostream>
#include <string>
#include <locale>
#include <codecvt>

#include "path_util.h"

#define LONG_PATH_PREFIX "\\\\?\\"
#define GLOBALROOT_NAME "GLOBALROOT"

char g_System32Path[MAX_PATH] = { 0 }; //= "C:\\Windows\\system32";
char g_Syswow64Path[MAX_PATH] = { 0 }; //= "C:\\Windows\\SysWOW64";

namespace pesieve {
	namespace util {

		void init_syspaths()
		{
			if (!g_System32Path[0]) {
				memset(g_System32Path, 0, MAX_PATH);
				ExpandEnvironmentStringsA("%SystemRoot%\\system32", g_System32Path, MAX_PATH);
			}
			if (!g_Syswow64Path[0]) {
				memset(g_Syswow64Path, 0, MAX_PATH);
				ExpandEnvironmentStringsA("%SystemRoot%\\SysWoW64", g_Syswow64Path, MAX_PATH);
			}
		}

		HANDLE nt_create_file(PCWSTR filePath)
		{
			HANDLE hFile;
			OBJECT_ATTRIBUTES objAttribs = { 0 };

			UNICODE_STRING unicodeString;
			RtlInitUnicodeString(&unicodeString, filePath);

			InitializeObjectAttributes(&objAttribs, &unicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

			const int allocSize = 2048;
			LARGE_INTEGER largeInteger;
			largeInteger.QuadPart = allocSize;

			IO_STATUS_BLOCK ioStatusBlock = { 0 };
			NTSTATUS status = NtCreateFile(&hFile,
				STANDARD_RIGHTS_READ,
				&objAttribs,
				&ioStatusBlock,
				&largeInteger,
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ,
				FILE_OPEN,
				FILE_NON_DIRECTORY_FILE,
				NULL,
				NULL
			);
			if (status != STATUS_SUCCESS) {
				std::wcerr << "Cannot open file: " << filePath << ". Error: " << std::hex << status << std::endl;
				return nullptr;
			}
			return hFile;
		}

		std::string nt_retrieve_file_path(HANDLE hFile)
		{
			IO_STATUS_BLOCK status_block = { 0 };

			struct MY_FILE_NAME_INFORMATION {
				ULONG FileNameLength;
				WCHAR FileName[MAX_PATH];
			} name_info;

			memset(&name_info, 0, sizeof(MY_FILE_NAME_INFORMATION));

			NTSTATUS status = ZwQueryInformationFile(hFile, &status_block, &name_info, sizeof(MY_FILE_NAME_INFORMATION), FileNameInformation);
			if (status != STATUS_SUCCESS) {
				return "";
			}
			std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
			std::string my_string = converter.to_bytes(name_info.FileName);

			my_string = get_system_drive() + my_string;
			return my_string;
		}

		bool is_relative(const char *path, size_t path_len)
		{
			if (path_len < 2) {
				return true;
			}
			// i.e. "c:\"
			if (path[1] == ':') {
				return false;
			}
			// i.e. "\\path1\" or "\\?\UNC\"
			if (path[0] == '\\' && path[1] == '\\') {
				return false;
			}
			return true;
		}

		bool is_disk_relative(const char *path, size_t path_len)
		{
			if (path_len < 2) {
				return true;
			}
			//check format:
			if ((path[0] >= 'a' && path[0] <= 'z')
				|| (path[0] >= 'A' && path[0] <= 'Z'))
			{
				if (path[1] == ':') {
					// format i.e: C:\...
					return true;
				}
			}
			return false;
		}

		std::string remap_to_drive_letter(std::string full_path)
		{
			size_t full_path_size = full_path.length();
			if (full_path_size == 0) {
				return full_path;
			}

			DWORD drives_bitmask = GetLogicalDrives();
			//std::cout << "Drives: " << std::hex << drives_bitmask << std::endl;

			for (DWORD i = 0; i < 32; i += 1, drives_bitmask >>= 1) {
				if ((drives_bitmask & 1) == 1) {
					char letter[] = "?:";
					letter[0] = 'A' + (char)i;
					//std::cout << "Drive: " << letter << std::endl;
					char out_path[MAX_PATH] = { 0 };
					if (!QueryDosDeviceA(letter, out_path, MAX_PATH)) {
						return full_path;
					}
					//QueryDosDeviceA returns all possible mappings pointing to this drive letter, divided by a delimiter: ";"
					//sometimes one device letter is mapped to several paths
					// i.e. "\Device\VBoxMiniRdr\;E:\vboxsrv\vm_shared"
					const char delim[] = ";";
					char *next_token = nullptr;

					char * pch = strtok_s(out_path, delim, &next_token);
					while (pch != nullptr) {
						// check if the current path starts from any of the mapped paths
						std::size_t found = full_path.find(pch);
						if (found != std::string::npos && found == 0) {
							size_t dir_len = strlen(pch);
							//if so, cut out the mappining path/device path and replace it with a drive letter
							std::string str2 = full_path.substr(dir_len, full_path_size);
							if (str2[0] != '//' && str2[0] != '\\') {
								str2 = "\\" + str2;
							}
							return letter + str2;
						}
						pch = strtok_s(nullptr, delim, &next_token);
					}
				}
			}
			return full_path;
		}

		std::string relative_to_absolute_path(std::string path)
		{
			if (is_relative(path.c_str(), path.length())) {
				char current_dir[MAX_PATH] = { 0 };
				GetCurrentDirectoryA(MAX_PATH, current_dir);
				path = std::string(current_dir) + "\\" + path;
			}
			char out_path[MAX_PATH] = { 0 };
			PathCanonicalizeA(out_path, path.c_str());
			return std::string(out_path);
		}

		std::string replace_char(std::string &str, char ch1, char ch2) {
			for (size_t i = 0; i < str.length(); ++i) {
				if (str[i] == ch1)
					str[i] = ch2;
			}
			return str;
		}
	};
};

bool pesieve::util::convert_to_wow64_path(char *szModName)
{
	init_syspaths();
	if (!get_subpath_ptr(szModName, g_System32Path)) {
		return false;
	}
	size_t sysPathLen = strlen(g_Syswow64Path);
	memcpy(szModName, g_Syswow64Path, sysPathLen);
	return true;
}

std::string pesieve::util::convert_to_win32_path(const std::string &path)
{
	std::string stripped_path = strip_prefix(path, LONG_PATH_PREFIX);
	if (stripped_path.length() < 3) {
		return "";
	}
	//check format:
	if (is_disk_relative(stripped_path.c_str(), stripped_path.length())) {
		return stripped_path;
	}
	stripped_path = strip_prefix(stripped_path, GLOBALROOT_NAME);
	const char *szModName = stripped_path.c_str();
	std::wstring unicode_name(szModName, szModName + strlen(szModName));
	HANDLE hFile = nt_create_file(unicode_name.c_str());
	if (hFile == nullptr) {
		return "";
	}
	std::string my_path = nt_retrieve_file_path(hFile);
	CloseHandle(hFile);
	return my_path;
}

std::string pesieve::util::device_path_to_win32_path(const std::string &full_path)
{
	std::string path = full_path;
	//sometimes mapping can be recursive, so resolve it till the root
	do {
		std::string remapped_path = remap_to_drive_letter(path);
		if (remapped_path == path) break;
		path = remapped_path;
	} while (true);
	return path;
}

bool is_device_path(std::string path)
{
	const std::string device_path = "\\Device\\";
	if (path.length() < device_path.length() || path[0] !='\\') {
		return false;
	}
	if (path.compare(0, device_path.length(), device_path) == 0){
		return true;
	}
	return false;
}

std::string pesieve::util::expand_path(std::string path)
{
	std::string basic_path = pesieve::util::device_path_to_win32_path(path);
	if (is_device_path(basic_path)) {
		// Could not normalize it: it is still a device path. Return as is.
		return path;
	}
	// normalize path sepators: use '/' not '\'
	replace_char(basic_path, '/', '\\');

	std::string abs_path = relative_to_absolute_path(basic_path);
	
	char filename[MAX_PATH] = { 0 };
	if (GetLongPathNameA(abs_path.c_str(), filename, MAX_PATH) == 0) {
		size_t len = abs_path.length();
		if (len > MAX_PATH) len = MAX_PATH;
		//if could not retrieve, process what you have:
		memcpy(filename, abs_path.c_str(), len);
	}
	return strip_prefix(filename, LONG_PATH_PREFIX);
}


```

`utils/path_converter.h`:

```h
#pragma once

#include <iostream>

namespace pesieve {

	namespace util {

		//convert from System32 path to the WoW64 equivalent:
		bool convert_to_wow64_path(char *szModName);

		//converts path in format: \SystemRoot\... to format: C:\...
		std::string convert_to_win32_path(const std::string &path);

		//converts path in format i.e.: \Device\HarddiskVolume2\... to format: C:\...
		std::string device_path_to_win32_path(const std::string &full_path);

		std::string expand_path(std::string path);

	};
};


```

`utils/path_util.cpp`:

```cpp
#include "path_util.h"

#include "format_util.h"

char* pesieve::util::get_subpath_ptr(char *modulePath, char* searchedPath)
{
	if (modulePath == nullptr || searchedPath == nullptr) {
		return nullptr;
	}
	size_t modNameLen = strlen(modulePath);
	size_t sysPathLen = strlen(searchedPath);
	size_t i = 0;
	for (; i < modNameLen && i < sysPathLen; i++) {
		char c1 = tolower(modulePath[i]);
		char c2 = tolower(searchedPath[i]);
		if (c1 == '/') c1 = '\\'; //normalize
		if (c1 != c2) {
			break;
		}
	}
	if (i == sysPathLen) {
		return modulePath + i;
	}
	return nullptr;
}

std::string pesieve::util::escape_path_separators(std::string path)
{
	size_t pos = std::string::npos;
	size_t prev = 0;
	const char to_escape = '\\';
	const std::string escaped = "\\\\";
	do
	{
		pos = path.find(to_escape, prev);
		if (pos == std::string::npos) break;

		path.replace(pos, 1, escaped);
		prev = pos + escaped.length();

	} while (pos < path.length() && prev < path.length());

	return path;
}

std::string pesieve::util::get_system_drive()
{
	char buf[MAX_PATH];
	GetWindowsDirectory(buf, MAX_PATH);
	buf[2] = '\0'; // cut after the drive letter
	return std::string(buf);
}

std::string get_full_path(const char* szPath)
{
	char out_buf[MAX_PATH] = { 0 };
	if (GetFullPathNameA(szPath, MAX_PATH, out_buf, nullptr) == 0) {
		return "";
	}
	return out_buf;
}

bool pesieve::util::dir_exists(const char* szPath)
{
	DWORD dwAttrib = GetFileAttributes(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

bool pesieve::util::create_dir_recursively(const std::string& in_path)
{
	std::string path = get_full_path(in_path.c_str());
	if (path.length() == 0) path = in_path;

	if (dir_exists(path.c_str())) {
		return true;
	}
	size_t pos = 0;
	do
	{
		pos = path.find_first_of("\\/", pos + 1);
		if (CreateDirectoryA(path.substr(0, pos).c_str(), NULL) == FALSE) {
			if (GetLastError() != ERROR_ALREADY_EXISTS) {
				return false;
			}
		}
	} while (pos != std::string::npos);
	return true;
}

std::string pesieve::util::strip_prefix(std::string path, std::string prefix)
{
	const size_t prefix_len = prefix.length();
	if (prefix_len == 0) {
		return path;
	}
	// case insensitive:
	std::string my_path = to_lowercase(path);
	prefix = to_lowercase(prefix);

	size_t found_index = my_path.find(prefix);
	if (found_index != std::string::npos
		&& found_index == 0) //the found string must be at the beginning
	{
		path.erase(found_index, prefix_len);
	}
	return path;
}


```

`utils/path_util.h`:

```h
#pragma once

#include <windows.h>
#include <sstream>
#include <iomanip>

namespace pesieve {
	namespace util{

		char* get_subpath_ptr(char *modulePath, char* searchedPath);

		// Add escape characters to path separators
		std::string escape_path_separators(std::string path);

		// Get system drive letter, i.e. "C:"
		std::string get_system_drive();

		bool dir_exists(const char* path);

		bool create_dir_recursively(const std::string& path);

		// Find given prefix in the string, and remove it if found. Case insensitive.
		std::string strip_prefix(std::string path, std::string prefix);
	};
};

```

`utils/process_minidump.cpp`:

```cpp
#include "process_minidump.h"
#include "process_privilege.h"
#include <dbghelp.h>

namespace pesieve {
	namespace util {

		BOOL(CALLBACK *_MiniDumpWriteDump)(
			HANDLE                            hProcess,
			DWORD                             ProcessId,
			HANDLE                            hFile,
			MINIDUMP_TYPE                     DumpType,
			PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,
			PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
			PMINIDUMP_CALLBACK_INFORMATION    CallbackParam
			) = NULL;

		bool load_MiniDumpWriteDump()
		{
			if (_MiniDumpWriteDump != NULL) {
				return true; // already loaded
			}
			HMODULE lib = LoadLibraryA("dbghelp.dll");
			if (!lib) return false;

			FARPROC proc = GetProcAddress(lib, "MiniDumpWriteDump");
			if (!proc) {
				FreeLibrary(lib);
				return false;
			}
			_MiniDumpWriteDump = (BOOL(CALLBACK *)(
				HANDLE,
				DWORD,
				HANDLE,
				MINIDUMP_TYPE,
				PMINIDUMP_EXCEPTION_INFORMATION,
				PMINIDUMP_USER_STREAM_INFORMATION,
				PMINIDUMP_CALLBACK_INFORMATION
				)) proc;

			if (_MiniDumpWriteDump != NULL) {
				return true; // loaded
			}
			return false;
		}

	};
};


bool pesieve::util::make_minidump(DWORD pid, std::string out_file)
{
	if (!load_MiniDumpWriteDump()) return false;

	HANDLE procHndl  = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
	if (procHndl == NULL) {
		DWORD last_err = GetLastError();
		if (last_err == ERROR_ACCESS_DENIED) {
			if (set_debug_privilege()) {
				procHndl = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);
			}
		}
	}
	if (procHndl == NULL) {
		return false;
	}
	HANDLE outFile = CreateFileA(out_file.c_str(), GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (outFile == INVALID_HANDLE_VALUE) {
		CloseHandle(procHndl);
		return false;
	}

	BOOL isDumped = _MiniDumpWriteDump(procHndl, pid, outFile, MiniDumpWithFullMemory, NULL, NULL, NULL);

	CloseHandle(outFile);
	CloseHandle(procHndl);
	return (isDumped) ? true : false;
}

```

`utils/process_minidump.h`:

```h
#pragma once
#include <windows.h>
#include <string>

namespace pesieve {
	namespace util {

		bool make_minidump(DWORD pid, std::string out_file);
	};
};

```

`utils/process_privilege.cpp`:

```cpp
#include "process_privilege.h"
#include "process_util.h"

#include <iostream>

namespace pesieve {
	namespace util {

		inline HMODULE get_or_load_module(char* name)
		{
			HMODULE hndl = GetModuleHandleA(name);
			if (!hndl) {
				hndl = LoadLibraryA(name);
			}
			return hndl;
		}

		/*
		based on: https://support.microsoft.com/en-us/help/131065/how-to-obtain-a-handle-to-any-process-with-sedebugprivilege
		*/
		BOOL set_privilege(
			HANDLE hToken,          // token handle
			LPCTSTR Privilege,      // Privilege to enable/disable
			BOOL bEnablePrivilege   // TRUE to enable.  FALSE to disable
		)
		{
			TOKEN_PRIVILEGES tp;
			LUID luid;
			TOKEN_PRIVILEGES tpPrevious;
			DWORD cbPrevious = sizeof(TOKEN_PRIVILEGES);

			if (!LookupPrivilegeValueA(nullptr, Privilege, &luid)) {
				return FALSE;
			}
			// get current privilege
			tp.PrivilegeCount = 1;
			tp.Privileges[0].Luid = luid;
			tp.Privileges[0].Attributes = 0;

			AdjustTokenPrivileges(
				hToken,
				FALSE,
				&tp,
				sizeof(TOKEN_PRIVILEGES),
				&tpPrevious,
				&cbPrevious
			);

			if (GetLastError() != ERROR_SUCCESS) {
				return FALSE;
			}
			// set privilege based on previous setting
			tpPrevious.PrivilegeCount = 1;
			tpPrevious.Privileges[0].Luid = luid;

			if (bEnablePrivilege) {
				tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
			}
			else {
				tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);
			}

			AdjustTokenPrivileges(
				hToken,
				FALSE,
				&tpPrevious,
				cbPrevious,
				NULL,
				NULL
			);

			if (GetLastError() != ERROR_SUCCESS) {
				return FALSE;
			}
			return TRUE;
		}

		BOOL _get_process_DEP_policy(HANDLE processHandle, DWORD &flags, BOOL &is_permanent)
		{
			//load the function GetProcessDEPPolicy dynamically, to provide backward compatibility with systems that don't have it
			HMODULE kernelLib = get_or_load_module("kernel32.dll");
			if (!kernelLib) return FALSE;

			FARPROC procPtr = GetProcAddress(kernelLib, "GetProcessDEPPolicy");
			if (!procPtr) return FALSE;

			BOOL(WINAPI *_GetProcessDEPPolicy)(HANDLE, LPDWORD, PBOOL) = (BOOL(WINAPI *)(HANDLE, LPDWORD, PBOOL))procPtr;
			return _GetProcessDEPPolicy(processHandle, &flags, &is_permanent);
		}

		DEP_SYSTEM_POLICY_TYPE _get_system_DEP_policy()
		{
			//load the function GetSystemDEPPolicy dynamically, to provide backward compatibility with systems that don't have it
			HMODULE kernelLib = get_or_load_module("kernel32.dll");
			if (!kernelLib) return DEPPolicyAlwaysOff;

			FARPROC procPtr = GetProcAddress(kernelLib, "GetSystemDEPPolicy");
			if (!procPtr) return DEPPolicyAlwaysOff; //in old systems where this function does not exist, DEP is Off

			DEP_SYSTEM_POLICY_TYPE(WINAPI *_GetSystemDEPPolicy)(VOID) = (DEP_SYSTEM_POLICY_TYPE(WINAPI *)(VOID))procPtr;
			return _GetSystemDEPPolicy();
		}

	};
};

bool pesieve::util::set_debug_privilege()
{
	HANDLE hToken;
	if (!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)) {
		if (GetLastError() == ERROR_NO_TOKEN) {
			if (!ImpersonateSelf(SecurityImpersonation)) return false;
			if(!OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, FALSE, &hToken)){
				std::cerr << "Error: cannot open the token" << std::endl;
				return false;
			}
		}
	}
	bool is_ok = false;
	// enable SeDebugPrivilege
	if (set_privilege(hToken, SE_DEBUG_NAME, TRUE)) {
		is_ok = true;
	}
	// close token handle
	CloseHandle(hToken);
	return is_ok;
}

pesieve::util::process_integrity_t translate_integrity_level(TOKEN_MANDATORY_LABEL *pTIL)
{
	DWORD dwIntegrityLevel = *GetSidSubAuthority(pTIL->Label.Sid,
		(DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL->Label.Sid) - 1));

	if (dwIntegrityLevel == SECURITY_MANDATORY_LOW_RID)
	{
		// Low Integrity
		return pesieve::util::INTEGRITY_LOW;
	}
	if (dwIntegrityLevel >= SECURITY_MANDATORY_MEDIUM_RID &&
		dwIntegrityLevel < SECURITY_MANDATORY_HIGH_RID)
	{
		// Medium Integrity
		return pesieve::util::INTEGRITY_MEDIUM;
	}
	if (dwIntegrityLevel >= SECURITY_MANDATORY_HIGH_RID &&
		dwIntegrityLevel < SECURITY_MANDATORY_SYSTEM_RID)
	{
		// High Integrity
		return pesieve::util::INTEGRITY_HIGH;
	}
	if (dwIntegrityLevel >= SECURITY_MANDATORY_SYSTEM_RID)
	{
		// System Integrity
		return pesieve::util::INTEGRITY_SYSTEM;
	}
	return pesieve::util::INTEGRITY_UNKNOWN;
}

pesieve::util::process_integrity_t pesieve::util::get_integrity_level(HANDLE hProcess)
{
	if (!hProcess) {
		return INTEGRITY_UNKNOWN;
	}

	HANDLE hToken = NULL;
	if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
		//std::cerr << "[-][Cannot Open the ProcessToken" << std::endl;
		return INTEGRITY_UNKNOWN;
	}
	DWORD dwLength = sizeof(TOKEN_GROUPS);
	TOKEN_MANDATORY_LABEL *ptg = (TOKEN_MANDATORY_LABEL*) calloc(1, dwLength);

	if (!GetTokenInformation(
		hToken,         // handle to the access token
		TokenIntegrityLevel,    // get information about the token's groups 
		(LPVOID)ptg,   // pointer to TOKEN_MANDATORY_LABEL buffer
		0,              // size of buffer
		&dwLength       // receives required buffer size
	))
	{
		free(ptg); ptg = nullptr;
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
			CloseHandle(hToken);
			return INTEGRITY_UNKNOWN;
		}
		ptg = (TOKEN_MANDATORY_LABEL*)calloc(1, dwLength);
		if (!ptg) {
			//failed allocating
			CloseHandle(hToken);
			return INTEGRITY_UNKNOWN;
		}
	}
	process_integrity_t level = INTEGRITY_UNKNOWN;
	if (GetTokenInformation(
		hToken,         // handle to the access token
		TokenIntegrityLevel,    // get information about the token's groups 
		(LPVOID)ptg,   // pointer to TOKEN_MANDATORY_LABEL buffer
		dwLength,       // size of buffer
		&dwLength       // receives required buffer size
	))
	{
		level = translate_integrity_level(ptg);
	}
	//cleanup:
	free(ptg); ptg = nullptr;
	CloseHandle(hToken);
	return level;
}

bool pesieve::util::is_DEP_enabled(HANDLE processHandle)
{
	DEP_SYSTEM_POLICY_TYPE global_dep = _get_system_DEP_policy();
	if (global_dep == DEPPolicyAlwaysOff) {
		return false;
	}
	if (global_dep == DEPPolicyAlwaysOn) {
		return true;
	}
	// 
	DWORD flags = 0;
	BOOL is_permanent = FALSE;
	BOOL is_ok = _get_process_DEP_policy(processHandle, flags, is_permanent);
	if (!is_ok) {
#ifdef _WIN64
		BOOL isRemoteWow64 = FALSE;
		is_process_wow64(processHandle, &isRemoteWow64);
		if (!isRemoteWow64) {
			return true; // it is a 64 bit process, DEP is enabled
		}
#endif
#ifdef _DEBUG
		std::cerr << "Could not fetch the DEP status\n";
#endif
		return false;
	}
	const bool is_DEP = (flags & PROCESS_DEP_ENABLE) || (flags & PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION);
	return is_DEP;
}

```

`utils/process_privilege.h`:

```h
#pragma once

#include <windows.h>

namespace pesieve {
	namespace util {

		typedef enum {
			INTEGRITY_UNKNOWN = -1,
			INTEGRITY_LOW = 0,
			INTEGRITY_MEDIUM, //1
			INTEGRITY_HIGH, //2
			INTEGRITY_SYSTEM //3
		} process_integrity_t;

		bool set_debug_privilege();

		process_integrity_t get_integrity_level(HANDLE hProcess);

		bool is_DEP_enabled(HANDLE hProcess);
	};
};

```

`utils/process_reflection.cpp`:

```cpp
#include "process_reflection.h"
#include <iostream>

#ifndef RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED
#define RTL_CLONE_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#endif

#ifndef RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES
#define RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES 0x00000002
#endif

#ifndef RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE
#define RTL_CLONE_PROCESS_FLAGS_NO_SYNCHRONIZE 0x00000004 // don't update synchronization objects
#endif

#ifndef HPSS
#define HPSS HANDLE
#endif

namespace pesieve {
	namespace util {

		typedef struct {
			HANDLE VaCloneHandle;
		} PSS_VA_CLONE_INFORMATION;

		typedef struct  {
			HANDLE UniqueProcess;
			HANDLE UniqueThread;
		} T_CLIENT_ID;

		typedef struct
		{
			HANDLE ReflectionProcessHandle;
			HANDLE ReflectionThreadHandle;
			T_CLIENT_ID ReflectionClientId;
		} T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;

		// Win >= 7
		NTSTATUS (NTAPI *_RtlCreateProcessReflection) (
			HANDLE ProcessHandle,
			ULONG Flags,
			PVOID StartRoutine,
			PVOID StartContext,
			HANDLE EventHandle,
			T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION* ReflectionInformation
		) = NULL;

		// Win >= 8.1

		typedef enum
		{
			PSS_CAPTURE_NONE = 0x00000000,
			PSS_CAPTURE_VA_CLONE = 0x00000001,
			PSS_CAPTURE_RESERVED_00000002 = 0x00000002,
			PSS_CAPTURE_HANDLES = 0x00000004,
			PSS_CAPTURE_HANDLE_NAME_INFORMATION = 0x00000008,
			PSS_CAPTURE_HANDLE_BASIC_INFORMATION = 0x00000010,
			PSS_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION = 0x00000020,
			PSS_CAPTURE_HANDLE_TRACE = 0x00000040,
			PSS_CAPTURE_THREADS = 0x00000080,
			PSS_CAPTURE_THREAD_CONTEXT = 0x00000100,
			PSS_CAPTURE_THREAD_CONTEXT_EXTENDED = 0x00000200,
			PSS_CAPTURE_RESERVED_00000400 = 0x00000400,
			PSS_CAPTURE_VA_SPACE = 0x00000800,
			PSS_CAPTURE_VA_SPACE_SECTION_INFORMATION = 0x00001000,
			PSS_CAPTURE_IPT_TRACE = 0x00002000,

			PSS_CREATE_BREAKAWAY_OPTIONAL = 0x04000000,
			PSS_CREATE_BREAKAWAY = 0x08000000,
			PSS_CREATE_FORCE_BREAKAWAY = 0x10000000,
			PSS_CREATE_USE_VM_ALLOCATIONS = 0x20000000,
			PSS_CREATE_MEASURE_PERFORMANCE = 0x40000000,
			PSS_CREATE_RELEASE_SECTION = 0x80000000
		} PSS_CAPTURE_FLAGS;

		typedef enum
		{
			PSS_QUERY_PROCESS_INFORMATION = 0,
			PSS_QUERY_VA_CLONE_INFORMATION = 1,
			PSS_QUERY_AUXILIARY_PAGES_INFORMATION = 2,
			PSS_QUERY_VA_SPACE_INFORMATION = 3,
			PSS_QUERY_HANDLE_INFORMATION = 4,
			PSS_QUERY_THREAD_INFORMATION = 5,
			PSS_QUERY_HANDLE_TRACE_INFORMATION = 6,
			PSS_QUERY_PERFORMANCE_COUNTERS = 7
		} PSS_QUERY_INFORMATION_CLASS;

		DWORD (__stdcall *_PssCaptureSnapshot)( //from Kernel32.dll
			HANDLE            ProcessHandle,
			PSS_CAPTURE_FLAGS CaptureFlags,
			DWORD             ThreadContextFlags,
			HPSS              *SnapshotHandle
			) = NULL;

		DWORD (__stdcall *_PssFreeSnapshot)(
			HANDLE ProcessHandle,
			HPSS   SnapshotHandle
			) = NULL;

		DWORD (__stdcall *_PssQuerySnapshot)(
				HPSS SnapshotHandle,
				PSS_QUERY_INFORMATION_CLASS InformationClass,
				void* Buffer,
				DWORD BufferLength
			) = NULL;

		bool load_PssCaptureFreeSnapshot()
		{
			if (_PssCaptureSnapshot == NULL || _PssFreeSnapshot == NULL || _PssQuerySnapshot == NULL) {
				HMODULE lib = LoadLibraryA("kernel32.dll");
				if (!lib) return false;

				FARPROC proc1 = GetProcAddress(lib, "PssCaptureSnapshot");
				if (!proc1) return false;

				FARPROC proc2 = GetProcAddress(lib, "PssFreeSnapshot");
				if (!proc2) return false;

				FARPROC proc3 = GetProcAddress(lib, "PssQuerySnapshot");
				if (!proc3) return false;

				_PssCaptureSnapshot = (DWORD(__stdcall *)(
					HANDLE,
					PSS_CAPTURE_FLAGS,
					DWORD,
					HPSS*
					)) proc1;

				_PssFreeSnapshot = (DWORD(__stdcall *)(
					HANDLE,
					HPSS
					)) proc2;

				_PssQuerySnapshot = (DWORD(__stdcall *)(
					HPSS,
					PSS_QUERY_INFORMATION_CLASS,
					void*,
					DWORD
					)) proc3;
			}
			if (_PssCaptureSnapshot == NULL || _PssFreeSnapshot == NULL || _PssQuerySnapshot == NULL) {
				return false;
			}
			return true;
		}

		bool load_RtlCreateProcessReflection()
		{
			if (_RtlCreateProcessReflection == NULL) {
				HMODULE lib = LoadLibraryA("ntdll.dll");
				if (!lib) return false;

				FARPROC proc = GetProcAddress(lib, "RtlCreateProcessReflection");
				if (!proc) return false;

				_RtlCreateProcessReflection = (NTSTATUS(NTAPI *) (
					HANDLE,
					ULONG,
					PVOID,
					PVOID,
					HANDLE,
					T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION*
				)) proc;

			}
			if (_RtlCreateProcessReflection == NULL) return false;
			return true;
		}

		typedef struct {
			HANDLE orig_hndl;
			HANDLE returned_hndl;
			DWORD returned_pid;
			bool is_ok;
		} t_refl_args;

		DWORD WINAPI refl_creator(LPVOID lpParam)
		{
			t_refl_args *args = static_cast<t_refl_args*>(lpParam);
			if (!args) {
				return !S_OK;
			}
			args->is_ok = false;

			T_RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION info = { 0 };
			NTSTATUS ret = _RtlCreateProcessReflection(args->orig_hndl, RTL_CLONE_PROCESS_FLAGS_INHERIT_HANDLES, NULL, NULL, NULL, &info);
			if (ret == S_OK) {
				args->is_ok = true;
				args->returned_hndl = info.ReflectionProcessHandle;
				args->returned_pid = (DWORD)info.ReflectionClientId.UniqueProcess;
			}
			return ret;
		}

		HANDLE make_process_reflection1(HANDLE orig_hndl)
		{
			const DWORD max_wait = 1000;
			if (!load_RtlCreateProcessReflection()) {
				return NULL;
			}

			t_refl_args args = { 0 };
			args.orig_hndl = orig_hndl;

			HANDLE hThead = CreateThread(
				NULL,                   // default security attributes
				0,                      // use default stack size  
				refl_creator,       // thread function name
				&args,          // argument to thread function 
				0,                      // use default creation flags 
				0);   // returns the thread identifier 

			DWORD wait_result = WaitForSingleObject(hThead, max_wait);
			if (wait_result == WAIT_TIMEOUT) {
				std::cerr << "[!] [" << GetProcessId(orig_hndl) << "] Cannot create reflection: timeout passed!\n";
				TerminateThread(hThead, 0);
				CloseHandle(hThead);
				return NULL;
			}
			CloseHandle(hThead);
			if (args.is_ok) {
				if (args.returned_hndl == NULL || args.returned_hndl == INVALID_HANDLE_VALUE) {
					return NULL;
				}
#ifdef _DEBUG
				std::cout << "Created reflection, PID = " << std::dec << args.returned_pid << "\n";
#endif
				return args.returned_hndl;
			}
			return NULL;
		}

		HPSS make_process_snapshot(HANDLE orig_hndl)
		{
			if (!load_PssCaptureFreeSnapshot()) {
				return NULL;
			}
			pesieve::util::PSS_CAPTURE_FLAGS capture_flags = (pesieve::util::PSS_CAPTURE_FLAGS) (PSS_CAPTURE_VA_CLONE
				| PSS_CAPTURE_HANDLES
				| PSS_CAPTURE_HANDLE_NAME_INFORMATION
				| PSS_CAPTURE_HANDLE_BASIC_INFORMATION
				| PSS_CAPTURE_HANDLE_TYPE_SPECIFIC_INFORMATION
				//| PSS_CAPTURE_HANDLE_TRACE
				| PSS_CAPTURE_THREADS
				//| PSS_CAPTURE_THREAD_CONTEXT
				//| PSS_CAPTURE_THREAD_CONTEXT_EXTENDED
				| PSS_CAPTURE_VA_SPACE
				| PSS_CAPTURE_VA_SPACE_SECTION_INFORMATION
				| PSS_CREATE_BREAKAWAY
				//| PSS_CREATE_BREAKAWAY_OPTIONAL
				| PSS_CREATE_USE_VM_ALLOCATIONS
				//| PSS_CREATE_RELEASE_SECTION
				);

			HPSS snapShot = { 0 };
			DWORD ret = _PssCaptureSnapshot(orig_hndl, capture_flags, 0, &snapShot);
			if (ret != ERROR_SUCCESS) {
#ifdef _DEBUG
				std::cout << "PssCaptureSnapshot failed: " << std::hex << " ret: " << ret << " err: " << GetLastError() << "\n";
#endif
				return NULL;
			}
			return snapShot;
		}

		bool release_process_snapshot(HANDLE procHndl, HPSS snapshot)
		{
			if (procHndl && snapshot) {
				BOOL is_ok = _PssFreeSnapshot(procHndl, snapshot);
#ifdef _DEBUG
				if (is_ok) std::cout << "Released process snapshot\n";
#endif
				return is_ok ? true : false;
			}
			return false;
		}

		HANDLE make_process_reflection2(HPSS snapshot)
		{
			PSS_VA_CLONE_INFORMATION info = { 0 };
			DWORD ret = _PssQuerySnapshot(snapshot, PSS_QUERY_VA_CLONE_INFORMATION, &info, sizeof(info));
			if (ret != ERROR_SUCCESS) {
				return NULL;
			}
			HANDLE clone = info.VaCloneHandle;
#ifdef _DEBUG
			DWORD clone_pid = GetProcessId(clone);
			std::cout << "Clone PID = " << std::dec << clone_pid << "\n";
#endif
			return clone;
		}

	};
};

bool pesieve::util::can_make_process_reflection()
{
#ifdef USE_PROCESS_SNAPSHOT
	if (load_PssCaptureFreeSnapshot()) {
		return true;
	}
#endif
#ifdef USE_RTL_PROCESS_REFLECTION
	if (load_RtlCreateProcessReflection()) {
		return true;
	}
#endif
	return false;
}

HANDLE pesieve::util::make_process_reflection(HANDLE orig_hndl)
{
	if (orig_hndl == NULL) {
		return NULL;
	}
	HANDLE clone = NULL;
#ifdef USE_PROCESS_SNAPSHOT
	if (load_PssCaptureFreeSnapshot()) {
		HPSS snapshot = make_process_snapshot(orig_hndl);
		clone = make_process_reflection2(snapshot);
		release_process_snapshot(orig_hndl, snapshot);
		if (clone) {
			return clone;
		}
	}
#endif
#ifdef USE_RTL_PROCESS_REFLECTION
	if (load_RtlCreateProcessReflection()) {
		clone = make_process_reflection1(orig_hndl);
	}
#endif
	return clone;
}

bool pesieve::util::release_process_reflection(HANDLE* procHndl)
{
	if (procHndl == NULL || *procHndl == NULL) {
		return false;
	}
#ifdef _DEBUG
	DWORD clone_pid = GetProcessId(*procHndl);
	std::cout << "Releasing Clone, PID = " << std::dec << clone_pid << "\n";
#endif
	BOOL is_ok = TerminateProcess(*procHndl, 0);
	CloseHandle(*procHndl);
	*procHndl = NULL;

#ifdef _DEBUG
	std::cout << "Released process reflection\n";
#endif
	return is_ok ? true : false;
}

```

`utils/process_reflection.h`:

```h
#pragma once

#include <windows.h>

#define USE_PROCESS_SNAPSHOT
#define USE_RTL_PROCESS_REFLECTION

namespace pesieve {
	namespace util {

		// required by RtlCreateProcessReflection:
		const DWORD reflection_access1 = PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_DUP_HANDLE;

		// required by PssCaptureSnapshot:
		const DWORD reflection_access2 = PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_DUP_HANDLE | PROCESS_CREATE_PROCESS;

#ifdef USE_PROCESS_SNAPSHOT
		const DWORD reflection_access = reflection_access2;
#else
		const DWORD reflection_access = reflection_access1;
#endif

		bool can_make_process_reflection();
		HANDLE make_process_reflection(HANDLE orig_hndl);
		bool release_process_reflection(HANDLE* reflection_hndl);

	};
};

```

`utils/process_util.cpp`:

```cpp
#include "process_util.h"
#include <iostream>

namespace pesieve {
	namespace util {
		HMODULE g_kernel32Hndl = nullptr;

		BOOL(WINAPI *g_IsWow64Process)(IN HANDLE, OUT PBOOL) = nullptr;
		BOOL(WINAPI *g_Wow64DisableWow64FsRedirection) (OUT PVOID* OldValue) = nullptr;
		BOOL(WINAPI *g_Wow64RevertWow64FsRedirection) (IN PVOID OldValue) = nullptr;

		HMODULE get_kernel32_hndl()
		{
			if (g_kernel32Hndl == nullptr) {
				g_kernel32Hndl = LoadLibraryA("kernel32.dll");
			}
			return g_kernel32Hndl;
		}
	};
};

BOOL pesieve::util::is_process_wow64(IN HANDLE processHandle, OUT BOOL* isProcWow64)
{
	if (isProcWow64) {
		(*isProcWow64) = FALSE; //set default output value: FALSE
	}
	if (!g_IsWow64Process) {
		HMODULE kernelLib = get_kernel32_hndl();
		if (!kernelLib) return FALSE;

		FARPROC procPtr = GetProcAddress(kernelLib, "IsWow64Process");
		if (!procPtr) return FALSE;

		g_IsWow64Process = (BOOL(WINAPI *)(IN HANDLE, OUT PBOOL))procPtr;
	}
	if (!g_IsWow64Process) {
		return FALSE;
	}
	return g_IsWow64Process(processHandle, isProcWow64);
}

bool pesieve::util::is_process_64bit(IN HANDLE process)
{
	BOOL isScanner32bit = TRUE;
#ifdef _WIN64 //is the scanner 64 bit?
	isScanner32bit = FALSE;
#endif
	BOOL isScannerWow64 = FALSE;
	pesieve::util::is_process_wow64(GetCurrentProcess(), &isScannerWow64);

	const BOOL isSystem64bit = !isScanner32bit || isScannerWow64;
	if (!isSystem64bit) {
		//the system is not 64 bit, so for sure the app is 32 bit
		return false; 
	}

	BOOL isProcessWow = FALSE;
	pesieve::util::is_process_wow64(process, &isProcessWow);

	if (isProcessWow) {
		// the system is 64 bit, and the process runs as Wow64, so it is 32 bit
		return false;
	}
	// the system is 64 bit, and the process runs NOT as Wow64, so it is 64 bit
	return true;
}

BOOL pesieve::util::wow64_disable_fs_redirection(OUT PVOID* OldValue)
{
	if (!g_Wow64DisableWow64FsRedirection) {
		HMODULE kernelLib = get_kernel32_hndl();
		if (!kernelLib) return FALSE;

		FARPROC procPtr = GetProcAddress(kernelLib, "Wow64DisableWow64FsRedirection");
		if (!procPtr) return FALSE;

		g_Wow64DisableWow64FsRedirection = (BOOL(WINAPI *) (OUT PVOID*))procPtr;
	}
	if (!g_Wow64DisableWow64FsRedirection) {
		return FALSE;
	}
	return g_Wow64DisableWow64FsRedirection(OldValue);
}

BOOL pesieve::util::wow64_revert_fs_redirection(IN PVOID OldValue)
{
	if (!g_Wow64RevertWow64FsRedirection) {
		HMODULE kernelLib = get_kernel32_hndl();
		if (!kernelLib) return FALSE;

		FARPROC procPtr = GetProcAddress(kernelLib, "Wow64RevertWow64FsRedirection");
		if (!procPtr) return FALSE;

		g_Wow64RevertWow64FsRedirection = (BOOL(WINAPI *) (IN PVOID))procPtr;
	}
	if (!g_Wow64RevertWow64FsRedirection) {
		return FALSE;
	}
	return g_Wow64RevertWow64FsRedirection(OldValue);
}

```

`utils/process_util.h`:

```h
#pragma once

#include <windows.h>

namespace pesieve {
	namespace util {

		BOOL is_process_wow64(IN HANDLE processHandle, OUT BOOL* isProcWow64);
		bool is_process_64bit(IN HANDLE process);

		BOOL wow64_disable_fs_redirection(OUT PVOID* OldValue);
		BOOL wow64_revert_fs_redirection(IN PVOID  OldValue);
	};
};

```

`utils/strings_util.cpp`:

```cpp
#include "strings_util.h"

#include <algorithm>
#include <cstring>

std::string pesieve::util::to_lowercase(std::string str)
{
	std::transform(str.begin(), str.end(), str.begin(), tolower);
	return str;
}

bool pesieve::util::is_cstr_equal(char const *a, char const *b, const size_t max_len)
{
	for (size_t i = 0; i < max_len; ++i) {
		if (tolower(a[i]) != tolower(b[i])) {
			return false;
		}
		if (tolower(a[i]) == '\0') break;
	}
	return true;
}

```

`utils/strings_util.h`:

```h
#pragma once

#include <string>

namespace pesieve {

	namespace util {

		std::string to_lowercase(std::string);

		// Compare cstrings (ignore case)
		bool is_cstr_equal(char const *a, char const *b, const size_t max_len);

	};
};

```

`utils/threads_util.cpp`:

```cpp
#include "threads_util.h"

#include <peconv.h>
#include <tlhelp32.h>
#include "../utils/ntddk.h"

#ifdef _DEBUG
#include <iostream>
#endif

bool pesieve::util::fetch_threads_info(DWORD pid, std::vector<thread_info>& threads_info)
{
	BYTE* buffer = nullptr;
	ULONG buffer_size = 0;
	ULONG ret_len = 0;

	NTSTATUS status = STATUS_UNSUCCESSFUL;
	while (status != STATUS_SUCCESS) {
		status = NtQuerySystemInformation(SystemProcessInformation, buffer, buffer_size, &ret_len);
		if (status == STATUS_INFO_LENGTH_MISMATCH) {
			free(buffer);
			buffer = nullptr;
			buffer_size = 0;
			buffer = (BYTE*)calloc(ret_len, 1);
			if (!buffer) {
				return false;
			}
			buffer_size = ret_len;
			continue; // try again
		}
		break; //other error, or success
	};

	if (status != STATUS_SUCCESS) {
		free(buffer);
		return false;
	}

	bool found = false;
	SYSTEM_PROCESS_INFORMATION* info = (SYSTEM_PROCESS_INFORMATION*)buffer;
	while (info) {
		if (info->UniqueProcessId == pid) {
			found = true;
			break;
		}
		if (!info->NextEntryOffset) {
			break;
		}
		size_t record_size = info->NextEntryOffset;
		if (record_size < sizeof(SYSTEM_PROCESS_INFORMATION)) {
			// Record size smaller than expected, probably it is an old system that doesn not support the new version of this API
#ifdef _DEBUG
			std::cout << "The new version of SYSTEM_PROCESS_INFORMATION is not supported!\n";
#endif
			break;
		}
		info = (SYSTEM_PROCESS_INFORMATION*)((ULONG_PTR)info + info->NextEntryOffset);
		if (!peconv::validate_ptr(buffer, buffer_size, info, sizeof(SYSTEM_PROCESS_INFORMATION))) {
			break;
		}
	}

	if (!found) {
		free(buffer);
		return false;
	}

	size_t thread_count = info->NumberOfThreads;
	for (size_t i = 0; i < thread_count; i++) {
		thread_info threadi;

		threadi.tid = MASK_TO_DWORD((ULONGLONG)info->Threads[i].ClientId.UniqueThread);
		threadi.is_extended = true;
		threadi.ext.start_addr = (ULONG_PTR)info->Threads[i].StartAddress;
		threadi.ext.state = info->Threads[i].ThreadState;
		threadi.ext.wait_reason = info->Threads[i].WaitReason;
		threadi.ext.wait_time  = info->Threads[i].WaitTime;
		threads_info.push_back(threadi);
	}

	free(buffer);
	return true;
}

bool pesieve::util::fetch_threads_by_snapshot(DWORD pid, std::vector<thread_info>& threads_info)
{
	HANDLE hThreadSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnapShot == INVALID_HANDLE_VALUE) {
		const DWORD err = GetLastError();
#ifdef _DEBUG
		std::cerr << "[-] Could not create threads snapshot. Error: " << std::dec << err << std::endl;
#endif
		return false;
	}
	THREADENTRY32 th32 = { 0 };
	th32.dwSize = sizeof(THREADENTRY32);

	//check all threads in the process:
	if (!Thread32First(hThreadSnapShot, &th32)) {
		CloseHandle(hThreadSnapShot);
#ifdef _DEBUG
		std::cerr << "[-] Could not enumerate thread. Error: " << GetLastError() << std::endl;
#endif
		return false;
	}
	do {
		if (th32.th32OwnerProcessID != pid) {
			continue;
		}

		thread_info threadi;
		threadi.tid = th32.th32ThreadID;
		threadi.is_extended = false;
		threads_info.push_back(threadi);

	} while (Thread32Next(hThreadSnapShot, &th32));

	CloseHandle(hThreadSnapShot);
	return true;
}

```

`utils/threads_util.h`:

```h
#pragma once

#include <windows.h>
#include <vector>

namespace pesieve {
	namespace util {

		typedef struct _thread_info_ext
		{
			ULONGLONG start_addr;
			DWORD state;
			DWORD wait_reason;
			DWORD wait_time;

			_thread_info_ext()
			{
				this->start_addr = 0;
				this->state = 0;
				this->wait_reason = 0;
				this->wait_time = 0;
			}

			_thread_info_ext(const _thread_info_ext& other)
			{
				this->start_addr = other.start_addr;
				this->state = other.state;
				this->wait_reason = other.wait_reason;
				this->wait_time = other.wait_time;
			}

		} thread_info_ext;

		typedef struct _thread_info
		{
			DWORD tid;
			bool is_extended;
			thread_info_ext ext;

			_thread_info()
			{
				this->tid = 0;
				this->is_extended = false;
			}
			
			_thread_info(const _thread_info& other)
			{
				this->tid = other.tid;
				this->is_extended = other.is_extended;
				this->ext = other.ext;
			}

		} thread_info;

		bool fetch_threads_info(DWORD pid, std::vector<thread_info>& threads_info);

		bool fetch_threads_by_snapshot(DWORD pid, std::vector<thread_info>& threads_info);

	}; // namespace util
}; // namespace pesieve

```

`utils/workingset_enum.cpp`:

```cpp
#include "workingset_enum.h"

#include <iostream>

#include <psapi.h>
#pragma comment(lib,"psapi.lib")

#ifdef _WIN64
	const ULONGLONG mask = ULONGLONG(-1);
#else
	const ULONGLONG mask = DWORD(-1);
#endif

namespace pesieve {
	namespace util {

		bool get_next_commited_region(HANDLE processHandle, ULONGLONG start_va, MEMORY_BASIC_INFORMATION &page_info)
		{
			const SIZE_T page_info_size = sizeof(MEMORY_BASIC_INFORMATION);

			while (start_va < mask) {
				//std::cout << "Checking: " << std::hex << start_va << std::endl;
				memset(&page_info, 0, page_info_size);
				const SIZE_T out = VirtualQueryEx(processHandle, (LPCVOID)start_va, &page_info, page_info_size);
				const bool is_read = (out == page_info_size) ? true : false;
				const DWORD error = is_read ? ERROR_SUCCESS : GetLastError();
				if (error == ERROR_INVALID_PARAMETER) {
					//nothing more to read
#ifdef _DEBUG
					std::cout << "Nothing more to read: " << std::hex << start_va << std::endl;
#endif
					break;
				}
				if (error == ERROR_ACCESS_DENIED) {
					std::cerr << "[ERROR] Cannot query the memory region. " << std::hex << start_va << " Error: " << std::dec << error << std::endl;
					break;
				}
				if (!is_read) {
					// on any other error:
					std::cerr << "[WARNING] Cannot query the memory region. " << std::hex<< start_va << " Error: " << std::dec << error << ", skipping the page..." << std::endl;
					start_va += PAGE_SIZE;
					continue;
				}
				if ((page_info.State & MEM_FREE) || (page_info.State & MEM_COMMIT) == 0) {
					if (page_info.RegionSize != 0) {
						//std::cout << "Free:  " << std::hex << start_va << " RegionSize:" << page_info.RegionSize << std::endl;
						start_va += page_info.RegionSize;
						continue;
					}
				}
				if (page_info.RegionSize == 0) {
					start_va += PAGE_SIZE;
					continue;
				}
				//std::cout << "Commited:  " << std::hex << start_va << " RegionSize: " << page_info.RegionSize << " Err: " << std::dec << error << std::endl;
				return true;
			}
			return false;
		}

	};
};

size_t pesieve::util::enum_workingset(HANDLE processHandle, std::set<ULONGLONG> &region_bases)
{
	region_bases.clear();

	MEMORY_BASIC_INFORMATION page_info = { 0 };
	ULONGLONG next_va = 0;
	while (get_next_commited_region(processHandle, next_va, page_info))
	{
		ULONGLONG base = (ULONGLONG)page_info.BaseAddress;
		next_va = base + page_info.RegionSize; //end of the region
		if (region_bases.find(base) != region_bases.end()) {
			// don't let it stuck on adding the same region over and over again
			break;
		}
		region_bases.insert(base);
	}
	return region_bases.size();
}

DWORD pesieve::util::count_workingset_entries(HANDLE processHandle)
{
	DWORD number_of_entries = 1;
	DWORD buffer_size = sizeof(PSAPI_WORKING_SET_INFORMATION) + (number_of_entries * sizeof(PSAPI_WORKING_SET_BLOCK));
	PSAPI_WORKING_SET_INFORMATION* buffer = reinterpret_cast<PSAPI_WORKING_SET_INFORMATION*>(calloc(1, buffer_size));
	if (!buffer) {
		return 0; //this should not happen
	}
	DWORD res = QueryWorkingSet(processHandle, buffer, buffer_size);
	if (res == FALSE && GetLastError() == ERROR_BAD_LENGTH) {
		// ERROR_BAD_LENGTH is normal: we didn't provide the buffer that could fit all the entries
		res = TRUE;
	}
	number_of_entries = static_cast<DWORD>(buffer->NumberOfEntries);
	free(buffer); buffer = NULL;

	if (!res) {
		return 0;
	}
#ifdef _DEBUG
	std::cout << "Number of entries: " << std::dec << number_of_entries << std::endl;
#endif
	return number_of_entries;
}

```

`utils/workingset_enum.h`:

```h
#pragma once

#include <windows.h>
#include <set>

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif

namespace pesieve {
	namespace util {
		size_t enum_workingset(HANDLE processHandle, std::set<ULONGLONG> &region_bases);

		DWORD count_workingset_entries(HANDLE processHandle);
	};
};

```